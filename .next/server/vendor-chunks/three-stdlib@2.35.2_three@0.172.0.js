"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-stdlib@2.35.2_three@0.172.0";
exports.ids = ["vendor-chunks/three-stdlib@2.35.2_three@0.172.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/_polyfill/LoaderUtils.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/_polyfill/LoaderUtils.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeText: () => (/* binding */ decodeText)\n/* harmony export */ });\nfunction decodeText(array) {\n  if (typeof TextDecoder !== \"undefined\") {\n    return new TextDecoder().decode(array);\n  }\n  let s = \"\";\n  for (let i = 0, il = array.length; i < il; i++) {\n    s += String.fromCharCode(array[i]);\n  }\n  try {\n    return decodeURIComponent(escape(s));\n  } catch (e) {\n    return s;\n  }\n}\n\n//# sourceMappingURL=LoaderUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdGhyZWUtc3RkbGliQDIuMzUuMl90aHJlZUAwLjE3Mi4wL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvX3BvbHlmaWxsL0xvYWRlclV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2plcmVteWovRG9jdW1lbnRzL3NvdXJjZS9yZXBvcy9zaGFkZXJzL25vZGVfbW9kdWxlcy8ucG5wbS90aHJlZS1zdGRsaWJAMi4zNS4yX3RocmVlQDAuMTcyLjAvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9fcG9seWZpbGwvTG9hZGVyVXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZGVjb2RlVGV4dChhcnJheSkge1xuICBpZiAodHlwZW9mIFRleHREZWNvZGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShhcnJheSk7XG4gIH1cbiAgbGV0IHMgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHMpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5leHBvcnQge1xuICBkZWNvZGVUZXh0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9hZGVyVXRpbHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/_polyfill/LoaderUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/_polyfill/constants.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/_polyfill/constants.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/.pnpm/three@0.172.0/node_modules/three/build/three.core.js\");\n\nconst version = parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"));\n\n//# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdGhyZWUtc3RkbGliQDIuMzUuMl90aHJlZUAwLjE3Mi4wL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvX3BvbHlmaWxsL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpQztBQUNqQyx5QkFBeUIsMkNBQVE7QUFHL0I7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2plcmVteWovRG9jdW1lbnRzL3NvdXJjZS9yZXBvcy9zaGFkZXJzL25vZGVfbW9kdWxlcy8ucG5wbS90aHJlZS1zdGRsaWJAMi4zNS4yX3RocmVlQDAuMTcyLjAvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9fcG9seWZpbGwvY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJFVklTSU9OIH0gZnJvbSBcInRocmVlXCI7XG5jb25zdCB2ZXJzaW9uID0gcGFyc2VJbnQoUkVWSVNJT04ucmVwbGFjZSgvXFxEKy9nLCBcIlwiKSk7XG5leHBvcnQge1xuICB2ZXJzaW9uXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/_polyfill/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/loaders/DRACOLoader.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/loaders/DRACOLoader.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DRACOLoader: () => (/* binding */ DRACOLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/.pnpm/three@0.172.0/node_modules/three/build/three.core.js\");\n\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nclass DRACOLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = \"\";\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = \"\";\n    this.defaultAttributeIDs = {\n      position: \"POSITION\",\n      normal: \"NORMAL\",\n      color: \"COLOR\",\n      uv: \"TEX_COORD\"\n    };\n    this.defaultAttributeTypes = {\n      position: \"Float32Array\",\n      normal: \"Float32Array\",\n      color: \"Float32Array\",\n      uv: \"Float32Array\"\n    };\n  }\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false\n        };\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n      },\n      onProgress,\n      onError\n    );\n  }\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n  decodeGeometry(buffer, taskConfig) {\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n      if (type.BYTES_PER_ELEMENT !== void 0) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    }\n    const taskKey = JSON.stringify(taskConfig);\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        throw new Error(\n          \"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\"\n        );\n      }\n    }\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength;\n    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = { resolve, reject };\n        worker.postMessage({ type: \"decode\", id: taskID, taskConfig, buffer }, [buffer]);\n      });\n    }).then((message) => this._createGeometry(message.geometry));\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID);\n      }\n    });\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n    return geometryPending;\n  }\n  _createGeometry(geometryData) {\n    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n    if (geometryData.index) {\n      geometry.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(geometryData.index.array, 1));\n    }\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize));\n    }\n    return geometry;\n  }\n  _loadLibrary(url, responseType) {\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, void 0, reject);\n    });\n  }\n  preload() {\n    this._initDecoder();\n    return this;\n  }\n  _initDecoder() {\n    if (this.decoderPending)\n      return this.decoderPending;\n    const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n    const librariesPending = [];\n    if (useJS) {\n      librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n    } else {\n      librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n      librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n    }\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0];\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n      const fn = DRACOWorker.toString();\n      const body = [\n        \"/* draco decoder */\",\n        jsContent,\n        \"\",\n        \"/* worker */\",\n        fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n      ].join(\"\\n\");\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker2 = new Worker(this.workerSourceURL);\n        worker2._callbacks = {};\n        worker2._taskCosts = {};\n        worker2._taskLoad = 0;\n        worker2.postMessage({ type: \"init\", decoderConfig: this.decoderConfig });\n        worker2.onmessage = function(e) {\n          const message = e.data;\n          switch (message.type) {\n            case \"decode\":\n              worker2._callbacks[message.id].resolve(message);\n              break;\n            case \"error\":\n              worker2._callbacks[message.id].reject(message);\n              break;\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n        this.workerPool.push(worker2);\n      } else {\n        this.workerPool.sort(function(a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n  debug() {\n    console.log(\n      \"Task load: \",\n      this.workerPool.map((worker) => worker._taskLoad)\n    );\n  }\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n    this.workerPool.length = 0;\n    return this;\n  }\n}\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n  onmessage = function(e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function(resolve) {\n          decoderConfig.onModuleLoaded = function(draco) {\n            resolve({ draco });\n          };\n          DracoDecoderModule(decoderConfig);\n        });\n        break;\n      case \"decode\":\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then((module) => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer);\n            if (geometry.index)\n              buffers.push(geometry.index.array.buffer);\n            self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({ type: \"error\", id: message.id, error: error.message });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n    }\n    const geometry = { index: null, attributes: [] };\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID;\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1)\n          continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    }\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n    const ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n    draco._free(ptr);\n    return { array: index, itemSize: 1 };\n  }\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n    const ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n    draco._free(ptr);\n    return {\n      name: attributeName,\n      array,\n      itemSize: numComponents\n    };\n  }\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\n\n//# sourceMappingURL=DRACOLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdGhyZWUtc3RkbGliQDIuMzUuMl90aHJlZUAwLjE3Mi4wL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbG9hZGVycy9EUkFDT0xvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE0RTtBQUM1RTtBQUNBLDBCQUEwQix5Q0FBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkNBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qyw2QkFBNkIsZ0RBQWdEO0FBQzdFLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpREFBYztBQUN2QztBQUNBLDRCQUE0QixrREFBZTtBQUMzQztBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0RBQWU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkNBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaURBQWlEO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwQ0FBMEM7QUFDekUsWUFBWTtBQUNaO0FBQ0EsK0JBQStCLHFEQUFxRDtBQUNwRixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qZXJlbXlqL0RvY3VtZW50cy9zb3VyY2UvcmVwb3Mvc2hhZGVycy9ub2RlX21vZHVsZXMvLnBucG0vdGhyZWUtc3RkbGliQDIuMzUuMl90aHJlZUAwLjE3Mi4wL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbG9hZGVycy9EUkFDT0xvYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2FkZXIsIEZpbGVMb2FkZXIsIEJ1ZmZlckdlb21ldHJ5LCBCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tIFwidGhyZWVcIjtcbmNvbnN0IF90YXNrQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNsYXNzIERSQUNPTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgIHRoaXMuZGVjb2RlclBhdGggPSBcIlwiO1xuICAgIHRoaXMuZGVjb2RlckNvbmZpZyA9IHt9O1xuICAgIHRoaXMuZGVjb2RlckJpbmFyeSA9IG51bGw7XG4gICAgdGhpcy5kZWNvZGVyUGVuZGluZyA9IG51bGw7XG4gICAgdGhpcy53b3JrZXJMaW1pdCA9IDQ7XG4gICAgdGhpcy53b3JrZXJQb29sID0gW107XG4gICAgdGhpcy53b3JrZXJOZXh0VGFza0lEID0gMTtcbiAgICB0aGlzLndvcmtlclNvdXJjZVVSTCA9IFwiXCI7XG4gICAgdGhpcy5kZWZhdWx0QXR0cmlidXRlSURzID0ge1xuICAgICAgcG9zaXRpb246IFwiUE9TSVRJT05cIixcbiAgICAgIG5vcm1hbDogXCJOT1JNQUxcIixcbiAgICAgIGNvbG9yOiBcIkNPTE9SXCIsXG4gICAgICB1djogXCJURVhfQ09PUkRcIlxuICAgIH07XG4gICAgdGhpcy5kZWZhdWx0QXR0cmlidXRlVHlwZXMgPSB7XG4gICAgICBwb3NpdGlvbjogXCJGbG9hdDMyQXJyYXlcIixcbiAgICAgIG5vcm1hbDogXCJGbG9hdDMyQXJyYXlcIixcbiAgICAgIGNvbG9yOiBcIkZsb2F0MzJBcnJheVwiLFxuICAgICAgdXY6IFwiRmxvYXQzMkFycmF5XCJcbiAgICB9O1xuICB9XG4gIHNldERlY29kZXJQYXRoKHBhdGgpIHtcbiAgICB0aGlzLmRlY29kZXJQYXRoID0gcGF0aDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXREZWNvZGVyQ29uZmlnKGNvbmZpZykge1xuICAgIHRoaXMuZGVjb2RlckNvbmZpZyA9IGNvbmZpZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRXb3JrZXJMaW1pdCh3b3JrZXJMaW1pdCkge1xuICAgIHRoaXMud29ya2VyTGltaXQgPSB3b3JrZXJMaW1pdDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcbiAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJhcnJheWJ1ZmZlclwiKTtcbiAgICBsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgIGxvYWRlci5sb2FkKFxuICAgICAgdXJsLFxuICAgICAgKGJ1ZmZlcikgPT4ge1xuICAgICAgICBjb25zdCB0YXNrQ29uZmlnID0ge1xuICAgICAgICAgIGF0dHJpYnV0ZUlEczogdGhpcy5kZWZhdWx0QXR0cmlidXRlSURzLFxuICAgICAgICAgIGF0dHJpYnV0ZVR5cGVzOiB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVUeXBlcyxcbiAgICAgICAgICB1c2VVbmlxdWVJRHM6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVjb2RlR2VvbWV0cnkoYnVmZmVyLCB0YXNrQ29uZmlnKS50aGVuKG9uTG9hZCkuY2F0Y2gob25FcnJvcik7XG4gICAgICB9LFxuICAgICAgb25Qcm9ncmVzcyxcbiAgICAgIG9uRXJyb3JcbiAgICApO1xuICB9XG4gIC8qKiBAZGVwcmVjYXRlZCBLZXB0IGZvciBiYWNrd2FyZC1jb21wYXRpYmlsaXR5IHdpdGggcHJldmlvdXMgRFJBQ09Mb2FkZXIgdmVyc2lvbnMuICovXG4gIGRlY29kZURyYWNvRmlsZShidWZmZXIsIGNhbGxiYWNrLCBhdHRyaWJ1dGVJRHMsIGF0dHJpYnV0ZVR5cGVzKSB7XG4gICAgY29uc3QgdGFza0NvbmZpZyA9IHtcbiAgICAgIGF0dHJpYnV0ZUlEczogYXR0cmlidXRlSURzIHx8IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyxcbiAgICAgIGF0dHJpYnV0ZVR5cGVzOiBhdHRyaWJ1dGVUeXBlcyB8fCB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVUeXBlcyxcbiAgICAgIHVzZVVuaXF1ZUlEczogISFhdHRyaWJ1dGVJRHNcbiAgICB9O1xuICAgIHRoaXMuZGVjb2RlR2VvbWV0cnkoYnVmZmVyLCB0YXNrQ29uZmlnKS50aGVuKGNhbGxiYWNrKTtcbiAgfVxuICBkZWNvZGVHZW9tZXRyeShidWZmZXIsIHRhc2tDb25maWcpIHtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBpbiB0YXNrQ29uZmlnLmF0dHJpYnV0ZVR5cGVzKSB7XG4gICAgICBjb25zdCB0eXBlID0gdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlc1thdHRyaWJ1dGVdO1xuICAgICAgaWYgKHR5cGUuQllURVNfUEVSX0VMRU1FTlQgIT09IHZvaWQgMCkge1xuICAgICAgICB0YXNrQ29uZmlnLmF0dHJpYnV0ZVR5cGVzW2F0dHJpYnV0ZV0gPSB0eXBlLm5hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRhc2tLZXkgPSBKU09OLnN0cmluZ2lmeSh0YXNrQ29uZmlnKTtcbiAgICBpZiAoX3Rhc2tDYWNoZS5oYXMoYnVmZmVyKSkge1xuICAgICAgY29uc3QgY2FjaGVkVGFzayA9IF90YXNrQ2FjaGUuZ2V0KGJ1ZmZlcik7XG4gICAgICBpZiAoY2FjaGVkVGFzay5rZXkgPT09IHRhc2tLZXkpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFRhc2sucHJvbWlzZTtcbiAgICAgIH0gZWxzZSBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuRFJBQ09Mb2FkZXI6IFVuYWJsZSB0byByZS1kZWNvZGUgYSBidWZmZXIgd2l0aCBkaWZmZXJlbnQgc2V0dGluZ3MuIEJ1ZmZlciBoYXMgYWxyZWFkeSBiZWVuIHRyYW5zZmVycmVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB3b3JrZXI7XG4gICAgY29uc3QgdGFza0lEID0gdGhpcy53b3JrZXJOZXh0VGFza0lEKys7XG4gICAgY29uc3QgdGFza0Nvc3QgPSBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBnZW9tZXRyeVBlbmRpbmcgPSB0aGlzLl9nZXRXb3JrZXIodGFza0lELCB0YXNrQ29zdCkudGhlbigoX3dvcmtlcikgPT4ge1xuICAgICAgd29ya2VyID0gX3dvcmtlcjtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHdvcmtlci5fY2FsbGJhY2tzW3Rhc2tJRF0gPSB7IHJlc29sdmUsIHJlamVjdCB9O1xuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImRlY29kZVwiLCBpZDogdGFza0lELCB0YXNrQ29uZmlnLCBidWZmZXIgfSwgW2J1ZmZlcl0pO1xuICAgICAgfSk7XG4gICAgfSkudGhlbigobWVzc2FnZSkgPT4gdGhpcy5fY3JlYXRlR2VvbWV0cnkobWVzc2FnZS5nZW9tZXRyeSkpO1xuICAgIGdlb21ldHJ5UGVuZGluZy5jYXRjaCgoKSA9PiB0cnVlKS50aGVuKCgpID0+IHtcbiAgICAgIGlmICh3b3JrZXIgJiYgdGFza0lEKSB7XG4gICAgICAgIHRoaXMuX3JlbGVhc2VUYXNrKHdvcmtlciwgdGFza0lEKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdGFza0NhY2hlLnNldChidWZmZXIsIHtcbiAgICAgIGtleTogdGFza0tleSxcbiAgICAgIHByb21pc2U6IGdlb21ldHJ5UGVuZGluZ1xuICAgIH0pO1xuICAgIHJldHVybiBnZW9tZXRyeVBlbmRpbmc7XG4gIH1cbiAgX2NyZWF0ZUdlb21ldHJ5KGdlb21ldHJ5RGF0YSkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgaWYgKGdlb21ldHJ5RGF0YS5pbmRleCkge1xuICAgICAgZ2VvbWV0cnkuc2V0SW5kZXgobmV3IEJ1ZmZlckF0dHJpYnV0ZShnZW9tZXRyeURhdGEuaW5kZXguYXJyYXksIDEpKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tZXRyeURhdGEuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnlEYXRhLmF0dHJpYnV0ZXNbaV07XG4gICAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlLm5hbWU7XG4gICAgICBjb25zdCBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKG5hbWUsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplKSk7XG4gICAgfVxuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxuICBfbG9hZExpYnJhcnkodXJsLCByZXNwb25zZVR5cGUpIHtcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuICAgIGxvYWRlci5zZXRQYXRoKHRoaXMuZGVjb2RlclBhdGgpO1xuICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUocmVzcG9uc2VUeXBlKTtcbiAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbG9hZGVyLmxvYWQodXJsLCByZXNvbHZlLCB2b2lkIDAsIHJlamVjdCk7XG4gICAgfSk7XG4gIH1cbiAgcHJlbG9hZCgpIHtcbiAgICB0aGlzLl9pbml0RGVjb2RlcigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9pbml0RGVjb2RlcigpIHtcbiAgICBpZiAodGhpcy5kZWNvZGVyUGVuZGluZylcbiAgICAgIHJldHVybiB0aGlzLmRlY29kZXJQZW5kaW5nO1xuICAgIGNvbnN0IHVzZUpTID0gdHlwZW9mIFdlYkFzc2VtYmx5ICE9PSBcIm9iamVjdFwiIHx8IHRoaXMuZGVjb2RlckNvbmZpZy50eXBlID09PSBcImpzXCI7XG4gICAgY29uc3QgbGlicmFyaWVzUGVuZGluZyA9IFtdO1xuICAgIGlmICh1c2VKUykge1xuICAgICAgbGlicmFyaWVzUGVuZGluZy5wdXNoKHRoaXMuX2xvYWRMaWJyYXJ5KFwiZHJhY29fZGVjb2Rlci5qc1wiLCBcInRleHRcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaWJyYXJpZXNQZW5kaW5nLnB1c2godGhpcy5fbG9hZExpYnJhcnkoXCJkcmFjb193YXNtX3dyYXBwZXIuanNcIiwgXCJ0ZXh0XCIpKTtcbiAgICAgIGxpYnJhcmllc1BlbmRpbmcucHVzaCh0aGlzLl9sb2FkTGlicmFyeShcImRyYWNvX2RlY29kZXIud2FzbVwiLCBcImFycmF5YnVmZmVyXCIpKTtcbiAgICB9XG4gICAgdGhpcy5kZWNvZGVyUGVuZGluZyA9IFByb21pc2UuYWxsKGxpYnJhcmllc1BlbmRpbmcpLnRoZW4oKGxpYnJhcmllcykgPT4ge1xuICAgICAgY29uc3QganNDb250ZW50ID0gbGlicmFyaWVzWzBdO1xuICAgICAgaWYgKCF1c2VKUykge1xuICAgICAgICB0aGlzLmRlY29kZXJDb25maWcud2FzbUJpbmFyeSA9IGxpYnJhcmllc1sxXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZuID0gRFJBQ09Xb3JrZXIudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IGJvZHkgPSBbXG4gICAgICAgIFwiLyogZHJhY28gZGVjb2RlciAqL1wiLFxuICAgICAgICBqc0NvbnRlbnQsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIFwiLyogd29ya2VyICovXCIsXG4gICAgICAgIGZuLnN1YnN0cmluZyhmbi5pbmRleE9mKFwie1wiKSArIDEsIGZuLmxhc3RJbmRleE9mKFwifVwiKSlcbiAgICAgIF0uam9pbihcIlxcblwiKTtcbiAgICAgIHRoaXMud29ya2VyU291cmNlVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbYm9keV0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGVyUGVuZGluZztcbiAgfVxuICBfZ2V0V29ya2VyKHRhc2tJRCwgdGFza0Nvc3QpIHtcbiAgICByZXR1cm4gdGhpcy5faW5pdERlY29kZXIoKS50aGVuKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLndvcmtlclBvb2wubGVuZ3RoIDwgdGhpcy53b3JrZXJMaW1pdCkge1xuICAgICAgICBjb25zdCB3b3JrZXIyID0gbmV3IFdvcmtlcih0aGlzLndvcmtlclNvdXJjZVVSTCk7XG4gICAgICAgIHdvcmtlcjIuX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgICB3b3JrZXIyLl90YXNrQ29zdHMgPSB7fTtcbiAgICAgICAgd29ya2VyMi5fdGFza0xvYWQgPSAwO1xuICAgICAgICB3b3JrZXIyLnBvc3RNZXNzYWdlKHsgdHlwZTogXCJpbml0XCIsIGRlY29kZXJDb25maWc6IHRoaXMuZGVjb2RlckNvbmZpZyB9KTtcbiAgICAgICAgd29ya2VyMi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGUuZGF0YTtcbiAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImRlY29kZVwiOlxuICAgICAgICAgICAgICB3b3JrZXIyLl9jYWxsYmFja3NbbWVzc2FnZS5pZF0ucmVzb2x2ZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgd29ya2VyMi5fY2FsbGJhY2tzW21lc3NhZ2UuaWRdLnJlamVjdChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5EUkFDT0xvYWRlcjogVW5leHBlY3RlZCBtZXNzYWdlLCBcIicgKyBtZXNzYWdlLnR5cGUgKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud29ya2VyUG9vbC5wdXNoKHdvcmtlcjIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53b3JrZXJQb29sLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLl90YXNrTG9hZCA+IGIuX3Rhc2tMb2FkID8gLTEgOiAxO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdvcmtlciA9IHRoaXMud29ya2VyUG9vbFt0aGlzLndvcmtlclBvb2wubGVuZ3RoIC0gMV07XG4gICAgICB3b3JrZXIuX3Rhc2tDb3N0c1t0YXNrSURdID0gdGFza0Nvc3Q7XG4gICAgICB3b3JrZXIuX3Rhc2tMb2FkICs9IHRhc2tDb3N0O1xuICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICB9KTtcbiAgfVxuICBfcmVsZWFzZVRhc2sod29ya2VyLCB0YXNrSUQpIHtcbiAgICB3b3JrZXIuX3Rhc2tMb2FkIC09IHdvcmtlci5fdGFza0Nvc3RzW3Rhc2tJRF07XG4gICAgZGVsZXRlIHdvcmtlci5fY2FsbGJhY2tzW3Rhc2tJRF07XG4gICAgZGVsZXRlIHdvcmtlci5fdGFza0Nvc3RzW3Rhc2tJRF07XG4gIH1cbiAgZGVidWcoKSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBcIlRhc2sgbG9hZDogXCIsXG4gICAgICB0aGlzLndvcmtlclBvb2wubWFwKCh3b3JrZXIpID0+IHdvcmtlci5fdGFza0xvYWQpXG4gICAgKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53b3JrZXJQb29sLmxlbmd0aDsgKytpKSB7XG4gICAgICB0aGlzLndvcmtlclBvb2xbaV0udGVybWluYXRlKCk7XG4gICAgfVxuICAgIHRoaXMud29ya2VyUG9vbC5sZW5ndGggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5mdW5jdGlvbiBEUkFDT1dvcmtlcigpIHtcbiAgbGV0IGRlY29kZXJDb25maWc7XG4gIGxldCBkZWNvZGVyUGVuZGluZztcbiAgb25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBlLmRhdGE7XG4gICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJpbml0XCI6XG4gICAgICAgIGRlY29kZXJDb25maWcgPSBtZXNzYWdlLmRlY29kZXJDb25maWc7XG4gICAgICAgIGRlY29kZXJQZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgIGRlY29kZXJDb25maWcub25Nb2R1bGVMb2FkZWQgPSBmdW5jdGlvbihkcmFjbykge1xuICAgICAgICAgICAgcmVzb2x2ZSh7IGRyYWNvIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgRHJhY29EZWNvZGVyTW9kdWxlKGRlY29kZXJDb25maWcpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGVjb2RlXCI6XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG1lc3NhZ2UuYnVmZmVyO1xuICAgICAgICBjb25zdCB0YXNrQ29uZmlnID0gbWVzc2FnZS50YXNrQ29uZmlnO1xuICAgICAgICBkZWNvZGVyUGVuZGluZy50aGVuKChtb2R1bGUpID0+IHtcbiAgICAgICAgICBjb25zdCBkcmFjbyA9IG1vZHVsZS5kcmFjbztcbiAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IGRyYWNvLkRlY29kZXIoKTtcbiAgICAgICAgICBjb25zdCBkZWNvZGVyQnVmZmVyID0gbmV3IGRyYWNvLkRlY29kZXJCdWZmZXIoKTtcbiAgICAgICAgICBkZWNvZGVyQnVmZmVyLkluaXQobmV3IEludDhBcnJheShidWZmZXIpLCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZGVjb2RlR2VvbWV0cnkoZHJhY28sIGRlY29kZXIsIGRlY29kZXJCdWZmZXIsIHRhc2tDb25maWcpO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVycyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMubWFwKChhdHRyKSA9PiBhdHRyLmFycmF5LmJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnkuaW5kZXgpXG4gICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChnZW9tZXRyeS5pbmRleC5hcnJheS5idWZmZXIpO1xuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiZGVjb2RlXCIsIGlkOiBtZXNzYWdlLmlkLCBnZW9tZXRyeSB9LCBidWZmZXJzKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgdHlwZTogXCJlcnJvclwiLCBpZDogbWVzc2FnZS5pZCwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGRyYWNvLmRlc3Ryb3koZGVjb2RlckJ1ZmZlcik7XG4gICAgICAgICAgICBkcmFjby5kZXN0cm95KGRlY29kZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZGVjb2RlR2VvbWV0cnkoZHJhY28sIGRlY29kZXIsIGRlY29kZXJCdWZmZXIsIHRhc2tDb25maWcpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVJRHMgPSB0YXNrQ29uZmlnLmF0dHJpYnV0ZUlEcztcbiAgICBjb25zdCBhdHRyaWJ1dGVUeXBlcyA9IHRhc2tDb25maWcuYXR0cmlidXRlVHlwZXM7XG4gICAgbGV0IGRyYWNvR2VvbWV0cnk7XG4gICAgbGV0IGRlY29kaW5nU3RhdHVzO1xuICAgIGNvbnN0IGdlb21ldHJ5VHlwZSA9IGRlY29kZXIuR2V0RW5jb2RlZEdlb21ldHJ5VHlwZShkZWNvZGVyQnVmZmVyKTtcbiAgICBpZiAoZ2VvbWV0cnlUeXBlID09PSBkcmFjby5UUklBTkdVTEFSX01FU0gpIHtcbiAgICAgIGRyYWNvR2VvbWV0cnkgPSBuZXcgZHJhY28uTWVzaCgpO1xuICAgICAgZGVjb2RpbmdTdGF0dXMgPSBkZWNvZGVyLkRlY29kZUJ1ZmZlclRvTWVzaChkZWNvZGVyQnVmZmVyLCBkcmFjb0dlb21ldHJ5KTtcbiAgICB9IGVsc2UgaWYgKGdlb21ldHJ5VHlwZSA9PT0gZHJhY28uUE9JTlRfQ0xPVUQpIHtcbiAgICAgIGRyYWNvR2VvbWV0cnkgPSBuZXcgZHJhY28uUG9pbnRDbG91ZCgpO1xuICAgICAgZGVjb2RpbmdTdGF0dXMgPSBkZWNvZGVyLkRlY29kZUJ1ZmZlclRvUG9pbnRDbG91ZChkZWNvZGVyQnVmZmVyLCBkcmFjb0dlb21ldHJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuRFJBQ09Mb2FkZXI6IFVuZXhwZWN0ZWQgZ2VvbWV0cnkgdHlwZS5cIik7XG4gICAgfVxuICAgIGlmICghZGVjb2RpbmdTdGF0dXMub2soKSB8fCBkcmFjb0dlb21ldHJ5LnB0ciA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuRFJBQ09Mb2FkZXI6IERlY29kaW5nIGZhaWxlZDogXCIgKyBkZWNvZGluZ1N0YXR1cy5lcnJvcl9tc2coKSk7XG4gICAgfVxuICAgIGNvbnN0IGdlb21ldHJ5ID0geyBpbmRleDogbnVsbCwgYXR0cmlidXRlczogW10gfTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlSURzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVUeXBlID0gc2VsZlthdHRyaWJ1dGVUeXBlc1thdHRyaWJ1dGVOYW1lXV07XG4gICAgICBsZXQgYXR0cmlidXRlO1xuICAgICAgbGV0IGF0dHJpYnV0ZUlEO1xuICAgICAgaWYgKHRhc2tDb25maWcudXNlVW5pcXVlSURzKSB7XG4gICAgICAgIGF0dHJpYnV0ZUlEID0gYXR0cmlidXRlSURzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICBhdHRyaWJ1dGUgPSBkZWNvZGVyLkdldEF0dHJpYnV0ZUJ5VW5pcXVlSWQoZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlSUQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlSUQgPSBkZWNvZGVyLkdldEF0dHJpYnV0ZUlkKGRyYWNvR2VvbWV0cnksIGRyYWNvW2F0dHJpYnV0ZUlEc1thdHRyaWJ1dGVOYW1lXV0pO1xuICAgICAgICBpZiAoYXR0cmlidXRlSUQgPT09IC0xKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhdHRyaWJ1dGUgPSBkZWNvZGVyLkdldEF0dHJpYnV0ZShkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVJRCk7XG4gICAgICB9XG4gICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnB1c2goZGVjb2RlQXR0cmlidXRlKGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBhdHRyaWJ1dGUpKTtcbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5VHlwZSA9PT0gZHJhY28uVFJJQU5HVUxBUl9NRVNIKSB7XG4gICAgICBnZW9tZXRyeS5pbmRleCA9IGRlY29kZUluZGV4KGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5KTtcbiAgICB9XG4gICAgZHJhY28uZGVzdHJveShkcmFjb0dlb21ldHJ5KTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlSW5kZXgoZHJhY28sIGRlY29kZXIsIGRyYWNvR2VvbWV0cnkpIHtcbiAgICBjb25zdCBudW1GYWNlcyA9IGRyYWNvR2VvbWV0cnkubnVtX2ZhY2VzKCk7XG4gICAgY29uc3QgbnVtSW5kaWNlcyA9IG51bUZhY2VzICogMztcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gbnVtSW5kaWNlcyAqIDQ7XG4gICAgY29uc3QgcHRyID0gZHJhY28uX21hbGxvYyhieXRlTGVuZ3RoKTtcbiAgICBkZWNvZGVyLkdldFRyaWFuZ2xlc1VJbnQzMkFycmF5KGRyYWNvR2VvbWV0cnksIGJ5dGVMZW5ndGgsIHB0cik7XG4gICAgY29uc3QgaW5kZXggPSBuZXcgVWludDMyQXJyYXkoZHJhY28uSEVBUEYzMi5idWZmZXIsIHB0ciwgbnVtSW5kaWNlcykuc2xpY2UoKTtcbiAgICBkcmFjby5fZnJlZShwdHIpO1xuICAgIHJldHVybiB7IGFycmF5OiBpbmRleCwgaXRlbVNpemU6IDEgfTtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVBdHRyaWJ1dGUoZHJhY28sIGRlY29kZXIsIGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVR5cGUsIGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IG51bUNvbXBvbmVudHMgPSBhdHRyaWJ1dGUubnVtX2NvbXBvbmVudHMoKTtcbiAgICBjb25zdCBudW1Qb2ludHMgPSBkcmFjb0dlb21ldHJ5Lm51bV9wb2ludHMoKTtcbiAgICBjb25zdCBudW1WYWx1ZXMgPSBudW1Qb2ludHMgKiBudW1Db21wb25lbnRzO1xuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBudW1WYWx1ZXMgKiBhdHRyaWJ1dGVUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIGNvbnN0IGRhdGFUeXBlID0gZ2V0RHJhY29EYXRhVHlwZShkcmFjbywgYXR0cmlidXRlVHlwZSk7XG4gICAgY29uc3QgcHRyID0gZHJhY28uX21hbGxvYyhieXRlTGVuZ3RoKTtcbiAgICBkZWNvZGVyLkdldEF0dHJpYnV0ZURhdGFBcnJheUZvckFsbFBvaW50cyhkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGUsIGRhdGFUeXBlLCBieXRlTGVuZ3RoLCBwdHIpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IGF0dHJpYnV0ZVR5cGUoZHJhY28uSEVBUEYzMi5idWZmZXIsIHB0ciwgbnVtVmFsdWVzKS5zbGljZSgpO1xuICAgIGRyYWNvLl9mcmVlKHB0cik7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IGF0dHJpYnV0ZU5hbWUsXG4gICAgICBhcnJheSxcbiAgICAgIGl0ZW1TaXplOiBudW1Db21wb25lbnRzXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBnZXREcmFjb0RhdGFUeXBlKGRyYWNvLCBhdHRyaWJ1dGVUeXBlKSB7XG4gICAgc3dpdGNoIChhdHRyaWJ1dGVUeXBlKSB7XG4gICAgICBjYXNlIEZsb2F0MzJBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX0ZMT0FUMzI7XG4gICAgICBjYXNlIEludDhBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX0lOVDg7XG4gICAgICBjYXNlIEludDE2QXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9JTlQxNjtcbiAgICAgIGNhc2UgSW50MzJBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX0lOVDMyO1xuICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfVUlOVDg7XG4gICAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfVUlOVDE2O1xuICAgICAgY2FzZSBVaW50MzJBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX1VJTlQzMjtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCB7XG4gIERSQUNPTG9hZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RFJBQ09Mb2FkZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/loaders/DRACOLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/loaders/GLTFLoader.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/loaders/GLTFLoader.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFLoader: () => (/* binding */ GLTFLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/.pnpm/three@0.172.0/node_modules/three/build/three.core.js\");\n/* harmony import */ var _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/BufferGeometryUtils.js */ \"(ssr)/./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/utils/BufferGeometryUtils.js\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/_polyfill/constants.js\");\n/* harmony import */ var _polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_polyfill/LoaderUtils.js */ \"(ssr)/./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/_polyfill/LoaderUtils.js\");\n\n\n\n\nconst SRGBColorSpace = \"srgb\";\nconst LinearSRGBColorSpace = \"srgb-linear\";\nconst sRGBEncoding = 3001;\nconst LinearEncoding = 3e3;\nclass GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  constructor(manager) {\n    super(manager);\n    this.dracoLoader = null;\n    this.ktx2Loader = null;\n    this.meshoptDecoder = null;\n    this.pluginCallbacks = [];\n    this.register(function(parser) {\n      return new GLTFMaterialsClearcoatExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsDispersionExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureBasisUExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureWebPExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureAVIFExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSheenExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsTransmissionExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsVolumeExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIorExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSpecularExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIridescenceExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsAnisotropyExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsBumpExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFLightsExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshoptCompression(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshGpuInstancing(parser);\n    });\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    let resourcePath;\n    if (this.resourcePath !== \"\") {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== \"\") {\n      const relativeUrl = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n      resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(relativeUrl, this.path);\n    } else {\n      resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n    }\n    this.manager.itemStart(url);\n    const _onError = function(e) {\n      if (onError) {\n        onError(e);\n      } else {\n        console.error(e);\n      }\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    };\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      function(data) {\n        try {\n          scope.parse(\n            data,\n            resourcePath,\n            function(gltf) {\n              onLoad(gltf);\n              scope.manager.itemEnd(url);\n            },\n            _onError\n          );\n        } catch (e) {\n          _onError(e);\n        }\n      },\n      onProgress,\n      _onError\n    );\n  }\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader;\n    return this;\n  }\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n  }\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader;\n    return this;\n  }\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder;\n    return this;\n  }\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n  parse(data, path, onLoad, onError) {\n    let json;\n    const extensions = {};\n    const plugins = {};\n    if (typeof data === \"string\") {\n      json = JSON.parse(data);\n    } else if (data instanceof ArrayBuffer) {\n      const magic = (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data.slice(0, 4)));\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n        } catch (error) {\n          if (onError)\n            onError(error);\n          return;\n        }\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);\n      } else {\n        json = JSON.parse((0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data)));\n      }\n    } else {\n      json = data;\n    }\n    if (json.asset === void 0 || json.asset.version[0] < 2) {\n      if (onError)\n        onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n      return;\n    }\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || \"\",\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder\n    });\n    parser.fileLoader.setRequestHeader(this.requestHeader);\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser);\n      if (!plugin.name)\n        console.error(\"THREE.GLTFLoader: Invalid plugin found: missing name\");\n      plugins[plugin.name] = plugin;\n      extensions[plugin.name] = true;\n    }\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i];\n        const extensionsRequired = json.extensionsRequired || [];\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n            break;\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n            break;\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension();\n            break;\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension();\n            break;\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n            }\n        }\n      }\n    }\n    parser.setExtensions(extensions);\n    parser.setPlugins(plugins);\n    parser.parse(onLoad, onError);\n  }\n  parseAsync(data, path) {\n    const scope = this;\n    return new Promise(function(resolve, reject) {\n      scope.parse(data, path, resolve, reject);\n    });\n  }\n}\nfunction GLTFRegistry() {\n  let objects = {};\n  return {\n    get: function(key) {\n      return objects[key];\n    },\n    add: function(key, object) {\n      objects[key] = object;\n    },\n    remove: function(key) {\n      delete objects[key];\n    },\n    removeAll: function() {\n      objects = {};\n    }\n  };\n}\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n  KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n  KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n  KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n  KHR_MATERIALS_DISPERSION: \"KHR_materials_dispersion\",\n  KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n  KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n  KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n  KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n  KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n  KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n  KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n  KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n  KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n  KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n  KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n  KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n  EXT_MATERIALS_BUMP: \"EXT_materials_bump\",\n  EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n  EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n  EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n  EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n    this.cache = { refs: {}, uses: {} };\n  }\n  _markDefs() {\n    const parser = this.parser;\n    const nodeDefs = this.parser.json.nodes || [];\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n      }\n    }\n  }\n  _loadLight(lightIndex) {\n    const parser = this.parser;\n    const cacheKey = \"light:\" + lightIndex;\n    let dependency = parser.cache.get(cacheKey);\n    if (dependency)\n      return dependency;\n    const json = parser.json;\n    const extensions = json.extensions && json.extensions[this.name] || {};\n    const lightDefs = extensions.lights || [];\n    const lightDef = lightDefs[lightIndex];\n    let lightNode;\n    const color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n    if (lightDef.color !== void 0)\n      color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);\n    const range = lightDef.range !== void 0 ? lightDef.range : 0;\n    switch (lightDef.type) {\n      case \"directional\":\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      case \"point\":\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(color);\n        lightNode.distance = range;\n        break;\n      case \"spot\":\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight(color);\n        lightNode.distance = range;\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      default:\n        throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n    }\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    assignExtrasToUserData(lightNode, lightDef);\n    if (lightDef.intensity !== void 0)\n      lightNode.intensity = lightDef.intensity;\n    lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n    dependency = Promise.resolve(lightNode);\n    parser.cache.add(cacheKey, dependency);\n    return dependency;\n  }\n  getDependency(type, index) {\n    if (type !== \"light\")\n      return;\n    return this._loadLight(index);\n  }\n  createNodeAttachment(nodeIndex) {\n    const self2 = this;\n    const parser = this.parser;\n    const json = parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n    const lightIndex = lightDef.light;\n    if (lightIndex === void 0)\n      return null;\n    return this._loadLight(lightIndex).then(function(light) {\n      return parser._getNodeRef(self2.cache, lightIndex, light);\n    });\n  }\n}\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n  getMaterialType() {\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;\n  }\n  extendParams(materialParams, materialDef, parser) {\n    const pending = [];\n    materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n    materialParams.opacity = 1;\n    const metallicRoughness = materialDef.pbrMetallicRoughness;\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n    if (emissiveStrength !== void 0) {\n      materialParams.emissiveIntensity = emissiveStrength;\n    }\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.clearcoatFactor !== void 0) {\n      materialParams.clearcoat = extension.clearcoatFactor;\n    }\n    if (extension.clearcoatTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n    }\n    if (extension.clearcoatRoughnessFactor !== void 0) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n    }\n    if (extension.clearcoatRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n    }\n    if (extension.clearcoatNormalTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n      if (extension.clearcoatNormalTexture.scale !== void 0) {\n        const scale = extension.clearcoatNormalTexture.scale;\n        materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scale, scale);\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsDispersionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.iridescenceFactor !== void 0) {\n      materialParams.iridescence = extension.iridescenceFactor;\n    }\n    if (extension.iridescenceTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"iridescenceMap\", extension.iridescenceTexture));\n    }\n    if (extension.iridescenceIor !== void 0) {\n      materialParams.iridescenceIOR = extension.iridescenceIor;\n    }\n    if (materialParams.iridescenceThicknessRange === void 0) {\n      materialParams.iridescenceThicknessRange = [100, 400];\n    }\n    if (extension.iridescenceThicknessMinimum !== void 0) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n    }\n    if (extension.iridescenceThicknessMaximum !== void 0) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n    }\n    if (extension.iridescenceThicknessTexture !== void 0) {\n      pending.push(\n        parser.assignTexture(materialParams, \"iridescenceThicknessMap\", extension.iridescenceThicknessTexture)\n      );\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    materialParams.sheenColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0);\n    materialParams.sheenRoughness = 0;\n    materialParams.sheen = 1;\n    const extension = materialDef.extensions[this.name];\n    if (extension.sheenColorFactor !== void 0) {\n      const colorFactor = extension.sheenColorFactor;\n      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);\n    }\n    if (extension.sheenRoughnessFactor !== void 0) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n    }\n    if (extension.sheenColorTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, SRGBColorSpace));\n    }\n    if (extension.sheenRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.transmissionFactor !== void 0) {\n      materialParams.transmission = extension.transmissionFactor;\n    }\n    if (extension.transmissionTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;\n    if (extension.thicknessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n    }\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n    const colorArray = extension.attenuationColor || [1, 1, 1];\n    materialParams.attenuationColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(\n      colorArray[0],\n      colorArray[1],\n      colorArray[2],\n      LinearSRGBColorSpace\n    );\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;\n    if (extension.specularTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n    }\n    const colorArray = extension.specularColorFactor || [1, 1, 1];\n    materialParams.specularColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);\n    if (extension.specularColorTexture !== void 0) {\n      pending.push(\n        parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, SRGBColorSpace)\n      );\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsBumpExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_MATERIALS_BUMP;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;\n    if (extension.bumpTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"bumpMap\", extension.bumpTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.anisotropyStrength !== void 0) {\n      materialParams.anisotropy = extension.anisotropyStrength;\n    }\n    if (extension.anisotropyRotation !== void 0) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation;\n    }\n    if (extension.anisotropyTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"anisotropyMap\", extension.anisotropyTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n  }\n  loadTexture(textureIndex) {\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[this.name];\n    const loader = parser.options.ktx2Loader;\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n      } else {\n        return null;\n      }\n    }\n    return parser.loadTextureImage(textureIndex, extension.source, loader);\n  }\n}\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n    this.parser = parser;\n  }\n  loadBufferView(index) {\n    const json = this.parser.json;\n    const bufferView = json.bufferViews[index];\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name];\n      const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n      const decoder = this.parser.options.meshoptDecoder;\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n        } else {\n          return null;\n        }\n      }\n      return buffer.then(function(res) {\n        const byteOffset = extensionDef.byteOffset || 0;\n        const byteLength = extensionDef.byteLength || 0;\n        const count = extensionDef.count;\n        const stride = extensionDef.byteStride;\n        const source = new Uint8Array(res, byteOffset, byteLength);\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {\n            return res2.buffer;\n          });\n        } else {\n          return decoder.ready.then(function() {\n            const result = new ArrayBuffer(count * stride);\n            decoder.decodeGltfBuffer(\n              new Uint8Array(result),\n              count,\n              stride,\n              source,\n              extensionDef.mode,\n              extensionDef.filter\n            );\n            return result;\n          });\n        }\n      });\n    } else {\n      return null;\n    }\n  }\n}\nclass GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n    this.parser = parser;\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {\n      return null;\n    }\n    const meshDef = json.meshes[nodeDef.mesh];\n    for (const primitive of meshDef.primitives) {\n      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {\n        return null;\n      }\n    }\n    const extensionDef = nodeDef.extensions[this.name];\n    const attributesDef = extensionDef.attributes;\n    const pending = [];\n    const attributes = {};\n    for (const key in attributesDef) {\n      pending.push(\n        this.parser.getDependency(\"accessor\", attributesDef[key]).then((accessor) => {\n          attributes[key] = accessor;\n          return attributes[key];\n        })\n      );\n    }\n    if (pending.length < 1) {\n      return null;\n    }\n    pending.push(this.parser.createNodeMesh(nodeIndex));\n    return Promise.all(pending).then((results) => {\n      const nodeObject = results.pop();\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];\n      const count = results[0].count;\n      const instancedMeshes = [];\n      for (const mesh of meshes) {\n        const m = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        const p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        const s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        const instancedMesh = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh(mesh.geometry, mesh.material, count);\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i);\n          }\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i);\n          }\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i);\n          }\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s));\n        }\n        for (const attributeName in attributes) {\n          if (attributeName === \"_COLOR_0\") {\n            const attr = attributes[attributeName];\n            instancedMesh.instanceColor = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);\n          } else if (attributeName !== \"TRANSLATION\" && attributeName !== \"ROTATION\" && attributeName !== \"SCALE\") {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\n          }\n        }\n        three__WEBPACK_IMPORTED_MODULE_0__.Object3D.prototype.copy.call(instancedMesh, mesh);\n        this.parser.assignFinalMaterial(instancedMesh);\n        instancedMeshes.push(instancedMesh);\n      }\n      if (nodeObject.isGroup) {\n        nodeObject.clear();\n        nodeObject.add(...instancedMeshes);\n        return nodeObject;\n      }\n      return instancedMeshes[0];\n    });\n  }\n}\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n    } else if (this.header.version < 2) {\n      throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n    }\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    let chunkIndex = 0;\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      const chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      }\n      chunkIndex += chunkLength;\n    }\n    if (this.content === null) {\n      throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n    }\n  }\n}\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n    }\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n    this.dracoLoader.preload();\n  }\n  decodePrimitive(primitive, parser) {\n    const json = this.json;\n    const dracoLoader = this.dracoLoader;\n    const bufferViewIndex = primitive.extensions[this.name].bufferView;\n    const gltfAttributeMap = primitive.extensions[this.name].attributes;\n    const threeAttributeMap = {};\n    const attributeNormalizedMap = {};\n    const attributeTypeMap = {};\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      if (gltfAttributeMap[attributeName] !== void 0) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]];\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType.name;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n    return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n      return new Promise(function(resolve, reject) {\n        dracoLoader.decodeDracoFile(\n          bufferView,\n          function(geometry) {\n            for (const attributeName in geometry.attributes) {\n              const attribute = geometry.attributes[attributeName];\n              const normalized = attributeNormalizedMap[attributeName];\n              if (normalized !== void 0)\n                attribute.normalized = normalized;\n            }\n            resolve(geometry);\n          },\n          threeAttributeMap,\n          attributeTypeMap,\n          LinearSRGBColorSpace,\n          reject\n        );\n      });\n    });\n  }\n}\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n  extendTexture(texture, transform) {\n    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {\n      return texture;\n    }\n    texture = texture.clone();\n    if (transform.texCoord !== void 0) {\n      texture.channel = transform.texCoord;\n    }\n    if (transform.offset !== void 0) {\n      texture.offset.fromArray(transform.offset);\n    }\n    if (transform.rotation !== void 0) {\n      texture.rotation = transform.rotation;\n    }\n    if (transform.scale !== void 0) {\n      texture.repeat.fromArray(transform.scale);\n    }\n    texture.needsUpdate = true;\n    return texture;\n  }\n}\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n  }\n}\nclass GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  copySampleValue_(index) {\n    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n    return result;\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const stride2 = stride * 2;\n    const stride3 = stride * 3;\n    const td = t1 - t0;\n    const p = (t - t0) / td;\n    const pp = p * p;\n    const ppp = pp * p;\n    const offset1 = i1 * stride3;\n    const offset0 = offset1 - stride3;\n    const s2 = -2 * ppp + 3 * pp;\n    const s3 = ppp - pp;\n    const s0 = 1 - s2;\n    const s1 = s3 - pp + p;\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride];\n      const m0 = values[offset0 + i + stride2] * td;\n      const p1 = values[offset1 + i + stride];\n      const m1 = values[offset1 + i] * td;\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n    }\n    return result;\n  }\n}\nconst _q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1);\n    _q.fromArray(result).normalize().toArray(result);\n    return result;\n  }\n}\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n  9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n  9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n  9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,\n  9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,\n  9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,\n  9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n  33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n  33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,\n  10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTES = {\n  POSITION: \"position\",\n  NORMAL: \"normal\",\n  TANGENT: \"tangent\",\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ..._polyfill_constants_js__WEBPACK_IMPORTED_MODULE_2__.version >= 152 ? {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv1\",\n    TEXCOORD_2: \"uv2\",\n    TEXCOORD_3: \"uv3\"\n  } : {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv2\"\n  },\n  COLOR_0: \"color\",\n  WEIGHTS_0: \"skinWeight\",\n  JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n  scale: \"scale\",\n  translation: \"position\",\n  rotation: \"quaternion\",\n  weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n  CUBICSPLINE: void 0,\n  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,\n  STEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n  OPAQUE: \"OPAQUE\",\n  MASK: \"MASK\",\n  BLEND: \"BLEND\"\n};\nfunction createDefaultMaterial(cache) {\n  if (cache[\"DefaultMaterial\"] === void 0) {\n    cache[\"DefaultMaterial\"] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n      color: 16777215,\n      emissive: 0,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide\n    });\n  }\n  return cache[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === void 0) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\n    }\n  }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== void 0) {\n    if (typeof gltfDef.extras === \"object\") {\n      Object.assign(object.userData, gltfDef.extras);\n    } else {\n      console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n    }\n  }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false;\n  let hasMorphNormal = false;\n  let hasMorphColor = false;\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (target.POSITION !== void 0)\n      hasMorphPosition = true;\n    if (target.NORMAL !== void 0)\n      hasMorphNormal = true;\n    if (target.COLOR_0 !== void 0)\n      hasMorphColor = true;\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor)\n      break;\n  }\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)\n    return Promise.resolve(geometry);\n  const pendingPositionAccessors = [];\n  const pendingNormalAccessors = [];\n  const pendingColorAccessors = [];\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (hasMorphPosition) {\n      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n      pendingPositionAccessors.push(pendingAccessor);\n    }\n    if (hasMorphNormal) {\n      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n      pendingNormalAccessors.push(pendingAccessor);\n    }\n    if (hasMorphColor) {\n      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n      pendingColorAccessors.push(pendingAccessor);\n    }\n  }\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors)\n  ]).then(function(accessors) {\n    const morphPositions = accessors[0];\n    const morphNormals = accessors[1];\n    const morphColors = accessors[2];\n    if (hasMorphPosition)\n      geometry.morphAttributes.position = morphPositions;\n    if (hasMorphNormal)\n      geometry.morphAttributes.normal = morphNormals;\n    if (hasMorphColor)\n      geometry.morphAttributes.color = morphColors;\n    geometry.morphTargetsRelative = true;\n    return geometry;\n  });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets();\n  if (meshDef.weights !== void 0) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\n    }\n  }\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames;\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {};\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i;\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n    }\n  }\n}\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey;\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n  if (dracoExtension) {\n    geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n  } else {\n    geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n  }\n  if (primitiveDef.targets !== void 0) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += \":\" + createAttributesKey(primitiveDef.targets[i]);\n    }\n  }\n  return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n  let attributesKey = \"\";\n  const keys = Object.keys(attributes).sort();\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n  }\n  return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127;\n    case Uint8Array:\n      return 1 / 255;\n    case Int16Array:\n      return 1 / 32767;\n    case Uint16Array:\n      return 1 / 65535;\n    default:\n      throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n  }\n}\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0)\n    return \"image/jpeg\";\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0)\n    return \"image/webp\";\n  return \"image/png\";\n}\nconst _identityMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json;\n    this.extensions = {};\n    this.plugins = {};\n    this.options = options;\n    this.cache = new GLTFRegistry();\n    this.associations = /* @__PURE__ */ new Map();\n    this.primitiveCache = {};\n    this.nodeCache = {};\n    this.meshCache = { refs: {}, uses: {} };\n    this.cameraCache = { refs: {}, uses: {} };\n    this.lightCache = { refs: {}, uses: {} };\n    this.sourceCache = {};\n    this.textureCache = {};\n    this.nodeNamesUsed = {};\n    let isSafari = false;\n    let isFirefox = false;\n    let firefoxVersion = -1;\n    if (typeof navigator !== \"undefined\" && typeof navigator.userAgent !== \"undefined\") {\n      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n      isFirefox = navigator.userAgent.indexOf(\"Firefox\") > -1;\n      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n    }\n    if (typeof createImageBitmap === \"undefined\" || isSafari || isFirefox && firefoxVersion < 98) {\n      this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(this.options.manager);\n    } else {\n      this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader(this.options.manager);\n    }\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\n    this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.options.manager);\n    this.fileLoader.setResponseType(\"arraybuffer\");\n    if (this.options.crossOrigin === \"use-credentials\") {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n  setExtensions(extensions) {\n    this.extensions = extensions;\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  parse(onLoad, onError) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    this.cache.removeAll();\n    this.nodeCache = {};\n    this._invokeAll(function(ext) {\n      return ext._markDefs && ext._markDefs();\n    });\n    Promise.all(\n      this._invokeAll(function(ext) {\n        return ext.beforeRoot && ext.beforeRoot();\n      })\n    ).then(function() {\n      return Promise.all([\n        parser.getDependencies(\"scene\"),\n        parser.getDependencies(\"animation\"),\n        parser.getDependencies(\"camera\")\n      ]);\n    }).then(function(dependencies) {\n      const result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      return Promise.all(\n        parser._invokeAll(function(ext) {\n          return ext.afterRoot && ext.afterRoot(result);\n        })\n      ).then(function() {\n        for (const scene of result.scenes) {\n          scene.updateMatrixWorld();\n        }\n        onLoad(result);\n      });\n    }).catch(onError);\n  }\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || [];\n    const skinDefs = this.json.skins || [];\n    const meshDefs = this.json.meshes || [];\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints;\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    }\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.mesh !== void 0) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh);\n        if (nodeDef.skin !== void 0) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n      if (nodeDef.camera !== void 0) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera);\n      }\n    }\n  }\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === void 0)\n      return;\n    if (cache.refs[index] === void 0) {\n      cache.refs[index] = cache.uses[index] = 0;\n    }\n    cache.refs[index]++;\n  }\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1)\n      return object;\n    const ref = object.clone();\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original);\n      if (mappings != null) {\n        this.associations.set(clone, mappings);\n      }\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i]);\n      }\n    };\n    updateMappings(object, ref);\n    ref.name += \"_instance_\" + cache.uses[index]++;\n    return ref;\n  }\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.push(this);\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        return result;\n    }\n    return null;\n  }\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.unshift(this);\n    const pending = [];\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        pending.push(result);\n    }\n    return pending;\n  }\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + \":\" + index;\n    let dependency = this.cache.get(cacheKey);\n    if (!dependency) {\n      switch (type) {\n        case \"scene\":\n          dependency = this.loadScene(index);\n          break;\n        case \"node\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadNode && ext.loadNode(index);\n          });\n          break;\n        case \"mesh\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMesh && ext.loadMesh(index);\n          });\n          break;\n        case \"accessor\":\n          dependency = this.loadAccessor(index);\n          break;\n        case \"bufferView\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadBufferView && ext.loadBufferView(index);\n          });\n          break;\n        case \"buffer\":\n          dependency = this.loadBuffer(index);\n          break;\n        case \"material\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMaterial && ext.loadMaterial(index);\n          });\n          break;\n        case \"texture\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadTexture && ext.loadTexture(index);\n          });\n          break;\n        case \"skin\":\n          dependency = this.loadSkin(index);\n          break;\n        case \"animation\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadAnimation && ext.loadAnimation(index);\n          });\n          break;\n        case \"camera\":\n          dependency = this.loadCamera(index);\n          break;\n        default:\n          dependency = this._invokeOne(function(ext) {\n            return ext != this && ext.getDependency && ext.getDependency(type, index);\n          });\n          if (!dependency) {\n            throw new Error(\"Unknown type: \" + type);\n          }\n          break;\n      }\n      this.cache.add(cacheKey, dependency);\n    }\n    return dependency;\n  }\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type);\n    if (!dependencies) {\n      const parser = this;\n      const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n      dependencies = Promise.all(\n        defs.map(function(def, index) {\n          return parser.getDependency(type, index);\n        })\n      );\n      this.cache.add(type, dependencies);\n    }\n    return dependencies;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex];\n    const loader = this.fileLoader;\n    if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n      throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n    }\n    if (bufferDef.uri === void 0 && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n    const options = this.options;\n    return new Promise(function(resolve, reject) {\n      loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n      const byteLength = bufferViewDef.byteLength || 0;\n      const byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this;\n    const json = this.json;\n    const accessorDef = this.json.accessors[accessorIndex];\n    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const normalized = accessorDef.normalized === true;\n      const array = new TypedArray(accessorDef.count * itemSize);\n      return Promise.resolve(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized));\n    }\n    const pendingBufferViews = [];\n    if (accessorDef.bufferView !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n    if (accessorDef.sparse !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n    }\n    return Promise.all(pendingBufferViews).then(function(bufferViews) {\n      const bufferView = bufferViews[0];\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      const itemBytes = elementBytes * itemSize;\n      const byteOffset = accessorDef.byteOffset || 0;\n      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n      const normalized = accessorDef.normalized === true;\n      let array, bufferAttribute;\n      if (byteStride && byteStride !== itemBytes) {\n        const ibSlice = Math.floor(byteOffset / byteStride);\n        const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n        let ib = parser.cache.get(ibCacheKey);\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n          ib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n        bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(\n          ib,\n          itemSize,\n          byteOffset % byteStride / elementBytes,\n          normalized\n        );\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n        bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n      }\n      if (accessorDef.sparse !== void 0) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        const sparseIndices = new TypedArrayIndices(\n          bufferViews[1],\n          byteOffsetIndices,\n          accessorDef.sparse.count * itemSizeIndices\n        );\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n        if (bufferView !== null) {\n          bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(\n            bufferAttribute.array.slice(),\n            bufferAttribute.itemSize,\n            bufferAttribute.normalized\n          );\n        }\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2)\n            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3)\n            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4)\n            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5)\n            throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n        }\n      }\n      return bufferAttribute;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const sourceIndex = textureDef.source;\n    const sourceDef = json.images[sourceIndex];\n    let loader = this.textureLoader;\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.loadTextureImage(textureIndex, sourceIndex, loader);\n  }\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const textureDef = json.textures[textureIndex];\n    const sourceDef = json.images[sourceIndex];\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n    if (this.textureCache[cacheKey]) {\n      return this.textureCache[cacheKey];\n    }\n    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {\n      texture.flipY = false;\n      texture.name = textureDef.name || sourceDef.name || \"\";\n      if (texture.name === \"\" && typeof sourceDef.uri === \"string\" && sourceDef.uri.startsWith(\"data:image/\") === false) {\n        texture.name = sourceDef.uri;\n      }\n      const samplers = json.samplers || {};\n      const sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n      parser.associations.set(texture, { textures: textureIndex });\n      return texture;\n    }).catch(function() {\n      return null;\n    });\n    this.textureCache[cacheKey] = promise;\n    return promise;\n  }\n  loadImageSource(sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const options = this.options;\n    if (this.sourceCache[sourceIndex] !== void 0) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone());\n    }\n    const sourceDef = json.images[sourceIndex];\n    const URL = self.URL || self.webkitURL;\n    let sourceURI = sourceDef.uri || \"\";\n    let isObjectURL = false;\n    if (sourceDef.bufferView !== void 0) {\n      sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function(bufferView) {\n        isObjectURL = true;\n        const blob = new Blob([bufferView], { type: sourceDef.mimeType });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    } else if (sourceDef.uri === void 0) {\n      throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n    }\n    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {\n      return new Promise(function(resolve, reject) {\n        let onLoad = resolve;\n        if (loader.isImageBitmapLoader === true) {\n          onLoad = function(imageBitmap) {\n            const texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(imageBitmap);\n            texture.needsUpdate = true;\n            resolve(texture);\n          };\n        }\n        loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n      });\n    }).then(function(texture) {\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n      assignExtrasToUserData(texture, sourceDef);\n      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n      return texture;\n    }).catch(function(error) {\n      console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n      throw error;\n    });\n    this.sourceCache[sourceIndex] = promise;\n    return promise;\n  }\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, colorSpace) {\n    const parser = this;\n    return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n      if (!texture)\n        return null;\n      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {\n        texture = texture.clone();\n        texture.channel = mapDef.texCoord;\n      }\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n        if (transform) {\n          const gltfReference = parser.associations.get(texture);\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n          parser.associations.set(texture, gltfReference);\n        }\n      }\n      if (colorSpace !== void 0) {\n        if (typeof colorSpace === \"number\")\n          colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n        if (\"colorSpace\" in texture)\n          texture.colorSpace = colorSpace;\n        else\n          texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n      }\n      materialParams[mapName] = texture;\n      return texture;\n    });\n  }\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry;\n    let material = mesh.material;\n    const useDerivativeTangents = geometry.attributes.tangent === void 0;\n    const useVertexColors = geometry.attributes.color !== void 0;\n    const useFlatShading = geometry.attributes.normal === void 0;\n    if (mesh.isPoints) {\n      const cacheKey = \"PointsMaterial:\" + material.uuid;\n      let pointsMaterial = this.cache.get(cacheKey);\n      if (!pointsMaterial) {\n        pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();\n        three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false;\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n      let lineMaterial = this.cache.get(cacheKey);\n      if (!lineMaterial) {\n        lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n        three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        lineMaterial.map = material.map;\n        this.cache.add(cacheKey, lineMaterial);\n      }\n      material = lineMaterial;\n    }\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n      if (useDerivativeTangents)\n        cacheKey += \"derivative-tangents:\";\n      if (useVertexColors)\n        cacheKey += \"vertex-colors:\";\n      if (useFlatShading)\n        cacheKey += \"flat-shading:\";\n      let cachedMaterial = this.cache.get(cacheKey);\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone();\n        if (useVertexColors)\n          cachedMaterial.vertexColors = true;\n        if (useFlatShading)\n          cachedMaterial.flatShading = true;\n        if (useDerivativeTangents) {\n          if (cachedMaterial.normalScale)\n            cachedMaterial.normalScale.y *= -1;\n          if (cachedMaterial.clearcoatNormalScale)\n            cachedMaterial.clearcoatNormalScale.y *= -1;\n        }\n        this.cache.add(cacheKey, cachedMaterial);\n        this.associations.set(cachedMaterial, this.associations.get(material));\n      }\n      material = cachedMaterial;\n    }\n    mesh.material = material;\n  }\n  getMaterialType() {\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const materialDef = json.materials[materialIndex];\n    let materialType;\n    const materialParams = {};\n    const materialExtensions = materialDef.extensions || {};\n    const pending = [];\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n      materialParams.opacity = 1;\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n      }\n      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n      if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n      }\n      materialType = this._invokeOne(function(ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex);\n      });\n      pending.push(\n        Promise.all(\n          this._invokeAll(function(ext) {\n            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n          })\n        )\n      );\n    }\n    if (materialDef.doubleSided === true) {\n      materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n    }\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n      materialParams.depthWrite = false;\n    } else {\n      materialParams.transparent = false;\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n    if (materialDef.normalTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n      materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);\n      if (materialDef.normalTexture.scale !== void 0) {\n        const scale = materialDef.normalTexture.scale;\n        materialParams.normalScale.set(scale, scale);\n      }\n    }\n    if (materialDef.occlusionTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n      if (materialDef.occlusionTexture.strength !== void 0) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n    if (materialDef.emissiveFactor !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      const emissiveFactor = materialDef.emissiveFactor;\n      materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(\n        emissiveFactor[0],\n        emissiveFactor[1],\n        emissiveFactor[2],\n        LinearSRGBColorSpace\n      );\n    }\n    if (materialDef.emissiveTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, SRGBColorSpace));\n    }\n    return Promise.all(pending).then(function() {\n      const material = new materialType(materialParams);\n      if (materialDef.name)\n        material.name = materialDef.name;\n      assignExtrasToUserData(material, materialDef);\n      parser.associations.set(material, { materials: materialIndex });\n      if (materialDef.extensions)\n        addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  }\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName(originalName || \"\");\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + \"_\" + ++this.nodeNamesUsed[sanitizedName];\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0;\n      return sanitizedName;\n    }\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this;\n    const extensions = this.extensions;\n    const cache = this.primitiveCache;\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i];\n      const cacheKey = createPrimitiveKey(primitive);\n      const cached = cache[cacheKey];\n      if (cached) {\n        pending.push(cached.promise);\n      } else {\n        let geometryPromise;\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          geometryPromise = addPrimitiveAttributes(new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser);\n        }\n        cache[cacheKey] = { primitive, promise: geometryPromise };\n        pending.push(geometryPromise);\n      }\n    }\n    return Promise.all(pending);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const meshDef = json.meshes[meshIndex];\n    const primitives = meshDef.primitives;\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n      pending.push(material);\n    }\n    pending.push(parser.loadGeometries(primitives));\n    return Promise.all(pending).then(function(results) {\n      const materials = results.slice(0, results.length - 1);\n      const geometries = results[results.length - 1];\n      const meshes = [];\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i];\n        const primitive = primitives[i];\n        let mesh;\n        const material = materials[i];\n        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {\n          mesh = meshDef.isSkinnedMesh === true ? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh(geometry, material) : new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);\n          if (mesh.isSkinnedMesh === true) {\n            mesh.normalizeSkinWeights();\n          }\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode);\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode);\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(geometry, material);\n        } else {\n          throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n        }\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef);\n        }\n        mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n        assignExtrasToUserData(mesh, meshDef);\n        if (primitive.extensions)\n          addUnknownExtensionsToUserData(extensions, mesh, primitive);\n        parser.assignFinalMaterial(mesh);\n        meshes.push(mesh);\n      }\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i\n        });\n      }\n      if (meshes.length === 1) {\n        if (meshDef.extensions)\n          addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);\n        return meshes[0];\n      }\n      const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n      if (meshDef.extensions)\n        addUnknownExtensionsToUserData(extensions, group, meshDef);\n      parser.associations.set(group, { meshes: meshIndex });\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i]);\n      }\n      return group;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera;\n    const cameraDef = this.json.cameras[cameraIndex];\n    const params = cameraDef[cameraDef.type];\n    if (!params) {\n      console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n      return;\n    }\n    if (cameraDef.type === \"perspective\") {\n      camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(\n        three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(params.yfov),\n        params.aspectRatio || 1,\n        params.znear || 1,\n        params.zfar || 2e6\n      );\n    } else if (cameraDef.type === \"orthographic\") {\n      camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n    }\n    if (cameraDef.name)\n      camera.name = this.createUniqueName(cameraDef.name);\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex];\n    const pending = [];\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]));\n    }\n    if (skinDef.inverseBindMatrices !== void 0) {\n      pending.push(this.getDependency(\"accessor\", skinDef.inverseBindMatrices));\n    } else {\n      pending.push(null);\n    }\n    return Promise.all(pending).then(function(results) {\n      const inverseBindMatrices = results.pop();\n      const jointNodes = results;\n      const bones = [];\n      const boneInverses = [];\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i];\n        if (jointNode) {\n          bones.push(jointNode);\n          const mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16);\n          }\n          boneInverses.push(mat);\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i]);\n        }\n      }\n      return new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton(bones, boneInverses);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json;\n    const parser = this;\n    const animationDef = json.animations[animationIndex];\n    const animationName = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n    const pendingNodes = [];\n    const pendingInputAccessors = [];\n    const pendingOutputAccessors = [];\n    const pendingSamplers = [];\n    const pendingTargets = [];\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i];\n      const sampler = animationDef.samplers[channel.sampler];\n      const target = channel.target;\n      const name = target.node;\n      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n      if (target.node === void 0)\n        continue;\n      pendingNodes.push(this.getDependency(\"node\", name));\n      pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n      pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets)\n    ]).then(function(dependencies) {\n      const nodes = dependencies[0];\n      const inputAccessors = dependencies[1];\n      const outputAccessors = dependencies[2];\n      const samplers = dependencies[3];\n      const targets = dependencies[4];\n      const tracks = [];\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i];\n        const inputAccessor = inputAccessors[i];\n        const outputAccessor = outputAccessors[i];\n        const sampler = samplers[i];\n        const target = targets[i];\n        if (node === void 0)\n          continue;\n        if (node.updateMatrix) {\n          node.updateMatrix();\n        }\n        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);\n        if (createdTracks) {\n          for (let k = 0; k < createdTracks.length; k++) {\n            tracks.push(createdTracks[k]);\n          }\n        }\n      }\n      return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(animationName, void 0, tracks);\n    });\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    if (nodeDef.mesh === void 0)\n      return null;\n    return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n      if (nodeDef.weights !== void 0) {\n        node.traverse(function(o) {\n          if (!o.isMesh)\n            return;\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i];\n          }\n        });\n      }\n      return node;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    const nodePending = parser._loadNodeShallow(nodeIndex);\n    const childPending = [];\n    const childrenDef = nodeDef.children || [];\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency(\"node\", childrenDef[i]));\n    }\n    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency(\"skin\", nodeDef.skin);\n    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function(results) {\n      const node = results[0];\n      const children = results[1];\n      const skeleton = results[2];\n      if (skeleton !== null) {\n        node.traverse(function(mesh) {\n          if (!mesh.isSkinnedMesh)\n            return;\n          mesh.bind(skeleton, _identityMatrix);\n        });\n      }\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i]);\n      }\n      return node;\n    });\n  }\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const parser = this;\n    if (this.nodeCache[nodeIndex] !== void 0) {\n      return this.nodeCache[nodeIndex];\n    }\n    const nodeDef = json.nodes[nodeIndex];\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n    const pending = [];\n    const meshPromise = parser._invokeOne(function(ext) {\n      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n    });\n    if (meshPromise) {\n      pending.push(meshPromise);\n    }\n    if (nodeDef.camera !== void 0) {\n      pending.push(\n        parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n        })\n      );\n    }\n    parser._invokeAll(function(ext) {\n      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n    }).forEach(function(promise) {\n      pending.push(promise);\n    });\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {\n      let node;\n      if (nodeDef.isBone === true) {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n      } else if (objects.length > 1) {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n      }\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name;\n        node.name = nodeName;\n      }\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions)\n        addUnknownExtensionsToUserData(extensions, node, nodeDef);\n      if (nodeDef.matrix !== void 0) {\n        const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix4(matrix);\n      } else {\n        if (nodeDef.translation !== void 0) {\n          node.position.fromArray(nodeDef.translation);\n        }\n        if (nodeDef.rotation !== void 0) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n        if (nodeDef.scale !== void 0) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {});\n      }\n      parser.associations.get(node).nodes = nodeIndex;\n      return node;\n    });\n    return this.nodeCache[nodeIndex];\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions;\n    const sceneDef = this.json.scenes[sceneIndex];\n    const parser = this;\n    const scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n    if (sceneDef.name)\n      scene.name = parser.createUniqueName(sceneDef.name);\n    assignExtrasToUserData(scene, sceneDef);\n    if (sceneDef.extensions)\n      addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n    const nodeIds = sceneDef.nodes || [];\n    const pending = [];\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency(\"node\", nodeIds[i]));\n    }\n    return Promise.all(pending).then(function(nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i]);\n      }\n      const reduceAssociations = (node) => {\n        const reducedAssociations = /* @__PURE__ */ new Map();\n        for (const [key, value] of parser.associations) {\n          if (key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) {\n            reducedAssociations.set(key, value);\n          }\n        }\n        node.traverse((node2) => {\n          const mappings = parser.associations.get(node2);\n          if (mappings != null) {\n            reducedAssociations.set(node2, mappings);\n          }\n        });\n        return reducedAssociations;\n      };\n      parser.associations = reduceAssociations(scene);\n      return scene;\n    });\n  }\n  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n    const tracks = [];\n    const targetName = node.name ? node.name : node.uuid;\n    const targetNames = [];\n    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n      node.traverse(function(object) {\n        if (object.morphTargetInfluences) {\n          targetNames.push(object.name ? object.name : object.uuid);\n        }\n      });\n    } else {\n      targetNames.push(targetName);\n    }\n    let TypedKeyframeTrack;\n    switch (PATH_PROPERTIES[target.path]) {\n      case PATH_PROPERTIES.weights:\n        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n        break;\n      case PATH_PROPERTIES.rotation:\n        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;\n        break;\n      case PATH_PROPERTIES.position:\n      case PATH_PROPERTIES.scale:\n        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n        break;\n      default:\n        switch (outputAccessor.itemSize) {\n          case 1:\n            TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n            break;\n          case 2:\n          case 3:\n          default:\n            TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n            break;\n        }\n        break;\n    }\n    const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;\n    const outputArray = this._getArrayFromAccessor(outputAccessor);\n    for (let j = 0, jl = targetNames.length; j < jl; j++) {\n      const track = new TypedKeyframeTrack(\n        targetNames[j] + \".\" + PATH_PROPERTIES[target.path],\n        inputAccessor.array,\n        outputArray,\n        interpolation\n      );\n      if (sampler.interpolation === \"CUBICSPLINE\") {\n        this._createCubicSplineTrackInterpolant(track);\n      }\n      tracks.push(track);\n    }\n    return tracks;\n  }\n  _getArrayFromAccessor(accessor) {\n    let outputArray = accessor.array;\n    if (accessor.normalized) {\n      const scale = getNormalizedComponentScale(outputArray.constructor);\n      const scaled = new Float32Array(outputArray.length);\n      for (let j = 0, jl = outputArray.length; j < jl; j++) {\n        scaled[j] = outputArray[j] * scale;\n      }\n      outputArray = scaled;\n    }\n    return outputArray;\n  }\n  _createCubicSplineTrackInterpolant(track) {\n    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n      const interpolantType = this instanceof three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n    };\n    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n  }\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n  if (attributes.POSITION !== void 0) {\n    const accessor = parser.json.accessors[attributes.POSITION];\n    const min = accessor.min;\n    const max = accessor.max;\n    if (min !== void 0 && max !== void 0) {\n      box.set(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(min[0], min[1], min[2]), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(max[0], max[1], max[2]));\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n        box.min.multiplyScalar(boxScale);\n        box.max.multiplyScalar(boxScale);\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n      return;\n    }\n  } else {\n    return;\n  }\n  const targets = primitiveDef.targets;\n  if (targets !== void 0) {\n    const maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i];\n      if (target.POSITION !== void 0) {\n        const accessor = parser.json.accessors[target.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        if (min !== void 0 && max !== void 0) {\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n            vector.multiplyScalar(boxScale);\n          }\n          maxDisplacement.max(vector);\n        } else {\n          console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n        }\n      }\n    }\n    box.expandByVector(maxDisplacement);\n  }\n  geometry.boundingBox = box;\n  const sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n  box.getCenter(sphere.center);\n  sphere.radius = box.min.distanceTo(box.max) / 2;\n  geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const pending = [];\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n      geometry.setAttribute(attributeName, accessor);\n    });\n  }\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n    if (threeAttributeName in geometry.attributes)\n      continue;\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n  }\n  if (primitiveDef.indices !== void 0 && !geometry.index) {\n    const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor2) {\n      geometry.setIndex(accessor2);\n    });\n    pending.push(accessor);\n  }\n  assignExtrasToUserData(geometry, primitiveDef);\n  computeBounds(geometry, primitiveDef, parser);\n  return Promise.all(pending).then(function() {\n    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n  });\n}\n\n//# sourceMappingURL=GLTFLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdGhyZWUtc3RkbGliQDIuMzUuMl90aHJlZUAwLjE3Mi4wL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbG9hZGVycy9HTFRGTG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTA5QjtBQUNwNUI7QUFDbEI7QUFDSztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5Q0FBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBCQUEwQiw4Q0FBVztBQUNyQyxxQkFBcUIsOENBQVc7QUFDaEMsTUFBTTtBQUNOLHFCQUFxQiw4Q0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkNBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFD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a0RBQWtELDBDQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3Q0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0NBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdDQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBLGdDQUFnQywwQ0FBTztBQUN2Qyx1QkFBdUIsMENBQU87QUFDOUIseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5Q0FBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFHRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvamVyZW15ai9Eb2N1bWVudHMvc291cmNlL3JlcG9zL3NoYWRlcnMvbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVlLXN0ZGxpYkAyLjM1LjJfdGhyZWVAMC4xNzIuMC9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvR0xURkxvYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2FkZXIsIExvYWRlclV0aWxzLCBGaWxlTG9hZGVyLCBDb2xvciwgU3BvdExpZ2h0LCBQb2ludExpZ2h0LCBEaXJlY3Rpb25hbExpZ2h0LCBNZXNoQmFzaWNNYXRlcmlhbCwgTWVzaFBoeXNpY2FsTWF0ZXJpYWwsIFZlY3RvcjIsIE1hdHJpeDQsIFZlY3RvcjMsIFF1YXRlcm5pb24sIEluc3RhbmNlZE1lc2gsIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSwgT2JqZWN0M0QsIFRleHR1cmVMb2FkZXIsIEltYWdlQml0bWFwTG9hZGVyLCBCdWZmZXJBdHRyaWJ1dGUsIEludGVybGVhdmVkQnVmZmVyLCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSwgTGluZWFyRmlsdGVyLCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsIFJlcGVhdFdyYXBwaW5nLCBQb2ludHNNYXRlcmlhbCwgTWF0ZXJpYWwsIExpbmVCYXNpY01hdGVyaWFsLCBNZXNoU3RhbmRhcmRNYXRlcmlhbCwgRG91YmxlU2lkZSwgUHJvcGVydHlCaW5kaW5nLCBCdWZmZXJHZW9tZXRyeSwgU2tpbm5lZE1lc2gsIE1lc2gsIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSwgVHJpYW5nbGVGYW5EcmF3TW9kZSwgTGluZVNlZ21lbnRzLCBMaW5lLCBMaW5lTG9vcCwgUG9pbnRzLCBHcm91cCwgUGVyc3BlY3RpdmVDYW1lcmEsIE1hdGhVdGlscywgT3J0aG9ncmFwaGljQ2FtZXJhLCBTa2VsZXRvbiwgQW5pbWF0aW9uQ2xpcCwgQm9uZSwgSW50ZXJwb2xhdGVMaW5lYXIsIE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLCBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLCBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLCBJbnRlcnBvbGF0ZURpc2NyZXRlLCBGcm9udFNpZGUsIFRleHR1cmUsIFZlY3RvcktleWZyYW1lVHJhY2ssIE51bWJlcktleWZyYW1lVHJhY2ssIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBCb3gzLCBTcGhlcmUsIEludGVycG9sYW50IH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyB0b1RyaWFuZ2xlc0RyYXdNb2RlIH0gZnJvbSBcIi4uL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanNcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3BvbHlmaWxsL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgZGVjb2RlVGV4dCB9IGZyb20gXCIuLi9fcG9seWZpbGwvTG9hZGVyVXRpbHMuanNcIjtcbmNvbnN0IFNSR0JDb2xvclNwYWNlID0gXCJzcmdiXCI7XG5jb25zdCBMaW5lYXJTUkdCQ29sb3JTcGFjZSA9IFwic3JnYi1saW5lYXJcIjtcbmNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG5jb25zdCBMaW5lYXJFbmNvZGluZyA9IDNlMztcbmNsYXNzIEdMVEZMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG4gICAgc3VwZXIobWFuYWdlcik7XG4gICAgdGhpcy5kcmFjb0xvYWRlciA9IG51bGw7XG4gICAgdGhpcy5rdHgyTG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLm1lc2hvcHREZWNvZGVyID0gbnVsbDtcbiAgICB0aGlzLnBsdWdpbkNhbGxiYWNrcyA9IFtdO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNDbGVhcmNvYXRFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzRGlzcGVyc2lvbkV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZUZXh0dXJlQmFzaXNVRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURlRleHR1cmVXZWJQRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURlRleHR1cmVBVklGRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1NoZWVuRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNWb2x1bWVFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzSW9yRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0VtaXNzaXZlU3RyZW5ndGhFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzU3BlY3VsYXJFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzSXJpZGVzY2VuY2VFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzQW5pc290cm9weUV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNCdW1wRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURkxpZ2h0c0V4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNZXNob3B0Q29tcHJlc3Npb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWVzaEdwdUluc3RhbmNpbmcocGFyc2VyKTtcbiAgICB9KTtcbiAgfVxuICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzO1xuICAgIGxldCByZXNvdXJjZVBhdGg7XG4gICAgaWYgKHRoaXMucmVzb3VyY2VQYXRoICE9PSBcIlwiKSB7XG4gICAgICByZXNvdXJjZVBhdGggPSB0aGlzLnJlc291cmNlUGF0aDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGF0aCAhPT0gXCJcIikge1xuICAgICAgY29uc3QgcmVsYXRpdmVVcmwgPSBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSh1cmwpO1xuICAgICAgcmVzb3VyY2VQYXRoID0gTG9hZGVyVXRpbHMucmVzb2x2ZVVSTChyZWxhdGl2ZVVybCwgdGhpcy5wYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb3VyY2VQYXRoID0gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UodXJsKTtcbiAgICB9XG4gICAgdGhpcy5tYW5hZ2VyLml0ZW1TdGFydCh1cmwpO1xuICAgIGNvbnN0IF9vbkVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgfTtcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZShcImFycmF5YnVmZmVyXCIpO1xuICAgIGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgbG9hZGVyLmxvYWQoXG4gICAgICB1cmwsXG4gICAgICBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2NvcGUucGFyc2UoXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcmVzb3VyY2VQYXRoLFxuICAgICAgICAgICAgZnVuY3Rpb24oZ2x0Zikge1xuICAgICAgICAgICAgICBvbkxvYWQoZ2x0Zik7XG4gICAgICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkVycm9yXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIF9vbkVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Qcm9ncmVzcyxcbiAgICAgIF9vbkVycm9yXG4gICAgKTtcbiAgfVxuICBzZXREUkFDT0xvYWRlcihkcmFjb0xvYWRlcikge1xuICAgIHRoaXMuZHJhY29Mb2FkZXIgPSBkcmFjb0xvYWRlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRERFNMb2FkZXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUSFJFRS5HTFRGTG9hZGVyOiBcIk1TRlRfdGV4dHVyZV9kZHNcIiBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgdXBkYXRlIHRvIFwiS0hSX3RleHR1cmVfYmFzaXN1XCIuJyk7XG4gIH1cbiAgc2V0S1RYMkxvYWRlcihrdHgyTG9hZGVyKSB7XG4gICAgdGhpcy5rdHgyTG9hZGVyID0ga3R4MkxvYWRlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRNZXNob3B0RGVjb2RlcihtZXNob3B0RGVjb2Rlcikge1xuICAgIHRoaXMubWVzaG9wdERlY29kZXIgPSBtZXNob3B0RGVjb2RlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWdpc3RlcihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnBsdWdpbkNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMucGx1Z2luQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB1bnJlZ2lzdGVyKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spICE9PSAtMSkge1xuICAgICAgdGhpcy5wbHVnaW5DYWxsYmFja3Muc3BsaWNlKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcGFyc2UoZGF0YSwgcGF0aCwgb25Mb2FkLCBvbkVycm9yKSB7XG4gICAgbGV0IGpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuICAgIGNvbnN0IHBsdWdpbnMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGpzb24gPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBjb25zdCBtYWdpYyA9IGRlY29kZVRleHQobmV3IFVpbnQ4QXJyYXkoZGF0YS5zbGljZSgwLCA0KSkpO1xuICAgICAgaWYgKG1hZ2ljID09PSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEZdID0gbmV3IEdMVEZCaW5hcnlFeHRlbnNpb24oZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaWYgKG9uRXJyb3IpXG4gICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAganNvbiA9IEpTT04ucGFyc2UoZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURl0uY29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShkZWNvZGVUZXh0KG5ldyBVaW50OEFycmF5KGRhdGEpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGpzb24gPSBkYXRhO1xuICAgIH1cbiAgICBpZiAoanNvbi5hc3NldCA9PT0gdm9pZCAwIHx8IGpzb24uYXNzZXQudmVyc2lvblswXSA8IDIpIHtcbiAgICAgIGlmIChvbkVycm9yKVxuICAgICAgICBvbkVycm9yKG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGFzc2V0LiBnbFRGIHZlcnNpb25zID49Mi4wIGFyZSBzdXBwb3J0ZWQuXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IEdMVEZQYXJzZXIoanNvbiwge1xuICAgICAgcGF0aDogcGF0aCB8fCB0aGlzLnJlc291cmNlUGF0aCB8fCBcIlwiLFxuICAgICAgY3Jvc3NPcmlnaW46IHRoaXMuY3Jvc3NPcmlnaW4sXG4gICAgICByZXF1ZXN0SGVhZGVyOiB0aGlzLnJlcXVlc3RIZWFkZXIsXG4gICAgICBtYW5hZ2VyOiB0aGlzLm1hbmFnZXIsXG4gICAgICBrdHgyTG9hZGVyOiB0aGlzLmt0eDJMb2FkZXIsXG4gICAgICBtZXNob3B0RGVjb2RlcjogdGhpcy5tZXNob3B0RGVjb2RlclxuICAgIH0pO1xuICAgIHBhcnNlci5maWxlTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2luQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnBsdWdpbkNhbGxiYWNrc1tpXShwYXJzZXIpO1xuICAgICAgaWYgKCFwbHVnaW4ubmFtZSlcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEludmFsaWQgcGx1Z2luIGZvdW5kOiBtaXNzaW5nIG5hbWVcIik7XG4gICAgICBwbHVnaW5zW3BsdWdpbi5uYW1lXSA9IHBsdWdpbjtcbiAgICAgIGV4dGVuc2lvbnNbcGx1Z2luLm5hbWVdID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGpzb24uZXh0ZW5zaW9uc1VzZWQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5leHRlbnNpb25zVXNlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBleHRlbnNpb25OYW1lID0ganNvbi5leHRlbnNpb25zVXNlZFtpXTtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uc1JlcXVpcmVkID0ganNvbi5leHRlbnNpb25zUmVxdWlyZWQgfHwgW107XG4gICAgICAgIHN3aXRjaCAoZXh0ZW5zaW9uTmFtZSkge1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUOlxuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXSA9IG5ldyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjpcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBuZXcgR0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uKGpzb24sIHRoaXMuZHJhY29Mb2FkZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STTpcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBuZXcgR0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfTUVTSF9RVUFOVElaQVRJT046XG4gICAgICAgICAgICBleHRlbnNpb25zW2V4dGVuc2lvbk5hbWVdID0gbmV3IEdMVEZNZXNoUXVhbnRpemF0aW9uRXh0ZW5zaW9uKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKGV4dGVuc2lvbk5hbWUpID49IDAgJiYgcGx1Z2luc1tleHRlbnNpb25OYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuR0xURkxvYWRlcjogVW5rbm93biBleHRlbnNpb24gXCInICsgZXh0ZW5zaW9uTmFtZSArICdcIi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwYXJzZXIuc2V0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgICBwYXJzZXIuc2V0UGx1Z2lucyhwbHVnaW5zKTtcbiAgICBwYXJzZXIucGFyc2Uob25Mb2FkLCBvbkVycm9yKTtcbiAgfVxuICBwYXJzZUFzeW5jKGRhdGEsIHBhdGgpIHtcbiAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgc2NvcGUucGFyc2UoZGF0YSwgcGF0aCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gR0xURlJlZ2lzdHJ5KCkge1xuICBsZXQgb2JqZWN0cyA9IHt9O1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0c1trZXldO1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbihrZXksIG9iamVjdCkge1xuICAgICAgb2JqZWN0c1trZXldID0gb2JqZWN0O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGRlbGV0ZSBvYmplY3RzW2tleV07XG4gICAgfSxcbiAgICByZW1vdmVBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgb2JqZWN0cyA9IHt9O1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IEVYVEVOU0lPTlMgPSB7XG4gIEtIUl9CSU5BUllfR0xURjogXCJLSFJfYmluYXJ5X2dsVEZcIixcbiAgS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT046IFwiS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb25cIixcbiAgS0hSX0xJR0hUU19QVU5DVFVBTDogXCJLSFJfbGlnaHRzX3B1bmN0dWFsXCIsXG4gIEtIUl9NQVRFUklBTFNfQ0xFQVJDT0FUOiBcIktIUl9tYXRlcmlhbHNfY2xlYXJjb2F0XCIsXG4gIEtIUl9NQVRFUklBTFNfRElTUEVSU0lPTjogXCJLSFJfbWF0ZXJpYWxzX2Rpc3BlcnNpb25cIixcbiAgS0hSX01BVEVSSUFMU19JT1I6IFwiS0hSX21hdGVyaWFsc19pb3JcIixcbiAgS0hSX01BVEVSSUFMU19TSEVFTjogXCJLSFJfbWF0ZXJpYWxzX3NoZWVuXCIsXG4gIEtIUl9NQVRFUklBTFNfU1BFQ1VMQVI6IFwiS0hSX21hdGVyaWFsc19zcGVjdWxhclwiLFxuICBLSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTjogXCJLSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvblwiLFxuICBLSFJfTUFURVJJQUxTX0lSSURFU0NFTkNFOiBcIktIUl9tYXRlcmlhbHNfaXJpZGVzY2VuY2VcIixcbiAgS0hSX01BVEVSSUFMU19BTklTT1RST1BZOiBcIktIUl9tYXRlcmlhbHNfYW5pc290cm9weVwiLFxuICBLSFJfTUFURVJJQUxTX1VOTElUOiBcIktIUl9tYXRlcmlhbHNfdW5saXRcIixcbiAgS0hSX01BVEVSSUFMU19WT0xVTUU6IFwiS0hSX21hdGVyaWFsc192b2x1bWVcIixcbiAgS0hSX1RFWFRVUkVfQkFTSVNVOiBcIktIUl90ZXh0dXJlX2Jhc2lzdVwiLFxuICBLSFJfVEVYVFVSRV9UUkFOU0ZPUk06IFwiS0hSX3RleHR1cmVfdHJhbnNmb3JtXCIsXG4gIEtIUl9NRVNIX1FVQU5USVpBVElPTjogXCJLSFJfbWVzaF9xdWFudGl6YXRpb25cIixcbiAgS0hSX01BVEVSSUFMU19FTUlTU0lWRV9TVFJFTkdUSDogXCJLSFJfbWF0ZXJpYWxzX2VtaXNzaXZlX3N0cmVuZ3RoXCIsXG4gIEVYVF9NQVRFUklBTFNfQlVNUDogXCJFWFRfbWF0ZXJpYWxzX2J1bXBcIixcbiAgRVhUX1RFWFRVUkVfV0VCUDogXCJFWFRfdGV4dHVyZV93ZWJwXCIsXG4gIEVYVF9URVhUVVJFX0FWSUY6IFwiRVhUX3RleHR1cmVfYXZpZlwiLFxuICBFWFRfTUVTSE9QVF9DT01QUkVTU0lPTjogXCJFWFRfbWVzaG9wdF9jb21wcmVzc2lvblwiLFxuICBFWFRfTUVTSF9HUFVfSU5TVEFOQ0lORzogXCJFWFRfbWVzaF9ncHVfaW5zdGFuY2luZ1wiXG59O1xuY2xhc3MgR0xURkxpZ2h0c0V4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0xJR0hUU19QVU5DVFVBTDtcbiAgICB0aGlzLmNhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcbiAgfVxuICBfbWFya0RlZnMoKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3Qgbm9kZURlZnMgPSB0aGlzLnBhcnNlci5qc29uLm5vZGVzIHx8IFtdO1xuICAgIGZvciAobGV0IG5vZGVJbmRleCA9IDAsIG5vZGVMZW5ndGggPSBub2RlRGVmcy5sZW5ndGg7IG5vZGVJbmRleCA8IG5vZGVMZW5ndGg7IG5vZGVJbmRleCsrKSB7XG4gICAgICBjb25zdCBub2RlRGVmID0gbm9kZURlZnNbbm9kZUluZGV4XTtcbiAgICAgIGlmIChub2RlRGVmLmV4dGVuc2lvbnMgJiYgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0gJiYgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0ubGlnaHQgIT09IHZvaWQgMCkge1xuICAgICAgICBwYXJzZXIuX2FkZE5vZGVSZWYodGhpcy5jYWNoZSwgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0ubGlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfbG9hZExpZ2h0KGxpZ2h0SW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBjYWNoZUtleSA9IFwibGlnaHQ6XCIgKyBsaWdodEluZGV4O1xuICAgIGxldCBkZXBlbmRlbmN5ID0gcGFyc2VyLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKGRlcGVuZGVuY3kpXG4gICAgICByZXR1cm4gZGVwZW5kZW5jeTtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IGpzb24uZXh0ZW5zaW9ucyAmJiBqc29uLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSB8fCB7fTtcbiAgICBjb25zdCBsaWdodERlZnMgPSBleHRlbnNpb25zLmxpZ2h0cyB8fCBbXTtcbiAgICBjb25zdCBsaWdodERlZiA9IGxpZ2h0RGVmc1tsaWdodEluZGV4XTtcbiAgICBsZXQgbGlnaHROb2RlO1xuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKDE2Nzc3MjE1KTtcbiAgICBpZiAobGlnaHREZWYuY29sb3IgIT09IHZvaWQgMClcbiAgICAgIGNvbG9yLnNldFJHQihsaWdodERlZi5jb2xvclswXSwgbGlnaHREZWYuY29sb3JbMV0sIGxpZ2h0RGVmLmNvbG9yWzJdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgY29uc3QgcmFuZ2UgPSBsaWdodERlZi5yYW5nZSAhPT0gdm9pZCAwID8gbGlnaHREZWYucmFuZ2UgOiAwO1xuICAgIHN3aXRjaCAobGlnaHREZWYudHlwZSkge1xuICAgICAgY2FzZSBcImRpcmVjdGlvbmFsXCI6XG4gICAgICAgIGxpZ2h0Tm9kZSA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KGNvbG9yKTtcbiAgICAgICAgbGlnaHROb2RlLnRhcmdldC5wb3NpdGlvbi5zZXQoMCwgMCwgLTEpO1xuICAgICAgICBsaWdodE5vZGUuYWRkKGxpZ2h0Tm9kZS50YXJnZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb2ludFwiOlxuICAgICAgICBsaWdodE5vZGUgPSBuZXcgUG9pbnRMaWdodChjb2xvcik7XG4gICAgICAgIGxpZ2h0Tm9kZS5kaXN0YW5jZSA9IHJhbmdlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzcG90XCI6XG4gICAgICAgIGxpZ2h0Tm9kZSA9IG5ldyBTcG90TGlnaHQoY29sb3IpO1xuICAgICAgICBsaWdodE5vZGUuZGlzdGFuY2UgPSByYW5nZTtcbiAgICAgICAgbGlnaHREZWYuc3BvdCA9IGxpZ2h0RGVmLnNwb3QgfHwge307XG4gICAgICAgIGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgPSBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlICE9PSB2b2lkIDAgPyBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlIDogMDtcbiAgICAgICAgbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSA9IGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgIT09IHZvaWQgMCA/IGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgOiBNYXRoLlBJIC8gNDtcbiAgICAgICAgbGlnaHROb2RlLmFuZ2xlID0gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZTtcbiAgICAgICAgbGlnaHROb2RlLnBlbnVtYnJhID0gMSAtIGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgLyBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlO1xuICAgICAgICBsaWdodE5vZGUudGFyZ2V0LnBvc2l0aW9uLnNldCgwLCAwLCAtMSk7XG4gICAgICAgIGxpZ2h0Tm9kZS5hZGQobGlnaHROb2RlLnRhcmdldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5leHBlY3RlZCBsaWdodCB0eXBlOiBcIiArIGxpZ2h0RGVmLnR5cGUpO1xuICAgIH1cbiAgICBsaWdodE5vZGUucG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICAgIGxpZ2h0Tm9kZS5kZWNheSA9IDI7XG4gICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShsaWdodE5vZGUsIGxpZ2h0RGVmKTtcbiAgICBpZiAobGlnaHREZWYuaW50ZW5zaXR5ICE9PSB2b2lkIDApXG4gICAgICBsaWdodE5vZGUuaW50ZW5zaXR5ID0gbGlnaHREZWYuaW50ZW5zaXR5O1xuICAgIGxpZ2h0Tm9kZS5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUobGlnaHREZWYubmFtZSB8fCBcImxpZ2h0X1wiICsgbGlnaHRJbmRleCk7XG4gICAgZGVwZW5kZW5jeSA9IFByb21pc2UucmVzb2x2ZShsaWdodE5vZGUpO1xuICAgIHBhcnNlci5jYWNoZS5hZGQoY2FjaGVLZXksIGRlcGVuZGVuY3kpO1xuICAgIHJldHVybiBkZXBlbmRlbmN5O1xuICB9XG4gIGdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpIHtcbiAgICBpZiAodHlwZSAhPT0gXCJsaWdodFwiKVxuICAgICAgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLl9sb2FkTGlnaHQoaW5kZXgpO1xuICB9XG4gIGNyZWF0ZU5vZGVBdHRhY2htZW50KG5vZGVJbmRleCkge1xuICAgIGNvbnN0IHNlbGYyID0gdGhpcztcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBjb25zdCBsaWdodERlZiA9IG5vZGVEZWYuZXh0ZW5zaW9ucyAmJiBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSB8fCB7fTtcbiAgICBjb25zdCBsaWdodEluZGV4ID0gbGlnaHREZWYubGlnaHQ7XG4gICAgaWYgKGxpZ2h0SW5kZXggPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLl9sb2FkTGlnaHQobGlnaHRJbmRleCkudGhlbihmdW5jdGlvbihsaWdodCkge1xuICAgICAgcmV0dXJuIHBhcnNlci5fZ2V0Tm9kZVJlZihzZWxmMi5jYWNoZSwgbGlnaHRJbmRleCwgbGlnaHQpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQ7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKCkge1xuICAgIHJldHVybiBNZXNoQmFzaWNNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRQYXJhbXMobWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIpIHtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgbWF0ZXJpYWxQYXJhbXMuY29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG4gICAgbWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IDE7XG4gICAgY29uc3QgbWV0YWxsaWNSb3VnaG5lc3MgPSBtYXRlcmlhbERlZi5wYnJNZXRhbGxpY1JvdWdobmVzcztcbiAgICBpZiAobWV0YWxsaWNSb3VnaG5lc3MpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcikpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3I7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmNvbG9yLnNldFJHQihhcnJheVswXSwgYXJyYXlbMV0sIGFycmF5WzJdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSBhcnJheVszXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcIm1hcFwiLCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNFbWlzc2l2ZVN0cmVuZ3RoRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0VNSVNTSVZFX1NUUkVOR1RIO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgZW1pc3NpdmVTdHJlbmd0aCA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5lbWlzc2l2ZVN0cmVuZ3RoO1xuICAgIGlmIChlbWlzc2l2ZVN0cmVuZ3RoICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlSW50ZW5zaXR5ID0gZW1pc3NpdmVTdHJlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0NMRUFSQ09BVDtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdEZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXQgPSBleHRlbnNpb24uY2xlYXJjb2F0RmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdFRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImNsZWFyY29hdE1hcFwiLCBleHRlbnNpb24uY2xlYXJjb2F0VGV4dHVyZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc0ZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXRSb3VnaG5lc3MgPSBleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImNsZWFyY29hdFJvdWdobmVzc01hcFwiLCBleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImNsZWFyY29hdE5vcm1hbE1hcFwiLCBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSkpO1xuICAgICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZS5zY2FsZTtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMihzY2FsZSwgc2NhbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNEaXNwZXJzaW9uRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0RJU1BFUlNJT047XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5kaXNwZXJzaW9uID0gZXh0ZW5zaW9uLmRpc3BlcnNpb24gIT09IHZvaWQgMCA/IGV4dGVuc2lvbi5kaXNwZXJzaW9uIDogMDtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNJcmlkZXNjZW5jZUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19JUklERVNDRU5DRTtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlID0gZXh0ZW5zaW9uLmlyaWRlc2NlbmNlRmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiaXJpZGVzY2VuY2VNYXBcIiwgZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGV4dHVyZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlSW9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlSU9SID0gZXh0ZW5zaW9uLmlyaWRlc2NlbmNlSW9yO1xuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9PT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlID0gWzEwMCwgNDAwXTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0gIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZVswXSA9IGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW07XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbMV0gPSBleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwXCIsIGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmUpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNTaGVlbkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19TSEVFTjtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCk7XG4gICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW5Sb3VnaG5lc3MgPSAwO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuID0gMTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi5zaGVlbkNvbG9yRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGNvbG9yRmFjdG9yID0gZXh0ZW5zaW9uLnNoZWVuQ29sb3JGYWN0b3I7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5zaGVlbkNvbG9yLnNldFJHQihjb2xvckZhY3RvclswXSwgY29sb3JGYWN0b3JbMV0sIGNvbG9yRmFjdG9yWzJdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW5Sb3VnaG5lc3MgPSBleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NGYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uc2hlZW5Db2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInNoZWVuQ29sb3JNYXBcIiwgZXh0ZW5zaW9uLnNoZWVuQ29sb3JUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwic2hlZW5Sb3VnaG5lc3NNYXBcIiwgZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzVGV4dHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNUcmFuc21pc3Npb25FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVFJBTlNNSVNTSU9OO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24udHJhbnNtaXNzaW9uRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnRyYW5zbWlzc2lvbiA9IGV4dGVuc2lvbi50cmFuc21pc3Npb25GYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24udHJhbnNtaXNzaW9uVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwidHJhbnNtaXNzaW9uTWFwXCIsIGV4dGVuc2lvbi50cmFuc21pc3Npb25UZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1ZvbHVtZUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19WT0xVTUU7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMudGhpY2tuZXNzID0gZXh0ZW5zaW9uLnRoaWNrbmVzc0ZhY3RvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLnRoaWNrbmVzc0ZhY3RvciA6IDA7XG4gICAgaWYgKGV4dGVuc2lvbi50aGlja25lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJ0aGlja25lc3NNYXBcIiwgZXh0ZW5zaW9uLnRoaWNrbmVzc1RleHR1cmUpKTtcbiAgICB9XG4gICAgbWF0ZXJpYWxQYXJhbXMuYXR0ZW51YXRpb25EaXN0YW5jZSA9IGV4dGVuc2lvbi5hdHRlbnVhdGlvbkRpc3RhbmNlIHx8IEluZmluaXR5O1xuICAgIGNvbnN0IGNvbG9yQXJyYXkgPSBleHRlbnNpb24uYXR0ZW51YXRpb25Db2xvciB8fCBbMSwgMSwgMV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuYXR0ZW51YXRpb25Db2xvciA9IG5ldyBDb2xvcigpLnNldFJHQihcbiAgICAgIGNvbG9yQXJyYXlbMF0sXG4gICAgICBjb2xvckFycmF5WzFdLFxuICAgICAgY29sb3JBcnJheVsyXSxcbiAgICAgIExpbmVhclNSR0JDb2xvclNwYWNlXG4gICAgKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNJb3JFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfSU9SO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuaW9yID0gZXh0ZW5zaW9uLmlvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLmlvciA6IDEuNTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNTcGVjdWxhckV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19TUEVDVUxBUjtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5zcGVjdWxhckludGVuc2l0eSA9IGV4dGVuc2lvbi5zcGVjdWxhckZhY3RvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLnNwZWN1bGFyRmFjdG9yIDogMTtcbiAgICBpZiAoZXh0ZW5zaW9uLnNwZWN1bGFyVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwic3BlY3VsYXJJbnRlbnNpdHlNYXBcIiwgZXh0ZW5zaW9uLnNwZWN1bGFyVGV4dHVyZSkpO1xuICAgIH1cbiAgICBjb25zdCBjb2xvckFycmF5ID0gZXh0ZW5zaW9uLnNwZWN1bGFyQ29sb3JGYWN0b3IgfHwgWzEsIDEsIDFdO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFyQ29sb3IgPSBuZXcgQ29sb3IoKS5zZXRSR0IoY29sb3JBcnJheVswXSwgY29sb3JBcnJheVsxXSwgY29sb3JBcnJheVsyXSwgTGluZWFyU1JHQkNvbG9yU3BhY2UpO1xuICAgIGlmIChleHRlbnNpb24uc3BlY3VsYXJDb2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICBwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJzcGVjdWxhckNvbG9yTWFwXCIsIGV4dGVuc2lvbi5zcGVjdWxhckNvbG9yVGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNCdW1wRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUFURVJJQUxTX0JVTVA7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuYnVtcFNjYWxlID0gZXh0ZW5zaW9uLmJ1bXBGYWN0b3IgIT09IHZvaWQgMCA/IGV4dGVuc2lvbi5idW1wRmFjdG9yIDogMTtcbiAgICBpZiAoZXh0ZW5zaW9uLmJ1bXBUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJidW1wTWFwXCIsIGV4dGVuc2lvbi5idW1wVGV4dHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNBbmlzb3Ryb3B5RXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0FOSVNPVFJPUFk7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi5hbmlzb3Ryb3B5U3RyZW5ndGggIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuYW5pc290cm9weSA9IGV4dGVuc2lvbi5hbmlzb3Ryb3B5U3RyZW5ndGg7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uYW5pc290cm9weVJvdGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmFuaXNvdHJvcHlSb3RhdGlvbiA9IGV4dGVuc2lvbi5hbmlzb3Ryb3B5Um90YXRpb247XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uYW5pc290cm9weVRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImFuaXNvdHJvcHlNYXBcIiwgZXh0ZW5zaW9uLmFuaXNvdHJvcHlUZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVCYXNpc1VFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9URVhUVVJFX0JBU0lTVTtcbiAgfVxuICBsb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3QgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbdGV4dHVyZUluZGV4XTtcbiAgICBpZiAoIXRleHR1cmVEZWYuZXh0ZW5zaW9ucyB8fCAhdGV4dHVyZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBjb25zdCBsb2FkZXIgPSBwYXJzZXIub3B0aW9ucy5rdHgyTG9hZGVyO1xuICAgIGlmICghbG9hZGVyKSB7XG4gICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZih0aGlzLm5hbWUpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogc2V0S1RYMkxvYWRlciBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgbG9hZGluZyBLVFgyIHRleHR1cmVzXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIGV4dGVuc2lvbi5zb3VyY2UsIGxvYWRlcik7XG4gIH1cbn1cbmNsYXNzIEdMVEZUZXh0dXJlV2ViUEV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX1RFWFRVUkVfV0VCUDtcbiAgICB0aGlzLmlzU3VwcG9ydGVkID0gbnVsbDtcbiAgfVxuICBsb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGlmICghdGV4dHVyZURlZi5leHRlbnNpb25zIHx8ICF0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV07XG4gICAgY29uc3Qgc291cmNlID0ganNvbi5pbWFnZXNbZXh0ZW5zaW9uLnNvdXJjZV07XG4gICAgbGV0IGxvYWRlciA9IHBhcnNlci50ZXh0dXJlTG9hZGVyO1xuICAgIGlmIChzb3VyY2UudXJpKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gcGFyc2VyLm9wdGlvbnMubWFuYWdlci5nZXRIYW5kbGVyKHNvdXJjZS51cmkpO1xuICAgICAgaWYgKGhhbmRsZXIgIT09IG51bGwpXG4gICAgICAgIGxvYWRlciA9IGhhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRldGVjdFN1cHBvcnQoKS50aGVuKGZ1bmN0aW9uKGlzU3VwcG9ydGVkKSB7XG4gICAgICBpZiAoaXNTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIGV4dGVuc2lvbi5zb3VyY2UsIGxvYWRlcik7XG4gICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFdlYlAgcmVxdWlyZWQgYnkgYXNzZXQgYnV0IHVuc3VwcG9ydGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmUodGV4dHVyZUluZGV4KTtcbiAgICB9KTtcbiAgfVxuICBkZXRlY3RTdXBwb3J0KCkge1xuICAgIGlmICghdGhpcy5pc1N1cHBvcnRlZCkge1xuICAgICAgdGhpcy5pc1N1cHBvcnRlZCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1hZ2Uuc3JjID0gXCJkYXRhOmltYWdlL3dlYnA7YmFzZTY0LFVrbEdSaUlBQUFCWFJVSlFWbEE0SUJZQUFBQXdBUUNkQVNvQkFBRUFEc0QrSmFRQUEzQUFBQUFBXCI7XG4gICAgICAgIGltYWdlLm9ubG9hZCA9IGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXNvbHZlKGltYWdlLmhlaWdodCA9PT0gMSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNTdXBwb3J0ZWQ7XG4gIH1cbn1cbmNsYXNzIEdMVEZUZXh0dXJlQVZJRkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX1RFWFRVUkVfQVZJRjtcbiAgICB0aGlzLmlzU3VwcG9ydGVkID0gbnVsbDtcbiAgfVxuICBsb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGlmICghdGV4dHVyZURlZi5leHRlbnNpb25zIHx8ICF0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV07XG4gICAgY29uc3Qgc291cmNlID0ganNvbi5pbWFnZXNbZXh0ZW5zaW9uLnNvdXJjZV07XG4gICAgbGV0IGxvYWRlciA9IHBhcnNlci50ZXh0dXJlTG9hZGVyO1xuICAgIGlmIChzb3VyY2UudXJpKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gcGFyc2VyLm9wdGlvbnMubWFuYWdlci5nZXRIYW5kbGVyKHNvdXJjZS51cmkpO1xuICAgICAgaWYgKGhhbmRsZXIgIT09IG51bGwpXG4gICAgICAgIGxvYWRlciA9IGhhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRldGVjdFN1cHBvcnQoKS50aGVuKGZ1bmN0aW9uKGlzU3VwcG9ydGVkKSB7XG4gICAgICBpZiAoaXNTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIGV4dGVuc2lvbi5zb3VyY2UsIGxvYWRlcik7XG4gICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEFWSUYgcmVxdWlyZWQgYnkgYXNzZXQgYnV0IHVuc3VwcG9ydGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmUodGV4dHVyZUluZGV4KTtcbiAgICB9KTtcbiAgfVxuICBkZXRlY3RTdXBwb3J0KCkge1xuICAgIGlmICghdGhpcy5pc1N1cHBvcnRlZCkge1xuICAgICAgdGhpcy5pc1N1cHBvcnRlZCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1hZ2Uuc3JjID0gXCJkYXRhOmltYWdlL2F2aWY7YmFzZTY0LEFBQUFJR1owZVhCaGRtbG1BQUFBQUdGMmFXWnRhV1l4YldsaFprMUJNVUlBQUFEeWJXVjBZUUFBQUFBQUFBQW9hR1JzY2dBQUFBQUFBQUFBY0dsamRBQUFBQUFBQUFBQUFBQUFBR3hwWW1GMmFXWUFBQUFBRG5CcGRHMEFBQUFBQUFFQUFBQWVhV3h2WXdBQUFBQkVBQUFCQUFFQUFBQUJBQUFCR2dBQUFCY0FBQUFvYVdsdVpnQUFBQUFBQVFBQUFCcHBibVpsQWdBQUFBQUJBQUJoZGpBeFEyOXNiM0lBQUFBQWFtbHdjbkFBQUFCTGFYQmpid0FBQUJScGMzQmxBQUFBQUFBQUFBRUFBQUFCQUFBQUVIQnBlR2tBQUFBQUF3Z0lDQUFBQUF4aGRqRkRnUUFNQUFBQUFCTmpiMnh5Ym1Oc2VBQUNBQUlBQm9BQUFBQVhhWEJ0WVFBQUFBQUFBQUFCQUFFRUFRS0RCQUFBQUI5dFpHRjBFZ0FLQ0JnQUJvZ1FFRFFnTWdrUUFBQUFCOGRTTGZJPVwiO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVzb2x2ZShpbWFnZS5oZWlnaHQgPT09IDEpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzU3VwcG9ydGVkO1xuICB9XG59XG5jbGFzcyBHTFRGTWVzaG9wdENvbXByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUVTSE9QVF9DT01QUkVTU0lPTjtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgfVxuICBsb2FkQnVmZmVyVmlldyhpbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLnBhcnNlci5qc29uO1xuICAgIGNvbnN0IGJ1ZmZlclZpZXcgPSBqc29uLmJ1ZmZlclZpZXdzW2luZGV4XTtcbiAgICBpZiAoYnVmZmVyVmlldy5leHRlbnNpb25zICYmIGJ1ZmZlclZpZXcuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICBjb25zdCBleHRlbnNpb25EZWYgPSBidWZmZXJWaWV3LmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMucGFyc2VyLmdldERlcGVuZGVuY3koXCJidWZmZXJcIiwgZXh0ZW5zaW9uRGVmLmJ1ZmZlcik7XG4gICAgICBjb25zdCBkZWNvZGVyID0gdGhpcy5wYXJzZXIub3B0aW9ucy5tZXNob3B0RGVjb2RlcjtcbiAgICAgIGlmICghZGVjb2RlciB8fCAhZGVjb2Rlci5zdXBwb3J0ZWQpIHtcbiAgICAgICAgaWYgKGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YodGhpcy5uYW1lKSA+PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogc2V0TWVzaG9wdERlY29kZXIgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgY29tcHJlc3NlZCBmaWxlc1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlci50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gZXh0ZW5zaW9uRGVmLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGV4dGVuc2lvbkRlZi5ieXRlTGVuZ3RoIHx8IDA7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gZXh0ZW5zaW9uRGVmLmNvdW50O1xuICAgICAgICBjb25zdCBzdHJpZGUgPSBleHRlbnNpb25EZWYuYnl0ZVN0cmlkZTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkocmVzLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgICAgaWYgKGRlY29kZXIuZGVjb2RlR2x0ZkJ1ZmZlckFzeW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlR2x0ZkJ1ZmZlckFzeW5jKGNvdW50LCBzdHJpZGUsIHNvdXJjZSwgZXh0ZW5zaW9uRGVmLm1vZGUsIGV4dGVuc2lvbkRlZi5maWx0ZXIpLnRoZW4oZnVuY3Rpb24ocmVzMikge1xuICAgICAgICAgICAgcmV0dXJuIHJlczIuYnVmZmVyO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZWNvZGVyLnJlYWR5LnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoY291bnQgKiBzdHJpZGUpO1xuICAgICAgICAgICAgZGVjb2Rlci5kZWNvZGVHbHRmQnVmZmVyKFxuICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShyZXN1bHQpLFxuICAgICAgICAgICAgICBjb3VudCxcbiAgICAgICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgIGV4dGVuc2lvbkRlZi5tb2RlLFxuICAgICAgICAgICAgICBleHRlbnNpb25EZWYuZmlsdGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgR0xURk1lc2hHcHVJbnN0YW5jaW5nIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUVTSF9HUFVfSU5TVEFOQ0lORztcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgfVxuICBjcmVhdGVOb2RlTWVzaChub2RlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5wYXJzZXIuanNvbjtcbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGlmICghbm9kZURlZi5leHRlbnNpb25zIHx8ICFub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSB8fCBub2RlRGVmLm1lc2ggPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG1lc2hEZWYgPSBqc29uLm1lc2hlc1tub2RlRGVmLm1lc2hdO1xuICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIG1lc2hEZWYucHJpbWl0aXZlcykge1xuICAgICAgaWYgKHByaW1pdGl2ZS5tb2RlICE9PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVTICYmIHByaW1pdGl2ZS5tb2RlICE9PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfU1RSSVAgJiYgcHJpbWl0aXZlLm1vZGUgIT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4gJiYgcHJpbWl0aXZlLm1vZGUgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uRGVmID0gbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgY29uc3QgYXR0cmlidXRlc0RlZiA9IGV4dGVuc2lvbkRlZi5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlc0RlZikge1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICB0aGlzLnBhcnNlci5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgYXR0cmlidXRlc0RlZltrZXldKS50aGVuKChhY2Nlc3NvcikgPT4ge1xuICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IGFjY2Vzc29yO1xuICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAocGVuZGluZy5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGVuZGluZy5wdXNoKHRoaXMucGFyc2VyLmNyZWF0ZU5vZGVNZXNoKG5vZGVJbmRleCkpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICBjb25zdCBub2RlT2JqZWN0ID0gcmVzdWx0cy5wb3AoKTtcbiAgICAgIGNvbnN0IG1lc2hlcyA9IG5vZGVPYmplY3QuaXNHcm91cCA/IG5vZGVPYmplY3QuY2hpbGRyZW4gOiBbbm9kZU9iamVjdF07XG4gICAgICBjb25zdCBjb3VudCA9IHJlc3VsdHNbMF0uY291bnQ7XG4gICAgICBjb25zdCBpbnN0YW5jZWRNZXNoZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgbWVzaCBvZiBtZXNoZXMpIHtcbiAgICAgICAgY29uc3QgbSA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICAgIGNvbnN0IHAgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICBjb25zdCBxID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICAgICAgY29uc3QgcyA9IG5ldyBWZWN0b3IzKDEsIDEsIDEpO1xuICAgICAgICBjb25zdCBpbnN0YW5jZWRNZXNoID0gbmV3IEluc3RhbmNlZE1lc2gobWVzaC5nZW9tZXRyeSwgbWVzaC5tYXRlcmlhbCwgY291bnQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlcy5UUkFOU0xBVElPTikge1xuICAgICAgICAgICAgcC5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZXMuVFJBTlNMQVRJT04sIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0cmlidXRlcy5ST1RBVElPTikge1xuICAgICAgICAgICAgcS5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZXMuUk9UQVRJT04sIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0cmlidXRlcy5TQ0FMRSkge1xuICAgICAgICAgICAgcy5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZXMuU0NBTEUsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnN0YW5jZWRNZXNoLnNldE1hdHJpeEF0KGksIG0uY29tcG9zZShwLCBxLCBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gXCJfQ09MT1JfMFwiKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgICAgIGluc3RhbmNlZE1lc2guaW5zdGFuY2VDb2xvciA9IG5ldyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUoYXR0ci5hcnJheSwgYXR0ci5pdGVtU2l6ZSwgYXR0ci5ub3JtYWxpemVkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWUgIT09IFwiVFJBTlNMQVRJT05cIiAmJiBhdHRyaWJ1dGVOYW1lICE9PSBcIlJPVEFUSU9OXCIgJiYgYXR0cmlidXRlTmFtZSAhPT0gXCJTQ0FMRVwiKSB7XG4gICAgICAgICAgICBtZXNoLmdlb21ldHJ5LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbChpbnN0YW5jZWRNZXNoLCBtZXNoKTtcbiAgICAgICAgdGhpcy5wYXJzZXIuYXNzaWduRmluYWxNYXRlcmlhbChpbnN0YW5jZWRNZXNoKTtcbiAgICAgICAgaW5zdGFuY2VkTWVzaGVzLnB1c2goaW5zdGFuY2VkTWVzaCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZU9iamVjdC5pc0dyb3VwKSB7XG4gICAgICAgIG5vZGVPYmplY3QuY2xlYXIoKTtcbiAgICAgICAgbm9kZU9iamVjdC5hZGQoLi4uaW5zdGFuY2VkTWVzaGVzKTtcbiAgICAgICAgcmV0dXJuIG5vZGVPYmplY3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zdGFuY2VkTWVzaGVzWzBdO1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQyA9IFwiZ2xURlwiO1xuY29uc3QgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIID0gMTI7XG5jb25zdCBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTID0geyBKU09OOiAxMzEzODIxNTE0LCBCSU46IDUxMzA1NjIgfTtcbmNsYXNzIEdMVEZCaW5hcnlFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEY7XG4gICAgdGhpcy5jb250ZW50ID0gbnVsbDtcbiAgICB0aGlzLmJvZHkgPSBudWxsO1xuICAgIGNvbnN0IGhlYWRlclZpZXcgPSBuZXcgRGF0YVZpZXcoZGF0YSwgMCwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIKTtcbiAgICB0aGlzLmhlYWRlciA9IHtcbiAgICAgIG1hZ2ljOiBkZWNvZGVUZXh0KG5ldyBVaW50OEFycmF5KGRhdGEuc2xpY2UoMCwgNCkpKSxcbiAgICAgIHZlcnNpb246IGhlYWRlclZpZXcuZ2V0VWludDMyKDQsIHRydWUpLFxuICAgICAgbGVuZ3RoOiBoZWFkZXJWaWV3LmdldFVpbnQzMig4LCB0cnVlKVxuICAgIH07XG4gICAgaWYgKHRoaXMuaGVhZGVyLm1hZ2ljICE9PSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgZ2xURi1CaW5hcnkgaGVhZGVyLlwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaGVhZGVyLnZlcnNpb24gPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBMZWdhY3kgYmluYXJ5IGZpbGUgZGV0ZWN0ZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBjaHVua0NvbnRlbnRzTGVuZ3RoID0gdGhpcy5oZWFkZXIubGVuZ3RoIC0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIO1xuICAgIGNvbnN0IGNodW5rVmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEgpO1xuICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICB3aGlsZSAoY2h1bmtJbmRleCA8IGNodW5rQ29udGVudHNMZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNodW5rTGVuZ3RoID0gY2h1bmtWaWV3LmdldFVpbnQzMihjaHVua0luZGV4LCB0cnVlKTtcbiAgICAgIGNodW5rSW5kZXggKz0gNDtcbiAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rVmlldy5nZXRVaW50MzIoY2h1bmtJbmRleCwgdHJ1ZSk7XG4gICAgICBjaHVua0luZGV4ICs9IDQ7XG4gICAgICBpZiAoY2h1bmtUeXBlID09PSBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTLkpTT04pIHtcbiAgICAgICAgY29uc3QgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICsgY2h1bmtJbmRleCwgY2h1bmtMZW5ndGgpO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBkZWNvZGVUZXh0KGNvbnRlbnRBcnJheSk7XG4gICAgICB9IGVsc2UgaWYgKGNodW5rVHlwZSA9PT0gQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUy5CSU4pIHtcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCArIGNodW5rSW5kZXg7XG4gICAgICAgIHRoaXMuYm9keSA9IGRhdGEuc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGNodW5rTGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGNodW5rSW5kZXggKz0gY2h1bmtMZW5ndGg7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEpTT04gY29udGVudCBub3QgZm91bmQuXCIpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgR0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IoanNvbiwgZHJhY29Mb2FkZXIpIHtcbiAgICBpZiAoIWRyYWNvTG9hZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBObyBEUkFDT0xvYWRlciBpbnN0YW5jZSBwcm92aWRlZC5cIik7XG4gICAgfVxuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT047XG4gICAgdGhpcy5qc29uID0ganNvbjtcbiAgICB0aGlzLmRyYWNvTG9hZGVyID0gZHJhY29Mb2FkZXI7XG4gICAgdGhpcy5kcmFjb0xvYWRlci5wcmVsb2FkKCk7XG4gIH1cbiAgZGVjb2RlUHJpbWl0aXZlKHByaW1pdGl2ZSwgcGFyc2VyKSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBkcmFjb0xvYWRlciA9IHRoaXMuZHJhY29Mb2FkZXI7XG4gICAgY29uc3QgYnVmZmVyVmlld0luZGV4ID0gcHJpbWl0aXZlLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5idWZmZXJWaWV3O1xuICAgIGNvbnN0IGdsdGZBdHRyaWJ1dGVNYXAgPSBwcmltaXRpdmUuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgdGhyZWVBdHRyaWJ1dGVNYXAgPSB7fTtcbiAgICBjb25zdCBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwID0ge307XG4gICAgY29uc3QgYXR0cmlidXRlVHlwZU1hcCA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBnbHRmQXR0cmlidXRlTWFwKSB7XG4gICAgICBjb25zdCB0aHJlZUF0dHJpYnV0ZU5hbWUgPSBBVFRSSUJVVEVTW2F0dHJpYnV0ZU5hbWVdIHx8IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRocmVlQXR0cmlidXRlTWFwW3RocmVlQXR0cmlidXRlTmFtZV0gPSBnbHRmQXR0cmlidXRlTWFwW2F0dHJpYnV0ZU5hbWVdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gcHJpbWl0aXZlLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbYXR0cmlidXRlTmFtZV0gfHwgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGdsdGZBdHRyaWJ1dGVNYXBbYXR0cmlidXRlTmFtZV0gIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NvckRlZiA9IGpzb24uYWNjZXNzb3JzW3ByaW1pdGl2ZS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdXTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50VHlwZSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlXTtcbiAgICAgICAgYXR0cmlidXRlVHlwZU1hcFt0aHJlZUF0dHJpYnV0ZU5hbWVdID0gY29tcG9uZW50VHlwZS5uYW1lO1xuICAgICAgICBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwW3RocmVlQXR0cmlidXRlTmFtZV0gPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIGJ1ZmZlclZpZXdJbmRleCkudGhlbihmdW5jdGlvbihidWZmZXJWaWV3KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGRyYWNvTG9hZGVyLmRlY29kZURyYWNvRmlsZShcbiAgICAgICAgICBidWZmZXJWaWV3LFxuICAgICAgICAgIGZ1bmN0aW9uKGdlb21ldHJ5KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gYXR0cmlidXRlTm9ybWFsaXplZE1hcFthdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQgIT09IHZvaWQgMClcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGdlb21ldHJ5KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRocmVlQXR0cmlidXRlTWFwLFxuICAgICAgICAgIGF0dHJpYnV0ZVR5cGVNYXAsXG4gICAgICAgICAgTGluZWFyU1JHQkNvbG9yU3BhY2UsXG4gICAgICAgICAgcmVqZWN0XG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STTtcbiAgfVxuICBleHRlbmRUZXh0dXJlKHRleHR1cmUsIHRyYW5zZm9ybSkge1xuICAgIGlmICgodHJhbnNmb3JtLnRleENvb3JkID09PSB2b2lkIDAgfHwgdHJhbnNmb3JtLnRleENvb3JkID09PSB0ZXh0dXJlLmNoYW5uZWwpICYmIHRyYW5zZm9ybS5vZmZzZXQgPT09IHZvaWQgMCAmJiB0cmFuc2Zvcm0ucm90YXRpb24gPT09IHZvaWQgMCAmJiB0cmFuc2Zvcm0uc2NhbGUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfVxuICAgIHRleHR1cmUgPSB0ZXh0dXJlLmNsb25lKCk7XG4gICAgaWYgKHRyYW5zZm9ybS50ZXhDb29yZCAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZXh0dXJlLmNoYW5uZWwgPSB0cmFuc2Zvcm0udGV4Q29vcmQ7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm0ub2Zmc2V0ICE9PSB2b2lkIDApIHtcbiAgICAgIHRleHR1cmUub2Zmc2V0LmZyb21BcnJheSh0cmFuc2Zvcm0ub2Zmc2V0KTtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybS5yb3RhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZXh0dXJlLnJvdGF0aW9uID0gdHJhbnNmb3JtLnJvdGF0aW9uO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgIHRleHR1cmUucmVwZWF0LmZyb21BcnJheSh0cmFuc2Zvcm0uc2NhbGUpO1xuICAgIH1cbiAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxufVxuY2xhc3MgR0xURk1lc2hRdWFudGl6YXRpb25FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NRVNIX1FVQU5USVpBVElPTjtcbiAgfVxufVxuY2xhc3MgR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQgZXh0ZW5kcyBJbnRlcnBvbGFudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKTtcbiAgfVxuICBjb3B5U2FtcGxlVmFsdWVfKGluZGV4KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsIHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLCB2YWx1ZVNpemUgPSB0aGlzLnZhbHVlU2l6ZSwgb2Zmc2V0ID0gaW5kZXggKiB2YWx1ZVNpemUgKiAzICsgdmFsdWVTaXplO1xuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSB2YWx1ZVNpemU7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gdmFsdWVzW29mZnNldCArIGldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXI7XG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXM7XG4gICAgY29uc3Qgc3RyaWRlID0gdGhpcy52YWx1ZVNpemU7XG4gICAgY29uc3Qgc3RyaWRlMiA9IHN0cmlkZSAqIDI7XG4gICAgY29uc3Qgc3RyaWRlMyA9IHN0cmlkZSAqIDM7XG4gICAgY29uc3QgdGQgPSB0MSAtIHQwO1xuICAgIGNvbnN0IHAgPSAodCAtIHQwKSAvIHRkO1xuICAgIGNvbnN0IHBwID0gcCAqIHA7XG4gICAgY29uc3QgcHBwID0gcHAgKiBwO1xuICAgIGNvbnN0IG9mZnNldDEgPSBpMSAqIHN0cmlkZTM7XG4gICAgY29uc3Qgb2Zmc2V0MCA9IG9mZnNldDEgLSBzdHJpZGUzO1xuICAgIGNvbnN0IHMyID0gLTIgKiBwcHAgKyAzICogcHA7XG4gICAgY29uc3QgczMgPSBwcHAgLSBwcDtcbiAgICBjb25zdCBzMCA9IDEgLSBzMjtcbiAgICBjb25zdCBzMSA9IHMzIC0gcHAgKyBwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7IGkrKykge1xuICAgICAgY29uc3QgcDAgPSB2YWx1ZXNbb2Zmc2V0MCArIGkgKyBzdHJpZGVdO1xuICAgICAgY29uc3QgbTAgPSB2YWx1ZXNbb2Zmc2V0MCArIGkgKyBzdHJpZGUyXSAqIHRkO1xuICAgICAgY29uc3QgcDEgPSB2YWx1ZXNbb2Zmc2V0MSArIGkgKyBzdHJpZGVdO1xuICAgICAgY29uc3QgbTEgPSB2YWx1ZXNbb2Zmc2V0MSArIGldICogdGQ7XG4gICAgICByZXN1bHRbaV0gPSBzMCAqIHAwICsgczEgKiBtMCArIHMyICogcDEgKyBzMyAqIG0xO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5jb25zdCBfcSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5jbGFzcyBHTFRGQ3ViaWNTcGxpbmVRdWF0ZXJuaW9uSW50ZXJwb2xhbnQgZXh0ZW5kcyBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudCB7XG4gIGludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuaW50ZXJwb2xhdGVfKGkxLCB0MCwgdCwgdDEpO1xuICAgIF9xLmZyb21BcnJheShyZXN1bHQpLm5vcm1hbGl6ZSgpLnRvQXJyYXkocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5jb25zdCBXRUJHTF9DT05TVEFOVFMgPSB7XG4gIEZMT0FUOiA1MTI2LFxuICAvL0ZMT0FUX01BVDI6IDM1Njc0LFxuICBGTE9BVF9NQVQzOiAzNTY3NSxcbiAgRkxPQVRfTUFUNDogMzU2NzYsXG4gIEZMT0FUX1ZFQzI6IDM1NjY0LFxuICBGTE9BVF9WRUMzOiAzNTY2NSxcbiAgRkxPQVRfVkVDNDogMzU2NjYsXG4gIExJTkVBUjogOTcyOSxcbiAgUkVQRUFUOiAxMDQ5NyxcbiAgU0FNUExFUl8yRDogMzU2NzgsXG4gIFBPSU5UUzogMCxcbiAgTElORVM6IDEsXG4gIExJTkVfTE9PUDogMixcbiAgTElORV9TVFJJUDogMyxcbiAgVFJJQU5HTEVTOiA0LFxuICBUUklBTkdMRV9TVFJJUDogNSxcbiAgVFJJQU5HTEVfRkFOOiA2LFxuICBVTlNJR05FRF9CWVRFOiA1MTIxLFxuICBVTlNJR05FRF9TSE9SVDogNTEyM1xufTtcbmNvbnN0IFdFQkdMX0NPTVBPTkVOVF9UWVBFUyA9IHtcbiAgNTEyMDogSW50OEFycmF5LFxuICA1MTIxOiBVaW50OEFycmF5LFxuICA1MTIyOiBJbnQxNkFycmF5LFxuICA1MTIzOiBVaW50MTZBcnJheSxcbiAgNTEyNTogVWludDMyQXJyYXksXG4gIDUxMjY6IEZsb2F0MzJBcnJheVxufTtcbmNvbnN0IFdFQkdMX0ZJTFRFUlMgPSB7XG4gIDk3Mjg6IE5lYXJlc3RGaWx0ZXIsXG4gIDk3Mjk6IExpbmVhckZpbHRlcixcbiAgOTk4NDogTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsXG4gIDk5ODU6IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsXG4gIDk5ODY6IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsXG4gIDk5ODc6IExpbmVhck1pcG1hcExpbmVhckZpbHRlclxufTtcbmNvbnN0IFdFQkdMX1dSQVBQSU5HUyA9IHtcbiAgMzMwNzE6IENsYW1wVG9FZGdlV3JhcHBpbmcsXG4gIDMzNjQ4OiBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLFxuICAxMDQ5NzogUmVwZWF0V3JhcHBpbmdcbn07XG5jb25zdCBXRUJHTF9UWVBFX1NJWkVTID0ge1xuICBTQ0FMQVI6IDEsXG4gIFZFQzI6IDIsXG4gIFZFQzM6IDMsXG4gIFZFQzQ6IDQsXG4gIE1BVDI6IDQsXG4gIE1BVDM6IDksXG4gIE1BVDQ6IDE2XG59O1xuY29uc3QgQVRUUklCVVRFUyA9IHtcbiAgUE9TSVRJT046IFwicG9zaXRpb25cIixcbiAgTk9STUFMOiBcIm5vcm1hbFwiLFxuICBUQU5HRU5UOiBcInRhbmdlbnRcIixcbiAgLy8gdXYgPT4gdXYxLCA0IHV2IGNoYW5uZWxzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yNTk0M1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjU3ODhcbiAgLi4udmVyc2lvbiA+PSAxNTIgPyB7XG4gICAgVEVYQ09PUkRfMDogXCJ1dlwiLFxuICAgIFRFWENPT1JEXzE6IFwidXYxXCIsXG4gICAgVEVYQ09PUkRfMjogXCJ1djJcIixcbiAgICBURVhDT09SRF8zOiBcInV2M1wiXG4gIH0gOiB7XG4gICAgVEVYQ09PUkRfMDogXCJ1dlwiLFxuICAgIFRFWENPT1JEXzE6IFwidXYyXCJcbiAgfSxcbiAgQ09MT1JfMDogXCJjb2xvclwiLFxuICBXRUlHSFRTXzA6IFwic2tpbldlaWdodFwiLFxuICBKT0lOVFNfMDogXCJza2luSW5kZXhcIlxufTtcbmNvbnN0IFBBVEhfUFJPUEVSVElFUyA9IHtcbiAgc2NhbGU6IFwic2NhbGVcIixcbiAgdHJhbnNsYXRpb246IFwicG9zaXRpb25cIixcbiAgcm90YXRpb246IFwicXVhdGVybmlvblwiLFxuICB3ZWlnaHRzOiBcIm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1wiXG59O1xuY29uc3QgSU5URVJQT0xBVElPTiA9IHtcbiAgQ1VCSUNTUExJTkU6IHZvaWQgMCxcbiAgLy8gV2UgdXNlIGEgY3VzdG9tIGludGVycG9sYW50IChHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGF0aW9uKSBmb3IgQ1VCSUNTUExJTkUgdHJhY2tzLiBFYWNoXG4gIC8vIGtleWZyYW1lIHRyYWNrIHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIGRlZmF1bHQgaW50ZXJwb2xhdGlvbiB0eXBlLCB0aGVuIG1vZGlmaWVkLlxuICBMSU5FQVI6IEludGVycG9sYXRlTGluZWFyLFxuICBTVEVQOiBJbnRlcnBvbGF0ZURpc2NyZXRlXG59O1xuY29uc3QgQUxQSEFfTU9ERVMgPSB7XG4gIE9QQVFVRTogXCJPUEFRVUVcIixcbiAgTUFTSzogXCJNQVNLXCIsXG4gIEJMRU5EOiBcIkJMRU5EXCJcbn07XG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0TWF0ZXJpYWwoY2FjaGUpIHtcbiAgaWYgKGNhY2hlW1wiRGVmYXVsdE1hdGVyaWFsXCJdID09PSB2b2lkIDApIHtcbiAgICBjYWNoZVtcIkRlZmF1bHRNYXRlcmlhbFwiXSA9IG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgICBjb2xvcjogMTY3NzcyMTUsXG4gICAgICBlbWlzc2l2ZTogMCxcbiAgICAgIG1ldGFsbmVzczogMSxcbiAgICAgIHJvdWdobmVzczogMSxcbiAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogdHJ1ZSxcbiAgICAgIHNpZGU6IEZyb250U2lkZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBjYWNoZVtcIkRlZmF1bHRNYXRlcmlhbFwiXTtcbn1cbmZ1bmN0aW9uIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShrbm93bkV4dGVuc2lvbnMsIG9iamVjdCwgb2JqZWN0RGVmKSB7XG4gIGZvciAoY29uc3QgbmFtZSBpbiBvYmplY3REZWYuZXh0ZW5zaW9ucykge1xuICAgIGlmIChrbm93bkV4dGVuc2lvbnNbbmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zID0gb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zIHx8IHt9O1xuICAgICAgb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zW25hbWVdID0gb2JqZWN0RGVmLmV4dGVuc2lvbnNbbmFtZV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKG9iamVjdCwgZ2x0ZkRlZikge1xuICBpZiAoZ2x0ZkRlZi5leHRyYXMgIT09IHZvaWQgMCkge1xuICAgIGlmICh0eXBlb2YgZ2x0ZkRlZi5leHRyYXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ob2JqZWN0LnVzZXJEYXRhLCBnbHRmRGVmLmV4dHJhcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IElnbm9yaW5nIHByaW1pdGl2ZSB0eXBlIC5leHRyYXMsIFwiICsgZ2x0ZkRlZi5leHRyYXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRkTW9ycGhUYXJnZXRzKGdlb21ldHJ5LCB0YXJnZXRzLCBwYXJzZXIpIHtcbiAgbGV0IGhhc01vcnBoUG9zaXRpb24gPSBmYWxzZTtcbiAgbGV0IGhhc01vcnBoTm9ybWFsID0gZmFsc2U7XG4gIGxldCBoYXNNb3JwaENvbG9yID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgaWYgKHRhcmdldC5QT1NJVElPTiAhPT0gdm9pZCAwKVxuICAgICAgaGFzTW9ycGhQb3NpdGlvbiA9IHRydWU7XG4gICAgaWYgKHRhcmdldC5OT1JNQUwgIT09IHZvaWQgMClcbiAgICAgIGhhc01vcnBoTm9ybWFsID0gdHJ1ZTtcbiAgICBpZiAodGFyZ2V0LkNPTE9SXzAgIT09IHZvaWQgMClcbiAgICAgIGhhc01vcnBoQ29sb3IgPSB0cnVlO1xuICAgIGlmIChoYXNNb3JwaFBvc2l0aW9uICYmIGhhc01vcnBoTm9ybWFsICYmIGhhc01vcnBoQ29sb3IpXG4gICAgICBicmVhaztcbiAgfVxuICBpZiAoIWhhc01vcnBoUG9zaXRpb24gJiYgIWhhc01vcnBoTm9ybWFsICYmICFoYXNNb3JwaENvbG9yKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZ2VvbWV0cnkpO1xuICBjb25zdCBwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMgPSBbXTtcbiAgY29uc3QgcGVuZGluZ05vcm1hbEFjY2Vzc29ycyA9IFtdO1xuICBjb25zdCBwZW5kaW5nQ29sb3JBY2Nlc3NvcnMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICBpZiAoaGFzTW9ycGhQb3NpdGlvbikge1xuICAgICAgY29uc3QgcGVuZGluZ0FjY2Vzc29yID0gdGFyZ2V0LlBPU0lUSU9OICE9PSB2b2lkIDAgPyBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHRhcmdldC5QT1NJVElPTikgOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICAgICAgcGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzLnB1c2gocGVuZGluZ0FjY2Vzc29yKTtcbiAgICB9XG4gICAgaWYgKGhhc01vcnBoTm9ybWFsKSB7XG4gICAgICBjb25zdCBwZW5kaW5nQWNjZXNzb3IgPSB0YXJnZXQuTk9STUFMICE9PSB2b2lkIDAgPyBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHRhcmdldC5OT1JNQUwpIDogZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG4gICAgICBwZW5kaW5nTm9ybWFsQWNjZXNzb3JzLnB1c2gocGVuZGluZ0FjY2Vzc29yKTtcbiAgICB9XG4gICAgaWYgKGhhc01vcnBoQ29sb3IpIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdBY2Nlc3NvciA9IHRhcmdldC5DT0xPUl8wICE9PSB2b2lkIDAgPyBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHRhcmdldC5DT0xPUl8wKSA6IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3I7XG4gICAgICBwZW5kaW5nQ29sb3JBY2Nlc3NvcnMucHVzaChwZW5kaW5nQWNjZXNzb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgIFByb21pc2UuYWxsKHBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycyksXG4gICAgUHJvbWlzZS5hbGwocGVuZGluZ05vcm1hbEFjY2Vzc29ycyksXG4gICAgUHJvbWlzZS5hbGwocGVuZGluZ0NvbG9yQWNjZXNzb3JzKVxuICBdKS50aGVuKGZ1bmN0aW9uKGFjY2Vzc29ycykge1xuICAgIGNvbnN0IG1vcnBoUG9zaXRpb25zID0gYWNjZXNzb3JzWzBdO1xuICAgIGNvbnN0IG1vcnBoTm9ybWFscyA9IGFjY2Vzc29yc1sxXTtcbiAgICBjb25zdCBtb3JwaENvbG9ycyA9IGFjY2Vzc29yc1syXTtcbiAgICBpZiAoaGFzTW9ycGhQb3NpdGlvbilcbiAgICAgIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiA9IG1vcnBoUG9zaXRpb25zO1xuICAgIGlmIChoYXNNb3JwaE5vcm1hbClcbiAgICAgIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgPSBtb3JwaE5vcm1hbHM7XG4gICAgaWYgKGhhc01vcnBoQ29sb3IpXG4gICAgICBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3IgPSBtb3JwaENvbG9ycztcbiAgICBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRydWU7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vcnBoVGFyZ2V0cyhtZXNoLCBtZXNoRGVmKSB7XG4gIG1lc2gudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG4gIGlmIChtZXNoRGVmLndlaWdodHMgIT09IHZvaWQgMCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG1lc2hEZWYud2VpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBtZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tpXSA9IG1lc2hEZWYud2VpZ2h0c1tpXTtcbiAgICB9XG4gIH1cbiAgaWYgKG1lc2hEZWYuZXh0cmFzICYmIEFycmF5LmlzQXJyYXkobWVzaERlZi5leHRyYXMudGFyZ2V0TmFtZXMpKSB7XG4gICAgY29uc3QgdGFyZ2V0TmFtZXMgPSBtZXNoRGVmLmV4dHJhcy50YXJnZXROYW1lcztcbiAgICBpZiAobWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoID09PSB0YXJnZXROYW1lcy5sZW5ndGgpIHtcbiAgICAgIG1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSB0YXJnZXROYW1lcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIG1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5W3RhcmdldE5hbWVzW2ldXSA9IGk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IEludmFsaWQgZXh0cmFzLnRhcmdldE5hbWVzIGxlbmd0aC4gSWdub3JpbmcgbmFtZXMuXCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlS2V5KHByaW1pdGl2ZURlZikge1xuICBsZXQgZ2VvbWV0cnlLZXk7XG4gIGNvbnN0IGRyYWNvRXh0ZW5zaW9uID0gcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnMgJiYgcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTl07XG4gIGlmIChkcmFjb0V4dGVuc2lvbikge1xuICAgIGdlb21ldHJ5S2V5ID0gXCJkcmFjbzpcIiArIGRyYWNvRXh0ZW5zaW9uLmJ1ZmZlclZpZXcgKyBcIjpcIiArIGRyYWNvRXh0ZW5zaW9uLmluZGljZXMgKyBcIjpcIiArIGNyZWF0ZUF0dHJpYnV0ZXNLZXkoZHJhY29FeHRlbnNpb24uYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgZ2VvbWV0cnlLZXkgPSBwcmltaXRpdmVEZWYuaW5kaWNlcyArIFwiOlwiICsgY3JlYXRlQXR0cmlidXRlc0tleShwcmltaXRpdmVEZWYuYXR0cmlidXRlcykgKyBcIjpcIiArIHByaW1pdGl2ZURlZi5tb2RlO1xuICB9XG4gIGlmIChwcmltaXRpdmVEZWYudGFyZ2V0cyAhPT0gdm9pZCAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gcHJpbWl0aXZlRGVmLnRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgZ2VvbWV0cnlLZXkgKz0gXCI6XCIgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KHByaW1pdGl2ZURlZi50YXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdlb21ldHJ5S2V5O1xufVxuZnVuY3Rpb24gY3JlYXRlQXR0cmlidXRlc0tleShhdHRyaWJ1dGVzKSB7XG4gIGxldCBhdHRyaWJ1dGVzS2V5ID0gXCJcIjtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLnNvcnQoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgYXR0cmlidXRlc0tleSArPSBrZXlzW2ldICsgXCI6XCIgKyBhdHRyaWJ1dGVzW2tleXNbaV1dICsgXCI7XCI7XG4gIH1cbiAgcmV0dXJuIGF0dHJpYnV0ZXNLZXk7XG59XG5mdW5jdGlvbiBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoY29uc3RydWN0b3IpIHtcbiAgc3dpdGNoIChjb25zdHJ1Y3Rvcikge1xuICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgcmV0dXJuIDEgLyAxMjc7XG4gICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgcmV0dXJuIDEgLyAyNTU7XG4gICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIDEgLyAzMjc2NztcbiAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIDEgLyA2NTUzNTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgbm9ybWFsaXplZCBhY2Nlc3NvciBjb21wb25lbnQgdHlwZS5cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEltYWdlVVJJTWltZVR5cGUodXJpKSB7XG4gIGlmICh1cmkuc2VhcmNoKC9cXC5qcGU/ZygkfFxcPykvaSkgPiAwIHx8IHVyaS5zZWFyY2goL15kYXRhXFw6aW1hZ2VcXC9qcGVnLykgPT09IDApXG4gICAgcmV0dXJuIFwiaW1hZ2UvanBlZ1wiO1xuICBpZiAodXJpLnNlYXJjaCgvXFwud2VicCgkfFxcPykvaSkgPiAwIHx8IHVyaS5zZWFyY2goL15kYXRhXFw6aW1hZ2VcXC93ZWJwLykgPT09IDApXG4gICAgcmV0dXJuIFwiaW1hZ2Uvd2VicFwiO1xuICByZXR1cm4gXCJpbWFnZS9wbmdcIjtcbn1cbmNvbnN0IF9pZGVudGl0eU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5jbGFzcyBHTFRGUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoanNvbiA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmpzb24gPSBqc29uO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHt9O1xuICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5jYWNoZSA9IG5ldyBHTFRGUmVnaXN0cnkoKTtcbiAgICB0aGlzLmFzc29jaWF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5wcmltaXRpdmVDYWNoZSA9IHt9O1xuICAgIHRoaXMubm9kZUNhY2hlID0ge307XG4gICAgdGhpcy5tZXNoQ2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuICAgIHRoaXMuY2FtZXJhQ2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuICAgIHRoaXMubGlnaHRDYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG4gICAgdGhpcy5zb3VyY2VDYWNoZSA9IHt9O1xuICAgIHRoaXMudGV4dHVyZUNhY2hlID0ge307XG4gICAgdGhpcy5ub2RlTmFtZXNVc2VkID0ge307XG4gICAgbGV0IGlzU2FmYXJpID0gZmFsc2U7XG4gICAgbGV0IGlzRmlyZWZveCA9IGZhbHNlO1xuICAgIGxldCBmaXJlZm94VmVyc2lvbiA9IC0xO1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgPT09IHRydWU7XG4gICAgICBpc0ZpcmVmb3ggPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpID4gLTE7XG4gICAgICBmaXJlZm94VmVyc2lvbiA9IGlzRmlyZWZveCA/IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8oWzAtOV0rKVxcLi8pWzFdIDogLTE7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09IFwidW5kZWZpbmVkXCIgfHwgaXNTYWZhcmkgfHwgaXNGaXJlZm94ICYmIGZpcmVmb3hWZXJzaW9uIDwgOTgpIHtcbiAgICAgIHRoaXMudGV4dHVyZUxvYWRlciA9IG5ldyBUZXh0dXJlTG9hZGVyKHRoaXMub3B0aW9ucy5tYW5hZ2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0dXJlTG9hZGVyID0gbmV3IEltYWdlQml0bWFwTG9hZGVyKHRoaXMub3B0aW9ucy5tYW5hZ2VyKTtcbiAgICB9XG4gICAgdGhpcy50ZXh0dXJlTG9hZGVyLnNldENyb3NzT3JpZ2luKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbik7XG4gICAgdGhpcy50ZXh0dXJlTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5vcHRpb25zLnJlcXVlc3RIZWFkZXIpO1xuICAgIHRoaXMuZmlsZUxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMub3B0aW9ucy5tYW5hZ2VyKTtcbiAgICB0aGlzLmZpbGVMb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gXCJ1c2UtY3JlZGVudGlhbHNcIikge1xuICAgICAgdGhpcy5maWxlTG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0cnVlKTtcbiAgICB9XG4gIH1cbiAgc2V0RXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gICAgdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgfVxuICBzZXRQbHVnaW5zKHBsdWdpbnMpIHtcbiAgICB0aGlzLnBsdWdpbnMgPSBwbHVnaW5zO1xuICB9XG4gIHBhcnNlKG9uTG9hZCwgb25FcnJvcikge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIHRoaXMuY2FjaGUucmVtb3ZlQWxsKCk7XG4gICAgdGhpcy5ub2RlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICByZXR1cm4gZXh0Ll9tYXJrRGVmcyAmJiBleHQuX21hcmtEZWZzKCk7XG4gICAgfSk7XG4gICAgUHJvbWlzZS5hbGwoXG4gICAgICB0aGlzLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgIHJldHVybiBleHQuYmVmb3JlUm9vdCAmJiBleHQuYmVmb3JlUm9vdCgpO1xuICAgICAgfSlcbiAgICApLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICBwYXJzZXIuZ2V0RGVwZW5kZW5jaWVzKFwic2NlbmVcIiksXG4gICAgICAgIHBhcnNlci5nZXREZXBlbmRlbmNpZXMoXCJhbmltYXRpb25cIiksXG4gICAgICAgIHBhcnNlci5nZXREZXBlbmRlbmNpZXMoXCJjYW1lcmFcIilcbiAgICAgIF0pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24oZGVwZW5kZW5jaWVzKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHNjZW5lOiBkZXBlbmRlbmNpZXNbMF1banNvbi5zY2VuZSB8fCAwXSxcbiAgICAgICAgc2NlbmVzOiBkZXBlbmRlbmNpZXNbMF0sXG4gICAgICAgIGFuaW1hdGlvbnM6IGRlcGVuZGVuY2llc1sxXSxcbiAgICAgICAgY2FtZXJhczogZGVwZW5kZW5jaWVzWzJdLFxuICAgICAgICBhc3NldDoganNvbi5hc3NldCxcbiAgICAgICAgcGFyc2VyLFxuICAgICAgICB1c2VyRGF0YToge31cbiAgICAgIH07XG4gICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgcmVzdWx0LCBqc29uKTtcbiAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEocmVzdWx0LCBqc29uKTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgcGFyc2VyLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGV4dC5hZnRlclJvb3QgJiYgZXh0LmFmdGVyUm9vdChyZXN1bHQpO1xuICAgICAgICB9KVxuICAgICAgKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHNjZW5lIG9mIHJlc3VsdC5zY2VuZXMpIHtcbiAgICAgICAgICBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgICB9XG4gICAgICAgIG9uTG9hZChyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSkuY2F0Y2gob25FcnJvcik7XG4gIH1cbiAgLyoqXG4gICAqIE1hcmtzIHRoZSBzcGVjaWFsIG5vZGVzL21lc2hlcyBpbiBqc29uIGZvciBlZmZpY2llbnQgcGFyc2UuXG4gICAqL1xuICBfbWFya0RlZnMoKSB7XG4gICAgY29uc3Qgbm9kZURlZnMgPSB0aGlzLmpzb24ubm9kZXMgfHwgW107XG4gICAgY29uc3Qgc2tpbkRlZnMgPSB0aGlzLmpzb24uc2tpbnMgfHwgW107XG4gICAgY29uc3QgbWVzaERlZnMgPSB0aGlzLmpzb24ubWVzaGVzIHx8IFtdO1xuICAgIGZvciAobGV0IHNraW5JbmRleCA9IDAsIHNraW5MZW5ndGggPSBza2luRGVmcy5sZW5ndGg7IHNraW5JbmRleCA8IHNraW5MZW5ndGg7IHNraW5JbmRleCsrKSB7XG4gICAgICBjb25zdCBqb2ludHMgPSBza2luRGVmc1tza2luSW5kZXhdLmpvaW50cztcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGpvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIG5vZGVEZWZzW2pvaW50c1tpXV0uaXNCb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgbm9kZUluZGV4ID0gMCwgbm9kZUxlbmd0aCA9IG5vZGVEZWZzLmxlbmd0aDsgbm9kZUluZGV4IDwgbm9kZUxlbmd0aDsgbm9kZUluZGV4KyspIHtcbiAgICAgIGNvbnN0IG5vZGVEZWYgPSBub2RlRGVmc1tub2RlSW5kZXhdO1xuICAgICAgaWYgKG5vZGVEZWYubWVzaCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuX2FkZE5vZGVSZWYodGhpcy5tZXNoQ2FjaGUsIG5vZGVEZWYubWVzaCk7XG4gICAgICAgIGlmIChub2RlRGVmLnNraW4gIT09IHZvaWQgMCkge1xuICAgICAgICAgIG1lc2hEZWZzW25vZGVEZWYubWVzaF0uaXNTa2lubmVkTWVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlRGVmLmNhbWVyYSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuX2FkZE5vZGVSZWYodGhpcy5jYW1lcmFDYWNoZSwgbm9kZURlZi5jYW1lcmEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ291bnRzIHJlZmVyZW5jZXMgdG8gc2hhcmVkIG5vZGUgLyBPYmplY3QzRCByZXNvdXJjZXMuIFRoZXNlIHJlc291cmNlc1xuICAgKiBjYW4gYmUgcmV1c2VkLCBvciBcImluc3RhbnRpYXRlZFwiLCBhdCBtdWx0aXBsZSBub2RlcyBpbiB0aGUgc2NlbmVcbiAgICogaGllcmFyY2h5LiBNZXNoLCBDYW1lcmEsIGFuZCBMaWdodCBpbnN0YW5jZXMgYXJlIGluc3RhbnRpYXRlZCBhbmQgbXVzdFxuICAgKiBiZSBtYXJrZWQuIE5vbi1zY2VuZWdyYXBoIHJlc291cmNlcyAobGlrZSBNYXRlcmlhbHMsIEdlb21ldHJpZXMsIGFuZFxuICAgKiBUZXh0dXJlcykgY2FuIGJlIHJldXNlZCBkaXJlY3RseSBhbmQgYXJlIG5vdCBtYXJrZWQgaGVyZS5cbiAgICpcbiAgICogRXhhbXBsZTogQ2VzaXVtTWlsa1RydWNrIHNhbXBsZSBtb2RlbCByZXVzZXMgXCJXaGVlbFwiIG1lc2hlcy5cbiAgICovXG4gIF9hZGROb2RlUmVmKGNhY2hlLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChjYWNoZS5yZWZzW2luZGV4XSA9PT0gdm9pZCAwKSB7XG4gICAgICBjYWNoZS5yZWZzW2luZGV4XSA9IGNhY2hlLnVzZXNbaW5kZXhdID0gMDtcbiAgICB9XG4gICAgY2FjaGUucmVmc1tpbmRleF0rKztcbiAgfVxuICAvKiogUmV0dXJucyBhIHJlZmVyZW5jZSB0byBhIHNoYXJlZCByZXNvdXJjZSwgY2xvbmluZyBpdCBpZiBuZWNlc3NhcnkuICovXG4gIF9nZXROb2RlUmVmKGNhY2hlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgaWYgKGNhY2hlLnJlZnNbaW5kZXhdIDw9IDEpXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIGNvbnN0IHJlZiA9IG9iamVjdC5jbG9uZSgpO1xuICAgIGNvbnN0IHVwZGF0ZU1hcHBpbmdzID0gKG9yaWdpbmFsLCBjbG9uZSkgPT4ge1xuICAgICAgY29uc3QgbWFwcGluZ3MgPSB0aGlzLmFzc29jaWF0aW9ucy5nZXQob3JpZ2luYWwpO1xuICAgICAgaWYgKG1hcHBpbmdzICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5hc3NvY2lhdGlvbnMuc2V0KGNsb25lLCBtYXBwaW5ncyk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IFtpLCBjaGlsZF0gb2Ygb3JpZ2luYWwuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgIHVwZGF0ZU1hcHBpbmdzKGNoaWxkLCBjbG9uZS5jaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB1cGRhdGVNYXBwaW5ncyhvYmplY3QsIHJlZik7XG4gICAgcmVmLm5hbWUgKz0gXCJfaW5zdGFuY2VfXCIgKyBjYWNoZS51c2VzW2luZGV4XSsrO1xuICAgIHJldHVybiByZWY7XG4gIH1cbiAgX2ludm9rZU9uZShmdW5jKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IE9iamVjdC52YWx1ZXModGhpcy5wbHVnaW5zKTtcbiAgICBleHRlbnNpb25zLnB1c2godGhpcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBmdW5jKGV4dGVuc2lvbnNbaV0pO1xuICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgX2ludm9rZUFsbChmdW5jKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IE9iamVjdC52YWx1ZXModGhpcy5wbHVnaW5zKTtcbiAgICBleHRlbnNpb25zLnVuc2hpZnQodGhpcyk7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZnVuYyhleHRlbnNpb25zW2ldKTtcbiAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgIHBlbmRpbmcucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcGVuZGluZztcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgdGhlIHNwZWNpZmllZCBkZXBlbmRlbmN5IGFzeW5jaHJvbm91c2x5LCB3aXRoIGNhY2hpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdDNEfE1hdGVyaWFsfFRIUkVFLlRleHR1cmV8QW5pbWF0aW9uQ2xpcHxBcnJheUJ1ZmZlcnxPYmplY3Q+fVxuICAgKi9cbiAgZ2V0RGVwZW5kZW5jeSh0eXBlLCBpbmRleCkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gdHlwZSArIFwiOlwiICsgaW5kZXg7XG4gICAgbGV0IGRlcGVuZGVuY3kgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCFkZXBlbmRlbmN5KSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInNjZW5lXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMubG9hZFNjZW5lKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5vZGVcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkTm9kZSAmJiBleHQubG9hZE5vZGUoaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWVzaFwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRNZXNoICYmIGV4dC5sb2FkTWVzaChpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhY2Nlc3NvclwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRBY2Nlc3NvcihpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJidWZmZXJWaWV3XCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZEJ1ZmZlclZpZXcgJiYgZXh0LmxvYWRCdWZmZXJWaWV3KGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJ1ZmZlclwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRCdWZmZXIoaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWF0ZXJpYWxcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkTWF0ZXJpYWwgJiYgZXh0LmxvYWRNYXRlcmlhbChpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0ZXh0dXJlXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZFRleHR1cmUgJiYgZXh0LmxvYWRUZXh0dXJlKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNraW5cIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkU2tpbihpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhbmltYXRpb25cIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkQW5pbWF0aW9uICYmIGV4dC5sb2FkQW5pbWF0aW9uKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhbWVyYVwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRDYW1lcmEoaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0ICE9IHRoaXMgJiYgZXh0LmdldERlcGVuZGVuY3kgJiYgZXh0LmdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghZGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGUuYWRkKGNhY2hlS2V5LCBkZXBlbmRlbmN5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcGVuZGVuY3k7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGFsbCBkZXBlbmRlbmNpZXMgb2YgdGhlIHNwZWNpZmllZCB0eXBlIGFzeW5jaHJvbm91c2x5LCB3aXRoIGNhY2hpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8T2JqZWN0Pj59XG4gICAqL1xuICBnZXREZXBlbmRlbmNpZXModHlwZSkge1xuICAgIGxldCBkZXBlbmRlbmNpZXMgPSB0aGlzLmNhY2hlLmdldCh0eXBlKTtcbiAgICBpZiAoIWRlcGVuZGVuY2llcykge1xuICAgICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICAgIGNvbnN0IGRlZnMgPSB0aGlzLmpzb25bdHlwZSArICh0eXBlID09PSBcIm1lc2hcIiA/IFwiZXNcIiA6IFwic1wiKV0gfHwgW107XG4gICAgICBkZXBlbmRlbmNpZXMgPSBQcm9taXNlLmFsbChcbiAgICAgICAgZGVmcy5tYXAoZnVuY3Rpb24oZGVmLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeSh0eXBlLCBpbmRleCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgdGhpcy5jYWNoZS5hZGQodHlwZSwgZGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNidWZmZXJzLWFuZC1idWZmZXItdmlld3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlckluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXlCdWZmZXI+fVxuICAgKi9cbiAgbG9hZEJ1ZmZlcihidWZmZXJJbmRleCkge1xuICAgIGNvbnN0IGJ1ZmZlckRlZiA9IHRoaXMuanNvbi5idWZmZXJzW2J1ZmZlckluZGV4XTtcbiAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmZpbGVMb2FkZXI7XG4gICAgaWYgKGJ1ZmZlckRlZi50eXBlICYmIGJ1ZmZlckRlZi50eXBlICE9PSBcImFycmF5YnVmZmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFwiICsgYnVmZmVyRGVmLnR5cGUgKyBcIiBidWZmZXIgdHlwZSBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gICAgaWYgKGJ1ZmZlckRlZi51cmkgPT09IHZvaWQgMCAmJiBidWZmZXJJbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEZdLmJvZHkpO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGxvYWRlci5sb2FkKExvYWRlclV0aWxzLnJlc29sdmVVUkwoYnVmZmVyRGVmLnVyaSwgb3B0aW9ucy5wYXRoKSwgcmVzb2x2ZSwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVEhSRUUuR0xURkxvYWRlcjogRmFpbGVkIHRvIGxvYWQgYnVmZmVyIFwiJyArIGJ1ZmZlckRlZi51cmkgKyAnXCIuJykpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjYnVmZmVycy1hbmQtYnVmZmVyLXZpZXdzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBidWZmZXJWaWV3SW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheUJ1ZmZlcj59XG4gICAqL1xuICBsb2FkQnVmZmVyVmlldyhidWZmZXJWaWV3SW5kZXgpIHtcbiAgICBjb25zdCBidWZmZXJWaWV3RGVmID0gdGhpcy5qc29uLmJ1ZmZlclZpZXdzW2J1ZmZlclZpZXdJbmRleF07XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclwiLCBidWZmZXJWaWV3RGVmLmJ1ZmZlcikudGhlbihmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBidWZmZXJWaWV3RGVmLmJ5dGVMZW5ndGggfHwgMDtcbiAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBidWZmZXJWaWV3RGVmLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2FjY2Vzc29yc1xuICAgKiBAcGFyYW0ge251bWJlcn0gYWNjZXNzb3JJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEJ1ZmZlckF0dHJpYnV0ZXxJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZT59XG4gICAqL1xuICBsb2FkQWNjZXNzb3IoYWNjZXNzb3JJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBhY2Nlc3NvckRlZiA9IHRoaXMuanNvbi5hY2Nlc3NvcnNbYWNjZXNzb3JJbmRleF07XG4gICAgaWYgKGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgPT09IHZvaWQgMCAmJiBhY2Nlc3NvckRlZi5zcGFyc2UgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBXRUJHTF9UWVBFX1NJWkVTW2FjY2Vzc29yRGVmLnR5cGVdO1xuICAgICAgY29uc3QgVHlwZWRBcnJheSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlXTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShhY2Nlc3NvckRlZi5jb3VudCAqIGl0ZW1TaXplKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZ0J1ZmZlclZpZXdzID0gW107XG4gICAgaWYgKGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZ0J1ZmZlclZpZXdzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBhY2Nlc3NvckRlZi5idWZmZXJWaWV3KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKG51bGwpO1xuICAgIH1cbiAgICBpZiAoYWNjZXNzb3JEZWYuc3BhcnNlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgYWNjZXNzb3JEZWYuc3BhcnNlLmluZGljZXMuYnVmZmVyVmlldykpO1xuICAgICAgcGVuZGluZ0J1ZmZlclZpZXdzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBhY2Nlc3NvckRlZi5zcGFyc2UudmFsdWVzLmJ1ZmZlclZpZXcpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmdCdWZmZXJWaWV3cykudGhlbihmdW5jdGlvbihidWZmZXJWaWV3cykge1xuICAgICAgY29uc3QgYnVmZmVyVmlldyA9IGJ1ZmZlclZpZXdzWzBdO1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBXRUJHTF9UWVBFX1NJWkVTW2FjY2Vzc29yRGVmLnR5cGVdO1xuICAgICAgY29uc3QgVHlwZWRBcnJheSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlXTtcbiAgICAgIGNvbnN0IGVsZW1lbnRCeXRlcyA9IFR5cGVkQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICBjb25zdCBpdGVtQnl0ZXMgPSBlbGVtZW50Qnl0ZXMgKiBpdGVtU2l6ZTtcbiAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBhY2Nlc3NvckRlZi5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICBjb25zdCBieXRlU3RyaWRlID0gYWNjZXNzb3JEZWYuYnVmZmVyVmlldyAhPT0gdm9pZCAwID8ganNvbi5idWZmZXJWaWV3c1thY2Nlc3NvckRlZi5idWZmZXJWaWV3XS5ieXRlU3RyaWRlIDogdm9pZCAwO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGFjY2Vzc29yRGVmLm5vcm1hbGl6ZWQgPT09IHRydWU7XG4gICAgICBsZXQgYXJyYXksIGJ1ZmZlckF0dHJpYnV0ZTtcbiAgICAgIGlmIChieXRlU3RyaWRlICYmIGJ5dGVTdHJpZGUgIT09IGl0ZW1CeXRlcykge1xuICAgICAgICBjb25zdCBpYlNsaWNlID0gTWF0aC5mbG9vcihieXRlT2Zmc2V0IC8gYnl0ZVN0cmlkZSk7XG4gICAgICAgIGNvbnN0IGliQ2FjaGVLZXkgPSBcIkludGVybGVhdmVkQnVmZmVyOlwiICsgYWNjZXNzb3JEZWYuYnVmZmVyVmlldyArIFwiOlwiICsgYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZSArIFwiOlwiICsgaWJTbGljZSArIFwiOlwiICsgYWNjZXNzb3JEZWYuY291bnQ7XG4gICAgICAgIGxldCBpYiA9IHBhcnNlci5jYWNoZS5nZXQoaWJDYWNoZUtleSk7XG4gICAgICAgIGlmICghaWIpIHtcbiAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGJ1ZmZlclZpZXcsIGliU2xpY2UgKiBieXRlU3RyaWRlLCBhY2Nlc3NvckRlZi5jb3VudCAqIGJ5dGVTdHJpZGUgLyBlbGVtZW50Qnl0ZXMpO1xuICAgICAgICAgIGliID0gbmV3IEludGVybGVhdmVkQnVmZmVyKGFycmF5LCBieXRlU3RyaWRlIC8gZWxlbWVudEJ5dGVzKTtcbiAgICAgICAgICBwYXJzZXIuY2FjaGUuYWRkKGliQ2FjaGVLZXksIGliKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJBdHRyaWJ1dGUgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoXG4gICAgICAgICAgaWIsXG4gICAgICAgICAgaXRlbVNpemUsXG4gICAgICAgICAgYnl0ZU9mZnNldCAlIGJ5dGVTdHJpZGUgLyBlbGVtZW50Qnl0ZXMsXG4gICAgICAgICAgbm9ybWFsaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJ1ZmZlclZpZXcgPT09IG51bGwpIHtcbiAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGFjY2Vzc29yRGVmLmNvdW50ICogaXRlbVNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYnVmZmVyVmlldywgYnl0ZU9mZnNldCwgYWNjZXNzb3JEZWYuY291bnQgKiBpdGVtU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuICAgICAgfVxuICAgICAgaWYgKGFjY2Vzc29yRGVmLnNwYXJzZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1TaXplSW5kaWNlcyA9IFdFQkdMX1RZUEVfU0laRVMuU0NBTEFSO1xuICAgICAgICBjb25zdCBUeXBlZEFycmF5SW5kaWNlcyA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5jb21wb25lbnRUeXBlXTtcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldEluZGljZXMgPSBhY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXRWYWx1ZXMgPSBhY2Nlc3NvckRlZi5zcGFyc2UudmFsdWVzLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3Qgc3BhcnNlSW5kaWNlcyA9IG5ldyBUeXBlZEFycmF5SW5kaWNlcyhcbiAgICAgICAgICBidWZmZXJWaWV3c1sxXSxcbiAgICAgICAgICBieXRlT2Zmc2V0SW5kaWNlcyxcbiAgICAgICAgICBhY2Nlc3NvckRlZi5zcGFyc2UuY291bnQgKiBpdGVtU2l6ZUluZGljZXNcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgc3BhcnNlVmFsdWVzID0gbmV3IFR5cGVkQXJyYXkoYnVmZmVyVmlld3NbMl0sIGJ5dGVPZmZzZXRWYWx1ZXMsIGFjY2Vzc29yRGVmLnNwYXJzZS5jb3VudCAqIGl0ZW1TaXplKTtcbiAgICAgICAgaWYgKGJ1ZmZlclZpZXcgIT09IG51bGwpIHtcbiAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKFxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLmFycmF5LnNsaWNlKCksXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuaXRlbVNpemUsXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUubm9ybWFsaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gc3BhcnNlSW5kaWNlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBzcGFyc2VJbmRpY2VzW2ldO1xuICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5zZXRYKGluZGV4LCBzcGFyc2VWYWx1ZXNbaSAqIGl0ZW1TaXplXSk7XG4gICAgICAgICAgaWYgKGl0ZW1TaXplID49IDIpXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuc2V0WShpbmRleCwgc3BhcnNlVmFsdWVzW2kgKiBpdGVtU2l6ZSArIDFdKTtcbiAgICAgICAgICBpZiAoaXRlbVNpemUgPj0gMylcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5zZXRaKGluZGV4LCBzcGFyc2VWYWx1ZXNbaSAqIGl0ZW1TaXplICsgMl0pO1xuICAgICAgICAgIGlmIChpdGVtU2l6ZSA+PSA0KVxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLnNldFcoaW5kZXgsIHNwYXJzZVZhbHVlc1tpICogaXRlbVNpemUgKyAzXSk7XG4gICAgICAgICAgaWYgKGl0ZW1TaXplID49IDUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBpdGVtU2l6ZSBpbiBzcGFyc2UgQnVmZmVyQXR0cmlidXRlLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlckF0dHJpYnV0ZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3RleHR1cmVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0ZXh0dXJlSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxUSFJFRS5UZXh0dXJlfG51bGw+fVxuICAgKi9cbiAgbG9hZFRleHR1cmUodGV4dHVyZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgY29uc3Qgc291cmNlSW5kZXggPSB0ZXh0dXJlRGVmLnNvdXJjZTtcbiAgICBjb25zdCBzb3VyY2VEZWYgPSBqc29uLmltYWdlc1tzb3VyY2VJbmRleF07XG4gICAgbGV0IGxvYWRlciA9IHRoaXMudGV4dHVyZUxvYWRlcjtcbiAgICBpZiAoc291cmNlRGVmLnVyaSkge1xuICAgICAgY29uc3QgaGFuZGxlciA9IG9wdGlvbnMubWFuYWdlci5nZXRIYW5kbGVyKHNvdXJjZURlZi51cmkpO1xuICAgICAgaWYgKGhhbmRsZXIgIT09IG51bGwpXG4gICAgICAgIGxvYWRlciA9IGhhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvYWRUZXh0dXJlSW1hZ2UodGV4dHVyZUluZGV4LCBzb3VyY2VJbmRleCwgbG9hZGVyKTtcbiAgfVxuICBsb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgc291cmNlSW5kZXgsIGxvYWRlcikge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGNvbnN0IHNvdXJjZURlZiA9IGpzb24uaW1hZ2VzW3NvdXJjZUluZGV4XTtcbiAgICBjb25zdCBjYWNoZUtleSA9IChzb3VyY2VEZWYudXJpIHx8IHNvdXJjZURlZi5idWZmZXJWaWV3KSArIFwiOlwiICsgdGV4dHVyZURlZi5zYW1wbGVyO1xuICAgIGlmICh0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV0pIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV07XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmxvYWRJbWFnZVNvdXJjZShzb3VyY2VJbmRleCwgbG9hZGVyKS50aGVuKGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICAgIHRleHR1cmUuZmxpcFkgPSBmYWxzZTtcbiAgICAgIHRleHR1cmUubmFtZSA9IHRleHR1cmVEZWYubmFtZSB8fCBzb3VyY2VEZWYubmFtZSB8fCBcIlwiO1xuICAgICAgaWYgKHRleHR1cmUubmFtZSA9PT0gXCJcIiAmJiB0eXBlb2Ygc291cmNlRGVmLnVyaSA9PT0gXCJzdHJpbmdcIiAmJiBzb3VyY2VEZWYudXJpLnN0YXJ0c1dpdGgoXCJkYXRhOmltYWdlL1wiKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGV4dHVyZS5uYW1lID0gc291cmNlRGVmLnVyaTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNhbXBsZXJzID0ganNvbi5zYW1wbGVycyB8fCB7fTtcbiAgICAgIGNvbnN0IHNhbXBsZXIgPSBzYW1wbGVyc1t0ZXh0dXJlRGVmLnNhbXBsZXJdIHx8IHt9O1xuICAgICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBXRUJHTF9GSUxURVJTW3NhbXBsZXIubWFnRmlsdGVyXSB8fCBMaW5lYXJGaWx0ZXI7XG4gICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IFdFQkdMX0ZJTFRFUlNbc2FtcGxlci5taW5GaWx0ZXJdIHx8IExpbmVhck1pcG1hcExpbmVhckZpbHRlcjtcbiAgICAgIHRleHR1cmUud3JhcFMgPSBXRUJHTF9XUkFQUElOR1Nbc2FtcGxlci53cmFwU10gfHwgUmVwZWF0V3JhcHBpbmc7XG4gICAgICB0ZXh0dXJlLndyYXBUID0gV0VCR0xfV1JBUFBJTkdTW3NhbXBsZXIud3JhcFRdIHx8IFJlcGVhdFdyYXBwaW5nO1xuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQodGV4dHVyZSwgeyB0ZXh0dXJlczogdGV4dHVyZUluZGV4IH0pO1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICB0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGxvYWRJbWFnZVNvdXJjZShzb3VyY2VJbmRleCwgbG9hZGVyKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHRoaXMuc291cmNlQ2FjaGVbc291cmNlSW5kZXhdICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZUNhY2hlW3NvdXJjZUluZGV4XS50aGVuKCh0ZXh0dXJlKSA9PiB0ZXh0dXJlLmNsb25lKCkpO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VEZWYgPSBqc29uLmltYWdlc1tzb3VyY2VJbmRleF07XG4gICAgY29uc3QgVVJMID0gc2VsZi5VUkwgfHwgc2VsZi53ZWJraXRVUkw7XG4gICAgbGV0IHNvdXJjZVVSSSA9IHNvdXJjZURlZi51cmkgfHwgXCJcIjtcbiAgICBsZXQgaXNPYmplY3RVUkwgPSBmYWxzZTtcbiAgICBpZiAoc291cmNlRGVmLmJ1ZmZlclZpZXcgIT09IHZvaWQgMCkge1xuICAgICAgc291cmNlVVJJID0gcGFyc2VyLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIHNvdXJjZURlZi5idWZmZXJWaWV3KS50aGVuKGZ1bmN0aW9uKGJ1ZmZlclZpZXcpIHtcbiAgICAgICAgaXNPYmplY3RVUkwgPSB0cnVlO1xuICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J1ZmZlclZpZXddLCB7IHR5cGU6IHNvdXJjZURlZi5taW1lVHlwZSB9KTtcbiAgICAgICAgc291cmNlVVJJID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZVVSSTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc291cmNlRGVmLnVyaSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBJbWFnZSBcIiArIHNvdXJjZUluZGV4ICsgXCIgaXMgbWlzc2luZyBVUkkgYW5kIGJ1ZmZlclZpZXdcIik7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoc291cmNlVVJJKS50aGVuKGZ1bmN0aW9uKHNvdXJjZVVSSTIpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbGV0IG9uTG9hZCA9IHJlc29sdmU7XG4gICAgICAgIGlmIChsb2FkZXIuaXNJbWFnZUJpdG1hcExvYWRlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG9uTG9hZCA9IGZ1bmN0aW9uKGltYWdlQml0bWFwKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoaW1hZ2VCaXRtYXApO1xuICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKHRleHR1cmUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbG9hZGVyLmxvYWQoTG9hZGVyVXRpbHMucmVzb2x2ZVVSTChzb3VyY2VVUkkyLCBvcHRpb25zLnBhdGgpLCBvbkxvYWQsIHZvaWQgMCwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24odGV4dHVyZSkge1xuICAgICAgaWYgKGlzT2JqZWN0VVJMID09PSB0cnVlKSB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoc291cmNlVVJJKTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEodGV4dHVyZSwgc291cmNlRGVmKTtcbiAgICAgIHRleHR1cmUudXNlckRhdGEubWltZVR5cGUgPSBzb3VyY2VEZWYubWltZVR5cGUgfHwgZ2V0SW1hZ2VVUklNaW1lVHlwZShzb3VyY2VEZWYudXJpKTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogQ291bGRuJ3QgbG9hZCB0ZXh0dXJlXCIsIHNvdXJjZVVSSSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgICB0aGlzLnNvdXJjZUNhY2hlW3NvdXJjZUluZGV4XSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91c2x5IGFzc2lnbnMgYSB0ZXh0dXJlIHRvIHRoZSBnaXZlbiBtYXRlcmlhbCBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWF0ZXJpYWxQYXJhbXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcE5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcERlZlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFRleHR1cmU+fVxuICAgKi9cbiAgYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgbWFwTmFtZSwgbWFwRGVmLCBjb2xvclNwYWNlKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5nZXREZXBlbmRlbmN5KFwidGV4dHVyZVwiLCBtYXBEZWYuaW5kZXgpLnRoZW4oZnVuY3Rpb24odGV4dHVyZSkge1xuICAgICAgaWYgKCF0ZXh0dXJlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChtYXBEZWYudGV4Q29vcmQgIT09IHZvaWQgMCAmJiBtYXBEZWYudGV4Q29vcmQgPiAwKSB7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlLmNsb25lKCk7XG4gICAgICAgIHRleHR1cmUuY2hhbm5lbCA9IG1hcERlZi50ZXhDb29yZDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZXIuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STV0pIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gbWFwRGVmLmV4dGVuc2lvbnMgIT09IHZvaWQgMCA/IG1hcERlZi5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNXSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgIGNvbnN0IGdsdGZSZWZlcmVuY2UgPSBwYXJzZXIuYXNzb2NpYXRpb25zLmdldCh0ZXh0dXJlKTtcbiAgICAgICAgICB0ZXh0dXJlID0gcGFyc2VyLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk1dLmV4dGVuZFRleHR1cmUodGV4dHVyZSwgdHJhbnNmb3JtKTtcbiAgICAgICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldCh0ZXh0dXJlLCBnbHRmUmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbG9yU3BhY2UgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbG9yU3BhY2UgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgY29sb3JTcGFjZSA9IGNvbG9yU3BhY2UgPT09IHNSR0JFbmNvZGluZyA/IFNSR0JDb2xvclNwYWNlIDogTGluZWFyU1JHQkNvbG9yU3BhY2U7XG4gICAgICAgIGlmIChcImNvbG9yU3BhY2VcIiBpbiB0ZXh0dXJlKVxuICAgICAgICAgIHRleHR1cmUuY29sb3JTcGFjZSA9IGNvbG9yU3BhY2U7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0ZXh0dXJlLmVuY29kaW5nID0gY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgPyBzUkdCRW5jb2RpbmcgOiBMaW5lYXJFbmNvZGluZztcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsUGFyYW1zW21hcE5hbWVdID0gdGV4dHVyZTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBc3NpZ25zIGZpbmFsIG1hdGVyaWFsIHRvIGEgTWVzaCwgTGluZSwgb3IgUG9pbnRzIGluc3RhbmNlLiBUaGUgaW5zdGFuY2VcbiAgICogYWxyZWFkeSBoYXMgYSBtYXRlcmlhbCAoZ2VuZXJhdGVkIGZyb20gdGhlIGdsVEYgbWF0ZXJpYWwgb3B0aW9ucyBhbG9uZSlcbiAgICogYnV0IHJldXNlIG9mIHRoZSBzYW1lIGdsVEYgbWF0ZXJpYWwgbWF5IHJlcXVpcmUgbXVsdGlwbGUgdGhyZWVqcyBtYXRlcmlhbHNcbiAgICogdG8gYWNjb21tb2RhdGUgZGlmZmVyZW50IHByaW1pdGl2ZSB0eXBlcywgZGVmaW5lcywgZXRjLiBOZXcgbWF0ZXJpYWxzIHdpbGxcbiAgICogYmUgY3JlYXRlZCBpZiBuZWNlc3NhcnksIGFuZCByZXVzZWQgZnJvbSBhIGNhY2hlLlxuICAgKiBAcGFyYW0gIHtPYmplY3QzRH0gbWVzaCBNZXNoLCBMaW5lLCBvciBQb2ludHMgaW5zdGFuY2UuXG4gICAqL1xuICBhc3NpZ25GaW5hbE1hdGVyaWFsKG1lc2gpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG1lc2guZ2VvbWV0cnk7XG4gICAgbGV0IG1hdGVyaWFsID0gbWVzaC5tYXRlcmlhbDtcbiAgICBjb25zdCB1c2VEZXJpdmF0aXZlVGFuZ2VudHMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnRhbmdlbnQgPT09IHZvaWQgMDtcbiAgICBjb25zdCB1c2VWZXJ0ZXhDb2xvcnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yICE9PSB2b2lkIDA7XG4gICAgY29uc3QgdXNlRmxhdFNoYWRpbmcgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdm9pZCAwO1xuICAgIGlmIChtZXNoLmlzUG9pbnRzKSB7XG4gICAgICBjb25zdCBjYWNoZUtleSA9IFwiUG9pbnRzTWF0ZXJpYWw6XCIgKyBtYXRlcmlhbC51dWlkO1xuICAgICAgbGV0IHBvaW50c01hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgaWYgKCFwb2ludHNNYXRlcmlhbCkge1xuICAgICAgICBwb2ludHNNYXRlcmlhbCA9IG5ldyBQb2ludHNNYXRlcmlhbCgpO1xuICAgICAgICBNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKHBvaW50c01hdGVyaWFsLCBtYXRlcmlhbCk7XG4gICAgICAgIHBvaW50c01hdGVyaWFsLmNvbG9yLmNvcHkobWF0ZXJpYWwuY29sb3IpO1xuICAgICAgICBwb2ludHNNYXRlcmlhbC5tYXAgPSBtYXRlcmlhbC5tYXA7XG4gICAgICAgIHBvaW50c01hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhY2hlLmFkZChjYWNoZUtleSwgcG9pbnRzTWF0ZXJpYWwpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWwgPSBwb2ludHNNYXRlcmlhbDtcbiAgICB9IGVsc2UgaWYgKG1lc2guaXNMaW5lKSB7XG4gICAgICBjb25zdCBjYWNoZUtleSA9IFwiTGluZUJhc2ljTWF0ZXJpYWw6XCIgKyBtYXRlcmlhbC51dWlkO1xuICAgICAgbGV0IGxpbmVNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmICghbGluZU1hdGVyaWFsKSB7XG4gICAgICAgIGxpbmVNYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCgpO1xuICAgICAgICBNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKGxpbmVNYXRlcmlhbCwgbWF0ZXJpYWwpO1xuICAgICAgICBsaW5lTWF0ZXJpYWwuY29sb3IuY29weShtYXRlcmlhbC5jb2xvcik7XG4gICAgICAgIGxpbmVNYXRlcmlhbC5tYXAgPSBtYXRlcmlhbC5tYXA7XG4gICAgICAgIHRoaXMuY2FjaGUuYWRkKGNhY2hlS2V5LCBsaW5lTWF0ZXJpYWwpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWwgPSBsaW5lTWF0ZXJpYWw7XG4gICAgfVxuICAgIGlmICh1c2VEZXJpdmF0aXZlVGFuZ2VudHMgfHwgdXNlVmVydGV4Q29sb3JzIHx8IHVzZUZsYXRTaGFkaW5nKSB7XG4gICAgICBsZXQgY2FjaGVLZXkgPSBcIkNsb25lZE1hdGVyaWFsOlwiICsgbWF0ZXJpYWwudXVpZCArIFwiOlwiO1xuICAgICAgaWYgKHVzZURlcml2YXRpdmVUYW5nZW50cylcbiAgICAgICAgY2FjaGVLZXkgKz0gXCJkZXJpdmF0aXZlLXRhbmdlbnRzOlwiO1xuICAgICAgaWYgKHVzZVZlcnRleENvbG9ycylcbiAgICAgICAgY2FjaGVLZXkgKz0gXCJ2ZXJ0ZXgtY29sb3JzOlwiO1xuICAgICAgaWYgKHVzZUZsYXRTaGFkaW5nKVxuICAgICAgICBjYWNoZUtleSArPSBcImZsYXQtc2hhZGluZzpcIjtcbiAgICAgIGxldCBjYWNoZWRNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmICghY2FjaGVkTWF0ZXJpYWwpIHtcbiAgICAgICAgY2FjaGVkTWF0ZXJpYWwgPSBtYXRlcmlhbC5jbG9uZSgpO1xuICAgICAgICBpZiAodXNlVmVydGV4Q29sb3JzKVxuICAgICAgICAgIGNhY2hlZE1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRydWU7XG4gICAgICAgIGlmICh1c2VGbGF0U2hhZGluZylcbiAgICAgICAgICBjYWNoZWRNYXRlcmlhbC5mbGF0U2hhZGluZyA9IHRydWU7XG4gICAgICAgIGlmICh1c2VEZXJpdmF0aXZlVGFuZ2VudHMpIHtcbiAgICAgICAgICBpZiAoY2FjaGVkTWF0ZXJpYWwubm9ybWFsU2NhbGUpXG4gICAgICAgICAgICBjYWNoZWRNYXRlcmlhbC5ub3JtYWxTY2FsZS55ICo9IC0xO1xuICAgICAgICAgIGlmIChjYWNoZWRNYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxTY2FsZSlcbiAgICAgICAgICAgIGNhY2hlZE1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlLnkgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZS5hZGQoY2FjaGVLZXksIGNhY2hlZE1hdGVyaWFsKTtcbiAgICAgICAgdGhpcy5hc3NvY2lhdGlvbnMuc2V0KGNhY2hlZE1hdGVyaWFsLCB0aGlzLmFzc29jaWF0aW9ucy5nZXQobWF0ZXJpYWwpKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsID0gY2FjaGVkTWF0ZXJpYWw7XG4gICAgfVxuICAgIG1lc2gubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUoKSB7XG4gICAgcmV0dXJuIE1lc2hTdGFuZGFyZE1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI21hdGVyaWFsc1xuICAgKiBAcGFyYW0ge251bWJlcn0gbWF0ZXJpYWxJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE1hdGVyaWFsPn1cbiAgICovXG4gIGxvYWRNYXRlcmlhbChtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBqc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBsZXQgbWF0ZXJpYWxUeXBlO1xuICAgIGNvbnN0IG1hdGVyaWFsUGFyYW1zID0ge307XG4gICAgY29uc3QgbWF0ZXJpYWxFeHRlbnNpb25zID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgaWYgKG1hdGVyaWFsRXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVRdKSB7XG4gICAgICBjb25zdCBrbXVFeHRlbnNpb24gPSBleHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVF07XG4gICAgICBtYXRlcmlhbFR5cGUgPSBrbXVFeHRlbnNpb24uZ2V0TWF0ZXJpYWxUeXBlKCk7XG4gICAgICBwZW5kaW5nLnB1c2goa211RXh0ZW5zaW9uLmV4dGVuZFBhcmFtcyhtYXRlcmlhbFBhcmFtcywgbWF0ZXJpYWxEZWYsIHBhcnNlcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtZXRhbGxpY1JvdWdobmVzcyA9IG1hdGVyaWFsRGVmLnBick1ldGFsbGljUm91Z2huZXNzIHx8IHt9O1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuY29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gMTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcikpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3I7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmNvbG9yLnNldFJHQihhcnJheVswXSwgYXJyYXlbMV0sIGFycmF5WzJdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSBhcnJheVszXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcIm1hcFwiLCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSkpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWxQYXJhbXMubWV0YWxuZXNzID0gbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNGYWN0b3IgIT09IHZvaWQgMCA/IG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljRmFjdG9yIDogMTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnJvdWdobmVzcyA9IG1ldGFsbGljUm91Z2huZXNzLnJvdWdobmVzc0ZhY3RvciAhPT0gdm9pZCAwID8gbWV0YWxsaWNSb3VnaG5lc3Mucm91Z2huZXNzRmFjdG9yIDogMTtcbiAgICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwibWV0YWxuZXNzTWFwXCIsIG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkpO1xuICAgICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwicm91Z2huZXNzTWFwXCIsIG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWxUeXBlID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICByZXR1cm4gZXh0LmdldE1hdGVyaWFsVHlwZSAmJiBleHQuZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgIHRoaXMuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQuZXh0ZW5kTWF0ZXJpYWxQYXJhbXMgJiYgZXh0LmV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYuZG91YmxlU2lkZWQgPT09IHRydWUpIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnNpZGUgPSBEb3VibGVTaWRlO1xuICAgIH1cbiAgICBjb25zdCBhbHBoYU1vZGUgPSBtYXRlcmlhbERlZi5hbHBoYU1vZGUgfHwgQUxQSEFfTU9ERVMuT1BBUVVFO1xuICAgIGlmIChhbHBoYU1vZGUgPT09IEFMUEhBX01PREVTLkJMRU5EKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5kZXB0aFdyaXRlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnRyYW5zcGFyZW50ID0gZmFsc2U7XG4gICAgICBpZiAoYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5NQVNLKSB7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmFscGhhVGVzdCA9IG1hdGVyaWFsRGVmLmFscGhhQ3V0b2ZmICE9PSB2b2lkIDAgPyBtYXRlcmlhbERlZi5hbHBoYUN1dG9mZiA6IDAuNTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUgIT09IHZvaWQgMCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwibm9ybWFsTWFwXCIsIG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUpKTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoMSwgMSk7XG4gICAgICBpZiAobWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZS5zY2FsZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZS5zY2FsZTtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMubm9ybWFsU2NhbGUuc2V0KHNjYWxlLCBzY2FsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlICE9PSB2b2lkIDAgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImFvTWFwXCIsIG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUpKTtcbiAgICAgIGlmIChtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlLnN0cmVuZ3RoICE9PSB2b2lkIDApIHtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuYW9NYXBJbnRlbnNpdHkgPSBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlLnN0cmVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYuZW1pc3NpdmVGYWN0b3IgIT09IHZvaWQgMCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsKSB7XG4gICAgICBjb25zdCBlbWlzc2l2ZUZhY3RvciA9IG1hdGVyaWFsRGVmLmVtaXNzaXZlRmFjdG9yO1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoKS5zZXRSR0IoXG4gICAgICAgIGVtaXNzaXZlRmFjdG9yWzBdLFxuICAgICAgICBlbWlzc2l2ZUZhY3RvclsxXSxcbiAgICAgICAgZW1pc3NpdmVGYWN0b3JbMl0sXG4gICAgICAgIExpbmVhclNSR0JDb2xvclNwYWNlXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYuZW1pc3NpdmVUZXh0dXJlICE9PSB2b2lkIDAgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImVtaXNzaXZlTWFwXCIsIG1hdGVyaWFsRGVmLmVtaXNzaXZlVGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBtYXRlcmlhbFR5cGUobWF0ZXJpYWxQYXJhbXMpO1xuICAgICAgaWYgKG1hdGVyaWFsRGVmLm5hbWUpXG4gICAgICAgIG1hdGVyaWFsLm5hbWUgPSBtYXRlcmlhbERlZi5uYW1lO1xuICAgICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShtYXRlcmlhbCwgbWF0ZXJpYWxEZWYpO1xuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQobWF0ZXJpYWwsIHsgbWF0ZXJpYWxzOiBtYXRlcmlhbEluZGV4IH0pO1xuICAgICAgaWYgKG1hdGVyaWFsRGVmLmV4dGVuc2lvbnMpXG4gICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBtYXRlcmlhbCwgbWF0ZXJpYWxEZWYpO1xuICAgICAgcmV0dXJuIG1hdGVyaWFsO1xuICAgIH0pO1xuICB9XG4gIC8qKiBXaGVuIE9iamVjdDNEIGluc3RhbmNlcyBhcmUgdGFyZ2V0ZWQgYnkgYW5pbWF0aW9uLCB0aGV5IG5lZWQgdW5pcXVlIG5hbWVzLiAqL1xuICBjcmVhdGVVbmlxdWVOYW1lKG9yaWdpbmFsTmFtZSkge1xuICAgIGNvbnN0IHNhbml0aXplZE5hbWUgPSBQcm9wZXJ0eUJpbmRpbmcuc2FuaXRpemVOb2RlTmFtZShvcmlnaW5hbE5hbWUgfHwgXCJcIik7XG4gICAgaWYgKHNhbml0aXplZE5hbWUgaW4gdGhpcy5ub2RlTmFtZXNVc2VkKSB7XG4gICAgICByZXR1cm4gc2FuaXRpemVkTmFtZSArIFwiX1wiICsgKyt0aGlzLm5vZGVOYW1lc1VzZWRbc2FuaXRpemVkTmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm9kZU5hbWVzVXNlZFtzYW5pdGl6ZWROYW1lXSA9IDA7XG4gICAgICByZXR1cm4gc2FuaXRpemVkTmFtZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjZ2VvbWV0cnlcbiAgICpcbiAgICogQ3JlYXRlcyBCdWZmZXJHZW9tZXRyaWVzIGZyb20gcHJpbWl0aXZlcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxHTFRGLlByaW1pdGl2ZT59IHByaW1pdGl2ZXNcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxCdWZmZXJHZW9tZXRyeT4+fVxuICAgKi9cbiAgbG9hZEdlb21ldHJpZXMocHJpbWl0aXZlcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMucHJpbWl0aXZlQ2FjaGU7XG4gICAgZnVuY3Rpb24gY3JlYXRlRHJhY29QcmltaXRpdmUocHJpbWl0aXZlKSB7XG4gICAgICByZXR1cm4gZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OXS5kZWNvZGVQcmltaXRpdmUocHJpbWl0aXZlLCBwYXJzZXIpLnRoZW4oZnVuY3Rpb24oZ2VvbWV0cnkpIHtcbiAgICAgICAgcmV0dXJuIGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMoZ2VvbWV0cnksIHByaW1pdGl2ZSwgcGFyc2VyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gcHJpbWl0aXZlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjb25zdCBwcmltaXRpdmUgPSBwcmltaXRpdmVzW2ldO1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBjcmVhdGVQcmltaXRpdmVLZXkocHJpbWl0aXZlKTtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKGNhY2hlZC5wcm9taXNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBnZW9tZXRyeVByb21pc2U7XG4gICAgICAgIGlmIChwcmltaXRpdmUuZXh0ZW5zaW9ucyAmJiBwcmltaXRpdmUuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OXSkge1xuICAgICAgICAgIGdlb21ldHJ5UHJvbWlzZSA9IGNyZWF0ZURyYWNvUHJpbWl0aXZlKHByaW1pdGl2ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VvbWV0cnlQcm9taXNlID0gYWRkUHJpbWl0aXZlQXR0cmlidXRlcyhuZXcgQnVmZmVyR2VvbWV0cnkoKSwgcHJpbWl0aXZlLCBwYXJzZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHsgcHJpbWl0aXZlLCBwcm9taXNlOiBnZW9tZXRyeVByb21pc2UgfTtcbiAgICAgICAgcGVuZGluZy5wdXNoKGdlb21ldHJ5UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNtZXNoZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1lc2hJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEdyb3VwfE1lc2h8U2tpbm5lZE1lc2g+fVxuICAgKi9cbiAgbG9hZE1lc2gobWVzaEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3QgbWVzaERlZiA9IGpzb24ubWVzaGVzW21lc2hJbmRleF07XG4gICAgY29uc3QgcHJpbWl0aXZlcyA9IG1lc2hEZWYucHJpbWl0aXZlcztcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gcHJpbWl0aXZlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbCA9IHByaW1pdGl2ZXNbaV0ubWF0ZXJpYWwgPT09IHZvaWQgMCA/IGNyZWF0ZURlZmF1bHRNYXRlcmlhbCh0aGlzLmNhY2hlKSA6IHRoaXMuZ2V0RGVwZW5kZW5jeShcIm1hdGVyaWFsXCIsIHByaW1pdGl2ZXNbaV0ubWF0ZXJpYWwpO1xuICAgICAgcGVuZGluZy5wdXNoKG1hdGVyaWFsKTtcbiAgICB9XG4gICAgcGVuZGluZy5wdXNoKHBhcnNlci5sb2FkR2VvbWV0cmllcyhwcmltaXRpdmVzKSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgY29uc3QgbWF0ZXJpYWxzID0gcmVzdWx0cy5zbGljZSgwLCByZXN1bHRzLmxlbmd0aCAtIDEpO1xuICAgICAgY29uc3QgZ2VvbWV0cmllcyA9IHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IG1lc2hlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZ2VvbWV0cmllc1tpXTtcbiAgICAgICAgY29uc3QgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1tpXTtcbiAgICAgICAgbGV0IG1lc2g7XG4gICAgICAgIGNvbnN0IG1hdGVyaWFsID0gbWF0ZXJpYWxzW2ldO1xuICAgICAgICBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRVMgfHwgcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9TVFJJUCB8fCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX0ZBTiB8fCBwcmltaXRpdmUubW9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgbWVzaCA9IG1lc2hEZWYuaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZSA/IG5ldyBTa2lubmVkTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpIDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgICBpZiAobWVzaC5pc1NraW5uZWRNZXNoID09PSB0cnVlKSB7XG4gICAgICAgICAgICBtZXNoLm5vcm1hbGl6ZVNraW5XZWlnaHRzKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX1NUUklQKSB7XG4gICAgICAgICAgICBtZXNoLmdlb21ldHJ5ID0gdG9UcmlhbmdsZXNEcmF3TW9kZShtZXNoLmdlb21ldHJ5LCBUcmlhbmdsZVN0cmlwRHJhd01vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4pIHtcbiAgICAgICAgICAgIG1lc2guZ2VvbWV0cnkgPSB0b1RyaWFuZ2xlc0RyYXdNb2RlKG1lc2guZ2VvbWV0cnksIFRyaWFuZ2xlRmFuRHJhd01vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVTKSB7XG4gICAgICAgICAgbWVzaCA9IG5ldyBMaW5lU2VnbWVudHMoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVfU1RSSVApIHtcbiAgICAgICAgICBtZXNoID0gbmV3IExpbmUoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVfTE9PUCkge1xuICAgICAgICAgIG1lc2ggPSBuZXcgTGluZUxvb3AoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlBPSU5UUykge1xuICAgICAgICAgIG1lc2ggPSBuZXcgUG9pbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogUHJpbWl0aXZlIG1vZGUgdW5zdXBwb3J0ZWQ6IFwiICsgcHJpbWl0aXZlLm1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhtZXNoLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHVwZGF0ZU1vcnBoVGFyZ2V0cyhtZXNoLCBtZXNoRGVmKTtcbiAgICAgICAgfVxuICAgICAgICBtZXNoLm5hbWUgPSBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZShtZXNoRGVmLm5hbWUgfHwgXCJtZXNoX1wiICsgbWVzaEluZGV4KTtcbiAgICAgICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShtZXNoLCBtZXNoRGVmKTtcbiAgICAgICAgaWYgKHByaW1pdGl2ZS5leHRlbnNpb25zKVxuICAgICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBtZXNoLCBwcmltaXRpdmUpO1xuICAgICAgICBwYXJzZXIuYXNzaWduRmluYWxNYXRlcmlhbChtZXNoKTtcbiAgICAgICAgbWVzaGVzLnB1c2gobWVzaCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBtZXNoZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldChtZXNoZXNbaV0sIHtcbiAgICAgICAgICBtZXNoZXM6IG1lc2hJbmRleCxcbiAgICAgICAgICBwcmltaXRpdmVzOiBpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG1lc2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKG1lc2hEZWYuZXh0ZW5zaW9ucylcbiAgICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgbWVzaGVzWzBdLCBtZXNoRGVmKTtcbiAgICAgICAgcmV0dXJuIG1lc2hlc1swXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdyb3VwID0gbmV3IEdyb3VwKCk7XG4gICAgICBpZiAobWVzaERlZi5leHRlbnNpb25zKVxuICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgZ3JvdXAsIG1lc2hEZWYpO1xuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQoZ3JvdXAsIHsgbWVzaGVzOiBtZXNoSW5kZXggfSk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBtZXNoZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBncm91cC5hZGQobWVzaGVzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI2NhbWVyYXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNhbWVyYUluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8VEhSRUUuQ2FtZXJhPn1cbiAgICovXG4gIGxvYWRDYW1lcmEoY2FtZXJhSW5kZXgpIHtcbiAgICBsZXQgY2FtZXJhO1xuICAgIGNvbnN0IGNhbWVyYURlZiA9IHRoaXMuanNvbi5jYW1lcmFzW2NhbWVyYUluZGV4XTtcbiAgICBjb25zdCBwYXJhbXMgPSBjYW1lcmFEZWZbY2FtZXJhRGVmLnR5cGVdO1xuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIGNhbWVyYSBwYXJhbWV0ZXJzLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhbWVyYURlZi50eXBlID09PSBcInBlcnNwZWN0aXZlXCIpIHtcbiAgICAgIGNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShcbiAgICAgICAgTWF0aFV0aWxzLnJhZFRvRGVnKHBhcmFtcy55Zm92KSxcbiAgICAgICAgcGFyYW1zLmFzcGVjdFJhdGlvIHx8IDEsXG4gICAgICAgIHBhcmFtcy56bmVhciB8fCAxLFxuICAgICAgICBwYXJhbXMuemZhciB8fCAyZTZcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjYW1lcmFEZWYudHlwZSA9PT0gXCJvcnRob2dyYXBoaWNcIikge1xuICAgICAgY2FtZXJhID0gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSgtcGFyYW1zLnhtYWcsIHBhcmFtcy54bWFnLCBwYXJhbXMueW1hZywgLXBhcmFtcy55bWFnLCBwYXJhbXMuem5lYXIsIHBhcmFtcy56ZmFyKTtcbiAgICB9XG4gICAgaWYgKGNhbWVyYURlZi5uYW1lKVxuICAgICAgY2FtZXJhLm5hbWUgPSB0aGlzLmNyZWF0ZVVuaXF1ZU5hbWUoY2FtZXJhRGVmLm5hbWUpO1xuICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoY2FtZXJhLCBjYW1lcmFEZWYpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3NraW5zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBza2luSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxTa2VsZXRvbj59XG4gICAqL1xuICBsb2FkU2tpbihza2luSW5kZXgpIHtcbiAgICBjb25zdCBza2luRGVmID0gdGhpcy5qc29uLnNraW5zW3NraW5JbmRleF07XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHNraW5EZWYuam9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIHBlbmRpbmcucHVzaCh0aGlzLl9sb2FkTm9kZVNoYWxsb3coc2tpbkRlZi5qb2ludHNbaV0pKTtcbiAgICB9XG4gICAgaWYgKHNraW5EZWYuaW52ZXJzZUJpbmRNYXRyaWNlcyAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgc2tpbkRlZi5pbnZlcnNlQmluZE1hdHJpY2VzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmcucHVzaChudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgY29uc3QgaW52ZXJzZUJpbmRNYXRyaWNlcyA9IHJlc3VsdHMucG9wKCk7XG4gICAgICBjb25zdCBqb2ludE5vZGVzID0gcmVzdWx0cztcbiAgICAgIGNvbnN0IGJvbmVzID0gW107XG4gICAgICBjb25zdCBib25lSW52ZXJzZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGpvaW50Tm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBjb25zdCBqb2ludE5vZGUgPSBqb2ludE5vZGVzW2ldO1xuICAgICAgICBpZiAoam9pbnROb2RlKSB7XG4gICAgICAgICAgYm9uZXMucHVzaChqb2ludE5vZGUpO1xuICAgICAgICAgIGNvbnN0IG1hdCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICAgICAgaWYgKGludmVyc2VCaW5kTWF0cmljZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1hdC5mcm9tQXJyYXkoaW52ZXJzZUJpbmRNYXRyaWNlcy5hcnJheSwgaSAqIDE2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm9uZUludmVyc2VzLnB1c2gobWF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLkdMVEZMb2FkZXI6IEpvaW50IFwiJXNcIiBjb3VsZCBub3QgYmUgZm91bmQuJywgc2tpbkRlZi5qb2ludHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFNrZWxldG9uKGJvbmVzLCBib25lSW52ZXJzZXMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjYW5pbWF0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gYW5pbWF0aW9uSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxBbmltYXRpb25DbGlwPn1cbiAgICovXG4gIGxvYWRBbmltYXRpb24oYW5pbWF0aW9uSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QgYW5pbWF0aW9uRGVmID0ganNvbi5hbmltYXRpb25zW2FuaW1hdGlvbkluZGV4XTtcbiAgICBjb25zdCBhbmltYXRpb25OYW1lID0gYW5pbWF0aW9uRGVmLm5hbWUgPyBhbmltYXRpb25EZWYubmFtZSA6IFwiYW5pbWF0aW9uX1wiICsgYW5pbWF0aW9uSW5kZXg7XG4gICAgY29uc3QgcGVuZGluZ05vZGVzID0gW107XG4gICAgY29uc3QgcGVuZGluZ0lucHV0QWNjZXNzb3JzID0gW107XG4gICAgY29uc3QgcGVuZGluZ091dHB1dEFjY2Vzc29ycyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdTYW1wbGVycyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdUYXJnZXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gYW5pbWF0aW9uRGVmLmNoYW5uZWxzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSBhbmltYXRpb25EZWYuY2hhbm5lbHNbaV07XG4gICAgICBjb25zdCBzYW1wbGVyID0gYW5pbWF0aW9uRGVmLnNhbXBsZXJzW2NoYW5uZWwuc2FtcGxlcl07XG4gICAgICBjb25zdCB0YXJnZXQgPSBjaGFubmVsLnRhcmdldDtcbiAgICAgIGNvbnN0IG5hbWUgPSB0YXJnZXQubm9kZTtcbiAgICAgIGNvbnN0IGlucHV0ID0gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnMgIT09IHZvaWQgMCA/IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzW3NhbXBsZXIuaW5wdXRdIDogc2FtcGxlci5pbnB1dDtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzICE9PSB2b2lkIDAgPyBhbmltYXRpb25EZWYucGFyYW1ldGVyc1tzYW1wbGVyLm91dHB1dF0gOiBzYW1wbGVyLm91dHB1dDtcbiAgICAgIGlmICh0YXJnZXQubm9kZSA9PT0gdm9pZCAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHBlbmRpbmdOb2Rlcy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcIm5vZGVcIiwgbmFtZSkpO1xuICAgICAgcGVuZGluZ0lucHV0QWNjZXNzb3JzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgaW5wdXQpKTtcbiAgICAgIHBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBvdXRwdXQpKTtcbiAgICAgIHBlbmRpbmdTYW1wbGVycy5wdXNoKHNhbXBsZXIpO1xuICAgICAgcGVuZGluZ1RhcmdldHMucHVzaCh0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ05vZGVzKSxcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdJbnB1dEFjY2Vzc29ycyksXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nT3V0cHV0QWNjZXNzb3JzKSxcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdTYW1wbGVycyksXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nVGFyZ2V0cylcbiAgICBdKS50aGVuKGZ1bmN0aW9uKGRlcGVuZGVuY2llcykge1xuICAgICAgY29uc3Qgbm9kZXMgPSBkZXBlbmRlbmNpZXNbMF07XG4gICAgICBjb25zdCBpbnB1dEFjY2Vzc29ycyA9IGRlcGVuZGVuY2llc1sxXTtcbiAgICAgIGNvbnN0IG91dHB1dEFjY2Vzc29ycyA9IGRlcGVuZGVuY2llc1syXTtcbiAgICAgIGNvbnN0IHNhbXBsZXJzID0gZGVwZW5kZW5jaWVzWzNdO1xuICAgICAgY29uc3QgdGFyZ2V0cyA9IGRlcGVuZGVuY2llc1s0XTtcbiAgICAgIGNvbnN0IHRyYWNrcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGNvbnN0IGlucHV0QWNjZXNzb3IgPSBpbnB1dEFjY2Vzc29yc1tpXTtcbiAgICAgICAgY29uc3Qgb3V0cHV0QWNjZXNzb3IgPSBvdXRwdXRBY2Nlc3NvcnNbaV07XG4gICAgICAgIGNvbnN0IHNhbXBsZXIgPSBzYW1wbGVyc1tpXTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHZvaWQgMClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKG5vZGUudXBkYXRlTWF0cml4KSB7XG4gICAgICAgICAgbm9kZS51cGRhdGVNYXRyaXgoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVhdGVkVHJhY2tzID0gcGFyc2VyLl9jcmVhdGVBbmltYXRpb25UcmFja3Mobm9kZSwgaW5wdXRBY2Nlc3Nvciwgb3V0cHV0QWNjZXNzb3IsIHNhbXBsZXIsIHRhcmdldCk7XG4gICAgICAgIGlmIChjcmVhdGVkVHJhY2tzKSB7XG4gICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjcmVhdGVkVHJhY2tzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB0cmFja3MucHVzaChjcmVhdGVkVHJhY2tzW2tdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uQ2xpcChhbmltYXRpb25OYW1lLCB2b2lkIDAsIHRyYWNrcyk7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlTm9kZU1lc2gobm9kZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzW25vZGVJbmRleF07XG4gICAgaWYgKG5vZGVEZWYubWVzaCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KFwibWVzaFwiLCBub2RlRGVmLm1lc2gpLnRoZW4oZnVuY3Rpb24obWVzaCkge1xuICAgICAgY29uc3Qgbm9kZSA9IHBhcnNlci5fZ2V0Tm9kZVJlZihwYXJzZXIubWVzaENhY2hlLCBub2RlRGVmLm1lc2gsIG1lc2gpO1xuICAgICAgaWYgKG5vZGVEZWYud2VpZ2h0cyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG5vZGUudHJhdmVyc2UoZnVuY3Rpb24obykge1xuICAgICAgICAgIGlmICghby5pc01lc2gpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbm9kZURlZi53ZWlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICAgIG8ubW9ycGhUYXJnZXRJbmZsdWVuY2VzW2ldID0gbm9kZURlZi53ZWlnaHRzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI25vZGVzLWFuZC1oaWVyYXJjaHlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5vZGVJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdDNEPn1cbiAgICovXG4gIGxvYWROb2RlKG5vZGVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGNvbnN0IG5vZGVQZW5kaW5nID0gcGFyc2VyLl9sb2FkTm9kZVNoYWxsb3cobm9kZUluZGV4KTtcbiAgICBjb25zdCBjaGlsZFBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBjaGlsZHJlbkRlZiA9IG5vZGVEZWYuY2hpbGRyZW4gfHwgW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gY2hpbGRyZW5EZWYubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY2hpbGRQZW5kaW5nLnB1c2gocGFyc2VyLmdldERlcGVuZGVuY3koXCJub2RlXCIsIGNoaWxkcmVuRGVmW2ldKSk7XG4gICAgfVxuICAgIGNvbnN0IHNrZWxldG9uUGVuZGluZyA9IG5vZGVEZWYuc2tpbiA9PT0gdm9pZCAwID8gUHJvbWlzZS5yZXNvbHZlKG51bGwpIDogcGFyc2VyLmdldERlcGVuZGVuY3koXCJza2luXCIsIG5vZGVEZWYuc2tpbik7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtub2RlUGVuZGluZywgUHJvbWlzZS5hbGwoY2hpbGRQZW5kaW5nKSwgc2tlbGV0b25QZW5kaW5nXSkudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICBjb25zdCBub2RlID0gcmVzdWx0c1swXTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gcmVzdWx0c1sxXTtcbiAgICAgIGNvbnN0IHNrZWxldG9uID0gcmVzdWx0c1syXTtcbiAgICAgIGlmIChza2VsZXRvbiAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLnRyYXZlcnNlKGZ1bmN0aW9uKG1lc2gpIHtcbiAgICAgICAgICBpZiAoIW1lc2guaXNTa2lubmVkTWVzaClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBtZXNoLmJpbmQoc2tlbGV0b24sIF9pZGVudGl0eU1hdHJpeCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBub2RlLmFkZChjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgfVxuICAvLyAuX2xvYWROb2RlU2hhbGxvdygpIHBhcnNlcyBhIHNpbmdsZSBub2RlLlxuICAvLyBza2luIGFuZCBjaGlsZCBub2RlcyBhcmUgY3JlYXRlZCBhbmQgYWRkZWQgaW4gLmxvYWROb2RlKCkgKG5vICdfJyBwcmVmaXgpLlxuICBfbG9hZE5vZGVTaGFsbG93KG5vZGVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGlmICh0aGlzLm5vZGVDYWNoZVtub2RlSW5kZXhdICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVDYWNoZVtub2RlSW5kZXhdO1xuICAgIH1cbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGNvbnN0IG5vZGVOYW1lID0gbm9kZURlZi5uYW1lID8gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUobm9kZURlZi5uYW1lKSA6IFwiXCI7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IG1lc2hQcm9taXNlID0gcGFyc2VyLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICByZXR1cm4gZXh0LmNyZWF0ZU5vZGVNZXNoICYmIGV4dC5jcmVhdGVOb2RlTWVzaChub2RlSW5kZXgpO1xuICAgIH0pO1xuICAgIGlmIChtZXNoUHJvbWlzZSkge1xuICAgICAgcGVuZGluZy5wdXNoKG1lc2hQcm9taXNlKTtcbiAgICB9XG4gICAgaWYgKG5vZGVEZWYuY2FtZXJhICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChcbiAgICAgICAgcGFyc2VyLmdldERlcGVuZGVuY3koXCJjYW1lcmFcIiwgbm9kZURlZi5jYW1lcmEpLnRoZW4oZnVuY3Rpb24oY2FtZXJhKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlci5fZ2V0Tm9kZVJlZihwYXJzZXIuY2FtZXJhQ2FjaGUsIG5vZGVEZWYuY2FtZXJhLCBjYW1lcmEpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcGFyc2VyLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICByZXR1cm4gZXh0LmNyZWF0ZU5vZGVBdHRhY2htZW50ICYmIGV4dC5jcmVhdGVOb2RlQXR0YWNobWVudChub2RlSW5kZXgpO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgICAgcGVuZGluZy5wdXNoKHByb21pc2UpO1xuICAgIH0pO1xuICAgIHRoaXMubm9kZUNhY2hlW25vZGVJbmRleF0gPSBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKG9iamVjdHMpIHtcbiAgICAgIGxldCBub2RlO1xuICAgICAgaWYgKG5vZGVEZWYuaXNCb25lID09PSB0cnVlKSB7XG4gICAgICAgIG5vZGUgPSBuZXcgQm9uZSgpO1xuICAgICAgfSBlbHNlIGlmIChvYmplY3RzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbm9kZSA9IG5ldyBHcm91cCgpO1xuICAgICAgfSBlbHNlIGlmIChvYmplY3RzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBub2RlID0gb2JqZWN0c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBuZXcgT2JqZWN0M0QoKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlICE9PSBvYmplY3RzWzBdKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgIG5vZGUuYWRkKG9iamVjdHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZURlZi5uYW1lKSB7XG4gICAgICAgIG5vZGUudXNlckRhdGEubmFtZSA9IG5vZGVEZWYubmFtZTtcbiAgICAgICAgbm9kZS5uYW1lID0gbm9kZU5hbWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKG5vZGUsIG5vZGVEZWYpO1xuICAgICAgaWYgKG5vZGVEZWYuZXh0ZW5zaW9ucylcbiAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIG5vZGUsIG5vZGVEZWYpO1xuICAgICAgaWYgKG5vZGVEZWYubWF0cml4ICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICAgICAgbWF0cml4LmZyb21BcnJheShub2RlRGVmLm1hdHJpeCk7XG4gICAgICAgIG5vZGUuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobm9kZURlZi50cmFuc2xhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgbm9kZS5wb3NpdGlvbi5mcm9tQXJyYXkobm9kZURlZi50cmFuc2xhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVEZWYucm90YXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICAgIG5vZGUucXVhdGVybmlvbi5mcm9tQXJyYXkobm9kZURlZi5yb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVEZWYuc2NhbGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIG5vZGUuc2NhbGUuZnJvbUFycmF5KG5vZGVEZWYuc2NhbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXBhcnNlci5hc3NvY2lhdGlvbnMuaGFzKG5vZGUpKSB7XG4gICAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KG5vZGUsIHt9KTtcbiAgICAgIH1cbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuZ2V0KG5vZGUpLm5vZGVzID0gbm9kZUluZGV4O1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMubm9kZUNhY2hlW25vZGVJbmRleF07XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNzY2VuZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjZW5lSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxHcm91cD59XG4gICAqL1xuICBsb2FkU2NlbmUoc2NlbmVJbmRleCkge1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3Qgc2NlbmVEZWYgPSB0aGlzLmpzb24uc2NlbmVzW3NjZW5lSW5kZXhdO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3Qgc2NlbmUgPSBuZXcgR3JvdXAoKTtcbiAgICBpZiAoc2NlbmVEZWYubmFtZSlcbiAgICAgIHNjZW5lLm5hbWUgPSBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZShzY2VuZURlZi5uYW1lKTtcbiAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKHNjZW5lLCBzY2VuZURlZik7XG4gICAgaWYgKHNjZW5lRGVmLmV4dGVuc2lvbnMpXG4gICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgc2NlbmUsIHNjZW5lRGVmKTtcbiAgICBjb25zdCBub2RlSWRzID0gc2NlbmVEZWYubm9kZXMgfHwgW107XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG5vZGVJZHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5nZXREZXBlbmRlbmN5KFwibm9kZVwiLCBub2RlSWRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBub2Rlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIHNjZW5lLmFkZChub2Rlc1tpXSk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWR1Y2VBc3NvY2lhdGlvbnMgPSAobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCByZWR1Y2VkQXNzb2NpYXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgcGFyc2VyLmFzc29jaWF0aW9ucykge1xuICAgICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBNYXRlcmlhbCB8fCBrZXkgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICAgICAgICByZWR1Y2VkQXNzb2NpYXRpb25zLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS50cmF2ZXJzZSgobm9kZTIpID0+IHtcbiAgICAgICAgICBjb25zdCBtYXBwaW5ncyA9IHBhcnNlci5hc3NvY2lhdGlvbnMuZ2V0KG5vZGUyKTtcbiAgICAgICAgICBpZiAobWFwcGluZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVkdWNlZEFzc29jaWF0aW9ucy5zZXQobm9kZTIsIG1hcHBpbmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVkdWNlZEFzc29jaWF0aW9ucztcbiAgICAgIH07XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zID0gcmVkdWNlQXNzb2NpYXRpb25zKHNjZW5lKTtcbiAgICAgIHJldHVybiBzY2VuZTtcbiAgICB9KTtcbiAgfVxuICBfY3JlYXRlQW5pbWF0aW9uVHJhY2tzKG5vZGUsIGlucHV0QWNjZXNzb3IsIG91dHB1dEFjY2Vzc29yLCBzYW1wbGVyLCB0YXJnZXQpIHtcbiAgICBjb25zdCB0cmFja3MgPSBbXTtcbiAgICBjb25zdCB0YXJnZXROYW1lID0gbm9kZS5uYW1lID8gbm9kZS5uYW1lIDogbm9kZS51dWlkO1xuICAgIGNvbnN0IHRhcmdldE5hbWVzID0gW107XG4gICAgaWYgKFBBVEhfUFJPUEVSVElFU1t0YXJnZXQucGF0aF0gPT09IFBBVEhfUFJPUEVSVElFUy53ZWlnaHRzKSB7XG4gICAgICBub2RlLnRyYXZlcnNlKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcykge1xuICAgICAgICAgIHRhcmdldE5hbWVzLnB1c2gob2JqZWN0Lm5hbWUgPyBvYmplY3QubmFtZSA6IG9iamVjdC51dWlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldE5hbWVzLnB1c2godGFyZ2V0TmFtZSk7XG4gICAgfVxuICAgIGxldCBUeXBlZEtleWZyYW1lVHJhY2s7XG4gICAgc3dpdGNoIChQQVRIX1BST1BFUlRJRVNbdGFyZ2V0LnBhdGhdKSB7XG4gICAgICBjYXNlIFBBVEhfUFJPUEVSVElFUy53ZWlnaHRzOlxuICAgICAgICBUeXBlZEtleWZyYW1lVHJhY2sgPSBOdW1iZXJLZXlmcmFtZVRyYWNrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUEFUSF9QUk9QRVJUSUVTLnJvdGF0aW9uOlxuICAgICAgICBUeXBlZEtleWZyYW1lVHJhY2sgPSBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBBVEhfUFJPUEVSVElFUy5wb3NpdGlvbjpcbiAgICAgIGNhc2UgUEFUSF9QUk9QRVJUSUVTLnNjYWxlOlxuICAgICAgICBUeXBlZEtleWZyYW1lVHJhY2sgPSBWZWN0b3JLZXlmcmFtZVRyYWNrO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN3aXRjaCAob3V0cHV0QWNjZXNzb3IuaXRlbVNpemUpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBUeXBlZEtleWZyYW1lVHJhY2sgPSBOdW1iZXJLZXlmcmFtZVRyYWNrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgVHlwZWRLZXlmcmFtZVRyYWNrID0gVmVjdG9yS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcnBvbGF0aW9uID0gc2FtcGxlci5pbnRlcnBvbGF0aW9uICE9PSB2b2lkIDAgPyBJTlRFUlBPTEFUSU9OW3NhbXBsZXIuaW50ZXJwb2xhdGlvbl0gOiBJbnRlcnBvbGF0ZUxpbmVhcjtcbiAgICBjb25zdCBvdXRwdXRBcnJheSA9IHRoaXMuX2dldEFycmF5RnJvbUFjY2Vzc29yKG91dHB1dEFjY2Vzc29yKTtcbiAgICBmb3IgKGxldCBqID0gMCwgamwgPSB0YXJnZXROYW1lcy5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICBjb25zdCB0cmFjayA9IG5ldyBUeXBlZEtleWZyYW1lVHJhY2soXG4gICAgICAgIHRhcmdldE5hbWVzW2pdICsgXCIuXCIgKyBQQVRIX1BST1BFUlRJRVNbdGFyZ2V0LnBhdGhdLFxuICAgICAgICBpbnB1dEFjY2Vzc29yLmFycmF5LFxuICAgICAgICBvdXRwdXRBcnJheSxcbiAgICAgICAgaW50ZXJwb2xhdGlvblxuICAgICAgKTtcbiAgICAgIGlmIChzYW1wbGVyLmludGVycG9sYXRpb24gPT09IFwiQ1VCSUNTUExJTkVcIikge1xuICAgICAgICB0aGlzLl9jcmVhdGVDdWJpY1NwbGluZVRyYWNrSW50ZXJwb2xhbnQodHJhY2spO1xuICAgICAgfVxuICAgICAgdHJhY2tzLnB1c2godHJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdHJhY2tzO1xuICB9XG4gIF9nZXRBcnJheUZyb21BY2Nlc3NvcihhY2Nlc3Nvcikge1xuICAgIGxldCBvdXRwdXRBcnJheSA9IGFjY2Vzc29yLmFycmF5O1xuICAgIGlmIChhY2Nlc3Nvci5ub3JtYWxpemVkKSB7XG4gICAgICBjb25zdCBzY2FsZSA9IGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZShvdXRwdXRBcnJheS5jb25zdHJ1Y3Rvcik7XG4gICAgICBjb25zdCBzY2FsZWQgPSBuZXcgRmxvYXQzMkFycmF5KG91dHB1dEFycmF5Lmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBvdXRwdXRBcnJheS5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgIHNjYWxlZFtqXSA9IG91dHB1dEFycmF5W2pdICogc2NhbGU7XG4gICAgICB9XG4gICAgICBvdXRwdXRBcnJheSA9IHNjYWxlZDtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dEFycmF5O1xuICB9XG4gIF9jcmVhdGVDdWJpY1NwbGluZVRyYWNrSW50ZXJwb2xhbnQodHJhY2spIHtcbiAgICB0cmFjay5jcmVhdGVJbnRlcnBvbGFudCA9IGZ1bmN0aW9uIEludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZShyZXN1bHQpIHtcbiAgICAgIGNvbnN0IGludGVycG9sYW50VHlwZSA9IHRoaXMgaW5zdGFuY2VvZiBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayA/IEdMVEZDdWJpY1NwbGluZVF1YXRlcm5pb25JbnRlcnBvbGFudCA6IEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50O1xuICAgICAgcmV0dXJuIG5ldyBpbnRlcnBvbGFudFR5cGUodGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCkgLyAzLCByZXN1bHQpO1xuICAgIH07XG4gICAgdHJhY2suY3JlYXRlSW50ZXJwb2xhbnQuaXNJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUgPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlQm91bmRzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlcikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXM7XG4gIGNvbnN0IGJveCA9IG5ldyBCb3gzKCk7XG4gIGlmIChhdHRyaWJ1dGVzLlBPU0lUSU9OICE9PSB2b2lkIDApIHtcbiAgICBjb25zdCBhY2Nlc3NvciA9IHBhcnNlci5qc29uLmFjY2Vzc29yc1thdHRyaWJ1dGVzLlBPU0lUSU9OXTtcbiAgICBjb25zdCBtaW4gPSBhY2Nlc3Nvci5taW47XG4gICAgY29uc3QgbWF4ID0gYWNjZXNzb3IubWF4O1xuICAgIGlmIChtaW4gIT09IHZvaWQgMCAmJiBtYXggIT09IHZvaWQgMCkge1xuICAgICAgYm94LnNldChuZXcgVmVjdG9yMyhtaW5bMF0sIG1pblsxXSwgbWluWzJdKSwgbmV3IFZlY3RvcjMobWF4WzBdLCBtYXhbMV0sIG1heFsyXSkpO1xuICAgICAgaWYgKGFjY2Vzc29yLm5vcm1hbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgYm94U2NhbGUgPSBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yLmNvbXBvbmVudFR5cGVdKTtcbiAgICAgICAgYm94Lm1pbi5tdWx0aXBseVNjYWxhcihib3hTY2FsZSk7XG4gICAgICAgIGJveC5tYXgubXVsdGlwbHlTY2FsYXIoYm94U2NhbGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIG1pbi9tYXggcHJvcGVydGllcyBmb3IgYWNjZXNzb3IgUE9TSVRJT04uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFyZ2V0cyA9IHByaW1pdGl2ZURlZi50YXJnZXRzO1xuICBpZiAodGFyZ2V0cyAhPT0gdm9pZCAwKSB7XG4gICAgY29uc3QgbWF4RGlzcGxhY2VtZW50ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjb25zdCB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgIGlmICh0YXJnZXQuUE9TSVRJT04gIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NvciA9IHBhcnNlci5qc29uLmFjY2Vzc29yc1t0YXJnZXQuUE9TSVRJT05dO1xuICAgICAgICBjb25zdCBtaW4gPSBhY2Nlc3Nvci5taW47XG4gICAgICAgIGNvbnN0IG1heCA9IGFjY2Vzc29yLm1heDtcbiAgICAgICAgaWYgKG1pbiAhPT0gdm9pZCAwICYmIG1heCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmVjdG9yLnNldFgoTWF0aC5tYXgoTWF0aC5hYnMobWluWzBdKSwgTWF0aC5hYnMobWF4WzBdKSkpO1xuICAgICAgICAgIHZlY3Rvci5zZXRZKE1hdGgubWF4KE1hdGguYWJzKG1pblsxXSksIE1hdGguYWJzKG1heFsxXSkpKTtcbiAgICAgICAgICB2ZWN0b3Iuc2V0WihNYXRoLm1heChNYXRoLmFicyhtaW5bMl0pLCBNYXRoLmFicyhtYXhbMl0pKSk7XG4gICAgICAgICAgaWYgKGFjY2Vzc29yLm5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJveFNjYWxlID0gZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlKFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3Nvci5jb21wb25lbnRUeXBlXSk7XG4gICAgICAgICAgICB2ZWN0b3IubXVsdGlwbHlTY2FsYXIoYm94U2NhbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXhEaXNwbGFjZW1lbnQubWF4KHZlY3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBtaW4vbWF4IHByb3BlcnRpZXMgZm9yIGFjY2Vzc29yIFBPU0lUSU9OLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBib3guZXhwYW5kQnlWZWN0b3IobWF4RGlzcGxhY2VtZW50KTtcbiAgfVxuICBnZW9tZXRyeS5ib3VuZGluZ0JveCA9IGJveDtcbiAgY29uc3Qgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuICBib3guZ2V0Q2VudGVyKHNwaGVyZS5jZW50ZXIpO1xuICBzcGhlcmUucmFkaXVzID0gYm94Lm1pbi5kaXN0YW5jZVRvKGJveC5tYXgpIC8gMjtcbiAgZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBzcGhlcmU7XG59XG5mdW5jdGlvbiBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlcikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXM7XG4gIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgZnVuY3Rpb24gYXNzaWduQXR0cmlidXRlQWNjZXNzb3IoYWNjZXNzb3JJbmRleCwgYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIGFjY2Vzc29ySW5kZXgpLnRoZW4oZnVuY3Rpb24oYWNjZXNzb3IpIHtcbiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhY2Nlc3Nvcik7XG4gICAgfSk7XG4gIH1cbiAgZm9yIChjb25zdCBnbHRmQXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1tnbHRmQXR0cmlidXRlTmFtZV0gfHwgZ2x0ZkF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodGhyZWVBdHRyaWJ1dGVOYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMpXG4gICAgICBjb250aW51ZTtcbiAgICBwZW5kaW5nLnB1c2goYXNzaWduQXR0cmlidXRlQWNjZXNzb3IoYXR0cmlidXRlc1tnbHRmQXR0cmlidXRlTmFtZV0sIHRocmVlQXR0cmlidXRlTmFtZSkpO1xuICB9XG4gIGlmIChwcmltaXRpdmVEZWYuaW5kaWNlcyAhPT0gdm9pZCAwICYmICFnZW9tZXRyeS5pbmRleCkge1xuICAgIGNvbnN0IGFjY2Vzc29yID0gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBwcmltaXRpdmVEZWYuaW5kaWNlcykudGhlbihmdW5jdGlvbihhY2Nlc3NvcjIpIHtcbiAgICAgIGdlb21ldHJ5LnNldEluZGV4KGFjY2Vzc29yMik7XG4gICAgfSk7XG4gICAgcGVuZGluZy5wdXNoKGFjY2Vzc29yKTtcbiAgfVxuICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYpO1xuICBjb21wdXRlQm91bmRzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlcik7XG4gIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwcmltaXRpdmVEZWYudGFyZ2V0cyAhPT0gdm9pZCAwID8gYWRkTW9ycGhUYXJnZXRzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYudGFyZ2V0cywgcGFyc2VyKSA6IGdlb21ldHJ5O1xuICB9KTtcbn1cbmV4cG9ydCB7XG4gIEdMVEZMb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HTFRGTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/loaders/GLTFLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/types/helpers.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/types/helpers.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWithKey: () => (/* binding */ getWithKey)\n/* harmony export */ });\nconst getWithKey = (obj, key) => obj[key];\n\n//# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdGhyZWUtc3RkbGliQDIuMzUuMl90aHJlZUAwLjE3Mi4wL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvdHlwZXMvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFHRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvamVyZW15ai9Eb2N1bWVudHMvc291cmNlL3JlcG9zL3NoYWRlcnMvbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVlLXN0ZGxpYkAyLjM1LjJfdGhyZWVAMC4xNzIuMC9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3R5cGVzL2hlbHBlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZ2V0V2l0aEtleSA9IChvYmosIGtleSkgPT4gb2JqW2tleV07XG5leHBvcnQge1xuICBnZXRXaXRoS2V5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/types/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/utils/BufferGeometryUtils.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/utils/BufferGeometryUtils.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeMorphedAttributes: () => (/* binding */ computeMorphedAttributes),\n/* harmony export */   estimateBytesUsed: () => (/* binding */ estimateBytesUsed),\n/* harmony export */   interleaveAttributes: () => (/* binding */ interleaveAttributes),\n/* harmony export */   mergeBufferAttributes: () => (/* binding */ mergeBufferAttributes),\n/* harmony export */   mergeBufferGeometries: () => (/* binding */ mergeBufferGeometries),\n/* harmony export */   mergeVertices: () => (/* binding */ mergeVertices),\n/* harmony export */   toCreasedNormals: () => (/* binding */ toCreasedNormals),\n/* harmony export */   toTrianglesDrawMode: () => (/* binding */ toTrianglesDrawMode)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/.pnpm/three@0.172.0/node_modules/three/build/three.core.js\");\n/* harmony import */ var _types_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/helpers.js */ \"(ssr)/./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/types/helpers.js\");\n\n\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"\n      );\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.'\n        );\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\"\n      );\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\"\n      );\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\"\n        );\n        return null;\n      }\n      if (morphAttributes[name] === void 0)\n        morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\"\n        );\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach((geom) => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\"\n      );\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0)\n      break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\"\n        );\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach((attr) => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"\n      );\n      return null;\n    }\n    if (itemSize === void 0)\n      itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    if (normalized === void 0)\n      normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0)\n      TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(iba, setters[k]);\n        const get = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n        );\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n      // @ts-ignore\n      material2.morphTargets && morphAttribute && morphInfluences\n    ) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0)\n          continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  }\n  const morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()];\n  const tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\n\n//# sourceMappingURL=BufferGeometryUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdGhyZWUtc3RkbGliQDIuMzUuMl90aHJlZUAwLjE3Mi4wL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvdXRpbHMvQnVmZmVyR2VvbWV0cnlVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXVNO0FBQ3RKO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlEQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSkFBc0o7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0pBQXdKO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBLHNCQUFzQixrQ0FBa0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5REFBc0I7QUFDN0QscUNBQXFDLHlEQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBTyxRQUFRLDBDQUFPLFFBQVEsMENBQU87QUFDMUQsdUJBQXVCLDBDQUFPO0FBQzlCLHVCQUF1QiwwQ0FBTztBQUM5Qix1QkFBdUIsMENBQU87QUFDOUIsd0JBQXdCLDBDQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMENBQU87QUFDOUIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtEQUFlO0FBQ3RDLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvamVyZW15ai9Eb2N1bWVudHMvc291cmNlL3JlcG9zL3NoYWRlcnMvbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVlLXN0ZGxpYkAyLjM1LjJfdGhyZWVAMC4xNzIuMC9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnksIEJ1ZmZlckF0dHJpYnV0ZSwgSW50ZXJsZWF2ZWRCdWZmZXIsIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLCBUcmlhbmdsZXNEcmF3TW9kZSwgVHJpYW5nbGVGYW5EcmF3TW9kZSwgVHJpYW5nbGVTdHJpcERyYXdNb2RlLCBWZWN0b3IzLCBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyBnZXRXaXRoS2V5IH0gZnJvbSBcIi4uL3R5cGVzL2hlbHBlcnMuanNcIjtcbmNvbnN0IG1lcmdlQnVmZmVyR2VvbWV0cmllcyA9IChnZW9tZXRyaWVzLCB1c2VHcm91cHMpID0+IHtcbiAgY29uc3QgaXNJbmRleGVkID0gZ2VvbWV0cmllc1swXS5pbmRleCAhPT0gbnVsbDtcbiAgY29uc3QgYXR0cmlidXRlc1VzZWQgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGdlb21ldHJpZXNbMF0uYXR0cmlidXRlcykpO1xuICBjb25zdCBtb3JwaEF0dHJpYnV0ZXNVc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyhnZW9tZXRyaWVzWzBdLm1vcnBoQXR0cmlidXRlcykpO1xuICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gIGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHt9O1xuICBjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGdlb21ldHJpZXNbMF0ubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG4gIGNvbnN0IG1lcmdlZEdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBnZW9tZXRyaWVzLmZvckVhY2goKGdlb20sIGkpID0+IHtcbiAgICBsZXQgYXR0cmlidXRlc0NvdW50ID0gMDtcbiAgICBpZiAoaXNJbmRleGVkICE9PSAoZ2VvbS5pbmRleCAhPT0gbnVsbCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiBBbGwgZ2VvbWV0cmllcyBtdXN0IGhhdmUgY29tcGF0aWJsZSBhdHRyaWJ1dGVzOyBtYWtlIHN1cmUgaW5kZXggYXR0cmlidXRlIGV4aXN0cyBhbW9uZyBhbGwgZ2VvbWV0cmllcywgb3IgaW4gbm9uZSBvZiB0aGVtLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAobGV0IG5hbWUgaW4gZ2VvbS5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIWF0dHJpYnV0ZXNVc2VkLmhhcyhuYW1lKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArICcuIEFsbCBnZW9tZXRyaWVzIG11c3QgaGF2ZSBjb21wYXRpYmxlIGF0dHJpYnV0ZXM7IG1ha2Ugc3VyZSBcIicgKyBuYW1lICsgJ1wiIGF0dHJpYnV0ZSBleGlzdHMgYW1vbmcgYWxsIGdlb21ldHJpZXMsIG9yIGluIG5vbmUgb2YgdGhlbS4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZXNbbmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICBhdHRyaWJ1dGVzW25hbWVdID0gW107XG4gICAgICB9XG4gICAgICBhdHRyaWJ1dGVzW25hbWVdLnB1c2goZ2VvbS5hdHRyaWJ1dGVzW25hbWVdKTtcbiAgICAgIGF0dHJpYnV0ZXNDb3VudCsrO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlc0NvdW50ICE9PSBhdHRyaWJ1dGVzVXNlZC5zaXplKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gTWFrZSBzdXJlIGFsbCBnZW9tZXRyaWVzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG1vcnBoVGFyZ2V0c1JlbGF0aXZlICE9PSBnZW9tLm1vcnBoVGFyZ2V0c1JlbGF0aXZlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gLm1vcnBoVGFyZ2V0c1JlbGF0aXZlIG11c3QgYmUgY29uc2lzdGVudCB0aHJvdWdob3V0IGFsbCBnZW9tZXRyaWVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAobGV0IG5hbWUgaW4gZ2VvbS5tb3JwaEF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghbW9ycGhBdHRyaWJ1dGVzVXNlZC5oYXMobmFtZSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gIC5tb3JwaEF0dHJpYnV0ZXMgbXVzdCBiZSBjb25zaXN0ZW50IHRocm91Z2hvdXQgYWxsIGdlb21ldHJpZXMuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAobW9ycGhBdHRyaWJ1dGVzW25hbWVdID09PSB2b2lkIDApXG4gICAgICAgIG1vcnBoQXR0cmlidXRlc1tuYW1lXSA9IFtdO1xuICAgICAgbW9ycGhBdHRyaWJ1dGVzW25hbWVdLnB1c2goZ2VvbS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV0pO1xuICAgIH1cbiAgICBtZXJnZWRHZW9tZXRyeS51c2VyRGF0YS5tZXJnZWRVc2VyRGF0YSA9IG1lcmdlZEdlb21ldHJ5LnVzZXJEYXRhLm1lcmdlZFVzZXJEYXRhIHx8IFtdO1xuICAgIG1lcmdlZEdlb21ldHJ5LnVzZXJEYXRhLm1lcmdlZFVzZXJEYXRhLnB1c2goZ2VvbS51c2VyRGF0YSk7XG4gICAgaWYgKHVzZUdyb3Vwcykge1xuICAgICAgbGV0IGNvdW50O1xuICAgICAgaWYgKGdlb20uaW5kZXgpIHtcbiAgICAgICAgY291bnQgPSBnZW9tLmluZGV4LmNvdW50O1xuICAgICAgfSBlbHNlIGlmIChnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICBjb3VudCA9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIFRoZSBnZW9tZXRyeSBtdXN0IGhhdmUgZWl0aGVyIGFuIGluZGV4IG9yIGEgcG9zaXRpb24gYXR0cmlidXRlXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBtZXJnZWRHZW9tZXRyeS5hZGRHcm91cChvZmZzZXQsIGNvdW50LCBpKTtcbiAgICAgIG9mZnNldCArPSBjb3VudDtcbiAgICB9XG4gIH0pO1xuICBpZiAoaXNJbmRleGVkKSB7XG4gICAgbGV0IGluZGV4T2Zmc2V0ID0gMDtcbiAgICBjb25zdCBtZXJnZWRJbmRleCA9IFtdO1xuICAgIGdlb21ldHJpZXMuZm9yRWFjaCgoZ2VvbSkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBnZW9tLmluZGV4O1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmRleC5jb3VudDsgKytqKSB7XG4gICAgICAgIG1lcmdlZEluZGV4LnB1c2goaW5kZXguZ2V0WChqKSArIGluZGV4T2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGluZGV4T2Zmc2V0ICs9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDtcbiAgICB9KTtcbiAgICBtZXJnZWRHZW9tZXRyeS5zZXRJbmRleChtZXJnZWRJbmRleCk7XG4gIH1cbiAgZm9yIChsZXQgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgbWVyZ2VkQXR0cmlidXRlID0gbWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKGF0dHJpYnV0ZXNbbmFtZV0pO1xuICAgIGlmICghbWVyZ2VkQXR0cmlidXRlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2hpbGUgdHJ5aW5nIHRvIG1lcmdlIHRoZSBcIiArIG5hbWUgKyBcIiBhdHRyaWJ1dGUuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbWVyZ2VkR2VvbWV0cnkuc2V0QXR0cmlidXRlKG5hbWUsIG1lcmdlZEF0dHJpYnV0ZSk7XG4gIH1cbiAgZm9yIChsZXQgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBudW1Nb3JwaFRhcmdldHMgPSBtb3JwaEF0dHJpYnV0ZXNbbmFtZV1bMF0ubGVuZ3RoO1xuICAgIGlmIChudW1Nb3JwaFRhcmdldHMgPT09IDApXG4gICAgICBicmVhaztcbiAgICBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgPSBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgfHwge307XG4gICAgbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Nb3JwaFRhcmdldHM7ICsraSkge1xuICAgICAgY29uc3QgbW9ycGhBdHRyaWJ1dGVzVG9NZXJnZSA9IFtdO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtb3JwaEF0dHJpYnV0ZXNbbmFtZV0ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgbW9ycGhBdHRyaWJ1dGVzVG9NZXJnZS5wdXNoKG1vcnBoQXR0cmlidXRlc1tuYW1lXVtqXVtpXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXJnZWRNb3JwaEF0dHJpYnV0ZSA9IG1lcmdlQnVmZmVyQXR0cmlidXRlcyhtb3JwaEF0dHJpYnV0ZXNUb01lcmdlKTtcbiAgICAgIGlmICghbWVyZ2VkTW9ycGhBdHRyaWJ1dGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2hpbGUgdHJ5aW5nIHRvIG1lcmdlIHRoZSBcIiArIG5hbWUgKyBcIiBtb3JwaEF0dHJpYnV0ZS5cIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXS5wdXNoKG1lcmdlZE1vcnBoQXR0cmlidXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlZEdlb21ldHJ5O1xufTtcbmNvbnN0IG1lcmdlQnVmZmVyQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzKSA9PiB7XG4gIGxldCBUeXBlZEFycmF5ID0gdm9pZCAwO1xuICBsZXQgaXRlbVNpemUgPSB2b2lkIDA7XG4gIGxldCBub3JtYWxpemVkID0gdm9pZCAwO1xuICBsZXQgYXJyYXlMZW5ndGggPSAwO1xuICBhdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICBpZiAoVHlwZWRBcnJheSA9PT0gdm9pZCAwKSB7XG4gICAgICBUeXBlZEFycmF5ID0gYXR0ci5hcnJheS5jb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgaWYgKFR5cGVkQXJyYXkgIT09IGF0dHIuYXJyYXkuY29uc3RydWN0b3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyQXR0cmlidXRlcygpIGZhaWxlZC4gQnVmZmVyQXR0cmlidXRlLmFycmF5IG11c3QgYmUgb2YgY29uc2lzdGVudCBhcnJheSB0eXBlcyBhY3Jvc3MgbWF0Y2hpbmcgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXRlbVNpemUgPT09IHZvaWQgMClcbiAgICAgIGl0ZW1TaXplID0gYXR0ci5pdGVtU2l6ZTtcbiAgICBpZiAoaXRlbVNpemUgIT09IGF0dHIuaXRlbVNpemUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyQXR0cmlidXRlcygpIGZhaWxlZC4gQnVmZmVyQXR0cmlidXRlLml0ZW1TaXplIG11c3QgYmUgY29uc2lzdGVudCBhY3Jvc3MgbWF0Y2hpbmcgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXplZCA9PT0gdm9pZCAwKVxuICAgICAgbm9ybWFsaXplZCA9IGF0dHIubm9ybWFsaXplZDtcbiAgICBpZiAobm9ybWFsaXplZCAhPT0gYXR0ci5ub3JtYWxpemVkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5ub3JtYWxpemVkIG11c3QgYmUgY29uc2lzdGVudCBhY3Jvc3MgbWF0Y2hpbmcgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhcnJheUxlbmd0aCArPSBhdHRyLmFycmF5Lmxlbmd0aDtcbiAgfSk7XG4gIGlmIChUeXBlZEFycmF5ICYmIGl0ZW1TaXplKSB7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShhcnJheUxlbmd0aCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICBhcnJheS5zZXQoYXR0ci5hcnJheSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBhdHRyLmFycmF5Lmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuICB9XG59O1xuY29uc3QgaW50ZXJsZWF2ZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlcykgPT4ge1xuICBsZXQgVHlwZWRBcnJheSA9IHZvaWQgMDtcbiAgbGV0IGFycmF5TGVuZ3RoID0gMDtcbiAgbGV0IHN0cmlkZSA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2ldO1xuICAgIGlmIChUeXBlZEFycmF5ID09PSB2b2lkIDApXG4gICAgICBUeXBlZEFycmF5ID0gYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yO1xuICAgIGlmIChUeXBlZEFycmF5ICE9PSBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBdHRyaWJ1dGVCdWZmZXJzIG9mIGRpZmZlcmVudCB0eXBlcyBjYW5ub3QgYmUgaW50ZXJsZWF2ZWRcIik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXJyYXlMZW5ndGggKz0gYXR0cmlidXRlLmFycmF5Lmxlbmd0aDtcbiAgICBzdHJpZGUgKz0gYXR0cmlidXRlLml0ZW1TaXplO1xuICB9XG4gIGNvbnN0IGludGVybGVhdmVkQnVmZmVyID0gbmV3IEludGVybGVhdmVkQnVmZmVyKG5ldyBUeXBlZEFycmF5KGFycmF5TGVuZ3RoKSwgc3RyaWRlKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBjb25zdCBnZXR0ZXJzID0gW1wiZ2V0WFwiLCBcImdldFlcIiwgXCJnZXRaXCIsIFwiZ2V0V1wiXTtcbiAgY29uc3Qgc2V0dGVycyA9IFtcInNldFhcIiwgXCJzZXRZXCIsIFwic2V0WlwiLCBcInNldFdcIl07XG4gIGZvciAobGV0IGogPSAwLCBsID0gYXR0cmlidXRlcy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2pdO1xuICAgIGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgIGNvbnN0IGNvdW50ID0gYXR0cmlidXRlLmNvdW50O1xuICAgIGNvbnN0IGliYSA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShpbnRlcmxlYXZlZEJ1ZmZlciwgaXRlbVNpemUsIG9mZnNldCwgYXR0cmlidXRlLm5vcm1hbGl6ZWQpO1xuICAgIHJlcy5wdXNoKGliYSk7XG4gICAgb2Zmc2V0ICs9IGl0ZW1TaXplO1xuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY291bnQ7IGMrKykge1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpdGVtU2l6ZTsgaysrKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IGdldFdpdGhLZXkoaWJhLCBzZXR0ZXJzW2tdKTtcbiAgICAgICAgY29uc3QgZ2V0ID0gZ2V0V2l0aEtleShhdHRyaWJ1dGUsIGdldHRlcnNba10pO1xuICAgICAgICBzZXQoYywgZ2V0KGMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5mdW5jdGlvbiBlc3RpbWF0ZUJ5dGVzVXNlZChnZW9tZXRyeSkge1xuICBsZXQgbWVtID0gMDtcbiAgZm9yIChsZXQgbmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgYXR0ciA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBtZW0gKz0gYXR0ci5jb3VudCAqIGF0dHIuaXRlbVNpemUgKiBhdHRyLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICB9XG4gIGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuICBtZW0gKz0gaW5kaWNlcyA/IGluZGljZXMuY291bnQgKiBpbmRpY2VzLml0ZW1TaXplICogaW5kaWNlcy5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCA6IDA7XG4gIHJldHVybiBtZW07XG59XG5mdW5jdGlvbiBtZXJnZVZlcnRpY2VzKGdlb21ldHJ5LCB0b2xlcmFuY2UgPSAxZS00KSB7XG4gIHRvbGVyYW5jZSA9IE1hdGgubWF4KHRvbGVyYW5jZSwgTnVtYmVyLkVQU0lMT04pO1xuICBjb25zdCBoYXNoVG9JbmRleCA9IHt9O1xuICBjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgY29uc3QgcG9zaXRpb25zID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIik7XG4gIGNvbnN0IHZlcnRleENvdW50ID0gaW5kaWNlcyA/IGluZGljZXMuY291bnQgOiBwb3NpdGlvbnMuY291bnQ7XG4gIGxldCBuZXh0SW5kZXggPSAwO1xuICBjb25zdCBhdHRyaWJ1dGVOYW1lcyA9IE9iamVjdC5rZXlzKGdlb21ldHJ5LmF0dHJpYnV0ZXMpO1xuICBjb25zdCBhdHRyQXJyYXlzID0ge307XG4gIGNvbnN0IG1vcnBoQXR0cnNBcnJheXMgPSB7fTtcbiAgY29uc3QgbmV3SW5kaWNlcyA9IFtdO1xuICBjb25zdCBnZXR0ZXJzID0gW1wiZ2V0WFwiLCBcImdldFlcIiwgXCJnZXRaXCIsIFwiZ2V0V1wiXTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbaV07XG4gICAgYXR0ckFycmF5c1tuYW1lXSA9IFtdO1xuICAgIGNvbnN0IG1vcnBoQXR0ciA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXTtcbiAgICBpZiAobW9ycGhBdHRyKSB7XG4gICAgICBtb3JwaEF0dHJzQXJyYXlzW25hbWVdID0gbmV3IEFycmF5KG1vcnBoQXR0ci5sZW5ndGgpLmZpbGwoMCkubWFwKCgpID0+IFtdKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGVjaW1hbFNoaWZ0ID0gTWF0aC5sb2cxMCgxIC8gdG9sZXJhbmNlKTtcbiAgY29uc3Qgc2hpZnRNdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIGRlY2ltYWxTaGlmdCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkrKykge1xuICAgIGNvbnN0IGluZGV4ID0gaW5kaWNlcyA/IGluZGljZXMuZ2V0WChpKSA6IGk7XG4gICAgbGV0IGhhc2ggPSBcIlwiO1xuICAgIGZvciAobGV0IGogPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbal07XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaXRlbVNpemU7IGsrKykge1xuICAgICAgICBoYXNoICs9IGAke35+KGF0dHJpYnV0ZVtnZXR0ZXJzW2tdXShpbmRleCkgKiBzaGlmdE11bHRpcGxpZXIpfSxgO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzaCBpbiBoYXNoVG9JbmRleCkge1xuICAgICAgbmV3SW5kaWNlcy5wdXNoKGhhc2hUb0luZGV4W2hhc2hdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGwgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2pdO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIGNvbnN0IG1vcnBoQXR0ciA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgY29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgICAgIGNvbnN0IG5ld2FycmF5ID0gYXR0ckFycmF5c1tuYW1lXTtcbiAgICAgICAgY29uc3QgbmV3TW9ycGhBcnJheXMgPSBtb3JwaEF0dHJzQXJyYXlzW25hbWVdO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGl0ZW1TaXplOyBrKyspIHtcbiAgICAgICAgICBjb25zdCBnZXR0ZXJGdW5jID0gZ2V0dGVyc1trXTtcbiAgICAgICAgICBuZXdhcnJheS5wdXNoKGF0dHJpYnV0ZVtnZXR0ZXJGdW5jXShpbmRleCkpO1xuICAgICAgICAgIGlmIChtb3JwaEF0dHIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG0gPSAwLCBtbCA9IG1vcnBoQXR0ci5sZW5ndGg7IG0gPCBtbDsgbSsrKSB7XG4gICAgICAgICAgICAgIG5ld01vcnBoQXJyYXlzW21dLnB1c2gobW9ycGhBdHRyW21dW2dldHRlckZ1bmNdKGluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoYXNoVG9JbmRleFtoYXNoXSA9IG5leHRJbmRleDtcbiAgICAgIG5ld0luZGljZXMucHVzaChuZXh0SW5kZXgpO1xuICAgICAgbmV4dEluZGV4Kys7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IGdlb21ldHJ5LmNsb25lKCk7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2ldO1xuICAgIGNvbnN0IG9sZEF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgb2xkQXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yKGF0dHJBcnJheXNbbmFtZV0pO1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoYnVmZmVyLCBvbGRBdHRyaWJ1dGUuaXRlbVNpemUsIG9sZEF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICByZXN1bHQuc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJpYnV0ZSk7XG4gICAgaWYgKG5hbWUgaW4gbW9ycGhBdHRyc0FycmF5cykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtb3JwaEF0dHJzQXJyYXlzW25hbWVdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IG9sZE1vcnBoQXR0cmlidXRlID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdW2pdO1xuICAgICAgICBjb25zdCBidWZmZXIyID0gbmV3IG9sZE1vcnBoQXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yKG1vcnBoQXR0cnNBcnJheXNbbmFtZV1bal0pO1xuICAgICAgICBjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoYnVmZmVyMiwgb2xkTW9ycGhBdHRyaWJ1dGUuaXRlbVNpemUsIG9sZE1vcnBoQXR0cmlidXRlLm5vcm1hbGl6ZWQpO1xuICAgICAgICByZXN1bHQubW9ycGhBdHRyaWJ1dGVzW25hbWVdW2pdID0gbW9ycGhBdHRyaWJ1dGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc3VsdC5zZXRJbmRleChuZXdJbmRpY2VzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvVHJpYW5nbGVzRHJhd01vZGUoZ2VvbWV0cnksIGRyYXdNb2RlKSB7XG4gIGlmIChkcmF3TW9kZSA9PT0gVHJpYW5nbGVzRHJhd01vZGUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogR2VvbWV0cnkgYWxyZWFkeSBkZWZpbmVkIGFzIHRyaWFuZ2xlcy5cIik7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG4gIGlmIChkcmF3TW9kZSA9PT0gVHJpYW5nbGVGYW5EcmF3TW9kZSB8fCBkcmF3TW9kZSA9PT0gVHJpYW5nbGVTdHJpcERyYXdNb2RlKSB7XG4gICAgbGV0IGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgICBpZiAoaW5kZXggPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGluZGljZXMgPSBbXTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIik7XG4gICAgICBpZiAocG9zaXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9uLmNvdW50OyBpKyspIHtcbiAgICAgICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2VvbWV0cnkuc2V0SW5kZXgoaW5kaWNlcyk7XG4gICAgICAgIGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5kZWZpbmVkIHBvc2l0aW9uIGF0dHJpYnV0ZS4gUHJvY2Vzc2luZyBub3QgcG9zc2libGUuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBudW1iZXJPZlRyaWFuZ2xlcyA9IGluZGV4LmNvdW50IC0gMjtcbiAgICBjb25zdCBuZXdJbmRpY2VzID0gW107XG4gICAgaWYgKGluZGV4KSB7XG4gICAgICBpZiAoZHJhd01vZGUgPT09IFRyaWFuZ2xlRmFuRHJhd01vZGUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbnVtYmVyT2ZUcmlhbmdsZXM7IGkrKykge1xuICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKDApKTtcbiAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpKSk7XG4gICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDEpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlRyaWFuZ2xlczsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMSkpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDIpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAxKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdJbmRpY2VzLmxlbmd0aCAvIDMgIT09IG51bWJlck9mVHJpYW5nbGVzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVuYWJsZSB0byBnZW5lcmF0ZSBjb3JyZWN0IGFtb3VudCBvZiB0cmlhbmdsZXMuXCIpO1xuICAgIH1cbiAgICBjb25zdCBuZXdHZW9tZXRyeSA9IGdlb21ldHJ5LmNsb25lKCk7XG4gICAgbmV3R2VvbWV0cnkuc2V0SW5kZXgobmV3SW5kaWNlcyk7XG4gICAgbmV3R2VvbWV0cnkuY2xlYXJHcm91cHMoKTtcbiAgICByZXR1cm4gbmV3R2VvbWV0cnk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmtub3duIGRyYXcgbW9kZTpcIiwgZHJhd01vZGUpO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZU1vcnBoZWRBdHRyaWJ1dGVzKG9iamVjdCkge1xuICBpZiAob2JqZWN0Lmdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgIT09IHRydWUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogR2VvbWV0cnkgaXMgbm90IG9mIHR5cGUgQnVmZmVyR2VvbWV0cnkuXCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IF92QSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF92QiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF92QyA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF90ZW1wQSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF90ZW1wQiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF90ZW1wQyA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF9tb3JwaEEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfbW9ycGhCID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX21vcnBoQyA9IG5ldyBWZWN0b3IzKCk7XG4gIGZ1bmN0aW9uIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShvYmplY3QyLCBtYXRlcmlhbDIsIGF0dHJpYnV0ZSwgbW9ycGhBdHRyaWJ1dGUsIG1vcnBoVGFyZ2V0c1JlbGF0aXZlMiwgYTIsIGIyLCBjMiwgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheSkge1xuICAgIF92QS5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgYTIpO1xuICAgIF92Qi5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgYjIpO1xuICAgIF92Qy5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgYzIpO1xuICAgIGNvbnN0IG1vcnBoSW5mbHVlbmNlcyA9IG9iamVjdDIubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuICAgIGlmIChcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIG1hdGVyaWFsMi5tb3JwaFRhcmdldHMgJiYgbW9ycGhBdHRyaWJ1dGUgJiYgbW9ycGhJbmZsdWVuY2VzXG4gICAgKSB7XG4gICAgICBfbW9ycGhBLnNldCgwLCAwLCAwKTtcbiAgICAgIF9tb3JwaEIuc2V0KDAsIDAsIDApO1xuICAgICAgX21vcnBoQy5zZXQoMCwgMCwgMCk7XG4gICAgICBmb3IgKGxldCBpMiA9IDAsIGlsMiA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgaTIgPCBpbDI7IGkyKyspIHtcbiAgICAgICAgY29uc3QgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzW2kyXTtcbiAgICAgICAgY29uc3QgbW9ycGggPSBtb3JwaEF0dHJpYnV0ZVtpMl07XG4gICAgICAgIGlmIChpbmZsdWVuY2UgPT09IDApXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIF90ZW1wQS5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoLCBhMik7XG4gICAgICAgIF90ZW1wQi5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoLCBiMik7XG4gICAgICAgIF90ZW1wQy5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoLCBjMik7XG4gICAgICAgIGlmIChtb3JwaFRhcmdldHNSZWxhdGl2ZTIpIHtcbiAgICAgICAgICBfbW9ycGhBLmFkZFNjYWxlZFZlY3RvcihfdGVtcEEsIGluZmx1ZW5jZSk7XG4gICAgICAgICAgX21vcnBoQi5hZGRTY2FsZWRWZWN0b3IoX3RlbXBCLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEMuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQywgaW5mbHVlbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfbW9ycGhBLmFkZFNjYWxlZFZlY3RvcihfdGVtcEEuc3ViKF92QSksIGluZmx1ZW5jZSk7XG4gICAgICAgICAgX21vcnBoQi5hZGRTY2FsZWRWZWN0b3IoX3RlbXBCLnN1YihfdkIpLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEMuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQy5zdWIoX3ZDKSwgaW5mbHVlbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX3ZBLmFkZChfbW9ycGhBKTtcbiAgICAgIF92Qi5hZGQoX21vcnBoQik7XG4gICAgICBfdkMuYWRkKF9tb3JwaEMpO1xuICAgIH1cbiAgICBpZiAob2JqZWN0Mi5pc1NraW5uZWRNZXNoKSB7XG4gICAgICBvYmplY3QyLmJvbmVUcmFuc2Zvcm0oYTIsIF92QSk7XG4gICAgICBvYmplY3QyLmJvbmVUcmFuc2Zvcm0oYjIsIF92Qik7XG4gICAgICBvYmplY3QyLmJvbmVUcmFuc2Zvcm0oYzIsIF92Qyk7XG4gICAgfVxuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYTIgKiAzICsgMF0gPSBfdkEueDtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2EyICogMyArIDFdID0gX3ZBLnk7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVthMiAqIDMgKyAyXSA9IF92QS56O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYjIgKiAzICsgMF0gPSBfdkIueDtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2IyICogMyArIDFdID0gX3ZCLnk7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtiMiAqIDMgKyAyXSA9IF92Qi56O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYzIgKiAzICsgMF0gPSBfdkMueDtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2MyICogMyArIDFdID0gX3ZDLnk7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtjMiAqIDMgKyAyXSA9IF92Qy56O1xuICB9XG4gIGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuICBjb25zdCBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcbiAgbGV0IGEsIGIsIGM7XG4gIGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gIGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgbW9ycGhQb3NpdGlvbiA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcbiAgY29uc3Qgbm9ybWFsQXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG4gIGNvbnN0IG1vcnBoTm9ybWFsID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG4gIGNvbnN0IGRyYXdSYW5nZSA9IGdlb21ldHJ5LmRyYXdSYW5nZTtcbiAgbGV0IGksIGosIGlsLCBqbDtcbiAgbGV0IGdyb3VwLCBncm91cE1hdGVyaWFsO1xuICBsZXQgc3RhcnQsIGVuZDtcbiAgY29uc3QgbW9kaWZpZWRQb3NpdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25BdHRyaWJ1dGUuY291bnQgKiBwb3NpdGlvbkF0dHJpYnV0ZS5pdGVtU2l6ZSk7XG4gIGNvbnN0IG1vZGlmaWVkTm9ybWFsID0gbmV3IEZsb2F0MzJBcnJheShub3JtYWxBdHRyaWJ1dGUuY291bnQgKiBub3JtYWxBdHRyaWJ1dGUuaXRlbVNpemUpO1xuICBpZiAoaW5kZXggIT09IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFtncm91cC5tYXRlcmlhbEluZGV4XTtcbiAgICAgICAgc3RhcnQgPSBNYXRoLm1heChncm91cC5zdGFydCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgICAgZW5kID0gTWF0aC5taW4oZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgICAgZm9yIChqID0gc3RhcnQsIGpsID0gZW5kOyBqIDwgamw7IGogKz0gMykge1xuICAgICAgICAgIGEgPSBpbmRleC5nZXRYKGopO1xuICAgICAgICAgIGIgPSBpbmRleC5nZXRYKGogKyAxKTtcbiAgICAgICAgICBjID0gaW5kZXguZ2V0WChqICsgMik7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgZW5kID0gTWF0aC5taW4oaW5kZXguY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSArPSAzKSB7XG4gICAgICAgIGEgPSBpbmRleC5nZXRYKGkpO1xuICAgICAgICBiID0gaW5kZXguZ2V0WChpICsgMSk7XG4gICAgICAgIGMgPSBpbmRleC5nZXRYKGkgKyAyKTtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAocG9zaXRpb25BdHRyaWJ1dGUgIT09IHZvaWQgMCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuICAgICAgZm9yIChpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsW2dyb3VwLm1hdGVyaWFsSW5kZXhdO1xuICAgICAgICBzdGFydCA9IE1hdGgubWF4KGdyb3VwLnN0YXJ0LCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihncm91cC5zdGFydCArIGdyb3VwLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgICBmb3IgKGogPSBzdGFydCwgamwgPSBlbmQ7IGogPCBqbDsgaiArPSAzKSB7XG4gICAgICAgICAgYSA9IGo7XG4gICAgICAgICAgYiA9IGogKyAxO1xuICAgICAgICAgIGMgPSBqICsgMjtcbiAgICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncm91cE1hdGVyaWFsLFxuICAgICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncm91cE1hdGVyaWFsLFxuICAgICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IE1hdGgubWF4KDAsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICBlbmQgPSBNYXRoLm1pbihwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgIGZvciAoaSA9IHN0YXJ0LCBpbCA9IGVuZDsgaSA8IGlsOyBpICs9IDMpIHtcbiAgICAgICAgYSA9IGk7XG4gICAgICAgIGIgPSBpICsgMTtcbiAgICAgICAgYyA9IGkgKyAyO1xuICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICApO1xuICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBtb3JwaGVkUG9zaXRpb25BdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShtb2RpZmllZFBvc2l0aW9uLCAzKTtcbiAgY29uc3QgbW9ycGhlZE5vcm1hbEF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG1vZGlmaWVkTm9ybWFsLCAzKTtcbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgbW9ycGhlZFBvc2l0aW9uQXR0cmlidXRlLFxuICAgIG1vcnBoZWROb3JtYWxBdHRyaWJ1dGVcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvQ3JlYXNlZE5vcm1hbHMoZ2VvbWV0cnksIGNyZWFzZUFuZ2xlID0gTWF0aC5QSSAvIDMpIHtcbiAgY29uc3QgY3JlYXNlRG90ID0gTWF0aC5jb3MoY3JlYXNlQW5nbGUpO1xuICBjb25zdCBoYXNoTXVsdGlwbGllciA9ICgxICsgMWUtMTApICogMTAwO1xuICBjb25zdCB2ZXJ0cyA9IFtuZXcgVmVjdG9yMygpLCBuZXcgVmVjdG9yMygpLCBuZXcgVmVjdG9yMygpXTtcbiAgY29uc3QgdGVtcFZlYzEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCB0ZW1wVmVjMiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IHRlbXBOb3JtID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgdGVtcE5vcm0yID0gbmV3IFZlY3RvcjMoKTtcbiAgZnVuY3Rpb24gaGFzaFZlcnRleCh2KSB7XG4gICAgY29uc3QgeCA9IH5+KHYueCAqIGhhc2hNdWx0aXBsaWVyKTtcbiAgICBjb25zdCB5ID0gfn4odi55ICogaGFzaE11bHRpcGxpZXIpO1xuICAgIGNvbnN0IHogPSB+fih2LnogKiBoYXNoTXVsdGlwbGllcik7XG4gICAgcmV0dXJuIGAke3h9LCR7eX0sJHt6fWA7XG4gIH1cbiAgY29uc3QgcmVzdWx0R2VvbWV0cnkgPSBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpIDogZ2VvbWV0cnk7XG4gIGNvbnN0IHBvc0F0dHIgPSByZXN1bHRHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCB2ZXJ0ZXhNYXAgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBwb3NBdHRyLmNvdW50IC8gMzsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGkzID0gMyAqIGk7XG4gICAgY29uc3QgYSA9IHZlcnRzWzBdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAwKTtcbiAgICBjb25zdCBiID0gdmVydHNbMV0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDEpO1xuICAgIGNvbnN0IGMgPSB2ZXJ0c1syXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMik7XG4gICAgdGVtcFZlYzEuc3ViVmVjdG9ycyhjLCBiKTtcbiAgICB0ZW1wVmVjMi5zdWJWZWN0b3JzKGEsIGIpO1xuICAgIGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKHRlbXBWZWMxLCB0ZW1wVmVjMikubm9ybWFsaXplKCk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCAzOyBuKyspIHtcbiAgICAgIGNvbnN0IHZlcnQgPSB2ZXJ0c1tuXTtcbiAgICAgIGNvbnN0IGhhc2ggPSBoYXNoVmVydGV4KHZlcnQpO1xuICAgICAgaWYgKCEoaGFzaCBpbiB2ZXJ0ZXhNYXApKSB7XG4gICAgICAgIHZlcnRleE1hcFtoYXNoXSA9IFtdO1xuICAgICAgfVxuICAgICAgdmVydGV4TWFwW2hhc2hdLnB1c2gobm9ybWFsKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgbm9ybWFsQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHBvc0F0dHIuY291bnQgKiAzKTtcbiAgY29uc3Qgbm9ybUF0dHIgPSBuZXcgQnVmZmVyQXR0cmlidXRlKG5vcm1hbEFycmF5LCAzLCBmYWxzZSk7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gcG9zQXR0ci5jb3VudCAvIDM7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBpMyA9IDMgKiBpO1xuICAgIGNvbnN0IGEgPSB2ZXJ0c1swXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMCk7XG4gICAgY29uc3QgYiA9IHZlcnRzWzFdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAxKTtcbiAgICBjb25zdCBjID0gdmVydHNbMl0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDIpO1xuICAgIHRlbXBWZWMxLnN1YlZlY3RvcnMoYywgYik7XG4gICAgdGVtcFZlYzIuc3ViVmVjdG9ycyhhLCBiKTtcbiAgICB0ZW1wTm9ybS5jcm9zc1ZlY3RvcnModGVtcFZlYzEsIHRlbXBWZWMyKS5ub3JtYWxpemUoKTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IDM7IG4rKykge1xuICAgICAgY29uc3QgdmVydCA9IHZlcnRzW25dO1xuICAgICAgY29uc3QgaGFzaCA9IGhhc2hWZXJ0ZXgodmVydCk7XG4gICAgICBjb25zdCBvdGhlck5vcm1hbHMgPSB2ZXJ0ZXhNYXBbaGFzaF07XG4gICAgICB0ZW1wTm9ybTIuc2V0KDAsIDAsIDApO1xuICAgICAgZm9yIChsZXQgayA9IDAsIGxrID0gb3RoZXJOb3JtYWxzLmxlbmd0aDsgayA8IGxrOyBrKyspIHtcbiAgICAgICAgY29uc3Qgb3RoZXJOb3JtID0gb3RoZXJOb3JtYWxzW2tdO1xuICAgICAgICBpZiAodGVtcE5vcm0uZG90KG90aGVyTm9ybSkgPiBjcmVhc2VEb3QpIHtcbiAgICAgICAgICB0ZW1wTm9ybTIuYWRkKG90aGVyTm9ybSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXBOb3JtMi5ub3JtYWxpemUoKTtcbiAgICAgIG5vcm1BdHRyLnNldFhZWihpMyArIG4sIHRlbXBOb3JtMi54LCB0ZW1wTm9ybTIueSwgdGVtcE5vcm0yLnopO1xuICAgIH1cbiAgfVxuICByZXN1bHRHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJub3JtYWxcIiwgbm9ybUF0dHIpO1xuICByZXR1cm4gcmVzdWx0R2VvbWV0cnk7XG59XG5leHBvcnQge1xuICBjb21wdXRlTW9ycGhlZEF0dHJpYnV0ZXMsXG4gIGVzdGltYXRlQnl0ZXNVc2VkLFxuICBpbnRlcmxlYXZlQXR0cmlidXRlcyxcbiAgbWVyZ2VCdWZmZXJBdHRyaWJ1dGVzLFxuICBtZXJnZUJ1ZmZlckdlb21ldHJpZXMsXG4gIG1lcmdlVmVydGljZXMsXG4gIHRvQ3JlYXNlZE5vcm1hbHMsXG4gIHRvVHJpYW5nbGVzRHJhd01vZGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdWZmZXJHZW9tZXRyeVV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/three-stdlib@2.35.2_three@0.172.0/node_modules/three-stdlib/utils/BufferGeometryUtils.js\n");

/***/ })

};
;