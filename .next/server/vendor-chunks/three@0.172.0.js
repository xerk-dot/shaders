"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three@0.172.0";
exports.ids = ["vendor-chunks/three@0.172.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/three@0.172.0/node_modules/three/build/three.core.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/three@0.172.0/node_modules/three/build/three.core.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACESFilmicToneMapping: () => (/* binding */ ACESFilmicToneMapping),\n/* harmony export */   AddEquation: () => (/* binding */ AddEquation),\n/* harmony export */   AddOperation: () => (/* binding */ AddOperation),\n/* harmony export */   AdditiveAnimationBlendMode: () => (/* binding */ AdditiveAnimationBlendMode),\n/* harmony export */   AdditiveBlending: () => (/* binding */ AdditiveBlending),\n/* harmony export */   AgXToneMapping: () => (/* binding */ AgXToneMapping),\n/* harmony export */   AlphaFormat: () => (/* binding */ AlphaFormat),\n/* harmony export */   AlwaysCompare: () => (/* binding */ AlwaysCompare),\n/* harmony export */   AlwaysDepth: () => (/* binding */ AlwaysDepth),\n/* harmony export */   AlwaysStencilFunc: () => (/* binding */ AlwaysStencilFunc),\n/* harmony export */   AmbientLight: () => (/* binding */ AmbientLight),\n/* harmony export */   AnimationAction: () => (/* binding */ AnimationAction),\n/* harmony export */   AnimationClip: () => (/* binding */ AnimationClip),\n/* harmony export */   AnimationLoader: () => (/* binding */ AnimationLoader),\n/* harmony export */   AnimationMixer: () => (/* binding */ AnimationMixer),\n/* harmony export */   AnimationObjectGroup: () => (/* binding */ AnimationObjectGroup),\n/* harmony export */   AnimationUtils: () => (/* binding */ AnimationUtils),\n/* harmony export */   ArcCurve: () => (/* binding */ ArcCurve),\n/* harmony export */   ArrayCamera: () => (/* binding */ ArrayCamera),\n/* harmony export */   ArrowHelper: () => (/* binding */ ArrowHelper),\n/* harmony export */   AttachedBindMode: () => (/* binding */ AttachedBindMode),\n/* harmony export */   Audio: () => (/* binding */ Audio),\n/* harmony export */   AudioAnalyser: () => (/* binding */ AudioAnalyser),\n/* harmony export */   AudioContext: () => (/* binding */ AudioContext),\n/* harmony export */   AudioListener: () => (/* binding */ AudioListener),\n/* harmony export */   AudioLoader: () => (/* binding */ AudioLoader),\n/* harmony export */   AxesHelper: () => (/* binding */ AxesHelper),\n/* harmony export */   BackSide: () => (/* binding */ BackSide),\n/* harmony export */   BasicDepthPacking: () => (/* binding */ BasicDepthPacking),\n/* harmony export */   BasicShadowMap: () => (/* binding */ BasicShadowMap),\n/* harmony export */   BatchedMesh: () => (/* binding */ BatchedMesh),\n/* harmony export */   Bone: () => (/* binding */ Bone),\n/* harmony export */   BooleanKeyframeTrack: () => (/* binding */ BooleanKeyframeTrack),\n/* harmony export */   Box2: () => (/* binding */ Box2),\n/* harmony export */   Box3: () => (/* binding */ Box3),\n/* harmony export */   Box3Helper: () => (/* binding */ Box3Helper),\n/* harmony export */   BoxGeometry: () => (/* binding */ BoxGeometry),\n/* harmony export */   BoxHelper: () => (/* binding */ BoxHelper),\n/* harmony export */   BufferAttribute: () => (/* binding */ BufferAttribute),\n/* harmony export */   BufferGeometry: () => (/* binding */ BufferGeometry),\n/* harmony export */   BufferGeometryLoader: () => (/* binding */ BufferGeometryLoader),\n/* harmony export */   ByteType: () => (/* binding */ ByteType),\n/* harmony export */   Cache: () => (/* binding */ Cache),\n/* harmony export */   Camera: () => (/* binding */ Camera),\n/* harmony export */   CameraHelper: () => (/* binding */ CameraHelper),\n/* harmony export */   CanvasTexture: () => (/* binding */ CanvasTexture),\n/* harmony export */   CapsuleGeometry: () => (/* binding */ CapsuleGeometry),\n/* harmony export */   CatmullRomCurve3: () => (/* binding */ CatmullRomCurve3),\n/* harmony export */   CineonToneMapping: () => (/* binding */ CineonToneMapping),\n/* harmony export */   CircleGeometry: () => (/* binding */ CircleGeometry),\n/* harmony export */   ClampToEdgeWrapping: () => (/* binding */ ClampToEdgeWrapping),\n/* harmony export */   Clock: () => (/* binding */ Clock),\n/* harmony export */   Color: () => (/* binding */ Color),\n/* harmony export */   ColorKeyframeTrack: () => (/* binding */ ColorKeyframeTrack),\n/* harmony export */   ColorManagement: () => (/* binding */ ColorManagement),\n/* harmony export */   CompressedArrayTexture: () => (/* binding */ CompressedArrayTexture),\n/* harmony export */   CompressedCubeTexture: () => (/* binding */ CompressedCubeTexture),\n/* harmony export */   CompressedTexture: () => (/* binding */ CompressedTexture),\n/* harmony export */   CompressedTextureLoader: () => (/* binding */ CompressedTextureLoader),\n/* harmony export */   ConeGeometry: () => (/* binding */ ConeGeometry),\n/* harmony export */   ConstantAlphaFactor: () => (/* binding */ ConstantAlphaFactor),\n/* harmony export */   ConstantColorFactor: () => (/* binding */ ConstantColorFactor),\n/* harmony export */   Controls: () => (/* binding */ Controls),\n/* harmony export */   CubeCamera: () => (/* binding */ CubeCamera),\n/* harmony export */   CubeReflectionMapping: () => (/* binding */ CubeReflectionMapping),\n/* harmony export */   CubeRefractionMapping: () => (/* binding */ CubeRefractionMapping),\n/* harmony export */   CubeTexture: () => (/* binding */ CubeTexture),\n/* harmony export */   CubeTextureLoader: () => (/* binding */ CubeTextureLoader),\n/* harmony export */   CubeUVReflectionMapping: () => (/* binding */ CubeUVReflectionMapping),\n/* harmony export */   CubicBezierCurve: () => (/* binding */ CubicBezierCurve),\n/* harmony export */   CubicBezierCurve3: () => (/* binding */ CubicBezierCurve3),\n/* harmony export */   CubicInterpolant: () => (/* binding */ CubicInterpolant),\n/* harmony export */   CullFaceBack: () => (/* binding */ CullFaceBack),\n/* harmony export */   CullFaceFront: () => (/* binding */ CullFaceFront),\n/* harmony export */   CullFaceFrontBack: () => (/* binding */ CullFaceFrontBack),\n/* harmony export */   CullFaceNone: () => (/* binding */ CullFaceNone),\n/* harmony export */   Curve: () => (/* binding */ Curve),\n/* harmony export */   CurvePath: () => (/* binding */ CurvePath),\n/* harmony export */   CustomBlending: () => (/* binding */ CustomBlending),\n/* harmony export */   CustomToneMapping: () => (/* binding */ CustomToneMapping),\n/* harmony export */   CylinderGeometry: () => (/* binding */ CylinderGeometry),\n/* harmony export */   Cylindrical: () => (/* binding */ Cylindrical),\n/* harmony export */   Data3DTexture: () => (/* binding */ Data3DTexture),\n/* harmony export */   DataArrayTexture: () => (/* binding */ DataArrayTexture),\n/* harmony export */   DataTexture: () => (/* binding */ DataTexture),\n/* harmony export */   DataTextureLoader: () => (/* binding */ DataTextureLoader),\n/* harmony export */   DataUtils: () => (/* binding */ DataUtils),\n/* harmony export */   DecrementStencilOp: () => (/* binding */ DecrementStencilOp),\n/* harmony export */   DecrementWrapStencilOp: () => (/* binding */ DecrementWrapStencilOp),\n/* harmony export */   DefaultLoadingManager: () => (/* binding */ DefaultLoadingManager),\n/* harmony export */   DepthFormat: () => (/* binding */ DepthFormat),\n/* harmony export */   DepthStencilFormat: () => (/* binding */ DepthStencilFormat),\n/* harmony export */   DepthTexture: () => (/* binding */ DepthTexture),\n/* harmony export */   DetachedBindMode: () => (/* binding */ DetachedBindMode),\n/* harmony export */   DirectionalLight: () => (/* binding */ DirectionalLight),\n/* harmony export */   DirectionalLightHelper: () => (/* binding */ DirectionalLightHelper),\n/* harmony export */   DiscreteInterpolant: () => (/* binding */ DiscreteInterpolant),\n/* harmony export */   DodecahedronGeometry: () => (/* binding */ DodecahedronGeometry),\n/* harmony export */   DoubleSide: () => (/* binding */ DoubleSide),\n/* harmony export */   DstAlphaFactor: () => (/* binding */ DstAlphaFactor),\n/* harmony export */   DstColorFactor: () => (/* binding */ DstColorFactor),\n/* harmony export */   DynamicCopyUsage: () => (/* binding */ DynamicCopyUsage),\n/* harmony export */   DynamicDrawUsage: () => (/* binding */ DynamicDrawUsage),\n/* harmony export */   DynamicReadUsage: () => (/* binding */ DynamicReadUsage),\n/* harmony export */   EdgesGeometry: () => (/* binding */ EdgesGeometry),\n/* harmony export */   EllipseCurve: () => (/* binding */ EllipseCurve),\n/* harmony export */   EqualCompare: () => (/* binding */ EqualCompare),\n/* harmony export */   EqualDepth: () => (/* binding */ EqualDepth),\n/* harmony export */   EqualStencilFunc: () => (/* binding */ EqualStencilFunc),\n/* harmony export */   EquirectangularReflectionMapping: () => (/* binding */ EquirectangularReflectionMapping),\n/* harmony export */   EquirectangularRefractionMapping: () => (/* binding */ EquirectangularRefractionMapping),\n/* harmony export */   Euler: () => (/* binding */ Euler),\n/* harmony export */   EventDispatcher: () => (/* binding */ EventDispatcher),\n/* harmony export */   ExtrudeGeometry: () => (/* binding */ ExtrudeGeometry),\n/* harmony export */   FileLoader: () => (/* binding */ FileLoader),\n/* harmony export */   Float16BufferAttribute: () => (/* binding */ Float16BufferAttribute),\n/* harmony export */   Float32BufferAttribute: () => (/* binding */ Float32BufferAttribute),\n/* harmony export */   FloatType: () => (/* binding */ FloatType),\n/* harmony export */   Fog: () => (/* binding */ Fog),\n/* harmony export */   FogExp2: () => (/* binding */ FogExp2),\n/* harmony export */   FramebufferTexture: () => (/* binding */ FramebufferTexture),\n/* harmony export */   FrontSide: () => (/* binding */ FrontSide),\n/* harmony export */   Frustum: () => (/* binding */ Frustum),\n/* harmony export */   GLBufferAttribute: () => (/* binding */ GLBufferAttribute),\n/* harmony export */   GLSL1: () => (/* binding */ GLSL1),\n/* harmony export */   GLSL3: () => (/* binding */ GLSL3),\n/* harmony export */   GreaterCompare: () => (/* binding */ GreaterCompare),\n/* harmony export */   GreaterDepth: () => (/* binding */ GreaterDepth),\n/* harmony export */   GreaterEqualCompare: () => (/* binding */ GreaterEqualCompare),\n/* harmony export */   GreaterEqualDepth: () => (/* binding */ GreaterEqualDepth),\n/* harmony export */   GreaterEqualStencilFunc: () => (/* binding */ GreaterEqualStencilFunc),\n/* harmony export */   GreaterStencilFunc: () => (/* binding */ GreaterStencilFunc),\n/* harmony export */   GridHelper: () => (/* binding */ GridHelper),\n/* harmony export */   Group: () => (/* binding */ Group),\n/* harmony export */   HalfFloatType: () => (/* binding */ HalfFloatType),\n/* harmony export */   HemisphereLight: () => (/* binding */ HemisphereLight),\n/* harmony export */   HemisphereLightHelper: () => (/* binding */ HemisphereLightHelper),\n/* harmony export */   IcosahedronGeometry: () => (/* binding */ IcosahedronGeometry),\n/* harmony export */   ImageBitmapLoader: () => (/* binding */ ImageBitmapLoader),\n/* harmony export */   ImageLoader: () => (/* binding */ ImageLoader),\n/* harmony export */   ImageUtils: () => (/* binding */ ImageUtils),\n/* harmony export */   IncrementStencilOp: () => (/* binding */ IncrementStencilOp),\n/* harmony export */   IncrementWrapStencilOp: () => (/* binding */ IncrementWrapStencilOp),\n/* harmony export */   InstancedBufferAttribute: () => (/* binding */ InstancedBufferAttribute),\n/* harmony export */   InstancedBufferGeometry: () => (/* binding */ InstancedBufferGeometry),\n/* harmony export */   InstancedInterleavedBuffer: () => (/* binding */ InstancedInterleavedBuffer),\n/* harmony export */   InstancedMesh: () => (/* binding */ InstancedMesh),\n/* harmony export */   Int16BufferAttribute: () => (/* binding */ Int16BufferAttribute),\n/* harmony export */   Int32BufferAttribute: () => (/* binding */ Int32BufferAttribute),\n/* harmony export */   Int8BufferAttribute: () => (/* binding */ Int8BufferAttribute),\n/* harmony export */   IntType: () => (/* binding */ IntType),\n/* harmony export */   InterleavedBuffer: () => (/* binding */ InterleavedBuffer),\n/* harmony export */   InterleavedBufferAttribute: () => (/* binding */ InterleavedBufferAttribute),\n/* harmony export */   Interpolant: () => (/* binding */ Interpolant),\n/* harmony export */   InterpolateDiscrete: () => (/* binding */ InterpolateDiscrete),\n/* harmony export */   InterpolateLinear: () => (/* binding */ InterpolateLinear),\n/* harmony export */   InterpolateSmooth: () => (/* binding */ InterpolateSmooth),\n/* harmony export */   InvertStencilOp: () => (/* binding */ InvertStencilOp),\n/* harmony export */   KeepStencilOp: () => (/* binding */ KeepStencilOp),\n/* harmony export */   KeyframeTrack: () => (/* binding */ KeyframeTrack),\n/* harmony export */   LOD: () => (/* binding */ LOD),\n/* harmony export */   LatheGeometry: () => (/* binding */ LatheGeometry),\n/* harmony export */   Layers: () => (/* binding */ Layers),\n/* harmony export */   LessCompare: () => (/* binding */ LessCompare),\n/* harmony export */   LessDepth: () => (/* binding */ LessDepth),\n/* harmony export */   LessEqualCompare: () => (/* binding */ LessEqualCompare),\n/* harmony export */   LessEqualDepth: () => (/* binding */ LessEqualDepth),\n/* harmony export */   LessEqualStencilFunc: () => (/* binding */ LessEqualStencilFunc),\n/* harmony export */   LessStencilFunc: () => (/* binding */ LessStencilFunc),\n/* harmony export */   Light: () => (/* binding */ Light),\n/* harmony export */   LightProbe: () => (/* binding */ LightProbe),\n/* harmony export */   Line: () => (/* binding */ Line),\n/* harmony export */   Line3: () => (/* binding */ Line3),\n/* harmony export */   LineBasicMaterial: () => (/* binding */ LineBasicMaterial),\n/* harmony export */   LineCurve: () => (/* binding */ LineCurve),\n/* harmony export */   LineCurve3: () => (/* binding */ LineCurve3),\n/* harmony export */   LineDashedMaterial: () => (/* binding */ LineDashedMaterial),\n/* harmony export */   LineLoop: () => (/* binding */ LineLoop),\n/* harmony export */   LineSegments: () => (/* binding */ LineSegments),\n/* harmony export */   LinearFilter: () => (/* binding */ LinearFilter),\n/* harmony export */   LinearInterpolant: () => (/* binding */ LinearInterpolant),\n/* harmony export */   LinearMipMapLinearFilter: () => (/* binding */ LinearMipMapLinearFilter),\n/* harmony export */   LinearMipMapNearestFilter: () => (/* binding */ LinearMipMapNearestFilter),\n/* harmony export */   LinearMipmapLinearFilter: () => (/* binding */ LinearMipmapLinearFilter),\n/* harmony export */   LinearMipmapNearestFilter: () => (/* binding */ LinearMipmapNearestFilter),\n/* harmony export */   LinearSRGBColorSpace: () => (/* binding */ LinearSRGBColorSpace),\n/* harmony export */   LinearToneMapping: () => (/* binding */ LinearToneMapping),\n/* harmony export */   LinearTransfer: () => (/* binding */ LinearTransfer),\n/* harmony export */   Loader: () => (/* binding */ Loader),\n/* harmony export */   LoaderUtils: () => (/* binding */ LoaderUtils),\n/* harmony export */   LoadingManager: () => (/* binding */ LoadingManager),\n/* harmony export */   LoopOnce: () => (/* binding */ LoopOnce),\n/* harmony export */   LoopPingPong: () => (/* binding */ LoopPingPong),\n/* harmony export */   LoopRepeat: () => (/* binding */ LoopRepeat),\n/* harmony export */   LuminanceAlphaFormat: () => (/* binding */ LuminanceAlphaFormat),\n/* harmony export */   LuminanceFormat: () => (/* binding */ LuminanceFormat),\n/* harmony export */   MOUSE: () => (/* binding */ MOUSE),\n/* harmony export */   Material: () => (/* binding */ Material),\n/* harmony export */   MaterialLoader: () => (/* binding */ MaterialLoader),\n/* harmony export */   MathUtils: () => (/* binding */ MathUtils),\n/* harmony export */   Matrix2: () => (/* binding */ Matrix2),\n/* harmony export */   Matrix3: () => (/* binding */ Matrix3),\n/* harmony export */   Matrix4: () => (/* binding */ Matrix4),\n/* harmony export */   MaxEquation: () => (/* binding */ MaxEquation),\n/* harmony export */   Mesh: () => (/* binding */ Mesh),\n/* harmony export */   MeshBasicMaterial: () => (/* binding */ MeshBasicMaterial),\n/* harmony export */   MeshDepthMaterial: () => (/* binding */ MeshDepthMaterial),\n/* harmony export */   MeshDistanceMaterial: () => (/* binding */ MeshDistanceMaterial),\n/* harmony export */   MeshLambertMaterial: () => (/* binding */ MeshLambertMaterial),\n/* harmony export */   MeshMatcapMaterial: () => (/* binding */ MeshMatcapMaterial),\n/* harmony export */   MeshNormalMaterial: () => (/* binding */ MeshNormalMaterial),\n/* harmony export */   MeshPhongMaterial: () => (/* binding */ MeshPhongMaterial),\n/* harmony export */   MeshPhysicalMaterial: () => (/* binding */ MeshPhysicalMaterial),\n/* harmony export */   MeshStandardMaterial: () => (/* binding */ MeshStandardMaterial),\n/* harmony export */   MeshToonMaterial: () => (/* binding */ MeshToonMaterial),\n/* harmony export */   MinEquation: () => (/* binding */ MinEquation),\n/* harmony export */   MirroredRepeatWrapping: () => (/* binding */ MirroredRepeatWrapping),\n/* harmony export */   MixOperation: () => (/* binding */ MixOperation),\n/* harmony export */   MultiplyBlending: () => (/* binding */ MultiplyBlending),\n/* harmony export */   MultiplyOperation: () => (/* binding */ MultiplyOperation),\n/* harmony export */   NearestFilter: () => (/* binding */ NearestFilter),\n/* harmony export */   NearestMipMapLinearFilter: () => (/* binding */ NearestMipMapLinearFilter),\n/* harmony export */   NearestMipMapNearestFilter: () => (/* binding */ NearestMipMapNearestFilter),\n/* harmony export */   NearestMipmapLinearFilter: () => (/* binding */ NearestMipmapLinearFilter),\n/* harmony export */   NearestMipmapNearestFilter: () => (/* binding */ NearestMipmapNearestFilter),\n/* harmony export */   NeutralToneMapping: () => (/* binding */ NeutralToneMapping),\n/* harmony export */   NeverCompare: () => (/* binding */ NeverCompare),\n/* harmony export */   NeverDepth: () => (/* binding */ NeverDepth),\n/* harmony export */   NeverStencilFunc: () => (/* binding */ NeverStencilFunc),\n/* harmony export */   NoBlending: () => (/* binding */ NoBlending),\n/* harmony export */   NoColorSpace: () => (/* binding */ NoColorSpace),\n/* harmony export */   NoToneMapping: () => (/* binding */ NoToneMapping),\n/* harmony export */   NormalAnimationBlendMode: () => (/* binding */ NormalAnimationBlendMode),\n/* harmony export */   NormalBlending: () => (/* binding */ NormalBlending),\n/* harmony export */   NotEqualCompare: () => (/* binding */ NotEqualCompare),\n/* harmony export */   NotEqualDepth: () => (/* binding */ NotEqualDepth),\n/* harmony export */   NotEqualStencilFunc: () => (/* binding */ NotEqualStencilFunc),\n/* harmony export */   NumberKeyframeTrack: () => (/* binding */ NumberKeyframeTrack),\n/* harmony export */   Object3D: () => (/* binding */ Object3D),\n/* harmony export */   ObjectLoader: () => (/* binding */ ObjectLoader),\n/* harmony export */   ObjectSpaceNormalMap: () => (/* binding */ ObjectSpaceNormalMap),\n/* harmony export */   OctahedronGeometry: () => (/* binding */ OctahedronGeometry),\n/* harmony export */   OneFactor: () => (/* binding */ OneFactor),\n/* harmony export */   OneMinusConstantAlphaFactor: () => (/* binding */ OneMinusConstantAlphaFactor),\n/* harmony export */   OneMinusConstantColorFactor: () => (/* binding */ OneMinusConstantColorFactor),\n/* harmony export */   OneMinusDstAlphaFactor: () => (/* binding */ OneMinusDstAlphaFactor),\n/* harmony export */   OneMinusDstColorFactor: () => (/* binding */ OneMinusDstColorFactor),\n/* harmony export */   OneMinusSrcAlphaFactor: () => (/* binding */ OneMinusSrcAlphaFactor),\n/* harmony export */   OneMinusSrcColorFactor: () => (/* binding */ OneMinusSrcColorFactor),\n/* harmony export */   OrthographicCamera: () => (/* binding */ OrthographicCamera),\n/* harmony export */   PCFShadowMap: () => (/* binding */ PCFShadowMap),\n/* harmony export */   PCFSoftShadowMap: () => (/* binding */ PCFSoftShadowMap),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   PerspectiveCamera: () => (/* binding */ PerspectiveCamera),\n/* harmony export */   Plane: () => (/* binding */ Plane),\n/* harmony export */   PlaneGeometry: () => (/* binding */ PlaneGeometry),\n/* harmony export */   PlaneHelper: () => (/* binding */ PlaneHelper),\n/* harmony export */   PointLight: () => (/* binding */ PointLight),\n/* harmony export */   PointLightHelper: () => (/* binding */ PointLightHelper),\n/* harmony export */   Points: () => (/* binding */ Points),\n/* harmony export */   PointsMaterial: () => (/* binding */ PointsMaterial),\n/* harmony export */   PolarGridHelper: () => (/* binding */ PolarGridHelper),\n/* harmony export */   PolyhedronGeometry: () => (/* binding */ PolyhedronGeometry),\n/* harmony export */   PositionalAudio: () => (/* binding */ PositionalAudio),\n/* harmony export */   PropertyBinding: () => (/* binding */ PropertyBinding),\n/* harmony export */   PropertyMixer: () => (/* binding */ PropertyMixer),\n/* harmony export */   QuadraticBezierCurve: () => (/* binding */ QuadraticBezierCurve),\n/* harmony export */   QuadraticBezierCurve3: () => (/* binding */ QuadraticBezierCurve3),\n/* harmony export */   Quaternion: () => (/* binding */ Quaternion),\n/* harmony export */   QuaternionKeyframeTrack: () => (/* binding */ QuaternionKeyframeTrack),\n/* harmony export */   QuaternionLinearInterpolant: () => (/* binding */ QuaternionLinearInterpolant),\n/* harmony export */   RAD2DEG: () => (/* binding */ RAD2DEG),\n/* harmony export */   RED_GREEN_RGTC2_Format: () => (/* binding */ RED_GREEN_RGTC2_Format),\n/* harmony export */   RED_RGTC1_Format: () => (/* binding */ RED_RGTC1_Format),\n/* harmony export */   REVISION: () => (/* binding */ REVISION),\n/* harmony export */   RGBADepthPacking: () => (/* binding */ RGBADepthPacking),\n/* harmony export */   RGBAFormat: () => (/* binding */ RGBAFormat),\n/* harmony export */   RGBAIntegerFormat: () => (/* binding */ RGBAIntegerFormat),\n/* harmony export */   RGBA_ASTC_10x10_Format: () => (/* binding */ RGBA_ASTC_10x10_Format),\n/* harmony export */   RGBA_ASTC_10x5_Format: () => (/* binding */ RGBA_ASTC_10x5_Format),\n/* harmony export */   RGBA_ASTC_10x6_Format: () => (/* binding */ RGBA_ASTC_10x6_Format),\n/* harmony export */   RGBA_ASTC_10x8_Format: () => (/* binding */ RGBA_ASTC_10x8_Format),\n/* harmony export */   RGBA_ASTC_12x10_Format: () => (/* binding */ RGBA_ASTC_12x10_Format),\n/* harmony export */   RGBA_ASTC_12x12_Format: () => (/* binding */ RGBA_ASTC_12x12_Format),\n/* harmony export */   RGBA_ASTC_4x4_Format: () => (/* binding */ RGBA_ASTC_4x4_Format),\n/* harmony export */   RGBA_ASTC_5x4_Format: () => (/* binding */ RGBA_ASTC_5x4_Format),\n/* harmony export */   RGBA_ASTC_5x5_Format: () => (/* binding */ RGBA_ASTC_5x5_Format),\n/* harmony export */   RGBA_ASTC_6x5_Format: () => (/* binding */ RGBA_ASTC_6x5_Format),\n/* harmony export */   RGBA_ASTC_6x6_Format: () => (/* binding */ RGBA_ASTC_6x6_Format),\n/* harmony export */   RGBA_ASTC_8x5_Format: () => (/* binding */ RGBA_ASTC_8x5_Format),\n/* harmony export */   RGBA_ASTC_8x6_Format: () => (/* binding */ RGBA_ASTC_8x6_Format),\n/* harmony export */   RGBA_ASTC_8x8_Format: () => (/* binding */ RGBA_ASTC_8x8_Format),\n/* harmony export */   RGBA_BPTC_Format: () => (/* binding */ RGBA_BPTC_Format),\n/* harmony export */   RGBA_ETC2_EAC_Format: () => (/* binding */ RGBA_ETC2_EAC_Format),\n/* harmony export */   RGBA_PVRTC_2BPPV1_Format: () => (/* binding */ RGBA_PVRTC_2BPPV1_Format),\n/* harmony export */   RGBA_PVRTC_4BPPV1_Format: () => (/* binding */ RGBA_PVRTC_4BPPV1_Format),\n/* harmony export */   RGBA_S3TC_DXT1_Format: () => (/* binding */ RGBA_S3TC_DXT1_Format),\n/* harmony export */   RGBA_S3TC_DXT3_Format: () => (/* binding */ RGBA_S3TC_DXT3_Format),\n/* harmony export */   RGBA_S3TC_DXT5_Format: () => (/* binding */ RGBA_S3TC_DXT5_Format),\n/* harmony export */   RGBDepthPacking: () => (/* binding */ RGBDepthPacking),\n/* harmony export */   RGBFormat: () => (/* binding */ RGBFormat),\n/* harmony export */   RGBIntegerFormat: () => (/* binding */ RGBIntegerFormat),\n/* harmony export */   RGB_BPTC_SIGNED_Format: () => (/* binding */ RGB_BPTC_SIGNED_Format),\n/* harmony export */   RGB_BPTC_UNSIGNED_Format: () => (/* binding */ RGB_BPTC_UNSIGNED_Format),\n/* harmony export */   RGB_ETC1_Format: () => (/* binding */ RGB_ETC1_Format),\n/* harmony export */   RGB_ETC2_Format: () => (/* binding */ RGB_ETC2_Format),\n/* harmony export */   RGB_PVRTC_2BPPV1_Format: () => (/* binding */ RGB_PVRTC_2BPPV1_Format),\n/* harmony export */   RGB_PVRTC_4BPPV1_Format: () => (/* binding */ RGB_PVRTC_4BPPV1_Format),\n/* harmony export */   RGB_S3TC_DXT1_Format: () => (/* binding */ RGB_S3TC_DXT1_Format),\n/* harmony export */   RGDepthPacking: () => (/* binding */ RGDepthPacking),\n/* harmony export */   RGFormat: () => (/* binding */ RGFormat),\n/* harmony export */   RGIntegerFormat: () => (/* binding */ RGIntegerFormat),\n/* harmony export */   RawShaderMaterial: () => (/* binding */ RawShaderMaterial),\n/* harmony export */   Ray: () => (/* binding */ Ray),\n/* harmony export */   Raycaster: () => (/* binding */ Raycaster),\n/* harmony export */   RectAreaLight: () => (/* binding */ RectAreaLight),\n/* harmony export */   RedFormat: () => (/* binding */ RedFormat),\n/* harmony export */   RedIntegerFormat: () => (/* binding */ RedIntegerFormat),\n/* harmony export */   ReinhardToneMapping: () => (/* binding */ ReinhardToneMapping),\n/* harmony export */   RenderTarget: () => (/* binding */ RenderTarget),\n/* harmony export */   RenderTarget3D: () => (/* binding */ RenderTarget3D),\n/* harmony export */   RenderTargetArray: () => (/* binding */ RenderTargetArray),\n/* harmony export */   RepeatWrapping: () => (/* binding */ RepeatWrapping),\n/* harmony export */   ReplaceStencilOp: () => (/* binding */ ReplaceStencilOp),\n/* harmony export */   ReverseSubtractEquation: () => (/* binding */ ReverseSubtractEquation),\n/* harmony export */   RingGeometry: () => (/* binding */ RingGeometry),\n/* harmony export */   SIGNED_RED_GREEN_RGTC2_Format: () => (/* binding */ SIGNED_RED_GREEN_RGTC2_Format),\n/* harmony export */   SIGNED_RED_RGTC1_Format: () => (/* binding */ SIGNED_RED_RGTC1_Format),\n/* harmony export */   SRGBColorSpace: () => (/* binding */ SRGBColorSpace),\n/* harmony export */   SRGBTransfer: () => (/* binding */ SRGBTransfer),\n/* harmony export */   Scene: () => (/* binding */ Scene),\n/* harmony export */   ShaderMaterial: () => (/* binding */ ShaderMaterial),\n/* harmony export */   ShadowMaterial: () => (/* binding */ ShadowMaterial),\n/* harmony export */   Shape: () => (/* binding */ Shape),\n/* harmony export */   ShapeGeometry: () => (/* binding */ ShapeGeometry),\n/* harmony export */   ShapePath: () => (/* binding */ ShapePath),\n/* harmony export */   ShapeUtils: () => (/* binding */ ShapeUtils),\n/* harmony export */   ShortType: () => (/* binding */ ShortType),\n/* harmony export */   Skeleton: () => (/* binding */ Skeleton),\n/* harmony export */   SkeletonHelper: () => (/* binding */ SkeletonHelper),\n/* harmony export */   SkinnedMesh: () => (/* binding */ SkinnedMesh),\n/* harmony export */   Source: () => (/* binding */ Source),\n/* harmony export */   Sphere: () => (/* binding */ Sphere),\n/* harmony export */   SphereGeometry: () => (/* binding */ SphereGeometry),\n/* harmony export */   Spherical: () => (/* binding */ Spherical),\n/* harmony export */   SphericalHarmonics3: () => (/* binding */ SphericalHarmonics3),\n/* harmony export */   SplineCurve: () => (/* binding */ SplineCurve),\n/* harmony export */   SpotLight: () => (/* binding */ SpotLight),\n/* harmony export */   SpotLightHelper: () => (/* binding */ SpotLightHelper),\n/* harmony export */   Sprite: () => (/* binding */ Sprite),\n/* harmony export */   SpriteMaterial: () => (/* binding */ SpriteMaterial),\n/* harmony export */   SrcAlphaFactor: () => (/* binding */ SrcAlphaFactor),\n/* harmony export */   SrcAlphaSaturateFactor: () => (/* binding */ SrcAlphaSaturateFactor),\n/* harmony export */   SrcColorFactor: () => (/* binding */ SrcColorFactor),\n/* harmony export */   StaticCopyUsage: () => (/* binding */ StaticCopyUsage),\n/* harmony export */   StaticDrawUsage: () => (/* binding */ StaticDrawUsage),\n/* harmony export */   StaticReadUsage: () => (/* binding */ StaticReadUsage),\n/* harmony export */   StereoCamera: () => (/* binding */ StereoCamera),\n/* harmony export */   StreamCopyUsage: () => (/* binding */ StreamCopyUsage),\n/* harmony export */   StreamDrawUsage: () => (/* binding */ StreamDrawUsage),\n/* harmony export */   StreamReadUsage: () => (/* binding */ StreamReadUsage),\n/* harmony export */   StringKeyframeTrack: () => (/* binding */ StringKeyframeTrack),\n/* harmony export */   SubtractEquation: () => (/* binding */ SubtractEquation),\n/* harmony export */   SubtractiveBlending: () => (/* binding */ SubtractiveBlending),\n/* harmony export */   TOUCH: () => (/* binding */ TOUCH),\n/* harmony export */   TangentSpaceNormalMap: () => (/* binding */ TangentSpaceNormalMap),\n/* harmony export */   TetrahedronGeometry: () => (/* binding */ TetrahedronGeometry),\n/* harmony export */   Texture: () => (/* binding */ Texture),\n/* harmony export */   TextureLoader: () => (/* binding */ TextureLoader),\n/* harmony export */   TextureUtils: () => (/* binding */ TextureUtils),\n/* harmony export */   TorusGeometry: () => (/* binding */ TorusGeometry),\n/* harmony export */   TorusKnotGeometry: () => (/* binding */ TorusKnotGeometry),\n/* harmony export */   Triangle: () => (/* binding */ Triangle),\n/* harmony export */   TriangleFanDrawMode: () => (/* binding */ TriangleFanDrawMode),\n/* harmony export */   TriangleStripDrawMode: () => (/* binding */ TriangleStripDrawMode),\n/* harmony export */   TrianglesDrawMode: () => (/* binding */ TrianglesDrawMode),\n/* harmony export */   TubeGeometry: () => (/* binding */ TubeGeometry),\n/* harmony export */   UVMapping: () => (/* binding */ UVMapping),\n/* harmony export */   Uint16BufferAttribute: () => (/* binding */ Uint16BufferAttribute),\n/* harmony export */   Uint32BufferAttribute: () => (/* binding */ Uint32BufferAttribute),\n/* harmony export */   Uint8BufferAttribute: () => (/* binding */ Uint8BufferAttribute),\n/* harmony export */   Uint8ClampedBufferAttribute: () => (/* binding */ Uint8ClampedBufferAttribute),\n/* harmony export */   Uniform: () => (/* binding */ Uniform),\n/* harmony export */   UniformsGroup: () => (/* binding */ UniformsGroup),\n/* harmony export */   UniformsUtils: () => (/* binding */ UniformsUtils),\n/* harmony export */   UnsignedByteType: () => (/* binding */ UnsignedByteType),\n/* harmony export */   UnsignedInt248Type: () => (/* binding */ UnsignedInt248Type),\n/* harmony export */   UnsignedInt5999Type: () => (/* binding */ UnsignedInt5999Type),\n/* harmony export */   UnsignedIntType: () => (/* binding */ UnsignedIntType),\n/* harmony export */   UnsignedShort4444Type: () => (/* binding */ UnsignedShort4444Type),\n/* harmony export */   UnsignedShort5551Type: () => (/* binding */ UnsignedShort5551Type),\n/* harmony export */   UnsignedShortType: () => (/* binding */ UnsignedShortType),\n/* harmony export */   VSMShadowMap: () => (/* binding */ VSMShadowMap),\n/* harmony export */   Vector2: () => (/* binding */ Vector2),\n/* harmony export */   Vector3: () => (/* binding */ Vector3),\n/* harmony export */   Vector4: () => (/* binding */ Vector4),\n/* harmony export */   VectorKeyframeTrack: () => (/* binding */ VectorKeyframeTrack),\n/* harmony export */   VideoTexture: () => (/* binding */ VideoTexture),\n/* harmony export */   WebGL3DRenderTarget: () => (/* binding */ WebGL3DRenderTarget),\n/* harmony export */   WebGLArrayRenderTarget: () => (/* binding */ WebGLArrayRenderTarget),\n/* harmony export */   WebGLCoordinateSystem: () => (/* binding */ WebGLCoordinateSystem),\n/* harmony export */   WebGLCubeRenderTarget: () => (/* binding */ WebGLCubeRenderTarget),\n/* harmony export */   WebGLRenderTarget: () => (/* binding */ WebGLRenderTarget),\n/* harmony export */   WebGPUCoordinateSystem: () => (/* binding */ WebGPUCoordinateSystem),\n/* harmony export */   WireframeGeometry: () => (/* binding */ WireframeGeometry),\n/* harmony export */   WrapAroundEnding: () => (/* binding */ WrapAroundEnding),\n/* harmony export */   ZeroCurvatureEnding: () => (/* binding */ ZeroCurvatureEnding),\n/* harmony export */   ZeroFactor: () => (/* binding */ ZeroFactor),\n/* harmony export */   ZeroSlopeEnding: () => (/* binding */ ZeroSlopeEnding),\n/* harmony export */   ZeroStencilOp: () => (/* binding */ ZeroStencilOp),\n/* harmony export */   arrayNeedsUint32: () => (/* binding */ arrayNeedsUint32),\n/* harmony export */   cloneUniforms: () => (/* binding */ cloneUniforms),\n/* harmony export */   createCanvasElement: () => (/* binding */ createCanvasElement),\n/* harmony export */   createElementNS: () => (/* binding */ createElementNS),\n/* harmony export */   getByteLength: () => (/* binding */ getByteLength),\n/* harmony export */   getUnlitUniformColorSpace: () => (/* binding */ getUnlitUniformColorSpace),\n/* harmony export */   mergeUniforms: () => (/* binding */ mergeUniforms),\n/* harmony export */   probeAsync: () => (/* binding */ probeAsync),\n/* harmony export */   toNormalizedProjectionMatrix: () => (/* binding */ toNormalizedProjectionMatrix),\n/* harmony export */   toReversedProjectionMatrix: () => (/* binding */ toReversedProjectionMatrix),\n/* harmony export */   warnOnce: () => (/* binding */ warnOnce)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2010-2024 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nconst REVISION = '172';\n\nconst MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };\nconst TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };\nconst CullFaceNone = 0;\nconst CullFaceBack = 1;\nconst CullFaceFront = 2;\nconst CullFaceFrontBack = 3;\nconst BasicShadowMap = 0;\nconst PCFShadowMap = 1;\nconst PCFSoftShadowMap = 2;\nconst VSMShadowMap = 3;\nconst FrontSide = 0;\nconst BackSide = 1;\nconst DoubleSide = 2;\nconst NoBlending = 0;\nconst NormalBlending = 1;\nconst AdditiveBlending = 2;\nconst SubtractiveBlending = 3;\nconst MultiplyBlending = 4;\nconst CustomBlending = 5;\nconst AddEquation = 100;\nconst SubtractEquation = 101;\nconst ReverseSubtractEquation = 102;\nconst MinEquation = 103;\nconst MaxEquation = 104;\nconst ZeroFactor = 200;\nconst OneFactor = 201;\nconst SrcColorFactor = 202;\nconst OneMinusSrcColorFactor = 203;\nconst SrcAlphaFactor = 204;\nconst OneMinusSrcAlphaFactor = 205;\nconst DstAlphaFactor = 206;\nconst OneMinusDstAlphaFactor = 207;\nconst DstColorFactor = 208;\nconst OneMinusDstColorFactor = 209;\nconst SrcAlphaSaturateFactor = 210;\nconst ConstantColorFactor = 211;\nconst OneMinusConstantColorFactor = 212;\nconst ConstantAlphaFactor = 213;\nconst OneMinusConstantAlphaFactor = 214;\nconst NeverDepth = 0;\nconst AlwaysDepth = 1;\nconst LessDepth = 2;\nconst LessEqualDepth = 3;\nconst EqualDepth = 4;\nconst GreaterEqualDepth = 5;\nconst GreaterDepth = 6;\nconst NotEqualDepth = 7;\nconst MultiplyOperation = 0;\nconst MixOperation = 1;\nconst AddOperation = 2;\nconst NoToneMapping = 0;\nconst LinearToneMapping = 1;\nconst ReinhardToneMapping = 2;\nconst CineonToneMapping = 3;\nconst ACESFilmicToneMapping = 4;\nconst CustomToneMapping = 5;\nconst AgXToneMapping = 6;\nconst NeutralToneMapping = 7;\nconst AttachedBindMode = 'attached';\nconst DetachedBindMode = 'detached';\n\nconst UVMapping = 300;\nconst CubeReflectionMapping = 301;\nconst CubeRefractionMapping = 302;\nconst EquirectangularReflectionMapping = 303;\nconst EquirectangularRefractionMapping = 304;\nconst CubeUVReflectionMapping = 306;\nconst RepeatWrapping = 1000;\nconst ClampToEdgeWrapping = 1001;\nconst MirroredRepeatWrapping = 1002;\nconst NearestFilter = 1003;\nconst NearestMipmapNearestFilter = 1004;\nconst NearestMipMapNearestFilter = 1004;\nconst NearestMipmapLinearFilter = 1005;\nconst NearestMipMapLinearFilter = 1005;\nconst LinearFilter = 1006;\nconst LinearMipmapNearestFilter = 1007;\nconst LinearMipMapNearestFilter = 1007;\nconst LinearMipmapLinearFilter = 1008;\nconst LinearMipMapLinearFilter = 1008;\nconst UnsignedByteType = 1009;\nconst ByteType = 1010;\nconst ShortType = 1011;\nconst UnsignedShortType = 1012;\nconst IntType = 1013;\nconst UnsignedIntType = 1014;\nconst FloatType = 1015;\nconst HalfFloatType = 1016;\nconst UnsignedShort4444Type = 1017;\nconst UnsignedShort5551Type = 1018;\nconst UnsignedInt248Type = 1020;\nconst UnsignedInt5999Type = 35902;\nconst AlphaFormat = 1021;\nconst RGBFormat = 1022;\nconst RGBAFormat = 1023;\nconst LuminanceFormat = 1024;\nconst LuminanceAlphaFormat = 1025;\nconst DepthFormat = 1026;\nconst DepthStencilFormat = 1027;\nconst RedFormat = 1028;\nconst RedIntegerFormat = 1029;\nconst RGFormat = 1030;\nconst RGIntegerFormat = 1031;\nconst RGBIntegerFormat = 1032;\nconst RGBAIntegerFormat = 1033;\n\nconst RGB_S3TC_DXT1_Format = 33776;\nconst RGBA_S3TC_DXT1_Format = 33777;\nconst RGBA_S3TC_DXT3_Format = 33778;\nconst RGBA_S3TC_DXT5_Format = 33779;\nconst RGB_PVRTC_4BPPV1_Format = 35840;\nconst RGB_PVRTC_2BPPV1_Format = 35841;\nconst RGBA_PVRTC_4BPPV1_Format = 35842;\nconst RGBA_PVRTC_2BPPV1_Format = 35843;\nconst RGB_ETC1_Format = 36196;\nconst RGB_ETC2_Format = 37492;\nconst RGBA_ETC2_EAC_Format = 37496;\nconst RGBA_ASTC_4x4_Format = 37808;\nconst RGBA_ASTC_5x4_Format = 37809;\nconst RGBA_ASTC_5x5_Format = 37810;\nconst RGBA_ASTC_6x5_Format = 37811;\nconst RGBA_ASTC_6x6_Format = 37812;\nconst RGBA_ASTC_8x5_Format = 37813;\nconst RGBA_ASTC_8x6_Format = 37814;\nconst RGBA_ASTC_8x8_Format = 37815;\nconst RGBA_ASTC_10x5_Format = 37816;\nconst RGBA_ASTC_10x6_Format = 37817;\nconst RGBA_ASTC_10x8_Format = 37818;\nconst RGBA_ASTC_10x10_Format = 37819;\nconst RGBA_ASTC_12x10_Format = 37820;\nconst RGBA_ASTC_12x12_Format = 37821;\nconst RGBA_BPTC_Format = 36492;\nconst RGB_BPTC_SIGNED_Format = 36494;\nconst RGB_BPTC_UNSIGNED_Format = 36495;\nconst RED_RGTC1_Format = 36283;\nconst SIGNED_RED_RGTC1_Format = 36284;\nconst RED_GREEN_RGTC2_Format = 36285;\nconst SIGNED_RED_GREEN_RGTC2_Format = 36286;\nconst LoopOnce = 2200;\nconst LoopRepeat = 2201;\nconst LoopPingPong = 2202;\nconst InterpolateDiscrete = 2300;\nconst InterpolateLinear = 2301;\nconst InterpolateSmooth = 2302;\nconst ZeroCurvatureEnding = 2400;\nconst ZeroSlopeEnding = 2401;\nconst WrapAroundEnding = 2402;\nconst NormalAnimationBlendMode = 2500;\nconst AdditiveAnimationBlendMode = 2501;\nconst TrianglesDrawMode = 0;\nconst TriangleStripDrawMode = 1;\nconst TriangleFanDrawMode = 2;\nconst BasicDepthPacking = 3200;\nconst RGBADepthPacking = 3201;\nconst RGBDepthPacking = 3202;\nconst RGDepthPacking = 3203;\nconst TangentSpaceNormalMap = 0;\nconst ObjectSpaceNormalMap = 1;\n\n// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.\nconst NoColorSpace = '';\nconst SRGBColorSpace = 'srgb';\nconst LinearSRGBColorSpace = 'srgb-linear';\n\nconst LinearTransfer = 'linear';\nconst SRGBTransfer = 'srgb';\n\nconst ZeroStencilOp = 0;\nconst KeepStencilOp = 7680;\nconst ReplaceStencilOp = 7681;\nconst IncrementStencilOp = 7682;\nconst DecrementStencilOp = 7683;\nconst IncrementWrapStencilOp = 34055;\nconst DecrementWrapStencilOp = 34056;\nconst InvertStencilOp = 5386;\n\nconst NeverStencilFunc = 512;\nconst LessStencilFunc = 513;\nconst EqualStencilFunc = 514;\nconst LessEqualStencilFunc = 515;\nconst GreaterStencilFunc = 516;\nconst NotEqualStencilFunc = 517;\nconst GreaterEqualStencilFunc = 518;\nconst AlwaysStencilFunc = 519;\n\nconst NeverCompare = 512;\nconst LessCompare = 513;\nconst EqualCompare = 514;\nconst LessEqualCompare = 515;\nconst GreaterCompare = 516;\nconst NotEqualCompare = 517;\nconst GreaterEqualCompare = 518;\nconst AlwaysCompare = 519;\n\nconst StaticDrawUsage = 35044;\nconst DynamicDrawUsage = 35048;\nconst StreamDrawUsage = 35040;\nconst StaticReadUsage = 35045;\nconst DynamicReadUsage = 35049;\nconst StreamReadUsage = 35041;\nconst StaticCopyUsage = 35046;\nconst DynamicCopyUsage = 35050;\nconst StreamCopyUsage = 35042;\n\nconst GLSL1 = '100';\nconst GLSL3 = '300 es';\n\nconst WebGLCoordinateSystem = 2000;\nconst WebGPUCoordinateSystem = 2001;\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nclass EventDispatcher {\n\n\taddEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tconst listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t}\n\n\thasEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tconst listeners = this._listeners;\n\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n\t}\n\n\tremoveEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tconst index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdispatchEvent( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\tconst array = listenerArray.slice( 0 );\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t\tevent.target = null;\n\n\t\t}\n\n\t}\n\n}\n\nconst _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];\n\nlet _seed = 1234567;\n\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n\n\tconst d0 = Math.random() * 0xffffffff | 0;\n\tconst d1 = Math.random() * 0xffffffff | 0;\n\tconst d2 = Math.random() * 0xffffffff | 0;\n\tconst d3 = Math.random() * 0xffffffff | 0;\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t// .toLowerCase() here flattens concatenated strings to save heap memory space.\n\treturn uuid.toLowerCase();\n\n}\n\nfunction clamp( value, min, max ) {\n\n\treturn Math.max( min, Math.min( max, value ) );\n\n}\n\n// compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo( n, m ) {\n\n\treturn ( ( n % m ) + m ) % m;\n\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear( x, a1, a2, b1, b2 ) {\n\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp( x, y, value ) {\n\n\tif ( x !== y ) {\n\n\t\treturn ( value - x ) / ( y - x );\n\n\t} else {\n\n\t\treturn 0;\n\n\t}\n\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp( x, y, t ) {\n\n\treturn ( 1 - t ) * x + t * y;\n\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp( x, y, lambda, dt ) {\n\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong( x, length = 1 ) {\n\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\n\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * ( 3 - 2 * x );\n\n}\n\nfunction smootherstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n}\n\n// Random integer from <low, high> interval\nfunction randInt( low, high ) {\n\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n}\n\n// Random float from <low, high> interval\nfunction randFloat( low, high ) {\n\n\treturn low + Math.random() * ( high - low );\n\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread( range ) {\n\n\treturn range * ( 0.5 - Math.random() );\n\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom( s ) {\n\n\tif ( s !== undefined ) _seed = s;\n\n\t// Mulberry32 generator\n\n\tlet t = _seed += 0x6D2B79F5;\n\n\tt = Math.imul( t ^ t >>> 15, t | 1 );\n\n\tt ^= t + Math.imul( t ^ t >>> 7, t | 61 );\n\n\treturn ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;\n\n}\n\nfunction degToRad( degrees ) {\n\n\treturn degrees * DEG2RAD;\n\n}\n\nfunction radToDeg( radians ) {\n\n\treturn radians * RAD2DEG;\n\n}\n\nfunction isPowerOfTwo( value ) {\n\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n}\n\nfunction ceilPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction floorPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction setQuaternionFromProperEuler( q, a, b, c, order ) {\n\n\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t// rotations are applied to the axes in the order specified by 'order'\n\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t// angles are in radians\n\n\tconst cos = Math.cos;\n\tconst sin = Math.sin;\n\n\tconst c2 = cos( b / 2 );\n\tconst s2 = sin( b / 2 );\n\n\tconst c13 = cos( ( a + c ) / 2 );\n\tconst s13 = sin( ( a + c ) / 2 );\n\n\tconst c1_3 = cos( ( a - c ) / 2 );\n\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\tconst c3_1 = cos( ( c - a ) / 2 );\n\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\tswitch ( order ) {\n\n\t\tcase 'XYX':\n\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YZY':\n\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZXZ':\n\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'XZX':\n\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YXY':\n\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZYZ':\n\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t}\n\n}\n\nfunction denormalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn value / 4294967295.0;\n\n\t\tcase Uint16Array:\n\n\t\t\treturn value / 65535.0;\n\n\t\tcase Uint8Array:\n\n\t\t\treturn value / 255.0;\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.max( value / 2147483647.0, - 1.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.max( value / 32767.0, - 1.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.max( value / 127.0, - 1.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nfunction normalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn Math.round( value * 4294967295.0 );\n\n\t\tcase Uint16Array:\n\n\t\t\treturn Math.round( value * 65535.0 );\n\n\t\tcase Uint8Array:\n\n\t\t\treturn Math.round( value * 255.0 );\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.round( value * 2147483647.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.round( value * 32767.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.round( value * 127.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nconst MathUtils = {\n\tDEG2RAD: DEG2RAD,\n\tRAD2DEG: RAD2DEG,\n\tgenerateUUID: generateUUID,\n\tclamp: clamp,\n\teuclideanModulo: euclideanModulo,\n\tmapLinear: mapLinear,\n\tinverseLerp: inverseLerp,\n\tlerp: lerp,\n\tdamp: damp,\n\tpingpong: pingpong,\n\tsmoothstep: smoothstep,\n\tsmootherstep: smootherstep,\n\trandInt: randInt,\n\trandFloat: randFloat,\n\trandFloatSpread: randFloatSpread,\n\tseededRandom: seededRandom,\n\tdegToRad: degToRad,\n\tradToDeg: radToDeg,\n\tisPowerOfTwo: isPowerOfTwo,\n\tceilPowerOfTwo: ceilPowerOfTwo,\n\tfloorPowerOfTwo: floorPowerOfTwo,\n\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler,\n\tnormalize: normalize,\n\tdenormalize: denormalize\n};\n\nclass Vector2 {\n\n\tconstructor( x = 0, y = 0 ) {\n\n\t\tVector2.prototype.isVector2 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.x;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.x = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.y;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.y = value;\n\n\t}\n\n\tset( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = clamp( this.x, min.x, max.x );\n\t\tthis.y = clamp( this.y, min.y, max.y );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = clamp( this.x, minVal, maxVal );\n\t\tthis.y = clamp( this.y, minVal, maxVal );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = Math.trunc( this.x );\n\t\tthis.y = Math.trunc( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t}\n\n\tcross( v ) {\n\n\t\treturn this.x * v.y - this.y * v.x;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tangle() {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tconst angle = Math.atan2( - this.y, - this.x ) + Math.PI;\n\n\t\treturn angle;\n\n\t}\n\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( clamp( theta, - 1, 1 ) );\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\n\t\treturn this;\n\n\t}\n\n\trotateAround( center, angle ) {\n\n\t\tconst c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tconst x = this.x - center.x;\n\t\tconst y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\n\t}\n\n}\n\nclass Matrix3 {\n\n\tconstructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tMatrix3.prototype.isMatrix3 = true;\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\n\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\n\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrix3Column( this, 0 );\n\t\tyAxis.setFromMatrix3Column( this, 1 );\n\t\tzAxis.setFromMatrix3Column( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix4( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t}\n\n\tinvert() {\n\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],\n\t\t\tn12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],\n\t\t\tn13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\ttranspose() {\n\n\t\tlet tmp;\n\t\tconst m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tgetNormalMatrix( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).invert().transpose();\n\n\t}\n\n\ttransposeIntoArray( r ) {\n\n\t\tconst m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {\n\n\t\tconst c = Math.cos( rotation );\n\t\tconst s = Math.sin( rotation );\n\n\t\tthis.set(\n\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\n\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\n\t\t\t0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t//\n\n\tscale( sx, sy ) {\n\n\t\tthis.premultiply( _m3.makeScale( sx, sy ) );\n\n\t\treturn this;\n\n\t}\n\n\trotate( theta ) {\n\n\t\tthis.premultiply( _m3.makeRotation( - theta ) );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( tx, ty ) {\n\n\t\tthis.premultiply( _m3.makeTranslation( tx, ty ) );\n\n\t\treturn this;\n\n\t}\n\n\t// for 2D Transforms\n\n\tmakeTranslation( x, y ) {\n\n\t\tif ( x.isVector2 ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, x.x,\n\t\t\t\t0, 1, x.y,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, x,\n\t\t\t\t0, 1, y,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotation( theta ) {\n\n\t\t// counterclockwise\n\n\t\tconst c = Math.cos( theta );\n\t\tconst s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0,\n\t\t\ts, c, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeScale( x, y ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0,\n\t\t\t0, y, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t//\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t}\n\n}\n\nconst _m3 = /*@__PURE__*/ new Matrix3();\n\nfunction arrayNeedsUint32( array ) {\n\n\t// assumes larger values usually on last\n\n\tfor ( let i = array.length - 1; i >= 0; -- i ) {\n\n\t\tif ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565\n\n\t}\n\n\treturn false;\n\n}\n\nconst TYPED_ARRAYS = {\n\tInt8Array: Int8Array,\n\tUint8Array: Uint8Array,\n\tUint8ClampedArray: Uint8ClampedArray,\n\tInt16Array: Int16Array,\n\tUint16Array: Uint16Array,\n\tInt32Array: Int32Array,\n\tUint32Array: Uint32Array,\n\tFloat32Array: Float32Array,\n\tFloat64Array: Float64Array\n};\n\nfunction getTypedArray( type, buffer ) {\n\n\treturn new TYPED_ARRAYS[ type ]( buffer );\n\n}\n\nfunction createElementNS( name ) {\n\n\treturn document.createElementNS( 'http://www.w3.org/1999/xhtml', name );\n\n}\n\nfunction createCanvasElement() {\n\n\tconst canvas = createElementNS( 'canvas' );\n\tcanvas.style.display = 'block';\n\treturn canvas;\n\n}\n\nconst _cache = {};\n\nfunction warnOnce( message ) {\n\n\tif ( message in _cache ) return;\n\n\t_cache[ message ] = true;\n\n\tconsole.warn( message );\n\n}\n\nfunction probeAsync( gl, sync, interval ) {\n\n\treturn new Promise( function ( resolve, reject ) {\n\n\t\tfunction probe() {\n\n\t\t\tswitch ( gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 ) ) {\n\n\t\t\t\tcase gl.WAIT_FAILED:\n\t\t\t\t\treject();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase gl.TIMEOUT_EXPIRED:\n\t\t\t\t\tsetTimeout( probe, interval );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tresolve();\n\n\t\t\t}\n\n\t\t}\n\n\t\tsetTimeout( probe, interval );\n\n\t} );\n\n}\n\nfunction toNormalizedProjectionMatrix( projectionMatrix ) {\n\n\tconst m = projectionMatrix.elements;\n\n\t// Convert [-1, 1] to [0, 1] projection matrix\n\tm[ 2 ] = 0.5 * m[ 2 ] + 0.5 * m[ 3 ];\n\tm[ 6 ] = 0.5 * m[ 6 ] + 0.5 * m[ 7 ];\n\tm[ 10 ] = 0.5 * m[ 10 ] + 0.5 * m[ 11 ];\n\tm[ 14 ] = 0.5 * m[ 14 ] + 0.5 * m[ 15 ];\n\n}\n\nfunction toReversedProjectionMatrix( projectionMatrix ) {\n\n\tconst m = projectionMatrix.elements;\n\tconst isPerspectiveMatrix = m[ 11 ] === - 1;\n\n\t// Reverse [0, 1] projection matrix\n\tif ( isPerspectiveMatrix ) {\n\n\t\tm[ 10 ] = - m[ 10 ] - 1;\n\t\tm[ 14 ] = - m[ 14 ];\n\n\t} else {\n\n\t\tm[ 10 ] = - m[ 10 ];\n\t\tm[ 14 ] = - m[ 14 ] + 1;\n\n\t}\n\n}\n\nconst LINEAR_REC709_TO_XYZ = /*@__PURE__*/ new Matrix3().set(\n\t0.4123908, 0.3575843, 0.1804808,\n\t0.2126390, 0.7151687, 0.0721923,\n\t0.0193308, 0.1191948, 0.9505322\n);\n\nconst XYZ_TO_LINEAR_REC709 = /*@__PURE__*/ new Matrix3().set(\n\t3.2409699, - 1.5373832, - 0.4986108,\n\t- 0.9692436, 1.8759675, 0.0415551,\n\t0.0556301, - 0.2039770, 1.0569715\n);\n\nfunction createColorManagement() {\n\n\tconst ColorManagement = {\n\n\t\tenabled: true,\n\n\t\tworkingColorSpace: LinearSRGBColorSpace,\n\n\t\t/**\n\t\t * Implementations of supported color spaces.\n\t\t *\n\t\t * Required:\n\t\t *\t- primaries: chromaticity coordinates [ rx ry gx gy bx by ]\n\t\t *\t- whitePoint: reference white [ x y ]\n\t\t *\t- transfer: transfer function (pre-defined)\n\t\t *\t- toXYZ: Matrix3 RGB to XYZ transform\n\t\t *\t- fromXYZ: Matrix3 XYZ to RGB transform\n\t\t *\t- luminanceCoefficients: RGB luminance coefficients\n\t\t *\n\t\t * Optional:\n\t\t *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }\n\t\t *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }\n\t\t *\n\t\t * Reference:\n\t\t * - https://www.russellcottrell.com/photo/matrixCalculator.htm\n\t\t */\n\t\tspaces: {},\n\n\t\tconvert: function ( color, sourceColorSpace, targetColorSpace ) {\n\n\t\t\tif ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {\n\n\t\t\t\treturn color;\n\n\t\t\t}\n\n\t\t\tif ( this.spaces[ sourceColorSpace ].transfer === SRGBTransfer ) {\n\n\t\t\t\tcolor.r = SRGBToLinear( color.r );\n\t\t\t\tcolor.g = SRGBToLinear( color.g );\n\t\t\t\tcolor.b = SRGBToLinear( color.b );\n\n\t\t\t}\n\n\t\t\tif ( this.spaces[ sourceColorSpace ].primaries !== this.spaces[ targetColorSpace ].primaries ) {\n\n\t\t\t\tcolor.applyMatrix3( this.spaces[ sourceColorSpace ].toXYZ );\n\t\t\t\tcolor.applyMatrix3( this.spaces[ targetColorSpace ].fromXYZ );\n\n\t\t\t}\n\n\t\t\tif ( this.spaces[ targetColorSpace ].transfer === SRGBTransfer ) {\n\n\t\t\t\tcolor.r = LinearToSRGB( color.r );\n\t\t\t\tcolor.g = LinearToSRGB( color.g );\n\t\t\t\tcolor.b = LinearToSRGB( color.b );\n\n\t\t\t}\n\n\t\t\treturn color;\n\n\t\t},\n\n\t\tfromWorkingColorSpace: function ( color, targetColorSpace ) {\n\n\t\t\treturn this.convert( color, this.workingColorSpace, targetColorSpace );\n\n\t\t},\n\n\t\ttoWorkingColorSpace: function ( color, sourceColorSpace ) {\n\n\t\t\treturn this.convert( color, sourceColorSpace, this.workingColorSpace );\n\n\t\t},\n\n\t\tgetPrimaries: function ( colorSpace ) {\n\n\t\t\treturn this.spaces[ colorSpace ].primaries;\n\n\t\t},\n\n\t\tgetTransfer: function ( colorSpace ) {\n\n\t\t\tif ( colorSpace === NoColorSpace ) return LinearTransfer;\n\n\t\t\treturn this.spaces[ colorSpace ].transfer;\n\n\t\t},\n\n\t\tgetLuminanceCoefficients: function ( target, colorSpace = this.workingColorSpace ) {\n\n\t\t\treturn target.fromArray( this.spaces[ colorSpace ].luminanceCoefficients );\n\n\t\t},\n\n\t\tdefine: function ( colorSpaces ) {\n\n\t\t\tObject.assign( this.spaces, colorSpaces );\n\n\t\t},\n\n\t\t// Internal APIs\n\n\t\t_getMatrix: function ( targetMatrix, sourceColorSpace, targetColorSpace ) {\n\n\t\t\treturn targetMatrix\n\t\t\t\t.copy( this.spaces[ sourceColorSpace ].toXYZ )\n\t\t\t\t.multiply( this.spaces[ targetColorSpace ].fromXYZ );\n\n\t\t},\n\n\t\t_getDrawingBufferColorSpace: function ( colorSpace ) {\n\n\t\t\treturn this.spaces[ colorSpace ].outputColorSpaceConfig.drawingBufferColorSpace;\n\n\t\t},\n\n\t\t_getUnpackColorSpace: function ( colorSpace = this.workingColorSpace ) {\n\n\t\t\treturn this.spaces[ colorSpace ].workingColorSpaceConfig.unpackColorSpace;\n\n\t\t}\n\n\t};\n\n\t/******************************************************************************\n\t * sRGB definitions\n\t */\n\n\tconst REC709_PRIMARIES = [ 0.640, 0.330, 0.300, 0.600, 0.150, 0.060 ];\n\tconst REC709_LUMINANCE_COEFFICIENTS = [ 0.2126, 0.7152, 0.0722 ];\n\tconst D65 = [ 0.3127, 0.3290 ];\n\n\tColorManagement.define( {\n\n\t\t[ LinearSRGBColorSpace ]: {\n\t\t\tprimaries: REC709_PRIMARIES,\n\t\t\twhitePoint: D65,\n\t\t\ttransfer: LinearTransfer,\n\t\t\ttoXYZ: LINEAR_REC709_TO_XYZ,\n\t\t\tfromXYZ: XYZ_TO_LINEAR_REC709,\n\t\t\tluminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n\t\t\tworkingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },\n\t\t\toutputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n\t\t},\n\n\t\t[ SRGBColorSpace ]: {\n\t\t\tprimaries: REC709_PRIMARIES,\n\t\t\twhitePoint: D65,\n\t\t\ttransfer: SRGBTransfer,\n\t\t\ttoXYZ: LINEAR_REC709_TO_XYZ,\n\t\t\tfromXYZ: XYZ_TO_LINEAR_REC709,\n\t\t\tluminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n\t\t\toutputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n\t\t},\n\n\t} );\n\n\treturn ColorManagement;\n\n}\n\nconst ColorManagement = /*@__PURE__*/ createColorManagement();\n\nfunction SRGBToLinear( c ) {\n\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n}\n\nfunction LinearToSRGB( c ) {\n\n\treturn ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;\n\n}\n\nlet _canvas;\n\nclass ImageUtils {\n\n\tstatic getDataURL( image ) {\n\n\t\tif ( /^data:/i.test( image.src ) ) {\n\n\t\t\treturn image.src;\n\n\t\t}\n\n\t\tif ( typeof HTMLCanvasElement === 'undefined' ) {\n\n\t\t\treturn image.src;\n\n\t\t}\n\n\t\tlet canvas;\n\n\t\tif ( image instanceof HTMLCanvasElement ) {\n\n\t\t\tcanvas = image;\n\n\t\t} else {\n\n\t\t\tif ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );\n\n\t\t\t_canvas.width = image.width;\n\t\t\t_canvas.height = image.height;\n\n\t\t\tconst context = _canvas.getContext( '2d' );\n\n\t\t\tif ( image instanceof ImageData ) {\n\n\t\t\t\tcontext.putImageData( image, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t}\n\n\t\t\tcanvas = _canvas;\n\n\t\t}\n\n\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );\n\n\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t} else {\n\n\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t}\n\n\t}\n\n\tstatic sRGBToLinear( image ) {\n\n\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t\tconst canvas = createElementNS( 'canvas' );\n\n\t\t\tcanvas.width = image.width;\n\t\t\tcanvas.height = image.height;\n\n\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\tconst imageData = context.getImageData( 0, 0, image.width, image.height );\n\t\t\tconst data = imageData.data;\n\n\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tdata[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;\n\n\t\t\t}\n\n\t\t\tcontext.putImageData( imageData, 0, 0 );\n\n\t\t\treturn canvas;\n\n\t\t} else if ( image.data ) {\n\n\t\t\tconst data = image.data.slice( 0 );\n\n\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tif ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {\n\n\t\t\t\t\tdata[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// assuming float\n\n\t\t\t\t\tdata[ i ] = SRGBToLinear( data[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdata: data,\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );\n\t\t\treturn image;\n\n\t\t}\n\n\t}\n\n}\n\nlet _sourceId = 0;\n\nclass Source {\n\n\tconstructor( data = null ) {\n\n\t\tthis.isSource = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _sourceId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.data = data;\n\t\tthis.dataReady = true;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.images[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\t\t\tuuid: this.uuid,\n\t\t\turl: ''\n\t\t};\n\n\t\tconst data = this.data;\n\n\t\tif ( data !== null ) {\n\n\t\t\tlet url;\n\n\t\t\tif ( Array.isArray( data ) ) {\n\n\t\t\t\t// cube texture\n\n\t\t\t\turl = [];\n\n\t\t\t\tfor ( let i = 0, l = data.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( data[ i ].isDataTexture ) {\n\n\t\t\t\t\t\turl.push( serializeImage( data[ i ].image ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\turl.push( serializeImage( data[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// texture\n\n\t\t\t\turl = serializeImage( data );\n\n\t\t\t}\n\n\t\t\toutput.url = url;\n\n\t\t}\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.images[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nfunction serializeImage( image ) {\n\n\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t// default images\n\n\t\treturn ImageUtils.getDataURL( image );\n\n\t} else {\n\n\t\tif ( image.data ) {\n\n\t\t\t// images of DataTexture\n\n\t\t\treturn {\n\t\t\t\tdata: Array.from( image.data ),\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\ttype: image.data.constructor.name\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Texture: Unable to serialize Texture.' );\n\t\t\treturn {};\n\n\t\t}\n\n\t}\n\n}\n\nlet _textureId = 0;\n\nclass Texture extends EventDispatcher {\n\n\tconstructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {\n\n\t\tsuper();\n\n\t\tthis.isTexture = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _textureId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\n\t\tthis.source = new Source( image );\n\t\tthis.mipmaps = [];\n\n\t\tthis.mapping = mapping;\n\t\tthis.channel = 0;\n\n\t\tthis.wrapS = wrapS;\n\t\tthis.wrapT = wrapT;\n\n\t\tthis.magFilter = magFilter;\n\t\tthis.minFilter = minFilter;\n\n\t\tthis.anisotropy = anisotropy;\n\n\t\tthis.format = format;\n\t\tthis.internalFormat = null;\n\t\tthis.type = type;\n\n\t\tthis.offset = new Vector2( 0, 0 );\n\t\tthis.repeat = new Vector2( 1, 1 );\n\t\tthis.center = new Vector2( 0, 0 );\n\t\tthis.rotation = 0;\n\n\t\tthis.matrixAutoUpdate = true;\n\t\tthis.matrix = new Matrix3();\n\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\t\tthis.colorSpace = colorSpace;\n\n\t\tthis.userData = {};\n\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\n\t\tthis.renderTarget = null; // assign texture to a render target\n\t\tthis.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not\n\t\tthis.pmremVersion = 0; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)\n\n\t}\n\n\tget image() {\n\n\t\treturn this.source.data;\n\n\t}\n\n\tset image( value = null ) {\n\n\t\tthis.source.data = value;\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.source = source.source;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\t\tthis.channel = source.channel;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.internalFormat = source.internalFormat;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\t\tthis.center.copy( source.center );\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrix.copy( source.matrix );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.colorSpace = source.colorSpace;\n\n\t\tthis.renderTarget = source.renderTarget;\n\t\tthis.isRenderTargetTexture = source.isRenderTargetTexture;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tthis.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\timage: this.source.toJSON( meta ).uuid,\n\n\t\t\tmapping: this.mapping,\n\t\t\tchannel: this.channel,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\trotation: this.rotation,\n\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tformat: this.format,\n\t\t\tinternalFormat: this.internalFormat,\n\t\t\ttype: this.type,\n\t\t\tcolorSpace: this.colorSpace,\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy,\n\n\t\t\tflipY: this.flipY,\n\n\t\t\tgenerateMipmaps: this.generateMipmaps,\n\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\tunpackAlignment: this.unpackAlignment\n\n\t\t};\n\n\t\tif ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\ttransformUv( uv ) {\n\n\t\tif ( this.mapping !== UVMapping ) return uv;\n\n\t\tuv.applyMatrix3( this.matrix );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t\treturn uv;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.version ++;\n\t\t\tthis.source.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tset needsPMREMUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.pmremVersion ++;\n\n\t\t}\n\n\t}\n\n}\n\nTexture.DEFAULT_IMAGE = null;\nTexture.DEFAULT_MAPPING = UVMapping;\nTexture.DEFAULT_ANISOTROPY = 1;\n\nclass Vector4 {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tVector4.prototype.isVector4 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.z;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.z = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.w;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.w = value;\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\t\tthis.w = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetW( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\t\tthis.w += v.w * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\t\tthis.w -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\t\tthis.w *= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\tthis.w *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z, w = this.w;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\treturn this;\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\t\tthis.w /= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tsetAxisAngleFromQuaternion( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tconst s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\tthis.x = 1;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t} else {\n\n\t\t\tthis.x = q.x / s;\n\t\t\tthis.y = q.y / s;\n\t\t\tthis.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetAxisAngleFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tlet angle, x, y, z; // variables for result\n\t\tconst epsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tconst xx = ( m11 + 1 ) / 2;\n\t\t\tconst yy = ( m22 + 1 ) / 2;\n\t\t\tconst zz = ( m33 + 1 ) / 2;\n\t\t\tconst xy = ( m12 + m21 ) / 4;\n\t\t\tconst xz = ( m13 + m31 ) / 4;\n\t\t\tconst yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tlet s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixPosition( m ) {\n\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 12 ];\n\t\tthis.y = e[ 13 ];\n\t\tthis.z = e[ 14 ];\n\t\tthis.w = e[ 15 ];\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\t\tthis.w = Math.min( this.w, v.w );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\t\tthis.w = Math.max( this.w, v.w );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = clamp( this.x, min.x, max.x );\n\t\tthis.y = clamp( this.y, min.y, max.y );\n\t\tthis.z = clamp( this.z, min.z, max.z );\n\t\tthis.w = clamp( this.w, min.w, max.w );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = clamp( this.x, minVal, maxVal );\n\t\tthis.y = clamp( this.y, minVal, maxVal );\n\t\tthis.z = clamp( this.z, minVal, maxVal );\n\t\tthis.w = clamp( this.w, minVal, maxVal );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\t\tthis.w = Math.floor( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\t\tthis.w = Math.ceil( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\t\tthis.w = Math.round( this.w );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = Math.trunc( this.x );\n\t\tthis.y = Math.trunc( this.y );\n\t\tthis.z = Math.trunc( this.z );\n\t\tthis.w = Math.trunc( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\t\tthis.w = - this.w;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\t\tthis.w = v1.w + ( v2.w - v1.w ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\t\tthis.w = array[ offset + 3 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\t\tarray[ offset + 3 ] = this.w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\t\tthis.w = attribute.getW( index );\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\t\tthis.w = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\t\tyield this.z;\n\t\tyield this.w;\n\n\t}\n\n}\n\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\nclass RenderTarget extends EventDispatcher {\n\n\tconstructor( width = 1, height = 1, options = {} ) {\n\n\t\tsuper();\n\n\t\tthis.isRenderTarget = true;\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.depth = 1;\n\n\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\t\tthis.scissorTest = false;\n\n\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\n\t\tconst image = { width: width, height: height, depth: 1 };\n\n\t\toptions = Object.assign( {\n\t\t\tgenerateMipmaps: false,\n\t\t\tinternalFormat: null,\n\t\t\tminFilter: LinearFilter,\n\t\t\tdepthBuffer: true,\n\t\t\tstencilBuffer: false,\n\t\t\tresolveDepthBuffer: true,\n\t\t\tresolveStencilBuffer: true,\n\t\t\tdepthTexture: null,\n\t\t\tsamples: 0,\n\t\t\tcount: 1\n\t\t}, options );\n\n\t\tconst texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );\n\n\t\ttexture.flipY = false;\n\t\ttexture.generateMipmaps = options.generateMipmaps;\n\t\ttexture.internalFormat = options.internalFormat;\n\n\t\tthis.textures = [];\n\n\t\tconst count = options.count;\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.textures[ i ] = texture.clone();\n\t\t\tthis.textures[ i ].isRenderTargetTexture = true;\n\t\t\tthis.textures[ i ].renderTarget = this;\n\n\t\t}\n\n\t\tthis.depthBuffer = options.depthBuffer;\n\t\tthis.stencilBuffer = options.stencilBuffer;\n\n\t\tthis.resolveDepthBuffer = options.resolveDepthBuffer;\n\t\tthis.resolveStencilBuffer = options.resolveStencilBuffer;\n\n\t\tthis._depthTexture = null;\n\t\tthis.depthTexture = options.depthTexture;\n\n\t\tthis.samples = options.samples;\n\n\t}\n\n\tget texture() {\n\n\t\treturn this.textures[ 0 ];\n\n\t}\n\n\tset texture( value ) {\n\n\t\tthis.textures[ 0 ] = value;\n\n\t}\n\n\tset depthTexture( current ) {\n\n\t\tif ( this._depthTexture !== null ) this._depthTexture.renderTarget = null;\n\t\tif ( current !== null ) current.renderTarget = this;\n\n\t\tthis._depthTexture = current;\n\n\t}\n\n\tget depthTexture() {\n\n\t\treturn this._depthTexture;\n\n\t}\n\n\tsetSize( width, height, depth = 1 ) {\n\n\t\tif ( this.width !== width || this.height !== height || this.depth !== depth ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.depth = depth;\n\n\t\t\tfor ( let i = 0, il = this.textures.length; i < il; i ++ ) {\n\n\t\t\t\tthis.textures[ i ].image.width = width;\n\t\t\t\tthis.textures[ i ].image.height = height;\n\t\t\t\tthis.textures[ i ].image.depth = depth;\n\n\t\t\t}\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\t\tthis.depth = source.depth;\n\n\t\tthis.scissor.copy( source.scissor );\n\t\tthis.scissorTest = source.scissorTest;\n\n\t\tthis.viewport.copy( source.viewport );\n\n\t\tthis.textures.length = 0;\n\n\t\tfor ( let i = 0, il = source.textures.length; i < il; i ++ ) {\n\n\t\t\tthis.textures[ i ] = source.textures[ i ].clone();\n\t\t\tthis.textures[ i ].isRenderTargetTexture = true;\n\t\t\tthis.textures[ i ].renderTarget = this;\n\n\t\t}\n\n\t\t// ensure image object is not shared, see #20328\n\n\t\tconst image = Object.assign( {}, source.texture.image );\n\t\tthis.texture.source = new Source( image );\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\n\t\tthis.resolveDepthBuffer = source.resolveDepthBuffer;\n\t\tthis.resolveStencilBuffer = source.resolveStencilBuffer;\n\n\t\tif ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();\n\n\t\tthis.samples = source.samples;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nclass WebGLRenderTarget extends RenderTarget {\n\n\tconstructor( width = 1, height = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.isWebGLRenderTarget = true;\n\n\t}\n\n}\n\nclass DataArrayTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, depth = 1 ) {\n\n\t\tsuper( null );\n\n\t\tthis.isDataArrayTexture = true;\n\n\t\tthis.image = { data, width, height, depth };\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t\tthis.layerUpdates = new Set();\n\n\t}\n\n\taddLayerUpdate( layerIndex ) {\n\n\t\tthis.layerUpdates.add( layerIndex );\n\n\t}\n\n\tclearLayerUpdates() {\n\n\t\tthis.layerUpdates.clear();\n\n\t}\n\n}\n\nclass WebGLArrayRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( width = 1, height = 1, depth = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.isWebGLArrayRenderTarget = true;\n\n\t\tthis.depth = depth;\n\n\t\tthis.texture = new DataArrayTexture( null, width, height, depth );\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t}\n\n}\n\nclass Data3DTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, depth = 1 ) {\n\n\t\t// We're going to add .setXXX() methods for setting properties later.\n\t\t// Users can still set in Data3DTexture directly.\n\t\t//\n\t\t//\tconst texture = new THREE.Data3DTexture( data, width, height, depth );\n\t\t// \ttexture.anisotropy = 16;\n\t\t//\n\t\t// See #14839\n\n\t\tsuper( null );\n\n\t\tthis.isData3DTexture = true;\n\n\t\tthis.image = { data, width, height, depth };\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n}\n\nclass WebGL3DRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( width = 1, height = 1, depth = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.isWebGL3DRenderTarget = true;\n\n\t\tthis.depth = depth;\n\n\t\tthis.texture = new Data3DTexture( null, width, height, depth );\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t}\n\n}\n\nclass Quaternion {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tthis.isQuaternion = true;\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t}\n\n\tstatic slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tlet x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( t === 0 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( t === 1 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x1;\n\t\t\tdst[ dstOffset + 1 ] = y1;\n\t\t\tdst[ dstOffset + 2 ] = z1;\n\t\t\tdst[ dstOffset + 3 ] = w1;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tlet s = 1 - t;\n\t\t\tconst cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tconst sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tconst tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tconst f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n\tstatic multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {\n\n\t\tconst x0 = src0[ srcOffset0 ];\n\t\tconst y0 = src0[ srcOffset0 + 1 ];\n\t\tconst z0 = src0[ srcOffset0 + 2 ];\n\t\tconst w0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 ];\n\t\tconst y1 = src1[ srcOffset1 + 1 ];\n\t\tconst z1 = src1[ srcOffset1 + 2 ];\n\t\tconst w1 = src1[ srcOffset1 + 3 ];\n\n\t\tdst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n\t\tdst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n\t\tdst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n\t\tdst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n\n\t\treturn dst;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget w() {\n\n\t\treturn this._w;\n\n\t}\n\n\tset w( value ) {\n\n\t\tthis._w = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t}\n\n\tcopy( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromEuler( euler, update = true ) {\n\n\t\tconst x = euler._x, y = euler._y, z = euler._z, order = euler._order;\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tconst cos = Math.cos;\n\t\tconst sin = Math.sin;\n\n\t\tconst c1 = cos( x / 2 );\n\t\tconst c2 = cos( y / 2 );\n\t\tconst c3 = cos( z / 2 );\n\n\t\tconst s1 = sin( x / 2 );\n\t\tconst s2 = sin( y / 2 );\n\t\tconst s3 = sin( z / 2 );\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tif ( update === true ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromAxisAngle( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tconst halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\tconst s = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromUnitVectors( vFrom, vTo ) {\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tlet r = vFrom.dot( vTo ) + 1;\n\n\t\tif ( r < Number.EPSILON ) {\n\n\t\t\t// vFrom and vTo point in opposite directions\n\n\t\t\tr = 0;\n\n\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\tthis._x = - vFrom.y;\n\t\t\t\tthis._y = vFrom.x;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = r;\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = - vFrom.z;\n\t\t\t\tthis._z = vFrom.y;\n\t\t\t\tthis._w = r;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n\t\t\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n\t\t\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n\t\t\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n\t\t\tthis._w = r;\n\n\t\t}\n\n\t\treturn this.normalize();\n\n\t}\n\n\tangleTo( q ) {\n\n\t\treturn 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );\n\n\t}\n\n\trotateTowards( q, step ) {\n\n\t\tconst angle = this.angleTo( q );\n\n\t\tif ( angle === 0 ) return this;\n\n\t\tconst t = Math.min( 1, step / angle );\n\n\t\tthis.slerp( q, t );\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\treturn this.set( 0, 0, 0, 1 );\n\n\t}\n\n\tinvert() {\n\n\t\t// quaternion is assumed to have unit length\n\n\t\treturn this.conjugate();\n\n\t}\n\n\tconjugate() {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t}\n\n\tnormalize() {\n\n\t\tlet l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t}\n\n\tpremultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t}\n\n\tmultiplyQuaternions( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tconst qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tconst qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerp( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tconst x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tlet cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\n\n\t\t\tconst s = 1 - t;\n\t\t\tthis._w = s * w + t * this._w;\n\t\t\tthis._x = s * x + t * this._x;\n\t\t\tthis._y = s * y + t * this._y;\n\t\t\tthis._z = s * z + t * this._z;\n\n\t\t\tthis.normalize(); // normalize calls _onChangeCallback()\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\n\t\tconst halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tconst ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerpQuaternions( qa, qb, t ) {\n\n\t\treturn this.copy( qa ).slerp( qb, t );\n\n\t}\n\n\trandom() {\n\n\t\t// sets this quaternion to a uniform random unit quaternnion\n\n\t\t// Ken Shoemake\n\t\t// Uniform random rotations\n\t\t// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.\n\n\t\tconst theta1 = 2 * Math.PI * Math.random();\n\t\tconst theta2 = 2 * Math.PI * Math.random();\n\n\t\tconst x0 = Math.random();\n\t\tconst r1 = Math.sqrt( 1 - x0 );\n\t\tconst r2 = Math.sqrt( x0 );\n\n\t\treturn this.set(\n\t\t\tr1 * Math.sin( theta1 ),\n\t\t\tr1 * Math.cos( theta1 ),\n\t\t\tr2 * Math.sin( theta2 ),\n\t\t\tr2 * Math.cos( theta2 ),\n\t\t);\n\n\t}\n\n\tequals( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis._x = attribute.getX( index );\n\t\tthis._y = attribute.getY( index );\n\t\tthis._z = attribute.getZ( index );\n\t\tthis._w = attribute.getW( index );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.toArray();\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this._x;\n\t\tyield this._y;\n\t\tyield this._z;\n\t\tyield this._w;\n\n\t}\n\n}\n\nclass Vector3 {\n\n\tconstructor( x = 0, y = 0, z = 0 ) {\n\n\t\tVector3.prototype.isVector3 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t}\n\n\tset( x, y, z ) {\n\n\t\tif ( z === undefined ) z = this.z; // sprite.scale.set(x,y)\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyVectors( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyEuler( euler ) {\n\n\t\treturn this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );\n\n\t}\n\n\tapplyAxisAngle( axis, angle ) {\n\n\t\treturn this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\treturn this.applyMatrix3( m ).normalize();\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tconst w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\t// quaternion q is assumed to have unit length\n\n\t\tconst vx = this.x, vy = this.y, vz = this.z;\n\t\tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// t = 2 * cross( q.xyz, v );\n\t\tconst tx = 2 * ( qy * vz - qz * vy );\n\t\tconst ty = 2 * ( qz * vx - qx * vz );\n\t\tconst tz = 2 * ( qx * vy - qy * vx );\n\n\t\t// v + q.w * t + cross( q.xyz, t );\n\t\tthis.x = vx + qw * tx + qy * tz - qz * ty;\n\t\tthis.y = vy + qw * ty + qz * tx - qx * tz;\n\t\tthis.z = vz + qw * tz + qx * ty - qy * tx;\n\n\t\treturn this;\n\n\t}\n\n\tproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\n\n\t}\n\n\tunproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = clamp( this.x, min.x, max.x );\n\t\tthis.y = clamp( this.y, min.y, max.y );\n\t\tthis.z = clamp( this.z, min.z, max.z );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = clamp( this.x, minVal, maxVal );\n\t\tthis.y = clamp( this.y, minVal, maxVal );\n\t\tthis.z = clamp( this.z, minVal, maxVal );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = Math.trunc( this.x );\n\t\tthis.y = Math.trunc( this.y );\n\t\tthis.z = Math.trunc( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t}\n\n\t// TODO lengthSquared?\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tcross( v ) {\n\n\t\treturn this.crossVectors( this, v );\n\n\t}\n\n\tcrossVectors( a, b ) {\n\n\t\tconst ax = a.x, ay = a.y, az = a.z;\n\t\tconst bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t}\n\n\tprojectOnVector( v ) {\n\n\t\tconst denominator = v.lengthSq();\n\n\t\tif ( denominator === 0 ) return this.set( 0, 0, 0 );\n\n\t\tconst scalar = v.dot( this ) / denominator;\n\n\t\treturn this.copy( v ).multiplyScalar( scalar );\n\n\t}\n\n\tprojectOnPlane( planeNormal ) {\n\n\t\t_vector$c.copy( this ).projectOnVector( planeNormal );\n\n\t\treturn this.sub( _vector$c );\n\n\t}\n\n\treflect( normal ) {\n\n\t\t// reflect incident vector off plane orthogonal to normal\n\t\t// normal is assumed to have unit length\n\n\t\treturn this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t}\n\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( clamp( theta, - 1, 1 ) );\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t}\n\n\tsetFromSpherical( s ) {\n\n\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\n\n\t}\n\n\tsetFromSphericalCoords( radius, phi, theta ) {\n\n\t\tconst sinPhiRadius = Math.sin( phi ) * radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( theta );\n\t\tthis.y = Math.cos( phi ) * radius;\n\t\tthis.z = sinPhiRadius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCylindrical( c ) {\n\n\t\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\n\n\t}\n\n\tsetFromCylindricalCoords( radius, theta, y ) {\n\n\t\tthis.x = radius * Math.sin( theta );\n\t\tthis.y = y;\n\t\tthis.z = radius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixPosition( m ) {\n\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 12 ];\n\t\tthis.y = e[ 13 ];\n\t\tthis.z = e[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixScale( m ) {\n\n\t\tconst sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tconst sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tconst sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixColumn( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t}\n\n\tsetFromMatrix3Column( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 3 );\n\n\t}\n\n\tsetFromEuler( e ) {\n\n\t\tthis.x = e._x;\n\t\tthis.y = e._y;\n\t\tthis.z = e._z;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromColor( c ) {\n\n\t\tthis.x = c.r;\n\t\tthis.y = c.g;\n\t\tthis.z = c.b;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\trandomDirection() {\n\n\t\t// https://mathworld.wolfram.com/SpherePointPicking.html\n\n\t\tconst theta = Math.random() * Math.PI * 2;\n\t\tconst u = Math.random() * 2 - 1;\n\t\tconst c = Math.sqrt( 1 - u * u );\n\n\t\tthis.x = c * Math.cos( theta );\n\t\tthis.y = u;\n\t\tthis.z = c * Math.sin( theta );\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\t\tyield this.z;\n\n\t}\n\n}\n\nconst _vector$c = /*@__PURE__*/ new Vector3();\nconst _quaternion$4 = /*@__PURE__*/ new Quaternion();\n\nclass Box3 {\n\n\tconstructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {\n\n\t\tthis.isBox3 = true;\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromArray( array ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\tthis.expandByPoint( _vector$b.fromArray( array, i ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromBufferAttribute( attribute ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( _vector$b.fromBufferAttribute( attribute, i ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );\n\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromObject( object, precise = false ) {\n\n\t\tthis.makeEmpty();\n\n\t\treturn this.expandByObject( object, precise );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\texpandByObject( object, precise = false ) {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tobject.updateWorldMatrix( false, false );\n\n\t\tconst geometry = object.geometry;\n\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\t// precise AABB computation based on vertex data requires at least a position attribute.\n\t\t\t// instancing isn't supported so far and uses the normal (conservative) code path.\n\n\t\t\tif ( precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true ) {\n\n\t\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t\tif ( object.isMesh === true ) {\n\n\t\t\t\t\t\tobject.getVertexPosition( i, _vector$b );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_vector$b.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_vector$b.applyMatrix4( object.matrixWorld );\n\t\t\t\t\tthis.expandByPoint( _vector$b );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( object.boundingBox !== undefined ) {\n\n\t\t\t\t\t// object-level bounding box\n\n\t\t\t\t\tif ( object.boundingBox === null ) {\n\n\t\t\t\t\t\tobject.computeBoundingBox();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_box$4.copy( object.boundingBox );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// geometry-level bounding box\n\n\t\t\t\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\t\t\t\tgeometry.computeBoundingBox();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_box$4.copy( geometry.boundingBox );\n\n\t\t\t\t}\n\n\t\t\t\t_box$4.applyMatrix4( object.matrixWorld );\n\n\t\t\t\tthis.union( _box$4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis.expandByObject( children[ i ], precise );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn point.x >= this.min.x && point.x <= this.max.x &&\n\t\t\tpoint.y >= this.min.y && point.y <= this.max.y &&\n\t\t\tpoint.z >= this.min.z && point.z <= this.max.z;\n\n\t}\n\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\n\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\n\n\t}\n\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\t\treturn box.max.x >= this.min.x && box.min.x <= this.max.x &&\n\t\t\tbox.max.y >= this.min.y && box.min.y <= this.max.y &&\n\t\t\tbox.max.z >= this.min.z && box.min.z <= this.max.z;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\t// Find the point on the AABB closest to the sphere center.\n\t\tthis.clampPoint( sphere.center, _vector$b );\n\n\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\treturn _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tlet min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= - plane.constant && max >= - plane.constant );\n\n\t}\n\n\tintersectsTriangle( triangle ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// compute box center and extents\n\t\tthis.getCenter( _center );\n\t\t_extents.subVectors( this.max, _center );\n\n\t\t// translate triangle to aabb origin\n\t\t_v0$2.subVectors( triangle.a, _center );\n\t\t_v1$7.subVectors( triangle.b, _center );\n\t\t_v2$4.subVectors( triangle.c, _center );\n\n\t\t// compute edge vectors for triangle\n\t\t_f0.subVectors( _v1$7, _v0$2 );\n\t\t_f1.subVectors( _v2$4, _v1$7 );\n\t\t_f2.subVectors( _v0$2, _v2$4 );\n\n\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\t\tlet axes = [\n\t\t\t0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,\n\t\t\t_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,\n\t\t\t- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0\n\t\t];\n\t\tif ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// test 3 face normals from the aabb\n\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\n\t\tif ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// finally testing the face normal of the triangle\n\t\t// use already existing triangle edge vectors here\n\t\t_triangleNormal.crossVectors( _f0, _f1 );\n\t\taxes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];\n\n\t\treturn satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents );\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _vector$b ).distanceTo( point );\n\n\t}\n\n\tgetBoundingSphere( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\ttarget.makeEmpty();\n\n\t\t} else {\n\n\t\t\tthis.getCenter( target.center );\n\n\t\t\ttarget.radius = this.getSize( _vector$b ).length() * 0.5;\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t}\n\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\t// transform of empty box is an empty box.\n\t\tif ( this.isEmpty() ) return this;\n\n\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\n\n\t\tthis.setFromPoints( _points );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n}\n\nconst _points = [\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3()\n];\n\nconst _vector$b = /*@__PURE__*/ new Vector3();\n\nconst _box$4 = /*@__PURE__*/ new Box3();\n\n// triangle centered vertices\n\nconst _v0$2 = /*@__PURE__*/ new Vector3();\nconst _v1$7 = /*@__PURE__*/ new Vector3();\nconst _v2$4 = /*@__PURE__*/ new Vector3();\n\n// triangle edge vectors\n\nconst _f0 = /*@__PURE__*/ new Vector3();\nconst _f1 = /*@__PURE__*/ new Vector3();\nconst _f2 = /*@__PURE__*/ new Vector3();\n\nconst _center = /*@__PURE__*/ new Vector3();\nconst _extents = /*@__PURE__*/ new Vector3();\nconst _triangleNormal = /*@__PURE__*/ new Vector3();\nconst _testAxis = /*@__PURE__*/ new Vector3();\n\nfunction satForAxes( axes, v0, v1, v2, extents ) {\n\n\tfor ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {\n\n\t\t_testAxis.fromArray( axes, i );\n\t\t// project the aabb onto the separating axis\n\t\tconst r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );\n\t\t// project all 3 vertices of the triangle onto the separating axis\n\t\tconst p0 = v0.dot( _testAxis );\n\t\tconst p1 = v1.dot( _testAxis );\n\t\tconst p2 = v2.dot( _testAxis );\n\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\n\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t// the axis is separating and we can exit\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nconst _box$3 = /*@__PURE__*/ new Box3();\nconst _v1$6 = /*@__PURE__*/ new Vector3();\nconst _v2$3 = /*@__PURE__*/ new Vector3();\n\nclass Sphere {\n\n\tconstructor( center = new Vector3(), radius = - 1 ) {\n\n\t\tthis.isSphere = true;\n\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\n\t}\n\n\tset( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points, optionalCenter ) {\n\n\t\tconst center = this.center;\n\n\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\tcenter.copy( optionalCenter );\n\n\t\t} else {\n\n\t\t\t_box$3.setFromPoints( points ).getCenter( center );\n\n\t\t}\n\n\t\tlet maxRadiusSq = 0;\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t}\n\n\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\treturn ( this.radius < 0 );\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.center.set( 0, 0, 0 );\n\t\tthis.radius = - 1;\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\tconst deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\ttarget.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\ttarget.sub( this.center ).normalize();\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\t// Empty sphere produces empty bounding box\n\t\t\ttarget.makeEmpty();\n\t\t\treturn target;\n\n\t\t}\n\n\t\ttarget.set( this.center, this.center );\n\t\ttarget.expandByScalar( this.radius );\n\n\t\treturn target;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\tthis.center.copy( point );\n\n\t\t\tthis.radius = 0;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t_v1$6.subVectors( point, this.center );\n\n\t\tconst lengthSq = _v1$6.lengthSq();\n\n\t\tif ( lengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\t// calculate the minimal sphere\n\n\t\t\tconst length = Math.sqrt( lengthSq );\n\n\t\t\tconst delta = ( length - this.radius ) * 0.5;\n\n\t\t\tthis.center.addScaledVector( _v1$6, delta / length );\n\n\t\t\tthis.radius += delta;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunion( sphere ) {\n\n\t\tif ( sphere.isEmpty() ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\tthis.copy( sphere );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( this.center.equals( sphere.center ) === true ) {\n\n\t\t\t this.radius = Math.max( this.radius, sphere.radius );\n\n\t\t} else {\n\n\t\t\t_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );\n\n\t\t\tthis.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );\n\n\t\t\tthis.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tequals( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$a = /*@__PURE__*/ new Vector3();\nconst _segCenter = /*@__PURE__*/ new Vector3();\nconst _segDir = /*@__PURE__*/ new Vector3();\nconst _diff = /*@__PURE__*/ new Vector3();\n\nconst _edge1 = /*@__PURE__*/ new Vector3();\nconst _edge2 = /*@__PURE__*/ new Vector3();\nconst _normal$1 = /*@__PURE__*/ new Vector3();\n\nclass Ray {\n\n\tconstructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {\n\n\t\tthis.origin = origin;\n\t\tthis.direction = direction;\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t}\n\n\tat( t, target ) {\n\n\t\treturn target.copy( this.origin ).addScaledVector( this.direction, t );\n\n\t}\n\n\tlookAt( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t}\n\n\trecast( t ) {\n\n\t\tthis.origin.copy( this.at( t, _vector$a ) );\n\n\t\treturn this;\n\n\t}\n\n\tclosestPointToPoint( point, target ) {\n\n\t\ttarget.subVectors( point, this.origin );\n\n\t\tconst directionDistance = target.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn target.copy( this.origin );\n\n\t\t}\n\n\t\treturn target.copy( this.origin ).addScaledVector( this.direction, directionDistance );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t}\n\n\tdistanceSqToPoint( point ) {\n\n\t\tconst directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t// point behind the ray\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t}\n\n\t\t_vector$a.copy( this.origin ).addScaledVector( this.direction, directionDistance );\n\n\t\treturn _vector$a.distanceToSquared( point );\n\n\t}\n\n\tdistanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t// It returns the min distance between the ray and the segment\n\t\t// defined by v0 and v1\n\t\t// It can also set two optional targets :\n\t\t// - The closest point on the ray\n\t\t// - The closest point on the segment\n\n\t\t_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t_segDir.copy( v1 ).sub( v0 ).normalize();\n\t\t_diff.copy( this.origin ).sub( _segCenter );\n\n\t\tconst segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\tconst a01 = - this.direction.dot( _segDir );\n\t\tconst b0 = _diff.dot( this.direction );\n\t\tconst b1 = - _diff.dot( _segDir );\n\t\tconst c = _diff.lengthSq();\n\t\tconst det = Math.abs( 1 - a01 * a01 );\n\t\tlet s0, s1, sqrDist, extDet;\n\n\t\tif ( det > 0 ) {\n\n\t\t\t// The ray and segment are not parallel.\n\n\t\t\ts0 = a01 * b1 - b0;\n\t\t\ts1 = a01 * b0 - b1;\n\t\t\textDet = segExtent * det;\n\n\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\tconst invDet = 1 / det;\n\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 5\n\n\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t// region 4\n\n\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t// region 3\n\n\t\t\t\t\ts0 = 0;\n\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 2\n\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Ray and segment are parallel.\n\n\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t}\n\n\t\tif ( optionalPointOnRay ) {\n\n\t\t\toptionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );\n\n\t\t}\n\n\t\tif ( optionalPointOnSegment ) {\n\n\t\t\toptionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );\n\n\t\t}\n\n\t\treturn sqrDist;\n\n\t}\n\n\tintersectSphere( sphere, target ) {\n\n\t\t_vector$a.subVectors( sphere.center, this.origin );\n\t\tconst tca = _vector$a.dot( this.direction );\n\t\tconst d2 = _vector$a.dot( _vector$a ) - tca * tca;\n\t\tconst radius2 = sphere.radius * sphere.radius;\n\n\t\tif ( d2 > radius2 ) return null;\n\n\t\tconst thc = Math.sqrt( radius2 - d2 );\n\n\t\t// t0 = first intersect point - entrance on front of sphere\n\t\tconst t0 = tca - thc;\n\n\t\t// t1 = second intersect point - exit point on back of sphere\n\t\tconst t1 = tca + thc;\n\n\t\t// test to see if t1 is behind the ray - if so, return null\n\t\tif ( t1 < 0 ) return null;\n\n\t\t// test to see if t0 is behind the ray:\n\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t// in order to always return an intersect point that is in front of the ray.\n\t\tif ( t0 < 0 ) return this.at( t1, target );\n\n\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\treturn this.at( t0, target );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tdistanceToPlane( plane ) {\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t : null;\n\n\t}\n\n\tintersectPlane( plane, target ) {\n\n\t\tconst t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, target );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tconst distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t}\n\n\tintersectBox( box, target ) {\n\n\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tconst invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tconst origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\t\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn this.intersectBox( box, _vector$a ) !== null;\n\n\t}\n\n\tintersectTriangle( a, b, c, backfaceCulling, target ) {\n\n\t\t// Compute the offset origin, edges, and normal.\n\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t_edge1.subVectors( b, a );\n\t\t_edge2.subVectors( c, a );\n\t\t_normal$1.crossVectors( _edge1, _edge2 );\n\n\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\tlet DdN = this.direction.dot( _normal$1 );\n\t\tlet sign;\n\n\t\tif ( DdN > 0 ) {\n\n\t\t\tif ( backfaceCulling ) return null;\n\t\t\tsign = 1;\n\n\t\t} else if ( DdN < 0 ) {\n\n\t\t\tsign = - 1;\n\t\t\tDdN = - DdN;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t_diff.subVectors( this.origin, a );\n\t\tconst DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );\n\n\t\t// b1 < 0, no intersection\n\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );\n\n\t\t// b2 < 0, no intersection\n\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// b1+b2 > 1, no intersection\n\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Line intersects triangle, check if ray does.\n\t\tconst QdN = - sign * _diff.dot( _normal$1 );\n\n\t\t// t < 0, no intersection\n\t\tif ( QdN < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Ray intersects triangle.\n\t\treturn this.at( QdN / DdN, target );\n\n\t}\n\n\tapplyMatrix4( matrix4 ) {\n\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.transformDirection( matrix4 );\n\n\t\treturn this;\n\n\t}\n\n\tequals( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass Matrix4 {\n\n\tconstructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tMatrix4.prototype.isMatrix4 = true;\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Matrix4().fromArray( this.elements );\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\n\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\n\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\n\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\n\n\t\treturn this;\n\n\t}\n\n\tcopyPosition( m ) {\n\n\t\tconst te = this.elements, me = m.elements;\n\n\t\tte[ 12 ] = me[ 12 ];\n\t\tte[ 13 ] = me[ 13 ];\n\t\tte[ 14 ] = me[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix3( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ], 0,\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ], 0,\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ], 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tmakeBasis( xAxis, yAxis, zAxis ) {\n\n\t\tthis.set(\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\textractRotation( m ) {\n\n\t\t// this method does not support reflection matrices\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tconst scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();\n\t\tconst scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();\n\t\tconst scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();\n\n\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationFromEuler( euler ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = euler.x, y = euler.y, z = euler.z;\n\t\tconst a = Math.cos( x ), b = Math.sin( x );\n\t\tconst c = Math.cos( y ), d = Math.sin( y );\n\t\tconst e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - c * f;\n\t\t\tte[ 8 ] = d;\n\n\t\t\tte[ 1 ] = af + be * d;\n\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\tte[ 9 ] = - b * c;\n\n\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\tte[ 6 ] = be + af * d;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce + df * b;\n\t\t\tte[ 4 ] = de * b - cf;\n\t\t\tte[ 8 ] = a * d;\n\n\t\t\tte[ 1 ] = a * f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b;\n\n\t\t\tte[ 2 ] = cf * b - de;\n\t\t\tte[ 6 ] = df + ce * b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce - df * b;\n\t\t\tte[ 4 ] = - a * f;\n\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\tte[ 1 ] = cf + de * b;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\tte[ 2 ] = - a * d;\n\t\t\tte[ 6 ] = b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = be * d - af;\n\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\tte[ 1 ] = c * f;\n\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\tte[ 2 ] = - d;\n\t\t\tte[ 6 ] = b * c;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\tte[ 1 ] = f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b * e;\n\n\t\t\tte[ 2 ] = - d * e;\n\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - f;\n\t\t\tte[ 8 ] = d * e;\n\n\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\tte[ 6 ] = b * e;\n\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t}\n\n\t\t// bottom row\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// last column\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationFromQuaternion( q ) {\n\n\t\treturn this.compose( _zero, q, _one );\n\n\t}\n\n\tlookAt( eye, target, up ) {\n\n\t\tconst te = this.elements;\n\n\t\t_z.subVectors( eye, target );\n\n\t\tif ( _z.lengthSq() === 0 ) {\n\n\t\t\t// eye and target are in the same position\n\n\t\t\t_z.z = 1;\n\n\t\t}\n\n\t\t_z.normalize();\n\t\t_x.crossVectors( up, _z );\n\n\t\tif ( _x.lengthSq() === 0 ) {\n\n\t\t\t// up and z are parallel\n\n\t\t\tif ( Math.abs( up.z ) === 1 ) {\n\n\t\t\t\t_z.x += 0.0001;\n\n\t\t\t} else {\n\n\t\t\t\t_z.z += 0.0001;\n\n\t\t\t}\n\n\t\t\t_z.normalize();\n\t\t\t_x.crossVectors( up, _z );\n\n\t\t}\n\n\t\t_x.normalize();\n\t\t_y.crossVectors( _z, _x );\n\n\t\tte[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;\n\t\tte[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;\n\t\tte[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\tconst a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\tconst b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\tconst n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\tconst n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\tconst n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t - n13 * n24 * n32\n\t\t\t\t - n14 * n22 * n33\n\t\t\t\t + n12 * n24 * n33\n\t\t\t\t + n13 * n22 * n34\n\t\t\t\t - n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t - n11 * n24 * n33\n\t\t\t\t + n14 * n21 * n33\n\t\t\t\t - n13 * n21 * n34\n\t\t\t\t + n13 * n24 * n31\n\t\t\t\t - n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t - n11 * n22 * n34\n\t\t\t\t - n14 * n21 * n32\n\t\t\t\t + n12 * n21 * n34\n\t\t\t\t + n14 * n22 * n31\n\t\t\t\t - n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t- n13 * n22 * n31\n\t\t\t\t - n11 * n23 * n32\n\t\t\t\t + n11 * n22 * n33\n\t\t\t\t + n13 * n21 * n32\n\t\t\t\t - n12 * n21 * n33\n\t\t\t\t + n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t}\n\n\ttranspose() {\n\n\t\tconst te = this.elements;\n\t\tlet tmp;\n\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tsetPosition( x, y, z ) {\n\n\t\tconst te = this.elements;\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\tte[ 12 ] = x.x;\n\t\t\tte[ 13 ] = x.y;\n\t\t\tte[ 14 ] = x.z;\n\n\t\t} else {\n\n\t\t\tte[ 12 ] = x;\n\t\t\tte[ 13 ] = y;\n\t\t\tte[ 14 ] = z;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tinvert() {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],\n\t\t\tn12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],\n\t\t\tn13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],\n\t\t\tn14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\tte[ 4 ] = t12 * detInv;\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\tte[ 8 ] = t13 * detInv;\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\tte[ 12 ] = t14 * detInv;\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\tscale( v ) {\n\n\t\tconst te = this.elements;\n\t\tconst x = v.x, y = v.y, z = v.z;\n\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\treturn this;\n\n\t}\n\n\tgetMaxScaleOnAxis() {\n\n\t\tconst te = this.elements;\n\n\t\tconst scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\tconst scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\tconst scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t}\n\n\tmakeTranslation( x, y, z ) {\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x.x,\n\t\t\t\t0, 1, 0, x.y,\n\t\t\t\t0, 0, 1, x.z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x,\n\t\t\t\t0, 1, 0, y,\n\t\t\t\t0, 0, 1, z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationX( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, c, - s, 0,\n\t\t\t0, s, c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationY( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t- s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationZ( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0, 0,\n\t\t\ts, c, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationAxis( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tconst c = Math.cos( angle );\n\t\tconst s = Math.sin( angle );\n\t\tconst t = 1 - c;\n\t\tconst x = axis.x, y = axis.y, z = axis.z;\n\t\tconst tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeScale( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeShear( xy, xz, yx, yz, zx, zy ) {\n\n\t\tthis.set(\n\n\t\t\t1, yx, zx, 0,\n\t\t\txy, 1, zy, 0,\n\t\t\txz, yz, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n\t\tconst x2 = x + x,\ty2 = y + y, z2 = z + z;\n\t\tconst xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tconst yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tconst wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tconst sx = scale.x, sy = scale.y, sz = scale.z;\n\n\t\tte[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\n\t\tte[ 1 ] = ( xy + wz ) * sx;\n\t\tte[ 2 ] = ( xz - wy ) * sx;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = ( xy - wz ) * sy;\n\t\tte[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\n\t\tte[ 6 ] = ( yz + wx ) * sy;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = ( xz + wy ) * sz;\n\t\tte[ 9 ] = ( yz - wx ) * sz;\n\t\tte[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = position.x;\n\t\tte[ 13 ] = position.y;\n\t\tte[ 14 ] = position.z;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tdecompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tlet sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\tconst sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\tconst sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t// if determine is negative, we need to invert one scale\n\t\tconst det = this.determinant();\n\t\tif ( det < 0 ) sx = - sx;\n\n\t\tposition.x = te[ 12 ];\n\t\tposition.y = te[ 13 ];\n\t\tposition.z = te[ 14 ];\n\n\t\t// scale the rotation part\n\t\t_m1$2.copy( this );\n\n\t\tconst invSX = 1 / sx;\n\t\tconst invSY = 1 / sy;\n\t\tconst invSZ = 1 / sz;\n\n\t\t_m1$2.elements[ 0 ] *= invSX;\n\t\t_m1$2.elements[ 1 ] *= invSX;\n\t\t_m1$2.elements[ 2 ] *= invSX;\n\n\t\t_m1$2.elements[ 4 ] *= invSY;\n\t\t_m1$2.elements[ 5 ] *= invSY;\n\t\t_m1$2.elements[ 6 ] *= invSY;\n\n\t\t_m1$2.elements[ 8 ] *= invSZ;\n\t\t_m1$2.elements[ 9 ] *= invSZ;\n\t\t_m1$2.elements[ 10 ] *= invSZ;\n\n\t\tquaternion.setFromRotationMatrix( _m1$2 );\n\n\t\tscale.x = sx;\n\t\tscale.y = sy;\n\t\tscale.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tmakePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\tconst te = this.elements;\n\t\tconst x = 2 * near / ( right - left );\n\t\tconst y = 2 * near / ( top - bottom );\n\n\t\tconst a = ( right + left ) / ( right - left );\n\t\tconst b = ( top + bottom ) / ( top - bottom );\n\n\t\tlet c, d;\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tc = - ( far + near ) / ( far - near );\n\t\t\td = ( - 2 * far * near ) / ( far - near );\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tc = - far / ( far - near );\n\t\t\td = ( - far * near ) / ( far - near );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a; \tte[ 12 ] = 0;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b; \tte[ 13 ] = 0;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c; \tte[ 14 ] = d;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\treturn this;\n\n\t}\n\n\tmakeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\tconst te = this.elements;\n\t\tconst w = 1.0 / ( right - left );\n\t\tconst h = 1.0 / ( top - bottom );\n\t\tconst p = 1.0 / ( far - near );\n\n\t\tconst x = ( right + left ) * w;\n\t\tconst y = ( top + bottom ) * h;\n\n\t\tlet z, zInv;\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tz = ( far + near ) * p;\n\t\t\tzInv = - 2 * p;\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tz = near * p;\n\t\t\tzInv = - 1 * p;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\t\tte[ 8 ] = 0; \t\tte[ 12 ] = - x;\n\t\tte[ 1 ] = 0; \t\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0; \t\tte[ 13 ] = - y;\n\t\tte[ 2 ] = 0; \t\tte[ 6 ] = 0;\t\tte[ 10 ] = zInv;\tte[ 14 ] = - z;\n\t\tte[ 3 ] = 0; \t\tte[ 7 ] = 0;\t\tte[ 11 ] = 0;\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\t\tarray[ offset + 9 ] = te[ 9 ];\n\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\treturn array;\n\n\t}\n\n}\n\nconst _v1$5 = /*@__PURE__*/ new Vector3();\nconst _m1$2 = /*@__PURE__*/ new Matrix4();\nconst _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );\nconst _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );\nconst _x = /*@__PURE__*/ new Vector3();\nconst _y = /*@__PURE__*/ new Vector3();\nconst _z = /*@__PURE__*/ new Vector3();\n\nconst _matrix$2 = /*@__PURE__*/ new Matrix4();\nconst _quaternion$3 = /*@__PURE__*/ new Quaternion();\n\nclass Euler {\n\n\tconstructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {\n\n\t\tthis.isEuler = true;\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget order() {\n\n\t\treturn this._order;\n\n\t}\n\n\tset order( value ) {\n\n\t\tthis._order = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, order = this._order ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t}\n\n\tcopy( euler ) {\n\n\t\tthis._x = euler._x;\n\t\tthis._y = euler._y;\n\t\tthis._z = euler._z;\n\t\tthis._order = euler._order;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m, order = this._order, update = true ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements;\n\t\tconst m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\tconst m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\tconst m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m13 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m23 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m32 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m31 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m21 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m12 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._y = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tif ( update === true ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromQuaternion( q, order, update ) {\n\n\t\t_matrix$2.makeRotationFromQuaternion( q );\n\n\t\treturn this.setFromRotationMatrix( _matrix$2, order, update );\n\n\t}\n\n\tsetFromVector3( v, order = this._order ) {\n\n\t\treturn this.set( v.x, v.y, v.z, order );\n\n\t}\n\n\treorder( newOrder ) {\n\n\t\t// WARNING: this discards revolution information -bhouston\n\n\t\t_quaternion$3.setFromEuler( this );\n\n\t\treturn this.setFromQuaternion( _quaternion$3, newOrder );\n\n\t}\n\n\tequals( euler ) {\n\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t}\n\n\tfromArray( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._order;\n\n\t\treturn array;\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this._x;\n\t\tyield this._y;\n\t\tyield this._z;\n\t\tyield this._order;\n\n\t}\n\n}\n\nEuler.DEFAULT_ORDER = 'XYZ';\n\nclass Layers {\n\n\tconstructor() {\n\n\t\tthis.mask = 1 | 0;\n\n\t}\n\n\tset( channel ) {\n\n\t\tthis.mask = ( 1 << channel | 0 ) >>> 0;\n\n\t}\n\n\tenable( channel ) {\n\n\t\tthis.mask |= 1 << channel | 0;\n\n\t}\n\n\tenableAll() {\n\n\t\tthis.mask = 0xffffffff | 0;\n\n\t}\n\n\ttoggle( channel ) {\n\n\t\tthis.mask ^= 1 << channel | 0;\n\n\t}\n\n\tdisable( channel ) {\n\n\t\tthis.mask &= ~ ( 1 << channel | 0 );\n\n\t}\n\n\tdisableAll() {\n\n\t\tthis.mask = 0;\n\n\t}\n\n\ttest( layers ) {\n\n\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t}\n\n\tisEnabled( channel ) {\n\n\t\treturn ( this.mask & ( 1 << channel | 0 ) ) !== 0;\n\n\t}\n\n}\n\nlet _object3DId = 0;\n\nconst _v1$4 = /*@__PURE__*/ new Vector3();\nconst _q1 = /*@__PURE__*/ new Quaternion();\nconst _m1$1 = /*@__PURE__*/ new Matrix4();\nconst _target = /*@__PURE__*/ new Vector3();\n\nconst _position$3 = /*@__PURE__*/ new Vector3();\nconst _scale$2 = /*@__PURE__*/ new Vector3();\nconst _quaternion$2 = /*@__PURE__*/ new Quaternion();\n\nconst _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );\nconst _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );\nconst _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );\n\nconst _addedEvent = { type: 'added' };\nconst _removedEvent = { type: 'removed' };\n\nconst _childaddedEvent = { type: 'childadded', child: null };\nconst _childremovedEvent = { type: 'childremoved', child: null };\n\nclass Object3D extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isObject3D = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _object3DId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Object3D';\n\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\n\t\tthis.up = Object3D.DEFAULT_UP.clone();\n\n\t\tconst position = new Vector3();\n\t\tconst rotation = new Euler();\n\t\tconst quaternion = new Quaternion();\n\t\tconst scale = new Vector3( 1, 1, 1 );\n\n\t\tfunction onRotationChange() {\n\n\t\t\tquaternion.setFromEuler( rotation, false );\n\n\t\t}\n\n\t\tfunction onQuaternionChange() {\n\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t\t}\n\n\t\trotation._onChange( onRotationChange );\n\t\tquaternion._onChange( onQuaternionChange );\n\n\t\tObject.defineProperties( this, {\n\t\t\tposition: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: position\n\t\t\t},\n\t\t\trotation: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: rotation\n\t\t\t},\n\t\t\tquaternion: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: quaternion\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: scale\n\t\t\t},\n\t\t\tmodelViewMatrix: {\n\t\t\t\tvalue: new Matrix4()\n\t\t\t},\n\t\t\tnormalMatrix: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t} );\n\n\t\tthis.matrix = new Matrix4();\n\t\tthis.matrixWorld = new Matrix4();\n\n\t\tthis.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\n\n\t\tthis.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer\n\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\tthis.layers = new Layers();\n\t\tthis.visible = true;\n\n\t\tthis.castShadow = false;\n\t\tthis.receiveShadow = false;\n\n\t\tthis.frustumCulled = true;\n\t\tthis.renderOrder = 0;\n\n\t\tthis.animations = [];\n\n\t\tthis.userData = {};\n\n\t}\n\n\tonBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}\n\n\tonAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}\n\n\tonBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}\n\n\tonAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tthis.matrix.premultiply( matrix );\n\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\tthis.quaternion.premultiply( q );\n\n\t\treturn this;\n\n\t}\n\n\tsetRotationFromAxisAngle( axis, angle ) {\n\n\t\t// assumes axis is normalized\n\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t}\n\n\tsetRotationFromEuler( euler ) {\n\n\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t}\n\n\tsetRotationFromMatrix( m ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t}\n\n\tsetRotationFromQuaternion( q ) {\n\n\t\t// assumes q is normalized\n\n\t\tthis.quaternion.copy( q );\n\n\t}\n\n\trotateOnAxis( axis, angle ) {\n\n\t\t// rotate object on axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\t_q1.setFromAxisAngle( axis, angle );\n\n\t\tthis.quaternion.multiply( _q1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateOnWorldAxis( axis, angle ) {\n\n\t\t// rotate object on axis in world space\n\t\t// axis is assumed to be normalized\n\t\t// method assumes no rotated parent\n\n\t\t_q1.setFromAxisAngle( axis, angle );\n\n\t\tthis.quaternion.premultiply( _q1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateX( angle ) {\n\n\t\treturn this.rotateOnAxis( _xAxis, angle );\n\n\t}\n\n\trotateY( angle ) {\n\n\t\treturn this.rotateOnAxis( _yAxis, angle );\n\n\t}\n\n\trotateZ( angle ) {\n\n\t\treturn this.rotateOnAxis( _zAxis, angle );\n\n\t}\n\n\ttranslateOnAxis( axis, distance ) {\n\n\t\t// translate object by distance along axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\t_v1$4.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\tthis.position.add( _v1$4.multiplyScalar( distance ) );\n\n\t\treturn this;\n\n\t}\n\n\ttranslateX( distance ) {\n\n\t\treturn this.translateOnAxis( _xAxis, distance );\n\n\t}\n\n\ttranslateY( distance ) {\n\n\t\treturn this.translateOnAxis( _yAxis, distance );\n\n\t}\n\n\ttranslateZ( distance ) {\n\n\t\treturn this.translateOnAxis( _zAxis, distance );\n\n\t}\n\n\tlocalToWorld( vector ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t}\n\n\tworldToLocal( vector ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );\n\n\t}\n\n\tlookAt( x, y, z ) {\n\n\t\t// This method does not support objects having non-uniformly-scaled parent(s)\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\t_target.copy( x );\n\n\t\t} else {\n\n\t\t\t_target.set( x, y, z );\n\n\t\t}\n\n\t\tconst parent = this.parent;\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\t_position$3.setFromMatrixPosition( this.matrixWorld );\n\n\t\tif ( this.isCamera || this.isLight ) {\n\n\t\t\t_m1$1.lookAt( _position$3, _target, this.up );\n\n\t\t} else {\n\n\t\t\t_m1$1.lookAt( _target, _position$3, this.up );\n\n\t\t}\n\n\t\tthis.quaternion.setFromRotationMatrix( _m1$1 );\n\n\t\tif ( parent ) {\n\n\t\t\t_m1$1.extractRotation( parent.matrixWorld );\n\t\t\t_q1.setFromRotationMatrix( _m1$1 );\n\t\t\tthis.quaternion.premultiply( _q1.invert() );\n\n\t\t}\n\n\t}\n\n\tadd( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.error( 'THREE.Object3D.add: object can\\'t be added as a child of itself.', object );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object && object.isObject3D ) {\n\n\t\t\tobject.removeFromParent();\n\t\t\tobject.parent = this;\n\t\t\tthis.children.push( object );\n\n\t\t\tobject.dispatchEvent( _addedEvent );\n\n\t\t\t_childaddedEvent.child = object;\n\t\t\tthis.dispatchEvent( _childaddedEvent );\n\t\t\t_childaddedEvent.child = null;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tremove( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = null;\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t\tobject.dispatchEvent( _removedEvent );\n\n\t\t\t_childremovedEvent.child = object;\n\t\t\tthis.dispatchEvent( _childremovedEvent );\n\t\t\t_childremovedEvent.child = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tremoveFromParent() {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tparent.remove( this );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclear() {\n\n\t\treturn this.remove( ... this.children );\n\n\t}\n\n\tattach( object ) {\n\n\t\t// adds object as a child of this, while maintaining the object's world transform\n\n\t\t// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\t_m1$1.copy( this.matrixWorld ).invert();\n\n\t\tif ( object.parent !== null ) {\n\n\t\t\tobject.parent.updateWorldMatrix( true, false );\n\n\t\t\t_m1$1.multiply( object.parent.matrixWorld );\n\n\t\t}\n\n\t\tobject.applyMatrix4( _m1$1 );\n\n\t\tobject.removeFromParent();\n\t\tobject.parent = this;\n\t\tthis.children.push( object );\n\n\t\tobject.updateWorldMatrix( false, true );\n\n\t\tobject.dispatchEvent( _addedEvent );\n\n\t\t_childaddedEvent.child = object;\n\t\tthis.dispatchEvent( _childaddedEvent );\n\t\t_childaddedEvent.child = null;\n\n\t\treturn this;\n\n\t}\n\n\tgetObjectById( id ) {\n\n\t\treturn this.getObjectByProperty( 'id', id );\n\n\t}\n\n\tgetObjectByName( name ) {\n\n\t\treturn this.getObjectByProperty( 'name', name );\n\n\t}\n\n\tgetObjectByProperty( name, value ) {\n\n\t\tif ( this[ name ] === value ) return this;\n\n\t\tfor ( let i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = this.children[ i ];\n\t\t\tconst object = child.getObjectByProperty( name, value );\n\n\t\t\tif ( object !== undefined ) {\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\tgetObjectsByProperty( name, value, result = [] ) {\n\n\t\tif ( this[ name ] === value ) result.push( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].getObjectsByProperty( name, value, result );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tgetWorldPosition( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn target.setFromMatrixPosition( this.matrixWorld );\n\n\t}\n\n\tgetWorldQuaternion( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tthis.matrixWorld.decompose( _position$3, target, _scale$2 );\n\n\t\treturn target;\n\n\t}\n\n\tgetWorldScale( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tthis.matrixWorld.decompose( _position$3, _quaternion$2, target );\n\n\t\treturn target;\n\n\t}\n\n\tgetWorldDirection( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tconst e = this.matrixWorld.elements;\n\n\t\treturn target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();\n\n\t}\n\n\traycast( /* raycaster, intersects */ ) {}\n\n\ttraverse( callback ) {\n\n\t\tcallback( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverse( callback );\n\n\t\t}\n\n\t}\n\n\ttraverseVisible( callback ) {\n\n\t\tif ( this.visible === false ) return;\n\n\t\tcallback( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t}\n\n\t}\n\n\ttraverseAncestors( callback ) {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tcallback( parent );\n\n\t\t\tparent.traverseAncestors( callback );\n\n\t\t}\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.matrixWorldAutoUpdate === true ) {\n\n\t\t\t\tif ( this.parent === null ) {\n\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// make sure descendants are updated if required\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst child = children[ i ];\n\n\t\t\tchild.updateMatrixWorld( force );\n\n\t\t}\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( updateParents === true && parent !== null ) {\n\n\t\t\tparent.updateWorldMatrix( true, false );\n\n\t\t}\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldAutoUpdate === true ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// make sure descendants are updated\n\n\t\tif ( updateChildren === true ) {\n\n\t\t\tconst children = this.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\n\t\t\t\tchild.updateWorldMatrix( false, true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\t// meta is a string when called from JSON.stringify\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tconst output = {};\n\n\t\t// meta is a hash used to collect geometries, materials.\n\t\t// not providing it implies that this is the root object\n\t\t// being serialized.\n\t\tif ( isRootObject ) {\n\n\t\t\t// initialize meta obj\n\t\t\tmeta = {\n\t\t\t\tgeometries: {},\n\t\t\t\tmaterials: {},\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tshapes: {},\n\t\t\t\tskeletons: {},\n\t\t\t\tanimations: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t\toutput.metadata = {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Object',\n\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t};\n\n\t\t}\n\n\t\t// standard Object3D serialization\n\n\t\tconst object = {};\n\n\t\tobject.uuid = this.uuid;\n\t\tobject.type = this.type;\n\n\t\tif ( this.name !== '' ) object.name = this.name;\n\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\tif ( this.visible === false ) object.visible = false;\n\t\tif ( this.frustumCulled === false ) object.frustumCulled = false;\n\t\tif ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;\n\t\tif ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;\n\n\t\tobject.layers = this.layers.mask;\n\t\tobject.matrix = this.matrix.toArray();\n\t\tobject.up = this.up.toArray();\n\n\t\tif ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;\n\n\t\t// object specific properties\n\n\t\tif ( this.isInstancedMesh ) {\n\n\t\t\tobject.type = 'InstancedMesh';\n\t\t\tobject.count = this.count;\n\t\t\tobject.instanceMatrix = this.instanceMatrix.toJSON();\n\t\t\tif ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();\n\n\t\t}\n\n\t\tif ( this.isBatchedMesh ) {\n\n\t\t\tobject.type = 'BatchedMesh';\n\t\t\tobject.perObjectFrustumCulled = this.perObjectFrustumCulled;\n\t\t\tobject.sortObjects = this.sortObjects;\n\n\t\t\tobject.drawRanges = this._drawRanges;\n\t\t\tobject.reservedRanges = this._reservedRanges;\n\n\t\t\tobject.visibility = this._visibility;\n\t\t\tobject.active = this._active;\n\t\t\tobject.bounds = this._bounds.map( bound => ( {\n\t\t\t\tboxInitialized: bound.boxInitialized,\n\t\t\t\tboxMin: bound.box.min.toArray(),\n\t\t\t\tboxMax: bound.box.max.toArray(),\n\n\t\t\t\tsphereInitialized: bound.sphereInitialized,\n\t\t\t\tsphereRadius: bound.sphere.radius,\n\t\t\t\tsphereCenter: bound.sphere.center.toArray()\n\t\t\t} ) );\n\n\t\t\tobject.maxInstanceCount = this._maxInstanceCount;\n\t\t\tobject.maxVertexCount = this._maxVertexCount;\n\t\t\tobject.maxIndexCount = this._maxIndexCount;\n\n\t\t\tobject.geometryInitialized = this._geometryInitialized;\n\t\t\tobject.geometryCount = this._geometryCount;\n\n\t\t\tobject.matricesTexture = this._matricesTexture.toJSON( meta );\n\n\t\t\tif ( this._colorsTexture !== null ) object.colorsTexture = this._colorsTexture.toJSON( meta );\n\n\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\tobject.boundingSphere = {\n\t\t\t\t\tcenter: object.boundingSphere.center.toArray(),\n\t\t\t\t\tradius: object.boundingSphere.radius\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\tobject.boundingBox = {\n\t\t\t\t\tmin: object.boundingBox.min.toArray(),\n\t\t\t\t\tmax: object.boundingBox.max.toArray()\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tfunction serialize( library, element ) {\n\n\t\t\tif ( library[ element.uuid ] === undefined ) {\n\n\t\t\t\tlibrary[ element.uuid ] = element.toJSON( meta );\n\n\t\t\t}\n\n\t\t\treturn element.uuid;\n\n\t\t}\n\n\t\tif ( this.isScene ) {\n\n\t\t\tif ( this.background ) {\n\n\t\t\t\tif ( this.background.isColor ) {\n\n\t\t\t\t\tobject.background = this.background.toJSON();\n\n\t\t\t\t} else if ( this.background.isTexture ) {\n\n\t\t\t\t\tobject.background = this.background.toJSON( meta ).uuid;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {\n\n\t\t\t\tobject.environment = this.environment.toJSON( meta ).uuid;\n\n\t\t\t}\n\n\t\t} else if ( this.isMesh || this.isLine || this.isPoints ) {\n\n\t\t\tobject.geometry = serialize( meta.geometries, this.geometry );\n\n\t\t\tconst parameters = this.geometry.parameters;\n\n\t\t\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\n\n\t\t\t\tconst shapes = parameters.shapes;\n\n\t\t\t\tif ( Array.isArray( shapes ) ) {\n\n\t\t\t\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst shape = shapes[ i ];\n\n\t\t\t\t\t\tserialize( meta.shapes, shape );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tserialize( meta.shapes, shapes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.isSkinnedMesh ) {\n\n\t\t\tobject.bindMode = this.bindMode;\n\t\t\tobject.bindMatrix = this.bindMatrix.toArray();\n\n\t\t\tif ( this.skeleton !== undefined ) {\n\n\t\t\t\tserialize( meta.skeletons, this.skeleton );\n\n\t\t\t\tobject.skeleton = this.skeleton.uuid;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.material !== undefined ) {\n\n\t\t\tif ( Array.isArray( this.material ) ) {\n\n\t\t\t\tconst uuids = [];\n\n\t\t\t\tfor ( let i = 0, l = this.material.length; i < l; i ++ ) {\n\n\t\t\t\t\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tobject.material = uuids;\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = serialize( meta.materials, this.material );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.children.length > 0 ) {\n\n\t\t\tobject.children = [];\n\n\t\t\tfor ( let i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.animations.length > 0 ) {\n\n\t\t\tobject.animations = [];\n\n\t\t\tfor ( let i = 0; i < this.animations.length; i ++ ) {\n\n\t\t\t\tconst animation = this.animations[ i ];\n\n\t\t\t\tobject.animations.push( serialize( meta.animations, animation ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tconst geometries = extractFromCache( meta.geometries );\n\t\t\tconst materials = extractFromCache( meta.materials );\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst shapes = extractFromCache( meta.shapes );\n\t\t\tconst skeletons = extractFromCache( meta.skeletons );\n\t\t\tconst animations = extractFromCache( meta.animations );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\tif ( images.length > 0 ) output.images = images;\n\t\t\tif ( shapes.length > 0 ) output.shapes = shapes;\n\t\t\tif ( skeletons.length > 0 ) output.skeletons = skeletons;\n\t\t\tif ( animations.length > 0 ) output.animations = animations;\n\t\t\tif ( nodes.length > 0 ) output.nodes = nodes;\n\n\t\t}\n\n\t\toutput.object = object;\n\n\t\treturn output;\n\n\t\t// extract data from the cache hash\n\t\t// remove metadata on each item\n\t\t// and return as array\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t}\n\n\tclone( recursive ) {\n\n\t\treturn new this.constructor().copy( this, recursive );\n\n\t}\n\n\tcopy( source, recursive = true ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.up.copy( source.up );\n\n\t\tthis.position.copy( source.position );\n\t\tthis.rotation.order = source.rotation.order;\n\t\tthis.quaternion.copy( source.quaternion );\n\t\tthis.scale.copy( source.scale );\n\n\t\tthis.matrix.copy( source.matrix );\n\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\tthis.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\tthis.layers.mask = source.layers.mask;\n\t\tthis.visible = source.visible;\n\n\t\tthis.castShadow = source.castShadow;\n\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\tthis.frustumCulled = source.frustumCulled;\n\t\tthis.renderOrder = source.renderOrder;\n\n\t\tthis.animations = source.animations.slice();\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tfor ( let i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\tconst child = source.children[ i ];\n\t\t\t\tthis.add( child.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nObject3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );\nObject3D.DEFAULT_MATRIX_AUTO_UPDATE = true;\nObject3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;\n\nconst _v0$1 = /*@__PURE__*/ new Vector3();\nconst _v1$3 = /*@__PURE__*/ new Vector3();\nconst _v2$2 = /*@__PURE__*/ new Vector3();\nconst _v3$2 = /*@__PURE__*/ new Vector3();\n\nconst _vab = /*@__PURE__*/ new Vector3();\nconst _vac = /*@__PURE__*/ new Vector3();\nconst _vbc = /*@__PURE__*/ new Vector3();\nconst _vap = /*@__PURE__*/ new Vector3();\nconst _vbp = /*@__PURE__*/ new Vector3();\nconst _vcp = /*@__PURE__*/ new Vector3();\n\nconst _v40 = /*@__PURE__*/ new Vector4();\nconst _v41 = /*@__PURE__*/ new Vector4();\nconst _v42 = /*@__PURE__*/ new Vector4();\n\nclass Triangle {\n\n\tconstructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t}\n\n\tstatic getNormal( a, b, c, target ) {\n\n\t\ttarget.subVectors( c, b );\n\t\t_v0$1.subVectors( a, b );\n\t\ttarget.cross( _v0$1 );\n\n\t\tconst targetLengthSq = target.lengthSq();\n\t\tif ( targetLengthSq > 0 ) {\n\n\t\t\treturn target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );\n\n\t\t}\n\n\t\treturn target.set( 0, 0, 0 );\n\n\t}\n\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tstatic getBarycoord( point, a, b, c, target ) {\n\n\t\t_v0$1.subVectors( c, a );\n\t\t_v1$3.subVectors( b, a );\n\t\t_v2$2.subVectors( point, a );\n\n\t\tconst dot00 = _v0$1.dot( _v0$1 );\n\t\tconst dot01 = _v0$1.dot( _v1$3 );\n\t\tconst dot02 = _v0$1.dot( _v2$2 );\n\t\tconst dot11 = _v1$3.dot( _v1$3 );\n\t\tconst dot12 = _v1$3.dot( _v2$2 );\n\n\t\tconst denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\t// collinear or singular triangle\n\t\tif ( denom === 0 ) {\n\n\t\t\ttarget.set( 0, 0, 0 );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst invDenom = 1 / denom;\n\t\tconst u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tconst v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycentric coordinates must always sum to 1\n\t\treturn target.set( 1 - u - v, v, u );\n\n\t}\n\n\tstatic containsPoint( point, a, b, c ) {\n\n\t\t// if the triangle is degenerate then we can't contain a point\n\t\tif ( this.getBarycoord( point, a, b, c, _v3$2 ) === null ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn ( _v3$2.x >= 0 ) && ( _v3$2.y >= 0 ) && ( ( _v3$2.x + _v3$2.y ) <= 1 );\n\n\t}\n\n\tstatic getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {\n\n\t\tif ( this.getBarycoord( point, p1, p2, p3, _v3$2 ) === null ) {\n\n\t\t\ttarget.x = 0;\n\t\t\ttarget.y = 0;\n\t\t\tif ( 'z' in target ) target.z = 0;\n\t\t\tif ( 'w' in target ) target.w = 0;\n\t\t\treturn null;\n\n\t\t}\n\n\t\ttarget.setScalar( 0 );\n\t\ttarget.addScaledVector( v1, _v3$2.x );\n\t\ttarget.addScaledVector( v2, _v3$2.y );\n\t\ttarget.addScaledVector( v3, _v3$2.z );\n\n\t\treturn target;\n\n\t}\n\n\tstatic getInterpolatedAttribute( attr, i1, i2, i3, barycoord, target ) {\n\n\t\t_v40.setScalar( 0 );\n\t\t_v41.setScalar( 0 );\n\t\t_v42.setScalar( 0 );\n\n\t\t_v40.fromBufferAttribute( attr, i1 );\n\t\t_v41.fromBufferAttribute( attr, i2 );\n\t\t_v42.fromBufferAttribute( attr, i3 );\n\n\t\ttarget.setScalar( 0 );\n\t\ttarget.addScaledVector( _v40, barycoord.x );\n\t\ttarget.addScaledVector( _v41, barycoord.y );\n\t\ttarget.addScaledVector( _v42, barycoord.z );\n\n\t\treturn target;\n\n\t}\n\n\tstatic isFrontFacing( a, b, c, direction ) {\n\n\t\t_v0$1.subVectors( c, b );\n\t\t_v1$3.subVectors( a, b );\n\n\t\t// strictly front facing\n\t\treturn ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;\n\n\t}\n\n\tset( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPointsAndIndices( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromAttributeAndIndices( attribute, i0, i1, i2 ) {\n\n\t\tthis.a.fromBufferAttribute( attribute, i0 );\n\t\tthis.b.fromBufferAttribute( attribute, i1 );\n\t\tthis.c.fromBufferAttribute( attribute, i2 );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t}\n\n\tgetArea() {\n\n\t\t_v0$1.subVectors( this.c, this.b );\n\t\t_v1$3.subVectors( this.a, this.b );\n\n\t\treturn _v0$1.cross( _v1$3 ).length() * 0.5;\n\n\t}\n\n\tgetMidpoint( target ) {\n\n\t\treturn target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t}\n\n\tgetNormal( target ) {\n\n\t\treturn Triangle.getNormal( this.a, this.b, this.c, target );\n\n\t}\n\n\tgetPlane( target ) {\n\n\t\treturn target.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t}\n\n\tgetBarycoord( point, target ) {\n\n\t\treturn Triangle.getBarycoord( point, this.a, this.b, this.c, target );\n\n\t}\n\n\tgetInterpolation( point, v1, v2, v3, target ) {\n\n\t\treturn Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t}\n\n\tisFrontFacing( direction ) {\n\n\t\treturn Triangle.isFrontFacing( this.a, this.b, this.c, direction );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsTriangle( this );\n\n\t}\n\n\tclosestPointToPoint( p, target ) {\n\n\t\tconst a = this.a, b = this.b, c = this.c;\n\t\tlet v, w;\n\n\t\t// algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\n\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\n\t\t// the point lies in with the minimum amount of redundant computation.\n\n\t\t_vab.subVectors( b, a );\n\t\t_vac.subVectors( c, a );\n\t\t_vap.subVectors( p, a );\n\t\tconst d1 = _vab.dot( _vap );\n\t\tconst d2 = _vac.dot( _vap );\n\t\tif ( d1 <= 0 && d2 <= 0 ) {\n\n\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\n\t\t\treturn target.copy( a );\n\n\t\t}\n\n\t\t_vbp.subVectors( p, b );\n\t\tconst d3 = _vab.dot( _vbp );\n\t\tconst d4 = _vac.dot( _vbp );\n\t\tif ( d3 >= 0 && d4 <= d3 ) {\n\n\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\n\t\t\treturn target.copy( b );\n\n\t\t}\n\n\t\tconst vc = d1 * d4 - d3 * d2;\n\t\tif ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {\n\n\t\t\tv = d1 / ( d1 - d3 );\n\t\t\t// edge region of AB; barycentric coords (1-v, v, 0)\n\t\t\treturn target.copy( a ).addScaledVector( _vab, v );\n\n\t\t}\n\n\t\t_vcp.subVectors( p, c );\n\t\tconst d5 = _vab.dot( _vcp );\n\t\tconst d6 = _vac.dot( _vcp );\n\t\tif ( d6 >= 0 && d5 <= d6 ) {\n\n\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\n\t\t\treturn target.copy( c );\n\n\t\t}\n\n\t\tconst vb = d5 * d2 - d1 * d6;\n\t\tif ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {\n\n\t\t\tw = d2 / ( d2 - d6 );\n\t\t\t// edge region of AC; barycentric coords (1-w, 0, w)\n\t\t\treturn target.copy( a ).addScaledVector( _vac, w );\n\n\t\t}\n\n\t\tconst va = d3 * d6 - d5 * d4;\n\t\tif ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {\n\n\t\t\t_vbc.subVectors( c, b );\n\t\t\tw = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );\n\t\t\t// edge region of BC; barycentric coords (0, 1-w, w)\n\t\t\treturn target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC\n\n\t\t}\n\n\t\t// face region\n\t\tconst denom = 1 / ( va + vb + vc );\n\t\t// u = va * denom\n\t\tv = vb * denom;\n\t\tw = vc * denom;\n\n\t\treturn target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );\n\n\t}\n\n\tequals( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n}\n\nconst _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\nconst _hslA = { h: 0, s: 0, l: 0 };\nconst _hslB = { h: 0, s: 0, l: 0 };\n\nfunction hue2rgb( p, q, t ) {\n\n\tif ( t < 0 ) t += 1;\n\tif ( t > 1 ) t -= 1;\n\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\tif ( t < 1 / 2 ) return q;\n\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\treturn p;\n\n}\n\nclass Color {\n\n\tconstructor( r, g, b ) {\n\n\t\tthis.isColor = true;\n\n\t\tthis.r = 1;\n\t\tthis.g = 1;\n\t\tthis.b = 1;\n\n\t\treturn this.set( r, g, b );\n\n\t}\n\n\tset( r, g, b ) {\n\n\t\tif ( g === undefined && b === undefined ) {\n\n\t\t\t// r is THREE.Color, hex or string\n\n\t\t\tconst value = r;\n\n\t\t\tif ( value && value.isColor ) {\n\n\t\t\t\tthis.copy( value );\n\n\t\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\t\tthis.setHex( value );\n\n\t\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\t\tthis.setStyle( value );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.setRGB( r, g, b );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.r = scalar;\n\t\tthis.g = scalar;\n\t\tthis.b = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetHex( hex, colorSpace = SRGBColorSpace ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\tColorManagement.toWorkingColorSpace( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\tsetRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\tColorManagement.toWorkingColorSpace( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\tsetHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\th = euclideanModulo( h, 1 );\n\t\ts = clamp( s, 0, 1 );\n\t\tl = clamp( l, 0, 1 );\n\n\t\tif ( s === 0 ) {\n\n\t\t\tthis.r = this.g = this.b = l;\n\n\t\t} else {\n\n\t\t\tconst p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\tconst q = ( 2 * l ) - p;\n\n\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t}\n\n\t\tColorManagement.toWorkingColorSpace( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\tsetStyle( style, colorSpace = SRGBColorSpace ) {\n\n\t\tfunction handleAlpha( string ) {\n\n\t\t\tif ( string === undefined ) return;\n\n\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tlet m;\n\n\t\tif ( m = /^(\\w+)\\(([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t// rgb / hsl\n\n\t\t\tlet color;\n\t\t\tconst name = m[ 1 ];\n\t\t\tconst components = m[ 2 ];\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'rgb':\n\t\t\t\tcase 'rgba':\n\n\t\t\t\t\tif ( color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setRGB(\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setRGB(\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hsl':\n\t\t\t\tcase 'hsla':\n\n\t\t\t\t\tif ( color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setHSL(\n\t\t\t\t\t\t\tparseFloat( color[ 1 ] ) / 360,\n\t\t\t\t\t\t\tparseFloat( color[ 2 ] ) / 100,\n\t\t\t\t\t\t\tparseFloat( color[ 3 ] ) / 100,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color model ' + style );\n\n\t\t\t}\n\n\t\t} else if ( m = /^\\#([A-Fa-f\\d]+)$/.exec( style ) ) {\n\n\t\t\t// hex color\n\n\t\t\tconst hex = m[ 1 ];\n\t\t\tconst size = hex.length;\n\n\t\t\tif ( size === 3 ) {\n\n\t\t\t\t// #ff0\n\t\t\t\treturn this.setRGB(\n\t\t\t\t\tparseInt( hex.charAt( 0 ), 16 ) / 15,\n\t\t\t\t\tparseInt( hex.charAt( 1 ), 16 ) / 15,\n\t\t\t\t\tparseInt( hex.charAt( 2 ), 16 ) / 15,\n\t\t\t\t\tcolorSpace\n\t\t\t\t);\n\n\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t// #ff0000\n\t\t\t\treturn this.setHex( parseInt( hex, 16 ), colorSpace );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Invalid hex color ' + style );\n\n\t\t\t}\n\n\t\t} else if ( style && style.length > 0 ) {\n\n\t\t\treturn this.setColorName( style, colorSpace );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetColorName( style, colorSpace = SRGBColorSpace ) {\n\n\t\t// color keywords\n\t\tconst hex = _colorKeywords[ style.toLowerCase() ];\n\n\t\tif ( hex !== undefined ) {\n\n\t\t\t// red\n\t\t\tthis.setHex( hex, colorSpace );\n\n\t\t} else {\n\n\t\t\t// unknown color\n\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t}\n\n\tcopy( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t}\n\n\tcopySRGBToLinear( color ) {\n\n\t\tthis.r = SRGBToLinear( color.r );\n\t\tthis.g = SRGBToLinear( color.g );\n\t\tthis.b = SRGBToLinear( color.b );\n\n\t\treturn this;\n\n\t}\n\n\tcopyLinearToSRGB( color ) {\n\n\t\tthis.r = LinearToSRGB( color.r );\n\t\tthis.g = LinearToSRGB( color.g );\n\t\tthis.b = LinearToSRGB( color.b );\n\n\t\treturn this;\n\n\t}\n\n\tconvertSRGBToLinear() {\n\n\t\tthis.copySRGBToLinear( this );\n\n\t\treturn this;\n\n\t}\n\n\tconvertLinearToSRGB() {\n\n\t\tthis.copyLinearToSRGB( this );\n\n\t\treturn this;\n\n\t}\n\n\tgetHex( colorSpace = SRGBColorSpace ) {\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\treturn Math.round( clamp( _color.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp( _color.g * 255, 0, 255 ) ) * 256 + Math.round( clamp( _color.b * 255, 0, 255 ) );\n\n\t}\n\n\tgetHexString( colorSpace = SRGBColorSpace ) {\n\n\t\treturn ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );\n\n\t}\n\n\tgetHSL( target, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\tconst r = _color.r, g = _color.g, b = _color.b;\n\n\t\tconst max = Math.max( r, g, b );\n\t\tconst min = Math.min( r, g, b );\n\n\t\tlet hue, saturation;\n\t\tconst lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tconst delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\ttarget.h = hue;\n\t\ttarget.s = saturation;\n\t\ttarget.l = lightness;\n\n\t\treturn target;\n\n\t}\n\n\tgetRGB( target, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\ttarget.r = _color.r;\n\t\ttarget.g = _color.g;\n\t\ttarget.b = _color.b;\n\n\t\treturn target;\n\n\t}\n\n\tgetStyle( colorSpace = SRGBColorSpace ) {\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\tconst r = _color.r, g = _color.g, b = _color.b;\n\n\t\tif ( colorSpace !== SRGBColorSpace ) {\n\n\t\t\t// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).\n\t\t\treturn `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;\n\n\t\t}\n\n\t\treturn `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;\n\n\t}\n\n\toffsetHSL( h, s, l ) {\n\n\t\tthis.getHSL( _hslA );\n\n\t\treturn this.setHSL( _hslA.h + h, _hslA.s + s, _hslA.l + l );\n\n\t}\n\n\tadd( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t}\n\n\taddColors( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( color ) {\n\n\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\tthis.b = Math.max( 0, this.b - color.b );\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t}\n\n\tlerp( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpColors( color1, color2, alpha ) {\n\n\t\tthis.r = color1.r + ( color2.r - color1.r ) * alpha;\n\t\tthis.g = color1.g + ( color2.g - color1.g ) * alpha;\n\t\tthis.b = color1.b + ( color2.b - color1.b ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpHSL( color, alpha ) {\n\n\t\tthis.getHSL( _hslA );\n\t\tcolor.getHSL( _hslB );\n\n\t\tconst h = lerp( _hslA.h, _hslB.h, alpha );\n\t\tconst s = lerp( _hslA.s, _hslB.s, alpha );\n\t\tconst l = lerp( _hslA.l, _hslB.l, alpha );\n\n\t\tthis.setHSL( h, s, l );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\tthis.r = v.x;\n\t\tthis.g = v.y;\n\t\tthis.b = v.z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst r = this.r, g = this.g, b = this.b;\n\t\tconst e = m.elements;\n\n\t\tthis.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;\n\t\tthis.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;\n\t\tthis.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;\n\n\t\treturn this;\n\n\t}\n\n\tequals( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.r = array[ offset ];\n\t\tthis.g = array[ offset + 1 ];\n\t\tthis.b = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.r;\n\t\tarray[ offset + 1 ] = this.g;\n\t\tarray[ offset + 2 ] = this.b;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.r = attribute.getX( index );\n\t\tthis.g = attribute.getY( index );\n\t\tthis.b = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.getHex();\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.r;\n\t\tyield this.g;\n\t\tyield this.b;\n\n\t}\n\n}\n\nconst _color = /*@__PURE__*/ new Color();\n\nColor.NAMES = _colorKeywords;\n\nlet _materialId = 0;\n\nclass Material extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isMaterial = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _materialId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Material';\n\n\t\tthis.blending = NormalBlending;\n\t\tthis.side = FrontSide;\n\t\tthis.vertexColors = false;\n\n\t\tthis.opacity = 1;\n\t\tthis.transparent = false;\n\t\tthis.alphaHash = false;\n\n\t\tthis.blendSrc = SrcAlphaFactor;\n\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\tthis.blendEquation = AddEquation;\n\t\tthis.blendSrcAlpha = null;\n\t\tthis.blendDstAlpha = null;\n\t\tthis.blendEquationAlpha = null;\n\t\tthis.blendColor = new Color( 0, 0, 0 );\n\t\tthis.blendAlpha = 0;\n\n\t\tthis.depthFunc = LessEqualDepth;\n\t\tthis.depthTest = true;\n\t\tthis.depthWrite = true;\n\n\t\tthis.stencilWriteMask = 0xff;\n\t\tthis.stencilFunc = AlwaysStencilFunc;\n\t\tthis.stencilRef = 0;\n\t\tthis.stencilFuncMask = 0xff;\n\t\tthis.stencilFail = KeepStencilOp;\n\t\tthis.stencilZFail = KeepStencilOp;\n\t\tthis.stencilZPass = KeepStencilOp;\n\t\tthis.stencilWrite = false;\n\n\t\tthis.clippingPlanes = null;\n\t\tthis.clipIntersection = false;\n\t\tthis.clipShadows = false;\n\n\t\tthis.shadowSide = null;\n\n\t\tthis.colorWrite = true;\n\n\t\tthis.precision = null; // override the renderer's default precision for this material\n\n\t\tthis.polygonOffset = false;\n\t\tthis.polygonOffsetFactor = 0;\n\t\tthis.polygonOffsetUnits = 0;\n\n\t\tthis.dithering = false;\n\n\t\tthis.alphaToCoverage = false;\n\t\tthis.premultipliedAlpha = false;\n\t\tthis.forceSinglePass = false;\n\n\t\tthis.visible = true;\n\n\t\tthis.toneMapped = true;\n\n\t\tthis.userData = {};\n\n\t\tthis.version = 0;\n\n\t\tthis._alphaTest = 0;\n\n\t}\n\n\tget alphaTest() {\n\n\t\treturn this._alphaTest;\n\n\t}\n\n\tset alphaTest( value ) {\n\n\t\tif ( this._alphaTest > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._alphaTest = value;\n\n\t}\n\n\t// onBeforeRender and onBeforeCompile only supported in WebGLRenderer\n\n\tonBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}\n\n\tonBeforeCompile( /* shaderobject, renderer */ ) {}\n\n\tcustomProgramCacheKey() {\n\n\t\treturn this.onBeforeCompile.toString();\n\n\t}\n\n\tsetValues( values ) {\n\n\t\tif ( values === undefined ) return;\n\n\t\tfor ( const key in values ) {\n\n\t\t\tconst newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( `THREE.Material: parameter '${ key }' has value of undefined.` );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst currentValue = this[ key ];\n\n\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\tconsole.warn( `THREE.Material: '${ key }' is not a property of THREE.${ this.type }.` );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( currentValue && currentValue.isColor ) {\n\n\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRootObject ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Material',\n\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Material serialization\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.color && this.color.isColor ) data.color = this.color.getHex();\n\n\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\tif ( this.sheen !== undefined ) data.sheen = this.sheen;\n\t\tif ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();\n\t\tif ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;\n\t\tif ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\n\t\tif ( this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;\n\n\t\tif ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\n\t\tif ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;\n\t\tif ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\t\tif ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;\n\t\tif ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;\n\n\t\tif ( this.clearcoatMap && this.clearcoatMap.isTexture ) {\n\n\t\t\tdata.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {\n\n\t\t\tdata.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {\n\n\t\t\tdata.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;\n\t\t\tdata.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n\n\t\t}\n\n\t\tif ( this.dispersion !== undefined ) data.dispersion = this.dispersion;\n\n\t\tif ( this.iridescence !== undefined ) data.iridescence = this.iridescence;\n\t\tif ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;\n\t\tif ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;\n\n\t\tif ( this.iridescenceMap && this.iridescenceMap.isTexture ) {\n\n\t\t\tdata.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {\n\n\t\t\tdata.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.anisotropy !== undefined ) data.anisotropy = this.anisotropy;\n\t\tif ( this.anisotropyRotation !== undefined ) data.anisotropyRotation = this.anisotropyRotation;\n\n\t\tif ( this.anisotropyMap && this.anisotropyMap.isTexture ) {\n\n\t\t\tdata.anisotropyMap = this.anisotropyMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\n\t\tif ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;\n\t\tif ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\n\t\tif ( this.lightMap && this.lightMap.isTexture ) {\n\n\t\t\tdata.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\tdata.lightMapIntensity = this.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( this.aoMap && this.aoMap.isTexture ) {\n\n\t\t\tdata.aoMap = this.aoMap.toJSON( meta ).uuid;\n\t\t\tdata.aoMapIntensity = this.aoMapIntensity;\n\n\t\t}\n\n\t\tif ( this.bumpMap && this.bumpMap.isTexture ) {\n\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t}\n\n\t\tif ( this.normalMap && this.normalMap.isTexture ) {\n\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\tdata.normalMapType = this.normalMapType;\n\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t}\n\n\t\tif ( this.displacementMap && this.displacementMap.isTexture ) {\n\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t}\n\n\t\tif ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\tif ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\tif ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\tif ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\t\tif ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;\n\t\tif ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;\n\n\t\tif ( this.envMap && this.envMap.isTexture ) {\n\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\n\t\t\tif ( this.combine !== undefined ) data.combine = this.combine;\n\n\t\t}\n\n\t\tif ( this.envMapRotation !== undefined ) data.envMapRotation = this.envMapRotation.toArray();\n\t\tif ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;\n\t\tif ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;\n\t\tif ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;\n\n\t\tif ( this.gradientMap && this.gradientMap.isTexture ) {\n\n\t\t\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.transmission !== undefined ) data.transmission = this.transmission;\n\t\tif ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;\n\t\tif ( this.thickness !== undefined ) data.thickness = this.thickness;\n\t\tif ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;\n\t\tif ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;\n\t\tif ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();\n\n\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\tif ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\tif ( this.vertexColors === true ) data.vertexColors = true;\n\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\tif ( this.transparent === true ) data.transparent = true;\n\n\t\tif ( this.blendSrc !== SrcAlphaFactor ) data.blendSrc = this.blendSrc;\n\t\tif ( this.blendDst !== OneMinusSrcAlphaFactor ) data.blendDst = this.blendDst;\n\t\tif ( this.blendEquation !== AddEquation ) data.blendEquation = this.blendEquation;\n\t\tif ( this.blendSrcAlpha !== null ) data.blendSrcAlpha = this.blendSrcAlpha;\n\t\tif ( this.blendDstAlpha !== null ) data.blendDstAlpha = this.blendDstAlpha;\n\t\tif ( this.blendEquationAlpha !== null ) data.blendEquationAlpha = this.blendEquationAlpha;\n\t\tif ( this.blendColor && this.blendColor.isColor ) data.blendColor = this.blendColor.getHex();\n\t\tif ( this.blendAlpha !== 0 ) data.blendAlpha = this.blendAlpha;\n\n\t\tif ( this.depthFunc !== LessEqualDepth ) data.depthFunc = this.depthFunc;\n\t\tif ( this.depthTest === false ) data.depthTest = this.depthTest;\n\t\tif ( this.depthWrite === false ) data.depthWrite = this.depthWrite;\n\t\tif ( this.colorWrite === false ) data.colorWrite = this.colorWrite;\n\n\t\tif ( this.stencilWriteMask !== 0xff ) data.stencilWriteMask = this.stencilWriteMask;\n\t\tif ( this.stencilFunc !== AlwaysStencilFunc ) data.stencilFunc = this.stencilFunc;\n\t\tif ( this.stencilRef !== 0 ) data.stencilRef = this.stencilRef;\n\t\tif ( this.stencilFuncMask !== 0xff ) data.stencilFuncMask = this.stencilFuncMask;\n\t\tif ( this.stencilFail !== KeepStencilOp ) data.stencilFail = this.stencilFail;\n\t\tif ( this.stencilZFail !== KeepStencilOp ) data.stencilZFail = this.stencilZFail;\n\t\tif ( this.stencilZPass !== KeepStencilOp ) data.stencilZPass = this.stencilZPass;\n\t\tif ( this.stencilWrite === true ) data.stencilWrite = this.stencilWrite;\n\n\t\t// rotation (SpriteMaterial)\n\t\tif ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;\n\n\t\tif ( this.polygonOffset === true ) data.polygonOffset = true;\n\t\tif ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;\n\t\tif ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;\n\n\t\tif ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;\n\t\tif ( this.dashSize !== undefined ) data.dashSize = this.dashSize;\n\t\tif ( this.gapSize !== undefined ) data.gapSize = this.gapSize;\n\t\tif ( this.scale !== undefined ) data.scale = this.scale;\n\n\t\tif ( this.dithering === true ) data.dithering = true;\n\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\tif ( this.alphaHash === true ) data.alphaHash = true;\n\t\tif ( this.alphaToCoverage === true ) data.alphaToCoverage = true;\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = true;\n\t\tif ( this.forceSinglePass === true ) data.forceSinglePass = true;\n\n\t\tif ( this.wireframe === true ) data.wireframe = true;\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\n\t\tif ( this.flatShading === true ) data.flatShading = true;\n\n\t\tif ( this.visible === false ) data.visible = false;\n\n\t\tif ( this.toneMapped === false ) data.toneMapped = false;\n\n\t\tif ( this.fog === false ) data.fog = false;\n\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.blending = source.blending;\n\t\tthis.side = source.side;\n\t\tthis.vertexColors = source.vertexColors;\n\n\t\tthis.opacity = source.opacity;\n\t\tthis.transparent = source.transparent;\n\n\t\tthis.blendSrc = source.blendSrc;\n\t\tthis.blendDst = source.blendDst;\n\t\tthis.blendEquation = source.blendEquation;\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\t\tthis.blendColor.copy( source.blendColor );\n\t\tthis.blendAlpha = source.blendAlpha;\n\n\t\tthis.depthFunc = source.depthFunc;\n\t\tthis.depthTest = source.depthTest;\n\t\tthis.depthWrite = source.depthWrite;\n\n\t\tthis.stencilWriteMask = source.stencilWriteMask;\n\t\tthis.stencilFunc = source.stencilFunc;\n\t\tthis.stencilRef = source.stencilRef;\n\t\tthis.stencilFuncMask = source.stencilFuncMask;\n\t\tthis.stencilFail = source.stencilFail;\n\t\tthis.stencilZFail = source.stencilZFail;\n\t\tthis.stencilZPass = source.stencilZPass;\n\t\tthis.stencilWrite = source.stencilWrite;\n\n\t\tconst srcPlanes = source.clippingPlanes;\n\t\tlet dstPlanes = null;\n\n\t\tif ( srcPlanes !== null ) {\n\n\t\t\tconst n = srcPlanes.length;\n\t\t\tdstPlanes = new Array( n );\n\n\t\t\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.clippingPlanes = dstPlanes;\n\t\tthis.clipIntersection = source.clipIntersection;\n\t\tthis.clipShadows = source.clipShadows;\n\n\t\tthis.shadowSide = source.shadowSide;\n\n\t\tthis.colorWrite = source.colorWrite;\n\n\t\tthis.precision = source.precision;\n\n\t\tthis.polygonOffset = source.polygonOffset;\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\tthis.dithering = source.dithering;\n\n\t\tthis.alphaTest = source.alphaTest;\n\t\tthis.alphaHash = source.alphaHash;\n\t\tthis.alphaToCoverage = source.alphaToCoverage;\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\t\tthis.forceSinglePass = source.forceSinglePass;\n\n\t\tthis.visible = source.visible;\n\n\t\tthis.toneMapped = source.toneMapped;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tonBuild( /* shaderobject, renderer */ ) {\n\n\t\tconsole.warn( 'Material: onBuild() has been removed.' ); // @deprecated, r166\n\n\t}\n\n}\n\nclass MeshBasicMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshBasicMaterial = true;\n\n\t\tthis.type = 'MeshBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // emissive\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\n// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst _tables = /*@__PURE__*/ _generateTables();\n\nfunction _generateTables() {\n\n\t// float32 to float16 helpers\n\n\tconst buffer = new ArrayBuffer( 4 );\n\tconst floatView = new Float32Array( buffer );\n\tconst uint32View = new Uint32Array( buffer );\n\n\tconst baseTable = new Uint32Array( 512 );\n\tconst shiftTable = new Uint32Array( 512 );\n\n\tfor ( let i = 0; i < 256; ++ i ) {\n\n\t\tconst e = i - 127;\n\n\t\t// very small number (0, -0)\n\n\t\tif ( e < - 27 ) {\n\n\t\t\tbaseTable[ i ] = 0x0000;\n\t\t\tbaseTable[ i | 0x100 ] = 0x8000;\n\t\t\tshiftTable[ i ] = 24;\n\t\t\tshiftTable[ i | 0x100 ] = 24;\n\n\t\t\t// small number (denorm)\n\n\t\t} else if ( e < - 14 ) {\n\n\t\t\tbaseTable[ i ] = 0x0400 >> ( - e - 14 );\n\t\t\tbaseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;\n\t\t\tshiftTable[ i ] = - e - 1;\n\t\t\tshiftTable[ i | 0x100 ] = - e - 1;\n\n\t\t\t// normal number\n\n\t\t} else if ( e <= 15 ) {\n\n\t\t\tbaseTable[ i ] = ( e + 15 ) << 10;\n\t\t\tbaseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;\n\t\t\tshiftTable[ i ] = 13;\n\t\t\tshiftTable[ i | 0x100 ] = 13;\n\n\t\t\t// large number (Infinity, -Infinity)\n\n\t\t} else if ( e < 128 ) {\n\n\t\t\tbaseTable[ i ] = 0x7c00;\n\t\t\tbaseTable[ i | 0x100 ] = 0xfc00;\n\t\t\tshiftTable[ i ] = 24;\n\t\t\tshiftTable[ i | 0x100 ] = 24;\n\n\t\t\t// stay (NaN, Infinity, -Infinity)\n\n\t\t} else {\n\n\t\t\tbaseTable[ i ] = 0x7c00;\n\t\t\tbaseTable[ i | 0x100 ] = 0xfc00;\n\t\t\tshiftTable[ i ] = 13;\n\t\t\tshiftTable[ i | 0x100 ] = 13;\n\n\t\t}\n\n\t}\n\n\t// float16 to float32 helpers\n\n\tconst mantissaTable = new Uint32Array( 2048 );\n\tconst exponentTable = new Uint32Array( 64 );\n\tconst offsetTable = new Uint32Array( 64 );\n\n\tfor ( let i = 1; i < 1024; ++ i ) {\n\n\t\tlet m = i << 13; // zero pad mantissa bits\n\t\tlet e = 0; // zero exponent\n\n\t\t// normalized\n\t\twhile ( ( m & 0x00800000 ) === 0 ) {\n\n\t\t\tm <<= 1;\n\t\t\te -= 0x00800000; // decrement exponent\n\n\t\t}\n\n\t\tm &= ~ 0x00800000; // clear leading 1 bit\n\t\te += 0x38800000; // adjust bias\n\n\t\tmantissaTable[ i ] = m | e;\n\n\t}\n\n\tfor ( let i = 1024; i < 2048; ++ i ) {\n\n\t\tmantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );\n\n\t}\n\n\tfor ( let i = 1; i < 31; ++ i ) {\n\n\t\texponentTable[ i ] = i << 23;\n\n\t}\n\n\texponentTable[ 31 ] = 0x47800000;\n\texponentTable[ 32 ] = 0x80000000;\n\n\tfor ( let i = 33; i < 63; ++ i ) {\n\n\t\texponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );\n\n\t}\n\n\texponentTable[ 63 ] = 0xc7800000;\n\n\tfor ( let i = 1; i < 64; ++ i ) {\n\n\t\tif ( i !== 32 ) {\n\n\t\t\toffsetTable[ i ] = 1024;\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tfloatView: floatView,\n\t\tuint32View: uint32View,\n\t\tbaseTable: baseTable,\n\t\tshiftTable: shiftTable,\n\t\tmantissaTable: mantissaTable,\n\t\texponentTable: exponentTable,\n\t\toffsetTable: offsetTable\n\t};\n\n}\n\n// float32 to float16\n\nfunction toHalfFloat( val ) {\n\n\tif ( Math.abs( val ) > 65504 ) console.warn( 'THREE.DataUtils.toHalfFloat(): Value out of range.' );\n\n\tval = clamp( val, - 65504, 65504 );\n\n\t_tables.floatView[ 0 ] = val;\n\tconst f = _tables.uint32View[ 0 ];\n\tconst e = ( f >> 23 ) & 0x1ff;\n\treturn _tables.baseTable[ e ] + ( ( f & 0x007fffff ) >> _tables.shiftTable[ e ] );\n\n}\n\n// float16 to float32\n\nfunction fromHalfFloat( val ) {\n\n\tconst m = val >> 10;\n\t_tables.uint32View[ 0 ] = _tables.mantissaTable[ _tables.offsetTable[ m ] + ( val & 0x3ff ) ] + _tables.exponentTable[ m ];\n\treturn _tables.floatView[ 0 ];\n\n}\n\nconst DataUtils = {\n\ttoHalfFloat: toHalfFloat,\n\tfromHalfFloat: fromHalfFloat,\n};\n\nconst _vector$9 = /*@__PURE__*/ new Vector3();\nconst _vector2$1 = /*@__PURE__*/ new Vector2();\n\nclass BufferAttribute {\n\n\tconstructor( array, itemSize, normalized = false ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\tthis.isBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.array = array;\n\t\tthis.itemSize = itemSize;\n\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\tthis.normalized = normalized;\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.updateRanges = [];\n\t\tthis.gpuType = FloatType;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tonUploadCallback() {}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\taddUpdateRange( start, count ) {\n\n\t\tthis.updateRanges.push( { start, count } );\n\n\t}\n\n\tclearUpdateRanges() {\n\n\t\tthis.updateRanges.length = 0;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.itemSize = source.itemSize;\n\t\tthis.count = source.count;\n\t\tthis.normalized = source.normalized;\n\n\t\tthis.usage = source.usage;\n\t\tthis.gpuType = source.gpuType;\n\n\t\treturn this;\n\n\t}\n\n\tcopyAt( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.itemSize;\n\t\tindex2 *= attribute.itemSize;\n\n\t\tfor ( let i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcopyArray( array ) {\n\n\t\tthis.array.set( array );\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tif ( this.itemSize === 2 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector2$1.fromBufferAttribute( this, i );\n\t\t\t\t_vector2$1.applyMatrix3( m );\n\n\t\t\t\tthis.setXY( i, _vector2$1.x, _vector2$1.y );\n\n\t\t\t}\n\n\t\t} else if ( this.itemSize === 3 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector$9.fromBufferAttribute( this, i );\n\t\t\t\t_vector$9.applyMatrix3( m );\n\n\t\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.fromBufferAttribute( this, i );\n\n\t\t\t_vector$9.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.fromBufferAttribute( this, i );\n\n\t\t\t_vector$9.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.fromBufferAttribute( this, i );\n\n\t\t\t_vector$9.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tset( value, offset = 0 ) {\n\n\t\t// Matching BufferAttribute constructor, do not normalize the array.\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index, component ) {\n\n\t\tlet value = this.array[ index * this.itemSize + component ];\n\n\t\tif ( this.normalized ) value = denormalize( value, this.array );\n\n\t\treturn value;\n\n\t}\n\n\tsetComponent( index, component, value ) {\n\n\t\tif ( this.normalized ) value = normalize( value, this.array );\n\n\t\tthis.array[ index * this.itemSize + component ] = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = this.array[ index * this.itemSize ];\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\treturn this;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = this.array[ index * this.itemSize + 1 ];\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = this.array[ index * this.itemSize + 2 ];\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = this.array[ index * this.itemSize + 3 ];\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\t\tthis.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tonUpload( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.array, this.itemSize ).copy( this );\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\titemSize: this.itemSize,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tarray: Array.from( this.array ),\n\t\t\tnormalized: this.normalized\n\t\t};\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( this.usage !== StaticDrawUsage ) data.usage = this.usage;\n\n\t\treturn data;\n\n\t}\n\n}\n\n//\n\nclass Int8BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int8Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint8BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint8Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint8ClampedBufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint8ClampedArray( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Int16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Int32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Float16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint16Array( array ), itemSize, normalized );\n\n\t\tthis.isFloat16BufferAttribute = true;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = fromHalfFloat( this.array[ index * this.itemSize ] );\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.array[ index * this.itemSize ] = toHalfFloat( x );\n\n\t\treturn this;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = fromHalfFloat( this.array[ index * this.itemSize + 1 ] );\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.array[ index * this.itemSize + 1 ] = toHalfFloat( y );\n\n\t\treturn this;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = fromHalfFloat( this.array[ index * this.itemSize + 2 ] );\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.array[ index * this.itemSize + 2 ] = toHalfFloat( z );\n\n\t\treturn this;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = fromHalfFloat( this.array[ index * this.itemSize + 3 ] );\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.array[ index * this.itemSize + 3 ] = toHalfFloat( w );\n\n\t\treturn this;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\t\tthis.array[ index + 2 ] = toHalfFloat( z );\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\t\tthis.array[ index + 2 ] = toHalfFloat( z );\n\t\tthis.array[ index + 3 ] = toHalfFloat( w );\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nclass Float32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Float32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nlet _id$1 = 0;\n\nconst _m1 = /*@__PURE__*/ new Matrix4();\nconst _obj = /*@__PURE__*/ new Object3D();\nconst _offset = /*@__PURE__*/ new Vector3();\nconst _box$2 = /*@__PURE__*/ new Box3();\nconst _boxMorphTargets = /*@__PURE__*/ new Box3();\nconst _vector$8 = /*@__PURE__*/ new Vector3();\n\nclass BufferGeometry extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isBufferGeometry = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _id$1 ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\tthis.index = null;\n\t\tthis.indirect = null;\n\t\tthis.attributes = {};\n\n\t\tthis.morphAttributes = {};\n\t\tthis.morphTargetsRelative = false;\n\n\t\tthis.groups = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\tthis.userData = {};\n\n\t}\n\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute === undefined ) {\n\n\t\t\tconst position = [];\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t} else {\n\n\t\t\tconst l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tpositionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tif ( points.length > positionAttribute.count ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );\n\n\t\t\t}\n\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box$2.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector$8.addVectors( this.boundingBox.min, _box$2.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector$8 );\n\n\t\t\t\t\t\t_vector$8.addVectors( this.boundingBox.max, _box$2.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector$8 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box$2.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box$2.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box$2.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector$8.addVectors( _box$2.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box$2.expandByPoint( _vector$8 );\n\n\t\t\t\t\t\t_vector$8.addVectors( _box$2.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box$2.expandByPoint( _vector$8 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box$2.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box$2.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box$2.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector$8.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector$8.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector$8.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst positionAttribute = attributes.position;\n\t\tconst normalAttribute = attributes.normal;\n\t\tconst uvAttribute = attributes.uv;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );\n\n\t\t}\n\n\t\tconst tangentAttribute = this.getAttribute( 'tangent' );\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: index.count\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindex.getX( j + 0 ),\n\t\t\t\t\tindex.getX( j + 1 ),\n\t\t\t\t\tindex.getX( j + 2 )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( index.getX( j + 0 ) );\n\t\t\t\thandleVertex( index.getX( j + 1 ) );\n\t\t\t\thandleVertex( index.getX( j + 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tnormalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector$8.fromBufferAttribute( normals, i );\n\n\t\t\t_vector$8.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );\n\n\t\t}\n\n\t}\n\n\ttoNonIndexed() {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// used for storing cloned, shared data\n\n\t\tconst data = {};\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tconst index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone( data ) );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst attributes = source.attributes;\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = source.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = source.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nconst _inverseMatrix$3 = /*@__PURE__*/ new Matrix4();\nconst _ray$3 = /*@__PURE__*/ new Ray();\nconst _sphere$6 = /*@__PURE__*/ new Sphere();\nconst _sphereHitAt = /*@__PURE__*/ new Vector3();\n\nconst _vA$1 = /*@__PURE__*/ new Vector3();\nconst _vB$1 = /*@__PURE__*/ new Vector3();\nconst _vC$1 = /*@__PURE__*/ new Vector3();\n\nconst _tempA = /*@__PURE__*/ new Vector3();\nconst _morphA = /*@__PURE__*/ new Vector3();\n\nconst _intersectionPoint = /*@__PURE__*/ new Vector3();\nconst _intersectionPointWorld = /*@__PURE__*/ new Vector3();\n\nclass Mesh extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isMesh = true;\n\n\t\tthis.type = 'Mesh';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.morphTargetInfluences !== undefined ) {\n\n\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\n\t\t}\n\n\t\tif ( source.morphTargetDictionary !== undefined ) {\n\n\t\t\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\n\n\t\t}\n\n\t\tthis.material = Array.isArray( source.material ) ? source.material.slice() : source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetVertexPosition( index, target ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst position = geometry.attributes.position;\n\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\n\t\ttarget.fromBufferAttribute( position, index );\n\n\t\tconst morphInfluences = this.morphTargetInfluences;\n\n\t\tif ( morphPosition && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphPosition.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morphAttribute = morphPosition[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morphAttribute, index );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( target ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttarget.add( _morphA );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// test with bounding sphere in world space\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere$6.copy( geometry.boundingSphere );\n\t\t_sphere$6.applyMatrix4( matrixWorld );\n\n\t\t// check distance from ray origin to bounding sphere\n\n\t\t_ray$3.copy( raycaster.ray ).recast( raycaster.near );\n\n\t\tif ( _sphere$6.containsPoint( _ray$3.origin ) === false ) {\n\n\t\t\tif ( _ray$3.intersectSphere( _sphere$6, _sphereHitAt ) === null ) return;\n\n\t\t\tif ( _ray$3.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;\n\n\t\t}\n\n\t\t// convert ray to local space of mesh\n\n\t\t_inverseMatrix$3.copy( matrixWorld ).invert();\n\t\t_ray$3.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$3 );\n\n\t\t// test with bounding box in local space\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tif ( _ray$3.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\t// test for intersections with geometry\n\n\t\tthis._computeIntersections( raycaster, intersects, _ray$3 );\n\n\t}\n\n\t_computeIntersections( raycaster, intersects, rayLocalSpace ) {\n\n\t\tlet intersection;\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\tconst index = geometry.index;\n\t\tconst position = geometry.attributes.position;\n\t\tconst uv = geometry.attributes.uv;\n\t\tconst uv1 = geometry.attributes.uv1;\n\t\tconst normal = geometry.attributes.normal;\n\t\tconst groups = geometry.groups;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\tif ( index !== null ) {\n\n\t\t\t// indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\tconst end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );\n\n\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\tconst a = index.getX( j );\n\t\t\t\t\t\tconst b = index.getX( j + 1 );\n\t\t\t\t\t\tconst c = index.getX( j + 2 );\n\n\t\t\t\t\t\tintersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\tconst a = index.getX( i );\n\t\t\t\t\tconst b = index.getX( i + 1 );\n\t\t\t\t\tconst c = index.getX( i + 2 );\n\n\t\t\t\t\tintersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( position !== undefined ) {\n\n\t\t\t// non-indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\tconst end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );\n\n\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\tconst a = j;\n\t\t\t\t\t\tconst b = j + 1;\n\t\t\t\t\t\tconst c = j + 2;\n\n\t\t\t\t\t\tintersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( position.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\tconst a = i;\n\t\t\t\t\tconst b = i + 1;\n\t\t\t\t\tconst c = i + 2;\n\n\t\t\t\t\tintersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction checkIntersection$1( object, material, raycaster, ray, pA, pB, pC, point ) {\n\n\tlet intersect;\n\n\tif ( material.side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\t_intersectionPointWorld.copy( point );\n\t_intersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );\n\n\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\treturn {\n\t\tdistance: distance,\n\t\tpoint: _intersectionPointWorld.clone(),\n\t\tobject: object\n\t};\n\n}\n\nfunction checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {\n\n\tobject.getVertexPosition( a, _vA$1 );\n\tobject.getVertexPosition( b, _vB$1 );\n\tobject.getVertexPosition( c, _vC$1 );\n\n\tconst intersection = checkIntersection$1( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );\n\n\tif ( intersection ) {\n\n\t\tconst barycoord = new Vector3();\n\t\tTriangle.getBarycoord( _intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord );\n\n\t\tif ( uv ) {\n\n\t\t\tintersection.uv = Triangle.getInterpolatedAttribute( uv, a, b, c, barycoord, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\tintersection.uv1 = Triangle.getInterpolatedAttribute( uv1, a, b, c, barycoord, new Vector2() );\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\tintersection.normal = Triangle.getInterpolatedAttribute( normal, a, b, c, barycoord, new Vector3() );\n\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.barycoord = barycoord;\n\n\t}\n\n\treturn intersection;\n\n}\n\nclass BoxGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'BoxGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tconst scope = this;\n\n\t\t// segments\n\n\t\twidthSegments = Math.floor( widthSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\t\tdepthSegments = Math.floor( depthSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet numberOfVertices = 0;\n\t\tlet groupStart = 0;\n\n\t\t// build each side of the box geometry\n\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tconst segmentWidth = width / gridX;\n\t\t\tconst segmentHeight = height / gridY;\n\n\t\t\tconst widthHalf = width / 2;\n\t\t\tconst heightHalf = height / 2;\n\t\t\tconst depthHalf = depth / 2;\n\n\t\t\tconst gridX1 = gridX + 1;\n\t\t\tconst gridY1 = gridY + 1;\n\n\t\t\tlet vertexCounter = 0;\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tconst y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tconst x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\n\t\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\n\t\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t\t\t// counters\n\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\tconst a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tconst b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// increase counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );\n\n\t}\n\n}\n\n/**\n * Uniform Utilities\n */\n\nfunction cloneUniforms( src ) {\n\n\tconst dst = {};\n\n\tfor ( const u in src ) {\n\n\t\tdst[ u ] = {};\n\n\t\tfor ( const p in src[ u ] ) {\n\n\t\t\tconst property = src[ u ][ p ];\n\n\t\t\tif ( property && ( property.isColor ||\n\t\t\t\tproperty.isMatrix3 || property.isMatrix4 ||\n\t\t\t\tproperty.isVector2 || property.isVector3 || property.isVector4 ||\n\t\t\t\tproperty.isTexture || property.isQuaternion ) ) {\n\n\t\t\t\tif ( property.isRenderTargetTexture ) {\n\n\t\t\t\t\tconsole.warn( 'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().' );\n\t\t\t\t\tdst[ u ][ p ] = null;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdst[ u ][ p ] = property.clone();\n\n\t\t\t\t}\n\n\t\t\t} else if ( Array.isArray( property ) ) {\n\n\t\t\t\tdst[ u ][ p ] = property.slice();\n\n\t\t\t} else {\n\n\t\t\t\tdst[ u ][ p ] = property;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn dst;\n\n}\n\nfunction mergeUniforms( uniforms ) {\n\n\tconst merged = {};\n\n\tfor ( let u = 0; u < uniforms.length; u ++ ) {\n\n\t\tconst tmp = cloneUniforms( uniforms[ u ] );\n\n\t\tfor ( const p in tmp ) {\n\n\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t}\n\n\t}\n\n\treturn merged;\n\n}\n\nfunction cloneUniformsGroups( src ) {\n\n\tconst dst = [];\n\n\tfor ( let u = 0; u < src.length; u ++ ) {\n\n\t\tdst.push( src[ u ].clone() );\n\n\t}\n\n\treturn dst;\n\n}\n\nfunction getUnlitUniformColorSpace( renderer ) {\n\n\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\tif ( currentRenderTarget === null ) {\n\n\t\t// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398\n\t\treturn renderer.outputColorSpace;\n\n\t}\n\n\t// https://github.com/mrdoob/three.js/issues/27868\n\tif ( currentRenderTarget.isXRRenderTarget === true ) {\n\n\t\treturn currentRenderTarget.texture.colorSpace;\n\n\t}\n\n\treturn ColorManagement.workingColorSpace;\n\n}\n\n// Legacy\n\nconst UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };\n\nvar default_vertex = \"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";\n\nvar default_fragment = \"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";\n\nclass ShaderMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isShaderMaterial = true;\n\n\t\tthis.type = 'ShaderMaterial';\n\n\t\tthis.defines = {};\n\t\tthis.uniforms = {};\n\t\tthis.uniformsGroups = [];\n\n\t\tthis.vertexShader = default_vertex;\n\t\tthis.fragmentShader = default_fragment;\n\n\t\tthis.linewidth = 1;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false; // set to use scene fog\n\t\tthis.lights = false; // set to use scene lights\n\t\tthis.clipping = false; // set to use user-defined clipping planes\n\n\t\tthis.forceSinglePass = true;\n\n\t\tthis.extensions = {\n\t\t\tclipCullDistance: false, // set to use vertex shader clipping\n\t\t\tmultiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID\n\t\t};\n\n\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\tthis.defaultAttributeValues = {\n\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t'uv': [ 0, 0 ],\n\t\t\t'uv1': [ 0, 0 ]\n\t\t};\n\n\t\tthis.index0AttributeName = undefined;\n\t\tthis.uniformsNeedUpdate = false;\n\n\t\tthis.glslVersion = null;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tthis.setValues( parameters );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.fragmentShader = source.fragmentShader;\n\t\tthis.vertexShader = source.vertexShader;\n\n\t\tthis.uniforms = cloneUniforms( source.uniforms );\n\t\tthis.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );\n\n\t\tthis.defines = Object.assign( {}, source.defines );\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.fog = source.fog;\n\t\tthis.lights = source.lights;\n\t\tthis.clipping = source.clipping;\n\n\t\tthis.extensions = Object.assign( {}, source.extensions );\n\n\t\tthis.glslVersion = source.glslVersion;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.glslVersion = this.glslVersion;\n\t\tdata.uniforms = {};\n\n\t\tfor ( const name in this.uniforms ) {\n\n\t\t\tconst uniform = this.uniforms[ name ];\n\t\t\tconst value = uniform.value;\n\n\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 't',\n\t\t\t\t\tvalue: value.toJSON( meta ).uuid\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isColor ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'c',\n\t\t\t\t\tvalue: value.getHex()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector2 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v2',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector3 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v3',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector4 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v4',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isMatrix3 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'm3',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isMatrix4 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'm4',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\tvalue: value\n\t\t\t\t};\n\n\t\t\t\t// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;\n\n\t\tdata.vertexShader = this.vertexShader;\n\t\tdata.fragmentShader = this.fragmentShader;\n\n\t\tdata.lights = this.lights;\n\t\tdata.clipping = this.clipping;\n\n\t\tconst extensions = {};\n\n\t\tfor ( const key in this.extensions ) {\n\n\t\t\tif ( this.extensions[ key ] === true ) extensions[ key ] = true;\n\n\t\t}\n\n\t\tif ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass Camera extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isCamera = true;\n\n\t\tthis.type = 'Camera';\n\n\t\tthis.matrixWorldInverse = new Matrix4();\n\n\t\tthis.projectionMatrix = new Matrix4();\n\t\tthis.projectionMatrixInverse = new Matrix4();\n\n\t\tthis.coordinateSystem = WebGLCoordinateSystem;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\t\tthis.projectionMatrixInverse.copy( source.projectionMatrixInverse );\n\n\t\tthis.coordinateSystem = source.coordinateSystem;\n\n\t\treturn this;\n\n\t}\n\n\tgetWorldDirection( target ) {\n\n\t\treturn super.getWorldDirection( target ).negate();\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tsuper.updateWorldMatrix( updateParents, updateChildren );\n\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _v3$1 = /*@__PURE__*/ new Vector3();\nconst _minTarget = /*@__PURE__*/ new Vector2();\nconst _maxTarget = /*@__PURE__*/ new Vector2();\n\n\nclass PerspectiveCamera extends Camera {\n\n\tconstructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\tthis.isPerspectiveCamera = true;\n\n\t\tthis.type = 'PerspectiveCamera';\n\n\t\tthis.fov = fov;\n\t\tthis.zoom = 1;\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\t\tthis.focus = 10;\n\n\t\tthis.aspect = aspect;\n\t\tthis.view = null;\n\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * @param {number} focalLength - Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength( focalLength ) {\n\n\t\t/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n\t\tconst vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t *\n\t * @returns {number}\n\t */\n\tgetFocalLength() {\n\n\t\tconst vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t}\n\n\tgetEffectiveFOV() {\n\n\t\treturn RAD2DEG * 2 * Math.atan(\n\t\t\tMath.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t}\n\n\tgetFilmWidth() {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t}\n\n\tgetFilmHeight() {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t}\n\n\t/**\n\t * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.\n\t * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.\n\t *\n\t * @param {number} distance\n\t * @param {Vector2} minTarget\n\t * @param {Vector2} maxTarget\n\t */\n\tgetViewBounds( distance, minTarget, maxTarget ) {\n\n\t\t_v3$1.set( - 1, - 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );\n\n\t\tminTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );\n\n\t\t_v3$1.set( 1, 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );\n\n\t\tmaxTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );\n\n\t}\n\n\t/**\n\t * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.\n\t *\n\t * @param {number} distance\n\t * @param {Vector2} target - Vector2 target used to store result where x is width and y is height.\n\t * @returns {Vector2}\n\t */\n\tgetViewSize( distance, target ) {\n\n\t\tthis.getViewBounds( distance, _minTarget, _maxTarget );\n\n\t\treturn target.subVectors( _maxTarget, _minTarget );\n\n\t}\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   const w = 1920;\n\t *   const h = 1080;\n\t *   const fullWidth = w * 3;\n\t *   const fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t *\n\t * @param {number} fullWidth\n\t * @param {number} fullHeight\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} width\n\t * @param {number} height\n\t */\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tupdateProjectionMatrix() {\n\n\t\tconst near = this.near;\n\t\tlet top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;\n\t\tlet height = 2 * top;\n\t\tlet width = this.aspect * height;\n\t\tlet left = - 0.5 * width;\n\t\tconst view = this.view;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tconst skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst fov = - 90; // negative fov is not an error\nconst aspect = 1;\n\nclass CubeCamera extends Object3D {\n\n\tconstructor( near, far, renderTarget ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CubeCamera';\n\n\t\tthis.renderTarget = renderTarget;\n\t\tthis.coordinateSystem = null;\n\t\tthis.activeMipmapLevel = 0;\n\n\t\tconst cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPX.layers = this.layers;\n\t\tthis.add( cameraPX );\n\n\t\tconst cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNX.layers = this.layers;\n\t\tthis.add( cameraNX );\n\n\t\tconst cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPY.layers = this.layers;\n\t\tthis.add( cameraPY );\n\n\t\tconst cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNY.layers = this.layers;\n\t\tthis.add( cameraNY );\n\n\t\tconst cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPZ.layers = this.layers;\n\t\tthis.add( cameraPZ );\n\n\t\tconst cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNZ.layers = this.layers;\n\t\tthis.add( cameraNZ );\n\n\t}\n\n\tupdateCoordinateSystem() {\n\n\t\tconst coordinateSystem = this.coordinateSystem;\n\n\t\tconst cameras = this.children.concat();\n\n\t\tconst [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;\n\n\t\tfor ( const camera of cameras ) this.remove( camera );\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tcameraPX.up.set( 0, 1, 0 );\n\t\t\tcameraPX.lookAt( 1, 0, 0 );\n\n\t\t\tcameraNX.up.set( 0, 1, 0 );\n\t\t\tcameraNX.lookAt( - 1, 0, 0 );\n\n\t\t\tcameraPY.up.set( 0, 0, - 1 );\n\t\t\tcameraPY.lookAt( 0, 1, 0 );\n\n\t\t\tcameraNY.up.set( 0, 0, 1 );\n\t\t\tcameraNY.lookAt( 0, - 1, 0 );\n\n\t\t\tcameraPZ.up.set( 0, 1, 0 );\n\t\t\tcameraPZ.lookAt( 0, 0, 1 );\n\n\t\t\tcameraNZ.up.set( 0, 1, 0 );\n\t\t\tcameraNZ.lookAt( 0, 0, - 1 );\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\t\tcameraPX.lookAt( - 1, 0, 0 );\n\n\t\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\t\tcameraNX.lookAt( 1, 0, 0 );\n\n\t\t\tcameraPY.up.set( 0, 0, 1 );\n\t\t\tcameraPY.lookAt( 0, 1, 0 );\n\n\t\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\t\tcameraNY.lookAt( 0, - 1, 0 );\n\n\t\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\t\tcameraPZ.lookAt( 0, 0, 1 );\n\n\t\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\t\tcameraNZ.lookAt( 0, 0, - 1 );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tfor ( const camera of cameras ) {\n\n\t\t\tthis.add( camera );\n\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t}\n\n\t}\n\n\tupdate( renderer, scene ) {\n\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\tconst { renderTarget, activeMipmapLevel } = this;\n\n\t\tif ( this.coordinateSystem !== renderer.coordinateSystem ) {\n\n\t\t\tthis.coordinateSystem = renderer.coordinateSystem;\n\n\t\t\tthis.updateCoordinateSystem();\n\n\t\t}\n\n\t\tconst [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentActiveCubeFace = renderer.getActiveCubeFace();\n\t\tconst currentActiveMipmapLevel = renderer.getActiveMipmapLevel();\n\n\t\tconst currentXrEnabled = renderer.xr.enabled;\n\n\t\trenderer.xr.enabled = false;\n\n\t\tconst generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\trenderer.setRenderTarget( renderTarget, 0, activeMipmapLevel );\n\t\trenderer.render( scene, cameraPX );\n\n\t\trenderer.setRenderTarget( renderTarget, 1, activeMipmapLevel );\n\t\trenderer.render( scene, cameraNX );\n\n\t\trenderer.setRenderTarget( renderTarget, 2, activeMipmapLevel );\n\t\trenderer.render( scene, cameraPY );\n\n\t\trenderer.setRenderTarget( renderTarget, 3, activeMipmapLevel );\n\t\trenderer.render( scene, cameraNY );\n\n\t\trenderer.setRenderTarget( renderTarget, 4, activeMipmapLevel );\n\t\trenderer.render( scene, cameraPZ );\n\n\t\t// mipmaps are generated during the last call of render()\n\t\t// at this point, all sides of the cube render target are defined\n\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\trenderer.setRenderTarget( renderTarget, 5, activeMipmapLevel );\n\t\trenderer.render( scene, cameraNZ );\n\n\t\trenderer.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );\n\n\t\trenderer.xr.enabled = currentXrEnabled;\n\n\t\trenderTarget.texture.needsPMREMUpdate = true;\n\n\t}\n\n}\n\nclass CubeTexture extends Texture {\n\n\tconstructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace ) {\n\n\t\timages = images !== undefined ? images : [];\n\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\n\t\tsuper( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isCubeTexture = true;\n\n\t\tthis.flipY = false;\n\n\t}\n\n\tget images() {\n\n\t\treturn this.image;\n\n\t}\n\n\tset images( value ) {\n\n\t\tthis.image = value;\n\n\t}\n\n}\n\nclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( size = 1, options = {} ) {\n\n\t\tsuper( size, size, options );\n\n\t\tthis.isWebGLCubeRenderTarget = true;\n\n\t\tconst image = { width: size, height: size, depth: 1 };\n\t\tconst images = [ image, image, image, image, image, image ];\n\n\t\tthis.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );\n\n\t\t// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n\t\t// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n\t\t// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n\n\t\t// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n\t\t// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture\n\t\t// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\n\t}\n\n\tfromEquirectangularTexture( renderer, texture ) {\n\n\t\tthis.texture.type = texture.type;\n\t\tthis.texture.colorSpace = texture.colorSpace;\n\n\t\tthis.texture.generateMipmaps = texture.generateMipmaps;\n\t\tthis.texture.minFilter = texture.minFilter;\n\t\tthis.texture.magFilter = texture.magFilter;\n\n\t\tconst shader = {\n\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: { value: null },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n\t\t};\n\n\t\tconst geometry = new BoxGeometry( 5, 5, 5 );\n\n\t\tconst material = new ShaderMaterial( {\n\n\t\t\tname: 'CubemapFromEquirect',\n\n\t\t\tuniforms: cloneUniforms( shader.uniforms ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tside: BackSide,\n\t\t\tblending: NoBlending\n\n\t\t} );\n\n\t\tmaterial.uniforms.tEquirect.value = texture;\n\n\t\tconst mesh = new Mesh( geometry, material );\n\n\t\tconst currentMinFilter = texture.minFilter;\n\n\t\t// Avoid blurred poles\n\t\tif ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;\n\n\t\tconst camera = new CubeCamera( 1, 10, this );\n\t\tcamera.update( renderer, mesh );\n\n\t\ttexture.minFilter = currentMinFilter;\n\n\t\tmesh.geometry.dispose();\n\t\tmesh.material.dispose();\n\n\t\treturn this;\n\n\t}\n\n\tclear( renderer, color, depth, stencil ) {\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\trenderer.setRenderTarget( this, i );\n\n\t\t\trenderer.clear( color, depth, stencil );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n}\n\nclass FogExp2 {\n\n\tconstructor( color, density = 0.00025 ) {\n\n\t\tthis.isFogExp2 = true;\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\t\tthis.density = density;\n\n\t}\n\n\tclone() {\n\n\t\treturn new FogExp2( this.color, this.density );\n\n\t}\n\n\ttoJSON( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'FogExp2',\n\t\t\tname: this.name,\n\t\t\tcolor: this.color.getHex(),\n\t\t\tdensity: this.density\n\t\t};\n\n\t}\n\n}\n\nclass Fog {\n\n\tconstructor( color, near = 1, far = 1000 ) {\n\n\t\tthis.isFog = true;\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Fog( this.color, this.near, this.far );\n\n\t}\n\n\ttoJSON( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'Fog',\n\t\t\tname: this.name,\n\t\t\tcolor: this.color.getHex(),\n\t\t\tnear: this.near,\n\t\t\tfar: this.far\n\t\t};\n\n\t}\n\n}\n\nclass Scene extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isScene = true;\n\n\t\tthis.type = 'Scene';\n\n\t\tthis.background = null;\n\t\tthis.environment = null;\n\t\tthis.fog = null;\n\n\t\tthis.backgroundBlurriness = 0;\n\t\tthis.backgroundIntensity = 1;\n\t\tthis.backgroundRotation = new Euler();\n\n\t\tthis.environmentIntensity = 1;\n\t\tthis.environmentRotation = new Euler();\n\n\t\tthis.overrideMaterial = null;\n\n\t\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\tif ( source.environment !== null ) this.environment = source.environment.clone();\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\n\t\tthis.backgroundBlurriness = source.backgroundBlurriness;\n\t\tthis.backgroundIntensity = source.backgroundIntensity;\n\t\tthis.backgroundRotation.copy( source.backgroundRotation );\n\n\t\tthis.environmentIntensity = source.environmentIntensity;\n\t\tthis.environmentRotation.copy( source.environmentRotation );\n\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\n\t\tif ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;\n\t\tif ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;\n\t\tdata.object.backgroundRotation = this.backgroundRotation.toArray();\n\n\t\tif ( this.environmentIntensity !== 1 ) data.object.environmentIntensity = this.environmentIntensity;\n\t\tdata.object.environmentRotation = this.environmentRotation.toArray();\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass InterleavedBuffer {\n\n\tconstructor( array, stride ) {\n\n\t\tthis.isInterleavedBuffer = true;\n\n\t\tthis.array = array;\n\t\tthis.stride = stride;\n\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.updateRanges = [];\n\n\t\tthis.version = 0;\n\n\t\tthis.uuid = generateUUID();\n\n\t}\n\n\tonUploadCallback() {}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\taddUpdateRange( start, count ) {\n\n\t\tthis.updateRanges.push( { start, count } );\n\n\t}\n\n\tclearUpdateRanges() {\n\n\t\tthis.updateRanges.length = 0;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.count = source.count;\n\t\tthis.stride = source.stride;\n\t\tthis.usage = source.usage;\n\n\t\treturn this;\n\n\t}\n\n\tcopyAt( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.stride;\n\t\tindex2 *= attribute.stride;\n\n\t\tfor ( let i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tset( value, offset = 0 ) {\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tif ( data.arrayBuffers === undefined ) {\n\n\t\t\tdata.arrayBuffers = {};\n\n\t\t}\n\n\t\tif ( this.array.buffer._uuid === undefined ) {\n\n\t\t\tthis.array.buffer._uuid = generateUUID();\n\n\t\t}\n\n\t\tif ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {\n\n\t\t\tdata.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;\n\n\t\t}\n\n\t\tconst array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );\n\n\t\tconst ib = new this.constructor( array, this.stride );\n\t\tib.setUsage( this.usage );\n\n\t\treturn ib;\n\n\t}\n\n\tonUpload( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tif ( data.arrayBuffers === undefined ) {\n\n\t\t\tdata.arrayBuffers = {};\n\n\t\t}\n\n\t\t// generate UUID for array buffer if necessary\n\n\t\tif ( this.array.buffer._uuid === undefined ) {\n\n\t\t\tthis.array.buffer._uuid = generateUUID();\n\n\t\t}\n\n\t\tif ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {\n\n\t\t\tdata.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );\n\n\t\t}\n\n\t\t//\n\n\t\treturn {\n\t\t\tuuid: this.uuid,\n\t\t\tbuffer: this.array.buffer._uuid,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tstride: this.stride\n\t\t};\n\n\t}\n\n}\n\nconst _vector$7 = /*@__PURE__*/ new Vector3();\n\nclass InterleavedBufferAttribute {\n\n\tconstructor( interleavedBuffer, itemSize, offset, normalized = false ) {\n\n\t\tthis.isInterleavedBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.data = interleavedBuffer;\n\t\tthis.itemSize = itemSize;\n\t\tthis.offset = offset;\n\n\t\tthis.normalized = normalized;\n\n\t}\n\n\tget count() {\n\n\t\treturn this.data.count;\n\n\t}\n\n\tget array() {\n\n\t\treturn this.data.array;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tthis.data.needsUpdate = value;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tfor ( let i = 0, l = this.data.count; i < l; i ++ ) {\n\n\t\t\t_vector$7.fromBufferAttribute( this, i );\n\n\t\t\t_vector$7.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$7.fromBufferAttribute( this, i );\n\n\t\t\t_vector$7.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$7.fromBufferAttribute( this, i );\n\n\t\t\t_vector$7.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index, component ) {\n\n\t\tlet value = this.array[ index * this.data.stride + this.offset + component ];\n\n\t\tif ( this.normalized ) value = denormalize( value, this.array );\n\n\t\treturn value;\n\n\t}\n\n\tsetComponent( index, component, value ) {\n\n\t\tif ( this.normalized ) value = normalize( value, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + component ] = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = this.data.array[ index * this.data.stride + this.offset ];\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\t\tthis.data.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconsole.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n\t\t\t\t\tarray.push( this.data.array[ index + j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );\n\n\t\t} else {\n\n\t\t\tif ( data.interleavedBuffers === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers = {};\n\n\t\t\t}\n\n\t\t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );\n\n\t\t\t}\n\n\t\t\treturn new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );\n\n\t\t}\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconsole.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n\t\t\t\t\tarray.push( this.data.array[ index + j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// de-interleave data and save it as an ordinary buffer attribute for now\n\n\t\t\treturn {\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\ttype: this.array.constructor.name,\n\t\t\t\tarray: array,\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\n\t\t} else {\n\n\t\t\t// save as true interleaved attribute\n\n\t\t\tif ( data.interleavedBuffers === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers = {};\n\n\t\t\t}\n\n\t\t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tisInterleavedBufferAttribute: true,\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\tdata: this.data.uuid,\n\t\t\t\toffset: this.offset,\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\n\t\t}\n\n\t}\n\n}\n\nclass SpriteMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isSpriteMaterial = true;\n\n\t\tthis.type = 'SpriteMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.rotation = 0;\n\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.transparent = true;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nlet _geometry;\n\nconst _intersectPoint = /*@__PURE__*/ new Vector3();\nconst _worldScale = /*@__PURE__*/ new Vector3();\nconst _mvPosition = /*@__PURE__*/ new Vector3();\n\nconst _alignedPosition = /*@__PURE__*/ new Vector2();\nconst _rotatedPosition = /*@__PURE__*/ new Vector2();\nconst _viewWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _vA = /*@__PURE__*/ new Vector3();\nconst _vB = /*@__PURE__*/ new Vector3();\nconst _vC = /*@__PURE__*/ new Vector3();\n\nconst _uvA = /*@__PURE__*/ new Vector2();\nconst _uvB = /*@__PURE__*/ new Vector2();\nconst _uvC = /*@__PURE__*/ new Vector2();\n\nclass Sprite extends Object3D {\n\n\tconstructor( material = new SpriteMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isSprite = true;\n\n\t\tthis.type = 'Sprite';\n\n\t\tif ( _geometry === undefined ) {\n\n\t\t\t_geometry = new BufferGeometry();\n\n\t\t\tconst float32Array = new Float32Array( [\n\t\t\t\t- 0.5, - 0.5, 0, 0, 0,\n\t\t\t\t0.5, - 0.5, 0, 1, 0,\n\t\t\t\t0.5, 0.5, 0, 1, 1,\n\t\t\t\t- 0.5, 0.5, 0, 0, 1\n\t\t\t] );\n\n\t\t\tconst interleavedBuffer = new InterleavedBuffer( float32Array, 5 );\n\n\t\t\t_geometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\n\t\t\t_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\n\t\t\t_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\n\n\t\t}\n\n\t\tthis.geometry = _geometry;\n\t\tthis.material = material;\n\n\t\tthis.center = new Vector2( 0.5, 0.5 );\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( raycaster.camera === null ) {\n\n\t\t\tconsole.error( 'THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.' );\n\n\t\t}\n\n\t\t_worldScale.setFromMatrixScale( this.matrixWorld );\n\n\t\t_viewWorldMatrix.copy( raycaster.camera.matrixWorld );\n\t\tthis.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );\n\n\t\t_mvPosition.setFromMatrixPosition( this.modelViewMatrix );\n\n\t\tif ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {\n\n\t\t\t_worldScale.multiplyScalar( - _mvPosition.z );\n\n\t\t}\n\n\t\tconst rotation = this.material.rotation;\n\t\tlet sin, cos;\n\n\t\tif ( rotation !== 0 ) {\n\n\t\t\tcos = Math.cos( rotation );\n\t\t\tsin = Math.sin( rotation );\n\n\t\t}\n\n\t\tconst center = this.center;\n\n\t\ttransformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\ttransformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\ttransformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\n\t\t_uvA.set( 0, 0 );\n\t\t_uvB.set( 1, 0 );\n\t\t_uvC.set( 1, 1 );\n\n\t\t// check first triangle\n\t\tlet intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );\n\n\t\tif ( intersect === null ) {\n\n\t\t\t// check second triangle\n\t\t\ttransformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\t\t_uvB.set( 0, 1 );\n\n\t\t\tintersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );\n\t\t\tif ( intersect === null ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( _intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tpoint: _intersectPoint.clone(),\n\t\t\tuv: Triangle.getInterpolation( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),\n\t\t\tface: null,\n\t\t\tobject: this\n\n\t\t} );\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.center !== undefined ) this.center.copy( source.center );\n\n\t\tthis.material = source.material;\n\n\t\treturn this;\n\n\t}\n\n}\n\nfunction transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {\n\n\t// compute position in camera space\n\t_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );\n\n\t// to check if rotation is not zero\n\tif ( sin !== undefined ) {\n\n\t\t_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );\n\t\t_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );\n\n\t} else {\n\n\t\t_rotatedPosition.copy( _alignedPosition );\n\n\t}\n\n\n\tvertexPosition.copy( mvPosition );\n\tvertexPosition.x += _rotatedPosition.x;\n\tvertexPosition.y += _rotatedPosition.y;\n\n\t// transform to world space\n\tvertexPosition.applyMatrix4( _viewWorldMatrix );\n\n}\n\nconst _v1$2 = /*@__PURE__*/ new Vector3();\nconst _v2$1 = /*@__PURE__*/ new Vector3();\n\nclass LOD extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis._currentLevel = 0;\n\n\t\tthis.type = 'LOD';\n\n\t\tObject.defineProperties( this, {\n\t\t\tlevels: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tisLOD: {\n\t\t\t\tvalue: true,\n\t\t\t}\n\t\t} );\n\n\t\tthis.autoUpdate = true;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source, false );\n\n\t\tconst levels = source.levels;\n\n\t\tfor ( let i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tconst level = levels[ i ];\n\n\t\t\tthis.addLevel( level.object.clone(), level.distance, level.hysteresis );\n\n\t\t}\n\n\t\tthis.autoUpdate = source.autoUpdate;\n\n\t\treturn this;\n\n\t}\n\n\taddLevel( object, distance = 0, hysteresis = 0 ) {\n\n\t\tdistance = Math.abs( distance );\n\n\t\tconst levels = this.levels;\n\n\t\tlet l;\n\n\t\tfor ( l = 0; l < levels.length; l ++ ) {\n\n\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlevels.splice( l, 0, { distance: distance, hysteresis: hysteresis, object: object } );\n\n\t\tthis.add( object );\n\n\t\treturn this;\n\n\t}\n\n\tremoveLevel( distance ) {\n\n\t\tconst levels = this.levels;\n\n\t\tfor ( let i = 0; i < levels.length; i ++ ) {\n\n\t\t\tif ( levels[ i ].distance === distance ) {\n\n\t\t\t\tconst removedElements = levels.splice( i, 1 );\n\t\t\t\tthis.remove( removedElements[ 0 ].object );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgetCurrentLevel() {\n\n\t\treturn this._currentLevel;\n\n\t}\n\n\n\n\tgetObjectForDistance( distance ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 0 ) {\n\n\t\t\tlet i, l;\n\n\t\t\tfor ( i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tlet levelDistance = levels[ i ].distance;\n\n\t\t\t\tif ( levels[ i ].object.visible ) {\n\n\t\t\t\t\tlevelDistance -= levelDistance * levels[ i ].hysteresis;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distance < levelDistance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn levels[ i - 1 ].object;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 0 ) {\n\n\t\t\t_v1$2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tconst distance = raycaster.ray.origin.distanceTo( _v1$2 );\n\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\tupdate( camera ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 1 ) {\n\n\t\t\t_v1$2.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t_v2$1.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tconst distance = _v1$2.distanceTo( _v2$1 ) / camera.zoom;\n\n\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\tlet i, l;\n\n\t\t\tfor ( i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tlet levelDistance = levels[ i ].distance;\n\n\t\t\t\tif ( levels[ i ].object.visible ) {\n\n\t\t\t\t\tlevelDistance -= levelDistance * levels[ i ].hysteresis;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distance >= levelDistance ) {\n\n\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._currentLevel = i - 1;\n\n\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.autoUpdate === false ) data.object.autoUpdate = false;\n\n\t\tdata.object.levels = [];\n\n\t\tconst levels = this.levels;\n\n\t\tfor ( let i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tconst level = levels[ i ];\n\n\t\t\tdata.object.levels.push( {\n\t\t\t\tobject: level.object.uuid,\n\t\t\t\tdistance: level.distance,\n\t\t\t\thysteresis: level.hysteresis\n\t\t\t} );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst _basePosition = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\n\nconst _vector3 = /*@__PURE__*/ new Vector3();\nconst _matrix4 = /*@__PURE__*/ new Matrix4();\nconst _vertex = /*@__PURE__*/ new Vector3();\n\nconst _sphere$5 = /*@__PURE__*/ new Sphere();\nconst _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();\nconst _ray$2 = /*@__PURE__*/ new Ray();\n\nclass SkinnedMesh extends Mesh {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isSkinnedMesh = true;\n\n\t\tthis.type = 'SkinnedMesh';\n\n\t\tthis.bindMode = AttachedBindMode;\n\t\tthis.bindMatrix = new Matrix4();\n\t\tthis.bindMatrixInverse = new Matrix4();\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.makeEmpty();\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\tthis.getVertexPosition( i, _vertex );\n\t\t\tthis.boundingBox.expandByPoint( _vertex );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.makeEmpty();\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\tthis.getVertexPosition( i, _vertex );\n\t\t\tthis.boundingSphere.expandByPoint( _vertex );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.bindMode = source.bindMode;\n\t\tthis.bindMatrix.copy( source.bindMatrix );\n\t\tthis.bindMatrixInverse.copy( source.bindMatrixInverse );\n\n\t\tthis.skeleton = source.skeleton;\n\n\t\tif ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();\n\t\tif ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// test with bounding sphere in world space\n\n\t\tif ( this.boundingSphere === null ) this.computeBoundingSphere();\n\n\t\t_sphere$5.copy( this.boundingSphere );\n\t\t_sphere$5.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$5 ) === false ) return;\n\n\t\t// convert ray to local space of skinned mesh\n\n\t\t_inverseMatrix$2.copy( matrixWorld ).invert();\n\t\t_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );\n\n\t\t// test with bounding box in local space\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tif ( _ray$2.intersectsBox( this.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\t// test for intersections with geometry\n\n\t\tthis._computeIntersections( raycaster, intersects, _ray$2 );\n\n\t}\n\n\tgetVertexPosition( index, target ) {\n\n\t\tsuper.getVertexPosition( index, target );\n\n\t\tthis.applyBoneTransform( index, target );\n\n\t\treturn target;\n\n\t}\n\n\tbind( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.copy( bindMatrix ).invert();\n\n\t}\n\n\tpose() {\n\n\t\tthis.skeleton.pose();\n\n\t}\n\n\tnormalizeSkinWeights() {\n\n\t\tconst vector = new Vector4();\n\n\t\tconst skinWeight = this.geometry.attributes.skinWeight;\n\n\t\tfor ( let i = 0, l = skinWeight.count; i < l; i ++ ) {\n\n\t\t\tvector.fromBufferAttribute( skinWeight, i );\n\n\t\t\tconst scale = 1.0 / vector.manhattanLength();\n\n\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\tvector.multiplyScalar( scale );\n\n\t\t\t} else {\n\n\t\t\t\tvector.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t}\n\n\t\t\tskinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.bindMode === AttachedBindMode ) {\n\n\t\t\tthis.bindMatrixInverse.copy( this.matrixWorld ).invert();\n\n\t\t} else if ( this.bindMode === DetachedBindMode ) {\n\n\t\t\tthis.bindMatrixInverse.copy( this.bindMatrix ).invert();\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t}\n\n\tapplyBoneTransform( index, vector ) {\n\n\t\tconst skeleton = this.skeleton;\n\t\tconst geometry = this.geometry;\n\n\t\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t\t_basePosition.copy( vector ).applyMatrix4( this.bindMatrix );\n\n\t\tvector.set( 0, 0, 0 );\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\t\tif ( weight !== 0 ) {\n\n\t\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\n\t\t\t\t_matrix4.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );\n\n\t\t\t\tvector.addScaledVector( _vector3.copy( _basePosition ).applyMatrix4( _matrix4 ), weight );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn vector.applyMatrix4( this.bindMatrixInverse );\n\n\t}\n\n}\n\nclass Bone extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isBone = true;\n\n\t\tthis.type = 'Bone';\n\n\t}\n\n}\n\nclass DataTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace ) {\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isDataTexture = true;\n\n\t\tthis.image = { data: data, width: width, height: height };\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n}\n\nconst _offsetMatrix = /*@__PURE__*/ new Matrix4();\nconst _identityMatrix = /*@__PURE__*/ new Matrix4();\n\nclass Skeleton {\n\n\tconstructor( bones = [], boneInverses = [] ) {\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.bones = bones.slice( 0 );\n\t\tthis.boneInverses = boneInverses;\n\t\tthis.boneMatrices = null;\n\n\t\tthis.boneTexture = null;\n\n\t\tthis.init();\n\n\t}\n\n\tinit() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tthis.boneMatrices = new Float32Array( bones.length * 16 );\n\n\t\t// calculate inverse bone matrices if necessary\n\n\t\tif ( boneInverses.length === 0 ) {\n\n\t\t\tthis.calculateInverses();\n\n\t\t} else {\n\n\t\t\t// handle special case\n\n\t\t\tif ( bones.length !== boneInverses.length ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );\n\n\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcalculateInverses() {\n\n\t\tthis.boneInverses.length = 0;\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst inverse = new Matrix4();\n\n\t\t\tif ( this.bones[ i ] ) {\n\n\t\t\t\tinverse.copy( this.bones[ i ].matrixWorld ).invert();\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t}\n\n\tpose() {\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.copy( this.boneInverses[ i ] ).invert();\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\t\tconst boneMatrices = this.boneMatrices;\n\t\tconst boneTexture = this.boneTexture;\n\n\t\t// flatten bone matrices to array\n\n\t\tfor ( let i = 0, il = bones.length; i < il; i ++ ) {\n\n\t\t\t// compute the offset between the current and the original transform\n\n\t\t\tconst matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;\n\n\t\t\t_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\n\t\t\t_offsetMatrix.toArray( boneMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( boneTexture !== null ) {\n\n\t\t\tboneTexture.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new Skeleton( this.bones, this.boneInverses );\n\n\t}\n\n\tcomputeBoneTexture() {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\t\tlet size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = Math.ceil( size / 4 ) * 4;\n\t\tsize = Math.max( size, 4 );\n\n\t\tconst boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\tboneMatrices.set( this.boneMatrices ); // copy current values\n\n\t\tconst boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\n\t\tboneTexture.needsUpdate = true;\n\n\t\tthis.boneMatrices = boneMatrices;\n\t\tthis.boneTexture = boneTexture;\n\n\t\treturn this;\n\n\t}\n\n\tgetBoneByName( name ) {\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone.name === name ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\tdispose( ) {\n\n\t\tif ( this.boneTexture !== null ) {\n\n\t\t\tthis.boneTexture.dispose();\n\n\t\t\tthis.boneTexture = null;\n\n\t\t}\n\n\t}\n\n\tfromJSON( json, bones ) {\n\n\t\tthis.uuid = json.uuid;\n\n\t\tfor ( let i = 0, l = json.bones.length; i < l; i ++ ) {\n\n\t\t\tconst uuid = json.bones[ i ];\n\t\t\tlet bone = bones[ uuid ];\n\n\t\t\tif ( bone === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );\n\t\t\t\tbone = new Bone();\n\n\t\t\t}\n\n\t\t\tthis.bones.push( bone );\n\t\t\tthis.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );\n\n\t\t}\n\n\t\tthis.init();\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Skeleton',\n\t\t\t\tgenerator: 'Skeleton.toJSON'\n\t\t\t},\n\t\t\tbones: [],\n\t\t\tboneInverses: []\n\t\t};\n\n\t\tdata.uuid = this.uuid;\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tfor ( let i = 0, l = bones.length; i < l; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\t\t\tdata.bones.push( bone.uuid );\n\n\t\t\tconst boneInverse = boneInverses[ i ];\n\t\t\tdata.boneInverses.push( boneInverse.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass InstancedBufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized, meshPerAttribute = 1 ) {\n\n\t\tsuper( array, itemSize, normalized );\n\n\t\tthis.isInstancedBufferAttribute = true;\n\n\t\tthis.meshPerAttribute = meshPerAttribute;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.meshPerAttribute = this.meshPerAttribute;\n\n\t\tdata.isInstancedBufferAttribute = true;\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();\nconst _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _instanceIntersects = [];\n\nconst _box3 = /*@__PURE__*/ new Box3();\nconst _identity = /*@__PURE__*/ new Matrix4();\nconst _mesh$1 = /*@__PURE__*/ new Mesh();\nconst _sphere$4 = /*@__PURE__*/ new Sphere();\n\nclass InstancedMesh extends Mesh {\n\n\tconstructor( geometry, material, count ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isInstancedMesh = true;\n\n\t\tthis.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );\n\t\tthis.instanceColor = null;\n\t\tthis.morphTexture = null;\n\n\t\tthis.count = count;\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.setMatrixAt( i, _identity );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst count = this.count;\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tthis.boundingBox.makeEmpty();\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.getMatrixAt( i, _instanceLocalMatrix );\n\n\t\t\t_box3.copy( geometry.boundingBox ).applyMatrix4( _instanceLocalMatrix );\n\n\t\t\tthis.boundingBox.union( _box3 );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst count = this.count;\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.makeEmpty();\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.getMatrixAt( i, _instanceLocalMatrix );\n\n\t\t\t_sphere$4.copy( geometry.boundingSphere ).applyMatrix4( _instanceLocalMatrix );\n\n\t\t\tthis.boundingSphere.union( _sphere$4 );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.instanceMatrix.copy( source.instanceMatrix );\n\n\t\tif ( source.morphTexture !== null ) this.morphTexture = source.morphTexture.clone();\n\t\tif ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();\n\n\t\tthis.count = source.count;\n\n\t\tif ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();\n\t\tif ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();\n\n\t\treturn this;\n\n\t}\n\n\tgetColorAt( index, color ) {\n\n\t\tcolor.fromArray( this.instanceColor.array, index * 3 );\n\n\t}\n\n\tgetMatrixAt( index, matrix ) {\n\n\t\tmatrix.fromArray( this.instanceMatrix.array, index * 16 );\n\n\t}\n\n\tgetMorphAt( index, object ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\tconst array = this.morphTexture.source.data.data;\n\n\t\tconst len = objectInfluences.length + 1; // All influences + the baseInfluenceSum\n\n\t\tconst dataIndex = index * len + 1; // Skip the baseInfluenceSum at the beginning\n\n\t\tfor ( let i = 0; i < objectInfluences.length; i ++ ) {\n\n\t\t\tobjectInfluences[ i ] = array[ dataIndex + i ];\n\n\t\t}\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst raycastTimes = this.count;\n\n\t\t_mesh$1.geometry = this.geometry;\n\t\t_mesh$1.material = this.material;\n\n\t\tif ( _mesh$1.material === undefined ) return;\n\n\t\t// test with bounding sphere first\n\n\t\tif ( this.boundingSphere === null ) this.computeBoundingSphere();\n\n\t\t_sphere$4.copy( this.boundingSphere );\n\t\t_sphere$4.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$4 ) === false ) return;\n\n\t\t// now test each instance\n\n\t\tfor ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {\n\n\t\t\t// calculate the world matrix for each instance\n\n\t\t\tthis.getMatrixAt( instanceId, _instanceLocalMatrix );\n\n\t\t\t_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );\n\n\t\t\t// the mesh represents this single instance\n\n\t\t\t_mesh$1.matrixWorld = _instanceWorldMatrix;\n\n\t\t\t_mesh$1.raycast( raycaster, _instanceIntersects );\n\n\t\t\t// process the result of raycast\n\n\t\t\tfor ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {\n\n\t\t\t\tconst intersect = _instanceIntersects[ i ];\n\t\t\t\tintersect.instanceId = instanceId;\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_instanceIntersects.length = 0;\n\n\t\t}\n\n\t}\n\n\tsetColorAt( index, color ) {\n\n\t\tif ( this.instanceColor === null ) {\n\n\t\t\tthis.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ).fill( 1 ), 3 );\n\n\t\t}\n\n\t\tcolor.toArray( this.instanceColor.array, index * 3 );\n\n\t}\n\n\tsetMatrixAt( index, matrix ) {\n\n\t\tmatrix.toArray( this.instanceMatrix.array, index * 16 );\n\n\t}\n\n\tsetMorphAt( index, object ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\tconst len = objectInfluences.length + 1; // morphBaseInfluence + all influences\n\n\t\tif ( this.morphTexture === null ) {\n\n\t\t\tthis.morphTexture = new DataTexture( new Float32Array( len * this.count ), len, this.count, RedFormat, FloatType );\n\n\t\t}\n\n\t\tconst array = this.morphTexture.source.data.data;\n\n\t\tlet morphInfluencesSum = 0;\n\n\t\tfor ( let i = 0; i < objectInfluences.length; i ++ ) {\n\n\t\t\tmorphInfluencesSum += objectInfluences[ i ];\n\n\t\t}\n\n\t\tconst morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\n\t\tconst dataIndex = len * index;\n\n\t\tarray[ dataIndex ] = morphBaseInfluence;\n\n\t\tarray.set( objectInfluences, dataIndex + 1 );\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\tif ( this.morphTexture !== null ) {\n\n\t\t\tthis.morphTexture.dispose();\n\t\t\tthis.morphTexture = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _vector1 = /*@__PURE__*/ new Vector3();\nconst _vector2 = /*@__PURE__*/ new Vector3();\nconst _normalMatrix = /*@__PURE__*/ new Matrix3();\n\nclass Plane {\n\n\tconstructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {\n\n\t\tthis.isPlane = true;\n\n\t\t// normal is assumed to be normalized\n\n\t\tthis.normal = normal;\n\t\tthis.constant = constant;\n\n\t}\n\n\tset( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponents( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromNormalAndCoplanarPoint( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCoplanarPoints( a, b, c ) {\n\n\t\tconst normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\n\n\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t}\n\n\tnormalize() {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t}\n\n\tdistanceToSphere( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t}\n\n\tprojectPoint( point, target ) {\n\n\t\treturn target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );\n\n\t}\n\n\tintersectLine( line, target ) {\n\n\t\tconst direction = line.delta( _vector1 );\n\n\t\tconst denominator = this.normal.dot( direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\treturn target.copy( line.start );\n\n\t\t\t}\n\n\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn target.copy( line.start ).addScaledVector( direction, t );\n\n\t}\n\n\tintersectsLine( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tconst startSign = this.distanceToPoint( line.start );\n\t\tconst endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t}\n\n\tcoplanarPoint( target ) {\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t}\n\n\tapplyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\n\n\t\tconst referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\n\n\t\tconst normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.constant -= offset.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tequals( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _sphere$3 = /*@__PURE__*/ new Sphere();\nconst _vector$6 = /*@__PURE__*/ new Vector3();\n\nclass Frustum {\n\n\tconstructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {\n\n\t\tthis.planes = [ p0, p1, p2, p3, p4, p5 ];\n\n\t}\n\n\tset( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tconst planes = this.planes;\n\n\t\tplanes[ 0 ].copy( p0 );\n\t\tplanes[ 1 ].copy( p1 );\n\t\tplanes[ 2 ].copy( p2 );\n\t\tplanes[ 3 ].copy( p3 );\n\t\tplanes[ 4 ].copy( p4 );\n\t\tplanes[ 5 ].copy( p5 );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( frustum ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\tconst planes = this.planes;\n\t\tconst me = m.elements;\n\t\tconst me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\tconst me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\tconst me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\tconst me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tplanes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize();\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tintersectsObject( object ) {\n\n\t\tif ( object.boundingSphere !== undefined ) {\n\n\t\t\tif ( object.boundingSphere === null ) object.computeBoundingSphere();\n\n\t\t\t_sphere$3.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\t} else {\n\n\t\t\tconst geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t_sphere$3.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\t}\n\n\t\treturn this.intersectsSphere( _sphere$3 );\n\n\t}\n\n\tintersectsSprite( sprite ) {\n\n\t\t_sphere$3.center.set( 0, 0, 0 );\n\t\t_sphere$3.radius = 0.7071067811865476;\n\t\t_sphere$3.applyMatrix4( sprite.matrixWorld );\n\n\t\treturn this.intersectsSphere( _sphere$3 );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst planes = this.planes;\n\t\tconst center = sphere.center;\n\t\tconst negRadius = - sphere.radius;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = planes[ i ];\n\n\t\t\t// corner at max distance\n\n\t\t\t_vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t_vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t_vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\tif ( plane.distanceToPoint( _vector$6 ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nfunction ascIdSort( a, b ) {\n\n\treturn a - b;\n\n}\n\nfunction sortOpaque( a, b ) {\n\n\treturn a.z - b.z;\n\n}\n\nfunction sortTransparent( a, b ) {\n\n\treturn b.z - a.z;\n\n}\n\nclass MultiDrawRenderList {\n\n\tconstructor() {\n\n\t\tthis.index = 0;\n\t\tthis.pool = [];\n\t\tthis.list = [];\n\n\t}\n\n\tpush( start, count, z, index ) {\n\n\t\tconst pool = this.pool;\n\t\tconst list = this.list;\n\t\tif ( this.index >= pool.length ) {\n\n\t\t\tpool.push( {\n\n\t\t\t\tstart: - 1,\n\t\t\t\tcount: - 1,\n\t\t\t\tz: - 1,\n\t\t\t\tindex: - 1,\n\n\t\t\t} );\n\n\t\t}\n\n\t\tconst item = pool[ this.index ];\n\t\tlist.push( item );\n\t\tthis.index ++;\n\n\t\titem.start = start;\n\t\titem.count = count;\n\t\titem.z = z;\n\t\titem.index = index;\n\n\t}\n\n\treset() {\n\n\t\tthis.list.length = 0;\n\t\tthis.index = 0;\n\n\t}\n\n}\n\nconst _matrix$1 = /*@__PURE__*/ new Matrix4();\nconst _whiteColor = /*@__PURE__*/ new Color( 1, 1, 1 );\nconst _frustum = /*@__PURE__*/ new Frustum();\nconst _box$1 = /*@__PURE__*/ new Box3();\nconst _sphere$2 = /*@__PURE__*/ new Sphere();\nconst _vector$5 = /*@__PURE__*/ new Vector3();\nconst _forward = /*@__PURE__*/ new Vector3();\nconst _temp = /*@__PURE__*/ new Vector3();\nconst _renderList = /*@__PURE__*/ new MultiDrawRenderList();\nconst _mesh = /*@__PURE__*/ new Mesh();\nconst _batchIntersects = [];\n\n// copies data from attribute \"src\" into \"target\" starting at \"targetOffset\"\nfunction copyAttributeData( src, target, targetOffset = 0 ) {\n\n\tconst itemSize = target.itemSize;\n\tif ( src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor ) {\n\n\t\t// use the component getters and setters if the array data cannot\n\t\t// be copied directly\n\t\tconst vertexCount = src.count;\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\ttarget.setComponent( i + targetOffset, c, src.getComponent( i, c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// faster copy approach using typed array set function\n\t\ttarget.array.set( src.array, targetOffset * itemSize );\n\n\t}\n\n\ttarget.needsUpdate = true;\n\n}\n\n// safely copies array contents to a potentially smaller array\nfunction copyArrayContents( src, target ) {\n\n\tif ( src.constructor !== target.constructor ) {\n\n\t\t// if arrays are of a different type (eg due to index size increasing) then data must be per-element copied\n\t\tconst len = Math.min( src.length, target.length );\n\t\tfor ( let i = 0; i < len; i ++ ) {\n\n\t\t\ttarget[ i ] = src[ i ];\n\n\t\t}\n\n\t} else {\n\n\t\t// if the arrays use the same data layout we can use a fast block copy\n\t\tconst len = Math.min( src.length, target.length );\n\t\ttarget.set( new src.constructor( src.buffer, 0, len ) );\n\n\t}\n\n}\n\nclass BatchedMesh extends Mesh {\n\n\tget maxInstanceCount() {\n\n\t\treturn this._maxInstanceCount;\n\n\t}\n\n\tget instanceCount() {\n\n\t\treturn this._instanceInfo.length - this._availableInstanceIds.length;\n\n\t}\n\n\tget unusedVertexCount() {\n\n\t\treturn this._maxVertexCount - this._nextVertexStart;\n\n\t}\n\n\tget unusedIndexCount() {\n\n\t\treturn this._maxIndexCount - this._nextIndexStart;\n\n\t}\n\n\tconstructor( maxInstanceCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material ) {\n\n\t\tsuper( new BufferGeometry(), material );\n\n\t\tthis.isBatchedMesh = true;\n\t\tthis.perObjectFrustumCulled = true;\n\t\tthis.sortObjects = true;\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\t\tthis.customSort = null;\n\n\t\t// stores visible, active, and geometry id per instance and reserved buffer ranges for geometries\n\t\tthis._instanceInfo = [];\n\t\tthis._geometryInfo = [];\n\n\t\t// instance, geometry ids that have been set as inactive, and are available to be overwritten\n\t\tthis._availableInstanceIds = [];\n\t\tthis._availableGeometryIds = [];\n\n\t\t// used to track where the next point is that geometry should be inserted\n\t\tthis._nextIndexStart = 0;\n\t\tthis._nextVertexStart = 0;\n\t\tthis._geometryCount = 0;\n\n\t\t// flags\n\t\tthis._visibilityChanged = true;\n\t\tthis._geometryInitialized = false;\n\n\t\t// cached user options\n\t\tthis._maxInstanceCount = maxInstanceCount;\n\t\tthis._maxVertexCount = maxVertexCount;\n\t\tthis._maxIndexCount = maxIndexCount;\n\n\t\t// buffers for multi draw\n\t\tthis._multiDrawCounts = new Int32Array( maxInstanceCount );\n\t\tthis._multiDrawStarts = new Int32Array( maxInstanceCount );\n\t\tthis._multiDrawCount = 0;\n\t\tthis._multiDrawInstances = null;\n\n\t\t// Local matrix per geometry by using data texture\n\t\tthis._matricesTexture = null;\n\t\tthis._indirectTexture = null;\n\t\tthis._colorsTexture = null;\n\n\t\tthis._initMatricesTexture();\n\t\tthis._initIndirectTexture();\n\n\t}\n\n\t_initMatricesTexture() {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 matrices * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 matrices * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 matrices * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 matrices * 4 pixels = (64 * 64)\n\n\t\tlet size = Math.sqrt( this._maxInstanceCount * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = Math.ceil( size / 4 ) * 4;\n\t\tsize = Math.max( size, 4 );\n\n\t\tconst matricesArray = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\tconst matricesTexture = new DataTexture( matricesArray, size, size, RGBAFormat, FloatType );\n\n\t\tthis._matricesTexture = matricesTexture;\n\n\t}\n\n\t_initIndirectTexture() {\n\n\t\tlet size = Math.sqrt( this._maxInstanceCount );\n\t\tsize = Math.ceil( size );\n\n\t\tconst indirectArray = new Uint32Array( size * size );\n\t\tconst indirectTexture = new DataTexture( indirectArray, size, size, RedIntegerFormat, UnsignedIntType );\n\n\t\tthis._indirectTexture = indirectTexture;\n\n\t}\n\n\t_initColorsTexture() {\n\n\t\tlet size = Math.sqrt( this._maxInstanceCount );\n\t\tsize = Math.ceil( size );\n\n\t\t// 4 floats per RGBA pixel initialized to white\n\t\tconst colorsArray = new Float32Array( size * size * 4 ).fill( 1 );\n\t\tconst colorsTexture = new DataTexture( colorsArray, size, size, RGBAFormat, FloatType );\n\t\tcolorsTexture.colorSpace = ColorManagement.workingColorSpace;\n\n\t\tthis._colorsTexture = colorsTexture;\n\n\t}\n\n\t_initializeGeometry( reference ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst maxVertexCount = this._maxVertexCount;\n\t\tconst maxIndexCount = this._maxIndexCount;\n\t\tif ( this._geometryInitialized === false ) {\n\n\t\t\tfor ( const attributeName in reference.attributes ) {\n\n\t\t\t\tconst srcAttribute = reference.getAttribute( attributeName );\n\t\t\t\tconst { array, itemSize, normalized } = srcAttribute;\n\n\t\t\t\tconst dstArray = new array.constructor( maxVertexCount * itemSize );\n\t\t\t\tconst dstAttribute = new BufferAttribute( dstArray, itemSize, normalized );\n\n\t\t\t\tgeometry.setAttribute( attributeName, dstAttribute );\n\n\t\t\t}\n\n\t\t\tif ( reference.getIndex() !== null ) {\n\n\t\t\t\t// Reserve last u16 index for primitive restart.\n\t\t\t\tconst indexArray = maxVertexCount > 65535\n\t\t\t\t\t? new Uint32Array( maxIndexCount )\n\t\t\t\t\t: new Uint16Array( maxIndexCount );\n\n\t\t\t\tgeometry.setIndex( new BufferAttribute( indexArray, 1 ) );\n\n\t\t\t}\n\n\t\t\tthis._geometryInitialized = true;\n\n\t\t}\n\n\t}\n\n\t// Make sure the geometry is compatible with the existing combined geometry attributes\n\t_validateGeometry( geometry ) {\n\n\t\t// check to ensure the geometries are using consistent attributes and indices\n\t\tconst batchGeometry = this.geometry;\n\t\tif ( Boolean( geometry.getIndex() ) !== Boolean( batchGeometry.getIndex() ) ) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: All geometries must consistently have \"index\".' );\n\n\t\t}\n\n\t\tfor ( const attributeName in batchGeometry.attributes ) {\n\n\t\t\tif ( ! geometry.hasAttribute( attributeName ) ) {\n\n\t\t\t\tthrow new Error( `THREE.BatchedMesh: Added geometry missing \"${ attributeName }\". All geometries must have consistent attributes.` );\n\n\t\t\t}\n\n\t\t\tconst srcAttribute = geometry.getAttribute( attributeName );\n\t\t\tconst dstAttribute = batchGeometry.getAttribute( attributeName );\n\t\t\tif ( srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized ) {\n\n\t\t\t\tthrow new Error( 'THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tvalidateInstanceId( instanceId ) {\n\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tif ( instanceId < 0 || instanceId >= instanceInfo.length || instanceInfo[ instanceId ].active === false ) {\n\n\t\t\tthrow new Error( `THREE.BatchedMesh: Invalid instanceId ${instanceId}. Instance is either out of range or has been deleted.` );\n\n\t\t}\n\n\t}\n\n\tvalidateGeometryId( geometryId ) {\n\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tif ( geometryId < 0 || geometryId >= geometryInfoList.length || geometryInfoList[ geometryId ].active === false ) {\n\n\t\t\tthrow new Error( `THREE.BatchedMesh: Invalid geometryId ${geometryId}. Geometry is either out of range or has been deleted.` );\n\n\t\t}\n\n\t}\n\n\n\tsetCustomSort( func ) {\n\n\t\tthis.customSort = func;\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst boundingBox = this.boundingBox;\n\t\tconst instanceInfo = this._instanceInfo;\n\n\t\tboundingBox.makeEmpty();\n\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( instanceInfo[ i ].active === false ) continue;\n\n\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\tthis.getBoundingBoxAt( geometryId, _box$1 ).applyMatrix4( _matrix$1 );\n\t\t\tboundingBox.union( _box$1 );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\t\tconst instanceInfo = this._instanceInfo;\n\n\t\tboundingSphere.makeEmpty();\n\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( instanceInfo[ i ].active === false ) continue;\n\n\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\tthis.getBoundingSphereAt( geometryId, _sphere$2 ).applyMatrix4( _matrix$1 );\n\t\t\tboundingSphere.union( _sphere$2 );\n\n\t\t}\n\n\t}\n\n\taddInstance( geometryId ) {\n\n\t\tconst atCapacity = this._instanceInfo.length >= this.maxInstanceCount;\n\n\t\t// ensure we're not over geometry\n\t\tif ( atCapacity && this._availableInstanceIds.length === 0 ) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: Maximum item count reached.' );\n\n\t\t}\n\n\t\tconst instanceInfo = {\n\t\t\tvisible: true,\n\t\t\tactive: true,\n\t\t\tgeometryIndex: geometryId,\n\t\t};\n\n\t\tlet drawId = null;\n\n\t\t// Prioritize using previously freed instance ids\n\t\tif ( this._availableInstanceIds.length > 0 ) {\n\n\t\t\tthis._availableInstanceIds.sort( ascIdSort );\n\n\t\t\tdrawId = this._availableInstanceIds.shift();\n\t\t\tthis._instanceInfo[ drawId ] = instanceInfo;\n\n\t\t} else {\n\n\t\t\tdrawId = this._instanceInfo.length;\n\t\t\tthis._instanceInfo.push( instanceInfo );\n\n\t\t}\n\n\t\tconst matricesTexture = this._matricesTexture;\n\t\t_matrix$1.identity().toArray( matricesTexture.image.data, drawId * 16 );\n\t\tmatricesTexture.needsUpdate = true;\n\n\t\tconst colorsTexture = this._colorsTexture;\n\t\tif ( colorsTexture ) {\n\n\t\t\t_whiteColor.toArray( colorsTexture.image.data, drawId * 4 );\n\t\t\tcolorsTexture.needsUpdate = true;\n\n\t\t}\n\n\t\tthis._visibilityChanged = true;\n\t\treturn drawId;\n\n\t}\n\n\taddGeometry( geometry, reservedVertexCount = - 1, reservedIndexCount = - 1 ) {\n\n\t\tthis._initializeGeometry( geometry );\n\n\t\tthis._validateGeometry( geometry );\n\n\t\tconst geometryInfo = {\n\t\t\t// geometry information\n\t\t\tvertexStart: - 1,\n\t\t\tvertexCount: - 1,\n\t\t\treservedVertexCount: - 1,\n\n\t\t\tindexStart: - 1,\n\t\t\tindexCount: - 1,\n\t\t\treservedIndexCount: - 1,\n\n\t\t\t// draw range information\n\t\t\tstart: - 1,\n\t\t\tcount: - 1,\n\n\t\t\t// state\n\t\t\tboundingBox: null,\n\t\t\tboundingSphere: null,\n\t\t\tactive: true,\n\t\t};\n\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tgeometryInfo.vertexStart = this._nextVertexStart;\n\t\tgeometryInfo.reservedVertexCount = reservedVertexCount === - 1 ? geometry.getAttribute( 'position' ).count : reservedVertexCount;\n\n\t\tconst index = geometry.getIndex();\n\t\tconst hasIndex = index !== null;\n\t\tif ( hasIndex ) {\n\n\t\t\tgeometryInfo.indexStart = this._nextIndexStart;\n\t\t\tgeometryInfo.reservedIndexCount = reservedIndexCount === - 1 ? index.count : reservedIndexCount;\n\n\t\t}\n\n\t\tif (\n\t\t\tgeometryInfo.indexStart !== - 1 &&\n\t\t\tgeometryInfo.indexStart + geometryInfo.reservedIndexCount > this._maxIndexCount ||\n\t\t\tgeometryInfo.vertexStart + geometryInfo.reservedVertexCount > this._maxVertexCount\n\t\t) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.' );\n\n\t\t}\n\n\t\t// update id\n\t\tlet geometryId;\n\t\tif ( this._availableGeometryIds.length > 0 ) {\n\n\t\t\tthis._availableGeometryIds.sort( ascIdSort );\n\n\t\t\tgeometryId = this._availableGeometryIds.shift();\n\t\t\tgeometryInfoList[ geometryId ] = geometryInfo;\n\n\n\t\t} else {\n\n\t\t\tgeometryId = this._geometryCount;\n\t\t\tthis._geometryCount ++;\n\t\t\tgeometryInfoList.push( geometryInfo );\n\n\t\t}\n\n\t\t// update the geometry\n\t\tthis.setGeometryAt( geometryId, geometry );\n\n\t\t// increment the next geometry position\n\t\tthis._nextIndexStart = geometryInfo.indexStart + geometryInfo.reservedIndexCount;\n\t\tthis._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;\n\n\t\treturn geometryId;\n\n\t}\n\n\tsetGeometryAt( geometryId, geometry ) {\n\n\t\tif ( geometryId >= this._geometryCount ) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: Maximum geometry count reached.' );\n\n\t\t}\n\n\t\tthis._validateGeometry( geometry );\n\n\t\tconst batchGeometry = this.geometry;\n\t\tconst hasIndex = batchGeometry.getIndex() !== null;\n\t\tconst dstIndex = batchGeometry.getIndex();\n\t\tconst srcIndex = geometry.getIndex();\n\t\tconst geometryInfo = this._geometryInfo[ geometryId ];\n\t\tif (\n\t\t\thasIndex &&\n\t\t\tsrcIndex.count > geometryInfo.reservedIndexCount ||\n\t\t\tgeometry.attributes.position.count > geometryInfo.reservedVertexCount\n\t\t) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: Reserved space not large enough for provided geometry.' );\n\n\t\t}\n\n\t\t// copy geometry buffer data over\n\t\tconst vertexStart = geometryInfo.vertexStart;\n\t\tconst reservedVertexCount = geometryInfo.reservedVertexCount;\n\t\tgeometryInfo.vertexCount = geometry.getAttribute( 'position' ).count;\n\n\t\tfor ( const attributeName in batchGeometry.attributes ) {\n\n\t\t\t// copy attribute data\n\t\t\tconst srcAttribute = geometry.getAttribute( attributeName );\n\t\t\tconst dstAttribute = batchGeometry.getAttribute( attributeName );\n\t\t\tcopyAttributeData( srcAttribute, dstAttribute, vertexStart );\n\n\t\t\t// fill the rest in with zeroes\n\t\t\tconst itemSize = srcAttribute.itemSize;\n\t\t\tfor ( let i = srcAttribute.count, l = reservedVertexCount; i < l; i ++ ) {\n\n\t\t\t\tconst index = vertexStart + i;\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tdstAttribute.setComponent( index, c, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdstAttribute.needsUpdate = true;\n\t\t\tdstAttribute.addUpdateRange( vertexStart * itemSize, reservedVertexCount * itemSize );\n\n\t\t}\n\n\t\t// copy index\n\t\tif ( hasIndex ) {\n\n\t\t\tconst indexStart = geometryInfo.indexStart;\n\t\t\tconst reservedIndexCount = geometryInfo.reservedIndexCount;\n\t\t\tgeometryInfo.indexCount = geometry.getIndex().count;\n\n\t\t\t// copy index data over\n\t\t\tfor ( let i = 0; i < srcIndex.count; i ++ ) {\n\n\t\t\t\tdstIndex.setX( indexStart + i, vertexStart + srcIndex.getX( i ) );\n\n\t\t\t}\n\n\t\t\t// fill the rest in with zeroes\n\t\t\tfor ( let i = srcIndex.count, l = reservedIndexCount; i < l; i ++ ) {\n\n\t\t\t\tdstIndex.setX( indexStart + i, vertexStart );\n\n\t\t\t}\n\n\t\t\tdstIndex.needsUpdate = true;\n\t\t\tdstIndex.addUpdateRange( indexStart, geometryInfo.reservedIndexCount );\n\n\t\t}\n\n\t\t// update the draw range\n\t\tgeometryInfo.start = hasIndex ? geometryInfo.indexStart : geometryInfo.vertexStart;\n\t\tgeometryInfo.count = hasIndex ? geometryInfo.indexCount : geometryInfo.vertexCount;\n\n\t\t// store the bounding boxes\n\t\tgeometryInfo.boundingBox = null;\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tgeometryInfo.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\tgeometryInfo.boundingSphere = null;\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tgeometryInfo.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tthis._visibilityChanged = true;\n\t\treturn geometryId;\n\n\t}\n\n\tdeleteGeometry( geometryId ) {\n\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tif ( geometryId >= geometryInfoList.length || geometryInfoList[ geometryId ].active === false ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t// delete any instances associated with this geometry\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( instanceInfo[ i ].geometryIndex === geometryId ) {\n\n\t\t\t\tthis.deleteInstance( i );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometryInfoList[ geometryId ].active = false;\n\t\tthis._availableGeometryIds.push( geometryId );\n\t\tthis._visibilityChanged = true;\n\n\t\treturn this;\n\n\t}\n\n\tdeleteInstance( instanceId ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\tthis._instanceInfo[ instanceId ].active = false;\n\t\tthis._availableInstanceIds.push( instanceId );\n\t\tthis._visibilityChanged = true;\n\n\t\treturn this;\n\n\t}\n\n\toptimize() {\n\n\t\t// track the next indices to copy data to\n\t\tlet nextVertexStart = 0;\n\t\tlet nextIndexStart = 0;\n\n\t\t// Iterate over all geometry ranges in order sorted from earliest in the geometry buffer to latest\n\t\t// in the geometry buffer. Because draw range objects can be reused there is no guarantee of their order.\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tconst indices = geometryInfoList\n\t\t\t.map( ( e, i ) => i )\n\t\t\t.sort( ( a, b ) => {\n\n\t\t\t\treturn geometryInfoList[ a ].vertexStart - geometryInfoList[ b ].vertexStart;\n\n\t\t\t} );\n\n\t\tconst geometry = this.geometry;\n\t\tfor ( let i = 0, l = geometryInfoList.length; i < l; i ++ ) {\n\n\t\t\t// if a geometry range is inactive then don't copy anything\n\t\t\tconst index = indices[ i ];\n\t\t\tconst geometryInfo = geometryInfoList[ index ];\n\t\t\tif ( geometryInfo.active === false ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// if a geometry contains an index buffer then shift it, as well\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\tif ( geometryInfo.indexStart !== nextIndexStart ) {\n\n\t\t\t\t\tconst { indexStart, vertexStart, reservedIndexCount } = geometryInfo;\n\t\t\t\t\tconst index = geometry.index;\n\t\t\t\t\tconst array = index.array;\n\n\t\t\t\t\t// shift the index pointers based on how the vertex data will shift\n\t\t\t\t\t// adjusting the index must happen first so the original vertex start value is available\n\t\t\t\t\tconst elementDelta = nextVertexStart - vertexStart;\n\t\t\t\t\tfor ( let j = indexStart; j < indexStart + reservedIndexCount; j ++ ) {\n\n\t\t\t\t\t\tarray[ j ] = array[ j ] + elementDelta;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex.array.copyWithin( nextIndexStart, indexStart, indexStart + reservedIndexCount );\n\t\t\t\t\tindex.addUpdateRange( nextIndexStart, reservedIndexCount );\n\n\t\t\t\t\tgeometryInfo.indexStart = nextIndexStart;\n\n\t\t\t\t}\n\n\t\t\t\tnextIndexStart += geometryInfo.reservedIndexCount;\n\n\t\t\t}\n\n\t\t\t// if a geometry needs to be moved then copy attribute data to overwrite unused space\n\t\t\tif ( geometryInfo.vertexStart !== nextVertexStart ) {\n\n\t\t\t\tconst { vertexStart, reservedVertexCount } = geometryInfo;\n\t\t\t\tconst attributes = geometry.attributes;\n\t\t\t\tfor ( const key in attributes ) {\n\n\t\t\t\t\tconst attribute = attributes[ key ];\n\t\t\t\t\tconst { array, itemSize } = attribute;\n\t\t\t\t\tarray.copyWithin( nextVertexStart * itemSize, vertexStart * itemSize, ( vertexStart + reservedVertexCount ) * itemSize );\n\t\t\t\t\tattribute.addUpdateRange( nextVertexStart * itemSize, reservedVertexCount * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tgeometryInfo.vertexStart = nextVertexStart;\n\n\t\t\t}\n\n\t\t\tnextVertexStart += geometryInfo.reservedVertexCount;\n\t\t\tgeometryInfo.start = geometry.index ? geometryInfo.indexStart : geometryInfo.vertexStart;\n\n\t\t\t// step the next geometry points to the shifted position\n\t\t\tthis._nextIndexStart = geometry.index ? geometryInfo.indexStart + geometryInfo.reservedIndexCount : 0;\n\t\t\tthis._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// get bounding box and compute it if it doesn't exist\n\tgetBoundingBoxAt( geometryId, target ) {\n\n\t\tif ( geometryId >= this._geometryCount ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// compute bounding box\n\t\tconst geometry = this.geometry;\n\t\tconst geometryInfo = this._geometryInfo[ geometryId ];\n\t\tif ( geometryInfo.boundingBox === null ) {\n\n\t\t\tconst box = new Box3();\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\t\t\tfor ( let i = geometryInfo.start, l = geometryInfo.start + geometryInfo.count; i < l; i ++ ) {\n\n\t\t\t\tlet iv = i;\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\tiv = index.getX( iv );\n\n\t\t\t\t}\n\n\t\t\t\tbox.expandByPoint( _vector$5.fromBufferAttribute( position, iv ) );\n\n\t\t\t}\n\n\t\t\tgeometryInfo.boundingBox = box;\n\n\t\t}\n\n\t\ttarget.copy( geometryInfo.boundingBox );\n\t\treturn target;\n\n\t}\n\n\t// get bounding sphere and compute it if it doesn't exist\n\tgetBoundingSphereAt( geometryId, target ) {\n\n\t\tif ( geometryId >= this._geometryCount ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// compute bounding sphere\n\t\tconst geometry = this.geometry;\n\t\tconst geometryInfo = this._geometryInfo[ geometryId ];\n\t\tif ( geometryInfo.boundingSphere === null ) {\n\n\t\t\tconst sphere = new Sphere();\n\t\t\tthis.getBoundingBoxAt( geometryId, _box$1 );\n\t\t\t_box$1.getCenter( sphere.center );\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\n\t\t\tlet maxRadiusSq = 0;\n\t\t\tfor ( let i = geometryInfo.start, l = geometryInfo.start + geometryInfo.count; i < l; i ++ ) {\n\n\t\t\t\tlet iv = i;\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\tiv = index.getX( iv );\n\n\t\t\t\t}\n\n\t\t\t\t_vector$5.fromBufferAttribute( position, iv );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, sphere.center.distanceToSquared( _vector$5 ) );\n\n\t\t\t}\n\n\t\t\tsphere.radius = Math.sqrt( maxRadiusSq );\n\t\t\tgeometryInfo.boundingSphere = sphere;\n\n\t\t}\n\n\t\ttarget.copy( geometryInfo.boundingSphere );\n\t\treturn target;\n\n\t}\n\n\tsetMatrixAt( instanceId, matrix ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\tconst matricesTexture = this._matricesTexture;\n\t\tconst matricesArray = this._matricesTexture.image.data;\n\t\tmatrix.toArray( matricesArray, instanceId * 16 );\n\t\tmatricesTexture.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\tgetMatrixAt( instanceId, matrix ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\t\treturn matrix.fromArray( this._matricesTexture.image.data, instanceId * 16 );\n\n\t}\n\n\tsetColorAt( instanceId, color ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\tif ( this._colorsTexture === null ) {\n\n\t\t\tthis._initColorsTexture();\n\n\t\t}\n\n\t\tcolor.toArray( this._colorsTexture.image.data, instanceId * 4 );\n\t\tthis._colorsTexture.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\tgetColorAt( instanceId, color ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\t\treturn color.fromArray( this._colorsTexture.image.data, instanceId * 4 );\n\n\t}\n\n\tsetVisibleAt( instanceId, value ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\tif ( this._instanceInfo[ instanceId ].visible === value ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis._instanceInfo[ instanceId ].visible = value;\n\t\tthis._visibilityChanged = true;\n\n\t\treturn this;\n\n\t}\n\n\tgetVisibleAt( instanceId ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\treturn this._instanceInfo[ instanceId ].visible;\n\n\t}\n\n\tsetGeometryIdAt( instanceId, geometryId ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\t\tthis.validateGeometryId( geometryId );\n\n\t\tthis._instanceInfo[ instanceId ].geometryIndex = geometryId;\n\n\t\treturn this;\n\n\t}\n\n\tgetGeometryIdAt( instanceId ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\treturn this._instanceInfo[ instanceId ].geometryIndex;\n\n\t}\n\n\tgetGeometryRangeAt( geometryId, target = {} ) {\n\n\t\tthis.validateGeometryId( geometryId );\n\n\t\tconst geometryInfo = this._geometryInfo[ geometryId ];\n\t\ttarget.vertexStart = geometryInfo.vertexStart;\n\t\ttarget.vertexCount = geometryInfo.vertexCount;\n\t\ttarget.reservedVertexCount = geometryInfo.reservedVertexCount;\n\n\t\ttarget.indexStart = geometryInfo.indexStart;\n\t\ttarget.indexCount = geometryInfo.indexCount;\n\t\ttarget.reservedIndexCount = geometryInfo.reservedIndexCount;\n\n\t\ttarget.start = geometryInfo.start;\n\t\ttarget.count = geometryInfo.count;\n\n\t\treturn target;\n\n\t}\n\n\tsetInstanceCount( maxInstanceCount ) {\n\n\t\t// shrink the available instances as much as possible\n\t\tconst availableInstanceIds = this._availableInstanceIds;\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tavailableInstanceIds.sort( ascIdSort );\n\t\twhile ( availableInstanceIds[ availableInstanceIds.length - 1 ] === instanceInfo.length ) {\n\n\t\t\tinstanceInfo.pop();\n\t\t\tavailableInstanceIds.pop();\n\n\t\t}\n\n\t\t// throw an error if it can't be shrunk to the desired size\n\t\tif ( maxInstanceCount < instanceInfo.length ) {\n\n\t\t\tthrow new Error( `BatchedMesh: Instance ids outside the range ${ maxInstanceCount } are being used. Cannot shrink instance count.` );\n\n\t\t}\n\n\t\t// copy the multi draw counts\n\t\tconst multiDrawCounts = new Int32Array( maxInstanceCount );\n\t\tconst multiDrawStarts = new Int32Array( maxInstanceCount );\n\t\tcopyArrayContents( this._multiDrawCounts, multiDrawCounts );\n\t\tcopyArrayContents( this._multiDrawStarts, multiDrawStarts );\n\n\t\tthis._multiDrawCounts = multiDrawCounts;\n\t\tthis._multiDrawStarts = multiDrawStarts;\n\t\tthis._maxInstanceCount = maxInstanceCount;\n\n\t\t// update texture data for instance sampling\n\t\tconst indirectTexture = this._indirectTexture;\n\t\tconst matricesTexture = this._matricesTexture;\n\t\tconst colorsTexture = this._colorsTexture;\n\n\t\tindirectTexture.dispose();\n\t\tthis._initIndirectTexture();\n\t\tcopyArrayContents( indirectTexture.image.data, this._indirectTexture.image.data );\n\n\t\tmatricesTexture.dispose();\n\t\tthis._initMatricesTexture();\n\t\tcopyArrayContents( matricesTexture.image.data, this._matricesTexture.image.data );\n\n\t\tif ( colorsTexture ) {\n\n\t\t\tcolorsTexture.dispose();\n\t\t\tthis._initColorsTexture();\n\t\t\tcopyArrayContents( colorsTexture.image.data, this._colorsTexture.image.data );\n\n\t\t}\n\n\t}\n\n\tsetGeometrySize( maxVertexCount, maxIndexCount ) {\n\n\t\t// Check if we can shrink to the requested vertex attribute size\n\t\tconst validRanges = [ ...this._geometryInfo ].filter( info => info.active );\n\t\tconst requiredVertexLength = Math.max( ...validRanges.map( range => range.vertexStart + range.reservedVertexCount ) );\n\t\tif ( requiredVertexLength > maxVertexCount ) {\n\n\t\t\tthrow new Error( `BatchedMesh: Geometry vertex values are being used outside the range ${ maxIndexCount }. Cannot shrink further.` );\n\n\t\t}\n\n\t\t// Check if we can shrink to the requested index attribute size\n\t\tif ( this.geometry.index ) {\n\n\t\t\tconst requiredIndexLength = Math.max( ...validRanges.map( range => range.indexStart + range.reservedIndexCount ) );\n\t\t\tif ( requiredIndexLength > maxIndexCount ) {\n\n\t\t\t\tthrow new Error( `BatchedMesh: Geometry index values are being used outside the range ${ maxIndexCount }. Cannot shrink further.` );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\t// dispose of the previous geometry\n\t\tconst oldGeometry = this.geometry;\n\t\toldGeometry.dispose();\n\n\t\t// recreate the geometry needed based on the previous variant\n\t\tthis._maxVertexCount = maxVertexCount;\n\t\tthis._maxIndexCount = maxIndexCount;\n\n\t\tif ( this._geometryInitialized ) {\n\n\t\t\tthis._geometryInitialized = false;\n\t\t\tthis.geometry = new BufferGeometry();\n\t\t\tthis._initializeGeometry( oldGeometry );\n\n\t\t}\n\n\t\t// copy data from the previous geometry\n\t\tconst geometry = this.geometry;\n\t\tif ( oldGeometry.index ) {\n\n\t\t\tcopyArrayContents( oldGeometry.index.array, geometry.index.array );\n\n\t\t}\n\n\t\tfor ( const key in oldGeometry.attributes ) {\n\n\t\t\tcopyArrayContents( oldGeometry.attributes[ key ].array, geometry.attributes[ key ].array );\n\n\t\t}\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst batchGeometry = this.geometry;\n\n\t\t// iterate over each geometry\n\t\t_mesh.material = this.material;\n\t\t_mesh.geometry.index = batchGeometry.index;\n\t\t_mesh.geometry.attributes = batchGeometry.attributes;\n\t\tif ( _mesh.geometry.boundingBox === null ) {\n\n\t\t\t_mesh.geometry.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( _mesh.geometry.boundingSphere === null ) {\n\n\t\t\t_mesh.geometry.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( ! instanceInfo[ i ].visible || ! instanceInfo[ i ].active ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\t\t\tconst geometryInfo = geometryInfoList[ geometryId ];\n\t\t\t_mesh.geometry.setDrawRange( geometryInfo.start, geometryInfo.count );\n\n\t\t\t// get the intersects\n\t\t\tthis.getMatrixAt( i, _mesh.matrixWorld ).premultiply( matrixWorld );\n\t\t\tthis.getBoundingBoxAt( geometryId, _mesh.geometry.boundingBox );\n\t\t\tthis.getBoundingSphereAt( geometryId, _mesh.geometry.boundingSphere );\n\t\t\t_mesh.raycast( raycaster, _batchIntersects );\n\n\t\t\t// add batch id to the intersects\n\t\t\tfor ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {\n\n\t\t\t\tconst intersect = _batchIntersects[ j ];\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersect.batchId = i;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_batchIntersects.length = 0;\n\n\t\t}\n\n\t\t_mesh.material = null;\n\t\t_mesh.geometry.index = null;\n\t\t_mesh.geometry.attributes = {};\n\t\t_mesh.geometry.setDrawRange( 0, Infinity );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.geometry = source.geometry.clone();\n\t\tthis.perObjectFrustumCulled = source.perObjectFrustumCulled;\n\t\tthis.sortObjects = source.sortObjects;\n\t\tthis.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null;\n\t\tthis.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null;\n\n\t\tthis._geometryInfo = source._geometryInfo.map( info => ( {\n\t\t\t...info,\n\n\t\t\tboundingBox: info.boundingBox !== null ? info.boundingBox.clone() : null,\n\t\t\tboundingSphere: info.boundingSphere !== null ? info.boundingSphere.clone() : null,\n\t\t} ) );\n\t\tthis._instanceInfo = source._instanceInfo.map( info => ( { ...info } ) );\n\n\t\tthis._maxInstanceCount = source._maxInstanceCount;\n\t\tthis._maxVertexCount = source._maxVertexCount;\n\t\tthis._maxIndexCount = source._maxIndexCount;\n\n\t\tthis._geometryInitialized = source._geometryInitialized;\n\t\tthis._geometryCount = source._geometryCount;\n\t\tthis._multiDrawCounts = source._multiDrawCounts.slice();\n\t\tthis._multiDrawStarts = source._multiDrawStarts.slice();\n\n\t\tthis._matricesTexture = source._matricesTexture.clone();\n\t\tthis._matricesTexture.image.data = this._matricesTexture.image.data.slice();\n\n\t\tif ( this._colorsTexture !== null ) {\n\n\t\t\tthis._colorsTexture = source._colorsTexture.clone();\n\t\t\tthis._colorsTexture.image.data = this._colorsTexture.image.data.slice();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\t// Assuming the geometry is not shared with other meshes\n\t\tthis.geometry.dispose();\n\n\t\tthis._matricesTexture.dispose();\n\t\tthis._matricesTexture = null;\n\n\t\tthis._indirectTexture.dispose();\n\t\tthis._indirectTexture = null;\n\n\t\tif ( this._colorsTexture !== null ) {\n\n\t\t\tthis._colorsTexture.dispose();\n\t\t\tthis._colorsTexture = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tonBeforeRender( renderer, scene, camera, geometry, material/*, _group*/ ) {\n\n\t\t// if visibility has not changed and frustum culling and object sorting is not required\n\t\t// then skip iterating over all items\n\t\tif ( ! this._visibilityChanged && ! this.perObjectFrustumCulled && ! this.sortObjects ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// the indexed version of the multi draw function requires specifying the start\n\t\t// offset in bytes.\n\t\tconst index = geometry.getIndex();\n\t\tconst bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;\n\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tconst multiDrawStarts = this._multiDrawStarts;\n\t\tconst multiDrawCounts = this._multiDrawCounts;\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tconst perObjectFrustumCulled = this.perObjectFrustumCulled;\n\t\tconst indirectTexture = this._indirectTexture;\n\t\tconst indirectArray = indirectTexture.image.data;\n\n\t\t// prepare the frustum in the local frame\n\t\tif ( perObjectFrustumCulled ) {\n\n\t\t\t_matrix$1\n\t\t\t\t.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse )\n\t\t\t\t.multiply( this.matrixWorld );\n\t\t\t_frustum.setFromProjectionMatrix(\n\t\t\t\t_matrix$1,\n\t\t\t\trenderer.coordinateSystem\n\t\t\t);\n\n\t\t}\n\n\t\tlet multiDrawCount = 0;\n\t\tif ( this.sortObjects ) {\n\n\t\t\t// get the camera position in the local frame\n\t\t\t_matrix$1.copy( this.matrixWorld ).invert();\n\t\t\t_vector$5.setFromMatrixPosition( camera.matrixWorld ).applyMatrix4( _matrix$1 );\n\t\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld ).transformDirection( _matrix$1 );\n\n\t\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\t\tif ( instanceInfo[ i ].visible && instanceInfo[ i ].active ) {\n\n\t\t\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\n\t\t\t\t\t// get the bounds in world space\n\t\t\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\t\t\tthis.getBoundingSphereAt( geometryId, _sphere$2 ).applyMatrix4( _matrix$1 );\n\n\t\t\t\t\t// determine whether the batched geometry is within the frustum\n\t\t\t\t\tlet culled = false;\n\t\t\t\t\tif ( perObjectFrustumCulled ) {\n\n\t\t\t\t\t\tculled = ! _frustum.intersectsSphere( _sphere$2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! culled ) {\n\n\t\t\t\t\t\t// get the distance from camera used for sorting\n\t\t\t\t\t\tconst geometryInfo = geometryInfoList[ geometryId ];\n\t\t\t\t\t\tconst z = _temp.subVectors( _sphere$2.center, _vector$5 ).dot( _forward );\n\t\t\t\t\t\t_renderList.push( geometryInfo.start, geometryInfo.count, z, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Sort the draw ranges and prep for rendering\n\t\t\tconst list = _renderList.list;\n\t\t\tconst customSort = this.customSort;\n\t\t\tif ( customSort === null ) {\n\n\t\t\t\tlist.sort( material.transparent ? sortTransparent : sortOpaque );\n\n\t\t\t} else {\n\n\t\t\t\tcustomSort.call( this, list, camera );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = list.length; i < l; i ++ ) {\n\n\t\t\t\tconst item = list[ i ];\n\t\t\t\tmultiDrawStarts[ multiDrawCount ] = item.start * bytesPerElement;\n\t\t\t\tmultiDrawCounts[ multiDrawCount ] = item.count;\n\t\t\t\tindirectArray[ multiDrawCount ] = item.index;\n\t\t\t\tmultiDrawCount ++;\n\n\t\t\t}\n\n\t\t\t_renderList.reset();\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\t\tif ( instanceInfo[ i ].visible && instanceInfo[ i ].active ) {\n\n\t\t\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\n\t\t\t\t\t// determine whether the batched geometry is within the frustum\n\t\t\t\t\tlet culled = false;\n\t\t\t\t\tif ( perObjectFrustumCulled ) {\n\n\t\t\t\t\t\t// get the bounds in world space\n\t\t\t\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\t\t\t\tthis.getBoundingSphereAt( geometryId, _sphere$2 ).applyMatrix4( _matrix$1 );\n\t\t\t\t\t\tculled = ! _frustum.intersectsSphere( _sphere$2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! culled ) {\n\n\t\t\t\t\t\tconst geometryInfo = geometryInfoList[ geometryId ];\n\t\t\t\t\t\tmultiDrawStarts[ multiDrawCount ] = geometryInfo.start * bytesPerElement;\n\t\t\t\t\t\tmultiDrawCounts[ multiDrawCount ] = geometryInfo.count;\n\t\t\t\t\t\tindirectArray[ multiDrawCount ] = i;\n\t\t\t\t\t\tmultiDrawCount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tindirectTexture.needsUpdate = true;\n\t\tthis._multiDrawCount = multiDrawCount;\n\t\tthis._visibilityChanged = false;\n\n\t}\n\n\tonBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial/* , group */ ) {\n\n\t\tthis.onBeforeRender( renderer, null, shadowCamera, geometry, depthMaterial );\n\n\t}\n\n}\n\nclass LineBasicMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isLineBasicMaterial = true;\n\n\t\tthis.type = 'LineBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.linewidth = 1;\n\t\tthis.linecap = 'round';\n\t\tthis.linejoin = 'round';\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.linewidth = source.linewidth;\n\t\tthis.linecap = source.linecap;\n\t\tthis.linejoin = source.linejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _vStart = /*@__PURE__*/ new Vector3();\nconst _vEnd = /*@__PURE__*/ new Vector3();\n\nconst _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();\nconst _ray$1 = /*@__PURE__*/ new Ray();\nconst _sphere$1 = /*@__PURE__*/ new Sphere();\n\nconst _intersectPointOnRay = /*@__PURE__*/ new Vector3();\nconst _intersectPointOnSegment = /*@__PURE__*/ new Vector3();\n\nclass Line extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isLine = true;\n\n\t\tthis.type = 'Line';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.material = Array.isArray( source.material ) ? source.material.slice() : source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\t// we assume non-indexed geometry\n\n\t\tif ( geometry.index === null ) {\n\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst lineDistances = [ 0 ];\n\n\t\t\tfor ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t_vStart.fromBufferAttribute( positionAttribute, i - 1 );\n\t\t\t\t_vEnd.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\tlineDistances[ i ] += _vStart.distanceTo( _vEnd );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Line.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere$1.copy( geometry.boundingSphere );\n\t\t_sphere$1.applyMatrix4( matrixWorld );\n\t\t_sphere$1.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix$1.copy( matrixWorld ).invert();\n\t\t_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst step = this.isLineSegments ? 2 : 1;\n\n\t\tconst index = geometry.index;\n\t\tconst attributes = geometry.attributes;\n\t\tconst positionAttribute = attributes.position;\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\tconst a = index.getX( i );\n\t\t\t\tconst b = index.getX( i + 1 );\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.isLineLoop ) {\n\n\t\t\t\tconst a = index.getX( end - 1 );\n\t\t\t\tconst b = index.getX( start );\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, i, i + 1 );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.isLineLoop ) {\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, end - 1, start );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction checkIntersection( object, raycaster, ray, thresholdSq, a, b ) {\n\n\tconst positionAttribute = object.geometry.attributes.position;\n\n\t_vStart.fromBufferAttribute( positionAttribute, a );\n\t_vEnd.fromBufferAttribute( positionAttribute, b );\n\n\tconst distSq = ray.distanceSqToSegment( _vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment );\n\n\tif ( distSq > thresholdSq ) return;\n\n\t_intersectPointOnRay.applyMatrix4( object.matrixWorld ); // Move back to world space for distance calculation\n\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectPointOnRay );\n\n\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\treturn {\n\n\t\tdistance: distance,\n\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t// point: raycaster.ray.at( distance ),\n\t\tpoint: _intersectPointOnSegment.clone().applyMatrix4( object.matrixWorld ),\n\t\tindex: a,\n\t\tface: null,\n\t\tfaceIndex: null,\n\t\tbarycoord: null,\n\t\tobject: object\n\n\t};\n\n}\n\nconst _start = /*@__PURE__*/ new Vector3();\nconst _end = /*@__PURE__*/ new Vector3();\n\nclass LineSegments extends Line {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineSegments = true;\n\n\t\tthis.type = 'LineSegments';\n\n\t}\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\t// we assume non-indexed geometry\n\n\t\tif ( geometry.index === null ) {\n\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst lineDistances = [];\n\n\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {\n\n\t\t\t\t_start.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t_end.fromBufferAttribute( positionAttribute, i + 1 );\n\n\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineLoop extends Line {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineLoop = true;\n\n\t\tthis.type = 'LineLoop';\n\n\t}\n\n}\n\nclass PointsMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isPointsMaterial = true;\n\n\t\tthis.type = 'PointsMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.size = 1;\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.size = source.size;\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _inverseMatrix = /*@__PURE__*/ new Matrix4();\nconst _ray = /*@__PURE__*/ new Ray();\nconst _sphere = /*@__PURE__*/ new Sphere();\nconst _position$2 = /*@__PURE__*/ new Vector3();\n\nclass Points extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isPoints = true;\n\n\t\tthis.type = 'Points';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.material = Array.isArray( source.material ) ? source.material.slice() : source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Points.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\t\t_sphere.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst index = geometry.index;\n\t\tconst attributes = geometry.attributes;\n\t\tconst positionAttribute = attributes.position;\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, il = end; i < il; i ++ ) {\n\n\t\t\t\tconst a = index.getX( i );\n\n\t\t\t\t_position$2.fromBufferAttribute( positionAttribute, a );\n\n\t\t\t\ttestPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end; i < l; i ++ ) {\n\n\t\t\t\t_position$2.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\ttestPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {\n\n\tconst rayPointDistanceSq = _ray.distanceSqToPoint( point );\n\n\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\tconst intersectPoint = new Vector3();\n\n\t\t_ray.closestPointToPoint( point, intersectPoint );\n\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\tpoint: intersectPoint,\n\t\t\tindex: index,\n\t\t\tface: null,\n\t\t\tfaceIndex: null,\n\t\t\tbarycoord: null,\n\t\t\tobject: object\n\n\t\t} );\n\n\t}\n\n}\n\nclass Group extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isGroup = true;\n\n\t\tthis.type = 'Group';\n\n\t}\n\n}\n\nclass VideoTexture extends Texture {\n\n\tconstructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tsuper( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.isVideoTexture = true;\n\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\n\t\tthis.generateMipmaps = false;\n\n\t\tconst scope = this;\n\n\t\tfunction updateVideo() {\n\n\t\t\tscope.needsUpdate = true;\n\t\t\tvideo.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t\tif ( 'requestVideoFrameCallback' in video ) {\n\n\t\t\tvideo.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.image ).copy( this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst video = this.image;\n\t\tconst hasVideoFrameCallback = 'requestVideoFrameCallback' in video;\n\n\t\tif ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass FramebufferTexture extends Texture {\n\n\tconstructor( width, height ) {\n\n\t\tsuper( { width, height } );\n\n\t\tthis.isFramebufferTexture = true;\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.generateMipmaps = false;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nclass CompressedTexture extends Texture {\n\n\tconstructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace ) {\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isCompressedTexture = true;\n\n\t\tthis.image = { width: width, height: height };\n\t\tthis.mipmaps = mipmaps;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\tthis.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\tthis.generateMipmaps = false;\n\n\t}\n\n}\n\nclass CompressedArrayTexture extends CompressedTexture {\n\n\tconstructor( mipmaps, width, height, depth, format, type ) {\n\n\t\tsuper( mipmaps, width, height, format, type );\n\n\t\tthis.isCompressedArrayTexture = true;\n\t\tthis.image.depth = depth;\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.layerUpdates = new Set();\n\n\t}\n\n\taddLayerUpdate( layerIndex ) {\n\n\t\tthis.layerUpdates.add( layerIndex );\n\n\t}\n\n\tclearLayerUpdates() {\n\n\t\tthis.layerUpdates.clear();\n\n\t}\n\n}\n\nclass CompressedCubeTexture extends CompressedTexture {\n\n\tconstructor( images, format, type ) {\n\n\t\tsuper( undefined, images[ 0 ].width, images[ 0 ].height, format, type, CubeReflectionMapping );\n\n\t\tthis.isCompressedCubeTexture = true;\n\t\tthis.isCubeTexture = true;\n\n\t\tthis.image = images;\n\n\t}\n\n}\n\nclass CanvasTexture extends Texture {\n\n\tconstructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tsuper( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.isCanvasTexture = true;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nclass DepthTexture extends Texture {\n\n\tconstructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format = DepthFormat ) {\n\n\t\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\n\t\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );\n\n\t\t}\n\n\t\tif ( type === undefined && format === DepthFormat ) type = UnsignedIntType;\n\t\tif ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.isDepthTexture = true;\n\n\t\tthis.image = { width: width, height: height };\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.flipY = false;\n\t\tthis.generateMipmaps = false;\n\n\t\tthis.compareFunction = null;\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.compareFunction = source.compareFunction;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.compareFunction !== null ) data.compareFunction = this.compareFunction;\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * Extensible curve object.\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\nclass Curve {\n\n\tconstructor() {\n\n\t\tthis.type = 'Curve';\n\n\t\tthis.arcLengthDivisions = 200;\n\n\t}\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint( /* t, optionalTarget */ ) {\n\n\t\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\n\t\treturn null;\n\n\t}\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t, optionalTarget );\n\n\t}\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get total curve arc length\n\n\tgetLength() {\n\n\t\tconst lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t}\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths( divisions = this.arcLengthDivisions ) {\n\n\t\tif ( this.cacheArcLengths &&\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\n\t\t\t! this.needsUpdate ) {\n\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tconst cache = [];\n\t\tlet current, last = this.getPoint( 0 );\n\t\tlet sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( let p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\n\t}\n\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t}\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping( u, distance ) {\n\n\t\tconst arcLengths = this.getLengths();\n\n\t\tlet i = 0;\n\t\tconst il = arcLengths.length;\n\n\t\tlet targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tlet low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\treturn i / ( il - 1 );\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tconst lengthBefore = arcLengths[ i ];\n\t\tconst lengthAfter = arcLengths[ i + 1 ];\n\n\t\tconst segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tconst segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tconst t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t}\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent( t, optionalTarget ) {\n\n\t\tconst delta = 0.0001;\n\t\tlet t1 = t - delta;\n\t\tlet t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tconst pt1 = this.getPoint( t1 );\n\t\tconst pt2 = this.getPoint( t2 );\n\n\t\tconst tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );\n\n\t\ttangent.copy( pt2 ).sub( pt1 ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t, optionalTarget );\n\n\t}\n\n\tcomputeFrenetFrames( segments, closed ) {\n\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\tconst normal = new Vector3();\n\n\t\tconst tangents = [];\n\t\tconst normals = [];\n\t\tconst binormals = [];\n\n\t\tconst vec = new Vector3();\n\t\tconst mat = new Matrix4();\n\n\t\t// compute the tangent vectors for each segment on the curve\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst u = i / segments;\n\n\t\t\ttangents[ i ] = this.getTangentAt( u, new Vector3() );\n\n\t\t}\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the minimum tangent xyz component\n\n\t\tnormals[ 0 ] = new Vector3();\n\t\tbinormals[ 0 ] = new Vector3();\n\t\tlet min = Number.MAX_VALUE;\n\t\tconst tx = Math.abs( tangents[ 0 ].x );\n\t\tconst ty = Math.abs( tangents[ 0 ].y );\n\t\tconst tz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= min ) {\n\n\t\t\tmin = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= min ) {\n\n\t\t\tmin = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= min ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\tvec.normalize();\n\n\t\t\t\tconst theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t}\n\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\tif ( closed === true ) {\n\n\t\t\tlet theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\ttheta /= segments;\n\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\ttheta = - theta;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t// twist a little...\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\ttangents: tangents,\n\t\t\tnormals: normals,\n\t\t\tbinormals: binormals\n\t\t};\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Curve',\n\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t}\n\t\t};\n\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\tdata.type = this.type;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass EllipseCurve extends Curve {\n\n\tconstructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.isEllipseCurve = true;\n\n\t\tthis.type = 'EllipseCurve';\n\n\t\tthis.aX = aX;\n\t\tthis.aY = aY;\n\n\t\tthis.xRadius = xRadius;\n\t\tthis.yRadius = yRadius;\n\n\t\tthis.aStartAngle = aStartAngle;\n\t\tthis.aEndAngle = aEndAngle;\n\n\t\tthis.aClockwise = aClockwise;\n\n\t\tthis.aRotation = aRotation;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst twoPi = Math.PI * 2;\n\t\tlet deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\tconst samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\t\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\t\tif ( samePoints ) {\n\n\t\t\t\tdeltaAngle = 0;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\t\tdeltaAngle = - twoPi;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst angle = this.aStartAngle + t * deltaAngle;\n\t\tlet x = this.aX + this.xRadius * Math.cos( angle );\n\t\tlet y = this.aY + this.yRadius * Math.sin( angle );\n\n\t\tif ( this.aRotation !== 0 ) {\n\n\t\t\tconst cos = Math.cos( this.aRotation );\n\t\t\tconst sin = Math.sin( this.aRotation );\n\n\t\t\tconst tx = x - this.aX;\n\t\t\tconst ty = y - this.aY;\n\n\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\ty = tx * sin + ty * cos + this.aY;\n\n\t\t}\n\n\t\treturn point.set( x, y );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.aX = source.aX;\n\t\tthis.aY = source.aY;\n\n\t\tthis.xRadius = source.xRadius;\n\t\tthis.yRadius = source.yRadius;\n\n\t\tthis.aStartAngle = source.aStartAngle;\n\t\tthis.aEndAngle = source.aEndAngle;\n\n\t\tthis.aClockwise = source.aClockwise;\n\n\t\tthis.aRotation = source.aRotation;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.aX = this.aX;\n\t\tdata.aY = this.aY;\n\n\t\tdata.xRadius = this.xRadius;\n\t\tdata.yRadius = this.yRadius;\n\n\t\tdata.aStartAngle = this.aStartAngle;\n\t\tdata.aEndAngle = this.aEndAngle;\n\n\t\tdata.aClockwise = this.aClockwise;\n\n\t\tdata.aRotation = this.aRotation;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.aX = json.aX;\n\t\tthis.aY = json.aY;\n\n\t\tthis.xRadius = json.xRadius;\n\t\tthis.yRadius = json.yRadius;\n\n\t\tthis.aStartAngle = json.aStartAngle;\n\t\tthis.aEndAngle = json.aEndAngle;\n\n\t\tthis.aClockwise = json.aClockwise;\n\n\t\tthis.aRotation = json.aRotation;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass ArcCurve extends EllipseCurve {\n\n\tconstructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tsuper( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\tthis.isArcCurve = true;\n\n\t\tthis.type = 'ArcCurve';\n\n\t}\n\n}\n\n/**\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\n\n/*\nBased on an optimized c++ solution in\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n - http://ideone.com/NoEbVM\n\nThis CubicPoly class could be used for reusing some variables and calculations,\nbut for three.js curve use, it could be possible inlined and flatten into a single function call\nwhich can be placed in CurveUtils.\n*/\n\nfunction CubicPoly() {\n\n\tlet c0 = 0, c1 = 0, c2 = 0, c3 = 0;\n\n\t/*\n\t * Compute coefficients for a cubic polynomial\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t * such that\n\t *   p(0) = x0, p(1) = x1\n\t *  and\n\t *   p'(0) = t0, p'(1) = t1.\n\t */\n\tfunction init( x0, x1, t0, t1 ) {\n\n\t\tc0 = x0;\n\t\tc1 = t0;\n\t\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t}\n\n\treturn {\n\n\t\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\n\n\t\t\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t\t},\n\n\t\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tlet t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tlet t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\n\t\t\tinit( x1, x2, t1, t2 );\n\n\t\t},\n\n\t\tcalc: function ( t ) {\n\n\t\t\tconst t2 = t * t;\n\t\t\tconst t3 = t2 * t;\n\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\n\n\t\t}\n\n\t};\n\n}\n\n//\n\nconst tmp = /*@__PURE__*/ new Vector3();\nconst px = /*@__PURE__*/ new CubicPoly();\nconst py = /*@__PURE__*/ new CubicPoly();\nconst pz = /*@__PURE__*/ new CubicPoly();\n\nclass CatmullRomCurve3 extends Curve {\n\n\tconstructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {\n\n\t\tsuper();\n\n\t\tthis.isCatmullRomCurve3 = true;\n\n\t\tthis.type = 'CatmullRomCurve3';\n\n\t\tthis.points = points;\n\t\tthis.closed = closed;\n\t\tthis.curveType = curveType;\n\t\tthis.tension = tension;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst points = this.points;\n\t\tconst l = points.length;\n\n\t\tconst p = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\tlet intPoint = Math.floor( p );\n\t\tlet weight = p - intPoint;\n\n\t\tif ( this.closed ) {\n\n\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;\n\n\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\tintPoint = l - 2;\n\t\t\tweight = 1;\n\n\t\t}\n\n\t\tlet p0, p3; // 4 points (p1 & p2 defined below)\n\n\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate first point\n\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\tp0 = tmp;\n\n\t\t}\n\n\t\tconst p1 = points[ intPoint % l ];\n\t\tconst p2 = points[ ( intPoint + 1 ) % l ];\n\n\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate last point\n\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\tp3 = tmp;\n\n\t\t}\n\n\t\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\n\n\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\tconst pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n\t\t\tlet dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\tlet dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\tlet dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t// safety check for repeated points\n\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t} else if ( this.curveType === 'catmullrom' ) {\n\n\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\n\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\n\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\n\n\t\t}\n\n\t\tpoint.set(\n\t\t\tpx.calc( weight ),\n\t\t\tpy.calc( weight ),\n\t\t\tpz.calc( weight )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\tthis.closed = source.closed;\n\t\tthis.curveType = source.curveType;\n\t\tthis.tension = source.tension;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.points = [];\n\n\t\tfor ( let i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\tdata.closed = this.closed;\n\t\tdata.curveType = this.curveType;\n\t\tdata.tension = this.tension;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = json.points[ i ];\n\t\t\tthis.points.push( new Vector3().fromArray( point ) );\n\n\t\t}\n\n\t\tthis.closed = json.closed;\n\t\tthis.curveType = json.curveType;\n\t\tthis.tension = json.tension;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * Bezier Curves formulas obtained from\n * https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n */\n\nfunction CatmullRom( t, p0, p1, p2, p3 ) {\n\n\tconst v0 = ( p2 - p0 ) * 0.5;\n\tconst v1 = ( p3 - p1 ) * 0.5;\n\tconst t2 = t * t;\n\tconst t3 = t * t2;\n\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n}\n\n//\n\nfunction QuadraticBezierP0( t, p ) {\n\n\tconst k = 1 - t;\n\treturn k * k * p;\n\n}\n\nfunction QuadraticBezierP1( t, p ) {\n\n\treturn 2 * ( 1 - t ) * t * p;\n\n}\n\nfunction QuadraticBezierP2( t, p ) {\n\n\treturn t * t * p;\n\n}\n\nfunction QuadraticBezier( t, p0, p1, p2 ) {\n\n\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\n\t\tQuadraticBezierP2( t, p2 );\n\n}\n\n//\n\nfunction CubicBezierP0( t, p ) {\n\n\tconst k = 1 - t;\n\treturn k * k * k * p;\n\n}\n\nfunction CubicBezierP1( t, p ) {\n\n\tconst k = 1 - t;\n\treturn 3 * k * k * t * p;\n\n}\n\nfunction CubicBezierP2( t, p ) {\n\n\treturn 3 * ( 1 - t ) * t * t * p;\n\n}\n\nfunction CubicBezierP3( t, p ) {\n\n\treturn t * t * t * p;\n\n}\n\nfunction CubicBezier( t, p0, p1, p2, p3 ) {\n\n\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\n\t\tCubicBezierP3( t, p3 );\n\n}\n\nclass CubicBezierCurve extends Curve {\n\n\tconstructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.isCubicBezierCurve = true;\n\n\t\tthis.type = 'CubicBezierCurve';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass CubicBezierCurve3 extends Curve {\n\n\tconstructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.isCubicBezierCurve3 = true;\n\n\t\tthis.type = 'CubicBezierCurve3';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\n\t\t\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineCurve extends Curve {\n\n\tconstructor( v1 = new Vector2(), v2 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.isLineCurve = true;\n\n\t\tthis.type = 'LineCurve';\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new Vector2() ) {\n\n\t\treturn optionalTarget.subVectors( this.v2, this.v1 ).normalize();\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\treturn this.getTangent( u, optionalTarget );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineCurve3 extends Curve {\n\n\tconstructor( v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.isLineCurve3 = true;\n\n\t\tthis.type = 'LineCurve3';\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new Vector3() ) {\n\n\t\treturn optionalTarget.subVectors( this.v2, this.v1 ).normalize();\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\treturn this.getTangent( u, optionalTarget );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass QuadraticBezierCurve extends Curve {\n\n\tconstructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.isQuadraticBezierCurve = true;\n\n\t\tthis.type = 'QuadraticBezierCurve';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass QuadraticBezierCurve3 extends Curve {\n\n\tconstructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.isQuadraticBezierCurve3 = true;\n\n\t\tthis.type = 'QuadraticBezierCurve3';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\n\t\t\tQuadraticBezier( t, v0.z, v1.z, v2.z )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass SplineCurve extends Curve {\n\n\tconstructor( points = [] ) {\n\n\t\tsuper();\n\n\t\tthis.isSplineCurve = true;\n\n\t\tthis.type = 'SplineCurve';\n\n\t\tthis.points = points;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst points = this.points;\n\t\tconst p = ( points.length - 1 ) * t;\n\n\t\tconst intPoint = Math.floor( p );\n\t\tconst weight = p - intPoint;\n\n\t\tconst p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\tconst p1 = points[ intPoint ];\n\t\tconst p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tconst p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tpoint.set(\n\t\t\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\n\t\t\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.points = [];\n\n\t\tfor ( let i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = json.points[ i ];\n\t\t\tthis.points.push( new Vector2().fromArray( point ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nvar Curves = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tArcCurve: ArcCurve,\n\tCatmullRomCurve3: CatmullRomCurve3,\n\tCubicBezierCurve: CubicBezierCurve,\n\tCubicBezierCurve3: CubicBezierCurve3,\n\tEllipseCurve: EllipseCurve,\n\tLineCurve: LineCurve,\n\tLineCurve3: LineCurve3,\n\tQuadraticBezierCurve: QuadraticBezierCurve,\n\tQuadraticBezierCurve3: QuadraticBezierCurve3,\n\tSplineCurve: SplineCurve\n});\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nclass CurvePath extends Curve {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'CurvePath';\n\n\t\tthis.curves = [];\n\t\tthis.autoClose = false; // Automatically closes the path\n\n\t}\n\n\tadd( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t}\n\n\tclosePath() {\n\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tconst startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tconst endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tconst lineType = ( startPoint.isVector2 === true ) ? 'LineCurve' : 'LineCurve3';\n\t\t\tthis.curves.push( new Curves[ lineType ]( endPoint, startPoint ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint( t, optionalTarget ) {\n\n\t\tconst d = t * this.getLength();\n\t\tconst curveLengths = this.getCurveLengths();\n\t\tlet i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tconst diff = curveLengths[ i ] - d;\n\t\t\t\tconst curve = this.curves[ i ];\n\n\t\t\t\tconst segmentLength = curve.getLength();\n\t\t\t\tconst u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\treturn curve.getPointAt( u, optionalTarget );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t}\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength() {\n\n\t\tconst lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t}\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getCurveLengths();\n\n\t}\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths() {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tconst lengths = [];\n\t\tlet sums = 0;\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t}\n\n\tgetSpacedPoints( divisions = 40 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let i = 0; i <= divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tgetPoints( divisions = 12 ) {\n\n\t\tconst points = [];\n\t\tlet last;\n\n\t\tfor ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\tconst curve = curves[ i ];\n\t\t\tconst resolution = curve.isEllipseCurve ? divisions * 2\n\t\t\t\t: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1\n\t\t\t\t\t: curve.isSplineCurve ? divisions * curve.points.length\n\t\t\t\t\t\t: divisions;\n\n\t\t\tconst pts = curve.getPoints( resolution );\n\n\t\t\tfor ( let j = 0; j < pts.length; j ++ ) {\n\n\t\t\t\tconst point = pts[ j ];\n\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\tpoints.push( point );\n\t\t\t\tlast = point;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = source.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = source.curves[ i ];\n\n\t\t\tthis.curves.push( curve.clone() );\n\n\t\t}\n\n\t\tthis.autoClose = source.autoClose;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.autoClose = this.autoClose;\n\t\tdata.curves = [];\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = this.curves[ i ];\n\t\t\tdata.curves.push( curve.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.autoClose = json.autoClose;\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = json.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = json.curves[ i ];\n\t\t\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Path extends CurvePath {\n\n\tconstructor( points ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Path';\n\n\t\tthis.currentPoint = new Vector2();\n\n\t\tif ( points ) {\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t}\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\n\n\t\tfor ( let i = 1, l = points.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( points[ i ].x, points[ i ].y );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t\treturn this;\n\n\t}\n\n\tlineTo( x, y ) {\n\n\t\tconst curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tconst curve = new QuadraticBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tconst curve = new CubicBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tsplineThru( pts /*Array of Vector*/ ) {\n\n\t\tconst npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\tconst curve = new SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t\treturn this;\n\n\t}\n\n\tarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\tabsarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\tellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\treturn this;\n\n\t}\n\n\tabsellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t// if a previous curve is present, attempt to join\n\t\t\tconst firstPoint = curve.getPoint( 0 );\n\n\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.curves.push( curve );\n\n\t\tconst lastPoint = curve.getPoint( 1 );\n\t\tthis.currentPoint.copy( lastPoint );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.currentPoint.copy( source.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.currentPoint = this.currentPoint.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.currentPoint.fromArray( json.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LatheGeometry extends BufferGeometry {\n\n\tconstructor( points = [ new Vector2( 0, - 0.5 ), new Vector2( 0.5, 0 ), new Vector2( 0, 0.5 ) ], segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LatheGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tsegments = Math.floor( segments );\n\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\n\t\tphiLength = clamp( phiLength, 0, Math.PI * 2 );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst uvs = [];\n\t\tconst initNormals = [];\n\t\tconst normals = [];\n\n\t\t// helper variables\n\n\t\tconst inverseSegments = 1.0 / segments;\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tconst normal = new Vector3();\n\t\tconst curNormal = new Vector3();\n\t\tconst prevNormal = new Vector3();\n\t\tlet dx = 0;\n\t\tlet dy = 0;\n\n\t\t// pre-compute normals for initial \"meridian\"\n\n\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\tswitch ( j ) {\n\n\t\t\t\tcase 0:\t\t\t\t// special handling for 1st vertex on path\n\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\n\n\t\t\t\t\tnormal.x = dy * 1.0;\n\t\t\t\t\tnormal.y = - dx;\n\t\t\t\t\tnormal.z = dy * 0.0;\n\n\t\t\t\t\tprevNormal.copy( normal );\n\n\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ( points.length - 1 ):\t// special handling for last Vertex on path\n\n\t\t\t\t\tinitNormals.push( prevNormal.x, prevNormal.y, prevNormal.z );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\t\t\t// default handling for all vertices in between\n\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\n\n\t\t\t\t\tnormal.x = dy * 1.0;\n\t\t\t\t\tnormal.y = - dx;\n\t\t\t\t\tnormal.z = dy * 0.0;\n\n\t\t\t\t\tcurNormal.copy( normal );\n\n\t\t\t\t\tnormal.x += prevNormal.x;\n\t\t\t\t\tnormal.y += prevNormal.y;\n\t\t\t\t\tnormal.z += prevNormal.z;\n\n\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\tprevNormal.copy( curNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate vertices, uvs and normals\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst phi = phiStart + i * inverseSegments * phiLength;\n\n\t\t\tconst sin = Math.sin( phi );\n\t\t\tconst cos = Math.cos( phi );\n\n\t\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// normal\n\n\t\t\t\tconst x = initNormals[ 3 * j + 0 ] * sin;\n\t\t\t\tconst y = initNormals[ 3 * j + 1 ];\n\t\t\t\tconst z = initNormals[ 3 * j + 0 ] * cos;\n\n\t\t\t\tnormals.push( x, y, z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 0; i < segments; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\t\tconst base = j + i * points.length;\n\n\t\t\t\tconst a = base;\n\t\t\t\tconst b = base + points.length;\n\t\t\t\tconst c = base + points.length + 1;\n\t\t\t\tconst d = base + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( c, d, b );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );\n\n\t}\n\n}\n\nclass CapsuleGeometry extends LatheGeometry {\n\n\tconstructor( radius = 1, length = 1, capSegments = 4, radialSegments = 8 ) {\n\n\t\tconst path = new Path();\n\t\tpath.absarc( 0, - length / 2, radius, Math.PI * 1.5, 0 );\n\t\tpath.absarc( 0, length / 2, radius, 0, Math.PI * 0.5 );\n\n\t\tsuper( path.getPoints( capSegments ), radialSegments );\n\n\t\tthis.type = 'CapsuleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tlength: length,\n\t\t\tcapSegments: capSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CapsuleGeometry( data.radius, data.length, data.capSegments, data.radialSegments );\n\n\t}\n\n}\n\nclass CircleGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CircleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tsegments = Math.max( 3, segments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// center point\n\n\t\tvertices.push( 0, 0, 0 );\n\t\tnormals.push( 0, 0, 1 );\n\t\tuvs.push( 0.5, 0.5 );\n\n\t\tfor ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {\n\n\t\t\tconst segment = thetaStart + s / segments * thetaLength;\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t// uvs\n\n\t\t\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\n\t\t\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tindices.push( i, i + 1, 0 );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass CylinderGeometry extends BufferGeometry {\n\n\tconstructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CylinderGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tconst scope = this;\n\n\t\tradialSegments = Math.floor( radialSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet index = 0;\n\t\tconst indexArray = [];\n\t\tconst halfHeight = height / 2;\n\t\tlet groupStart = 0;\n\n\t\t// generate geometry\n\n\t\tgenerateTorso();\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction generateTorso() {\n\n\t\t\tconst normal = new Vector3();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\t// this will be used to calculate the normal\n\t\t\tconst slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\t\tconst indexRow = [];\n\n\t\t\t\tconst v = y / heightSegments;\n\n\t\t\t\t// calculate the radius of the current row\n\n\t\t\t\tconst radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\t\tconst u = x / radialSegments;\n\n\t\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\t\tconst sinTheta = Math.sin( theta );\n\t\t\t\t\tconst cosTheta = Math.cos( theta );\n\n\t\t\t\t\t// vertex\n\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t// normal\n\n\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\t// uv\n\n\t\t\t\t\tuvs.push( u, 1 - v );\n\n\t\t\t\t\t// save index of vertex in respective row\n\n\t\t\t\t\tindexRow.push( index ++ );\n\n\t\t\t\t}\n\n\t\t\t\t// now save vertices of the row in our index array\n\n\t\t\t\tindexArray.push( indexRow );\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t\t// we use the index array to access the correct indices\n\n\t\t\t\t\tconst a = indexArray[ y ][ x ];\n\t\t\t\t\tconst b = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tconst c = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tconst d = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tif ( radiusTop > 0 || y !== 0 ) {\n\n\t\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\t\tgroupCount += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( radiusBottom > 0 || y !== heightSegments - 1 ) {\n\n\t\t\t\t\t\tindices.push( b, c, d );\n\t\t\t\t\t\tgroupCount += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t\tfunction generateCap( top ) {\n\n\t\t\t// save the index of the first center vertex\n\t\t\tconst centerIndexStart = index;\n\n\t\t\tconst uv = new Vector2();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tconst sign = ( top === true ) ? 1 : - 1;\n\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\tfor ( let x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertices.push( 0, halfHeight * sign, 0 );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( 0.5, 0.5 );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// save the index of the last center vertex\n\t\t\tconst centerIndexEnd = index;\n\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tconst u = x / radialSegments;\n\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\tconst cosTheta = Math.cos( theta );\n\t\t\t\tconst sinTheta = Math.sin( theta );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tconst c = centerIndexStart + x;\n\t\t\t\tconst i = centerIndexEnd + x;\n\n\t\t\t\tif ( top === true ) {\n\n\t\t\t\t\t// face top\n\n\t\t\t\t\tindices.push( i, i + 1, c );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// face bottom\n\n\t\t\t\t\tindices.push( i + 1, i, c );\n\n\t\t\t\t}\n\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass ConeGeometry extends CylinderGeometry {\n\n\tconstructor( radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new ConeGeometry( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass PolyhedronGeometry extends BufferGeometry {\n\n\tconstructor( vertices = [], indices = [], radius = 1, detail = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PolyhedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\t// default buffer data\n\n\t\tconst vertexBuffer = [];\n\t\tconst uvBuffer = [];\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide( detail );\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tapplyRadius( radius );\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\n\n\t\tif ( detail === 0 ) {\n\n\t\t\tthis.computeVertexNormals(); // flat normals\n\n\t\t} else {\n\n\t\t\tthis.normalizeNormals(); // smooth normals\n\n\t\t}\n\n\t\t// helper functions\n\n\t\tfunction subdivide( detail ) {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivision with the given detail value\n\n\t\t\tfor ( let i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\t\tconst cols = detail + 1;\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tconst v = [];\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor ( let i = 0; i <= cols; i ++ ) {\n\n\t\t\t\tv[ i ] = [];\n\n\t\t\t\tconst aj = a.clone().lerp( c, i / cols );\n\t\t\t\tconst bj = b.clone().lerp( c, i / cols );\n\n\t\t\t\tconst rows = cols - i;\n\n\t\t\t\tfor ( let j = 0; j <= rows; j ++ ) {\n\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor ( let i = 0; i < cols; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\t\tconst k = Math.floor( j / 2 );\n\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction applyRadius( radius ) {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tconst u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\tconst v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t\t}\n\n\t\t\tcorrectUVs();\n\n\t\t\tcorrectSeam();\n\n\t\t}\n\n\t\tfunction correctSeam() {\n\n\t\t\t// handle case when face straddles the seam, see #3269\n\n\t\t\tfor ( let i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t\t// uv data of a single face\n\n\t\t\t\tconst x0 = uvBuffer[ i + 0 ];\n\t\t\t\tconst x1 = uvBuffer[ i + 2 ];\n\t\t\t\tconst x2 = uvBuffer[ i + 4 ];\n\n\t\t\t\tconst max = Math.max( x0, x1, x2 );\n\t\t\t\tconst min = Math.min( x0, x1, x2 );\n\n\t\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushVertex( vertex ) {\n\n\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tfunction getVertexByIndex( index, vertex ) {\n\n\t\t\tconst stride = index * 3;\n\n\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\tvertex.z = vertices[ stride + 2 ];\n\n\t\t}\n\n\t\tfunction correctUVs() {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\tconst centroid = new Vector3();\n\n\t\t\tconst uvA = new Vector2();\n\t\t\tconst uvB = new Vector2();\n\t\t\tconst uvC = new Vector2();\n\n\t\t\tfor ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\t\tconst azi = azimuth( centroid );\n\n\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction correctUV( uv, stride, vector, azimuth ) {\n\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = uv.x - 1;\n\n\t\t\t}\n\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\t\tfunction azimuth( vector ) {\n\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t\t}\n\n\n\t\t// Angle above the XZ plane.\n\n\t\tfunction inclination( vector ) {\n\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );\n\n\t}\n\n}\n\nclass DodecahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\tconst r = 1 / t;\n\n\t\tconst vertices = [\n\n\t\t\t// (±1, ±1, ±1)\n\t\t\t- 1, - 1, - 1,\t- 1, - 1, 1,\n\t\t\t- 1, 1, - 1, - 1, 1, 1,\n\t\t\t1, - 1, - 1, 1, - 1, 1,\n\t\t\t1, 1, - 1, 1, 1, 1,\n\n\t\t\t// (0, ±1/φ, ±φ)\n\t\t\t0, - r, - t, 0, - r, t,\n\t\t\t0, r, - t, 0, r, t,\n\n\t\t\t// (±1/φ, ±φ, 0)\n\t\t\t- r, - t, 0, - r, t, 0,\n\t\t\tr, - t, 0, r, t, 0,\n\n\t\t\t// (±φ, 0, ±1/φ)\n\t\t\t- t, 0, - r, t, 0, - r,\n\t\t\t- t, 0, r, t, 0, r\n\t\t];\n\n\t\tconst indices = [\n\t\t\t3, 11, 7, \t3, 7, 15, \t3, 15, 13,\n\t\t\t7, 19, 17, \t7, 17, 6, \t7, 6, 15,\n\t\t\t17, 4, 8, \t17, 8, 10, \t17, 10, 6,\n\t\t\t8, 0, 16, \t8, 16, 2, \t8, 2, 10,\n\t\t\t0, 12, 1, \t0, 1, 18, \t0, 18, 16,\n\t\t\t6, 10, 2, \t6, 2, 13, \t6, 13, 15,\n\t\t\t2, 16, 18, \t2, 18, 3, \t2, 3, 13,\n\t\t\t18, 1, 9, \t18, 9, 11, \t18, 11, 3,\n\t\t\t4, 14, 12, \t4, 12, 0, \t4, 0, 8,\n\t\t\t11, 9, 5, \t11, 5, 19, \t11, 19, 7,\n\t\t\t19, 5, 14, \t19, 14, 4, \t19, 4, 17,\n\t\t\t1, 12, 14, \t1, 14, 5, \t1, 5, 9\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'DodecahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new DodecahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nconst _v0 = /*@__PURE__*/ new Vector3();\nconst _v1$1 = /*@__PURE__*/ new Vector3();\nconst _normal = /*@__PURE__*/ new Vector3();\nconst _triangle = /*@__PURE__*/ new Triangle();\n\nclass EdgesGeometry extends BufferGeometry {\n\n\tconstructor( geometry = null, thresholdAngle = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'EdgesGeometry';\n\n\t\tthis.parameters = {\n\t\t\tgeometry: geometry,\n\t\t\tthresholdAngle: thresholdAngle\n\t\t};\n\n\t\tif ( geometry !== null ) {\n\n\t\t\tconst precisionPoints = 4;\n\t\t\tconst precision = Math.pow( 10, precisionPoints );\n\t\t\tconst thresholdDot = Math.cos( DEG2RAD * thresholdAngle );\n\n\t\t\tconst indexAttr = geometry.getIndex();\n\t\t\tconst positionAttr = geometry.getAttribute( 'position' );\n\t\t\tconst indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n\n\t\t\tconst indexArr = [ 0, 0, 0 ];\n\t\t\tconst vertKeys = [ 'a', 'b', 'c' ];\n\t\t\tconst hashes = new Array( 3 );\n\n\t\t\tconst edgeData = {};\n\t\t\tconst vertices = [];\n\t\t\tfor ( let i = 0; i < indexCount; i += 3 ) {\n\n\t\t\t\tif ( indexAttr ) {\n\n\t\t\t\t\tindexArr[ 0 ] = indexAttr.getX( i );\n\t\t\t\t\tindexArr[ 1 ] = indexAttr.getX( i + 1 );\n\t\t\t\t\tindexArr[ 2 ] = indexAttr.getX( i + 2 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindexArr[ 0 ] = i;\n\t\t\t\t\tindexArr[ 1 ] = i + 1;\n\t\t\t\t\tindexArr[ 2 ] = i + 2;\n\n\t\t\t\t}\n\n\t\t\t\tconst { a, b, c } = _triangle;\n\t\t\t\ta.fromBufferAttribute( positionAttr, indexArr[ 0 ] );\n\t\t\t\tb.fromBufferAttribute( positionAttr, indexArr[ 1 ] );\n\t\t\t\tc.fromBufferAttribute( positionAttr, indexArr[ 2 ] );\n\t\t\t\t_triangle.getNormal( _normal );\n\n\t\t\t\t// create hashes for the edge from the vertices\n\t\t\t\thashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;\n\t\t\t\thashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;\n\t\t\t\thashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;\n\n\t\t\t\t// skip degenerate triangles\n\t\t\t\tif ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over every edge\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t// get the first and next vertex making up the edge\n\t\t\t\t\tconst jNext = ( j + 1 ) % 3;\n\t\t\t\t\tconst vecHash0 = hashes[ j ];\n\t\t\t\t\tconst vecHash1 = hashes[ jNext ];\n\t\t\t\t\tconst v0 = _triangle[ vertKeys[ j ] ];\n\t\t\t\t\tconst v1 = _triangle[ vertKeys[ jNext ] ];\n\n\t\t\t\t\tconst hash = `${ vecHash0 }_${ vecHash1 }`;\n\t\t\t\t\tconst reverseHash = `${ vecHash1 }_${ vecHash0 }`;\n\n\t\t\t\t\tif ( reverseHash in edgeData && edgeData[ reverseHash ] ) {\n\n\t\t\t\t\t\t// if we found a sibling edge add it into the vertex array if\n\t\t\t\t\t\t// it meets the angle threshold and delete the edge from the map.\n\t\t\t\t\t\tif ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {\n\n\t\t\t\t\t\t\tvertices.push( v0.x, v0.y, v0.z );\n\t\t\t\t\t\t\tvertices.push( v1.x, v1.y, v1.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tedgeData[ reverseHash ] = null;\n\n\t\t\t\t\t} else if ( ! ( hash in edgeData ) ) {\n\n\t\t\t\t\t\t// if we've already got an edge here then skip adding a new one\n\t\t\t\t\t\tedgeData[ hash ] = {\n\n\t\t\t\t\t\t\tindex0: indexArr[ j ],\n\t\t\t\t\t\t\tindex1: indexArr[ jNext ],\n\t\t\t\t\t\t\tnormal: _normal.clone(),\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// iterate over all remaining, unmatched edges and add them to the vertex array\n\t\t\tfor ( const key in edgeData ) {\n\n\t\t\t\tif ( edgeData[ key ] ) {\n\n\t\t\t\t\tconst { index0, index1 } = edgeData[ key ];\n\t\t\t\t\t_v0.fromBufferAttribute( positionAttr, index0 );\n\t\t\t\t\t_v1$1.fromBufferAttribute( positionAttr, index1 );\n\n\t\t\t\t\tvertices.push( _v0.x, _v0.y, _v0.z );\n\t\t\t\t\tvertices.push( _v1$1.x, _v1$1.y, _v1$1.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Shape extends Path {\n\n\tconstructor( points ) {\n\n\t\tsuper( points );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.type = 'Shape';\n\n\t\tthis.holes = [];\n\n\t}\n\n\tgetPointsHoles( divisions ) {\n\n\t\tconst holesPts = [];\n\n\t\tfor ( let i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t}\n\n\t\treturn holesPts;\n\n\t}\n\n\t// get points of shape and holes (keypoints based on segments parameter)\n\n\textractPoints( divisions ) {\n\n\t\treturn {\n\n\t\t\tshape: this.getPoints( divisions ),\n\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t};\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.holes = [];\n\n\t\tfor ( let i = 0, l = source.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = source.holes[ i ];\n\n\t\t\tthis.holes.push( hole.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.holes = [];\n\n\t\tfor ( let i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = this.holes[ i ];\n\t\t\tdata.holes.push( hole.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.uuid = json.uuid;\n\t\tthis.holes = [];\n\n\t\tfor ( let i = 0, l = json.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = json.holes[ i ];\n\t\t\tthis.holes.push( new Path().fromJSON( hole ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * Port from https://github.com/mapbox/earcut (v2.2.4)\n */\n\nconst Earcut = {\n\n\ttriangulate: function ( data, holeIndices, dim = 2 ) {\n\n\t\tconst hasHoles = holeIndices && holeIndices.length;\n\t\tconst outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;\n\t\tlet outerNode = linkedList( data, 0, outerLen, dim, true );\n\t\tconst triangles = [];\n\n\t\tif ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;\n\n\t\tlet minX, minY, maxX, maxY, x, y, invSize;\n\n\t\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\n\n\t\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\t\tif ( data.length > 80 * dim ) {\n\n\t\t\tminX = maxX = data[ 0 ];\n\t\t\tminY = maxY = data[ 1 ];\n\n\t\t\tfor ( let i = dim; i < outerLen; i += dim ) {\n\n\t\t\t\tx = data[ i ];\n\t\t\t\ty = data[ i + 1 ];\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\n\t\t\t}\n\n\t\t\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\t\t\tinvSize = Math.max( maxX - minX, maxY - minY );\n\t\t\tinvSize = invSize !== 0 ? 32767 / invSize : 0;\n\n\t\t}\n\n\t\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize, 0 );\n\n\t\treturn triangles;\n\n\t}\n\n};\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList( data, start, end, dim, clockwise ) {\n\n\tlet i, last;\n\n\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\n\n\t\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t} else {\n\n\t\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t}\n\n\tif ( last && equals( last, last.next ) ) {\n\n\t\tremoveNode( last );\n\t\tlast = last.next;\n\n\t}\n\n\treturn last;\n\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints( start, end ) {\n\n\tif ( ! start ) return start;\n\tif ( ! end ) end = start;\n\n\tlet p = start,\n\t\tagain;\n\tdo {\n\n\t\tagain = false;\n\n\t\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\n\n\t\t\tremoveNode( p );\n\t\t\tp = end = p.prev;\n\t\t\tif ( p === p.next ) break;\n\t\t\tagain = true;\n\n\t\t} else {\n\n\t\t\tp = p.next;\n\n\t\t}\n\n\t} while ( again || p !== end );\n\n\treturn end;\n\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\n\n\tif ( ! ear ) return;\n\n\t// interlink polygon nodes in z-order\n\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\n\n\tlet stop = ear,\n\t\tprev, next;\n\n\t// iterate through ears, slicing them one by one\n\twhile ( ear.prev !== ear.next ) {\n\n\t\tprev = ear.prev;\n\t\tnext = ear.next;\n\n\t\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\n\n\t\t\t// cut off the triangle\n\t\t\ttriangles.push( prev.i / dim | 0 );\n\t\t\ttriangles.push( ear.i / dim | 0 );\n\t\t\ttriangles.push( next.i / dim | 0 );\n\n\t\t\tremoveNode( ear );\n\n\t\t\t// skipping the next vertex leads to less sliver triangles\n\t\t\tear = next.next;\n\t\t\tstop = next.next;\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tear = next;\n\n\t\t// if we looped through the whole remaining polygon and can't find any more ears\n\t\tif ( ear === stop ) {\n\n\t\t\t// try filtering points and slicing again\n\t\t\tif ( ! pass ) {\n\n\t\t\t\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\n\n\t\t\t\t// if this didn't work, try curing all small self-intersections locally\n\n\t\t\t} else if ( pass === 1 ) {\n\n\t\t\t\tear = cureLocalIntersections( filterPoints( ear ), triangles, dim );\n\t\t\t\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\n\n\t\t\t\t// as a last resort, try splitting the remaining polygon into two\n\n\t\t\t} else if ( pass === 2 ) {\n\n\t\t\t\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar( ear ) {\n\n\tconst a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\t// now make sure we don't have other points inside the potential ear\n\tconst ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n\t// triangle bbox; min & max are calculated like this for speed\n\tconst x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),\n\t\ty0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),\n\t\tx1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),\n\t\ty1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );\n\n\tlet p = c.next;\n\twhile ( p !== a ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) &&\n\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.next;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction isEarHashed( ear, minX, minY, invSize ) {\n\n\tconst a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\tconst ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n\t// triangle bbox; min & max are calculated like this for speed\n\tconst x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),\n\t\ty0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),\n\t\tx1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),\n\t\ty1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );\n\n\t// z-order range for the current triangle bbox;\n\tconst minZ = zOrder( x0, y0, minX, minY, invSize ),\n\t\tmaxZ = zOrder( x1, y1, minX, minY, invSize );\n\n\tlet p = ear.prevZ,\n\t\tn = ear.nextZ;\n\n\t// look for points inside the triangle in both directions\n\twhile ( p && p.z >= minZ && n && n.z <= maxZ ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t\tif ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\t// look for remaining points in decreasing z-order\n\twhile ( p && p.z >= minZ ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t}\n\n\t// look for remaining points in increasing z-order\n\twhile ( n && n.z <= maxZ ) {\n\n\t\tif ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\treturn true;\n\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections( start, triangles, dim ) {\n\n\tlet p = start;\n\tdo {\n\n\t\tconst a = p.prev,\n\t\t\tb = p.next.next;\n\n\t\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\n\n\t\t\ttriangles.push( a.i / dim | 0 );\n\t\t\ttriangles.push( p.i / dim | 0 );\n\t\t\ttriangles.push( b.i / dim | 0 );\n\n\t\t\t// remove two nodes involved\n\t\t\tremoveNode( p );\n\t\t\tremoveNode( p.next );\n\n\t\t\tp = start = b;\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn filterPoints( p );\n\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\n\n\t// look for a valid diagonal that divides the polygon into two\n\tlet a = start;\n\tdo {\n\n\t\tlet b = a.next.next;\n\t\twhile ( b !== a.prev ) {\n\n\t\t\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\n\n\t\t\t\t// split the polygon in two by the diagonal\n\t\t\t\tlet c = splitPolygon( a, b );\n\n\t\t\t\t// filter colinear points around the cuts\n\t\t\t\ta = filterPoints( a, a.next );\n\t\t\t\tc = filterPoints( c, c.next );\n\n\t\t\t\t// run earcut on each half\n\t\t\t\tearcutLinked( a, triangles, dim, minX, minY, invSize, 0 );\n\t\t\t\tearcutLinked( c, triangles, dim, minX, minY, invSize, 0 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tb = b.next;\n\n\t\t}\n\n\t\ta = a.next;\n\n\t} while ( a !== start );\n\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\n\n\tconst queue = [];\n\tlet i, len, start, end, list;\n\n\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\n\n\t\tstart = holeIndices[ i ] * dim;\n\t\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\n\t\tlist = linkedList( data, start, end, dim, false );\n\t\tif ( list === list.next ) list.steiner = true;\n\t\tqueue.push( getLeftmost( list ) );\n\n\t}\n\n\tqueue.sort( compareX );\n\n\t// process holes from left to right\n\tfor ( i = 0; i < queue.length; i ++ ) {\n\n\t\touterNode = eliminateHole( queue[ i ], outerNode );\n\n\t}\n\n\treturn outerNode;\n\n}\n\nfunction compareX( a, b ) {\n\n\treturn a.x - b.x;\n\n}\n\n// find a bridge between vertices that connects hole with an outer ring and link it\nfunction eliminateHole( hole, outerNode ) {\n\n\tconst bridge = findHoleBridge( hole, outerNode );\n\tif ( ! bridge ) {\n\n\t\treturn outerNode;\n\n\t}\n\n\tconst bridgeReverse = splitPolygon( bridge, hole );\n\n\t// filter collinear points around the cuts\n\tfilterPoints( bridgeReverse, bridgeReverse.next );\n\treturn filterPoints( bridge, bridge.next );\n\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge( hole, outerNode ) {\n\n\tlet p = outerNode,\n\t\tqx = - Infinity,\n\t\tm;\n\n\tconst hx = hole.x, hy = hole.y;\n\n\t// find a segment intersected by a ray from the hole's leftmost point to the left;\n\t// segment's endpoint with lesser x will be potential connection point\n\tdo {\n\n\t\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\n\n\t\t\tconst x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\n\t\t\tif ( x <= hx && x > qx ) {\n\n\t\t\t\tqx = x;\n\t\t\t\tm = p.x < p.next.x ? p : p.next;\n\t\t\t\tif ( x === hx ) return m; // hole touches outer segment; pick leftmost endpoint\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== outerNode );\n\n\tif ( ! m ) return null;\n\n\t// look for points inside the triangle of hole point, segment intersection and endpoint;\n\t// if there are no points found, we have a valid connection;\n\t// otherwise choose the point of the minimum angle with the ray as connection point\n\n\tconst stop = m,\n\t\tmx = m.x,\n\t\tmy = m.y;\n\tlet tanMin = Infinity, tan;\n\n\tp = m;\n\n\tdo {\n\n\t\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\n\t\t\t\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\n\n\t\t\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\n\n\t\t\tif ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {\n\n\t\t\t\tm = p;\n\t\t\t\ttanMin = tan;\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== stop );\n\n\treturn m;\n\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector( m, p ) {\n\n\treturn area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;\n\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve( start, minX, minY, invSize ) {\n\n\tlet p = start;\n\tdo {\n\n\t\tif ( p.z === 0 ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\n\t\tp.prevZ = p.prev;\n\t\tp.nextZ = p.next;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\tp.prevZ.nextZ = null;\n\tp.prevZ = null;\n\n\tsortLinked( p );\n\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked( list ) {\n\n\tlet i, p, q, e, tail, numMerges, pSize, qSize,\n\t\tinSize = 1;\n\n\tdo {\n\n\t\tp = list;\n\t\tlist = null;\n\t\ttail = null;\n\t\tnumMerges = 0;\n\n\t\twhile ( p ) {\n\n\t\t\tnumMerges ++;\n\t\t\tq = p;\n\t\t\tpSize = 0;\n\t\t\tfor ( i = 0; i < inSize; i ++ ) {\n\n\t\t\t\tpSize ++;\n\t\t\t\tq = q.nextZ;\n\t\t\t\tif ( ! q ) break;\n\n\t\t\t}\n\n\t\t\tqSize = inSize;\n\n\t\t\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\n\n\t\t\t\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\n\n\t\t\t\t\te = p;\n\t\t\t\t\tp = p.nextZ;\n\t\t\t\t\tpSize --;\n\n\t\t\t\t} else {\n\n\t\t\t\t\te = q;\n\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\tqSize --;\n\n\t\t\t\t}\n\n\t\t\t\tif ( tail ) tail.nextZ = e;\n\t\t\t\telse list = e;\n\n\t\t\t\te.prevZ = tail;\n\t\t\t\ttail = e;\n\n\t\t\t}\n\n\t\t\tp = q;\n\n\t\t}\n\n\t\ttail.nextZ = null;\n\t\tinSize *= 2;\n\n\t} while ( numMerges > 1 );\n\n\treturn list;\n\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder( x, y, minX, minY, invSize ) {\n\n\t// coords are transformed into non-negative 15-bit integer range\n\tx = ( x - minX ) * invSize | 0;\n\ty = ( y - minY ) * invSize | 0;\n\n\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\n\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\n\tx = ( x | ( x << 2 ) ) & 0x33333333;\n\tx = ( x | ( x << 1 ) ) & 0x55555555;\n\n\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\n\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\n\ty = ( y | ( y << 2 ) ) & 0x33333333;\n\ty = ( y | ( y << 1 ) ) & 0x55555555;\n\n\treturn x | ( y << 1 );\n\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost( start ) {\n\n\tlet p = start,\n\t\tleftmost = start;\n\tdo {\n\n\t\tif ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn leftmost;\n\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\n\n\treturn ( cx - px ) * ( ay - py ) >= ( ax - px ) * ( cy - py ) &&\n           ( ax - px ) * ( by - py ) >= ( bx - px ) * ( ay - py ) &&\n           ( bx - px ) * ( cy - py ) >= ( cx - px ) * ( by - py );\n\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal( a, b ) {\n\n\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // doesn't intersect other edges\n           ( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible\n            ( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors\n            equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case\n\n}\n\n// signed area of a triangle\nfunction area( p, q, r ) {\n\n\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\n\n}\n\n// check if two points are equal\nfunction equals( p1, p2 ) {\n\n\treturn p1.x === p2.x && p1.y === p2.y;\n\n}\n\n// check if two segments intersect\nfunction intersects( p1, q1, p2, q2 ) {\n\n\tconst o1 = sign( area( p1, q1, p2 ) );\n\tconst o2 = sign( area( p1, q1, q2 ) );\n\tconst o3 = sign( area( p2, q2, p1 ) );\n\tconst o4 = sign( area( p2, q2, q1 ) );\n\n\tif ( o1 !== o2 && o3 !== o4 ) return true; // general case\n\n\tif ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n\tif ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n\tif ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n\tif ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n\treturn false;\n\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment( p, q, r ) {\n\n\treturn q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );\n\n}\n\nfunction sign( num ) {\n\n\treturn num > 0 ? 1 : num < 0 ? - 1 : 0;\n\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon( a, b ) {\n\n\tlet p = a;\n\tdo {\n\n\t\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n\t\t\tintersects( p, p.next, a, b ) ) return true;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn false;\n\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside( a, b ) {\n\n\treturn area( a.prev, a, a.next ) < 0 ?\n\t\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\n\t\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\n\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside( a, b ) {\n\n\tlet p = a,\n\t\tinside = false;\n\tconst px = ( a.x + b.x ) / 2,\n\t\tpy = ( a.y + b.y ) / 2;\n\tdo {\n\n\t\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\n\t\t\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )\n\t\t\tinside = ! inside;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn inside;\n\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon( a, b ) {\n\n\tconst a2 = new Node( a.i, a.x, a.y ),\n\t\tb2 = new Node( b.i, b.x, b.y ),\n\t\tan = a.next,\n\t\tbp = b.prev;\n\n\ta.next = b;\n\tb.prev = a;\n\n\ta2.next = an;\n\tan.prev = a2;\n\n\tb2.next = a2;\n\ta2.prev = b2;\n\n\tbp.next = b2;\n\tb2.prev = bp;\n\n\treturn b2;\n\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode( i, x, y, last ) {\n\n\tconst p = new Node( i, x, y );\n\n\tif ( ! last ) {\n\n\t\tp.prev = p;\n\t\tp.next = p;\n\n\t} else {\n\n\t\tp.next = last.next;\n\t\tp.prev = last;\n\t\tlast.next.prev = p;\n\t\tlast.next = p;\n\n\t}\n\n\treturn p;\n\n}\n\nfunction removeNode( p ) {\n\n\tp.next.prev = p.prev;\n\tp.prev.next = p.next;\n\n\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\n\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\n\n}\n\nfunction Node( i, x, y ) {\n\n\t// vertex index in coordinates array\n\tthis.i = i;\n\n\t// vertex coordinates\n\tthis.x = x;\n\tthis.y = y;\n\n\t// previous and next vertex nodes in a polygon ring\n\tthis.prev = null;\n\tthis.next = null;\n\n\t// z-order curve value\n\tthis.z = 0;\n\n\t// previous and next nodes in z-order\n\tthis.prevZ = null;\n\tthis.nextZ = null;\n\n\t// indicates whether this is a steiner point\n\tthis.steiner = false;\n\n}\n\nfunction signedArea( data, start, end, dim ) {\n\n\tlet sum = 0;\n\tfor ( let i = start, j = end - dim; i < end; i += dim ) {\n\n\t\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\n\t\tj = i;\n\n\t}\n\n\treturn sum;\n\n}\n\nclass ShapeUtils {\n\n\t// calculate area of the contour polygon\n\n\tstatic area( contour ) {\n\n\t\tconst n = contour.length;\n\t\tlet a = 0.0;\n\n\t\tfor ( let p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t}\n\n\tstatic isClockWise( pts ) {\n\n\t\treturn ShapeUtils.area( pts ) < 0;\n\n\t}\n\n\tstatic triangulateShape( contour, holes ) {\n\n\t\tconst vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n\t\tconst holeIndices = []; // array of hole indices\n\t\tconst faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n\t\tremoveDupEndPts( contour );\n\t\taddContour( vertices, contour );\n\n\t\t//\n\n\t\tlet holeIndex = contour.length;\n\n\t\tholes.forEach( removeDupEndPts );\n\n\t\tfor ( let i = 0; i < holes.length; i ++ ) {\n\n\t\t\tholeIndices.push( holeIndex );\n\t\t\tholeIndex += holes[ i ].length;\n\t\t\taddContour( vertices, holes[ i ] );\n\n\t\t}\n\n\t\t//\n\n\t\tconst triangles = Earcut.triangulate( vertices, holeIndices );\n\n\t\t//\n\n\t\tfor ( let i = 0; i < triangles.length; i += 3 ) {\n\n\t\t\tfaces.push( triangles.slice( i, i + 3 ) );\n\n\t\t}\n\n\t\treturn faces;\n\n\t}\n\n}\n\nfunction removeDupEndPts( points ) {\n\n\tconst l = points.length;\n\n\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\n\t\tpoints.pop();\n\n\t}\n\n}\n\nfunction addContour( vertices, contour ) {\n\n\tfor ( let i = 0; i < contour.length; i ++ ) {\n\n\t\tvertices.push( contour[ i ].x );\n\t\tvertices.push( contour[ i ].y );\n\n\t}\n\n}\n\n/**\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\n\nclass ExtrudeGeometry extends BufferGeometry {\n\n\tconstructor( shapes = new Shape( [ new Vector2( 0.5, 0.5 ), new Vector2( - 0.5, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), options = {} ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ExtrudeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\toptions: options\n\t\t};\n\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\t\tconst scope = this;\n\n\t\tconst verticesArray = [];\n\t\tconst uvArray = [];\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\t\t\taddShape( shape );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\n\n\t\tthis.computeVertexNormals();\n\n\t\t// functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst placeholder = [];\n\n\t\t\t// options\n\n\t\t\tconst curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\t\tconst steps = options.steps !== undefined ? options.steps : 1;\n\t\t\tconst depth = options.depth !== undefined ? options.depth : 1;\n\n\t\t\tlet bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n\t\t\tlet bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;\n\t\t\tlet bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;\n\t\t\tlet bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n\t\t\tlet bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\t\tconst extrudePath = options.extrudePath;\n\n\t\t\tconst uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\n\n\t\t\t//\n\n\t\t\tlet extrudePts, extrudeByPath = false;\n\t\t\tlet splineTube, binormal, normal, position2;\n\n\t\t\tif ( extrudePath ) {\n\n\t\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\t\textrudeByPath = true;\n\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t\t// SETUP TNB variables\n\n\t\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\t\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\t\tbinormal = new Vector3();\n\t\t\t\tnormal = new Vector3();\n\t\t\t\tposition2 = new Vector3();\n\n\t\t\t}\n\n\t\t\t// Safeguards if bevels are not enabled\n\n\t\t\tif ( ! bevelEnabled ) {\n\n\t\t\t\tbevelSegments = 0;\n\t\t\t\tbevelThickness = 0;\n\t\t\t\tbevelSize = 0;\n\t\t\t\tbevelOffset = 0;\n\n\t\t\t}\n\n\t\t\t// Variables initialization\n\n\t\t\tconst shapePoints = shape.extractPoints( curveSegments );\n\n\t\t\tlet vertices = shapePoints.shape;\n\t\t\tconst holes = shapePoints.holes;\n\n\t\t\tconst reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\t\tif ( reverse ) {\n\n\t\t\t\tvertices = vertices.reverse();\n\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t\t/* Vertices */\n\n\t\t\tconst contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\tvertices = vertices.concat( ahole );\n\n\t\t\t}\n\n\n\t\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\t\tif ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );\n\n\t\t\t\treturn pt.clone().addScaledVector( vec, size );\n\n\t\t\t}\n\n\t\t\tconst vlen = vertices.length, flen = faces.length;\n\n\n\t\t\t// Find directions for point movement\n\n\n\t\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t//\n\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\t\tlet v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\t\tconst v_prev_x = inPt.x - inPrev.x,\n\t\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\t\tconst v_next_x = inNext.x - inPt.x,\n\t\t\t\t\tv_next_y = inNext.y - inPt.y;\n\n\t\t\t\tconst v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t\t// check for collinear edges\n\t\t\t\tconst collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not collinear\n\n\t\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\t\tconst v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\t\tconst v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\t\tconst ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\t\tconst ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\t\tconst ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\t\tconst ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\t\tconst sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\n\t\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t//  but prevent crazy spikes\n\t\t\t\t\tconst v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\t\tlet direction_eq = false; // assumes: opposite\n\n\t\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t\t}\n\n\n\t\t\tconst contourMovements = [];\n\n\t\t\tfor ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t\t}\n\n\t\t\tconst holesMovements = [];\n\t\t\tlet oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\toneHoleMovements = [];\n\n\t\t\t\tfor ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t\t}\n\n\t\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t\t}\n\n\n\t\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\t\tfor ( let b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst bs = bevelSize + bevelOffset;\n\n\t\t\t// Back facing vertices\n\n\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add stepped vertices...\n\t\t\t// Including front facing vertices\n\n\t\t\tfor ( let s = 1; s <= steps; s ++ ) {\n\n\t\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y, depth / steps * s );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// Add bevel segments planes\n\n\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\t\tfor ( let b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Faces */\n\n\t\t\t// Top and bottom faces\n\n\t\t\tbuildLidFaces();\n\n\t\t\t// Sides faces\n\n\t\t\tbuildSideFaces();\n\n\n\t\t\t/////  Internal functions\n\n\t\t\tfunction buildLidFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\n\t\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\t\tlet layer = 0; // steps + 1\n\t\t\t\t\tlet offset = vlen * layer;\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\n\n\t\t\t}\n\n\t\t\t// Create faces for the z-sides of the shape\n\n\t\t\tfunction buildSideFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\t\t\t\tlet layeroffset = 0;\n\t\t\t\tsidewalls( contour, layeroffset );\n\t\t\t\tlayeroffset += contour.length;\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t\t//, true\n\t\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t\t}\n\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\n\n\n\t\t\t}\n\n\t\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\t\tlet i = contour.length;\n\n\t\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\t\tconst j = i;\n\t\t\t\t\tlet k = i - 1;\n\t\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\t\tfor ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {\n\n\t\t\t\t\t\tconst slen1 = vlen * s;\n\t\t\t\t\t\tconst slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\t\tconst a = layeroffset + j + slen1,\n\t\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\t\tf4( a, b, c, d );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction v( x, y, z ) {\n\n\t\t\t\tplaceholder.push( x );\n\t\t\t\tplaceholder.push( y );\n\t\t\t\tplaceholder.push( z );\n\n\t\t\t}\n\n\n\t\t\tfunction f3( a, b, c ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\n\t\t\t}\n\n\t\t\tfunction f4( a, b, c, d ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( d );\n\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\t\t\t\taddVertex( d );\n\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t}\n\n\t\t\tfunction addVertex( index ) {\n\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\n\n\t\t\t}\n\n\n\t\t\tfunction addUV( vector2 ) {\n\n\t\t\t\tuvArray.push( vector2.x );\n\t\t\t\tuvArray.push( vector2.y );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tconst shapes = this.parameters.shapes;\n\t\tconst options = this.parameters.options;\n\n\t\treturn toJSON$1( shapes, options, data );\n\n\t}\n\n\tstatic fromJSON( data, shapes ) {\n\n\t\tconst geometryShapes = [];\n\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\tgeometryShapes.push( shape );\n\n\t\t}\n\n\t\tconst extrudePath = data.options.extrudePath;\n\n\t\tif ( extrudePath !== undefined ) {\n\n\t\t\tdata.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );\n\n\t\t}\n\n\t\treturn new ExtrudeGeometry( geometryShapes, data.options );\n\n\t}\n\n}\n\nconst WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\n\t\treturn [\n\t\t\tnew Vector2( a_x, a_y ),\n\t\t\tnew Vector2( b_x, b_y ),\n\t\t\tnew Vector2( c_x, c_y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst a_z = vertices[ indexA * 3 + 2 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst b_z = vertices[ indexB * 3 + 2 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\t\tconst c_z = vertices[ indexC * 3 + 2 ];\n\t\tconst d_x = vertices[ indexD * 3 ];\n\t\tconst d_y = vertices[ indexD * 3 + 1 ];\n\t\tconst d_z = vertices[ indexD * 3 + 2 ];\n\n\t\tif ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_x, 1 - a_z ),\n\t\t\t\tnew Vector2( b_x, 1 - b_z ),\n\t\t\t\tnew Vector2( c_x, 1 - c_z ),\n\t\t\t\tnew Vector2( d_x, 1 - d_z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_y, 1 - a_z ),\n\t\t\t\tnew Vector2( b_y, 1 - b_z ),\n\t\t\t\tnew Vector2( c_y, 1 - c_z ),\n\t\t\t\tnew Vector2( d_y, 1 - d_z )\n\t\t\t];\n\n\t\t}\n\n\t}\n\n};\n\nfunction toJSON$1( shapes, options, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\tdata.options = Object.assign( {}, options );\n\n\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\n\n\treturn data;\n\n}\n\nclass IcosahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\t\tconst vertices = [\n\t\t\t- 1, t, 0, \t1, t, 0, \t- 1, - t, 0, \t1, - t, 0,\n\t\t\t0, - 1, t, \t0, 1, t,\t0, - 1, - t, \t0, 1, - t,\n\t\t\tt, 0, - 1, \tt, 0, 1, \t- t, 0, - 1, \t- t, 0, 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t0, 11, 5, \t0, 5, 1, \t0, 1, 7, \t0, 7, 10, \t0, 10, 11,\n\t\t\t1, 5, 9, \t5, 11, 4,\t11, 10, 2,\t10, 7, 6,\t7, 1, 8,\n\t\t\t3, 9, 4, \t3, 4, 2,\t3, 2, 6,\t3, 6, 8,\t3, 8, 9,\n\t\t\t4, 9, 5, \t2, 4, 11,\t6, 2, 10,\t8, 6, 7,\t9, 8, 1\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'IcosahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new IcosahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass OctahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst vertices = [\n\t\t\t1, 0, 0, \t- 1, 0, 0,\t0, 1, 0,\n\t\t\t0, - 1, 0, \t0, 0, 1,\t0, 0, - 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t0, 2, 4,\t0, 4, 3,\t0, 3, 5,\n\t\t\t0, 5, 2,\t1, 2, 5,\t1, 5, 3,\n\t\t\t1, 3, 4,\t1, 4, 2\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'OctahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new OctahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass PlaneGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PlaneGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tconst width_half = width / 2;\n\t\tconst height_half = height / 2;\n\n\t\tconst gridX = Math.floor( widthSegments );\n\t\tconst gridY = Math.floor( heightSegments );\n\n\t\tconst gridX1 = gridX + 1;\n\t\tconst gridY1 = gridY + 1;\n\n\t\tconst segment_width = width / gridX;\n\t\tconst segment_height = height / gridY;\n\n\t\t//\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tconst y = iy * segment_height - height_half;\n\n\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tconst x = ix * segment_width - width_half;\n\n\t\t\t\tvertices.push( x, - y, 0 );\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\tconst a = ix + gridX1 * iy;\n\t\t\t\tconst b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tconst c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tconst d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );\n\n\t}\n\n}\n\nclass RingGeometry extends BufferGeometry {\n\n\tconstructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'RingGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthetaSegments = Math.max( 3, thetaSegments );\n\t\tphiSegments = Math.max( 1, phiSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// some helper variables\n\n\t\tlet radius = innerRadius;\n\t\tconst radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= phiSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t\t// values are generate from the inside of the ring to the outside\n\n\t\t\t\tconst segment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t}\n\n\t\t\t// increase the radius for next row of vertices\n\n\t\t\tradius += radiusStep;\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let j = 0; j < phiSegments; j ++ ) {\n\n\t\t\tconst thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\t\tfor ( let i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\t\tconst segment = i + thetaSegmentLevel;\n\n\t\t\t\tconst a = segment;\n\t\t\t\tconst b = segment + thetaSegments + 1;\n\t\t\t\tconst c = segment + thetaSegments + 2;\n\t\t\t\tconst d = segment + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass ShapeGeometry extends BufferGeometry {\n\n\tconstructor( shapes = new Shape( [ new Vector2( 0, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), curveSegments = 12 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ShapeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\tcurveSegments: curveSegments\n\t\t};\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet groupStart = 0;\n\t\tlet groupCount = 0;\n\n\t\t// allow single and array values for \"shapes\" parameter\n\n\t\tif ( Array.isArray( shapes ) === false ) {\n\n\t\t\taddShape( shapes );\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < shapes.length; i ++ ) {\n\n\t\t\t\taddShape( shapes[ i ] );\n\n\t\t\t\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\n\n\t\t\t\tgroupStart += groupCount;\n\t\t\t\tgroupCount = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n\t\t// helper functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst indexOffset = vertices.length / 3;\n\t\t\tconst points = shape.extractPoints( curveSegments );\n\n\t\t\tlet shapeVertices = points.shape;\n\t\t\tconst shapeHoles = points.holes;\n\n\t\t\t// check direction of vertices\n\n\t\t\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\n\n\t\t\t\tshapeVertices = shapeVertices.reverse();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\n\n\t\t\t\t\tshapeHoles[ i ] = shapeHole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\n\n\t\t\t// join vertices of inner and outer paths to a single array\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\t\t\t\tshapeVertices = shapeVertices.concat( shapeHole );\n\n\t\t\t}\n\n\t\t\t// vertices, normals, uvs\n\n\t\t\tfor ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {\n\n\t\t\t\tconst vertex = shapeVertices[ i ];\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, 0 );\n\t\t\t\tnormals.push( 0, 0, 1 );\n\t\t\t\tuvs.push( vertex.x, vertex.y ); // world uvs\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tconst face = faces[ i ];\n\n\t\t\t\tconst a = face[ 0 ] + indexOffset;\n\t\t\t\tconst b = face[ 1 ] + indexOffset;\n\t\t\t\tconst c = face[ 2 ] + indexOffset;\n\n\t\t\t\tindices.push( a, b, c );\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tconst shapes = this.parameters.shapes;\n\n\t\treturn toJSON( shapes, data );\n\n\t}\n\n\tstatic fromJSON( data, shapes ) {\n\n\t\tconst geometryShapes = [];\n\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\tgeometryShapes.push( shape );\n\n\t\t}\n\n\t\treturn new ShapeGeometry( geometryShapes, data.curveSegments );\n\n\t}\n\n}\n\nfunction toJSON( shapes, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\treturn data;\n\n}\n\nclass SphereGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'SphereGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) );\n\n\t\tconst thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );\n\n\t\tlet index = 0;\n\t\tconst grid = [];\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let iy = 0; iy <= heightSegments; iy ++ ) {\n\n\t\t\tconst verticesRow = [];\n\n\t\t\tconst v = iy / heightSegments;\n\n\t\t\t// special case for the poles\n\n\t\t\tlet uOffset = 0;\n\n\t\t\tif ( iy === 0 && thetaStart === 0 ) {\n\n\t\t\t\tuOffset = 0.5 / widthSegments;\n\n\t\t\t} else if ( iy === heightSegments && thetaEnd === Math.PI ) {\n\n\t\t\t\tuOffset = - 0.5 / widthSegments;\n\n\t\t\t}\n\n\t\t\tfor ( let ix = 0; ix <= widthSegments; ix ++ ) {\n\n\t\t\t\tconst u = ix / widthSegments;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.copy( vertex ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u + uOffset, 1 - v );\n\n\t\t\t\tverticesRow.push( index ++ );\n\n\t\t\t}\n\n\t\t\tgrid.push( verticesRow );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let iy = 0; iy < heightSegments; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < widthSegments; ix ++ ) {\n\n\t\t\t\tconst a = grid[ iy ][ ix + 1 ];\n\t\t\t\tconst b = grid[ iy ][ ix ];\n\t\t\t\tconst c = grid[ iy + 1 ][ ix ];\n\t\t\t\tconst d = grid[ iy + 1 ][ ix + 1 ];\n\n\t\t\t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\n\t\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass TetrahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst vertices = [\n\t\t\t1, 1, 1, \t- 1, - 1, 1, \t- 1, 1, - 1, \t1, - 1, - 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t2, 1, 0, \t0, 3, 2,\t1, 3, 0,\t2, 3, 1\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'TetrahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TetrahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass TorusGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TorusGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tradialSegments = Math.floor( radialSegments );\n\t\ttubularSegments = Math.floor( tubularSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst center = new Vector3();\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tconst u = i / tubularSegments * arc;\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\tcenter.y = radius * Math.sin( u );\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\tconst b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\tconst c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\tconst d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TorusGeometry( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc );\n\n\t}\n\n}\n\nclass TorusKnotGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TorusKnotGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\ttubularSegments = Math.floor( tubularSegments );\n\t\tradialSegments = Math.floor( radialSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\tconst P1 = new Vector3();\n\t\tconst P2 = new Vector3();\n\n\t\tconst B = new Vector3();\n\t\tconst T = new Vector3();\n\t\tconst N = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segment\n\n\t\t\tconst u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t\t// calculate orthonormal basis\n\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\n\t\t\tfor ( let j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\t\t\t\tconst cx = - tube * Math.cos( v );\n\t\t\t\tconst cy = tube * Math.sin( v );\n\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve\n\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// this function calculates the current position on the torus curve\n\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\t\tconst cu = Math.cos( u );\n\t\t\tconst su = Math.sin( u );\n\t\t\tconst quOverP = q / p * u;\n\t\t\tconst cs = Math.cos( quOverP );\n\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );\n\n\t}\n\n}\n\nclass TubeGeometry extends BufferGeometry {\n\n\tconstructor( path = new QuadraticBezierCurve3( new Vector3( - 1, - 1, 0 ), new Vector3( - 1, 1, 0 ), new Vector3( 1, 1, 0 ) ), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TubeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\tconst frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = frames.tangents;\n\t\tthis.normals = frames.normals;\n\t\tthis.binormals = frames.binormals;\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tlet P = new Vector3();\n\n\t\t// buffer\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst indices = [];\n\n\t\t// create buffer data\n\n\t\tgenerateBufferData();\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// functions\n\n\t\tfunction generateBufferData() {\n\n\t\t\tfor ( let i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\t\tgenerateSegment( i );\n\n\t\t\t}\n\n\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t// at the regular position on the given path\n\t\t\t//\n\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t\t// uvs are generated in a separate function.\n\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\tgenerateUVs();\n\n\t\t\t// finally create faces\n\n\t\t\tgenerateIndices();\n\n\t\t}\n\n\t\tfunction generateSegment( i ) {\n\n\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\t\tP = path.getPointAt( i / tubularSegments, P );\n\n\t\t\t// retrieve corresponding normal and binormal\n\n\t\t\tconst N = frames.normals[ i ];\n\t\t\tconst B = frames.binormals[ i ];\n\n\t\t\t// generate normals and vertices for the current segment\n\n\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\tconst sin = Math.sin( v );\n\t\t\t\tconst cos = - Math.cos( v );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\tnormal.normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateIndices() {\n\n\t\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.path = this.parameters.path.toJSON();\n\n\t\treturn data;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\t// This only works for built-in curves (e.g. CatmullRomCurve3).\n\t\t// User defined curves or instances of CurvePath will not be deserialized.\n\t\treturn new TubeGeometry(\n\t\t\tnew Curves[ data.path.type ]().fromJSON( data.path ),\n\t\t\tdata.tubularSegments,\n\t\t\tdata.radius,\n\t\t\tdata.radialSegments,\n\t\t\tdata.closed\n\t\t);\n\n\t}\n\n}\n\nclass WireframeGeometry extends BufferGeometry {\n\n\tconstructor( geometry = null ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'WireframeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tgeometry: geometry\n\t\t};\n\n\t\tif ( geometry !== null ) {\n\n\t\t\t// buffer\n\n\t\t\tconst vertices = [];\n\t\t\tconst edges = new Set();\n\n\t\t\t// helper variables\n\n\t\t\tconst start = new Vector3();\n\t\t\tconst end = new Vector3();\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t// indexed BufferGeometry\n\n\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\tconst indices = geometry.index;\n\t\t\t\tlet groups = geometry.groups;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\n\n\t\t\t\t}\n\n\t\t\t\t// create a data structure that contains all edges without duplicates\n\n\t\t\t\tfor ( let o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\t\tconst group = groups[ o ];\n\n\t\t\t\t\tconst groupStart = group.start;\n\t\t\t\t\tconst groupCount = group.count;\n\n\t\t\t\t\tfor ( let i = groupStart, l = ( groupStart + groupCount ); i < l; i += 3 ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\tconst index1 = indices.getX( i + j );\n\t\t\t\t\t\t\tconst index2 = indices.getX( i + ( j + 1 ) % 3 );\n\n\t\t\t\t\t\t\tstart.fromBufferAttribute( position, index1 );\n\t\t\t\t\t\t\tend.fromBufferAttribute( position, index2 );\n\n\t\t\t\t\t\t\tif ( isUniqueEdge( start, end, edges ) === true ) {\n\n\t\t\t\t\t\t\t\tvertices.push( start.x, start.y, start.z );\n\t\t\t\t\t\t\t\tvertices.push( end.x, end.y, end.z );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed BufferGeometry\n\n\t\t\t\tconst position = geometry.attributes.position;\n\n\t\t\t\tfor ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\n\t\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\n\t\t\t\t\t\tconst index1 = 3 * i + j;\n\t\t\t\t\t\tconst index2 = 3 * i + ( ( j + 1 ) % 3 );\n\n\t\t\t\t\t\tstart.fromBufferAttribute( position, index1 );\n\t\t\t\t\t\tend.fromBufferAttribute( position, index2 );\n\n\t\t\t\t\t\tif ( isUniqueEdge( start, end, edges ) === true ) {\n\n\t\t\t\t\t\t\tvertices.push( start.x, start.y, start.z );\n\t\t\t\t\t\t\tvertices.push( end.x, end.y, end.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n}\n\nfunction isUniqueEdge( start, end, edges ) {\n\n\tconst hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;\n\tconst hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge\n\n\tif ( edges.has( hash1 ) === true || edges.has( hash2 ) === true ) {\n\n\t\treturn false;\n\n\t} else {\n\n\t\tedges.add( hash1 );\n\t\tedges.add( hash2 );\n\t\treturn true;\n\n\t}\n\n}\n\nvar Geometries = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tBoxGeometry: BoxGeometry,\n\tCapsuleGeometry: CapsuleGeometry,\n\tCircleGeometry: CircleGeometry,\n\tConeGeometry: ConeGeometry,\n\tCylinderGeometry: CylinderGeometry,\n\tDodecahedronGeometry: DodecahedronGeometry,\n\tEdgesGeometry: EdgesGeometry,\n\tExtrudeGeometry: ExtrudeGeometry,\n\tIcosahedronGeometry: IcosahedronGeometry,\n\tLatheGeometry: LatheGeometry,\n\tOctahedronGeometry: OctahedronGeometry,\n\tPlaneGeometry: PlaneGeometry,\n\tPolyhedronGeometry: PolyhedronGeometry,\n\tRingGeometry: RingGeometry,\n\tShapeGeometry: ShapeGeometry,\n\tSphereGeometry: SphereGeometry,\n\tTetrahedronGeometry: TetrahedronGeometry,\n\tTorusGeometry: TorusGeometry,\n\tTorusKnotGeometry: TorusKnotGeometry,\n\tTubeGeometry: TubeGeometry,\n\tWireframeGeometry: WireframeGeometry\n});\n\nclass ShadowMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isShadowMaterial = true;\n\n\t\tthis.type = 'ShadowMaterial';\n\n\t\tthis.color = new Color( 0x000000 );\n\t\tthis.transparent = true;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass RawShaderMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( parameters );\n\n\t\tthis.isRawShaderMaterial = true;\n\n\t\tthis.type = 'RawShaderMaterial';\n\n\t}\n\n}\n\nclass MeshStandardMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshStandardMaterial = true;\n\n\t\tthis.type = 'MeshStandardMaterial';\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.roughness = 1.0;\n\t\tthis.metalness = 0.0;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.roughnessMap = null;\n\n\t\tthis.metalnessMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\t\tthis.envMapIntensity = 1.0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.color.copy( source.color );\n\t\tthis.roughness = source.roughness;\n\t\tthis.metalness = source.metalness;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.roughnessMap = source.roughnessMap;\n\n\t\tthis.metalnessMap = source.metalnessMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.envMapIntensity = source.envMapIntensity;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshPhysicalMaterial extends MeshStandardMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshPhysicalMaterial = true;\n\n\t\tthis.defines = {\n\n\t\t\t'STANDARD': '',\n\t\t\t'PHYSICAL': ''\n\n\t\t};\n\n\t\tthis.type = 'MeshPhysicalMaterial';\n\n\t\tthis.anisotropyRotation = 0;\n\t\tthis.anisotropyMap = null;\n\n\t\tthis.clearcoatMap = null;\n\t\tthis.clearcoatRoughness = 0.0;\n\t\tthis.clearcoatRoughnessMap = null;\n\t\tthis.clearcoatNormalScale = new Vector2( 1, 1 );\n\t\tthis.clearcoatNormalMap = null;\n\n\t\tthis.ior = 1.5;\n\n\t\tObject.defineProperty( this, 'reflectivity', {\n\t\t\tget: function () {\n\n\t\t\t\treturn ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );\n\n\t\t\t},\n\t\t\tset: function ( reflectivity ) {\n\n\t\t\t\tthis.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );\n\n\t\t\t}\n\t\t} );\n\n\t\tthis.iridescenceMap = null;\n\t\tthis.iridescenceIOR = 1.3;\n\t\tthis.iridescenceThicknessRange = [ 100, 400 ];\n\t\tthis.iridescenceThicknessMap = null;\n\n\t\tthis.sheenColor = new Color( 0x000000 );\n\t\tthis.sheenColorMap = null;\n\t\tthis.sheenRoughness = 1.0;\n\t\tthis.sheenRoughnessMap = null;\n\n\t\tthis.transmissionMap = null;\n\n\t\tthis.thickness = 0;\n\t\tthis.thicknessMap = null;\n\t\tthis.attenuationDistance = Infinity;\n\t\tthis.attenuationColor = new Color( 1, 1, 1 );\n\n\t\tthis.specularIntensity = 1.0;\n\t\tthis.specularIntensityMap = null;\n\t\tthis.specularColor = new Color( 1, 1, 1 );\n\t\tthis.specularColorMap = null;\n\n\t\tthis._anisotropy = 0;\n\t\tthis._clearcoat = 0;\n\t\tthis._dispersion = 0;\n\t\tthis._iridescence = 0;\n\t\tthis._sheen = 0.0;\n\t\tthis._transmission = 0;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tget anisotropy() {\n\n\t\treturn this._anisotropy;\n\n\t}\n\n\tset anisotropy( value ) {\n\n\t\tif ( this._anisotropy > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._anisotropy = value;\n\n\t}\n\n\tget clearcoat() {\n\n\t\treturn this._clearcoat;\n\n\t}\n\n\tset clearcoat( value ) {\n\n\t\tif ( this._clearcoat > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._clearcoat = value;\n\n\t}\n\n\tget iridescence() {\n\n\t\treturn this._iridescence;\n\n\t}\n\n\tset iridescence( value ) {\n\n\t\tif ( this._iridescence > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._iridescence = value;\n\n\t}\n\n\tget dispersion() {\n\n\t\treturn this._dispersion;\n\n\t}\n\n\tset dispersion( value ) {\n\n\t\tif ( this._dispersion > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._dispersion = value;\n\n\t}\n\n\tget sheen() {\n\n\t\treturn this._sheen;\n\n\t}\n\n\tset sheen( value ) {\n\n\t\tif ( this._sheen > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._sheen = value;\n\n\t}\n\n\tget transmission() {\n\n\t\treturn this._transmission;\n\n\t}\n\n\tset transmission( value ) {\n\n\t\tif ( this._transmission > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._transmission = value;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = {\n\n\t\t\t'STANDARD': '',\n\t\t\t'PHYSICAL': ''\n\n\t\t};\n\n\t\tthis.anisotropy = source.anisotropy;\n\t\tthis.anisotropyRotation = source.anisotropyRotation;\n\t\tthis.anisotropyMap = source.anisotropyMap;\n\n\t\tthis.clearcoat = source.clearcoat;\n\t\tthis.clearcoatMap = source.clearcoatMap;\n\t\tthis.clearcoatRoughness = source.clearcoatRoughness;\n\t\tthis.clearcoatRoughnessMap = source.clearcoatRoughnessMap;\n\t\tthis.clearcoatNormalMap = source.clearcoatNormalMap;\n\t\tthis.clearcoatNormalScale.copy( source.clearcoatNormalScale );\n\n\t\tthis.dispersion = source.dispersion;\n\t\tthis.ior = source.ior;\n\n\t\tthis.iridescence = source.iridescence;\n\t\tthis.iridescenceMap = source.iridescenceMap;\n\t\tthis.iridescenceIOR = source.iridescenceIOR;\n\t\tthis.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];\n\t\tthis.iridescenceThicknessMap = source.iridescenceThicknessMap;\n\n\t\tthis.sheen = source.sheen;\n\t\tthis.sheenColor.copy( source.sheenColor );\n\t\tthis.sheenColorMap = source.sheenColorMap;\n\t\tthis.sheenRoughness = source.sheenRoughness;\n\t\tthis.sheenRoughnessMap = source.sheenRoughnessMap;\n\n\t\tthis.transmission = source.transmission;\n\t\tthis.transmissionMap = source.transmissionMap;\n\n\t\tthis.thickness = source.thickness;\n\t\tthis.thicknessMap = source.thicknessMap;\n\t\tthis.attenuationDistance = source.attenuationDistance;\n\t\tthis.attenuationColor.copy( source.attenuationColor );\n\n\t\tthis.specularIntensity = source.specularIntensity;\n\t\tthis.specularIntensityMap = source.specularIntensityMap;\n\t\tthis.specularColor.copy( source.specularColor );\n\t\tthis.specularColorMap = source.specularColorMap;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshPhongMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshPhongMaterial = true;\n\n\t\tthis.type = 'MeshPhongMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.specular = new Color( 0x111111 );\n\t\tthis.shininess = 30;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.specular.copy( source.specular );\n\t\tthis.shininess = source.shininess;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshToonMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshToonMaterial = true;\n\n\t\tthis.defines = { 'TOON': '' };\n\n\t\tthis.type = 'MeshToonMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\t\tthis.gradientMap = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\t\tthis.gradientMap = source.gradientMap;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshNormalMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshNormalMaterial = true;\n\n\t\tthis.type = 'MeshNormalMaterial';\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshLambertMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshLambertMaterial = true;\n\n\t\tthis.type = 'MeshLambertMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshDepthMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshDepthMaterial = true;\n\n\t\tthis.type = 'MeshDepthMaterial';\n\n\t\tthis.depthPacking = BasicDepthPacking;\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.depthPacking = source.depthPacking;\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshDistanceMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshDistanceMaterial = true;\n\n\t\tthis.type = 'MeshDistanceMaterial';\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshMatcapMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshMatcapMaterial = true;\n\n\t\tthis.defines = { 'MATCAP': '' };\n\n\t\tthis.type = 'MeshMatcapMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.matcap = null;\n\n\t\tthis.map = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = { 'MATCAP': '' };\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.matcap = source.matcap;\n\n\t\tthis.map = source.map;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineDashedMaterial extends LineBasicMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isLineDashedMaterial = true;\n\t\tthis.type = 'LineDashedMaterial';\n\n\t\tthis.scale = 1;\n\t\tthis.dashSize = 3;\n\t\tthis.gapSize = 1;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.scale = source.scale;\n\t\tthis.dashSize = source.dashSize;\n\t\tthis.gapSize = source.gapSize;\n\n\t\treturn this;\n\n\t}\n\n}\n\n// converts an array to a specific type\nfunction convertArray( array, type, forceClone ) {\n\n\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t! forceClone && array.constructor === type ) return array;\n\n\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\treturn new type( array ); // create typed array\n\n\t}\n\n\treturn Array.prototype.slice.call( array ); // create Array\n\n}\n\nfunction isTypedArray( object ) {\n\n\treturn ArrayBuffer.isView( object ) &&\n\t\t! ( object instanceof DataView );\n\n}\n\n// returns an array by which times and values can be sorted\nfunction getKeyframeOrder( times ) {\n\n\tfunction compareTime( i, j ) {\n\n\t\treturn times[ i ] - times[ j ];\n\n\t}\n\n\tconst n = times.length;\n\tconst result = new Array( n );\n\tfor ( let i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\tresult.sort( compareTime );\n\n\treturn result;\n\n}\n\n// uses the array previously returned by 'getKeyframeOrder' to sort data\nfunction sortedArray( values, stride, order ) {\n\n\tconst nValues = values.length;\n\tconst result = new values.constructor( nValues );\n\n\tfor ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\tconst srcOffset = order[ i ] * stride;\n\n\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n// function for parsing AOS keyframe formats\nfunction flattenJSON( jsonKeys, times, values, valuePropertyName ) {\n\n\tlet i = 1, key = jsonKeys[ 0 ];\n\n\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\tkey = jsonKeys[ i ++ ];\n\n\t}\n\n\tif ( key === undefined ) return; // no data\n\n\tlet value = key[ valuePropertyName ];\n\tif ( value === undefined ) return; // no data\n\n\tif ( Array.isArray( value ) ) {\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else if ( value.toArray !== undefined ) {\n\n\t\t// ...assume THREE.Math-ish\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else {\n\n\t\t// otherwise push as-is\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push( value );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t}\n\n}\n\nfunction subclip( sourceClip, name, startFrame, endFrame, fps = 30 ) {\n\n\tconst clip = sourceClip.clone();\n\n\tclip.name = name;\n\n\tconst tracks = [];\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tconst track = clip.tracks[ i ];\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = [];\n\t\tconst values = [];\n\n\t\tfor ( let j = 0; j < track.times.length; ++ j ) {\n\n\t\t\tconst frame = track.times[ j ] * fps;\n\n\t\t\tif ( frame < startFrame || frame >= endFrame ) continue;\n\n\t\t\ttimes.push( track.times[ j ] );\n\n\t\t\tfor ( let k = 0; k < valueSize; ++ k ) {\n\n\t\t\t\tvalues.push( track.values[ j * valueSize + k ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( times.length === 0 ) continue;\n\n\t\ttrack.times = convertArray( times, track.times.constructor );\n\t\ttrack.values = convertArray( values, track.values.constructor );\n\n\t\ttracks.push( track );\n\n\t}\n\n\tclip.tracks = tracks;\n\n\t// find minimum .times value across all tracks in the trimmed clip\n\n\tlet minStartTime = Infinity;\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tif ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {\n\n\t\t\tminStartTime = clip.tracks[ i ].times[ 0 ];\n\n\t\t}\n\n\t}\n\n\t// shift all tracks such that clip begins at t=0\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tclip.tracks[ i ].shift( - 1 * minStartTime );\n\n\t}\n\n\tclip.resetDuration();\n\n\treturn clip;\n\n}\n\nfunction makeClipAdditive( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {\n\n\tif ( fps <= 0 ) fps = 30;\n\n\tconst numTracks = referenceClip.tracks.length;\n\tconst referenceTime = referenceFrame / fps;\n\n\t// Make each track's values relative to the values at the reference frame\n\tfor ( let i = 0; i < numTracks; ++ i ) {\n\n\t\tconst referenceTrack = referenceClip.tracks[ i ];\n\t\tconst referenceTrackType = referenceTrack.ValueTypeName;\n\n\t\t// Skip this track if it's non-numeric\n\t\tif ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;\n\n\t\t// Find the track in the target clip whose name and type matches the reference track\n\t\tconst targetTrack = targetClip.tracks.find( function ( track ) {\n\n\t\t\treturn track.name === referenceTrack.name\n\t\t\t\t&& track.ValueTypeName === referenceTrackType;\n\n\t\t} );\n\n\t\tif ( targetTrack === undefined ) continue;\n\n\t\tlet referenceOffset = 0;\n\t\tconst referenceValueSize = referenceTrack.getValueSize();\n\n\t\tif ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\treferenceOffset = referenceValueSize / 3;\n\n\t\t}\n\n\t\tlet targetOffset = 0;\n\t\tconst targetValueSize = targetTrack.getValueSize();\n\n\t\tif ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\ttargetOffset = targetValueSize / 3;\n\n\t\t}\n\n\t\tconst lastIndex = referenceTrack.times.length - 1;\n\t\tlet referenceValue;\n\n\t\t// Find the value to subtract out of the track\n\t\tif ( referenceTime <= referenceTrack.times[ 0 ] ) {\n\n\t\t\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\treferenceValue = referenceTrack.values.slice( startIndex, endIndex );\n\n\t\t} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {\n\n\t\t\t// Reference frame is after the last keyframe, so just use the last keyframe\n\t\t\tconst startIndex = lastIndex * referenceValueSize + referenceOffset;\n\t\t\tconst endIndex = startIndex + referenceValueSize - referenceOffset;\n\t\t\treferenceValue = referenceTrack.values.slice( startIndex, endIndex );\n\n\t\t} else {\n\n\t\t\t// Interpolate to the reference value\n\t\t\tconst interpolant = referenceTrack.createInterpolant();\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\tinterpolant.evaluate( referenceTime );\n\t\t\treferenceValue = interpolant.resultBuffer.slice( startIndex, endIndex );\n\n\t\t}\n\n\t\t// Conjugate the quaternion\n\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\tconst referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();\n\t\t\treferenceQuat.toArray( referenceValue );\n\n\t\t}\n\n\t\t// Subtract the reference value from all of the track values\n\n\t\tconst numTimes = targetTrack.times.length;\n\t\tfor ( let j = 0; j < numTimes; ++ j ) {\n\n\t\t\tconst valueStart = j * targetValueSize + targetOffset;\n\n\t\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\t\t// Multiply the conjugate for quaternion track types\n\t\t\t\tQuaternion.multiplyQuaternionsFlat(\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart,\n\t\t\t\t\treferenceValue,\n\t\t\t\t\t0,\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tconst valueEnd = targetValueSize - targetOffset * 2;\n\n\t\t\t\t// Subtract each value for all other numeric track types\n\t\t\t\tfor ( let k = 0; k < valueEnd; ++ k ) {\n\n\t\t\t\t\ttargetTrack.values[ valueStart + k ] -= referenceValue[ k ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttargetClip.blendMode = AdditiveAnimationBlendMode;\n\n\treturn targetClip;\n\n}\n\nconst AnimationUtils = {\n\tconvertArray: convertArray,\n\tisTypedArray: isTypedArray,\n\tgetKeyframeOrder: getKeyframeOrder,\n\tsortedArray: sortedArray,\n\tflattenJSON: flattenJSON,\n\tsubclip: subclip,\n\tmakeClipAdditive: makeClipAdditive\n};\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n */\n\nclass Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tthis.parameterPositions = parameterPositions;\n\t\tthis._cachedIndex = 0;\n\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\tthis.sampleValues = sampleValues;\n\t\tthis.valueSize = sampleSize;\n\n\t\tthis.settings = null;\n\t\tthis.DefaultSettings_ = {};\n\n\t}\n\n\tevaluate( t ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet i1 = this._cachedIndex,\n\t\t\tt1 = pp[ i1 ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tlet right;\n\n\t\t\t\tlinear_scan: {\n\n\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\n\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 + 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tconst t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 - 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.copySampleValue_( 0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tconst mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[ i1 ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.copySampleValue_( 0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t}\n\n\tgetSettings_() {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t// Template methods for derived classes:\n\n\tinterpolate_( /* i1, t0, t, t1 */ ) {\n\n\t\tthrow new Error( 'call to abstract method' );\n\t\t// implementations shall return this.resultBuffer\n\n\t}\n\n\tintervalChanged_( /* i1, t0, t1 */ ) {\n\n\t\t// empty\n\n\t}\n\n}\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n */\n\nclass CubicInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t\tthis._weightPrev = - 0;\n\t\tthis._offsetPrev = - 0;\n\t\tthis._weightNext = - 0;\n\t\tthis._offsetNext = - 0;\n\n\t\tthis.DefaultSettings_ = {\n\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\n\t\t};\n\n\t}\n\n\tintervalChanged_( i1, t0, t1 ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet iPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tconst sP = - wP * ppp + 2 * wP * pp - wP * p;\n\t\tconst s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\n\t\tconst s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\n\t\tconst sN = wN * ppp - wN * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nclass LinearInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset1 = i1 * stride,\n\t\t\toffset0 = offset1 - stride,\n\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tweight0 = 1 - weight1;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceding\n * the parameter.\n */\n\nclass DiscreteInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1 /*, t0, t, t1 */ ) {\n\n\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t}\n\n}\n\nclass KeyframeTrack {\n\n\tconstructor( name, times, values, interpolation ) {\n\n\t\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\n\t\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\n\n\t\tthis.name = name;\n\n\t\tthis.times = convertArray( times, this.TimeBufferType );\n\t\tthis.values = convertArray( values, this.ValueBufferType );\n\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\t}\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\tstatic toJSON( track ) {\n\n\t\tconst trackType = track.constructor;\n\n\t\tlet json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== this.toJSON ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': convertArray( track.times, Array ),\n\t\t\t\t'values': convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tconst interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t}\n\n\tInterpolantFactoryMethodDiscrete( result ) {\n\n\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodSmooth( result ) {\n\n\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tsetInterpolation( interpolation ) {\n\n\t\tlet factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tconst message = 'unsupported interpolation for ' +\n\t\t\t\tthis.ValueTypeName + ' keyframe track named ' + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.KeyframeTrack:', message );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t\treturn this;\n\n\t}\n\n\tgetInterpolation() {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn InterpolateSmooth;\n\n\t\t}\n\n\t}\n\n\tgetValueSize() {\n\n\t\treturn this.values.length / this.times.length;\n\n\t}\n\n\t// move all keyframes either forwards or backwards in time\n\tshift( timeOffset ) {\n\n\t\tif ( timeOffset !== 0.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale( timeScale ) {\n\n\t\tif ( timeScale !== 1.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim( startTime, endTime ) {\n\n\t\tconst times = this.times,\n\t\t\tnKeys = times.length;\n\n\t\tlet from = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\n\n\t\t\t++ from;\n\n\t\t}\n\n\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\n\n\t\t\t-- to;\n\n\t\t}\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif ( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) {\n\n\t\t\t\tto = Math.max( to, 1 );\n\t\t\t\tfrom = to - 1;\n\n\t\t\t}\n\n\t\t\tconst stride = this.getValueSize();\n\t\t\tthis.times = times.slice( from, to );\n\t\t\tthis.values = this.values.slice( from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tconst valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tconst times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif ( nKeys === 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tlet prevTime = null;\n\n\t\tfor ( let i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tconst currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( isTypedArray( values ) ) {\n\n\t\t\t\tfor ( let i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tconst value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize() {\n\n\t\t// times or values may be shared with other tracks, so overwriting is unsafe\n\t\tconst times = this.times.slice(),\n\t\t\tvalues = this.values.slice(),\n\t\t\tstride = this.getValueSize(),\n\n\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\tlastIndex = times.length - 1;\n\n\t\tlet writeIndex = 1;\n\n\t\tfor ( let i = 1; i < lastIndex; ++ i ) {\n\n\t\t\tlet keep = false;\n\n\t\t\tconst time = times[ i ];\n\t\t\tconst timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {\n\n\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\tconst offset = i * stride,\n\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tconst value = values[ offset + j ];\n\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tkeep = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tconst readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// flush last keyframe (compaction looks ahead)\n\n\t\tif ( lastIndex > 0 ) {\n\n\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\tfor ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t}\n\n\t\t\t++ writeIndex;\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = times.slice( 0, writeIndex );\n\t\t\tthis.values = values.slice( 0, writeIndex * stride );\n\n\t\t} else {\n\n\t\t\tthis.times = times;\n\t\t\tthis.values = values;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst times = this.times.slice();\n\t\tconst values = this.values.slice();\n\n\t\tconst TypedKeyframeTrack = this.constructor;\n\t\tconst track = new TypedKeyframeTrack( this.name, times, values );\n\n\t\t// Interpolant argument to constructor is not saved, so copy the factory method directly.\n\t\ttrack.createInterpolant = this.createInterpolant;\n\n\t\treturn track;\n\n\t}\n\n}\n\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\n/**\n * A Track of Boolean keyframe values.\n */\nclass BooleanKeyframeTrack extends KeyframeTrack {\n\n\t// No interpolation parameter because only InterpolateDiscrete is valid.\n\tconstructor( name, times, values ) {\n\n\t\tsuper( name, times, values );\n\n\t}\n\n}\n\nBooleanKeyframeTrack.prototype.ValueTypeName = 'bool';\nBooleanKeyframeTrack.prototype.ValueBufferType = Array;\nBooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of keyframe values that represent color.\n */\nclass ColorKeyframeTrack extends KeyframeTrack {}\n\nColorKeyframeTrack.prototype.ValueTypeName = 'color';\n\n/**\n * A Track of numeric keyframe values.\n */\nclass NumberKeyframeTrack extends KeyframeTrack {}\n\nNumberKeyframeTrack.prototype.ValueTypeName = 'number';\n\n/**\n * Spherical linear unit quaternion interpolant.\n */\n\nclass QuaternionLinearInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\tlet offset = i1 * stride;\n\n\t\tfor ( let end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\n/**\n * A Track of quaternion keyframe values.\n */\nclass QuaternionKeyframeTrack extends KeyframeTrack {\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n}\n\nQuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';\n// ValueBufferType is inherited\n// DefaultInterpolation is inherited;\nQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track that interpolates Strings\n */\nclass StringKeyframeTrack extends KeyframeTrack {\n\n\t// No interpolation parameter because only InterpolateDiscrete is valid.\n\tconstructor( name, times, values ) {\n\n\t\tsuper( name, times, values );\n\n\t}\n\n}\n\nStringKeyframeTrack.prototype.ValueTypeName = 'string';\nStringKeyframeTrack.prototype.ValueBufferType = Array;\nStringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of vectored keyframe values.\n */\nclass VectorKeyframeTrack extends KeyframeTrack {}\n\nVectorKeyframeTrack.prototype.ValueTypeName = 'vector';\n\nclass AnimationClip {\n\n\tconstructor( name = '', duration = - 1, tracks = [], blendMode = NormalAnimationBlendMode ) {\n\n\t\tthis.name = name;\n\t\tthis.tracks = tracks;\n\t\tthis.duration = duration;\n\t\tthis.blendMode = blendMode;\n\n\t\tthis.uuid = generateUUID();\n\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\n\t\t\tthis.resetDuration();\n\n\t\t}\n\n\t}\n\n\n\tstatic parse( json ) {\n\n\t\tconst tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\tconst clip = new this( json.name, json.duration, tracks, json.blendMode );\n\t\tclip.uuid = json.uuid;\n\n\t\treturn clip;\n\n\t}\n\n\tstatic toJSON( clip ) {\n\n\t\tconst tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tconst json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks,\n\t\t\t'uuid': clip.uuid,\n\t\t\t'blendMode': clip.blendMode\n\n\t\t};\n\n\t\tfor ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t}\n\n\tstatic CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tconst numMorphTargets = morphTargetSequence.length;\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tlet times = [];\n\t\t\tlet values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\ti,\n\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tconst order = getKeyframeOrder( times );\n\t\t\ttimes = sortedArray( times, 1, order );\n\t\t\tvalues = sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\ttimes, values\n\t\t\t\t).scale( 1.0 / fps ) );\n\n\t\t}\n\n\t\treturn new this( name, - 1, tracks );\n\n\t}\n\n\tstatic findByName( objectOrClipArray, name ) {\n\n\t\tlet clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tconst o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tstatic CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {\n\n\t\tconst animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tconst pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tconst name = parts[ 1 ];\n\n\t\t\t\tlet animationMorphTargets = animationToMorphTargets[ name ];\n\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst clips = [];\n\n\t\tfor ( const name in animationToMorphTargets ) {\n\n\t\t\tclips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t}\n\n\t// parse the animation.hierarchy format\n\tstatic parseAnimation( animation, bones ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tconst times = [];\n\t\t\t\tconst values = [];\n\n\t\t\t\tflattenJSON( animationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tconst tracks = [];\n\n\t\tconst clipName = animation.name || 'default';\n\t\tconst fps = animation.fps || 30;\n\t\tconst blendMode = animation.blendMode;\n\n\t\t// automatic length determination in AnimationClip.\n\t\tlet duration = animation.length || - 1;\n\n\t\tconst hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( let h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tconst animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets\n\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tconst morphTargetNames = {};\n\n\t\t\t\tlet k;\n\n\t\t\t\tfor ( k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\n\n\t\t\t\t\t\tfor ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( const morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tconst times = [];\n\t\t\t\t\tconst values = [];\n\n\t\t\t\t\tfor ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tconst animationKey = animationKeys[ k ];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * fps;\n\n\t\t\t} else {\n\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tconst boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst clip = new this( clipName, duration, tracks, blendMode );\n\n\t\treturn clip;\n\n\t}\n\n\tresetDuration() {\n\n\t\tconst tracks = this.tracks;\n\t\tlet duration = 0;\n\n\t\tfor ( let i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tconst track = this.tracks[ i ];\n\n\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t\treturn this;\n\n\t}\n\n\ttrim() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tvalid = valid && this.tracks[ i ].validate();\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\toptimize() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\ttracks.push( this.tracks[ i ].clone() );\n\n\t\t}\n\n\t\treturn new this.constructor( this.name, this.duration, tracks, this.blendMode );\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.constructor.toJSON( this );\n\n\t}\n\n}\n\nfunction getTrackTypeForValueTypeName( typeName ) {\n\n\tswitch ( typeName.toLowerCase() ) {\n\n\t\tcase 'scalar':\n\t\tcase 'double':\n\t\tcase 'float':\n\t\tcase 'number':\n\t\tcase 'integer':\n\n\t\t\treturn NumberKeyframeTrack;\n\n\t\tcase 'vector':\n\t\tcase 'vector2':\n\t\tcase 'vector3':\n\t\tcase 'vector4':\n\n\t\t\treturn VectorKeyframeTrack;\n\n\t\tcase 'color':\n\n\t\t\treturn ColorKeyframeTrack;\n\n\t\tcase 'quaternion':\n\n\t\t\treturn QuaternionKeyframeTrack;\n\n\t\tcase 'bool':\n\t\tcase 'boolean':\n\n\t\t\treturn BooleanKeyframeTrack;\n\n\t\tcase 'string':\n\n\t\t\treturn StringKeyframeTrack;\n\n\t}\n\n\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\n\n}\n\nfunction parseKeyframeTrack( json ) {\n\n\tif ( json.type === undefined ) {\n\n\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\n\n\t}\n\n\tconst trackType = getTrackTypeForValueTypeName( json.type );\n\n\tif ( json.times === undefined ) {\n\n\t\tconst times = [], values = [];\n\n\t\tflattenJSON( json.keys, times, values, 'value' );\n\n\t\tjson.times = times;\n\t\tjson.values = values;\n\n\t}\n\n\t// derived classes can define a static parse method\n\tif ( trackType.parse !== undefined ) {\n\n\t\treturn trackType.parse( json );\n\n\t} else {\n\n\t\t// by default, we assume a constructor compatible with the base\n\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\n\n\t}\n\n}\n\nconst Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\nclass LoadingManager {\n\n\tconstructor( onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet isLoading = false;\n\t\tlet itemsLoaded = 0;\n\t\tlet itemsTotal = 0;\n\t\tlet urlModifier = undefined;\n\t\tconst handlers = [];\n\n\t\t// Refer to #5689 for the reason why we don't set .onStart\n\t\t// in the constructor\n\n\t\tthis.onStart = undefined;\n\t\tthis.onLoad = onLoad;\n\t\tthis.onProgress = onProgress;\n\t\tthis.onError = onError;\n\n\t\tthis.itemStart = function ( url ) {\n\n\t\t\titemsTotal ++;\n\n\t\t\tif ( isLoading === false ) {\n\n\t\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tisLoading = true;\n\n\t\t};\n\n\t\tthis.itemEnd = function ( url ) {\n\n\t\t\titemsLoaded ++;\n\n\t\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\t\tisLoading = false;\n\n\t\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\t\tscope.onLoad();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.itemError = function ( url ) {\n\n\t\t\tif ( scope.onError !== undefined ) {\n\n\t\t\t\tscope.onError( url );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.resolveURL = function ( url ) {\n\n\t\t\tif ( urlModifier ) {\n\n\t\t\t\treturn urlModifier( url );\n\n\t\t\t}\n\n\t\t\treturn url;\n\n\t\t};\n\n\t\tthis.setURLModifier = function ( transform ) {\n\n\t\t\turlModifier = transform;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.addHandler = function ( regex, loader ) {\n\n\t\t\thandlers.push( regex, loader );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.removeHandler = function ( regex ) {\n\n\t\t\tconst index = handlers.indexOf( regex );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\thandlers.splice( index, 2 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.getHandler = function ( file ) {\n\n\t\t\tfor ( let i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\t\tconst regex = handlers[ i ];\n\t\t\t\tconst loader = handlers[ i + 1 ];\n\n\t\t\t\tif ( regex.global ) regex.lastIndex = 0; // see #17920\n\n\t\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\t\treturn loader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t}\n\n}\n\nconst DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();\n\nclass Loader {\n\n\tconstructor( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\tthis.crossOrigin = 'anonymous';\n\t\tthis.withCredentials = false;\n\t\tthis.path = '';\n\t\tthis.resourcePath = '';\n\t\tthis.requestHeader = {};\n\n\t}\n\n\tload( /* url, onLoad, onProgress, onError */ ) {}\n\n\tloadAsync( url, onProgress ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.load( url, resolve, onProgress, reject );\n\n\t\t} );\n\n\t}\n\n\tparse( /* data */ ) {}\n\n\tsetCrossOrigin( crossOrigin ) {\n\n\t\tthis.crossOrigin = crossOrigin;\n\t\treturn this;\n\n\t}\n\n\tsetWithCredentials( value ) {\n\n\t\tthis.withCredentials = value;\n\t\treturn this;\n\n\t}\n\n\tsetPath( path ) {\n\n\t\tthis.path = path;\n\t\treturn this;\n\n\t}\n\n\tsetResourcePath( resourcePath ) {\n\n\t\tthis.resourcePath = resourcePath;\n\t\treturn this;\n\n\t}\n\n\tsetRequestHeader( requestHeader ) {\n\n\t\tthis.requestHeader = requestHeader;\n\t\treturn this;\n\n\t}\n\n}\n\nLoader.DEFAULT_MATERIAL_NAME = '__DEFAULT';\n\nconst loading = {};\n\nclass HttpError extends Error {\n\n\tconstructor( message, response ) {\n\n\t\tsuper( message );\n\t\tthis.response = response;\n\n\t}\n\n}\n\nclass FileLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tthis.manager.itemStart( url );\n\n\t\t\tsetTimeout( () => {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tthis.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\t// Check if request is duplicate\n\n\t\tif ( loading[ url ] !== undefined ) {\n\n\t\t\tloading[ url ].push( {\n\n\t\t\t\tonLoad: onLoad,\n\t\t\t\tonProgress: onProgress,\n\t\t\t\tonError: onError\n\n\t\t\t} );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Initialise array for duplicate requests\n\t\tloading[ url ] = [];\n\n\t\tloading[ url ].push( {\n\t\t\tonLoad: onLoad,\n\t\t\tonProgress: onProgress,\n\t\t\tonError: onError,\n\t\t} );\n\n\t\t// create request\n\t\tconst req = new Request( url, {\n\t\t\theaders: new Headers( this.requestHeader ),\n\t\t\tcredentials: this.withCredentials ? 'include' : 'same-origin',\n\t\t\t// An abort controller could be added within a future PR\n\t\t} );\n\n\t\t// record states ( avoid data race )\n\t\tconst mimeType = this.mimeType;\n\t\tconst responseType = this.responseType;\n\n\t\t// start the fetch\n\t\tfetch( req )\n\t\t\t.then( response => {\n\n\t\t\t\tif ( response.status === 200 || response.status === 0 ) {\n\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\tif ( response.status === 0 ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Workaround: Checking if response.body === undefined for Alipay browser #23548\n\n\t\t\t\t\tif ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {\n\n\t\t\t\t\t\treturn response;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst callbacks = loading[ url ];\n\t\t\t\t\tconst reader = response.body.getReader();\n\n\t\t\t\t\t// Nginx needs X-File-Size check\n\t\t\t\t\t// https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content\n\t\t\t\t\tconst contentLength = response.headers.get( 'X-File-Size' ) || response.headers.get( 'Content-Length' );\n\t\t\t\t\tconst total = contentLength ? parseInt( contentLength ) : 0;\n\t\t\t\t\tconst lengthComputable = total !== 0;\n\t\t\t\t\tlet loaded = 0;\n\n\t\t\t\t\t// periodically read data into the new stream tracking while download progress\n\t\t\t\t\tconst stream = new ReadableStream( {\n\t\t\t\t\t\tstart( controller ) {\n\n\t\t\t\t\t\t\treadData();\n\n\t\t\t\t\t\t\tfunction readData() {\n\n\t\t\t\t\t\t\t\treader.read().then( ( { done, value } ) => {\n\n\t\t\t\t\t\t\t\t\tif ( done ) {\n\n\t\t\t\t\t\t\t\t\t\tcontroller.close();\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tloaded += value.byteLength;\n\n\t\t\t\t\t\t\t\t\t\tconst event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );\n\t\t\t\t\t\t\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\t\t\t\t\t\t\tif ( callback.onProgress ) callback.onProgress( event );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tcontroller.enqueue( value );\n\t\t\t\t\t\t\t\t\t\treadData();\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}, ( e ) => {\n\n\t\t\t\t\t\t\t\t\tcontroller.error( e );\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn new Response( stream );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new HttpError( `fetch for \"${response.url}\" responded with ${response.status}: ${response.statusText}`, response );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( response => {\n\n\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\tcase 'arraybuffer':\n\n\t\t\t\t\t\treturn response.arrayBuffer();\n\n\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\treturn response.blob();\n\n\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\treturn response.text()\n\t\t\t\t\t\t\t.then( text => {\n\n\t\t\t\t\t\t\t\tconst parser = new DOMParser();\n\t\t\t\t\t\t\t\treturn parser.parseFromString( text, mimeType );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\treturn response.json();\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( mimeType === undefined ) {\n\n\t\t\t\t\t\t\treturn response.text();\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// sniff encoding\n\t\t\t\t\t\t\tconst re = /charset=\"?([^;\"\\s]*)\"?/i;\n\t\t\t\t\t\t\tconst exec = re.exec( mimeType );\n\t\t\t\t\t\t\tconst label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;\n\t\t\t\t\t\t\tconst decoder = new TextDecoder( label );\n\t\t\t\t\t\t\treturn response.arrayBuffer().then( ab => decoder.decode( ab ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( data => {\n\n\t\t\t\t// Add to cache only on HTTP success, so that we do not cache\n\t\t\t\t// error response bodies as proper responses to requests.\n\t\t\t\tCache.add( url, data );\n\n\t\t\t\tconst callbacks = loading[ url ];\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( data );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.catch( err => {\n\n\t\t\t\t// Abort errors and other errors are handled the same\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tif ( callbacks === undefined ) {\n\n\t\t\t\t\t// When onLoad was called and url was deleted in `loading`\n\t\t\t\t\tthis.manager.itemError( url );\n\t\t\t\t\tthrow err;\n\n\t\t\t\t}\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onError ) callback.onError( err );\n\n\t\t\t\t}\n\n\t\t\t\tthis.manager.itemError( url );\n\n\t\t\t} )\n\t\t\t.finally( () => {\n\n\t\t\t\tthis.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\tthis.manager.itemStart( url );\n\n\t}\n\n\tsetResponseType( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t}\n\n\tsetMimeType( value ) {\n\n\t\tthis.mimeType = value;\n\t\treturn this;\n\n\t}\n\n}\n\nclass AnimationLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst animations = [];\n\n\t\tfor ( let i = 0; i < json.length; i ++ ) {\n\n\t\t\tconst clip = AnimationClip.parse( json[ i ] );\n\n\t\t\tanimations.push( clip );\n\n\t\t}\n\n\t\treturn animations;\n\n\t}\n\n}\n\n/**\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass CompressedTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst images = [];\n\n\t\tconst texture = new CompressedTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;\n\n\t\t\t\t\ttexture.image = images;\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tfor ( let i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tconst faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( let f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps: [] };\n\n\t\t\t\t\t\tfor ( let i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.image = images;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass ImageLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tconst image = createElementNS( 'img' );\n\n\t\tfunction onImageLoad() {\n\n\t\t\tremoveEventListeners();\n\n\t\t\tCache.add( url, this );\n\n\t\t\tif ( onLoad ) onLoad( this );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction onImageError( event ) {\n\n\t\t\tremoveEventListeners();\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction removeEventListeners() {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t}\n\n\t\timage.addEventListener( 'load', onImageLoad, false );\n\t\timage.addEventListener( 'error', onImageError, false );\n\n\t\tif ( url.slice( 0, 5 ) !== 'data:' ) {\n\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\timage.src = url;\n\n\t\treturn image;\n\n\t}\n\n}\n\nclass CubeTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( urls, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new CubeTexture();\n\t\ttexture.colorSpace = SRGBColorSpace;\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\tloaded ++;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, undefined, onError );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < urls.length; ++ i ) {\n\n\t\t\tloadTexture( i );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass DataTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst texture = new DataTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setPath( this.path );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tlet texData;\n\n\t\t\ttry {\n\n\t\t\t\ttexData = scope.parse( buffer );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError !== undefined ) {\n\n\t\t\t\t\tonError( error );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texData.image !== undefined ) {\n\n\t\t\t\ttexture.image = texData.image;\n\n\t\t\t} else if ( texData.data !== undefined ) {\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t}\n\n\t\t\ttexture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\ttexture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n\n\t\t\ttexture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n\t\t\ttexture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n\n\t\t\ttexture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n\t\t\tif ( texData.colorSpace !== undefined ) {\n\n\t\t\t\ttexture.colorSpace = texData.colorSpace;\n\n\t\t\t}\n\n\t\t\tif ( texData.flipY !== undefined ) {\n\n\t\t\t\ttexture.flipY = texData.flipY;\n\n\t\t\t}\n\n\t\t\tif ( texData.format !== undefined ) {\n\n\t\t\t\ttexture.format = texData.format;\n\n\t\t\t}\n\n\t\t\tif ( texData.type !== undefined ) {\n\n\t\t\t\ttexture.type = texData.type;\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmaps !== undefined ) {\n\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\t\t\ttexture.minFilter = LinearMipmapLinearFilter; // presumably...\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmapCount === 1 ) {\n\n\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t}\n\n\t\t\tif ( texData.generateMipmaps !== undefined ) {\n\n\t\t\t\ttexture.generateMipmaps = texData.generateMipmaps;\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}, onProgress, onError );\n\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass TextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new Texture();\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass Light extends Object3D {\n\n\tconstructor( color, intensity = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.isLight = true;\n\n\t\tthis.type = 'Light';\n\n\t\tthis.color = new Color( color );\n\t\tthis.intensity = intensity;\n\n\t}\n\n\tdispose() {\n\n\t\t// Empty here in base class; some subclasses override.\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.intensity = source.intensity;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.color = this.color.getHex();\n\t\tdata.object.intensity = this.intensity;\n\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\t\tif ( this.target !== undefined ) data.object.target = this.target.uuid;\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass HemisphereLight extends Light {\n\n\tconstructor( skyColor, groundColor, intensity ) {\n\n\t\tsuper( skyColor, intensity );\n\n\t\tthis.isHemisphereLight = true;\n\n\t\tthis.type = 'HemisphereLight';\n\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\n\t\tthis.updateMatrix();\n\n\t\tthis.groundColor = new Color( groundColor );\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.groundColor.copy( source.groundColor );\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();\nconst _lookTarget$1 = /*@__PURE__*/ new Vector3();\n\nclass LightShadow {\n\n\tconstructor( camera ) {\n\n\t\tthis.camera = camera;\n\n\t\tthis.intensity = 1;\n\n\t\tthis.bias = 0;\n\t\tthis.normalBias = 0;\n\t\tthis.radius = 1;\n\t\tthis.blurSamples = 8;\n\n\t\tthis.mapSize = new Vector2( 512, 512 );\n\n\t\tthis.map = null;\n\t\tthis.mapPass = null;\n\t\tthis.matrix = new Matrix4();\n\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\n\t\tthis._frustum = new Frustum();\n\t\tthis._frameExtents = new Vector2( 1, 1 );\n\n\t\tthis._viewportCount = 1;\n\n\t\tthis._viewports = [\n\n\t\t\tnew Vector4( 0, 0, 1, 1 )\n\n\t\t];\n\n\t}\n\n\tgetViewportCount() {\n\n\t\treturn this._viewportCount;\n\n\t}\n\n\tgetFrustum() {\n\n\t\treturn this._frustum;\n\n\t}\n\n\tupdateMatrices( light ) {\n\n\t\tconst shadowCamera = this.camera;\n\t\tconst shadowMatrix = this.matrix;\n\n\t\t_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );\n\t\tshadowCamera.position.copy( _lightPositionWorld$1 );\n\n\t\t_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );\n\t\tshadowCamera.lookAt( _lookTarget$1 );\n\t\tshadowCamera.updateMatrixWorld();\n\n\t\t_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\tthis._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );\n\n\t\tshadowMatrix.set(\n\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\n\t\tshadowMatrix.multiply( _projScreenMatrix$1 );\n\n\t}\n\n\tgetViewport( viewportIndex ) {\n\n\t\treturn this._viewports[ viewportIndex ];\n\n\t}\n\n\tgetFrameExtents() {\n\n\t\treturn this._frameExtents;\n\n\t}\n\n\tdispose() {\n\n\t\tif ( this.map ) {\n\n\t\t\tthis.map.dispose();\n\n\t\t}\n\n\t\tif ( this.mapPass ) {\n\n\t\t\tthis.mapPass.dispose();\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.camera = source.camera.clone();\n\n\t\tthis.intensity = source.intensity;\n\n\t\tthis.bias = source.bias;\n\t\tthis.radius = source.radius;\n\n\t\tthis.mapSize.copy( source.mapSize );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst object = {};\n\n\t\tif ( this.intensity !== 1 ) object.intensity = this.intensity;\n\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\tif ( this.normalBias !== 0 ) object.normalBias = this.normalBias;\n\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\tdelete object.camera.matrix;\n\n\t\treturn object;\n\n\t}\n\n}\n\nclass SpotLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n\t\tthis.isSpotLightShadow = true;\n\n\t\tthis.focus = 1;\n\n\t}\n\n\tupdateMatrices( light ) {\n\n\t\tconst camera = this.camera;\n\n\t\tconst fov = RAD2DEG * 2 * light.angle * this.focus;\n\t\tconst aspect = this.mapSize.width / this.mapSize.height;\n\t\tconst far = light.distance || camera.far;\n\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\tcamera.fov = fov;\n\t\t\tcamera.aspect = aspect;\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\tsuper.updateMatrices( light );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.focus = source.focus;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass SpotLight extends Light {\n\n\tconstructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isSpotLight = true;\n\n\t\tthis.type = 'SpotLight';\n\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.distance = distance;\n\t\tthis.angle = angle;\n\t\tthis.penumbra = penumbra;\n\t\tthis.decay = decay;\n\n\t\tthis.map = null;\n\n\t\tthis.shadow = new SpotLightShadow();\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in candela)\n\t\t// by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)\n\t\treturn this.intensity * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in candela) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / Math.PI;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.distance = source.distance;\n\t\tthis.angle = source.angle;\n\t\tthis.penumbra = source.penumbra;\n\t\tthis.decay = source.decay;\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld = /*@__PURE__*/ new Vector3();\nconst _lookTarget = /*@__PURE__*/ new Vector3();\n\nclass PointLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n\t\tthis.isPointLightShadow = true;\n\n\t\tthis._frameExtents = new Vector2( 4, 2 );\n\n\t\tthis._viewportCount = 6;\n\n\t\tthis._viewports = [\n\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t// following orientation:\n\t\t\t//\n\t\t\t//  xzXZ\n\t\t\t//   y Y\n\t\t\t//\n\t\t\t// X - Positive x direction\n\t\t\t// x - Negative x direction\n\t\t\t// Y - Positive y direction\n\t\t\t// y - Negative y direction\n\t\t\t// Z - Positive z direction\n\t\t\t// z - Negative z direction\n\n\t\t\t// positive X\n\t\t\tnew Vector4( 2, 1, 1, 1 ),\n\t\t\t// negative X\n\t\t\tnew Vector4( 0, 1, 1, 1 ),\n\t\t\t// positive Z\n\t\t\tnew Vector4( 3, 1, 1, 1 ),\n\t\t\t// negative Z\n\t\t\tnew Vector4( 1, 1, 1, 1 ),\n\t\t\t// positive Y\n\t\t\tnew Vector4( 3, 0, 1, 1 ),\n\t\t\t// negative Y\n\t\t\tnew Vector4( 1, 0, 1, 1 )\n\t\t];\n\n\t\tthis._cubeDirections = [\n\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t];\n\n\t\tthis._cubeUps = [\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t];\n\n\t}\n\n\tupdateMatrices( light, viewportIndex = 0 ) {\n\n\t\tconst camera = this.camera;\n\t\tconst shadowMatrix = this.matrix;\n\n\t\tconst far = light.distance || camera.far;\n\n\t\tif ( far !== camera.far ) {\n\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\tcamera.position.copy( _lightPositionWorld );\n\n\t\t_lookTarget.copy( camera.position );\n\t\t_lookTarget.add( this._cubeDirections[ viewportIndex ] );\n\t\tcamera.up.copy( this._cubeUps[ viewportIndex ] );\n\t\tcamera.lookAt( _lookTarget );\n\t\tcamera.updateMatrixWorld();\n\n\t\tshadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\tthis._frustum.setFromProjectionMatrix( _projScreenMatrix );\n\n\t}\n\n}\n\nclass PointLight extends Light {\n\n\tconstructor( color, intensity, distance = 0, decay = 2 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isPointLight = true;\n\n\t\tthis.type = 'PointLight';\n\n\t\tthis.distance = distance;\n\t\tthis.decay = decay;\n\n\t\tthis.shadow = new PointLightShadow();\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in candela)\n\t\t// for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)\n\t\treturn this.intensity * 4 * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in candela) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / ( 4 * Math.PI );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.distance = source.distance;\n\t\tthis.decay = source.decay;\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass OrthographicCamera extends Camera {\n\n\tconstructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\tthis.isOrthographicCamera = true;\n\n\t\tthis.type = 'OrthographicCamera';\n\n\t\tthis.zoom = 1;\n\t\tthis.view = null;\n\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.top = top;\n\t\tthis.bottom = bottom;\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.left = source.left;\n\t\tthis.right = source.right;\n\t\tthis.top = source.top;\n\t\tthis.bottom = source.bottom;\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\n\t\tthis.zoom = source.zoom;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\treturn this;\n\n\t}\n\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tupdateProjectionMatrix() {\n\n\t\tconst dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\tconst dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\tconst cx = ( this.right + this.left ) / 2;\n\t\tconst cy = ( this.top + this.bottom ) / 2;\n\n\t\tlet left = cx - dx;\n\t\tlet right = cx + dx;\n\t\tlet top = cy + dy;\n\t\tlet bottom = cy - dy;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;\n\t\t\tconst scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;\n\n\t\t\tleft += scaleW * this.view.offsetX;\n\t\t\tright = left + scaleW * this.view.width;\n\t\t\ttop -= scaleH * this.view.offsetY;\n\t\t\tbottom = top - scaleH * this.view.height;\n\n\t\t}\n\n\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far, this.coordinateSystem );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.zoom = this.zoom;\n\t\tdata.object.left = this.left;\n\t\tdata.object.right = this.right;\n\t\tdata.object.top = this.top;\n\t\tdata.object.bottom = this.bottom;\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass DirectionalLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n\t\tthis.isDirectionalLightShadow = true;\n\n\t}\n\n}\n\nclass DirectionalLight extends Light {\n\n\tconstructor( color, intensity ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isDirectionalLight = true;\n\n\t\tthis.type = 'DirectionalLight';\n\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.shadow = new DirectionalLightShadow();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.target = source.target.clone();\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass AmbientLight extends Light {\n\n\tconstructor( color, intensity ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isAmbientLight = true;\n\n\t\tthis.type = 'AmbientLight';\n\n\t}\n\n}\n\nclass RectAreaLight extends Light {\n\n\tconstructor( color, intensity, width = 10, height = 10 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isRectAreaLight = true;\n\n\t\tthis.type = 'RectAreaLight';\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in nits)\n\t\treturn this.intensity * this.width * this.height * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in nits) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / ( this.width * this.height * Math.PI );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.width = this.width;\n\t\tdata.object.height = this.height;\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * Primary reference:\n *   https://graphics.stanford.edu/papers/envmap/envmap.pdf\n *\n * Secondary reference:\n *   https://www.ppsloan.org/publications/StupidSH36.pdf\n */\n\n// 3-band SH defined by 9 coefficients\n\nclass SphericalHarmonics3 {\n\n\tconstructor() {\n\n\t\tthis.isSphericalHarmonics3 = true;\n\n\t\tthis.coefficients = [];\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients.push( new Vector3() );\n\n\t\t}\n\n\t}\n\n\tset( coefficients ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].copy( coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tzero() {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].set( 0, 0, 0 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// get the radiance in the direction of the normal\n\t// target is a Vector3\n\tgetAt( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\tconst coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );\n\n\t\t// band 1\n\t\ttarget.addScaledVector( coeff[ 1 ], 0.488603 * y );\n\t\ttarget.addScaledVector( coeff[ 2 ], 0.488603 * z );\n\t\ttarget.addScaledVector( coeff[ 3 ], 0.488603 * x );\n\n\t\t// band 2\n\t\ttarget.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );\n\t\ttarget.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );\n\t\ttarget.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );\n\t\ttarget.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );\n\t\ttarget.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );\n\n\t\treturn target;\n\n\t}\n\n\t// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\n\t// target is a Vector3\n\t// https://graphics.stanford.edu/papers/envmap/envmap.pdf\n\tgetIrradianceAt( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\tconst coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095\n\n\t\t// band 1\n\t\ttarget.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603\n\t\ttarget.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );\n\t\ttarget.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );\n\n\t\t// band 2\n\t\ttarget.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548\n\t\ttarget.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );\n\t\ttarget.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3\n\t\ttarget.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );\n\t\ttarget.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274\n\n\t\treturn target;\n\n\t}\n\n\tadd( sh ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].add( sh.coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\taddScaledSH( sh, s ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tscale( s ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].multiplyScalar( s );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tlerp( sh, alpha ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tequals( sh ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tcopy( sh ) {\n\n\t\treturn this.set( sh.coefficients );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tconst coefficients = this.coefficients;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].fromArray( array, offset + ( i * 3 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst coefficients = this.coefficients;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].toArray( array, offset + ( i * 3 ) );\n\n\t\t}\n\n\t\treturn array;\n\n\t}\n\n\t// evaluate the basis functions\n\t// shBasis is an Array[ 9 ]\n\tstatic getBasisAt( normal, shBasis ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\t// band 0\n\t\tshBasis[ 0 ] = 0.282095;\n\n\t\t// band 1\n\t\tshBasis[ 1 ] = 0.488603 * y;\n\t\tshBasis[ 2 ] = 0.488603 * z;\n\t\tshBasis[ 3 ] = 0.488603 * x;\n\n\t\t// band 2\n\t\tshBasis[ 4 ] = 1.092548 * x * y;\n\t\tshBasis[ 5 ] = 1.092548 * y * z;\n\t\tshBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );\n\t\tshBasis[ 7 ] = 1.092548 * x * z;\n\t\tshBasis[ 8 ] = 0.546274 * ( x * x - y * y );\n\n\t}\n\n}\n\nclass LightProbe extends Light {\n\n\tconstructor( sh = new SphericalHarmonics3(), intensity = 1 ) {\n\n\t\tsuper( undefined, intensity );\n\n\t\tthis.isLightProbe = true;\n\n\t\tthis.sh = sh;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.sh.copy( source.sh );\n\n\t\treturn this;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tthis.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();\n\t\tthis.sh.fromArray( json.sh );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.sh = this.sh.toArray();\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass MaterialLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\t\tthis.textures = {};\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst textures = this.textures;\n\n\t\tfunction getTexture( name ) {\n\n\t\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t\t}\n\n\t\t\treturn textures[ name ];\n\n\t\t}\n\n\t\tconst material = this.createMaterialFromType( json.type );\n\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\tif ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\tif ( json.sheen !== undefined ) material.sheen = json.sheen;\n\t\tif ( json.sheenColor !== undefined ) material.sheenColor = new Color().setHex( json.sheenColor );\n\t\tif ( json.sheenRoughness !== undefined ) material.sheenRoughness = json.sheenRoughness;\n\t\tif ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\tif ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );\n\t\tif ( json.specularIntensity !== undefined ) material.specularIntensity = json.specularIntensity;\n\t\tif ( json.specularColor !== undefined && material.specularColor !== undefined ) material.specularColor.setHex( json.specularColor );\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\tif ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;\n\t\tif ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;\n\t\tif ( json.dispersion !== undefined ) material.dispersion = json.dispersion;\n\t\tif ( json.iridescence !== undefined ) material.iridescence = json.iridescence;\n\t\tif ( json.iridescenceIOR !== undefined ) material.iridescenceIOR = json.iridescenceIOR;\n\t\tif ( json.iridescenceThicknessRange !== undefined ) material.iridescenceThicknessRange = json.iridescenceThicknessRange;\n\t\tif ( json.transmission !== undefined ) material.transmission = json.transmission;\n\t\tif ( json.thickness !== undefined ) material.thickness = json.thickness;\n\t\tif ( json.attenuationDistance !== undefined ) material.attenuationDistance = json.attenuationDistance;\n\t\tif ( json.attenuationColor !== undefined && material.attenuationColor !== undefined ) material.attenuationColor.setHex( json.attenuationColor );\n\t\tif ( json.anisotropy !== undefined ) material.anisotropy = json.anisotropy;\n\t\tif ( json.anisotropyRotation !== undefined ) material.anisotropyRotation = json.anisotropyRotation;\n\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\tif ( json.flatShading !== undefined ) material.flatShading = json.flatShading;\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\tif ( json.combine !== undefined ) material.combine = json.combine;\n\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\tif ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\tif ( json.alphaHash !== undefined ) material.alphaHash = json.alphaHash;\n\t\tif ( json.depthFunc !== undefined ) material.depthFunc = json.depthFunc;\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\tif ( json.blendSrc !== undefined ) material.blendSrc = json.blendSrc;\n\t\tif ( json.blendDst !== undefined ) material.blendDst = json.blendDst;\n\t\tif ( json.blendEquation !== undefined ) material.blendEquation = json.blendEquation;\n\t\tif ( json.blendSrcAlpha !== undefined ) material.blendSrcAlpha = json.blendSrcAlpha;\n\t\tif ( json.blendDstAlpha !== undefined ) material.blendDstAlpha = json.blendDstAlpha;\n\t\tif ( json.blendEquationAlpha !== undefined ) material.blendEquationAlpha = json.blendEquationAlpha;\n\t\tif ( json.blendColor !== undefined && material.blendColor !== undefined ) material.blendColor.setHex( json.blendColor );\n\t\tif ( json.blendAlpha !== undefined ) material.blendAlpha = json.blendAlpha;\n\t\tif ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;\n\t\tif ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;\n\t\tif ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;\n\t\tif ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;\n\t\tif ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;\n\t\tif ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;\n\t\tif ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;\n\t\tif ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;\n\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\n\t\tif ( json.rotation !== undefined ) material.rotation = json.rotation;\n\n\t\tif ( json.linewidth !== undefined ) material.linewidth = json.linewidth;\n\t\tif ( json.dashSize !== undefined ) material.dashSize = json.dashSize;\n\t\tif ( json.gapSize !== undefined ) material.gapSize = json.gapSize;\n\t\tif ( json.scale !== undefined ) material.scale = json.scale;\n\n\t\tif ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;\n\t\tif ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;\n\t\tif ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;\n\n\t\tif ( json.dithering !== undefined ) material.dithering = json.dithering;\n\n\t\tif ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;\n\t\tif ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;\n\t\tif ( json.forceSinglePass !== undefined ) material.forceSinglePass = json.forceSinglePass;\n\n\t\tif ( json.visible !== undefined ) material.visible = json.visible;\n\n\t\tif ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;\n\n\t\tif ( json.userData !== undefined ) material.userData = json.userData;\n\n\t\tif ( json.vertexColors !== undefined ) {\n\n\t\t\tif ( typeof json.vertexColors === 'number' ) {\n\n\t\t\t\tmaterial.vertexColors = ( json.vertexColors > 0 ) ? true : false;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.vertexColors = json.vertexColors;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Shader Material\n\n\t\tif ( json.uniforms !== undefined ) {\n\n\t\t\tfor ( const name in json.uniforms ) {\n\n\t\t\t\tconst uniform = json.uniforms[ name ];\n\n\t\t\t\tmaterial.uniforms[ name ] = {};\n\n\t\t\t\tswitch ( uniform.type ) {\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = getTexture( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Color().setHex( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v2':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector2().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector3().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = uniform.value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.defines !== undefined ) material.defines = json.defines;\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\tif ( json.glslVersion !== undefined ) material.glslVersion = json.glslVersion;\n\n\t\tif ( json.extensions !== undefined ) {\n\n\t\t\tfor ( const key in json.extensions ) {\n\n\t\t\t\tmaterial.extensions[ key ] = json.extensions[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.lights !== undefined ) material.lights = json.lights;\n\t\tif ( json.clipping !== undefined ) material.clipping = json.clipping;\n\n\t\t// for PointsMaterial\n\n\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t// maps\n\n\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\t\tif ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );\n\n\t\tif ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );\n\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\tif ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;\n\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\tlet normalScale = json.normalScale;\n\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t}\n\n\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\n\t\t}\n\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\t\tif ( json.specularIntensityMap !== undefined ) material.specularIntensityMap = getTexture( json.specularIntensityMap );\n\t\tif ( json.specularColorMap !== undefined ) material.specularColorMap = getTexture( json.specularColorMap );\n\n\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\t\tif ( json.envMapRotation !== undefined ) material.envMapRotation.fromArray( json.envMapRotation );\n\t\tif ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;\n\n\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\t\tif ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;\n\n\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\tif ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );\n\n\t\tif ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );\n\t\tif ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );\n\t\tif ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );\n\t\tif ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );\n\n\t\tif ( json.iridescenceMap !== undefined ) material.iridescenceMap = getTexture( json.iridescenceMap );\n\t\tif ( json.iridescenceThicknessMap !== undefined ) material.iridescenceThicknessMap = getTexture( json.iridescenceThicknessMap );\n\n\t\tif ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );\n\t\tif ( json.thicknessMap !== undefined ) material.thicknessMap = getTexture( json.thicknessMap );\n\n\t\tif ( json.anisotropyMap !== undefined ) material.anisotropyMap = getTexture( json.anisotropyMap );\n\n\t\tif ( json.sheenColorMap !== undefined ) material.sheenColorMap = getTexture( json.sheenColorMap );\n\t\tif ( json.sheenRoughnessMap !== undefined ) material.sheenRoughnessMap = getTexture( json.sheenRoughnessMap );\n\n\t\treturn material;\n\n\t}\n\n\tsetTextures( value ) {\n\n\t\tthis.textures = value;\n\t\treturn this;\n\n\t}\n\n\tcreateMaterialFromType( type ) {\n\n\t\treturn MaterialLoader.createMaterialFromType( type );\n\n\t}\n\n\tstatic createMaterialFromType( type ) {\n\n\t\tconst materialLib = {\n\t\t\tShadowMaterial,\n\t\t\tSpriteMaterial,\n\t\t\tRawShaderMaterial,\n\t\t\tShaderMaterial,\n\t\t\tPointsMaterial,\n\t\t\tMeshPhysicalMaterial,\n\t\t\tMeshStandardMaterial,\n\t\t\tMeshPhongMaterial,\n\t\t\tMeshToonMaterial,\n\t\t\tMeshNormalMaterial,\n\t\t\tMeshLambertMaterial,\n\t\t\tMeshDepthMaterial,\n\t\t\tMeshDistanceMaterial,\n\t\t\tMeshBasicMaterial,\n\t\t\tMeshMatcapMaterial,\n\t\t\tLineDashedMaterial,\n\t\t\tLineBasicMaterial,\n\t\t\tMaterial\n\t\t};\n\n\t\treturn new materialLib[ type ]();\n\n\t}\n\n}\n\nclass LoaderUtils {\n\n\tstatic decodeText( array ) { // @deprecated, r165\n\n\t\tconsole.warn( 'THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.' );\n\n\t\tif ( typeof TextDecoder !== 'undefined' ) {\n\n\t\t\treturn new TextDecoder().decode( array );\n\n\t\t}\n\n\t\t// Avoid the String.fromCharCode.apply(null, array) shortcut, which\n\t\t// throws a \"maximum call stack size exceeded\" error for large arrays.\n\n\t\tlet s = '';\n\n\t\tfor ( let i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t// Implicitly assumes little-endian.\n\t\t\ts += String.fromCharCode( array[ i ] );\n\n\t\t}\n\n\t\ttry {\n\n\t\t\t// merges multi-byte utf-8 characters.\n\n\t\t\treturn decodeURIComponent( escape( s ) );\n\n\t\t} catch ( e ) { // see #16358\n\n\t\t\treturn s;\n\n\t\t}\n\n\t}\n\n\tstatic extractUrlBase( url ) {\n\n\t\tconst index = url.lastIndexOf( '/' );\n\n\t\tif ( index === - 1 ) return './';\n\n\t\treturn url.slice( 0, index + 1 );\n\n\t}\n\n\tstatic resolveURL( url, path ) {\n\n\t\t// Invalid URL\n\t\tif ( typeof url !== 'string' || url === '' ) return '';\n\n\t\t// Host Relative URL\n\t\tif ( /^https?:\\/\\//i.test( path ) && /^\\//.test( url ) ) {\n\n\t\t\tpath = path.replace( /(^https?:\\/\\/[^\\/]+).*/i, '$1' );\n\n\t\t}\n\n\t\t// Absolute URL http://,https://,//\n\t\tif ( /^(https?:)?\\/\\//i.test( url ) ) return url;\n\n\t\t// Data URI\n\t\tif ( /^data:.*,.*$/i.test( url ) ) return url;\n\n\t\t// Blob URL\n\t\tif ( /^blob:.*$/i.test( url ) ) return url;\n\n\t\t// Relative URL\n\t\treturn path + url;\n\n\t}\n\n}\n\nclass InstancedBufferGeometry extends BufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isInstancedBufferGeometry = true;\n\n\t\tthis.type = 'InstancedBufferGeometry';\n\t\tthis.instanceCount = Infinity;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.instanceCount = source.instanceCount;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.instanceCount = this.instanceCount;\n\n\t\tdata.isInstancedBufferGeometry = true;\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass BufferGeometryLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst interleavedBufferMap = {};\n\t\tconst arrayBufferMap = {};\n\n\t\tfunction getInterleavedBuffer( json, uuid ) {\n\n\t\t\tif ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];\n\n\t\t\tconst interleavedBuffers = json.interleavedBuffers;\n\t\t\tconst interleavedBuffer = interleavedBuffers[ uuid ];\n\n\t\t\tconst buffer = getArrayBuffer( json, interleavedBuffer.buffer );\n\n\t\t\tconst array = getTypedArray( interleavedBuffer.type, buffer );\n\t\t\tconst ib = new InterleavedBuffer( array, interleavedBuffer.stride );\n\t\t\tib.uuid = interleavedBuffer.uuid;\n\n\t\t\tinterleavedBufferMap[ uuid ] = ib;\n\n\t\t\treturn ib;\n\n\t\t}\n\n\t\tfunction getArrayBuffer( json, uuid ) {\n\n\t\t\tif ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];\n\n\t\t\tconst arrayBuffers = json.arrayBuffers;\n\t\t\tconst arrayBuffer = arrayBuffers[ uuid ];\n\n\t\t\tconst ab = new Uint32Array( arrayBuffer ).buffer;\n\n\t\t\tarrayBufferMap[ uuid ] = ab;\n\n\t\t\treturn ab;\n\n\t\t}\n\n\t\tconst geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n\n\t\tconst index = json.data.index;\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst typedArray = getTypedArray( index.type, index.array );\n\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n\t\t}\n\n\t\tconst attributes = json.data.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\t\t\tlet bufferAttribute;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t} else {\n\n\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\tconst bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n\t\t\t\tbufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t}\n\n\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\tif ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );\n\n\t\t\tgeometry.setAttribute( key, bufferAttribute );\n\n\t\t}\n\n\t\tconst morphAttributes = json.data.morphAttributes;\n\n\t\tif ( morphAttributes ) {\n\n\t\t\tfor ( const key in morphAttributes ) {\n\n\t\t\t\tconst attributeArray = morphAttributes[ key ];\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst attribute = attributeArray[ i ];\n\t\t\t\t\tlet bufferAttribute;\n\n\t\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\t\t\tbufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\t\t\tarray.push( bufferAttribute );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.morphAttributes[ key ] = array;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst morphTargetsRelative = json.data.morphTargetsRelative;\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\tgeometry.morphTargetsRelative = true;\n\n\t\t}\n\n\t\tconst groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\tif ( groups !== undefined ) {\n\n\t\t\tfor ( let i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst boundingSphere = json.data.boundingSphere;\n\n\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\tconst center = new Vector3();\n\n\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\n\t\t}\n\n\t\tif ( json.name ) geometry.name = json.name;\n\t\tif ( json.userData ) geometry.userData = json.userData;\n\n\t\treturn geometry;\n\n\t}\n\n}\n\nclass ObjectLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tlet json = null;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError !== undefined ) onError( error );\n\n\t\t\t\tconsole.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst metadata = json.metadata;\n\n\t\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\t\tif ( onError !== undefined ) onError( new Error( 'THREE.ObjectLoader: Can\\'t load ' + url ) );\n\n\t\t\t\tconsole.error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tscope.parse( json, onLoad );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tasync loadAsync( url, onProgress ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tconst text = await loader.loadAsync( url, onProgress );\n\n\t\tconst json = JSON.parse( text );\n\n\t\tconst metadata = json.metadata;\n\n\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\tthrow new Error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\n\t\t}\n\n\t\treturn await scope.parseAsync( json );\n\n\t}\n\n\tparse( json, onLoad ) {\n\n\t\tconst animations = this.parseAnimations( json.animations );\n\t\tconst shapes = this.parseShapes( json.shapes );\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tconst images = this.parseImages( json.images, function () {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t} );\n\n\t\tconst textures = this.parseTextures( json.textures, images );\n\t\tconst materials = this.parseMaterials( json.materials, textures );\n\n\t\tconst object = this.parseObject( json.object, geometries, materials, textures, animations );\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\n\n\t\tthis.bindSkeletons( object, skeletons );\n\t\tthis.bindLightTargets( object );\n\n\t\t//\n\n\t\tif ( onLoad !== undefined ) {\n\n\t\t\tlet hasImages = false;\n\n\t\t\tfor ( const uuid in images ) {\n\n\t\t\t\tif ( images[ uuid ].data instanceof HTMLImageElement ) {\n\n\t\t\t\t\thasImages = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasImages === false ) onLoad( object );\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n\tasync parseAsync( json ) {\n\n\t\tconst animations = this.parseAnimations( json.animations );\n\t\tconst shapes = this.parseShapes( json.shapes );\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tconst images = await this.parseImagesAsync( json.images );\n\n\t\tconst textures = this.parseTextures( json.textures, images );\n\t\tconst materials = this.parseMaterials( json.materials, textures );\n\n\t\tconst object = this.parseObject( json.object, geometries, materials, textures, animations );\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\n\n\t\tthis.bindSkeletons( object, skeletons );\n\t\tthis.bindLightTargets( object );\n\n\t\treturn object;\n\n\t}\n\n\tparseShapes( json ) {\n\n\t\tconst shapes = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst shape = new Shape().fromJSON( json[ i ] );\n\n\t\t\t\tshapes[ shape.uuid ] = shape;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n\tparseSkeletons( json, object ) {\n\n\t\tconst skeletons = {};\n\t\tconst bones = {};\n\n\t\t// generate bone lookup table\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isBone ) bones[ child.uuid ] = child;\n\n\t\t} );\n\n\t\t// create skeletons\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst skeleton = new Skeleton().fromJSON( json[ i ], bones );\n\n\t\t\t\tskeletons[ skeleton.uuid ] = skeleton;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn skeletons;\n\n\t}\n\n\tparseGeometries( json, shapes ) {\n\n\t\tconst geometries = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tlet geometry;\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'BufferGeometry':\n\t\t\t\t\tcase 'InstancedBufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( data.type in Geometries ) {\n\n\t\t\t\t\t\t\tgeometry = Geometries[ data.type ].fromJSON( data, shapes );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( `THREE.ObjectLoader: Unsupported geometry type \"${ data.type }\"` );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\t\t\t\tif ( data.userData !== undefined ) geometry.userData = data.userData;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t}\n\n\tparseMaterials( json, textures ) {\n\n\t\tconst cache = {}; // MultiMaterial\n\t\tconst materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst loader = new MaterialLoader();\n\t\t\tloader.setTextures( textures );\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tif ( cache[ data.uuid ] === undefined ) {\n\n\t\t\t\t\tcache[ data.uuid ] = loader.parse( data );\n\n\t\t\t\t}\n\n\t\t\t\tmaterials[ data.uuid ] = cache[ data.uuid ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n\tparseAnimations( json ) {\n\n\t\tconst animations = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0; i < json.length; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tconst clip = AnimationClip.parse( data );\n\n\t\t\t\tanimations[ clip.uuid ] = clip;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn animations;\n\n\t}\n\n\tparseImages( json, onLoad ) {\n\n\t\tconst scope = this;\n\t\tconst images = {};\n\n\t\tlet loader;\n\n\t\tfunction loadImage( url ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn loader.load( url, function () {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, undefined, function () {\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction deserializeImage( image ) {\n\n\t\t\tif ( typeof image === 'string' ) {\n\n\t\t\t\tconst url = image;\n\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\n\n\t\t\t\treturn loadImage( path );\n\n\t\t\t} else {\n\n\t\t\t\tif ( image.data ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\n\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\theight: image.height\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tconst manager = new LoadingManager( onLoad );\n\n\t\t\tloader = new ImageLoader( manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tconst image = json[ i ];\n\t\t\t\tconst url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\tconst imageArray = [];\n\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst currentUrl = url[ j ];\n\n\t\t\t\t\t\tconst deserializedImage = deserializeImage( currentUrl );\n\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\n\n\t\t\t\t\t\t\t\timageArray.push( deserializedImage );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\n\t\t\t\t\t\t\t\timageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\timages[ image.uuid ] = new Source( imageArray );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tconst deserializedImage = deserializeImage( image.url );\n\t\t\t\t\timages[ image.uuid ] = new Source( deserializedImage );\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\tasync parseImagesAsync( json ) {\n\n\t\tconst scope = this;\n\t\tconst images = {};\n\n\t\tlet loader;\n\n\t\tasync function deserializeImage( image ) {\n\n\t\t\tif ( typeof image === 'string' ) {\n\n\t\t\t\tconst url = image;\n\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\n\n\t\t\t\treturn await loader.loadAsync( path );\n\n\t\t\t} else {\n\n\t\t\t\tif ( image.data ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\n\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\theight: image.height\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tloader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tconst image = json[ i ];\n\t\t\t\tconst url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\tconst imageArray = [];\n\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst currentUrl = url[ j ];\n\n\t\t\t\t\t\tconst deserializedImage = await deserializeImage( currentUrl );\n\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\n\n\t\t\t\t\t\t\t\timageArray.push( deserializedImage );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\n\t\t\t\t\t\t\t\timageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\timages[ image.uuid ] = new Source( imageArray );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tconst deserializedImage = await deserializeImage( image.url );\n\t\t\t\t\timages[ image.uuid ] = new Source( deserializedImage );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\tparseTextures( json, images ) {\n\n\t\tfunction parseConstant( value, type ) {\n\n\t\t\tif ( typeof value === 'number' ) return value;\n\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\treturn type[ value ];\n\n\t\t}\n\n\t\tconst textures = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t}\n\n\t\t\t\tconst source = images[ data.image ];\n\t\t\t\tconst image = source.data;\n\n\t\t\t\tlet texture;\n\n\t\t\t\tif ( Array.isArray( image ) ) {\n\n\t\t\t\t\ttexture = new CubeTexture();\n\n\t\t\t\t\tif ( image.length === 6 ) texture.needsUpdate = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( image && image.data ) {\n\n\t\t\t\t\t\ttexture = new DataTexture();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture = new Texture();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( image ) texture.needsUpdate = true; // textures can have undefined image data\n\n\t\t\t\t}\n\n\t\t\t\ttexture.source = source;\n\n\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\n\t\t\t\tif ( data.channel !== undefined ) texture.channel = data.channel;\n\n\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\n\t\t\t\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\n\n\t\t\t\tif ( data.wrap !== undefined ) {\n\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.format !== undefined ) texture.format = data.format;\n\t\t\t\tif ( data.internalFormat !== undefined ) texture.internalFormat = data.internalFormat;\n\t\t\t\tif ( data.type !== undefined ) texture.type = data.type;\n\t\t\t\tif ( data.colorSpace !== undefined ) texture.colorSpace = data.colorSpace;\n\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n\t\t\t\tif ( data.generateMipmaps !== undefined ) texture.generateMipmaps = data.generateMipmaps;\n\t\t\t\tif ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;\n\t\t\t\tif ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;\n\t\t\t\tif ( data.compareFunction !== undefined ) texture.compareFunction = data.compareFunction;\n\n\t\t\t\tif ( data.userData !== undefined ) texture.userData = data.userData;\n\n\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textures;\n\n\t}\n\n\tparseObject( data, geometries, materials, textures, animations ) {\n\n\t\tlet object;\n\n\t\tfunction getGeometry( name ) {\n\n\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t}\n\n\t\t\treturn geometries[ name ];\n\n\t\t}\n\n\t\tfunction getMaterial( name ) {\n\n\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, l = name.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst uuid = name[ i ];\n\n\t\t\t\t\tif ( materials[ uuid ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tarray.push( materials[ uuid ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t}\n\n\t\t\treturn materials[ name ];\n\n\t\t}\n\n\t\tfunction getTexture( uuid ) {\n\n\t\t\tif ( textures[ uuid ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined texture', uuid );\n\n\t\t\t}\n\n\t\t\treturn textures[ uuid ];\n\n\t\t}\n\n\t\tlet geometry, material;\n\n\t\tswitch ( data.type ) {\n\n\t\t\tcase 'Scene':\n\n\t\t\t\tobject = new Scene();\n\n\t\t\t\tif ( data.background !== undefined ) {\n\n\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\n\t\t\t\t\t\tobject.background = new Color( data.background );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject.background = getTexture( data.background );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.environment !== undefined ) {\n\n\t\t\t\t\tobject.environment = getTexture( data.environment );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.fog !== undefined ) {\n\n\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\n\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\n\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\n\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( data.fog.name !== '' ) {\n\n\t\t\t\t\t\tobject.fog.name = data.fog.name;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.backgroundBlurriness !== undefined ) object.backgroundBlurriness = data.backgroundBlurriness;\n\t\t\t\tif ( data.backgroundIntensity !== undefined ) object.backgroundIntensity = data.backgroundIntensity;\n\t\t\t\tif ( data.backgroundRotation !== undefined ) object.backgroundRotation.fromArray( data.backgroundRotation );\n\n\t\t\t\tif ( data.environmentIntensity !== undefined ) object.environmentIntensity = data.environmentIntensity;\n\t\t\t\tif ( data.environmentRotation !== undefined ) object.environmentRotation.fromArray( data.environmentRotation );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'AmbientLight':\n\n\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'DirectionalLight':\n\n\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\t\t\t\tobject.target = data.target || '';\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointLight':\n\n\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'RectAreaLight':\n\n\t\t\t\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SpotLight':\n\n\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\t\t\t\tobject.target = data.target || '';\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'HemisphereLight':\n\n\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LightProbe':\n\n\t\t\t\tobject = new LightProbe().fromJSON( data );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SkinnedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t \tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\n\t\t\t\tif ( data.bindMode !== undefined ) object.bindMode = data.bindMode;\n\t\t\t\tif ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );\n\t\t\t\tif ( data.skeleton !== undefined ) object.skeleton = data.skeleton;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Mesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'InstancedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\t\t\t\tconst count = data.count;\n\t\t\t\tconst instanceMatrix = data.instanceMatrix;\n\t\t\t\tconst instanceColor = data.instanceColor;\n\n\t\t\t\tobject = new InstancedMesh( geometry, material, count );\n\t\t\t\tobject.instanceMatrix = new InstancedBufferAttribute( new Float32Array( instanceMatrix.array ), 16 );\n\t\t\t\tif ( instanceColor !== undefined ) object.instanceColor = new InstancedBufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'BatchedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new BatchedMesh( data.maxInstanceCount, data.maxVertexCount, data.maxIndexCount, material );\n\t\t\t\tobject.geometry = geometry;\n\t\t\t\tobject.perObjectFrustumCulled = data.perObjectFrustumCulled;\n\t\t\t\tobject.sortObjects = data.sortObjects;\n\n\t\t\t\tobject._drawRanges = data.drawRanges;\n\t\t\t\tobject._reservedRanges = data.reservedRanges;\n\n\t\t\t\tobject._visibility = data.visibility;\n\t\t\t\tobject._active = data.active;\n\t\t\t\tobject._bounds = data.bounds.map( bound => {\n\n\t\t\t\t\tconst box = new Box3();\n\t\t\t\t\tbox.min.fromArray( bound.boxMin );\n\t\t\t\t\tbox.max.fromArray( bound.boxMax );\n\n\t\t\t\t\tconst sphere = new Sphere();\n\t\t\t\t\tsphere.radius = bound.sphereRadius;\n\t\t\t\t\tsphere.center.fromArray( bound.sphereCenter );\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tboxInitialized: bound.boxInitialized,\n\t\t\t\t\t\tbox: box,\n\n\t\t\t\t\t\tsphereInitialized: bound.sphereInitialized,\n\t\t\t\t\t\tsphere: sphere\n\t\t\t\t\t};\n\n\t\t\t\t} );\n\n\t\t\t\tobject._maxInstanceCount = data.maxInstanceCount;\n\t\t\t\tobject._maxVertexCount = data.maxVertexCount;\n\t\t\t\tobject._maxIndexCount = data.maxIndexCount;\n\n\t\t\t\tobject._geometryInitialized = data.geometryInitialized;\n\t\t\t\tobject._geometryCount = data.geometryCount;\n\n\t\t\t\tobject._matricesTexture = getTexture( data.matricesTexture.uuid );\n\t\t\t\tif ( data.colorsTexture !== undefined ) object._colorsTexture = getTexture( data.colorsTexture.uuid );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LOD':\n\n\t\t\t\tobject = new LOD();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Line':\n\n\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineLoop':\n\n\t\t\t\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineSegments':\n\n\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointCloud':\n\t\t\tcase 'Points':\n\n\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Sprite':\n\n\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Group':\n\n\t\t\t\tobject = new Group();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Bone':\n\n\t\t\t\tobject = new Bone();\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tobject = new Object3D();\n\n\t\t}\n\n\t\tobject.uuid = data.uuid;\n\n\t\tif ( data.name !== undefined ) object.name = data.name;\n\n\t\tif ( data.matrix !== undefined ) {\n\n\t\t\tobject.matrix.fromArray( data.matrix );\n\n\t\t\tif ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;\n\t\t\tif ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t} else {\n\n\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t}\n\n\t\tif ( data.up !== undefined ) object.up.fromArray( data.up );\n\n\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\tif ( data.shadow ) {\n\n\t\t\tif ( data.shadow.intensity !== undefined ) object.shadow.intensity = data.shadow.intensity;\n\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\tif ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;\n\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\n\t\t}\n\n\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\tif ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;\n\t\tif ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;\n\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\t\tif ( data.layers !== undefined ) object.layers.mask = data.layers;\n\n\t\tif ( data.children !== undefined ) {\n\n\t\t\tconst children = data.children;\n\n\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tobject.add( this.parseObject( children[ i ], geometries, materials, textures, animations ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.animations !== undefined ) {\n\n\t\t\tconst objectAnimations = data.animations;\n\n\t\t\tfor ( let i = 0; i < objectAnimations.length; i ++ ) {\n\n\t\t\t\tconst uuid = objectAnimations[ i ];\n\n\t\t\t\tobject.animations.push( animations[ uuid ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.type === 'LOD' ) {\n\n\t\t\tif ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;\n\n\t\t\tconst levels = data.levels;\n\n\t\t\tfor ( let l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\tconst level = levels[ l ];\n\t\t\t\tconst child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\tobject.addLevel( child, level.distance, level.hysteresis );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n\tbindSkeletons( object, skeletons ) {\n\n\t\tif ( Object.keys( skeletons ).length === 0 ) return;\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {\n\n\t\t\t\tconst skeleton = skeletons[ child.skeleton ];\n\n\t\t\t\tif ( skeleton === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tchild.bind( skeleton, child.bindMatrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tbindLightTargets( object ) {\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isDirectionalLight || child.isSpotLight ) {\n\n\t\t\t\tconst uuid = child.target;\n\n\t\t\t\tconst target = object.getObjectByProperty( 'uuid', uuid );\n\n\t\t\t\tif ( target !== undefined ) {\n\n\t\t\t\t\tchild.target = target;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tchild.target = new Object3D();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n\nconst TEXTURE_MAPPING = {\n\tUVMapping: UVMapping,\n\tCubeReflectionMapping: CubeReflectionMapping,\n\tCubeRefractionMapping: CubeRefractionMapping,\n\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\tCubeUVReflectionMapping: CubeUVReflectionMapping\n};\n\nconst TEXTURE_WRAPPING = {\n\tRepeatWrapping: RepeatWrapping,\n\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\tMirroredRepeatWrapping: MirroredRepeatWrapping\n};\n\nconst TEXTURE_FILTER = {\n\tNearestFilter: NearestFilter,\n\tNearestMipmapNearestFilter: NearestMipmapNearestFilter,\n\tNearestMipmapLinearFilter: NearestMipmapLinearFilter,\n\tLinearFilter: LinearFilter,\n\tLinearMipmapNearestFilter: LinearMipmapNearestFilter,\n\tLinearMipmapLinearFilter: LinearMipmapLinearFilter\n};\n\nclass ImageBitmapLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.isImageBitmapLoader = true;\n\n\t\tif ( typeof createImageBitmap === 'undefined' ) {\n\n\t\t\tconsole.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );\n\n\t\t}\n\n\t\tif ( typeof fetch === 'undefined' ) {\n\n\t\t\tconsole.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );\n\n\t\t}\n\n\t\tthis.options = { premultiplyAlpha: 'none' };\n\n\t}\n\n\tsetOptions( options ) {\n\n\t\tthis.options = options;\n\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\t// If cached is a promise, wait for it to resolve\n\t\t\tif ( cached.then ) {\n\n\t\t\t\tcached.then( imageBitmap => {\n\n\t\t\t\t\tif ( onLoad ) onLoad( imageBitmap );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t} ).catch( e => {\n\n\t\t\t\t\tif ( onError ) onError( e );\n\n\t\t\t\t} );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// If cached is not a promise (i.e., it's already an imageBitmap)\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tconst fetchOptions = {};\n\t\tfetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';\n\t\tfetchOptions.headers = this.requestHeader;\n\n\t\tconst promise = fetch( url, fetchOptions ).then( function ( res ) {\n\n\t\t\treturn res.blob();\n\n\t\t} ).then( function ( blob ) {\n\n\t\t\treturn createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );\n\n\t\t} ).then( function ( imageBitmap ) {\n\n\t\t\tCache.add( url, imageBitmap );\n\n\t\t\tif ( onLoad ) onLoad( imageBitmap );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t\treturn imageBitmap;\n\n\t\t} ).catch( function ( e ) {\n\n\t\t\tif ( onError ) onError( e );\n\n\t\t\tCache.remove( url );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t} );\n\n\t\tCache.add( url, promise );\n\t\tscope.manager.itemStart( url );\n\n\t}\n\n}\n\nlet _context;\n\nclass AudioContext {\n\n\tstatic getContext() {\n\n\t\tif ( _context === undefined ) {\n\n\t\t\t_context = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t}\n\n\t\treturn _context;\n\n\t}\n\n\tstatic setContext( value ) {\n\n\t\t_context = value;\n\n\t}\n\n}\n\nclass AudioLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\ttry {\n\n\t\t\t\t// Create a copy of the buffer. The `decodeAudioData` method\n\t\t\t\t// detaches the buffer when complete, preventing reuse.\n\t\t\t\tconst bufferCopy = buffer.slice( 0 );\n\n\t\t\t\tconst context = AudioContext.getContext();\n\t\t\t\tcontext.decodeAudioData( bufferCopy, function ( audioBuffer ) {\n\n\t\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t\t} ).catch( handleError );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\thandleError( e );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\tfunction handleError( e ) {\n\n\t\t\tif ( onError ) {\n\n\t\t\t\tonError( e );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemError( url );\n\n\t\t}\n\n\t}\n\n}\n\nconst _eyeRight = /*@__PURE__*/ new Matrix4();\nconst _eyeLeft = /*@__PURE__*/ new Matrix4();\nconst _projectionMatrix = /*@__PURE__*/ new Matrix4();\n\nclass StereoCamera {\n\n\tconstructor() {\n\n\t\tthis.type = 'StereoCamera';\n\n\t\tthis.aspect = 1;\n\n\t\tthis.eyeSep = 0.064;\n\n\t\tthis.cameraL = new PerspectiveCamera();\n\t\tthis.cameraL.layers.enable( 1 );\n\t\tthis.cameraL.matrixAutoUpdate = false;\n\n\t\tthis.cameraR = new PerspectiveCamera();\n\t\tthis.cameraR.layers.enable( 2 );\n\t\tthis.cameraR.matrixAutoUpdate = false;\n\n\t\tthis._cache = {\n\t\t\tfocus: null,\n\t\t\tfov: null,\n\t\t\taspect: null,\n\t\t\tnear: null,\n\t\t\tfar: null,\n\t\t\tzoom: null,\n\t\t\teyeSep: null\n\t\t};\n\n\t}\n\n\tupdate( camera ) {\n\n\t\tconst cache = this._cache;\n\n\t\tconst needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||\n\t\t\tcache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||\n\t\t\tcache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tcache.focus = camera.focus;\n\t\t\tcache.fov = camera.fov;\n\t\t\tcache.aspect = camera.aspect * this.aspect;\n\t\t\tcache.near = camera.near;\n\t\t\tcache.far = camera.far;\n\t\t\tcache.zoom = camera.zoom;\n\t\t\tcache.eyeSep = this.eyeSep;\n\n\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t_projectionMatrix.copy( camera.projectionMatrix );\n\t\t\tconst eyeSepHalf = cache.eyeSep / 2;\n\t\t\tconst eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;\n\t\t\tconst ymax = ( cache.near * Math.tan( DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;\n\t\t\tlet xmin, xmax;\n\n\t\t\t// translate xOffset\n\n\t\t\t_eyeLeft.elements[ 12 ] = - eyeSepHalf;\n\t\t\t_eyeRight.elements[ 12 ] = eyeSepHalf;\n\n\t\t\t// for left eye\n\n\t\t\txmin = - ymax * cache.aspect + eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect + eyeSepOnProjection;\n\n\t\t\t_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\t_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\tthis.cameraL.projectionMatrix.copy( _projectionMatrix );\n\n\t\t\t// for right eye\n\n\t\t\txmin = - ymax * cache.aspect - eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect - eyeSepOnProjection;\n\n\t\t\t_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\t_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\tthis.cameraR.projectionMatrix.copy( _projectionMatrix );\n\n\t\t}\n\n\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );\n\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );\n\n\t}\n\n}\n\nclass ArrayCamera extends PerspectiveCamera {\n\n\tconstructor( array = [] ) {\n\n\t\tsuper();\n\n\t\tthis.isArrayCamera = true;\n\n\t\tthis.cameras = array;\n\n\t}\n\n}\n\nclass Clock {\n\n\tconstructor( autoStart = true ) {\n\n\t\tthis.autoStart = autoStart;\n\n\t\tthis.startTime = 0;\n\t\tthis.oldTime = 0;\n\t\tthis.elapsedTime = 0;\n\n\t\tthis.running = false;\n\n\t}\n\n\tstart() {\n\n\t\tthis.startTime = now();\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.elapsedTime = 0;\n\t\tthis.running = true;\n\n\t}\n\n\tstop() {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\t\tthis.autoStart = false;\n\n\t}\n\n\tgetElapsedTime() {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t}\n\n\tgetDelta() {\n\n\t\tlet diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tconst newTime = now();\n\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n}\n\nfunction now() {\n\n\treturn performance.now();\n\n}\n\nconst _position$1 = /*@__PURE__*/ new Vector3();\nconst _quaternion$1 = /*@__PURE__*/ new Quaternion();\nconst _scale$1 = /*@__PURE__*/ new Vector3();\nconst _orientation$1 = /*@__PURE__*/ new Vector3();\n\nclass AudioListener extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'AudioListener';\n\n\t\tthis.context = AudioContext.getContext();\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( this.context.destination );\n\n\t\tthis.filter = null;\n\n\t\tthis.timeDelta = 0;\n\n\t\t// private\n\n\t\tthis._clock = new Clock();\n\n\t}\n\n\tgetInput() {\n\n\t\treturn this.gain;\n\n\t}\n\n\tremoveFilter() {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\tthis.gain.connect( this.context.destination );\n\t\t\tthis.filter = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetFilter() {\n\n\t\treturn this.filter;\n\n\t}\n\n\tsetFilter( value ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t} else {\n\n\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t}\n\n\t\tthis.filter = value;\n\t\tthis.gain.connect( this.filter );\n\t\tthis.filter.connect( this.context.destination );\n\n\t\treturn this;\n\n\t}\n\n\tgetMasterVolume() {\n\n\t\treturn this.gain.gain.value;\n\n\t}\n\n\tsetMasterVolume( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tconst listener = this.context.listener;\n\t\tconst up = this.up;\n\n\t\tthis.timeDelta = this._clock.getDelta();\n\n\t\tthis.matrixWorld.decompose( _position$1, _quaternion$1, _scale$1 );\n\n\t\t_orientation$1.set( 0, 0, - 1 ).applyQuaternion( _quaternion$1 );\n\n\t\tif ( listener.positionX ) {\n\n\t\t\t// code path for Chrome (see #14393)\n\n\t\t\tconst endTime = this.context.currentTime + this.timeDelta;\n\n\t\t\tlistener.positionX.linearRampToValueAtTime( _position$1.x, endTime );\n\t\t\tlistener.positionY.linearRampToValueAtTime( _position$1.y, endTime );\n\t\t\tlistener.positionZ.linearRampToValueAtTime( _position$1.z, endTime );\n\t\t\tlistener.forwardX.linearRampToValueAtTime( _orientation$1.x, endTime );\n\t\t\tlistener.forwardY.linearRampToValueAtTime( _orientation$1.y, endTime );\n\t\t\tlistener.forwardZ.linearRampToValueAtTime( _orientation$1.z, endTime );\n\t\t\tlistener.upX.linearRampToValueAtTime( up.x, endTime );\n\t\t\tlistener.upY.linearRampToValueAtTime( up.y, endTime );\n\t\t\tlistener.upZ.linearRampToValueAtTime( up.z, endTime );\n\n\t\t} else {\n\n\t\t\tlistener.setPosition( _position$1.x, _position$1.y, _position$1.z );\n\t\t\tlistener.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z );\n\n\t\t}\n\n\t}\n\n}\n\nclass Audio extends Object3D {\n\n\tconstructor( listener ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Audio';\n\n\t\tthis.listener = listener;\n\t\tthis.context = listener.context;\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( listener.getInput() );\n\n\t\tthis.autoplay = false;\n\n\t\tthis.buffer = null;\n\t\tthis.detune = 0;\n\t\tthis.loop = false;\n\t\tthis.loopStart = 0;\n\t\tthis.loopEnd = 0;\n\t\tthis.offset = 0;\n\t\tthis.duration = undefined;\n\t\tthis.playbackRate = 1;\n\t\tthis.isPlaying = false;\n\t\tthis.hasPlaybackControl = true;\n\t\tthis.source = null;\n\t\tthis.sourceType = 'empty';\n\n\t\tthis._startedAt = 0;\n\t\tthis._progress = 0;\n\t\tthis._connected = false;\n\n\t\tthis.filters = [];\n\n\t}\n\n\tgetOutput() {\n\n\t\treturn this.gain;\n\n\t}\n\n\tsetNodeSource( audioNode ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'audioNode';\n\t\tthis.source = audioNode;\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetMediaElementSource( mediaElement ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'mediaNode';\n\t\tthis.source = this.context.createMediaElementSource( mediaElement );\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetMediaStreamSource( mediaStream ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'mediaStreamNode';\n\t\tthis.source = this.context.createMediaStreamSource( mediaStream );\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetBuffer( audioBuffer ) {\n\n\t\tthis.buffer = audioBuffer;\n\t\tthis.sourceType = 'buffer';\n\n\t\tif ( this.autoplay ) this.play();\n\n\t\treturn this;\n\n\t}\n\n\tplay( delay = 0 ) {\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._startedAt = this.context.currentTime + delay;\n\n\t\tconst source = this.context.createBufferSource();\n\t\tsource.buffer = this.buffer;\n\t\tsource.loop = this.loop;\n\t\tsource.loopStart = this.loopStart;\n\t\tsource.loopEnd = this.loopEnd;\n\t\tsource.onended = this.onEnded.bind( this );\n\t\tsource.start( this._startedAt, this._progress + this.offset, this.duration );\n\n\t\tthis.isPlaying = true;\n\n\t\tthis.source = source;\n\n\t\tthis.setDetune( this.detune );\n\t\tthis.setPlaybackRate( this.playbackRate );\n\n\t\treturn this.connect();\n\n\t}\n\n\tpause() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\t// update current progress\n\n\t\t\tthis._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;\n\n\t\t\tif ( this.loop === true ) {\n\n\t\t\t\t// ensure _progress does not exceed duration with looped audios\n\n\t\t\t\tthis._progress = this._progress % ( this.duration || this.buffer.duration );\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.source.onended = null;\n\n\t\t\tthis.isPlaying = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tstop( delay = 0 ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._progress = 0;\n\n\t\tif ( this.source !== null ) {\n\n\t\t\tthis.source.stop( this.context.currentTime + delay );\n\t\t\tthis.source.onended = null;\n\n\t\t}\n\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t}\n\n\tconnect() {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\tfor ( let i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t}\n\n\t\tthis._connected = true;\n\n\t\treturn this;\n\n\t}\n\n\tdisconnect() {\n\n\t\tif ( this._connected === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\tfor ( let i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t}\n\n\t\tthis._connected = false;\n\n\t\treturn this;\n\n\t}\n\n\tgetFilters() {\n\n\t\treturn this.filters;\n\n\t}\n\n\tsetFilters( value ) {\n\n\t\tif ( ! value ) value = [];\n\n\t\tif ( this._connected === true ) {\n\n\t\t\tthis.disconnect();\n\t\t\tthis.filters = value.slice();\n\t\t\tthis.connect();\n\n\t\t} else {\n\n\t\t\tthis.filters = value.slice();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetDetune( value ) {\n\n\t\tthis.detune = value;\n\n\t\tif ( this.isPlaying === true && this.source.detune !== undefined ) {\n\n\t\t\tthis.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetDetune() {\n\n\t\treturn this.detune;\n\n\t}\n\n\tgetFilter() {\n\n\t\treturn this.getFilters()[ 0 ];\n\n\t}\n\n\tsetFilter( filter ) {\n\n\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t}\n\n\tsetPlaybackRate( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.playbackRate = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetPlaybackRate() {\n\n\t\treturn this.playbackRate;\n\n\t}\n\n\tonEnded() {\n\n\t\tthis.isPlaying = false;\n\t\tthis._progress = 0;\n\n\t}\n\n\tgetLoop() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.loop;\n\n\t}\n\n\tsetLoop( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.loop = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.loop = this.loop;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetLoopStart( value ) {\n\n\t\tthis.loopStart = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoopEnd( value ) {\n\n\t\tthis.loopEnd = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetVolume() {\n\n\t\treturn this.gain.gain.value;\n\n\t}\n\n\tsetVolume( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.sourceType !== 'buffer' ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio source type cannot be copied.' );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.autoplay = source.autoplay;\n\n\t\tthis.buffer = source.buffer;\n\t\tthis.detune = source.detune;\n\t\tthis.loop = source.loop;\n\t\tthis.loopStart = source.loopStart;\n\t\tthis.loopEnd = source.loopEnd;\n\t\tthis.offset = source.offset;\n\t\tthis.duration = source.duration;\n\t\tthis.playbackRate = source.playbackRate;\n\t\tthis.hasPlaybackControl = source.hasPlaybackControl;\n\t\tthis.sourceType = source.sourceType;\n\n\t\tthis.filters = source.filters.slice();\n\n\t\treturn this;\n\n\t}\n\n\tclone( recursive ) {\n\n\t\treturn new this.constructor( this.listener ).copy( this, recursive );\n\n\t}\n\n}\n\nconst _position = /*@__PURE__*/ new Vector3();\nconst _quaternion = /*@__PURE__*/ new Quaternion();\nconst _scale = /*@__PURE__*/ new Vector3();\nconst _orientation = /*@__PURE__*/ new Vector3();\n\nclass PositionalAudio extends Audio {\n\n\tconstructor( listener ) {\n\n\t\tsuper( listener );\n\n\t\tthis.panner = this.context.createPanner();\n\t\tthis.panner.panningModel = 'HRTF';\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tconnect() {\n\n\t\tsuper.connect();\n\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tdisconnect() {\n\n\t\tsuper.disconnect();\n\n\t\tthis.panner.disconnect( this.gain );\n\n\t}\n\n\tgetOutput() {\n\n\t\treturn this.panner;\n\n\t}\n\n\tgetRefDistance() {\n\n\t\treturn this.panner.refDistance;\n\n\t}\n\n\tsetRefDistance( value ) {\n\n\t\tthis.panner.refDistance = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetRolloffFactor() {\n\n\t\treturn this.panner.rolloffFactor;\n\n\t}\n\n\tsetRolloffFactor( value ) {\n\n\t\tthis.panner.rolloffFactor = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetDistanceModel() {\n\n\t\treturn this.panner.distanceModel;\n\n\t}\n\n\tsetDistanceModel( value ) {\n\n\t\tthis.panner.distanceModel = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetMaxDistance() {\n\n\t\treturn this.panner.maxDistance;\n\n\t}\n\n\tsetMaxDistance( value ) {\n\n\t\tthis.panner.maxDistance = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {\n\n\t\tthis.panner.coneInnerAngle = coneInnerAngle;\n\t\tthis.panner.coneOuterAngle = coneOuterAngle;\n\t\tthis.panner.coneOuterGain = coneOuterGain;\n\n\t\treturn this;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.hasPlaybackControl === true && this.isPlaying === false ) return;\n\n\t\tthis.matrixWorld.decompose( _position, _quaternion, _scale );\n\n\t\t_orientation.set( 0, 0, 1 ).applyQuaternion( _quaternion );\n\n\t\tconst panner = this.panner;\n\n\t\tif ( panner.positionX ) {\n\n\t\t\t// code path for Chrome and Firefox (see #14393)\n\n\t\t\tconst endTime = this.context.currentTime + this.listener.timeDelta;\n\n\t\t\tpanner.positionX.linearRampToValueAtTime( _position.x, endTime );\n\t\t\tpanner.positionY.linearRampToValueAtTime( _position.y, endTime );\n\t\t\tpanner.positionZ.linearRampToValueAtTime( _position.z, endTime );\n\t\t\tpanner.orientationX.linearRampToValueAtTime( _orientation.x, endTime );\n\t\t\tpanner.orientationY.linearRampToValueAtTime( _orientation.y, endTime );\n\t\t\tpanner.orientationZ.linearRampToValueAtTime( _orientation.z, endTime );\n\n\t\t} else {\n\n\t\t\tpanner.setPosition( _position.x, _position.y, _position.z );\n\t\t\tpanner.setOrientation( _orientation.x, _orientation.y, _orientation.z );\n\n\t\t}\n\n\t}\n\n}\n\nclass AudioAnalyser {\n\n\tconstructor( audio, fftSize = 2048 ) {\n\n\t\tthis.analyser = audio.context.createAnalyser();\n\t\tthis.analyser.fftSize = fftSize;\n\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\t\taudio.getOutput().connect( this.analyser );\n\n\t}\n\n\n\tgetFrequencyData() {\n\n\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\treturn this.data;\n\n\t}\n\n\tgetAverageFrequency() {\n\n\t\tlet value = 0;\n\t\tconst data = this.getFrequencyData();\n\n\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\tvalue += data[ i ];\n\n\t\t}\n\n\t\treturn value / data.length;\n\n\t}\n\n}\n\nclass PropertyMixer {\n\n\tconstructor( binding, typeName, valueSize ) {\n\n\t\tthis.binding = binding;\n\t\tthis.valueSize = valueSize;\n\n\t\tlet mixFunction,\n\t\t\tmixFunctionAdditive,\n\t\t\tsetIdentity;\n\n\t\t// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\t\t//\n\t\t// 'add' is used for additive cumulative results\n\t\t//\n\t\t// 'work' is optional and is only present for quaternion types. It is used\n\t\t// to store intermediate quaternion multiplication results\n\n\t\tswitch ( typeName ) {\n\n\t\t\tcase 'quaternion':\n\t\t\t\tmixFunction = this._slerp;\n\t\t\t\tmixFunctionAdditive = this._slerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityQuaternion;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 6 );\n\t\t\t\tthis._workIndex = 5;\n\t\t\t\tbreak;\n\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\t\t\t\tmixFunction = this._select;\n\n\t\t\t\t// Use the regular mix function and for additive on these types,\n\t\t\t\t// additive is not relevant for non-numeric types\n\t\t\t\tmixFunctionAdditive = this._select;\n\n\t\t\t\tsetIdentity = this._setAdditiveIdentityOther;\n\n\t\t\t\tthis.buffer = new Array( valueSize * 5 );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tmixFunction = this._lerp;\n\t\t\t\tmixFunctionAdditive = this._lerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityNumeric;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 5 );\n\n\t\t}\n\n\t\tthis._mixBufferRegion = mixFunction;\n\t\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\n\t\tthis._setIdentity = setIdentity;\n\t\tthis._origIndex = 3;\n\t\tthis._addIndex = 4;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tthis.useCount = 0;\n\t\tthis.referenceCount = 0;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride;\n\n\t\tlet currentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tconst mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'add'\n\taccumulateAdditive( weight ) {\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = stride * this._addIndex;\n\n\t\tif ( this.cumulativeWeightAdditive === 0 ) {\n\n\t\t\t// add = identity\n\n\t\t\tthis._setIdentity();\n\n\t\t}\n\n\t\t// add := add + incoming * weight\n\n\t\tthis._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );\n\t\tthis.cumulativeWeightAdditive += weight;\n\n\t}\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply( accuIndex ) {\n\n\t\tconst stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\t\t\tweightAdditive = this.cumulativeWeightAdditive,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tconst originalValueOffset = stride * this._origIndex;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tif ( weightAdditive > 0 ) {\n\n\t\t\t// accuN := accuN + additive accuN\n\n\t\t\tthis._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );\n\n\t\t}\n\n\t\tfor ( let i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState() {\n\n\t\tconst binding = this.binding;\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * this._origIndex;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\t// Add to identity for additive\n\t\tthis._setIdentity();\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t}\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState() {\n\n\t\tconst originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t}\n\n\t_setAdditiveIdentityNumeric() {\n\n\t\tconst startIndex = this._addIndex * this.valueSize;\n\t\tconst endIndex = startIndex + this.valueSize;\n\n\t\tfor ( let i = startIndex; i < endIndex; i ++ ) {\n\n\t\t\tthis.buffer[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\t_setAdditiveIdentityQuaternion() {\n\n\t\tthis._setAdditiveIdentityNumeric();\n\t\tthis.buffer[ this._addIndex * this.valueSize + 3 ] = 1;\n\n\t}\n\n\t_setAdditiveIdentityOther() {\n\n\t\tconst startIndex = this._origIndex * this.valueSize;\n\t\tconst targetIndex = this._addIndex * this.valueSize;\n\n\t\tfor ( let i = 0; i < this.valueSize; i ++ ) {\n\n\t\t\tthis.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];\n\n\t\t}\n\n\t}\n\n\n\t// mix functions\n\n\t_select( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_slerp( buffer, dstOffset, srcOffset, t ) {\n\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n\t}\n\n\t_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst workOffset = this._workIndex * stride;\n\n\t\t// Store result in intermediate buffer offset\n\t\tQuaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );\n\n\t\t// Slerp to the intermediate result\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );\n\n\t}\n\n\t_lerp( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst s = 1 - t;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n\t_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n}\n\n// Characters [].:/ are reserved for track binding syntax.\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\nconst _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );\n\n// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\n\n// Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\nconst _directoryRe = /*@__PURE__*/ /((?:WC+[\\/:])*)/.source.replace( 'WC', _wordChar );\n\n// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\nconst _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );\n\n// Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\nconst _objectRe = /*@__PURE__*/ /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', _wordChar );\n\n// Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\nconst _propertyRe = /*@__PURE__*/ /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', _wordChar );\n\nconst _trackRe = new RegExp( ''\n\t+ '^'\n\t+ _directoryRe\n\t+ _nodeRe\n\t+ _objectRe\n\t+ _propertyRe\n\t+ '$'\n);\n\nconst _supportedObjectNames = [ 'material', 'materials', 'bones', 'map' ];\n\nclass Composite {\n\n\tconstructor( targetGroup, path, optionalParsedPath ) {\n\n\t\tconst parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis._targetGroup = targetGroup;\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n\t}\n\n\tgetValue( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tconst firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t}\n\n\tsetValue( array, offset ) {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t}\n\n\tbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t}\n\n\tunbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n}\n\n// Note: This class uses a State pattern on a per-method basis:\n// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n// prototype version of these methods with one that represents\n// the bound state. When the property is not found, the methods\n// become no-ops.\nclass PropertyBinding {\n\n\tconstructor( rootNode, path, parsedPath ) {\n\n\t\tthis.path = path;\n\t\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName );\n\n\t\tthis.rootNode = rootNode;\n\n\t\t// initial state of these methods that calls 'bind'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n\n\tstatic create( root, path, parsedPath ) {\n\n\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Replaces spaces with underscores and removes unsupported characters from\n\t * node names, to ensure compatibility with parseTrackName().\n\t *\n\t * @param {string} name Node name to be sanitized.\n\t * @return {string}\n\t */\n\tstatic sanitizeNodeName( name ) {\n\n\t\treturn name.replace( /\\s/g, '_' ).replace( _reservedRe, '' );\n\n\t}\n\n\tstatic parseTrackName( trackName ) {\n\n\t\tconst matches = _trackRe.exec( trackName );\n\n\t\tif ( matches === null ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\n\n\t\t}\n\n\t\tconst results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 2 ],\n\t\t\tobjectName: matches[ 3 ],\n\t\t\tobjectIndex: matches[ 4 ],\n\t\t\tpropertyName: matches[ 5 ], // required\n\t\t\tpropertyIndex: matches[ 6 ]\n\t\t};\n\n\t\tconst lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\n\n\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\n\n\t\t\tconst objectName = results.nodeName.substring( lastDot + 1 );\n\n\t\t\t// Object names must be checked against an allowlist. Otherwise, there\n\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t// include '.' characters).\n\t\t\tif ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {\n\n\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\n\t\t\t\tresults.objectName = objectName;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\n\n\t\t}\n\n\t\treturn results;\n\n\t}\n\n\tstatic findNode( root, nodeName ) {\n\n\t\tif ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tconst bone = root.skeleton.getBoneByName( nodeName );\n\n\t\t\tif ( bone !== undefined ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tconst searchNodeSubtree = function ( children ) {\n\n\t\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tconst childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tconst subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable() {}\n\t_setValue_unavailable() {}\n\n\t// Getters\n\n\t_getValue_direct( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.targetObject[ this.propertyName ];\n\n\t}\n\n\t_getValue_array( buffer, offset ) {\n\n\t\tconst source = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t}\n\n\t}\n\n\t_getValue_arrayElement( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t}\n\n\t_getValue_toArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t}\n\n\t// Direct\n\n\t_setValue_direct( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// EntireArray\n\n\t_setValue_array( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t}\n\n\t_setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// ArrayElement\n\n\t_setValue_arrayElement( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// HasToFromArray\n\n\t_setValue_fromArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t}\n\n\t_setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t_getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t}\n\n\t_setValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t}\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind() {\n\n\t\tlet targetObject = this.node;\n\t\tconst parsedPath = this.parsedPath;\n\n\t\tconst objectName = parsedPath.objectName;\n\t\tconst propertyName = parsedPath.propertyName;\n\t\tlet propertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName );\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n\t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.warn( 'THREE.PropertyBinding: No target node found for track: ' + this.path + '.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tlet objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( let i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map':\n\n\t\t\t\t\tif ( 'map' in targetObject ) {\n\n\t\t\t\t\t\ttargetObject = targetObject.map;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.map ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.map;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tconst nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tconst nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\n\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tlet versioning = this.Versioning.None;\n\n\t\tthis.targetObject = targetObject;\n\n\t\tif ( targetObject.isMaterial === true ) {\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\n\t\t} else if ( targetObject.isObject3D === true ) {\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tlet bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === 'morphTargetInfluences' ) {\n\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {\n\n\t\t\t\t\tpropertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( Array.isArray( nodeProperty ) ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t}\n\n\tunbind() {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n}\n\nPropertyBinding.Composite = Composite;\n\nPropertyBinding.prototype.BindingType = {\n\tDirect: 0,\n\tEntireArray: 1,\n\tArrayElement: 2,\n\tHasFromToArray: 3\n};\n\nPropertyBinding.prototype.Versioning = {\n\tNone: 0,\n\tNeedsUpdate: 1,\n\tMatrixWorldNeedsUpdate: 2\n};\n\nPropertyBinding.prototype.GetterByBindingType = [\n\n\tPropertyBinding.prototype._getValue_direct,\n\tPropertyBinding.prototype._getValue_array,\n\tPropertyBinding.prototype._getValue_arrayElement,\n\tPropertyBinding.prototype._getValue_toArray,\n\n];\n\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [\n\n\t[\n\t\t// Direct\n\t\tPropertyBinding.prototype._setValue_direct,\n\t\tPropertyBinding.prototype._setValue_direct_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// EntireArray\n\n\t\tPropertyBinding.prototype._setValue_array,\n\t\tPropertyBinding.prototype._setValue_array_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// ArrayElement\n\t\tPropertyBinding.prototype._setValue_arrayElement,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// HasToFromArray\n\t\tPropertyBinding.prototype._setValue_fromArray,\n\t\tPropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,\n\n\t]\n\n];\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n *  - Add objects you would otherwise pass as 'root' to the\n *    constructor or the .clipAction method of AnimationMixer.\n *\n *  - Instead pass this object as 'root'.\n *\n *  - You can also add and remove objects later when the mixer\n *    is running.\n *\n * Note:\n *\n *    Objects of this class appear as one object to the mixer,\n *    so cache control of the individual objects must be done\n *    on the group.\n *\n * Limitation:\n *\n *  - The animated properties must be compatible among the\n *    all objects in the group.\n *\n *  - A single property can either be controlled through a\n *    target group or directly, but not both.\n */\n\nclass AnimationObjectGroup {\n\n\tconstructor() {\n\n\t\tthis.isAnimationObjectGroup = true;\n\n\t\tthis.uuid = generateUUID();\n\n\t\t// cached objects followed by the active ones\n\t\tthis._objects = Array.prototype.slice.call( arguments );\n\n\t\tthis.nCachedObjects_ = 0; // threshold\n\t\t// note: read by PropertyBinding.Composite\n\n\t\tconst indices = {};\n\t\tthis._indicesByUUID = indices; // for bookkeeping\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t\t}\n\n\t\tthis._paths = []; // inside: string\n\t\tthis._parsedPaths = []; // inside: { we don't care, here }\n\t\tthis._bindings = []; // inside: Array< PropertyBinding >\n\t\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tobjects: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._objects.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn this.total - scope.nCachedObjects_;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tget bindingsPerObject() {\n\n\t\t\t\treturn scope._bindings.length;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tadd() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet knownObject = undefined,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid;\n\t\t\tlet index = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tknownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ];\n\n\t\t\t\t\tlet binding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject ) {\n\n\t\t\t\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\n\t\t\t\t\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\tremove() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tconst lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// remove & forget\n\tuncache() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_,\n\t\t\tnObjects = objects.length;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tconst lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tif ( lastIndex > 0 ) {\n\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_( path, parsedPath ) {\n\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath;\n\t\tlet index = indicesByPath[ path ];\n\t\tconst bindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tconst paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\n\n\t\t\tconst object = objects[ i ];\n\t\t\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t}\n\n\tunsubscribe_( path ) {\n\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n}\n\nclass AnimationAction {\n\n\tconstructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {\n\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot;\n\t\tthis.blendMode = blendMode;\n\n\t\tconst tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\n\t\tconst interpolantSettings = {\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t};\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\n\t\t}\n\n\t\tthis._interpolantSettings = interpolantSettings;\n\n\t\tthis._interpolants = interpolants; // bound by the mixer\n\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\n\t\tthis._cacheIndex = null; // for the memory manager\n\t\tthis._byClipCacheIndex = null; // for the memory manager\n\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\n\t\tthis.loop = LoopRepeat;\n\t\tthis._loopCount = - 1;\n\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\n\t\tthis.repetitions = Infinity; // no. of repetitions when looping\n\n\t\tthis.paused = false; // true -> zero effective time scale\n\t\tthis.enabled = true; // false -> zero effective weight\n\n\t\tthis.clampWhenFinished = false;// keep feeding the last frame?\n\n\t\tthis.zeroSlopeAtStart = true;// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd = true;// clips for start, loop and end\n\n\t}\n\n\t// State & Scheduling\n\n\tplay() {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t}\n\n\tstop() {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t}\n\n\treset() {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0; // restart clip\n\t\tthis._loopCount = - 1;// forget previous loops\n\t\tthis._startTime = null;// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t}\n\n\tisRunning() {\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t}\n\n\t// return true when play has been called\n\tisScheduled() {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t}\n\n\tstartAt( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoop( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t}\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t}\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight() {\n\n\t\treturn this._effectiveWeight;\n\n\t}\n\n\tfadeIn( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t}\n\n\tfadeOut( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t}\n\n\tcrossFadeFrom( fadeOutAction, duration, warp ) {\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif ( warp ) {\n\n\t\t\tconst fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcrossFadeTo( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t}\n\n\tstopFading() {\n\n\t\tconst weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Time Scale Control\n\n\t// set the time scale stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale() {\n\n\t\treturn this._effectiveTimeScale;\n\n\t}\n\n\tsetDuration( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\tsyncWith( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\thalt( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t}\n\n\twarp( startTimeScale, endTimeScale, duration ) {\n\n\t\tconst mixer = this._mixer,\n\t\t\tnow = mixer.time,\n\t\t\ttimeScale = this.timeScale;\n\n\t\tlet interpolant = this._timeScaleInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t}\n\n\tstopWarping() {\n\n\t\tconst timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Object Accessors\n\n\tgetMixer() {\n\n\t\treturn this._mixer;\n\n\t}\n\n\tgetClip() {\n\n\t\treturn this._clip;\n\n\t}\n\n\tgetRoot() {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t}\n\n\t// Interna\n\n\t_update( time, deltaTime, timeDirection, accuIndex ) {\n\n\t\t// called by the mixer\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\n\t\t\tthis._updateWeight( time );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tconst timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\tdeltaTime = 0;\n\n\t\t\t} else {\n\n\n\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tconst clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tconst weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tconst interpolants = this._interpolants;\n\t\t\tconst propertyMixers = this._propertyBindings;\n\n\t\t\tswitch ( this.blendMode ) {\n\n\t\t\t\tcase AdditiveAnimationBlendMode:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulateAdditive( weight );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NormalAnimationBlendMode:\n\t\t\t\tdefault:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateWeight( time ) {\n\n\t\tlet weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tconst interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t}\n\n\t_updateTimeScale( time ) {\n\n\t\tlet timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tconst interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t}\n\n\t_updateTime( deltaTime ) {\n\n\t\tconst duration = this._clip.duration;\n\t\tconst loop = this.loop;\n\n\t\tlet time = this.time + deltaTime;\n\t\tlet loopCount = this._loopCount;\n\n\t\tconst pingPong = ( loop === LoopPingPong );\n\n\t\tif ( deltaTime === 0 ) {\n\n\t\t\tif ( loopCount === - 1 ) return time;\n\n\t\t\treturn ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;\n\n\t\t}\n\n\t\tif ( loop === LoopOnce ) {\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tthis._loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tbreak handle_stop;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis.time = time;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? - 1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings( true, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings( this.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\n\t\t\t\t// wrap around\n\n\t\t\t\tconst loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tconst pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending <= 0 ) {\n\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : - 1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 1 ) {\n\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tconst atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.time = time;\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn time;\n\n\t}\n\n\t_setEndings( atStart, atEnd, pingPong ) {\n\n\t\tconst settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart = ZeroSlopeEnding;\n\t\t\tsettings.endingEnd = ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_scheduleFading( duration, weightNow, weightThen ) {\n\n\t\tconst mixer = this._mixer, now = mixer.time;\n\t\tlet interpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\n\t\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _controlInterpolantsResultBuffer = new Float32Array( 1 );\n\n\nclass AnimationMixer extends EventDispatcher {\n\n\tconstructor( root ) {\n\n\t\tsuper();\n\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\t\tthis.time = 0;\n\t\tthis.timeScale = 1.0;\n\n\t}\n\n\t_bindAction( action, prototypeAction ) {\n\n\t\tconst root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName;\n\n\t\tlet bindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst track = tracks[ i ],\n\t\t\t\ttrackName = track.name;\n\n\t\t\tlet binding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tconst path = prototypeAction && prototypeAction.\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t}\n\n\t_activateAction( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tconst rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t}\n\n\t_deactivateAction( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t}\n\n\t// Memory manager\n\n\t_initMemoryManager() {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._actions.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveActions;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._bindings.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveBindings;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._controlInterpolants.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t// Memory management for AnimationAction objects\n\n\t_isActiveAction( action ) {\n\n\t\tconst index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t}\n\n\t_addInactiveAction( action, clipUuid, rootUuid ) {\n\n\t\tconst actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tlet actionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tconst knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t}\n\n\t_removeInactiveAction( action ) {\n\n\t\tconst actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tconst clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tconst actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t}\n\n\t_removeInactiveBindingsForAction( action ) {\n\n\t\tconst bindings = action._propertyBindings;\n\n\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tconst binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_lendAction( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t}\n\n\t_takeBackAction( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t}\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding( binding, rootUuid, trackName ) {\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindings = this._bindings;\n\n\t\tlet bindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t}\n\n\t_removeInactiveBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tif ( Object.keys( bindingByName ).length === 0 ) {\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t}\n\n\t_lendBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t}\n\n\t_takeBackBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t}\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant() {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++;\n\n\t\tlet interpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t1, _controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t}\n\n\t_takeBackControlInterpolant( interpolant ) {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t}\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction( clip, optionalRoot, blendMode ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid;\n\n\t\tlet clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;\n\n\t\tconst clipUuid = clipObject !== null ? clipObject.uuid : clip;\n\n\t\tconst actionsForClip = this._actionsByClip[ clipUuid ];\n\t\tlet prototypeAction = null;\n\n\t\tif ( blendMode === undefined ) {\n\n\t\t\tif ( clipObject !== null ) {\n\n\t\t\t\tblendMode = clipObject.blendMode;\n\n\t\t\t} else {\n\n\t\t\t\tblendMode = NormalAnimationBlendMode;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tconst existingAction = actionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined && existingAction.blendMode === blendMode ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tconst newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t}\n\n\t// get an existing action\n\texistingAction( clip, optionalRoot ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction() {\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions;\n\n\t\tfor ( let i = nActions - 1; i >= 0; -- i ) {\n\n\t\t\tactions[ i ].stop();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// advance the time and update apply the animation\n\tupdate( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( let i = 0; i !== nActions; ++ i ) {\n\n\t\t\tconst action = actions[ i ];\n\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tconst bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( let i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Allows you to seek to a specific time in an animation.\n\tsetTime( timeInSeconds ) {\n\n\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\n\t\tfor ( let i = 0; i < this._actions.length; i ++ ) {\n\n\t\t\tthis._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n\n\t\t}\n\n\t\treturn this.update( timeInSeconds ); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n\n\t}\n\n\t// return this mixer's root target object\n\tgetRoot() {\n\n\t\treturn this._root;\n\n\t}\n\n\t// free all resources specific to a particular clip\n\tuncacheClip( clip ) {\n\n\t\tconst actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tconst actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tconst action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tconst cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t}\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot( root ) {\n\n\t\tconst rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( const clipUuid in actionsByClip ) {\n\n\t\t\tconst actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( const trackName in bindingByName ) {\n\n\t\t\t\tconst binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remove a targeted clip from the cache\n\tuncacheAction( clip, optionalRoot ) {\n\n\t\tconst action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n}\n\nclass RenderTarget3D extends RenderTarget {\n\n\tconstructor( width = 1, height = 1, depth = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.isRenderTarget3D = true;\n\n\t\tthis.depth = depth;\n\n\t\tthis.texture = new Data3DTexture( null, width, height, depth );\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t}\n\n}\n\nclass RenderTargetArray extends RenderTarget {\n\n\tconstructor( width = 1, height = 1, depth = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.isRenderTargetArray = true;\n\n\t\tthis.depth = depth;\n\n\t\tthis.texture = new DataArrayTexture( null, width, height, depth );\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t}\n\n}\n\nclass Uniform {\n\n\tconstructor( value ) {\n\n\t\tthis.value = value;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\n\n\t}\n\n}\n\nlet _id = 0;\n\nclass UniformsGroup extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isUniformsGroup = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\tthis.name = '';\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.uniforms = [];\n\n\t}\n\n\tadd( uniform ) {\n\n\t\tthis.uniforms.push( uniform );\n\n\t\treturn this;\n\n\t}\n\n\tremove( uniform ) {\n\n\t\tconst index = this.uniforms.indexOf( uniform );\n\n\t\tif ( index !== - 1 ) this.uniforms.splice( index, 1 );\n\n\t\treturn this;\n\n\t}\n\n\tsetName( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\t\tthis.usage = source.usage;\n\n\t\tconst uniformsSource = source.uniforms;\n\n\t\tthis.uniforms.length = 0;\n\n\t\tfor ( let i = 0, l = uniformsSource.length; i < l; i ++ ) {\n\n\t\t\tconst uniforms = Array.isArray( uniformsSource[ i ] ) ? uniformsSource[ i ] : [ uniformsSource[ i ] ];\n\n\t\t\tfor ( let j = 0; j < uniforms.length; j ++ ) {\n\n\t\t\t\tthis.uniforms.push( uniforms[ j ].clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass InstancedInterleavedBuffer extends InterleavedBuffer {\n\n\tconstructor( array, stride, meshPerAttribute = 1 ) {\n\n\t\tsuper( array, stride );\n\n\t\tthis.isInstancedInterleavedBuffer = true;\n\n\t\tthis.meshPerAttribute = meshPerAttribute;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tconst ib = super.clone( data );\n\n\t\tib.meshPerAttribute = this.meshPerAttribute;\n\n\t\treturn ib;\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tconst json = super.toJSON( data );\n\n\t\tjson.isInstancedInterleavedBuffer = true;\n\t\tjson.meshPerAttribute = this.meshPerAttribute;\n\n\t\treturn json;\n\n\t}\n\n}\n\nclass GLBufferAttribute {\n\n\tconstructor( buffer, type, itemSize, elementSize, count ) {\n\n\t\tthis.isGLBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.buffer = buffer;\n\t\tthis.type = type;\n\t\tthis.itemSize = itemSize;\n\t\tthis.elementSize = elementSize;\n\t\tthis.count = count;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tsetBuffer( buffer ) {\n\n\t\tthis.buffer = buffer;\n\n\t\treturn this;\n\n\t}\n\n\tsetType( type, elementSize ) {\n\n\t\tthis.type = type;\n\t\tthis.elementSize = elementSize;\n\n\t\treturn this;\n\n\t}\n\n\tsetItemSize( itemSize ) {\n\n\t\tthis.itemSize = itemSize;\n\n\t\treturn this;\n\n\t}\n\n\tsetCount( count ) {\n\n\t\tthis.count = count;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _matrix = /*@__PURE__*/ new Matrix4();\n\nclass Raycaster {\n\n\tconstructor( origin, direction, near = 0, far = Infinity ) {\n\n\t\tthis.ray = new Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\t\tthis.camera = null;\n\t\tthis.layers = new Layers();\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: { threshold: 1 },\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.ray.set( origin, direction );\n\n\t}\n\n\tsetFromCamera( coords, camera ) {\n\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\t\tthis.camera = camera;\n\n\t\t} else if ( camera.isOrthographicCamera ) {\n\n\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\tthis.camera = camera;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );\n\n\t\t}\n\n\t}\n\n\tsetFromXRController( controller ) {\n\n\t\t_matrix.identity().extractRotation( controller.matrixWorld );\n\n\t\tthis.ray.origin.setFromMatrixPosition( controller.matrixWorld );\n\t\tthis.ray.direction.set( 0, 0, - 1 ).applyMatrix4( _matrix );\n\n\t\treturn this;\n\n\t}\n\n\tintersectObject( object, recursive = true, intersects = [] ) {\n\n\t\tintersect( object, this, intersects, recursive );\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n\tintersectObjects( objects, recursive = true, intersects = [] ) {\n\n\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tintersect( objects[ i ], this, intersects, recursive );\n\n\t\t}\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n}\n\nfunction ascSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersect( object, raycaster, intersects, recursive ) {\n\n\tlet propagate = true;\n\n\tif ( object.layers.test( raycaster.layers ) ) {\n\n\t\tconst result = object.raycast( raycaster, intersects );\n\n\t\tif ( result === false ) propagate = false;\n\n\t}\n\n\tif ( propagate === true && recursive === true ) {\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tintersect( children[ i ], raycaster, intersects, true );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * phi (the polar angle) is measured from the positive y-axis. The positive y-axis is up.\n * theta (the azimuthal angle) is measured from the positive z-axis.\n */\nclass Spherical {\n\n\tconstructor( radius = 1, phi = 0, theta = 0 ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi; // polar angle\n\t\tthis.theta = theta; // azimuthal angle\n\n\t\treturn this;\n\n\t}\n\n\tset( radius, phi, theta ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi;\n\t\tthis.theta = theta;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.phi = other.phi;\n\t\tthis.theta = other.theta;\n\n\t\treturn this;\n\n\t}\n\n\t// restrict phi to be between EPS and PI-EPS\n\tmakeSafe() {\n\n\t\tconst EPS = 0.000001;\n\t\tthis.phi = clamp( this.phi, EPS, Math.PI - EPS );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t}\n\n\tsetFromCartesianCoords( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + y * y + z * z );\n\n\t\tif ( this.radius === 0 ) {\n\n\t\t\tthis.theta = 0;\n\t\t\tthis.phi = 0;\n\n\t\t} else {\n\n\t\t\tthis.theta = Math.atan2( x, z );\n\t\t\tthis.phi = Math.acos( clamp( y / this.radius, - 1, 1 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n */\n\nclass Cylindrical {\n\n\tconstructor( radius = 1, theta = 0, y = 0 ) {\n\n\t\tthis.radius = radius; // distance from the origin to a point in the x-z plane\n\t\tthis.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\n\t\tthis.y = y; // height above the x-z plane\n\n\t\treturn this;\n\n\t}\n\n\tset( radius, theta, y ) {\n\n\t\tthis.radius = radius;\n\t\tthis.theta = theta;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.theta = other.theta;\n\t\tthis.y = other.y;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t}\n\n\tsetFromCartesianCoords( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + z * z );\n\t\tthis.theta = Math.atan2( x, z );\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass Matrix2 {\n\n\tconstructor( n11, n12, n21, n22 ) {\n\n\t\tMatrix2.prototype.isMatrix2 = true;\n\n\t\tthis.elements = [\n\t\t\t1, 0,\n\t\t\t0, 1,\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n21, n22 );\n\n\t\t}\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\t\t\t1, 0,\n\t\t\t0, 1,\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tset( n11, n12, n21, n22 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 2 ] = n12;\n\t\tte[ 1 ] = n21; te[ 3 ] = n22;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _vector$4 = /*@__PURE__*/ new Vector2();\n\nclass Box2 {\n\n\tconstructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {\n\n\t\tthis.isBox2 = true;\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector$4.copy( size ).multiplyScalar( 0.5 );\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = + Infinity;\n\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn point.x >= this.min.x && point.x <= this.max.x &&\n\t\t\tpoint.y >= this.min.y && point.y <= this.max.y;\n\n\t}\n\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y;\n\n\t}\n\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\t// using 4 splitting planes to rule out intersections\n\n\t\treturn box.max.x >= this.min.x && box.min.x <= this.max.x &&\n\t\t\tbox.max.y >= this.min.y && box.min.y <= this.max.y;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _vector$4 ).distanceTo( point );\n\n\t}\n\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t}\n\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n}\n\nconst _startP = /*@__PURE__*/ new Vector3();\nconst _startEnd = /*@__PURE__*/ new Vector3();\n\nclass Line3 {\n\n\tconstructor( start = new Vector3(), end = new Vector3() ) {\n\n\t\tthis.start = start;\n\t\tthis.end = end;\n\n\t}\n\n\tset( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t}\n\n\tdelta( target ) {\n\n\t\treturn target.subVectors( this.end, this.start );\n\n\t}\n\n\tdistanceSq() {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t}\n\n\tdistance() {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t}\n\n\tat( t, target ) {\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t}\n\n\tclosestPointToPointParameter( point, clampToLine ) {\n\n\t\t_startP.subVectors( point, this.start );\n\t\t_startEnd.subVectors( this.end, this.start );\n\n\t\tconst startEnd2 = _startEnd.dot( _startEnd );\n\t\tconst startEnd_startP = _startEnd.dot( _startP );\n\n\t\tlet t = startEnd_startP / startEnd2;\n\n\t\tif ( clampToLine ) {\n\n\t\t\tt = clamp( t, 0, 1 );\n\n\t\t}\n\n\t\treturn t;\n\n\t}\n\n\tclosestPointToPoint( point, clampToLine, target ) {\n\n\t\tconst t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t}\n\n\tequals( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$3 = /*@__PURE__*/ new Vector3();\n\nclass SpotLightHelper extends Object3D {\n\n\tconstructor( light, color ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'SpotLightHelper';\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst positions = [\n\t\t\t0, 0, 0, \t0, 0, 1,\n\t\t\t0, 0, 0, \t1, 0, 1,\n\t\t\t0, 0, 0,\t- 1, 0, 1,\n\t\t\t0, 0, 0, \t0, 1, 1,\n\t\t\t0, 0, 0, \t0, - 1, 1\n\t\t];\n\n\t\tfor ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\t\tconst p1 = ( i / l ) * Math.PI * 2;\n\t\t\tconst p2 = ( j / l ) * Math.PI * 2;\n\n\t\t\tpositions.push(\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t);\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { fog: false, toneMapped: false } );\n\n\t\tthis.cone = new LineSegments( geometry, material );\n\t\tthis.add( this.cone );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\t\tthis.light.target.updateWorldMatrix( true, false );\n\n\t\t// update the local matrix based on the parent and light target transforms\n\t\tif ( this.parent ) {\n\n\t\t\tthis.parent.updateWorldMatrix( true );\n\n\t\t\tthis.matrix\n\t\t\t\t.copy( this.parent.matrixWorld )\n\t\t\t\t.invert()\n\t\t\t\t.multiply( this.light.matrixWorld );\n\n\t\t} else {\n\n\t\t\tthis.matrix.copy( this.light.matrixWorld );\n\n\t\t}\n\n\t\tthis.matrixWorld.copy( this.light.matrixWorld );\n\n\t\tconst coneLength = this.light.distance ? this.light.distance : 1000;\n\t\tconst coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\t_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( _vector$3 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.cone.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.cone.material.color.copy( this.light.color );\n\n\t\t}\n\n\t}\n\n}\n\nconst _vector$2 = /*@__PURE__*/ new Vector3();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\nconst _matrixWorldInv = /*@__PURE__*/ new Matrix4();\n\n\nclass SkeletonHelper extends LineSegments {\n\n\tconstructor( object ) {\n\n\t\tconst bones = getBoneList( object );\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\tconst color1 = new Color( 0, 0, 1 );\n\t\tconst color2 = new Color( 0, 1, 0 );\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tcolors.push( color1.r, color1.g, color1.b );\n\t\t\t\tcolors.push( color2.r, color2.g, color2.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isSkeletonHelper = true;\n\n\t\tthis.type = 'SkeletonHelper';\n\n\t\tthis.root = object;\n\t\tthis.bones = bones;\n\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst bones = this.bones;\n\n\t\tconst geometry = this.geometry;\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t_matrixWorldInv.copy( this.root.matrixWorld ).invert();\n\n\t\tfor ( let i = 0, j = 0; i < bones.length; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );\n\t\t\t\t_vector$2.setFromMatrixPosition( _boneMatrix );\n\t\t\t\tposition.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );\n\n\t\t\t\t_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\t_vector$2.setFromMatrixPosition( _boneMatrix );\n\t\t\t\tposition.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );\n\n\t\t\t\tj += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\n\nfunction getBoneList( object ) {\n\n\tconst boneList = [];\n\n\tif ( object.isBone === true ) {\n\n\t\tboneList.push( object );\n\n\t}\n\n\tfor ( let i = 0; i < object.children.length; i ++ ) {\n\n\t\tboneList.push.apply( boneList, getBoneList( object.children[ i ] ) );\n\n\t}\n\n\treturn boneList;\n\n}\n\nclass PointLightHelper extends Mesh {\n\n\tconstructor( light, sphereSize, color ) {\n\n\t\tconst geometry = new SphereGeometry( sphereSize, 4, 2 );\n\t\tconst material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.light = light;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'PointLightHelper';\n\n\t\tthis.matrix = this.light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\n\t\t/*\n\t// TODO: delete this comment?\n\tconst distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\tconst distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tconst d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\t/*\n\t\tconst d = this.light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.visible = true;\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\t\t*/\n\n\t}\n\n}\n\nconst _vector$1 = /*@__PURE__*/ new Vector3();\nconst _color1 = /*@__PURE__*/ new Color();\nconst _color2 = /*@__PURE__*/ new Color();\n\nclass HemisphereLightHelper extends Object3D {\n\n\tconstructor( light, size, color ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'HemisphereLightHelper';\n\n\t\tconst geometry = new OctahedronGeometry( size );\n\t\tgeometry.rotateY( Math.PI * 0.5 );\n\n\t\tthis.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\n\t\tif ( this.color === undefined ) this.material.vertexColors = true;\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\t\tconst colors = new Float32Array( position.count * 3 );\n\n\t\tgeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\n\t\tthis.add( new Mesh( geometry, this.material ) );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.children[ 0 ].geometry.dispose();\n\t\tthis.children[ 0 ].material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.children[ 0 ];\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tconst colors = mesh.geometry.getAttribute( 'color' );\n\n\t\t\t_color1.copy( this.light.color );\n\t\t\t_color2.copy( this.light.groundColor );\n\n\t\t\tfor ( let i = 0, l = colors.count; i < l; i ++ ) {\n\n\t\t\t\tconst color = ( i < ( l / 2 ) ) ? _color1 : _color2;\n\n\t\t\t\tcolors.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t\tcolors.needsUpdate = true;\n\n\t\t}\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\n\t\tmesh.lookAt( _vector$1.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\n\t}\n\n}\n\nclass GridHelper extends LineSegments {\n\n\tconstructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {\n\n\t\tcolor1 = new Color( color1 );\n\t\tcolor2 = new Color( color2 );\n\n\t\tconst center = divisions / 2;\n\t\tconst step = size / divisions;\n\t\tconst halfSize = size / 2;\n\n\t\tconst vertices = [], colors = [];\n\n\t\tfor ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\n\n\t\t\tvertices.push( - halfSize, 0, k, halfSize, 0, k );\n\t\t\tvertices.push( k, 0, - halfSize, k, 0, halfSize );\n\n\t\t\tconst color = i === center ? color1 : color2;\n\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'GridHelper';\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass PolarGridHelper extends LineSegments {\n\n\tconstructor( radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {\n\n\t\tcolor1 = new Color( color1 );\n\t\tcolor2 = new Color( color2 );\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\t// create the sectors\n\n\t\tif ( sectors > 1 ) {\n\n\t\t\tfor ( let i = 0; i < sectors; i ++ ) {\n\n\t\t\t\tconst v = ( i / sectors ) * ( Math.PI * 2 );\n\n\t\t\t\tconst x = Math.sin( v ) * radius;\n\t\t\t\tconst z = Math.cos( v ) * radius;\n\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tvertices.push( x, 0, z );\n\n\t\t\t\tconst color = ( i & 1 ) ? color1 : color2;\n\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create the rings\n\n\t\tfor ( let i = 0; i < rings; i ++ ) {\n\n\t\t\tconst color = ( i & 1 ) ? color1 : color2;\n\n\t\t\tconst r = radius - ( radius / rings * i );\n\n\t\t\tfor ( let j = 0; j < divisions; j ++ ) {\n\n\t\t\t\t// first vertex\n\n\t\t\t\tlet v = ( j / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\tlet x = Math.sin( v ) * r;\n\t\t\t\tlet z = Math.cos( v ) * r;\n\n\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t// second vertex\n\n\t\t\t\tv = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\tx = Math.sin( v ) * r;\n\t\t\t\tz = Math.cos( v ) * r;\n\n\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'PolarGridHelper';\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\nconst _v3 = /*@__PURE__*/ new Vector3();\n\nclass DirectionalLightHelper extends Object3D {\n\n\tconstructor( light, size, color ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'DirectionalLightHelper';\n\n\t\tif ( size === undefined ) size = 1;\n\n\t\tlet geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [\n\t\t\t- size, size, 0,\n\t\t\tsize, size, 0,\n\t\t\tsize, - size, 0,\n\t\t\t- size, - size, 0,\n\t\t\t- size, size, 0\n\t\t], 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { fog: false, toneMapped: false } );\n\n\t\tthis.lightPlane = new Line( geometry, material );\n\t\tthis.add( this.lightPlane );\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\t\tthis.targetLine = new Line( geometry, material );\n\t\tthis.add( this.targetLine );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.lightPlane.geometry.dispose();\n\t\tthis.lightPlane.material.dispose();\n\t\tthis.targetLine.geometry.dispose();\n\t\tthis.targetLine.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\t\tthis.light.target.updateWorldMatrix( true, false );\n\n\t\t_v1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t_v2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t_v3.subVectors( _v2, _v1 );\n\n\t\tthis.lightPlane.lookAt( _v2 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.lightPlane.material.color.set( this.color );\n\t\t\tthis.targetLine.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.lightPlane.material.color.copy( this.light.color );\n\t\t\tthis.targetLine.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\tthis.targetLine.lookAt( _v2 );\n\t\tthis.targetLine.scale.z = _v3.length();\n\n\t}\n\n}\n\nconst _vector = /*@__PURE__*/ new Vector3();\nconst _camera = /*@__PURE__*/ new Camera();\n\n/**\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttps://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html\n */\n\nclass CameraHelper extends LineSegments {\n\n\tconstructor( camera ) {\n\n\t\tconst geometry = new BufferGeometry();\n\t\tconst material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\tconst pointMap = {};\n\n\t\t// near\n\n\t\taddLine( 'n1', 'n2' );\n\t\taddLine( 'n2', 'n4' );\n\t\taddLine( 'n4', 'n3' );\n\t\taddLine( 'n3', 'n1' );\n\n\t\t// far\n\n\t\taddLine( 'f1', 'f2' );\n\t\taddLine( 'f2', 'f4' );\n\t\taddLine( 'f4', 'f3' );\n\t\taddLine( 'f3', 'f1' );\n\n\t\t// sides\n\n\t\taddLine( 'n1', 'f1' );\n\t\taddLine( 'n2', 'f2' );\n\t\taddLine( 'n3', 'f3' );\n\t\taddLine( 'n4', 'f4' );\n\n\t\t// cone\n\n\t\taddLine( 'p', 'n1' );\n\t\taddLine( 'p', 'n2' );\n\t\taddLine( 'p', 'n3' );\n\t\taddLine( 'p', 'n4' );\n\n\t\t// up\n\n\t\taddLine( 'u1', 'u2' );\n\t\taddLine( 'u2', 'u3' );\n\t\taddLine( 'u3', 'u1' );\n\n\t\t// target\n\n\t\taddLine( 'c', 't' );\n\t\taddLine( 'p', 'c' );\n\n\t\t// cross\n\n\t\taddLine( 'cn1', 'cn2' );\n\t\taddLine( 'cn3', 'cn4' );\n\n\t\taddLine( 'cf1', 'cf2' );\n\t\taddLine( 'cf3', 'cf4' );\n\n\t\tfunction addLine( a, b ) {\n\n\t\t\taddPoint( a );\n\t\t\taddPoint( b );\n\n\t\t}\n\n\t\tfunction addPoint( id ) {\n\n\t\t\tvertices.push( 0, 0, 0 );\n\t\t\tcolors.push( 0, 0, 0 );\n\n\t\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\t\tpointMap[ id ] = [];\n\n\t\t\t}\n\n\t\t\tpointMap[ id ].push( ( vertices.length / 3 ) - 1 );\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'CameraHelper';\n\n\t\tthis.camera = camera;\n\t\tif ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\t\tthis.matrix = camera.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.pointMap = pointMap;\n\n\t\tthis.update();\n\n\t\t// colors\n\n\t\tconst colorFrustum = new Color( 0xffaa00 );\n\t\tconst colorCone = new Color( 0xff0000 );\n\t\tconst colorUp = new Color( 0x00aaff );\n\t\tconst colorTarget = new Color( 0xffffff );\n\t\tconst colorCross = new Color( 0x333333 );\n\n\t\tthis.setColors( colorFrustum, colorCone, colorUp, colorTarget, colorCross );\n\n\t}\n\n\tsetColors( frustum, cone, up, target, cross ) {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst colorAttribute = geometry.getAttribute( 'color' );\n\n\t\t// near\n\n\t\tcolorAttribute.setXYZ( 0, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 1, frustum.r, frustum.g, frustum.b ); // n1, n2\n\t\tcolorAttribute.setXYZ( 2, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 3, frustum.r, frustum.g, frustum.b ); // n2, n4\n\t\tcolorAttribute.setXYZ( 4, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 5, frustum.r, frustum.g, frustum.b ); // n4, n3\n\t\tcolorAttribute.setXYZ( 6, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 7, frustum.r, frustum.g, frustum.b ); // n3, n1\n\n\t\t// far\n\n\t\tcolorAttribute.setXYZ( 8, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 9, frustum.r, frustum.g, frustum.b ); // f1, f2\n\t\tcolorAttribute.setXYZ( 10, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 11, frustum.r, frustum.g, frustum.b ); // f2, f4\n\t\tcolorAttribute.setXYZ( 12, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 13, frustum.r, frustum.g, frustum.b ); // f4, f3\n\t\tcolorAttribute.setXYZ( 14, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 15, frustum.r, frustum.g, frustum.b ); // f3, f1\n\n\t\t// sides\n\n\t\tcolorAttribute.setXYZ( 16, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 17, frustum.r, frustum.g, frustum.b ); // n1, f1\n\t\tcolorAttribute.setXYZ( 18, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 19, frustum.r, frustum.g, frustum.b ); // n2, f2\n\t\tcolorAttribute.setXYZ( 20, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 21, frustum.r, frustum.g, frustum.b ); // n3, f3\n\t\tcolorAttribute.setXYZ( 22, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 23, frustum.r, frustum.g, frustum.b ); // n4, f4\n\n\t\t// cone\n\n\t\tcolorAttribute.setXYZ( 24, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 25, cone.r, cone.g, cone.b ); // p, n1\n\t\tcolorAttribute.setXYZ( 26, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 27, cone.r, cone.g, cone.b ); // p, n2\n\t\tcolorAttribute.setXYZ( 28, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 29, cone.r, cone.g, cone.b ); // p, n3\n\t\tcolorAttribute.setXYZ( 30, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 31, cone.r, cone.g, cone.b ); // p, n4\n\n\t\t// up\n\n\t\tcolorAttribute.setXYZ( 32, up.r, up.g, up.b ); colorAttribute.setXYZ( 33, up.r, up.g, up.b ); // u1, u2\n\t\tcolorAttribute.setXYZ( 34, up.r, up.g, up.b ); colorAttribute.setXYZ( 35, up.r, up.g, up.b ); // u2, u3\n\t\tcolorAttribute.setXYZ( 36, up.r, up.g, up.b ); colorAttribute.setXYZ( 37, up.r, up.g, up.b ); // u3, u1\n\n\t\t// target\n\n\t\tcolorAttribute.setXYZ( 38, target.r, target.g, target.b ); colorAttribute.setXYZ( 39, target.r, target.g, target.b ); // c, t\n\t\tcolorAttribute.setXYZ( 40, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 41, cross.r, cross.g, cross.b ); // p, c\n\n\t\t// cross\n\n\t\tcolorAttribute.setXYZ( 42, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 43, cross.r, cross.g, cross.b ); // cn1, cn2\n\t\tcolorAttribute.setXYZ( 44, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 45, cross.r, cross.g, cross.b ); // cn3, cn4\n\n\t\tcolorAttribute.setXYZ( 46, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 47, cross.r, cross.g, cross.b ); // cf1, cf2\n\t\tcolorAttribute.setXYZ( 48, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 49, cross.r, cross.g, cross.b ); // cf3, cf4\n\n\t\tcolorAttribute.needsUpdate = true;\n\n\t}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst pointMap = this.pointMap;\n\n\t\tconst w = 1, h = 1;\n\n\t\t// we need just camera projection matrix inverse\n\t\t// world matrix must be identity\n\n\t\t_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );\n\n\t\t// Adjust z values based on coordinate system\n\t\tconst nearZ = this.camera.coordinateSystem === WebGLCoordinateSystem ? - 1 : 0;\n\n\t\t// center / target\n\t\tsetPoint( 'c', pointMap, geometry, _camera, 0, 0, nearZ );\n\t\tsetPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );\n\n\t\t// near\n\n\t\tsetPoint( 'n1', pointMap, geometry, _camera, - w, - h, nearZ );\n\t\tsetPoint( 'n2', pointMap, geometry, _camera, w, - h, nearZ );\n\t\tsetPoint( 'n3', pointMap, geometry, _camera, - w, h, nearZ );\n\t\tsetPoint( 'n4', pointMap, geometry, _camera, w, h, nearZ );\n\n\t\t// far\n\n\t\tsetPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );\n\t\tsetPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );\n\t\tsetPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );\n\t\tsetPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );\n\n\t\t// up\n\n\t\tsetPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, nearZ );\n\t\tsetPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, nearZ );\n\t\tsetPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, nearZ );\n\n\t\t// cross\n\n\t\tsetPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );\n\t\tsetPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );\n\t\tsetPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );\n\t\tsetPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );\n\n\t\tsetPoint( 'cn1', pointMap, geometry, _camera, - w, 0, nearZ );\n\t\tsetPoint( 'cn2', pointMap, geometry, _camera, w, 0, nearZ );\n\t\tsetPoint( 'cn3', pointMap, geometry, _camera, 0, - h, nearZ );\n\t\tsetPoint( 'cn4', pointMap, geometry, _camera, 0, h, nearZ );\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\n\nfunction setPoint( point, pointMap, geometry, camera, x, y, z ) {\n\n\t_vector.set( x, y, z ).unproject( camera );\n\n\tconst points = pointMap[ point ];\n\n\tif ( points !== undefined ) {\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tposition.setXYZ( points[ i ], _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}\n\n}\n\nconst _box = /*@__PURE__*/ new Box3();\n\nclass BoxHelper extends LineSegments {\n\n\tconstructor( object, color = 0xffff00 ) {\n\n\t\tconst indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\tconst positions = new Float32Array( 8 * 3 );\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.object = object;\n\t\tthis.type = 'BoxHelper';\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate( object ) {\n\n\t\tif ( object !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );\n\n\t\t}\n\n\t\tif ( this.object !== undefined ) {\n\n\t\t\t_box.setFromObject( this.object );\n\n\t\t}\n\n\t\tif ( _box.isEmpty() ) return;\n\n\t\tconst min = _box.min;\n\t\tconst max = _box.max;\n\n\t\t/*\n\t\t\t5____4\n\t\t1/___0/|\n\t\t| 6__|_7\n\t\t2/___3/\n\n\t\t0: max.x, max.y, max.z\n\t\t1: min.x, max.y, max.z\n\t\t2: min.x, min.y, max.z\n\t\t3: max.x, min.y, max.z\n\t\t4: max.x, max.y, min.z\n\t\t5: min.x, max.y, min.z\n\t\t6: min.x, min.y, min.z\n\t\t7: max.x, min.y, min.z\n\t\t*/\n\n\t\tconst position = this.geometry.attributes.position;\n\t\tconst array = position.array;\n\n\t\tarray[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;\n\t\tarray[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;\n\t\tarray[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;\n\t\tarray[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\tposition.needsUpdate = true;\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t}\n\n\tsetFromObject( object ) {\n\n\t\tthis.object = object;\n\t\tthis.update();\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.object = source.object;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass Box3Helper extends LineSegments {\n\n\tconstructor( box, color = 0xffff00 ) {\n\n\t\tconst indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\n\t\tconst positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.box = box;\n\n\t\tthis.type = 'Box3Helper';\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst box = this.box;\n\n\t\tif ( box.isEmpty() ) return;\n\n\t\tbox.getCenter( this.position );\n\n\t\tbox.getSize( this.scale );\n\n\t\tthis.scale.multiplyScalar( 0.5 );\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass PlaneHelper extends Line {\n\n\tconstructor( plane, size = 1, hex = 0xffff00 ) {\n\n\t\tconst color = hex;\n\n\t\tconst positions = [ 1, - 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tgeometry.computeBoundingSphere();\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.type = 'PlaneHelper';\n\n\t\tthis.plane = plane;\n\n\t\tthis.size = size;\n\n\t\tconst positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\n\t\tconst geometry2 = new BufferGeometry();\n\t\tgeometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\n\t\tgeometry2.computeBoundingSphere();\n\n\t\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tthis.position.set( 0, 0, 0 );\n\n\t\tthis.scale.set( 0.5 * this.size, 0.5 * this.size, 1 );\n\n\t\tthis.lookAt( this.plane.normal );\n\n\t\tthis.translateZ( - this.plane.constant );\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\t\tthis.children[ 0 ].geometry.dispose();\n\t\tthis.children[ 0 ].material.dispose();\n\n\t}\n\n}\n\nconst _axis = /*@__PURE__*/ new Vector3();\nlet _lineGeometry, _coneGeometry;\n\nclass ArrowHelper extends Object3D {\n\n\t// dir is assumed to be normalized\n\n\tconstructor( dir = new Vector3( 0, 0, 1 ), origin = new Vector3( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ArrowHelper';\n\n\t\tif ( _lineGeometry === undefined ) {\n\n\t\t\t_lineGeometry = new BufferGeometry();\n\t\t\t_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\t\t\t_coneGeometry = new CylinderGeometry( 0, 0.5, 1, 5, 1 );\n\t\t\t_coneGeometry.translate( 0, - 0.5, 0 );\n\n\t\t}\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t}\n\n\tsetDirection( dir ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\t_axis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\tconst radians = Math.acos( dir.y );\n\n\t\t\tthis.quaternion.setFromAxisAngle( _axis, radians );\n\n\t\t}\n\n\t}\n\n\tsetLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {\n\n\t\tthis.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458\n\t\tthis.line.updateMatrix();\n\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\tthis.cone.position.y = length;\n\t\tthis.cone.updateMatrix();\n\n\t}\n\n\tsetColor( color ) {\n\n\t\tthis.line.material.color.set( color );\n\t\tthis.cone.material.color.set( color );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source, false );\n\n\t\tthis.line.copy( source.line );\n\t\tthis.cone.copy( source.cone );\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.line.geometry.dispose();\n\t\tthis.line.material.dispose();\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t}\n\n}\n\nclass AxesHelper extends LineSegments {\n\n\tconstructor( size = 1 ) {\n\n\t\tconst vertices = [\n\t\t\t0, 0, 0,\tsize, 0, 0,\n\t\t\t0, 0, 0,\t0, size, 0,\n\t\t\t0, 0, 0,\t0, 0, size\n\t\t];\n\n\t\tconst colors = [\n\t\t\t1, 0, 0,\t1, 0.6, 0,\n\t\t\t0, 1, 0,\t0.6, 1, 0,\n\t\t\t0, 0, 1,\t0, 0.6, 1\n\t\t];\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'AxesHelper';\n\n\t}\n\n\tsetColors( xAxisColor, yAxisColor, zAxisColor ) {\n\n\t\tconst color = new Color();\n\t\tconst array = this.geometry.attributes.color.array;\n\n\t\tcolor.set( xAxisColor );\n\t\tcolor.toArray( array, 0 );\n\t\tcolor.toArray( array, 3 );\n\n\t\tcolor.set( yAxisColor );\n\t\tcolor.toArray( array, 6 );\n\t\tcolor.toArray( array, 9 );\n\n\t\tcolor.set( zAxisColor );\n\t\tcolor.toArray( array, 12 );\n\t\tcolor.toArray( array, 15 );\n\n\t\tthis.geometry.attributes.color.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass ShapePath {\n\n\tconstructor() {\n\n\t\tthis.type = 'ShapePath';\n\n\t\tthis.color = new Color();\n\n\t\tthis.subPaths = [];\n\t\tthis.currentPath = null;\n\n\t}\n\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPath = new Path();\n\t\tthis.subPaths.push( this.currentPath );\n\t\tthis.currentPath.moveTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tlineTo( x, y ) {\n\n\t\tthis.currentPath.lineTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tsplineThru( pts ) {\n\n\t\tthis.currentPath.splineThru( pts );\n\n\t\treturn this;\n\n\t}\n\n\ttoShapes( isCCW ) {\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tconst shapes = [];\n\n\t\t\tfor ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tconst tmpPath = inSubpaths[ i ];\n\n\t\t\t\tconst tmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tconst polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tlet inside = false;\n\t\t\tfor ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tlet edgeLowPt = inPolygon[ p ];\n\t\t\t\tlet edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tlet edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tlet edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tconst isClockWise = ShapeUtils.isClockWise;\n\n\t\tconst subPaths = this.subPaths;\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tlet solid, tmpPath, tmpShape;\n\t\tconst shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new Shape();\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tlet holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tconst betterShapeHoles = [];\n\t\tconst newShapes = [];\n\t\tlet newShapeHoles = [];\n\t\tlet mainIdx = 0;\n\t\tlet tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( let i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tlet ambiguous = false;\n\t\t\tlet toChange = 0;\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tconst sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tconst ho = sho[ hIdx ];\n\t\t\t\t\tlet hole_unassigned = true;\n\n\t\t\t\t\tfor ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange ++;\n\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( toChange > 0 && ambiguous === false ) {\n\n\t\t\t\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet tmpHoles;\n\n\t\tfor ( let i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n\n}\n\nclass Controls extends EventDispatcher {\n\n\tconstructor( object, domElement = null ) {\n\n\t\tsuper();\n\n\t\tthis.object = object;\n\t\tthis.domElement = domElement;\n\n\t\tthis.enabled = true;\n\n\t\tthis.state = - 1;\n\n\t\tthis.keys = {};\n\t\tthis.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null };\n\t\tthis.touches = { ONE: null, TWO: null };\n\n\t}\n\n\tconnect() {}\n\n\tdisconnect() {}\n\n\tdispose() {}\n\n\tupdate( /* delta */ ) {}\n\n}\n\nfunction contain( texture, aspect ) {\n\n\tconst imageAspect = ( texture.image && texture.image.width ) ? texture.image.width / texture.image.height : 1;\n\n\tif ( imageAspect > aspect ) {\n\n\t\ttexture.repeat.x = 1;\n\t\ttexture.repeat.y = imageAspect / aspect;\n\n\t\ttexture.offset.x = 0;\n\t\ttexture.offset.y = ( 1 - texture.repeat.y ) / 2;\n\n\t} else {\n\n\t\ttexture.repeat.x = aspect / imageAspect;\n\t\ttexture.repeat.y = 1;\n\n\t\ttexture.offset.x = ( 1 - texture.repeat.x ) / 2;\n\t\ttexture.offset.y = 0;\n\n\t}\n\n\treturn texture;\n\n}\n\nfunction cover( texture, aspect ) {\n\n\tconst imageAspect = ( texture.image && texture.image.width ) ? texture.image.width / texture.image.height : 1;\n\n\tif ( imageAspect > aspect ) {\n\n\t\ttexture.repeat.x = aspect / imageAspect;\n\t\ttexture.repeat.y = 1;\n\n\t\ttexture.offset.x = ( 1 - texture.repeat.x ) / 2;\n\t\ttexture.offset.y = 0;\n\n\t} else {\n\n\t\ttexture.repeat.x = 1;\n\t\ttexture.repeat.y = imageAspect / aspect;\n\n\t\ttexture.offset.x = 0;\n\t\ttexture.offset.y = ( 1 - texture.repeat.y ) / 2;\n\n\t}\n\n\treturn texture;\n\n}\n\nfunction fill( texture ) {\n\n\ttexture.repeat.x = 1;\n\ttexture.repeat.y = 1;\n\n\ttexture.offset.x = 0;\n\ttexture.offset.y = 0;\n\n\treturn texture;\n\n}\n\n\n\n/**\n * Given the width, height, format, and type of a texture. Determines how many\n * bytes must be used to represent the texture.\n *\n * @param {Number} width\n * @param {Number} height\n * @param {Number} format\n * @param {Number} type\n * @return {Number} The number of bytes required to represent the texture.\n */\nfunction getByteLength( width, height, format, type ) {\n\n\tconst typeByteLength = getTextureTypeByteLength( type );\n\n\tswitch ( format ) {\n\n\t\t// https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml\n\t\tcase AlphaFormat:\n\t\t\treturn width * height;\n\t\tcase LuminanceFormat:\n\t\t\treturn width * height;\n\t\tcase LuminanceAlphaFormat:\n\t\t\treturn width * height * 2;\n\t\tcase RedFormat:\n\t\t\treturn ( ( width * height ) / typeByteLength.components ) * typeByteLength.byteLength;\n\t\tcase RedIntegerFormat:\n\t\t\treturn ( ( width * height ) / typeByteLength.components ) * typeByteLength.byteLength;\n\t\tcase RGFormat:\n\t\t\treturn ( ( width * height * 2 ) / typeByteLength.components ) * typeByteLength.byteLength;\n\t\tcase RGIntegerFormat:\n\t\t\treturn ( ( width * height * 2 ) / typeByteLength.components ) * typeByteLength.byteLength;\n\t\tcase RGBFormat:\n\t\t\treturn ( ( width * height * 3 ) / typeByteLength.components ) * typeByteLength.byteLength;\n\t\tcase RGBAFormat:\n\t\t\treturn ( ( width * height * 4 ) / typeByteLength.components ) * typeByteLength.byteLength;\n\t\tcase RGBAIntegerFormat:\n\t\t\treturn ( ( width * height * 4 ) / typeByteLength.components ) * typeByteLength.byteLength;\n\n\t\t// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/\n\t\tcase RGB_S3TC_DXT1_Format:\n\t\tcase RGBA_S3TC_DXT1_Format:\n\t\t\treturn Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 8;\n\t\tcase RGBA_S3TC_DXT3_Format:\n\t\tcase RGBA_S3TC_DXT5_Format:\n\t\t\treturn Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;\n\n\t\t// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/\n\t\tcase RGB_PVRTC_2BPPV1_Format:\n\t\tcase RGBA_PVRTC_2BPPV1_Format:\n\t\t\treturn ( Math.max( width, 16 ) * Math.max( height, 8 ) ) / 4;\n\t\tcase RGB_PVRTC_4BPPV1_Format:\n\t\tcase RGBA_PVRTC_4BPPV1_Format:\n\t\t\treturn ( Math.max( width, 8 ) * Math.max( height, 8 ) ) / 2;\n\n\t\t// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/\n\t\tcase RGB_ETC1_Format:\n\t\tcase RGB_ETC2_Format:\n\t\t\treturn Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 8;\n\t\tcase RGBA_ETC2_EAC_Format:\n\t\t\treturn Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;\n\n\t\t// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/\n\t\tcase RGBA_ASTC_4x4_Format:\n\t\t\treturn Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;\n\t\tcase RGBA_ASTC_5x4_Format:\n\t\t\treturn Math.floor( ( width + 4 ) / 5 ) * Math.floor( ( height + 3 ) / 4 ) * 16;\n\t\tcase RGBA_ASTC_5x5_Format:\n\t\t\treturn Math.floor( ( width + 4 ) / 5 ) * Math.floor( ( height + 4 ) / 5 ) * 16;\n\t\tcase RGBA_ASTC_6x5_Format:\n\t\t\treturn Math.floor( ( width + 5 ) / 6 ) * Math.floor( ( height + 4 ) / 5 ) * 16;\n\t\tcase RGBA_ASTC_6x6_Format:\n\t\t\treturn Math.floor( ( width + 5 ) / 6 ) * Math.floor( ( height + 5 ) / 6 ) * 16;\n\t\tcase RGBA_ASTC_8x5_Format:\n\t\t\treturn Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 4 ) / 5 ) * 16;\n\t\tcase RGBA_ASTC_8x6_Format:\n\t\t\treturn Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 5 ) / 6 ) * 16;\n\t\tcase RGBA_ASTC_8x8_Format:\n\t\t\treturn Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 7 ) / 8 ) * 16;\n\t\tcase RGBA_ASTC_10x5_Format:\n\t\t\treturn Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 4 ) / 5 ) * 16;\n\t\tcase RGBA_ASTC_10x6_Format:\n\t\t\treturn Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 5 ) / 6 ) * 16;\n\t\tcase RGBA_ASTC_10x8_Format:\n\t\t\treturn Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 7 ) / 8 ) * 16;\n\t\tcase RGBA_ASTC_10x10_Format:\n\t\t\treturn Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 9 ) / 10 ) * 16;\n\t\tcase RGBA_ASTC_12x10_Format:\n\t\t\treturn Math.floor( ( width + 11 ) / 12 ) * Math.floor( ( height + 9 ) / 10 ) * 16;\n\t\tcase RGBA_ASTC_12x12_Format:\n\t\t\treturn Math.floor( ( width + 11 ) / 12 ) * Math.floor( ( height + 11 ) / 12 ) * 16;\n\n\t\t// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/\n\t\tcase RGBA_BPTC_Format:\n\t\tcase RGB_BPTC_SIGNED_Format:\n\t\tcase RGB_BPTC_UNSIGNED_Format:\n\t\t\treturn Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 16;\n\n\t\t// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/\n\t\tcase RED_RGTC1_Format:\n\t\tcase SIGNED_RED_RGTC1_Format:\n\t\t\treturn Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 8;\n\t\tcase RED_GREEN_RGTC2_Format:\n\t\tcase SIGNED_RED_GREEN_RGTC2_Format:\n\t\t\treturn Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 16;\n\n\t}\n\n\tthrow new Error(\n\t\t`Unable to determine texture byte length for ${format} format.`,\n\t);\n\n}\n\nfunction getTextureTypeByteLength( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase UnsignedByteType:\n\t\tcase ByteType:\n\t\t\treturn { byteLength: 1, components: 1 };\n\t\tcase UnsignedShortType:\n\t\tcase ShortType:\n\t\tcase HalfFloatType:\n\t\t\treturn { byteLength: 2, components: 1 };\n\t\tcase UnsignedShort4444Type:\n\t\tcase UnsignedShort5551Type:\n\t\t\treturn { byteLength: 2, components: 4 };\n\t\tcase UnsignedIntType:\n\t\tcase IntType:\n\t\tcase FloatType:\n\t\t\treturn { byteLength: 4, components: 1 };\n\t\tcase UnsignedInt5999Type:\n\t\t\treturn { byteLength: 4, components: 3 };\n\n\t}\n\n\tthrow new Error( `Unknown texture type ${type}.` );\n\n}\n\nconst TextureUtils = {\n\tcontain,\n\tcover,\n\tfill,\n\tgetByteLength\n};\n\nif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {\n\t\trevision: REVISION,\n\t} } ) );\n\n}\n\nif ( typeof window !== 'undefined' ) {\n\n\tif ( window.__THREE__ ) {\n\n\t\tconsole.warn( 'WARNING: Multiple instances of Three.js being imported.' );\n\n\t} else {\n\n\t\twindow.__THREE__ = REVISION;\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdGhyZWVAMC4xNzIuMC9ub2RlX21vZHVsZXMvdGhyZWUvYnVpbGQvdGhyZWUuY29yZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlCQUFpQixlQUFlO0FBQ2hDLGlCQUFpQixlQUFlO0FBQ2hDLGlCQUFpQixlQUFlOztBQUVoQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsbUJBQW1CO0FBQ3hDLHFCQUFxQixtQkFBbUI7QUFDeEMscUJBQXFCLG1CQUFtQjs7QUFFeEM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYzs7QUFFOUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjs7QUFFakM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQ0FBaUMsUUFBUTs7QUFFekMsMENBQTBDOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRSw2QkFBNkI7QUFDN0IsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixHQUFHOztBQUVILEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxvQkFBb0IsaUJBQWlCOztBQUVyQzs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxzQkFBc0I7O0FBRTdEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyx1QkFBdUI7O0FBRTlEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1Qjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QixzQ0FBc0M7QUFDdEMseUJBQXlCOztBQUV6Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXdCLGtCQUFrQjs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCOztBQUVqQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGdCQUFnQjs7QUFFaEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtEOztBQUVsRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQixXQUFXOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLFFBQVE7O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGdEQUFnRCxRQUFROztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBd0Isa0JBQWtCOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQSxrREFBa0Q7O0FBRWxEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkRBQTZEOztBQUU3RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDZEQUE2RDs7QUFFN0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSixrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsUUFBUTs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrREFBa0QsT0FBTzs7QUFFekQ7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDLE9BQU87O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlGQUFpRjtBQUNqRixpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGLGlGQUFpRjtBQUNqRixpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGLGlGQUFpRjtBQUNqRixpRkFBaUY7O0FBRWpGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQkFBaUIsZUFBZSxlQUFlO0FBQy9DLGlCQUFpQixlQUFlLGVBQWU7QUFDL0MsaUJBQWlCLGVBQWUsZ0JBQWdCO0FBQ2hELGlCQUFpQixlQUFlLGdCQUFnQjs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsbUJBQW1CLG1CQUFtQjtBQUMzRCxxQkFBcUIsbUJBQW1CLG1CQUFtQjtBQUMzRCxxQkFBcUIsbUJBQW1CLHFCQUFxQjtBQUM3RCx1QkFBdUIscUJBQXFCLHFCQUFxQjs7QUFFakU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDLGtCQUFrQixnQkFBZ0I7QUFDbEMsa0JBQWtCLGdCQUFnQjs7QUFFbEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGdCQUFnQixjQUFjLGNBQWM7QUFDNUMsZ0JBQWdCLGNBQWMsY0FBYztBQUM1QyxnQkFBZ0IsY0FBYyxlQUFlO0FBQzdDLGdCQUFnQixjQUFjLGVBQWU7O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQyxpQkFBaUIsbUJBQW1CO0FBQ3BDLGlCQUFpQixtQkFBbUI7O0FBRXBDLGlCQUFpQixvQkFBb0I7QUFDckMsaUJBQWlCLG9CQUFvQjtBQUNyQyxrQkFBa0IscUJBQXFCOztBQUV2Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixjQUFjOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsZUFBZSxhQUFhLGNBQWM7QUFDMUMsZUFBZSxhQUFhLGNBQWM7QUFDMUMsZUFBZSxhQUFhLGVBQWU7QUFDM0MsZUFBZSxhQUFhLGdCQUFnQjs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLG1CQUFtQixjQUFjLGVBQWU7QUFDaEQsaUJBQWlCLGlCQUFpQixlQUFlO0FBQ2pELGlCQUFpQixjQUFjLGlCQUFpQjtBQUNoRCxpQkFBaUIsY0FBYyxlQUFlOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixRQUFROztBQUUzQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsUUFBUTs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLHdCQUF3Qjs7QUFFeEIsMkJBQTJCO0FBQzNCLDZCQUE2Qjs7QUFFN0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLHdCQUF3Qjs7QUFFL0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSwwRUFBMEU7QUFDMUU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixzQkFBc0I7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixzQkFBc0I7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDLE9BQU87O0FBRXBEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDLE9BQU87O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxPQUFPOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsT0FBTzs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLGNBQWM7QUFDZCxpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLE9BQU87O0FBRWhEOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwrQ0FBK0MsT0FBTzs7QUFFdEQ7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsMEJBQTBCOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsNEJBQTRCOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQiw0QkFBNEI7O0FBRWhEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVEQUF1RDs7QUFFdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCOztBQUVoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLHlEQUF5RDtBQUN6RCx5Q0FBeUM7QUFDekMseUNBQXlDOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLGFBQWEsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxnQkFBZ0I7O0FBRTVGOztBQUVBLGlCQUFpQix1QkFBdUIsSUFBSSx1QkFBdUIsSUFBSSx1QkFBdUI7O0FBRTlGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsd0JBQXdCOztBQUUvRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlEQUFpRCxLQUFLO0FBQ3REOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxLQUFLLGdDQUFnQyxXQUFXO0FBQ3ZGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7O0FBRTdCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBd0Isa0JBQWtCOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyREFBMkQ7O0FBRTNEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQzs7QUFFdEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixVQUFVOztBQUU1QixtQkFBbUI7QUFDbkIsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0Esb0JBQW9COztBQUVwQjs7QUFFQSxxQkFBcUI7QUFDckIsbUJBQW1COztBQUVuQjs7QUFFQTs7QUFFQSxxQkFBcUIsVUFBVTs7QUFFL0I7O0FBRUE7O0FBRUEsa0JBQWtCLFFBQVE7O0FBRTFCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLFFBQVE7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixRQUFROztBQUUxQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRCQUE0QixlQUFlOztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0NBQW9DLE9BQU87O0FBRTNDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSixvQ0FBb0MsT0FBTzs7QUFFM0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBbUMsT0FBTzs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DLE9BQU87O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxPQUFPOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLGtCQUFrQjs7QUFFekQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQjs7QUFFckI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5QztBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUosaUVBQWlFOztBQUVqRSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBEQUEwRCxRQUFROztBQUVsRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBEQUEwRCxRQUFROztBQUVsRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx5Q0FBeUMsUUFBUTs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMERBQTBELFFBQVE7O0FBRWxFO0FBQ0E7O0FBRUEsaURBQWlELFFBQVE7O0FBRXpEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQiw2QkFBNkI7O0FBRWhEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLHVDQUF1QyxRQUFROztBQUUvQzs7QUFFQTtBQUNBOztBQUVBLDRDQUE0QyxRQUFROztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7O0FBRUE7QUFDQTs7QUFFQSw0Q0FBNEMsUUFBUTs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLGlEQUFpRCxRQUFROztBQUV6RDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsbURBQW1ELFFBQVE7O0FBRTNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxRQUFROztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDLE9BQU87O0FBRS9DOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEscUJBQXFCLGNBQWM7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLG1EQUFtRDs7QUFFbkQsZ0RBQWdELFFBQVE7O0FBRXhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGdCQUFnQjs7QUFFaEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnREFBZ0QsUUFBUTs7QUFFeEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLG1EQUFtRDs7QUFFbkQsK0NBQStDLE9BQU87O0FBRXREOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXdCLGtCQUFrQjs7QUFFMUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlEQUFpRDs7QUFFakQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaURBQWlELFFBQVE7O0FBRXpEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsK0NBQStDLFFBQVE7O0FBRXZEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0MsUUFBUTs7QUFFNUM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxtQ0FBbUMsUUFBUTs7QUFFM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9EQUFvRDtBQUNwRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0NBQW9DLFFBQVE7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxxREFBcUQ7QUFDckQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsbUNBQW1DLFFBQVE7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvREFBb0Q7QUFDcEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGlHQUFpRztBQUNqRyxpR0FBaUc7QUFDakcsNEZBQTRGO0FBQzVGLGdHQUFnRztBQUNoRywrRkFBK0Y7QUFDL0YsbUdBQW1HOztBQUVuRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCLGFBQWE7O0FBRWxDOztBQUVBLHNCQUFzQixhQUFhOztBQUVuQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixZQUFZOztBQUVqQyxzQkFBc0IsWUFBWTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixxQkFBcUI7O0FBRXZDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixnQkFBZ0I7O0FBRWxDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBd0I7O0FBRXhCLG1DQUFtQyw2RUFBNkUsR0FBRzs7QUFFbkgscUNBQXFDLDhDQUE4QyxHQUFHOztBQUV0Rjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkIseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBLFdBQVcseUVBQXlFO0FBQ3BGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckIsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0VBQWdFOztBQUVoRTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQjtBQUNsQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFVBQVUsa0NBQWtDOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUEsa0JBQWtCO0FBQ2xCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1FQUFtRSxlQUFlOztBQUVsRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNEJBQTRCLGVBQWU7O0FBRTNDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0NBQW9DLE9BQU87O0FBRTNDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DLE9BQU87O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxPQUFPOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsZ0JBQWdCOztBQUVwQzs7QUFFQSxxQkFBcUIsbUJBQW1COztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixnQkFBZ0I7O0FBRXBDOztBQUVBLHFCQUFxQixtQkFBbUI7O0FBRXhDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsbUJBQW1COztBQUVsQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5QkFBeUIsNkRBQTZEOztBQUV0Rjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsbUJBQW1COztBQUV0Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7O0FBSUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DLE9BQU87O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DLE9BQU87O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxXQUFXLE9BQU87O0FBRWxCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQiw2QkFBNkI7O0FBRWhEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLDZCQUE2Qjs7QUFFaEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QyxPQUFPOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMLDhCQUE4Qjs7QUFFOUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDZDQUE2QyxRQUFROztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0NBQXNDLFFBQVE7O0FBRTlDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBLDREQUE0RDtBQUM1RCx5Q0FBeUM7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLE9BQU87O0FBRWpEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDLE9BQU87O0FBRTVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixXQUFXOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixXQUFXOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixXQUFXOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDOztBQUUzQyxxQ0FBcUM7O0FBRXJDLG1CQUFtQiw2QkFBNkI7O0FBRWhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDRCQUE0QiwyQkFBMkI7O0FBRXZEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9EQUFvRCxPQUFPOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkM7O0FBRTNDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQiw2QkFBNkI7O0FBRWhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdCQUF3QixrQkFBa0I7O0FBRTFDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7O0FBRXBDLG9CQUFvQixjQUFjOztBQUVsQzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7O0FBRTVCOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLDZEQUE2RDtBQUM3RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVksOEJBQThCOztBQUUxQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9FQUFvRSxlQUFlOztBQUVuRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw2REFBNkQsV0FBVzs7QUFFeEU7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw2REFBNkQsV0FBVzs7QUFFeEU7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxPQUFPOztBQUVuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLE9BQU87O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhEQUE4RCxPQUFPOztBQUVyRTtBQUNBLHFCQUFxQixjQUFjOztBQUVuQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG9CQUFvQjs7QUFFeEM7O0FBRUE7O0FBRUE7QUFDQSx5REFBeUQsT0FBTzs7QUFFaEU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTzs7QUFFbkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQSxnREFBZ0QsT0FBTzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLDhDQUE4QztBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQ0FBcUM7O0FBRXBFOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxZQUFZLG1DQUFtQztBQUMvQztBQUNBOztBQUVBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixPQUFPOztBQUV6RjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtGQUFrRixPQUFPOztBQUV6RjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw2Q0FBNkM7O0FBRTdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG9FQUFvRSxtQkFBbUI7O0FBRXZGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZGQUE2RixlQUFlOztBQUU1Rzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkZBQTZGLGVBQWU7O0FBRTVHOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QyxPQUFPOztBQUVuRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxPQUFPOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSiw2REFBNkQsVUFBVTs7QUFFdkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLE9BQU87O0FBRXBEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKLDZDQUE2QyxPQUFPOztBQUVwRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpREFBaUQsT0FBTzs7QUFFeEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRCxRQUFROztBQUV6RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMERBQTBEOztBQUUxRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRCxPQUFPOztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDLFFBQVE7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxpQ0FBaUMsT0FBTzs7QUFFeEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRCxRQUFROztBQUV6RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFdBQVcsZ0JBQWdCOztBQUUzQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixnQkFBZ0I7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixnQkFBZ0I7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsZ0JBQWdCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0IsS0FBSyx5QkFBeUI7O0FBRTlDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUI7O0FBRXZCOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsK0NBQStDOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsZUFBZTs7QUFFbEM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBLG1CQUFtQixlQUFlOztBQUVsQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3RkFBd0Y7O0FBRXhGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLGVBQWU7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYzs7QUFFZDs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDLE9BQU87O0FBRXBEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkMsT0FBTzs7QUFFbEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDLE9BQU87O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDLE9BQU87O0FBRXBEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQyxPQUFPOztBQUVsRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQyxPQUFPOztBQUVsRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxPQUFPOztBQUVsRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixnQkFBZ0I7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLG1CQUFtQjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsZ0JBQWdCOztBQUVwQzs7QUFFQSxrREFBa0Q7O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDLE9BQU87O0FBRXBEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLE9BQU87O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsT0FBTzs7QUFFbEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUNBQWlDOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLDRCQUE0Qjs7QUFFL0M7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixlQUFlOztBQUVsQzs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQiw0QkFBNEI7O0FBRWhEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsY0FBYzs7QUFFakMsb0JBQW9CLDJCQUEyQjs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixlQUFlOztBQUV6Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLGVBQWU7O0FBRWxDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IscUJBQXFCOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQkFBcUIscUJBQXFCOztBQUUxQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLG9CQUFvQjs7QUFFeEMscUJBQXFCLG9CQUFvQjs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixxQkFBcUI7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLG9CQUFvQjs7QUFFeEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDLElBQUk7O0FBRUosNEJBQTRCOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLG9CQUFvQjs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixXQUFXOztBQUUvQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixXQUFXOztBQUVoQzs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixVQUFVOztBQUU5QixxQkFBcUIsMEJBQTBCOztBQUUvQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHlCQUF5Qjs7QUFFN0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IseUJBQXlCOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixxQkFBcUI7O0FBRXpDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIseUJBQXlCOztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDOztBQUVyQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCOztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLCtCQUErQixJQUFJLCtCQUErQixJQUFJLCtCQUErQjtBQUMzSCxzQkFBc0IsK0JBQStCLElBQUksK0JBQStCLElBQUksK0JBQStCO0FBQzNILHNCQUFzQiwrQkFBK0IsSUFBSSwrQkFBK0IsSUFBSSwrQkFBK0I7O0FBRTNIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsT0FBTzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixVQUFVLElBQUksVUFBVTtBQUM5Qyw2QkFBNkIsVUFBVSxJQUFJLFVBQVU7O0FBRXJEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDOztBQUVyQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBMEMsT0FBTzs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw0Q0FBNEMsT0FBTzs7QUFFbkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwwQ0FBMEMsT0FBTzs7QUFFakQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQyxPQUFPOztBQUVqRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5RUFBeUU7QUFDekU7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsY0FBYzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixTQUFTOztBQUU1QixHQUFHOztBQUVILHVCQUF1QixZQUFZOztBQUVuQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQzs7QUFFM0M7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDOztBQUUzQzs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsY0FBYyxrQkFBa0I7O0FBRWhDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QiwrQkFBK0I7O0FBRTdEOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDOztBQUU5Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHOztBQUVoRzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7O0FBRTVDLHlEQUF5RDtBQUN6RCx5REFBeUQ7QUFDekQseURBQXlEO0FBQ3pELHlEQUF5RDs7QUFFekQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxxQ0FBcUMsU0FBUzs7QUFFOUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QixPQUFPOztBQUVyQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUI7QUFDdkIsMEJBQTBCO0FBQzFCLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsa0JBQWtCOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLHNCQUFzQjs7QUFFekM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLG9CQUFvQjs7QUFFdEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLGlLQUFpSzs7QUFFaks7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxRQUFROztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUEsNkJBQTZCOztBQUU3Qix1Q0FBdUMsUUFBUTs7QUFFL0M7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5Qzs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSwrQkFBK0I7O0FBRS9COztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQSxnRUFBZ0UsUUFBUTs7QUFFeEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBLCtEQUErRCxRQUFROztBQUV2RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUEsb0JBQW9CLG1CQUFtQjs7QUFFdkMsK0JBQStCLE9BQU87O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDLFFBQVE7O0FBRWhEO0FBQ0E7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixVQUFVOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsWUFBWTs7QUFFaEMscUJBQXFCLFVBQVU7O0FBRS9COztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0QyxvQ0FBb0MsUUFBUTs7QUFFNUM7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQyxRQUFROztBQUVsRDtBQUNBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxRQUFROztBQUVoRDtBQUNBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQSxRQUFROztBQUVSOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0I7QUFDcEI7O0FBRUE7O0FBRUEsc0JBQXNCLFVBQVU7O0FBRWhDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsVUFBVTs7QUFFaEM7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLHNCQUFzQixVQUFVOztBQUVoQztBQUNBOztBQUVBOztBQUVBOztBQUVBLHNCQUFzQixVQUFVOztBQUVoQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxRQUFROztBQUVoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMERBQTBELFFBQVE7O0FBRWxFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNENBQTRDLFFBQVE7O0FBRXBEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxpQ0FBaUM7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGFBQWE7O0FBRWpDOztBQUVBLHFCQUFxQixhQUFhOztBQUVsQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixZQUFZOztBQUVoQyxxQkFBcUIsWUFBWTs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsa0JBQWtCOztBQUVyQyxvQkFBb0Isb0JBQW9COztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLGlCQUFpQjs7QUFFcEM7O0FBRUEsb0JBQW9CLG1CQUFtQjs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSixvQkFBb0IsbUJBQW1COztBQUV2Qzs7QUFFQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkMsT0FBTzs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDLE9BQU87O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsOENBQThDLE9BQU87O0FBRXJEOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QyxRQUFROztBQUVwRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLHNCQUFzQjs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxxQkFBcUIscUJBQXFCOztBQUUxQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IscUJBQXFCOztBQUV6QyxxQkFBcUIsb0JBQW9COztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIscUJBQXFCOztBQUV4QyxvQkFBb0Isc0JBQXNCOztBQUUxQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIscUJBQXFCOztBQUV4QyxvQkFBb0Isc0JBQXNCOztBQUUxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLHNCQUFzQjs7QUFFekM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsc0JBQXNCOztBQUV6QyxvQkFBb0IscUJBQXFCOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IscUJBQXFCOztBQUV6Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLHFCQUFxQjs7QUFFekM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHNCQUFzQjs7QUFFMUMscUJBQXFCLHFCQUFxQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0Isc0JBQXNCOztBQUUxQyxxQkFBcUIscUJBQXFCOztBQUUxQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixtREFBbUQ7O0FBRXJFOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDs7QUFFQTtBQUNBOztBQUVBLGdFQUFnRSxPQUFPOztBQUV2RSx1QkFBdUIsT0FBTzs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxpREFBaUQsT0FBTzs7QUFFeEQsc0JBQXNCLE9BQU87O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDOztBQUVyQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IsUUFBUSxHQUFHLFFBQVEsR0FBRyxRQUFRLEdBQUcsTUFBTSxHQUFHLE1BQU0sR0FBRyxNQUFNO0FBQzNFLGtCQUFrQixNQUFNLEdBQUcsTUFBTSxHQUFHLE1BQU0sR0FBRyxRQUFRLEdBQUcsUUFBUSxHQUFHLFFBQVEsR0FBRzs7QUFFOUU7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUI7O0FBRW5CLHNDQUFzQztBQUN0QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUI7O0FBRW5COztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0M7O0FBRXRDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQjs7QUFFbkI7O0FBRUEsc0NBQXNDOztBQUV0Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBLG1CQUFtQjs7QUFFbkI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCOztBQUU1Qjs7QUFFQSw2Q0FBNkM7O0FBRTdDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUMsdUJBQXVCOztBQUV4RDs7QUFFQSxtQkFBbUIsY0FBYzs7QUFFakM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0Esb0NBQW9DOztBQUVwQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHdDQUF3Qzs7QUFFeEM7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSixHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSixHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0Isd0JBQXdCOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLHdCQUF3Qjs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLGVBQWU7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLHdCQUF3Qjs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLHdCQUF3Qjs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixlQUFlOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQixjQUFjOztBQUVqQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLHFCQUFxQixjQUFjOztBQUVuQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixjQUFjOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsY0FBYzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixjQUFjOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DOztBQUVuQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTixpQ0FBaUM7O0FBRWpDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsU0FBUzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsU0FBUzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixhQUFhOztBQUVoQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxTQUFTOztBQUVqRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixlQUFlOztBQUVsQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsY0FBYzs7QUFFcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsY0FBYzs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0ZBQXdGLGNBQWM7O0FBRXRHOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBbUMsZ0JBQWdCOztBQUVuRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTOztBQUVuRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsU0FBUzs7QUFFbkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIscUJBQXFCOztBQUV4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLHNCQUFzQjs7QUFFekM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTs7QUFFckQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLDRCQUE0Qjs7QUFFL0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLDBCQUEwQjs7QUFFM0M7O0FBRUEsdUJBQXVCLDRDQUE0Qzs7QUFFbkU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsOENBQThDOztBQUVwRTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsU0FBUzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLHdCQUF3Qjs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLHdCQUF3Qjs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLHdCQUF3Qjs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLHdCQUF3Qjs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsVUFBVTs7QUFFVjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLE9BQU87O0FBRWhEO0FBQ0E7O0FBRUEsNkNBQTZDOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGdDQUFnQyxjQUFjOztBQUU5Qzs7QUFFQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBLHlEQUF5RCxrQ0FBa0M7QUFDM0Ysa0RBQWtELFFBQVE7O0FBRTFEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBLFVBQVU7O0FBRVY7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQSxNQUFNOztBQUVOLHdDQUF3QyxhQUFhLG1CQUFtQixnQkFBZ0IsSUFBSSxvQkFBb0I7O0FBRWhIOztBQUVBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxRQUFROztBQUVSO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0Q0FBNEMsUUFBUTs7QUFFcEQ7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QyxRQUFROztBQUVwRDtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixpQkFBaUI7O0FBRXBDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEscUNBQXFDLFFBQVE7O0FBRTdDOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0JBQXNCLFdBQVc7O0FBRWpDLHNCQUFzQjs7QUFFdEIsdUJBQXVCLDBCQUEwQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxtQkFBbUIsaUJBQWlCOztBQUVwQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLE1BQU07O0FBRU47QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxrREFBa0Q7O0FBRWxEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7OztBQUdIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwrQkFBK0I7O0FBRS9COztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEOztBQUU3RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnRUFBZ0U7O0FBRWhFOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBLDREQUE0RDtBQUM1RDtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0Esc0VBQXNFOztBQUV0RTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQztBQUNuQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsOEJBQThCOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQyxRQUFROztBQUU5QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUksY0FBYzs7QUFFbEI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlEQUFpRCxRQUFROztBQUV6RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFNBQVM7O0FBRWhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDLE9BQU87O0FBRTVDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDLE9BQU87O0FBRTVDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVIsd0VBQXdFLFdBQVc7O0FBRW5GOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CO0FBQ3BCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDLE9BQU87O0FBRTVDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixpQkFBaUI7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsUUFBUTs7QUFFOUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsUUFBUTs7QUFFOUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDLE9BQU87O0FBRTVDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBLDhDQUE4Qzs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFOztBQUVsRTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGtFQUFrRTs7QUFFbEU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHFCQUFxQjs7QUFFekM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLDZCQUE2Qjs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLG1CQUFtQjs7QUFFdkM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQjs7QUFFbkI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUosbUVBQW1FLCtCQUErQjs7QUFFbEcsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDZDQUE2QyxPQUFPOztBQUVwRDs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDZDQUE2QyxPQUFPOztBQUVwRDs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsY0FBYzs7QUFFbEM7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw2Q0FBNkMsU0FBUzs7QUFFdEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxpREFBaUQsU0FBUzs7QUFFMUQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixjQUFjOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLG9CQUFvQjs7QUFFdkM7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixjQUFjOztBQUVsQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLGNBQWM7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixjQUFjOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsR0FBRztBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0VBQXdFLFNBQVM7O0FBRWpGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdFQUF3RSxTQUFTOztBQUVqRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3RUFBd0UsU0FBUzs7QUFFakY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIscUJBQXFCOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLFNBQVM7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQ0FBb0MsU0FBUzs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0NBQW9DLFNBQVM7O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9DQUFvQyxTQUFTOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLHlCQUF5Qjs7QUFFL0M7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQSxpQ0FBaUM7O0FBRWpDLHlDQUF5QyxTQUFTOztBQUVsRDs7QUFFQTs7QUFFQSxvQkFBb0I7QUFDcEIsMEJBQTBCLGFBQWE7QUFDdkMsdUJBQXVCO0FBQ3ZCLG9DQUFvQzs7QUFFcEM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBb0MsU0FBUzs7QUFFN0M7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBb0MsU0FBUzs7QUFFN0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUwsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQyxTQUFTOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQ0FBcUMsU0FBUzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxQ0FBcUMsU0FBUzs7QUFFOUM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOLEtBQUs7O0FBRUwsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9EQUFvRCxTQUFTOztBQUU3RDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixlQUFlOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBOztBQUVBLDJCQUEyQjtBQUMzQixpQ0FBaUM7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQkFBK0I7O0FBRS9CLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCLGlDQUFpQzs7QUFFakMsK0JBQStCO0FBQy9CLDZCQUE2Qjs7QUFFN0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIsd0JBQXdCO0FBQ3hCLHlCQUF5Qjs7QUFFekI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOzs7QUFHTCw0QkFBNEI7QUFDNUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsK0NBQStDLFNBQVM7O0FBRXhEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBK0MsU0FBUzs7QUFFeEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUEsSUFBSSxPQUFPOztBQUVYOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFEQUFxRDtBQUNyRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLGVBQWU7O0FBRWxDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EseUNBQXlDLFNBQVM7O0FBRWxEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSx1QkFBdUI7QUFDdkI7O0FBRUEsb0NBQW9DOzs7QUFHcEMsa0NBQWtDO0FBQ2xDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDLFNBQVM7O0FBRWpEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCLFFBQVE7O0FBRXRDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixnQkFBZ0I7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIsbUJBQW1CLDBCQUEwQjs7QUFFN0MsZ0NBQWdDOztBQUVoQzs7QUFFQSx1Q0FBdUM7O0FBRXZDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0RBQWdELFNBQVM7O0FBRXpEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkRBQTZEOztBQUU3RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw2REFBNkQ7O0FBRTdEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxnQkFBZ0I7O0FBRXZEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXdCLGtCQUFrQjs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUEsb0JBQW9CLHFCQUFxQjs7QUFFekM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxXQUFXLGNBQWM7QUFDekIsVUFBVTtBQUNWLGFBQWEsY0FBYztBQUMzQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKLCtIQUErSDtBQUMvSDtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDLE9BQU87O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCLHNCQUFzQjs7QUFFdEI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIsY0FBYzs7QUFFZDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCO0FBQ2pCLGlCQUFpQjs7QUFFakI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxRQUFROztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsT0FBTzs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw0Q0FBNEMsZ0NBQWdDOztBQUU1RTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7O0FBRXJDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNENBQTRDLGdHQUFnRzs7QUFFNUk7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLGtCQUFrQjs7QUFFNUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IsNEJBQTRCOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0QyxpREFBaUQ7O0FBRTdGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxnRkFBZ0Y7O0FBRXpJO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLGlEQUFpRDtBQUM1Rjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsZ0JBQWdCOztBQUUxRDtBQUNBOztBQUVBOztBQUVBLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CLCtCQUErQjs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0Qyx3Q0FBd0M7O0FBRXBGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixhQUFhOztBQUVqQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsV0FBVzs7QUFFOUI7O0FBRUE7O0FBRUEsb0JBQW9CLGVBQWU7O0FBRW5DOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0Qyx3Q0FBd0M7O0FBRXBGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsZ0NBQWdDOztBQUU1RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsNENBQTRDLHlEQUF5RDs7QUFFckc7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsK0RBQStELDZEQUE2RDtBQUM1SCwrREFBK0QsNkRBQTZEO0FBQzVILCtEQUErRCw2REFBNkQ7QUFDNUgsK0RBQStELDZEQUE2RDs7QUFFNUg7O0FBRUEsK0RBQStELDZEQUE2RDtBQUM1SCxnRUFBZ0UsOERBQThEO0FBQzlILGdFQUFnRSw4REFBOEQ7QUFDOUgsZ0VBQWdFLDhEQUE4RDs7QUFFOUg7O0FBRUEsZ0VBQWdFLDhEQUE4RDtBQUM5SCxnRUFBZ0UsOERBQThEO0FBQzlILGdFQUFnRSw4REFBOEQ7QUFDOUgsZ0VBQWdFLDhEQUE4RDs7QUFFOUg7O0FBRUEsdURBQXVELHFEQUFxRDtBQUM1Ryx1REFBdUQscURBQXFEO0FBQzVHLHVEQUF1RCxxREFBcUQ7QUFDNUcsdURBQXVELHFEQUFxRDs7QUFFNUc7O0FBRUEsaURBQWlELCtDQUErQztBQUNoRyxpREFBaUQsK0NBQStDO0FBQ2hHLGlEQUFpRCwrQ0FBK0M7O0FBRWhHOztBQUVBLDZEQUE2RCwyREFBMkQ7QUFDeEgsMERBQTBELHdEQUF3RDs7QUFFbEg7O0FBRUEsMERBQTBELHdEQUF3RDtBQUNsSCwwREFBMEQsd0RBQXdEOztBQUVsSCwwREFBMEQsd0RBQXdEO0FBQ2xILDBEQUEwRCx3REFBd0Q7O0FBRWxIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxrQ0FBa0M7O0FBRTlFO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixvQkFBb0I7QUFDMUMsc0JBQXNCLG9CQUFvQjtBQUMxQyxzQkFBc0Isb0JBQW9CO0FBQzFDLHNCQUFzQixxQkFBcUI7QUFDM0MsdUJBQXVCLHFCQUFxQjtBQUM1Qyx1QkFBdUIscUJBQXFCO0FBQzVDLHVCQUF1QixxQkFBcUI7QUFDNUMsdUJBQXVCLHFCQUFxQjs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QyxrQ0FBa0M7O0FBRTlFOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxrQ0FBa0M7O0FBRTlFOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQsc0ZBQXNGOztBQUVoSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnRUFBZ0Usa0NBQWtDO0FBQ2xHO0FBQ0E7O0FBRUEsZ0VBQWdFLGtDQUFrQztBQUNsRztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdFQUF3RTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLHdDQUF3Qzs7QUFFcEY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQyxPQUFPOztBQUVsRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsYUFBYTs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDLG1DQUFtQzs7QUFFbkM7O0FBRUE7O0FBRUE7O0FBRUEsbURBQW1EO0FBQ25ELHNCQUFzQjs7QUFFdEIsT0FBTzs7QUFFUDtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDBCQUEwQjs7QUFFMUI7O0FBRUEsTUFBTTs7QUFFTjtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMLHFDQUFxQyxnQ0FBZ0M7O0FBRXJFOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUEsZ0RBQWdELGFBQWE7O0FBRTdEOztBQUVBOztBQUVBLGdEQUFnRCxhQUFhOztBQUU3RDs7QUFFQSx3QkFBd0IsbUJBQW1COztBQUUzQztBQUNBOztBQUVBLDBCQUEwQiwwQkFBMEI7O0FBRXBEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxRQUFROztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCLG1CQUFtQjs7QUFFbkI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTs7QUFFWjs7QUFFQSwwQ0FBMEMsS0FBSzs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtFQUFrRTtBQUNsRTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFdWdPIiwic291cmNlcyI6WyIvVXNlcnMvamVyZW15ai9Eb2N1bWVudHMvc291cmNlL3JlcG9zL3NoYWRlcnMvbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVlQDAuMTcyLjAvbm9kZV9tb2R1bGVzL3RocmVlL2J1aWxkL3RocmVlLmNvcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTAtMjAyNCBUaHJlZS5qcyBBdXRob3JzXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4gKi9cbmNvbnN0IFJFVklTSU9OID0gJzE3Mic7XG5cbmNvbnN0IE1PVVNFID0geyBMRUZUOiAwLCBNSURETEU6IDEsIFJJR0hUOiAyLCBST1RBVEU6IDAsIERPTExZOiAxLCBQQU46IDIgfTtcbmNvbnN0IFRPVUNIID0geyBST1RBVEU6IDAsIFBBTjogMSwgRE9MTFlfUEFOOiAyLCBET0xMWV9ST1RBVEU6IDMgfTtcbmNvbnN0IEN1bGxGYWNlTm9uZSA9IDA7XG5jb25zdCBDdWxsRmFjZUJhY2sgPSAxO1xuY29uc3QgQ3VsbEZhY2VGcm9udCA9IDI7XG5jb25zdCBDdWxsRmFjZUZyb250QmFjayA9IDM7XG5jb25zdCBCYXNpY1NoYWRvd01hcCA9IDA7XG5jb25zdCBQQ0ZTaGFkb3dNYXAgPSAxO1xuY29uc3QgUENGU29mdFNoYWRvd01hcCA9IDI7XG5jb25zdCBWU01TaGFkb3dNYXAgPSAzO1xuY29uc3QgRnJvbnRTaWRlID0gMDtcbmNvbnN0IEJhY2tTaWRlID0gMTtcbmNvbnN0IERvdWJsZVNpZGUgPSAyO1xuY29uc3QgTm9CbGVuZGluZyA9IDA7XG5jb25zdCBOb3JtYWxCbGVuZGluZyA9IDE7XG5jb25zdCBBZGRpdGl2ZUJsZW5kaW5nID0gMjtcbmNvbnN0IFN1YnRyYWN0aXZlQmxlbmRpbmcgPSAzO1xuY29uc3QgTXVsdGlwbHlCbGVuZGluZyA9IDQ7XG5jb25zdCBDdXN0b21CbGVuZGluZyA9IDU7XG5jb25zdCBBZGRFcXVhdGlvbiA9IDEwMDtcbmNvbnN0IFN1YnRyYWN0RXF1YXRpb24gPSAxMDE7XG5jb25zdCBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbiA9IDEwMjtcbmNvbnN0IE1pbkVxdWF0aW9uID0gMTAzO1xuY29uc3QgTWF4RXF1YXRpb24gPSAxMDQ7XG5jb25zdCBaZXJvRmFjdG9yID0gMjAwO1xuY29uc3QgT25lRmFjdG9yID0gMjAxO1xuY29uc3QgU3JjQ29sb3JGYWN0b3IgPSAyMDI7XG5jb25zdCBPbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gMjAzO1xuY29uc3QgU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XG5jb25zdCBPbmVNaW51c1NyY0FscGhhRmFjdG9yID0gMjA1O1xuY29uc3QgRHN0QWxwaGFGYWN0b3IgPSAyMDY7XG5jb25zdCBPbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xuY29uc3QgRHN0Q29sb3JGYWN0b3IgPSAyMDg7XG5jb25zdCBPbmVNaW51c0RzdENvbG9yRmFjdG9yID0gMjA5O1xuY29uc3QgU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciA9IDIxMDtcbmNvbnN0IENvbnN0YW50Q29sb3JGYWN0b3IgPSAyMTE7XG5jb25zdCBPbmVNaW51c0NvbnN0YW50Q29sb3JGYWN0b3IgPSAyMTI7XG5jb25zdCBDb25zdGFudEFscGhhRmFjdG9yID0gMjEzO1xuY29uc3QgT25lTWludXNDb25zdGFudEFscGhhRmFjdG9yID0gMjE0O1xuY29uc3QgTmV2ZXJEZXB0aCA9IDA7XG5jb25zdCBBbHdheXNEZXB0aCA9IDE7XG5jb25zdCBMZXNzRGVwdGggPSAyO1xuY29uc3QgTGVzc0VxdWFsRGVwdGggPSAzO1xuY29uc3QgRXF1YWxEZXB0aCA9IDQ7XG5jb25zdCBHcmVhdGVyRXF1YWxEZXB0aCA9IDU7XG5jb25zdCBHcmVhdGVyRGVwdGggPSA2O1xuY29uc3QgTm90RXF1YWxEZXB0aCA9IDc7XG5jb25zdCBNdWx0aXBseU9wZXJhdGlvbiA9IDA7XG5jb25zdCBNaXhPcGVyYXRpb24gPSAxO1xuY29uc3QgQWRkT3BlcmF0aW9uID0gMjtcbmNvbnN0IE5vVG9uZU1hcHBpbmcgPSAwO1xuY29uc3QgTGluZWFyVG9uZU1hcHBpbmcgPSAxO1xuY29uc3QgUmVpbmhhcmRUb25lTWFwcGluZyA9IDI7XG5jb25zdCBDaW5lb25Ub25lTWFwcGluZyA9IDM7XG5jb25zdCBBQ0VTRmlsbWljVG9uZU1hcHBpbmcgPSA0O1xuY29uc3QgQ3VzdG9tVG9uZU1hcHBpbmcgPSA1O1xuY29uc3QgQWdYVG9uZU1hcHBpbmcgPSA2O1xuY29uc3QgTmV1dHJhbFRvbmVNYXBwaW5nID0gNztcbmNvbnN0IEF0dGFjaGVkQmluZE1vZGUgPSAnYXR0YWNoZWQnO1xuY29uc3QgRGV0YWNoZWRCaW5kTW9kZSA9ICdkZXRhY2hlZCc7XG5cbmNvbnN0IFVWTWFwcGluZyA9IDMwMDtcbmNvbnN0IEN1YmVSZWZsZWN0aW9uTWFwcGluZyA9IDMwMTtcbmNvbnN0IEN1YmVSZWZyYWN0aW9uTWFwcGluZyA9IDMwMjtcbmNvbnN0IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nID0gMzAzO1xuY29uc3QgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDQ7XG5jb25zdCBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyA9IDMwNjtcbmNvbnN0IFJlcGVhdFdyYXBwaW5nID0gMTAwMDtcbmNvbnN0IENsYW1wVG9FZGdlV3JhcHBpbmcgPSAxMDAxO1xuY29uc3QgTWlycm9yZWRSZXBlYXRXcmFwcGluZyA9IDEwMDI7XG5jb25zdCBOZWFyZXN0RmlsdGVyID0gMTAwMztcbmNvbnN0IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyID0gMTAwNDtcbmNvbnN0IE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNDtcbmNvbnN0IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xuY29uc3QgTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciA9IDEwMDU7XG5jb25zdCBMaW5lYXJGaWx0ZXIgPSAxMDA2O1xuY29uc3QgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XG5jb25zdCBMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNztcbmNvbnN0IExpbmVhck1pcG1hcExpbmVhckZpbHRlciA9IDEwMDg7XG5jb25zdCBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xuY29uc3QgVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XG5jb25zdCBCeXRlVHlwZSA9IDEwMTA7XG5jb25zdCBTaG9ydFR5cGUgPSAxMDExO1xuY29uc3QgVW5zaWduZWRTaG9ydFR5cGUgPSAxMDEyO1xuY29uc3QgSW50VHlwZSA9IDEwMTM7XG5jb25zdCBVbnNpZ25lZEludFR5cGUgPSAxMDE0O1xuY29uc3QgRmxvYXRUeXBlID0gMTAxNTtcbmNvbnN0IEhhbGZGbG9hdFR5cGUgPSAxMDE2O1xuY29uc3QgVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gMTAxNztcbmNvbnN0IFVuc2lnbmVkU2hvcnQ1NTUxVHlwZSA9IDEwMTg7XG5jb25zdCBVbnNpZ25lZEludDI0OFR5cGUgPSAxMDIwO1xuY29uc3QgVW5zaWduZWRJbnQ1OTk5VHlwZSA9IDM1OTAyO1xuY29uc3QgQWxwaGFGb3JtYXQgPSAxMDIxO1xuY29uc3QgUkdCRm9ybWF0ID0gMTAyMjtcbmNvbnN0IFJHQkFGb3JtYXQgPSAxMDIzO1xuY29uc3QgTHVtaW5hbmNlRm9ybWF0ID0gMTAyNDtcbmNvbnN0IEx1bWluYW5jZUFscGhhRm9ybWF0ID0gMTAyNTtcbmNvbnN0IERlcHRoRm9ybWF0ID0gMTAyNjtcbmNvbnN0IERlcHRoU3RlbmNpbEZvcm1hdCA9IDEwMjc7XG5jb25zdCBSZWRGb3JtYXQgPSAxMDI4O1xuY29uc3QgUmVkSW50ZWdlckZvcm1hdCA9IDEwMjk7XG5jb25zdCBSR0Zvcm1hdCA9IDEwMzA7XG5jb25zdCBSR0ludGVnZXJGb3JtYXQgPSAxMDMxO1xuY29uc3QgUkdCSW50ZWdlckZvcm1hdCA9IDEwMzI7XG5jb25zdCBSR0JBSW50ZWdlckZvcm1hdCA9IDEwMzM7XG5cbmNvbnN0IFJHQl9TM1RDX0RYVDFfRm9ybWF0ID0gMzM3NzY7XG5jb25zdCBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAzMzc3NztcbmNvbnN0IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IDMzNzc4O1xuY29uc3QgUkdCQV9TM1RDX0RYVDVfRm9ybWF0ID0gMzM3Nzk7XG5jb25zdCBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDM1ODQwO1xuY29uc3QgUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAzNTg0MTtcbmNvbnN0IFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDM1ODQyO1xuY29uc3QgUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMzU4NDM7XG5jb25zdCBSR0JfRVRDMV9Gb3JtYXQgPSAzNjE5NjtcbmNvbnN0IFJHQl9FVEMyX0Zvcm1hdCA9IDM3NDkyO1xuY29uc3QgUkdCQV9FVEMyX0VBQ19Gb3JtYXQgPSAzNzQ5NjtcbmNvbnN0IFJHQkFfQVNUQ180eDRfRm9ybWF0ID0gMzc4MDg7XG5jb25zdCBSR0JBX0FTVENfNXg0X0Zvcm1hdCA9IDM3ODA5O1xuY29uc3QgUkdCQV9BU1RDXzV4NV9Gb3JtYXQgPSAzNzgxMDtcbmNvbnN0IFJHQkFfQVNUQ182eDVfRm9ybWF0ID0gMzc4MTE7XG5jb25zdCBSR0JBX0FTVENfNng2X0Zvcm1hdCA9IDM3ODEyO1xuY29uc3QgUkdCQV9BU1RDXzh4NV9Gb3JtYXQgPSAzNzgxMztcbmNvbnN0IFJHQkFfQVNUQ184eDZfRm9ybWF0ID0gMzc4MTQ7XG5jb25zdCBSR0JBX0FTVENfOHg4X0Zvcm1hdCA9IDM3ODE1O1xuY29uc3QgUkdCQV9BU1RDXzEweDVfRm9ybWF0ID0gMzc4MTY7XG5jb25zdCBSR0JBX0FTVENfMTB4Nl9Gb3JtYXQgPSAzNzgxNztcbmNvbnN0IFJHQkFfQVNUQ18xMHg4X0Zvcm1hdCA9IDM3ODE4O1xuY29uc3QgUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCA9IDM3ODE5O1xuY29uc3QgUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdCA9IDM3ODIwO1xuY29uc3QgUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdCA9IDM3ODIxO1xuY29uc3QgUkdCQV9CUFRDX0Zvcm1hdCA9IDM2NDkyO1xuY29uc3QgUkdCX0JQVENfU0lHTkVEX0Zvcm1hdCA9IDM2NDk0O1xuY29uc3QgUkdCX0JQVENfVU5TSUdORURfRm9ybWF0ID0gMzY0OTU7XG5jb25zdCBSRURfUkdUQzFfRm9ybWF0ID0gMzYyODM7XG5jb25zdCBTSUdORURfUkVEX1JHVEMxX0Zvcm1hdCA9IDM2Mjg0O1xuY29uc3QgUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCA9IDM2Mjg1O1xuY29uc3QgU0lHTkVEX1JFRF9HUkVFTl9SR1RDMl9Gb3JtYXQgPSAzNjI4NjtcbmNvbnN0IExvb3BPbmNlID0gMjIwMDtcbmNvbnN0IExvb3BSZXBlYXQgPSAyMjAxO1xuY29uc3QgTG9vcFBpbmdQb25nID0gMjIwMjtcbmNvbnN0IEludGVycG9sYXRlRGlzY3JldGUgPSAyMzAwO1xuY29uc3QgSW50ZXJwb2xhdGVMaW5lYXIgPSAyMzAxO1xuY29uc3QgSW50ZXJwb2xhdGVTbW9vdGggPSAyMzAyO1xuY29uc3QgWmVyb0N1cnZhdHVyZUVuZGluZyA9IDI0MDA7XG5jb25zdCBaZXJvU2xvcGVFbmRpbmcgPSAyNDAxO1xuY29uc3QgV3JhcEFyb3VuZEVuZGluZyA9IDI0MDI7XG5jb25zdCBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGUgPSAyNTAwO1xuY29uc3QgQWRkaXRpdmVBbmltYXRpb25CbGVuZE1vZGUgPSAyNTAxO1xuY29uc3QgVHJpYW5nbGVzRHJhd01vZGUgPSAwO1xuY29uc3QgVHJpYW5nbGVTdHJpcERyYXdNb2RlID0gMTtcbmNvbnN0IFRyaWFuZ2xlRmFuRHJhd01vZGUgPSAyO1xuY29uc3QgQmFzaWNEZXB0aFBhY2tpbmcgPSAzMjAwO1xuY29uc3QgUkdCQURlcHRoUGFja2luZyA9IDMyMDE7XG5jb25zdCBSR0JEZXB0aFBhY2tpbmcgPSAzMjAyO1xuY29uc3QgUkdEZXB0aFBhY2tpbmcgPSAzMjAzO1xuY29uc3QgVGFuZ2VudFNwYWNlTm9ybWFsTWFwID0gMDtcbmNvbnN0IE9iamVjdFNwYWNlTm9ybWFsTWFwID0gMTtcblxuLy8gQ29sb3Igc3BhY2Ugc3RyaW5nIGlkZW50aWZpZXJzLCBtYXRjaGluZyBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDQgYW5kIFdlYkdQVSBuYW1lcyB3aGVyZSBhdmFpbGFibGUuXG5jb25zdCBOb0NvbG9yU3BhY2UgPSAnJztcbmNvbnN0IFNSR0JDb2xvclNwYWNlID0gJ3NyZ2InO1xuY29uc3QgTGluZWFyU1JHQkNvbG9yU3BhY2UgPSAnc3JnYi1saW5lYXInO1xuXG5jb25zdCBMaW5lYXJUcmFuc2ZlciA9ICdsaW5lYXInO1xuY29uc3QgU1JHQlRyYW5zZmVyID0gJ3NyZ2InO1xuXG5jb25zdCBaZXJvU3RlbmNpbE9wID0gMDtcbmNvbnN0IEtlZXBTdGVuY2lsT3AgPSA3NjgwO1xuY29uc3QgUmVwbGFjZVN0ZW5jaWxPcCA9IDc2ODE7XG5jb25zdCBJbmNyZW1lbnRTdGVuY2lsT3AgPSA3NjgyO1xuY29uc3QgRGVjcmVtZW50U3RlbmNpbE9wID0gNzY4MztcbmNvbnN0IEluY3JlbWVudFdyYXBTdGVuY2lsT3AgPSAzNDA1NTtcbmNvbnN0IERlY3JlbWVudFdyYXBTdGVuY2lsT3AgPSAzNDA1NjtcbmNvbnN0IEludmVydFN0ZW5jaWxPcCA9IDUzODY7XG5cbmNvbnN0IE5ldmVyU3RlbmNpbEZ1bmMgPSA1MTI7XG5jb25zdCBMZXNzU3RlbmNpbEZ1bmMgPSA1MTM7XG5jb25zdCBFcXVhbFN0ZW5jaWxGdW5jID0gNTE0O1xuY29uc3QgTGVzc0VxdWFsU3RlbmNpbEZ1bmMgPSA1MTU7XG5jb25zdCBHcmVhdGVyU3RlbmNpbEZ1bmMgPSA1MTY7XG5jb25zdCBOb3RFcXVhbFN0ZW5jaWxGdW5jID0gNTE3O1xuY29uc3QgR3JlYXRlckVxdWFsU3RlbmNpbEZ1bmMgPSA1MTg7XG5jb25zdCBBbHdheXNTdGVuY2lsRnVuYyA9IDUxOTtcblxuY29uc3QgTmV2ZXJDb21wYXJlID0gNTEyO1xuY29uc3QgTGVzc0NvbXBhcmUgPSA1MTM7XG5jb25zdCBFcXVhbENvbXBhcmUgPSA1MTQ7XG5jb25zdCBMZXNzRXF1YWxDb21wYXJlID0gNTE1O1xuY29uc3QgR3JlYXRlckNvbXBhcmUgPSA1MTY7XG5jb25zdCBOb3RFcXVhbENvbXBhcmUgPSA1MTc7XG5jb25zdCBHcmVhdGVyRXF1YWxDb21wYXJlID0gNTE4O1xuY29uc3QgQWx3YXlzQ29tcGFyZSA9IDUxOTtcblxuY29uc3QgU3RhdGljRHJhd1VzYWdlID0gMzUwNDQ7XG5jb25zdCBEeW5hbWljRHJhd1VzYWdlID0gMzUwNDg7XG5jb25zdCBTdHJlYW1EcmF3VXNhZ2UgPSAzNTA0MDtcbmNvbnN0IFN0YXRpY1JlYWRVc2FnZSA9IDM1MDQ1O1xuY29uc3QgRHluYW1pY1JlYWRVc2FnZSA9IDM1MDQ5O1xuY29uc3QgU3RyZWFtUmVhZFVzYWdlID0gMzUwNDE7XG5jb25zdCBTdGF0aWNDb3B5VXNhZ2UgPSAzNTA0NjtcbmNvbnN0IER5bmFtaWNDb3B5VXNhZ2UgPSAzNTA1MDtcbmNvbnN0IFN0cmVhbUNvcHlVc2FnZSA9IDM1MDQyO1xuXG5jb25zdCBHTFNMMSA9ICcxMDAnO1xuY29uc3QgR0xTTDMgPSAnMzAwIGVzJztcblxuY29uc3QgV2ViR0xDb29yZGluYXRlU3lzdGVtID0gMjAwMDtcbmNvbnN0IFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gPSAyMDAxO1xuXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvZXZlbnRkaXNwYXRjaGVyLmpzL1xuICovXG5cbmNsYXNzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0YWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgdGhpcy5fbGlzdGVuZXJzID0ge307XG5cblx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG5cblx0XHR9XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcblxuXHRcdFx0bGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0aGFzRXZlbnRMaXN0ZW5lciggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXG5cdFx0cmV0dXJuIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxO1xuXG5cdH1cblxuXHRyZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0Y29uc3QgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgdHlwZSBdO1xuXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IGluZGV4ID0gbGlzdGVuZXJBcnJheS5pbmRleE9mKCBsaXN0ZW5lciApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0bGlzdGVuZXJBcnJheS5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZGlzcGF0Y2hFdmVudCggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXHRcdGNvbnN0IGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcblxuXHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRldmVudC50YXJnZXQgPSB0aGlzO1xuXG5cdFx0XHQvLyBNYWtlIGEgY29weSwgaW4gY2FzZSBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgd2hpbGUgaXRlcmF0aW5nLlxuXHRcdFx0Y29uc3QgYXJyYXkgPSBsaXN0ZW5lckFycmF5LnNsaWNlKCAwICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0YXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGV2ZW50LnRhcmdldCA9IG51bGw7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmNvbnN0IF9sdXQgPSBbICcwMCcsICcwMScsICcwMicsICcwMycsICcwNCcsICcwNScsICcwNicsICcwNycsICcwOCcsICcwOScsICcwYScsICcwYicsICcwYycsICcwZCcsICcwZScsICcwZicsICcxMCcsICcxMScsICcxMicsICcxMycsICcxNCcsICcxNScsICcxNicsICcxNycsICcxOCcsICcxOScsICcxYScsICcxYicsICcxYycsICcxZCcsICcxZScsICcxZicsICcyMCcsICcyMScsICcyMicsICcyMycsICcyNCcsICcyNScsICcyNicsICcyNycsICcyOCcsICcyOScsICcyYScsICcyYicsICcyYycsICcyZCcsICcyZScsICcyZicsICczMCcsICczMScsICczMicsICczMycsICczNCcsICczNScsICczNicsICczNycsICczOCcsICczOScsICczYScsICczYicsICczYycsICczZCcsICczZScsICczZicsICc0MCcsICc0MScsICc0MicsICc0MycsICc0NCcsICc0NScsICc0NicsICc0NycsICc0OCcsICc0OScsICc0YScsICc0YicsICc0YycsICc0ZCcsICc0ZScsICc0ZicsICc1MCcsICc1MScsICc1MicsICc1MycsICc1NCcsICc1NScsICc1NicsICc1NycsICc1OCcsICc1OScsICc1YScsICc1YicsICc1YycsICc1ZCcsICc1ZScsICc1ZicsICc2MCcsICc2MScsICc2MicsICc2MycsICc2NCcsICc2NScsICc2NicsICc2NycsICc2OCcsICc2OScsICc2YScsICc2YicsICc2YycsICc2ZCcsICc2ZScsICc2ZicsICc3MCcsICc3MScsICc3MicsICc3MycsICc3NCcsICc3NScsICc3NicsICc3NycsICc3OCcsICc3OScsICc3YScsICc3YicsICc3YycsICc3ZCcsICc3ZScsICc3ZicsICc4MCcsICc4MScsICc4MicsICc4MycsICc4NCcsICc4NScsICc4NicsICc4NycsICc4OCcsICc4OScsICc4YScsICc4YicsICc4YycsICc4ZCcsICc4ZScsICc4ZicsICc5MCcsICc5MScsICc5MicsICc5MycsICc5NCcsICc5NScsICc5NicsICc5NycsICc5OCcsICc5OScsICc5YScsICc5YicsICc5YycsICc5ZCcsICc5ZScsICc5ZicsICdhMCcsICdhMScsICdhMicsICdhMycsICdhNCcsICdhNScsICdhNicsICdhNycsICdhOCcsICdhOScsICdhYScsICdhYicsICdhYycsICdhZCcsICdhZScsICdhZicsICdiMCcsICdiMScsICdiMicsICdiMycsICdiNCcsICdiNScsICdiNicsICdiNycsICdiOCcsICdiOScsICdiYScsICdiYicsICdiYycsICdiZCcsICdiZScsICdiZicsICdjMCcsICdjMScsICdjMicsICdjMycsICdjNCcsICdjNScsICdjNicsICdjNycsICdjOCcsICdjOScsICdjYScsICdjYicsICdjYycsICdjZCcsICdjZScsICdjZicsICdkMCcsICdkMScsICdkMicsICdkMycsICdkNCcsICdkNScsICdkNicsICdkNycsICdkOCcsICdkOScsICdkYScsICdkYicsICdkYycsICdkZCcsICdkZScsICdkZicsICdlMCcsICdlMScsICdlMicsICdlMycsICdlNCcsICdlNScsICdlNicsICdlNycsICdlOCcsICdlOScsICdlYScsICdlYicsICdlYycsICdlZCcsICdlZScsICdlZicsICdmMCcsICdmMScsICdmMicsICdmMycsICdmNCcsICdmNScsICdmNicsICdmNycsICdmOCcsICdmOScsICdmYScsICdmYicsICdmYycsICdmZCcsICdmZScsICdmZicgXTtcblxubGV0IF9zZWVkID0gMTIzNDU2NztcblxuXG5jb25zdCBERUcyUkFEID0gTWF0aC5QSSAvIDE4MDtcbmNvbnN0IFJBRDJERUcgPSAxODAgLyBNYXRoLlBJO1xuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9ob3ctdG8tY3JlYXRlLWEtZ3VpZC11dWlkLWluLWphdmFzY3JpcHQvMjE5NjMxMzYjMjE5NjMxMzZcbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcblxuXHRjb25zdCBkMCA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0Y29uc3QgZDEgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdGNvbnN0IGQyID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRjb25zdCBkMyA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0Y29uc3QgdXVpZCA9IF9sdXRbIGQwICYgMHhmZiBdICsgX2x1dFsgZDAgPj4gOCAmIDB4ZmYgXSArIF9sdXRbIGQwID4+IDE2ICYgMHhmZiBdICsgX2x1dFsgZDAgPj4gMjQgJiAweGZmIF0gKyAnLScgK1xuXHRcdFx0X2x1dFsgZDEgJiAweGZmIF0gKyBfbHV0WyBkMSA+PiA4ICYgMHhmZiBdICsgJy0nICsgX2x1dFsgZDEgPj4gMTYgJiAweDBmIHwgMHg0MCBdICsgX2x1dFsgZDEgPj4gMjQgJiAweGZmIF0gKyAnLScgK1xuXHRcdFx0X2x1dFsgZDIgJiAweDNmIHwgMHg4MCBdICsgX2x1dFsgZDIgPj4gOCAmIDB4ZmYgXSArICctJyArIF9sdXRbIGQyID4+IDE2ICYgMHhmZiBdICsgX2x1dFsgZDIgPj4gMjQgJiAweGZmIF0gK1xuXHRcdFx0X2x1dFsgZDMgJiAweGZmIF0gKyBfbHV0WyBkMyA+PiA4ICYgMHhmZiBdICsgX2x1dFsgZDMgPj4gMTYgJiAweGZmIF0gKyBfbHV0WyBkMyA+PiAyNCAmIDB4ZmYgXTtcblxuXHQvLyAudG9Mb3dlckNhc2UoKSBoZXJlIGZsYXR0ZW5zIGNvbmNhdGVuYXRlZCBzdHJpbmdzIHRvIHNhdmUgaGVhcCBtZW1vcnkgc3BhY2UuXG5cdHJldHVybiB1dWlkLnRvTG93ZXJDYXNlKCk7XG5cbn1cblxuZnVuY3Rpb24gY2xhbXAoIHZhbHVlLCBtaW4sIG1heCApIHtcblxuXHRyZXR1cm4gTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgdmFsdWUgKSApO1xuXG59XG5cbi8vIGNvbXB1dGUgZXVjbGlkZWFuIG1vZHVsbyBvZiBtICUgblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuZnVuY3Rpb24gZXVjbGlkZWFuTW9kdWxvKCBuLCBtICkge1xuXG5cdHJldHVybiAoICggbiAlIG0gKSArIG0gKSAlIG07XG5cbn1cblxuLy8gTGluZWFyIG1hcHBpbmcgZnJvbSByYW5nZSA8YTEsIGEyPiB0byByYW5nZSA8YjEsIGIyPlxuZnVuY3Rpb24gbWFwTGluZWFyKCB4LCBhMSwgYTIsIGIxLCBiMiApIHtcblxuXHRyZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcblxufVxuXG4vLyBodHRwczovL3d3dy5nYW1lZGV2Lm5ldC90dXRvcmlhbHMvcHJvZ3JhbW1pbmcvZ2VuZXJhbC1hbmQtZ2FtZXBsYXktcHJvZ3JhbW1pbmcvaW52ZXJzZS1sZXJwLWEtc3VwZXItdXNlZnVsLXlldC1vZnRlbi1vdmVybG9va2VkLWZ1bmN0aW9uLXI1MjMwL1xuZnVuY3Rpb24gaW52ZXJzZUxlcnAoIHgsIHksIHZhbHVlICkge1xuXG5cdGlmICggeCAhPT0geSApIHtcblxuXHRcdHJldHVybiAoIHZhbHVlIC0geCApIC8gKCB5IC0geCApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRyZXR1cm4gMDtcblxuXHR9XG5cbn1cblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb25cbmZ1bmN0aW9uIGxlcnAoIHgsIHksIHQgKSB7XG5cblx0cmV0dXJuICggMSAtIHQgKSAqIHggKyB0ICogeTtcblxufVxuXG4vLyBodHRwOi8vd3d3LnJvcnlkcmlzY29sbC5jb20vMjAxNi8wMy8wNy9mcmFtZS1yYXRlLWluZGVwZW5kZW50LWRhbXBpbmctdXNpbmctbGVycC9cbmZ1bmN0aW9uIGRhbXAoIHgsIHksIGxhbWJkYSwgZHQgKSB7XG5cblx0cmV0dXJuIGxlcnAoIHgsIHksIDEgLSBNYXRoLmV4cCggLSBsYW1iZGEgKiBkdCApICk7XG5cbn1cblxuLy8gaHR0cHM6Ly93d3cuZGVzbW9zLmNvbS9jYWxjdWxhdG9yL3Zjc2pueXo3eDRcbmZ1bmN0aW9uIHBpbmdwb25nKCB4LCBsZW5ndGggPSAxICkge1xuXG5cdHJldHVybiBsZW5ndGggLSBNYXRoLmFicyggZXVjbGlkZWFuTW9kdWxvKCB4LCBsZW5ndGggKiAyICkgLSBsZW5ndGggKTtcblxufVxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcbmZ1bmN0aW9uIHNtb290aHN0ZXAoIHgsIG1pbiwgbWF4ICkge1xuXG5cdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcblx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cblx0cmV0dXJuIHggKiB4ICogKCAzIC0gMiAqIHggKTtcblxufVxuXG5mdW5jdGlvbiBzbW9vdGhlcnN0ZXAoIHgsIG1pbiwgbWF4ICkge1xuXG5cdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcblx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cblx0cmV0dXJuIHggKiB4ICogeCAqICggeCAqICggeCAqIDYgLSAxNSApICsgMTAgKTtcblxufVxuXG4vLyBSYW5kb20gaW50ZWdlciBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5mdW5jdGlvbiByYW5kSW50KCBsb3csIGhpZ2ggKSB7XG5cblx0cmV0dXJuIGxvdyArIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKyAxICkgKTtcblxufVxuXG4vLyBSYW5kb20gZmxvYXQgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuZnVuY3Rpb24gcmFuZEZsb2F0KCBsb3csIGhpZ2ggKSB7XG5cblx0cmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcblxufVxuXG4vLyBSYW5kb20gZmxvYXQgZnJvbSA8LXJhbmdlLzIsIHJhbmdlLzI+IGludGVydmFsXG5mdW5jdGlvbiByYW5kRmxvYXRTcHJlYWQoIHJhbmdlICkge1xuXG5cdHJldHVybiByYW5nZSAqICggMC41IC0gTWF0aC5yYW5kb20oKSApO1xuXG59XG5cbi8vIERldGVybWluaXN0aWMgcHNldWRvLXJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgWyAwLCAxIF1cbmZ1bmN0aW9uIHNlZWRlZFJhbmRvbSggcyApIHtcblxuXHRpZiAoIHMgIT09IHVuZGVmaW5lZCApIF9zZWVkID0gcztcblxuXHQvLyBNdWxiZXJyeTMyIGdlbmVyYXRvclxuXG5cdGxldCB0ID0gX3NlZWQgKz0gMHg2RDJCNzlGNTtcblxuXHR0ID0gTWF0aC5pbXVsKCB0IF4gdCA+Pj4gMTUsIHQgfCAxICk7XG5cblx0dCBePSB0ICsgTWF0aC5pbXVsKCB0IF4gdCA+Pj4gNywgdCB8IDYxICk7XG5cblx0cmV0dXJuICggKCB0IF4gdCA+Pj4gMTQgKSA+Pj4gMCApIC8gNDI5NDk2NzI5NjtcblxufVxuXG5mdW5jdGlvbiBkZWdUb1JhZCggZGVncmVlcyApIHtcblxuXHRyZXR1cm4gZGVncmVlcyAqIERFRzJSQUQ7XG5cbn1cblxuZnVuY3Rpb24gcmFkVG9EZWcoIHJhZGlhbnMgKSB7XG5cblx0cmV0dXJuIHJhZGlhbnMgKiBSQUQyREVHO1xuXG59XG5cbmZ1bmN0aW9uIGlzUG93ZXJPZlR3byggdmFsdWUgKSB7XG5cblx0cmV0dXJuICggdmFsdWUgJiAoIHZhbHVlIC0gMSApICkgPT09IDAgJiYgdmFsdWUgIT09IDA7XG5cbn1cblxuZnVuY3Rpb24gY2VpbFBvd2VyT2ZUd28oIHZhbHVlICkge1xuXG5cdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5jZWlsKCBNYXRoLmxvZyggdmFsdWUgKSAvIE1hdGguTE4yICkgKTtcblxufVxuXG5mdW5jdGlvbiBmbG9vclBvd2VyT2ZUd28oIHZhbHVlICkge1xuXG5cdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5mbG9vciggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XG5cbn1cblxuZnVuY3Rpb24gc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlciggcSwgYSwgYiwgYywgb3JkZXIgKSB7XG5cblx0Ly8gSW50cmluc2ljIFByb3BlciBFdWxlciBBbmdsZXMgLSBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVsZXJfYW5nbGVzXG5cblx0Ly8gcm90YXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBheGVzIGluIHRoZSBvcmRlciBzcGVjaWZpZWQgYnkgJ29yZGVyJ1xuXHQvLyByb3RhdGlvbiBieSBhbmdsZSAnYScgaXMgYXBwbGllZCBmaXJzdCwgdGhlbiBieSBhbmdsZSAnYicsIHRoZW4gYnkgYW5nbGUgJ2MnXG5cdC8vIGFuZ2xlcyBhcmUgaW4gcmFkaWFuc1xuXG5cdGNvbnN0IGNvcyA9IE1hdGguY29zO1xuXHRjb25zdCBzaW4gPSBNYXRoLnNpbjtcblxuXHRjb25zdCBjMiA9IGNvcyggYiAvIDIgKTtcblx0Y29uc3QgczIgPSBzaW4oIGIgLyAyICk7XG5cblx0Y29uc3QgYzEzID0gY29zKCAoIGEgKyBjICkgLyAyICk7XG5cdGNvbnN0IHMxMyA9IHNpbiggKCBhICsgYyApIC8gMiApO1xuXG5cdGNvbnN0IGMxXzMgPSBjb3MoICggYSAtIGMgKSAvIDIgKTtcblx0Y29uc3QgczFfMyA9IHNpbiggKCBhIC0gYyApIC8gMiApO1xuXG5cdGNvbnN0IGMzXzEgPSBjb3MoICggYyAtIGEgKSAvIDIgKTtcblx0Y29uc3QgczNfMSA9IHNpbiggKCBjIC0gYSApIC8gMiApO1xuXG5cdHN3aXRjaCAoIG9yZGVyICkge1xuXG5cdFx0Y2FzZSAnWFlYJzpcblx0XHRcdHEuc2V0KCBjMiAqIHMxMywgczIgKiBjMV8zLCBzMiAqIHMxXzMsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ1laWSc6XG5cdFx0XHRxLnNldCggczIgKiBzMV8zLCBjMiAqIHMxMywgczIgKiBjMV8zLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdaWFonOlxuXHRcdFx0cS5zZXQoIHMyICogYzFfMywgczIgKiBzMV8zLCBjMiAqIHMxMywgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnWFpYJzpcblx0XHRcdHEuc2V0KCBjMiAqIHMxMywgczIgKiBzM18xLCBzMiAqIGMzXzEsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ1lYWSc6XG5cdFx0XHRxLnNldCggczIgKiBjM18xLCBjMiAqIHMxMywgczIgKiBzM18xLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdaWVonOlxuXHRcdFx0cS5zZXQoIHMyICogczNfMSwgczIgKiBjM18xLCBjMiAqIHMxMywgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGhVdGlsczogLnNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAnICsgb3JkZXIgKTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gZGVub3JtYWxpemUoIHZhbHVlLCBhcnJheSApIHtcblxuXHRzd2l0Y2ggKCBhcnJheS5jb25zdHJ1Y3RvciApIHtcblxuXHRcdGNhc2UgRmxvYXQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRjYXNlIFVpbnQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyA0Mjk0OTY3Mjk1LjA7XG5cblx0XHRjYXNlIFVpbnQxNkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyA2NTUzNS4wO1xuXG5cdFx0Y2FzZSBVaW50OEFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyAyNTUuMDtcblxuXHRcdGNhc2UgSW50MzJBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDIxNDc0ODM2NDcuMCwgLSAxLjAgKTtcblxuXHRcdGNhc2UgSW50MTZBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDMyNzY3LjAsIC0gMS4wICk7XG5cblx0XHRjYXNlIEludDhBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDEyNy4wLCAtIDEuMCApO1xuXG5cdFx0ZGVmYXVsdDpcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnSW52YWxpZCBjb21wb25lbnQgdHlwZS4nICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSggdmFsdWUsIGFycmF5ICkge1xuXG5cdHN3aXRjaCAoIGFycmF5LmNvbnN0cnVjdG9yICkge1xuXG5cdFx0Y2FzZSBGbG9hdDMyQXJyYXk6XG5cblx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdGNhc2UgVWludDMyQXJyYXk6XG5cblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCB2YWx1ZSAqIDQyOTQ5NjcyOTUuMCApO1xuXG5cdFx0Y2FzZSBVaW50MTZBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICogNjU1MzUuMCApO1xuXG5cdFx0Y2FzZSBVaW50OEFycmF5OlxuXG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCggdmFsdWUgKiAyNTUuMCApO1xuXG5cdFx0Y2FzZSBJbnQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCggdmFsdWUgKiAyMTQ3NDgzNjQ3LjAgKTtcblxuXHRcdGNhc2UgSW50MTZBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICogMzI3NjcuMCApO1xuXG5cdFx0Y2FzZSBJbnQ4QXJyYXk6XG5cblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCB2YWx1ZSAqIDEyNy4wICk7XG5cblx0XHRkZWZhdWx0OlxuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdJbnZhbGlkIGNvbXBvbmVudCB0eXBlLicgKTtcblxuXHR9XG5cbn1cblxuY29uc3QgTWF0aFV0aWxzID0ge1xuXHRERUcyUkFEOiBERUcyUkFELFxuXHRSQUQyREVHOiBSQUQyREVHLFxuXHRnZW5lcmF0ZVVVSUQ6IGdlbmVyYXRlVVVJRCxcblx0Y2xhbXA6IGNsYW1wLFxuXHRldWNsaWRlYW5Nb2R1bG86IGV1Y2xpZGVhbk1vZHVsbyxcblx0bWFwTGluZWFyOiBtYXBMaW5lYXIsXG5cdGludmVyc2VMZXJwOiBpbnZlcnNlTGVycCxcblx0bGVycDogbGVycCxcblx0ZGFtcDogZGFtcCxcblx0cGluZ3Bvbmc6IHBpbmdwb25nLFxuXHRzbW9vdGhzdGVwOiBzbW9vdGhzdGVwLFxuXHRzbW9vdGhlcnN0ZXA6IHNtb290aGVyc3RlcCxcblx0cmFuZEludDogcmFuZEludCxcblx0cmFuZEZsb2F0OiByYW5kRmxvYXQsXG5cdHJhbmRGbG9hdFNwcmVhZDogcmFuZEZsb2F0U3ByZWFkLFxuXHRzZWVkZWRSYW5kb206IHNlZWRlZFJhbmRvbSxcblx0ZGVnVG9SYWQ6IGRlZ1RvUmFkLFxuXHRyYWRUb0RlZzogcmFkVG9EZWcsXG5cdGlzUG93ZXJPZlR3bzogaXNQb3dlck9mVHdvLFxuXHRjZWlsUG93ZXJPZlR3bzogY2VpbFBvd2VyT2ZUd28sXG5cdGZsb29yUG93ZXJPZlR3bzogZmxvb3JQb3dlck9mVHdvLFxuXHRzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyOiBzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyLFxuXHRub3JtYWxpemU6IG5vcm1hbGl6ZSxcblx0ZGVub3JtYWxpemU6IGRlbm9ybWFsaXplXG59O1xuXG5jbGFzcyBWZWN0b3IyIHtcblxuXHRjb25zdHJ1Y3RvciggeCA9IDAsIHkgPSAwICkge1xuXG5cdFx0VmVjdG9yMi5wcm90b3R5cGUuaXNWZWN0b3IyID0gdHJ1ZTtcblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblxuXHR9XG5cblx0Z2V0IHdpZHRoKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueDtcblxuXHR9XG5cblx0c2V0IHdpZHRoKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMueCA9IHZhbHVlO1xuXG5cdH1cblxuXHRnZXQgaGVpZ2h0KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueTtcblxuXHR9XG5cblx0c2V0IGhlaWdodCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnkgPSB2YWx1ZTtcblxuXHR9XG5cblx0c2V0KCB4LCB5ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xuXHRcdHRoaXMueSA9IHNjYWxhcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYKCB4ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRZKCB5ICkge1xuXG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRDb21wb25lbnQoIGluZGV4LCB2YWx1ZSApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRDb21wb25lbnQoIGluZGV4ICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSApO1xuXG5cdH1cblxuXHRjb3B5KCB2ICkge1xuXG5cdFx0dGhpcy54ID0gdi54O1xuXHRcdHRoaXMueSA9IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGQoIHYgKSB7XG5cblx0XHR0aGlzLnggKz0gdi54O1xuXHRcdHRoaXMueSArPSB2Lnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkU2NhbGFyKCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHM7XG5cdFx0dGhpcy55ICs9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkVmVjdG9ycyggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkU2NhbGVkVmVjdG9yKCB2LCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHYueCAqIHM7XG5cdFx0dGhpcy55ICs9IHYueSAqIHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3ViKCB2ICkge1xuXG5cdFx0dGhpcy54IC09IHYueDtcblx0XHR0aGlzLnkgLT0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YlNjYWxhciggcyApIHtcblxuXHRcdHRoaXMueCAtPSBzO1xuXHRcdHRoaXMueSAtPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YlZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5KCB2ICkge1xuXG5cdFx0dGhpcy54ICo9IHYueDtcblx0XHR0aGlzLnkgKj0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGl2aWRlKCB2ICkge1xuXG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRpdmlkZVNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcblxuXHR9XG5cblx0YXBwbHlNYXRyaXgzKCBtICkge1xuXG5cdFx0Y29uc3QgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdO1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1pbiggdiApIHtcblxuXHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xuXHRcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1heCggdiApIHtcblxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsYW1wKCBtaW4sIG1heCApIHtcblxuXHRcdC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXG5cblx0XHR0aGlzLnggPSBjbGFtcCggdGhpcy54LCBtaW4ueCwgbWF4LnggKTtcblx0XHR0aGlzLnkgPSBjbGFtcCggdGhpcy55LCBtaW4ueSwgbWF4LnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XG5cblx0XHR0aGlzLnggPSBjbGFtcCggdGhpcy54LCBtaW5WYWwsIG1heFZhbCApO1xuXHRcdHRoaXMueSA9IGNsYW1wKCB0aGlzLnksIG1pblZhbCwgbWF4VmFsICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBMZW5ndGgoIG1pbiwgbWF4ICkge1xuXG5cdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggY2xhbXAoIGxlbmd0aCwgbWluLCBtYXggKSApO1xuXG5cdH1cblxuXHRmbG9vcigpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNlaWwoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm91bmQoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3VuZFRvWmVybygpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgudHJ1bmMoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGgudHJ1bmMoIHRoaXMueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG5lZ2F0ZSgpIHtcblxuXHRcdHRoaXMueCA9IC0gdGhpcy54O1xuXHRcdHRoaXMueSA9IC0gdGhpcy55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRvdCggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XG5cblx0fVxuXG5cdGNyb3NzKCB2ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueSAtIHRoaXMueSAqIHYueDtcblxuXHR9XG5cblx0bGVuZ3RoU3EoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xuXG5cdH1cblxuXHRsZW5ndGgoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKTtcblxuXHR9XG5cblx0bWFuaGF0dGFuTGVuZ3RoKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKTtcblxuXHR9XG5cblx0bm9ybWFsaXplKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpIHx8IDEgKTtcblxuXHR9XG5cblx0YW5nbGUoKSB7XG5cblx0XHQvLyBjb21wdXRlcyB0aGUgYW5nbGUgaW4gcmFkaWFucyB3aXRoIHJlc3BlY3QgdG8gdGhlIHBvc2l0aXZlIHgtYXhpc1xuXG5cdFx0Y29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKCAtIHRoaXMueSwgLSB0aGlzLnggKSArIE1hdGguUEk7XG5cblx0XHRyZXR1cm4gYW5nbGU7XG5cblx0fVxuXG5cdGFuZ2xlVG8oIHYgKSB7XG5cblx0XHRjb25zdCBkZW5vbWluYXRvciA9IE1hdGguc3FydCggdGhpcy5sZW5ndGhTcSgpICogdi5sZW5ndGhTcSgpICk7XG5cblx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkgcmV0dXJuIE1hdGguUEkgLyAyO1xuXG5cdFx0Y29uc3QgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gZGVub21pbmF0b3I7XG5cblx0XHQvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xuXG5cdFx0cmV0dXJuIE1hdGguYWNvcyggY2xhbXAoIHRoZXRhLCAtIDEsIDEgKSApO1xuXG5cdH1cblxuXHRkaXN0YW5jZVRvKCB2ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG9TcXVhcmVkKCB2ICkge1xuXG5cdFx0Y29uc3QgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55O1xuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcblxuXHR9XG5cblx0bWFuaGF0dGFuRGlzdGFuY2VUbyggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54IC0gdi54ICkgKyBNYXRoLmFicyggdGhpcy55IC0gdi55ICk7XG5cblx0fVxuXG5cdHNldExlbmd0aCggbGVuZ3RoICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCApO1xuXG5cdH1cblxuXHRsZXJwKCB2LCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRsZXJwVmVjdG9ycyggdjEsIHYyLCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCA9IHYxLnggKyAoIHYyLnggLSB2MS54ICkgKiBhbHBoYTtcblx0XHR0aGlzLnkgPSB2MS55ICsgKCB2Mi55IC0gdjEueSApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXF1YWxzKCB2ICkge1xuXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSApO1xuXG5cdH1cblxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xuXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHRmcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGV4ICkge1xuXG5cdFx0dGhpcy54ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XG5cdFx0dGhpcy55ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm90YXRlQXJvdW5kKCBjZW50ZXIsIGFuZ2xlICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCBhbmdsZSApLCBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XG5cblx0XHRjb25zdCB4ID0gdGhpcy54IC0gY2VudGVyLng7XG5cdFx0Y29uc3QgeSA9IHRoaXMueSAtIGNlbnRlci55O1xuXG5cdFx0dGhpcy54ID0geCAqIGMgLSB5ICogcyArIGNlbnRlci54O1xuXHRcdHRoaXMueSA9IHggKiBzICsgeSAqIGMgKyBjZW50ZXIueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyYW5kb20oKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnJhbmRvbSgpO1xuXHRcdHRoaXMueSA9IE1hdGgucmFuZG9tKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0KlsgU3ltYm9sLml0ZXJhdG9yIF0oKSB7XG5cblx0XHR5aWVsZCB0aGlzLng7XG5cdFx0eWllbGQgdGhpcy55O1xuXG5cdH1cblxufVxuXG5jbGFzcyBNYXRyaXgzIHtcblxuXHRjb25zdHJ1Y3RvciggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApIHtcblxuXHRcdE1hdHJpeDMucHJvdG90eXBlLmlzTWF0cml4MyA9IHRydWU7XG5cblx0XHR0aGlzLmVsZW1lbnRzID0gW1xuXG5cdFx0XHQxLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCxcblx0XHRcdDAsIDAsIDFcblxuXHRcdF07XG5cblx0XHRpZiAoIG4xMSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLnNldCggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXQoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgMSBdID0gbjIxOyB0ZVsgMiBdID0gbjMxO1xuXHRcdHRlWyAzIF0gPSBuMTI7IHRlWyA0IF0gPSBuMjI7IHRlWyA1IF0gPSBuMzI7XG5cdFx0dGVbIDYgXSA9IG4xMzsgdGVbIDcgXSA9IG4yMzsgdGVbIDggXSA9IG4zMztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpZGVudGl0eSgpIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCxcblx0XHRcdDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weSggbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbWVbIDAgXTsgdGVbIDEgXSA9IG1lWyAxIF07IHRlWyAyIF0gPSBtZVsgMiBdO1xuXHRcdHRlWyAzIF0gPSBtZVsgMyBdOyB0ZVsgNCBdID0gbWVbIDQgXTsgdGVbIDUgXSA9IG1lWyA1IF07XG5cdFx0dGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdOyB0ZVsgOCBdID0gbWVbIDggXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHRyYWN0QmFzaXMoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cblx0XHR4QXhpcy5zZXRGcm9tTWF0cml4M0NvbHVtbiggdGhpcywgMCApO1xuXHRcdHlBeGlzLnNldEZyb21NYXRyaXgzQ29sdW1uKCB0aGlzLCAxICk7XG5cdFx0ekF4aXMuc2V0RnJvbU1hdHJpeDNDb2x1bW4oIHRoaXMsIDIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4NCggbSApIHtcblxuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRtZVsgMCBdLCBtZVsgNCBdLCBtZVsgOCBdLFxuXHRcdFx0bWVbIDEgXSwgbWVbIDUgXSwgbWVbIDkgXSxcblx0XHRcdG1lWyAyIF0sIG1lWyA2IF0sIG1lWyAxMCBdXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5KCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xuXG5cdH1cblxuXHRwcmVtdWx0aXBseSggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIHRoaXMgKTtcblxuXHR9XG5cblx0bXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIHtcblxuXHRcdGNvbnN0IGFlID0gYS5lbGVtZW50cztcblx0XHRjb25zdCBiZSA9IGIuZWxlbWVudHM7XG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDMgXSwgYTEzID0gYWVbIDYgXTtcblx0XHRjb25zdCBhMjEgPSBhZVsgMSBdLCBhMjIgPSBhZVsgNCBdLCBhMjMgPSBhZVsgNyBdO1xuXHRcdGNvbnN0IGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA1IF0sIGEzMyA9IGFlWyA4IF07XG5cblx0XHRjb25zdCBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgMyBdLCBiMTMgPSBiZVsgNiBdO1xuXHRcdGNvbnN0IGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA0IF0sIGIyMyA9IGJlWyA3IF07XG5cdFx0Y29uc3QgYjMxID0gYmVbIDIgXSwgYjMyID0gYmVbIDUgXSwgYjMzID0gYmVbIDggXTtcblxuXHRcdHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzE7XG5cdFx0dGVbIDMgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMjtcblx0XHR0ZVsgNiBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzO1xuXG5cdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMTtcblx0XHR0ZVsgNCBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyO1xuXHRcdHRlWyA3IF0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzM7XG5cblx0XHR0ZVsgMiBdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxO1xuXHRcdHRlWyA1IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzI7XG5cdFx0dGVbIDggXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVNjYWxhciggcyApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gKj0gczsgdGVbIDMgXSAqPSBzOyB0ZVsgNiBdICo9IHM7XG5cdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA3IF0gKj0gcztcblx0XHR0ZVsgMiBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDggXSAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRldGVybWluYW50KCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgYSA9IHRlWyAwIF0sIGIgPSB0ZVsgMSBdLCBjID0gdGVbIDIgXSxcblx0XHRcdGQgPSB0ZVsgMyBdLCBlID0gdGVbIDQgXSwgZiA9IHRlWyA1IF0sXG5cdFx0XHRnID0gdGVbIDYgXSwgaCA9IHRlWyA3IF0sIGkgPSB0ZVsgOCBdO1xuXG5cdFx0cmV0dXJuIGEgKiBlICogaSAtIGEgKiBmICogaCAtIGIgKiBkICogaSArIGIgKiBmICogZyArIGMgKiBkICogaCAtIGMgKiBlICogZztcblxuXHR9XG5cblx0aW52ZXJ0KCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzLFxuXG5cdFx0XHRuMTEgPSB0ZVsgMCBdLCBuMjEgPSB0ZVsgMSBdLCBuMzEgPSB0ZVsgMiBdLFxuXHRcdFx0bjEyID0gdGVbIDMgXSwgbjIyID0gdGVbIDQgXSwgbjMyID0gdGVbIDUgXSxcblx0XHRcdG4xMyA9IHRlWyA2IF0sIG4yMyA9IHRlWyA3IF0sIG4zMyA9IHRlWyA4IF0sXG5cblx0XHRcdHQxMSA9IG4zMyAqIG4yMiAtIG4zMiAqIG4yMyxcblx0XHRcdHQxMiA9IG4zMiAqIG4xMyAtIG4zMyAqIG4xMixcblx0XHRcdHQxMyA9IG4yMyAqIG4xMiAtIG4yMiAqIG4xMyxcblxuXHRcdFx0ZGV0ID0gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzO1xuXG5cdFx0aWYgKCBkZXQgPT09IDAgKSByZXR1cm4gdGhpcy5zZXQoIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAgKTtcblxuXHRcdGNvbnN0IGRldEludiA9IDEgLyBkZXQ7XG5cblx0XHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xuXHRcdHRlWyAxIF0gPSAoIG4zMSAqIG4yMyAtIG4zMyAqIG4yMSApICogZGV0SW52O1xuXHRcdHRlWyAyIF0gPSAoIG4zMiAqIG4yMSAtIG4zMSAqIG4yMiApICogZGV0SW52O1xuXG5cdFx0dGVbIDMgXSA9IHQxMiAqIGRldEludjtcblx0XHR0ZVsgNCBdID0gKCBuMzMgKiBuMTEgLSBuMzEgKiBuMTMgKSAqIGRldEludjtcblx0XHR0ZVsgNSBdID0gKCBuMzEgKiBuMTIgLSBuMzIgKiBuMTEgKSAqIGRldEludjtcblxuXHRcdHRlWyA2IF0gPSB0MTMgKiBkZXRJbnY7XG5cdFx0dGVbIDcgXSA9ICggbjIxICogbjEzIC0gbjIzICogbjExICkgKiBkZXRJbnY7XG5cdFx0dGVbIDggXSA9ICggbjIyICogbjExIC0gbjIxICogbjEyICkgKiBkZXRJbnY7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dHJhbnNwb3NlKCkge1xuXG5cdFx0bGV0IHRtcDtcblx0XHRjb25zdCBtID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRtcCA9IG1bIDEgXTsgbVsgMSBdID0gbVsgMyBdOyBtWyAzIF0gPSB0bXA7XG5cdFx0dG1wID0gbVsgMiBdOyBtWyAyIF0gPSBtWyA2IF07IG1bIDYgXSA9IHRtcDtcblx0XHR0bXAgPSBtWyA1IF07IG1bIDUgXSA9IG1bIDcgXTsgbVsgNyBdID0gdG1wO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldE5vcm1hbE1hdHJpeCggbWF0cml4NCApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KCBtYXRyaXg0ICkuaW52ZXJ0KCkudHJhbnNwb3NlKCk7XG5cblx0fVxuXG5cdHRyYW5zcG9zZUludG9BcnJheSggciApIHtcblxuXHRcdGNvbnN0IG0gPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0clsgMCBdID0gbVsgMCBdO1xuXHRcdHJbIDEgXSA9IG1bIDMgXTtcblx0XHRyWyAyIF0gPSBtWyA2IF07XG5cdFx0clsgMyBdID0gbVsgMSBdO1xuXHRcdHJbIDQgXSA9IG1bIDQgXTtcblx0XHRyWyA1IF0gPSBtWyA3IF07XG5cdFx0clsgNiBdID0gbVsgMiBdO1xuXHRcdHJbIDcgXSA9IG1bIDUgXTtcblx0XHRyWyA4IF0gPSBtWyA4IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0VXZUcmFuc2Zvcm0oIHR4LCB0eSwgc3gsIHN5LCByb3RhdGlvbiwgY3gsIGN5ICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCByb3RhdGlvbiApO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbiggcm90YXRpb24gKTtcblxuXHRcdHRoaXMuc2V0KFxuXHRcdFx0c3ggKiBjLCBzeCAqIHMsIC0gc3ggKiAoIGMgKiBjeCArIHMgKiBjeSApICsgY3ggKyB0eCxcblx0XHRcdC0gc3kgKiBzLCBzeSAqIGMsIC0gc3kgKiAoIC0gcyAqIGN4ICsgYyAqIGN5ICkgKyBjeSArIHR5LFxuXHRcdFx0MCwgMCwgMVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Ly9cblxuXHRzY2FsZSggc3gsIHN5ICkge1xuXG5cdFx0dGhpcy5wcmVtdWx0aXBseSggX20zLm1ha2VTY2FsZSggc3gsIHN5ICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGUoIHRoZXRhICkge1xuXG5cdFx0dGhpcy5wcmVtdWx0aXBseSggX20zLm1ha2VSb3RhdGlvbiggLSB0aGV0YSApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dHJhbnNsYXRlKCB0eCwgdHkgKSB7XG5cblx0XHR0aGlzLnByZW11bHRpcGx5KCBfbTMubWFrZVRyYW5zbGF0aW9uKCB0eCwgdHkgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vIGZvciAyRCBUcmFuc2Zvcm1zXG5cblx0bWFrZVRyYW5zbGF0aW9uKCB4LCB5ICkge1xuXG5cdFx0aWYgKCB4LmlzVmVjdG9yMiApIHtcblxuXHRcdFx0dGhpcy5zZXQoXG5cblx0XHRcdFx0MSwgMCwgeC54LFxuXHRcdFx0XHQwLCAxLCB4LnksXG5cdFx0XHRcdDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdDEsIDAsIHgsXG5cdFx0XHRcdDAsIDEsIHksXG5cdFx0XHRcdDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb24oIHRoZXRhICkge1xuXG5cdFx0Ly8gY291bnRlcmNsb2Nrd2lzZVxuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRjLCAtIHMsIDAsXG5cdFx0XHRzLCBjLCAwLFxuXHRcdFx0MCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlU2NhbGUoIHgsIHkgKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0eCwgMCwgMCxcblx0XHRcdDAsIHksIDAsXG5cdFx0XHQwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vXG5cblx0ZXF1YWxzKCBtYXRyaXggKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUgPSBtYXRyaXguZWxlbWVudHM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZWxlbWVudHNbIGkgXSA9IGFycmF5WyBpICsgb2Zmc2V0IF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRlWyAxIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA4IF0gPSB0ZVsgOCBdO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xuXG5cdH1cblxufVxuXG5jb25zdCBfbTMgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCk7XG5cbmZ1bmN0aW9uIGFycmF5TmVlZHNVaW50MzIoIGFycmF5ICkge1xuXG5cdC8vIGFzc3VtZXMgbGFyZ2VyIHZhbHVlcyB1c3VhbGx5IG9uIGxhc3RcblxuXHRmb3IgKCBsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgLS0gaSApIHtcblxuXHRcdGlmICggYXJyYXlbIGkgXSA+PSA2NTUzNSApIHJldHVybiB0cnVlOyAvLyBhY2NvdW50IGZvciBQUklNSVRJVkVfUkVTVEFSVF9GSVhFRF9JTkRFWCwgIzI0NTY1XG5cblx0fVxuXG5cdHJldHVybiBmYWxzZTtcblxufVxuXG5jb25zdCBUWVBFRF9BUlJBWVMgPSB7XG5cdEludDhBcnJheTogSW50OEFycmF5LFxuXHRVaW50OEFycmF5OiBVaW50OEFycmF5LFxuXHRVaW50OENsYW1wZWRBcnJheTogVWludDhDbGFtcGVkQXJyYXksXG5cdEludDE2QXJyYXk6IEludDE2QXJyYXksXG5cdFVpbnQxNkFycmF5OiBVaW50MTZBcnJheSxcblx0SW50MzJBcnJheTogSW50MzJBcnJheSxcblx0VWludDMyQXJyYXk6IFVpbnQzMkFycmF5LFxuXHRGbG9hdDMyQXJyYXk6IEZsb2F0MzJBcnJheSxcblx0RmxvYXQ2NEFycmF5OiBGbG9hdDY0QXJyYXlcbn07XG5cbmZ1bmN0aW9uIGdldFR5cGVkQXJyYXkoIHR5cGUsIGJ1ZmZlciApIHtcblxuXHRyZXR1cm4gbmV3IFRZUEVEX0FSUkFZU1sgdHlwZSBdKCBidWZmZXIgKTtcblxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMoIG5hbWUgKSB7XG5cblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCBuYW1lICk7XG5cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2FudmFzRWxlbWVudCgpIHtcblxuXHRjb25zdCBjYW52YXMgPSBjcmVhdGVFbGVtZW50TlMoICdjYW52YXMnICk7XG5cdGNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0cmV0dXJuIGNhbnZhcztcblxufVxuXG5jb25zdCBfY2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk9uY2UoIG1lc3NhZ2UgKSB7XG5cblx0aWYgKCBtZXNzYWdlIGluIF9jYWNoZSApIHJldHVybjtcblxuXHRfY2FjaGVbIG1lc3NhZ2UgXSA9IHRydWU7XG5cblx0Y29uc29sZS53YXJuKCBtZXNzYWdlICk7XG5cbn1cblxuZnVuY3Rpb24gcHJvYmVBc3luYyggZ2wsIHN5bmMsIGludGVydmFsICkge1xuXG5cdHJldHVybiBuZXcgUHJvbWlzZSggZnVuY3Rpb24gKCByZXNvbHZlLCByZWplY3QgKSB7XG5cblx0XHRmdW5jdGlvbiBwcm9iZSgpIHtcblxuXHRcdFx0c3dpdGNoICggZ2wuY2xpZW50V2FpdFN5bmMoIHN5bmMsIGdsLlNZTkNfRkxVU0hfQ09NTUFORFNfQklULCAwICkgKSB7XG5cblx0XHRcdFx0Y2FzZSBnbC5XQUlUX0ZBSUxFRDpcblx0XHRcdFx0XHRyZWplY3QoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIGdsLlRJTUVPVVRfRVhQSVJFRDpcblx0XHRcdFx0XHRzZXRUaW1lb3V0KCBwcm9iZSwgaW50ZXJ2YWwgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJlc29sdmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0c2V0VGltZW91dCggcHJvYmUsIGludGVydmFsICk7XG5cblx0fSApO1xuXG59XG5cbmZ1bmN0aW9uIHRvTm9ybWFsaXplZFByb2plY3Rpb25NYXRyaXgoIHByb2plY3Rpb25NYXRyaXggKSB7XG5cblx0Y29uc3QgbSA9IHByb2plY3Rpb25NYXRyaXguZWxlbWVudHM7XG5cblx0Ly8gQ29udmVydCBbLTEsIDFdIHRvIFswLCAxXSBwcm9qZWN0aW9uIG1hdHJpeFxuXHRtWyAyIF0gPSAwLjUgKiBtWyAyIF0gKyAwLjUgKiBtWyAzIF07XG5cdG1bIDYgXSA9IDAuNSAqIG1bIDYgXSArIDAuNSAqIG1bIDcgXTtcblx0bVsgMTAgXSA9IDAuNSAqIG1bIDEwIF0gKyAwLjUgKiBtWyAxMSBdO1xuXHRtWyAxNCBdID0gMC41ICogbVsgMTQgXSArIDAuNSAqIG1bIDE1IF07XG5cbn1cblxuZnVuY3Rpb24gdG9SZXZlcnNlZFByb2plY3Rpb25NYXRyaXgoIHByb2plY3Rpb25NYXRyaXggKSB7XG5cblx0Y29uc3QgbSA9IHByb2plY3Rpb25NYXRyaXguZWxlbWVudHM7XG5cdGNvbnN0IGlzUGVyc3BlY3RpdmVNYXRyaXggPSBtWyAxMSBdID09PSAtIDE7XG5cblx0Ly8gUmV2ZXJzZSBbMCwgMV0gcHJvamVjdGlvbiBtYXRyaXhcblx0aWYgKCBpc1BlcnNwZWN0aXZlTWF0cml4ICkge1xuXG5cdFx0bVsgMTAgXSA9IC0gbVsgMTAgXSAtIDE7XG5cdFx0bVsgMTQgXSA9IC0gbVsgMTQgXTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0bVsgMTAgXSA9IC0gbVsgMTAgXTtcblx0XHRtWyAxNCBdID0gLSBtWyAxNCBdICsgMTtcblxuXHR9XG5cbn1cblxuY29uc3QgTElORUFSX1JFQzcwOV9UT19YWVogPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkuc2V0KFxuXHQwLjQxMjM5MDgsIDAuMzU3NTg0MywgMC4xODA0ODA4LFxuXHQwLjIxMjYzOTAsIDAuNzE1MTY4NywgMC4wNzIxOTIzLFxuXHQwLjAxOTMzMDgsIDAuMTE5MTk0OCwgMC45NTA1MzIyXG4pO1xuXG5jb25zdCBYWVpfVE9fTElORUFSX1JFQzcwOSA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKS5zZXQoXG5cdDMuMjQwOTY5OSwgLSAxLjUzNzM4MzIsIC0gMC40OTg2MTA4LFxuXHQtIDAuOTY5MjQzNiwgMS44NzU5Njc1LCAwLjA0MTU1NTEsXG5cdDAuMDU1NjMwMSwgLSAwLjIwMzk3NzAsIDEuMDU2OTcxNVxuKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29sb3JNYW5hZ2VtZW50KCkge1xuXG5cdGNvbnN0IENvbG9yTWFuYWdlbWVudCA9IHtcblxuXHRcdGVuYWJsZWQ6IHRydWUsXG5cblx0XHR3b3JraW5nQ29sb3JTcGFjZTogTGluZWFyU1JHQkNvbG9yU3BhY2UsXG5cblx0XHQvKipcblx0XHQgKiBJbXBsZW1lbnRhdGlvbnMgb2Ygc3VwcG9ydGVkIGNvbG9yIHNwYWNlcy5cblx0XHQgKlxuXHRcdCAqIFJlcXVpcmVkOlxuXHRcdCAqXHQtIHByaW1hcmllczogY2hyb21hdGljaXR5IGNvb3JkaW5hdGVzIFsgcnggcnkgZ3ggZ3kgYnggYnkgXVxuXHRcdCAqXHQtIHdoaXRlUG9pbnQ6IHJlZmVyZW5jZSB3aGl0ZSBbIHggeSBdXG5cdFx0ICpcdC0gdHJhbnNmZXI6IHRyYW5zZmVyIGZ1bmN0aW9uIChwcmUtZGVmaW5lZClcblx0XHQgKlx0LSB0b1hZWjogTWF0cml4MyBSR0IgdG8gWFlaIHRyYW5zZm9ybVxuXHRcdCAqXHQtIGZyb21YWVo6IE1hdHJpeDMgWFlaIHRvIFJHQiB0cmFuc2Zvcm1cblx0XHQgKlx0LSBsdW1pbmFuY2VDb2VmZmljaWVudHM6IFJHQiBsdW1pbmFuY2UgY29lZmZpY2llbnRzXG5cdFx0ICpcblx0XHQgKiBPcHRpb25hbDpcblx0XHQgKiAgLSBvdXRwdXRDb2xvclNwYWNlQ29uZmlnOiB7IGRyYXdpbmdCdWZmZXJDb2xvclNwYWNlOiBDb2xvclNwYWNlIH1cblx0XHQgKiAgLSB3b3JraW5nQ29sb3JTcGFjZUNvbmZpZzogeyB1bnBhY2tDb2xvclNwYWNlOiBDb2xvclNwYWNlIH1cblx0XHQgKlxuXHRcdCAqIFJlZmVyZW5jZTpcblx0XHQgKiAtIGh0dHBzOi8vd3d3LnJ1c3NlbGxjb3R0cmVsbC5jb20vcGhvdG8vbWF0cml4Q2FsY3VsYXRvci5odG1cblx0XHQgKi9cblx0XHRzcGFjZXM6IHt9LFxuXG5cdFx0Y29udmVydDogZnVuY3Rpb24gKCBjb2xvciwgc291cmNlQ29sb3JTcGFjZSwgdGFyZ2V0Q29sb3JTcGFjZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLmVuYWJsZWQgPT09IGZhbHNlIHx8IHNvdXJjZUNvbG9yU3BhY2UgPT09IHRhcmdldENvbG9yU3BhY2UgfHwgISBzb3VyY2VDb2xvclNwYWNlIHx8ICEgdGFyZ2V0Q29sb3JTcGFjZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gY29sb3I7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLnNwYWNlc1sgc291cmNlQ29sb3JTcGFjZSBdLnRyYW5zZmVyID09PSBTUkdCVHJhbnNmZXIgKSB7XG5cblx0XHRcdFx0Y29sb3IuciA9IFNSR0JUb0xpbmVhciggY29sb3IuciApO1xuXHRcdFx0XHRjb2xvci5nID0gU1JHQlRvTGluZWFyKCBjb2xvci5nICk7XG5cdFx0XHRcdGNvbG9yLmIgPSBTUkdCVG9MaW5lYXIoIGNvbG9yLmIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuc3BhY2VzWyBzb3VyY2VDb2xvclNwYWNlIF0ucHJpbWFyaWVzICE9PSB0aGlzLnNwYWNlc1sgdGFyZ2V0Q29sb3JTcGFjZSBdLnByaW1hcmllcyApIHtcblxuXHRcdFx0XHRjb2xvci5hcHBseU1hdHJpeDMoIHRoaXMuc3BhY2VzWyBzb3VyY2VDb2xvclNwYWNlIF0udG9YWVogKTtcblx0XHRcdFx0Y29sb3IuYXBwbHlNYXRyaXgzKCB0aGlzLnNwYWNlc1sgdGFyZ2V0Q29sb3JTcGFjZSBdLmZyb21YWVogKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuc3BhY2VzWyB0YXJnZXRDb2xvclNwYWNlIF0udHJhbnNmZXIgPT09IFNSR0JUcmFuc2ZlciApIHtcblxuXHRcdFx0XHRjb2xvci5yID0gTGluZWFyVG9TUkdCKCBjb2xvci5yICk7XG5cdFx0XHRcdGNvbG9yLmcgPSBMaW5lYXJUb1NSR0IoIGNvbG9yLmcgKTtcblx0XHRcdFx0Y29sb3IuYiA9IExpbmVhclRvU1JHQiggY29sb3IuYiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb2xvcjtcblxuXHRcdH0sXG5cblx0XHRmcm9tV29ya2luZ0NvbG9yU3BhY2U6IGZ1bmN0aW9uICggY29sb3IsIHRhcmdldENvbG9yU3BhY2UgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmNvbnZlcnQoIGNvbG9yLCB0aGlzLndvcmtpbmdDb2xvclNwYWNlLCB0YXJnZXRDb2xvclNwYWNlICk7XG5cblx0XHR9LFxuXG5cdFx0dG9Xb3JraW5nQ29sb3JTcGFjZTogZnVuY3Rpb24gKCBjb2xvciwgc291cmNlQ29sb3JTcGFjZSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuY29udmVydCggY29sb3IsIHNvdXJjZUNvbG9yU3BhY2UsIHRoaXMud29ya2luZ0NvbG9yU3BhY2UgKTtcblxuXHRcdH0sXG5cblx0XHRnZXRQcmltYXJpZXM6IGZ1bmN0aW9uICggY29sb3JTcGFjZSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc3BhY2VzWyBjb2xvclNwYWNlIF0ucHJpbWFyaWVzO1xuXG5cdFx0fSxcblxuXHRcdGdldFRyYW5zZmVyOiBmdW5jdGlvbiAoIGNvbG9yU3BhY2UgKSB7XG5cblx0XHRcdGlmICggY29sb3JTcGFjZSA9PT0gTm9Db2xvclNwYWNlICkgcmV0dXJuIExpbmVhclRyYW5zZmVyO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zcGFjZXNbIGNvbG9yU3BhY2UgXS50cmFuc2ZlcjtcblxuXHRcdH0sXG5cblx0XHRnZXRMdW1pbmFuY2VDb2VmZmljaWVudHM6IGZ1bmN0aW9uICggdGFyZ2V0LCBjb2xvclNwYWNlID0gdGhpcy53b3JraW5nQ29sb3JTcGFjZSApIHtcblxuXHRcdFx0cmV0dXJuIHRhcmdldC5mcm9tQXJyYXkoIHRoaXMuc3BhY2VzWyBjb2xvclNwYWNlIF0ubHVtaW5hbmNlQ29lZmZpY2llbnRzICk7XG5cblx0XHR9LFxuXG5cdFx0ZGVmaW5lOiBmdW5jdGlvbiAoIGNvbG9yU3BhY2VzICkge1xuXG5cdFx0XHRPYmplY3QuYXNzaWduKCB0aGlzLnNwYWNlcywgY29sb3JTcGFjZXMgKTtcblxuXHRcdH0sXG5cblx0XHQvLyBJbnRlcm5hbCBBUElzXG5cblx0XHRfZ2V0TWF0cml4OiBmdW5jdGlvbiAoIHRhcmdldE1hdHJpeCwgc291cmNlQ29sb3JTcGFjZSwgdGFyZ2V0Q29sb3JTcGFjZSApIHtcblxuXHRcdFx0cmV0dXJuIHRhcmdldE1hdHJpeFxuXHRcdFx0XHQuY29weSggdGhpcy5zcGFjZXNbIHNvdXJjZUNvbG9yU3BhY2UgXS50b1hZWiApXG5cdFx0XHRcdC5tdWx0aXBseSggdGhpcy5zcGFjZXNbIHRhcmdldENvbG9yU3BhY2UgXS5mcm9tWFlaICk7XG5cblx0XHR9LFxuXG5cdFx0X2dldERyYXdpbmdCdWZmZXJDb2xvclNwYWNlOiBmdW5jdGlvbiAoIGNvbG9yU3BhY2UgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnNwYWNlc1sgY29sb3JTcGFjZSBdLm91dHB1dENvbG9yU3BhY2VDb25maWcuZHJhd2luZ0J1ZmZlckNvbG9yU3BhY2U7XG5cblx0XHR9LFxuXG5cdFx0X2dldFVucGFja0NvbG9yU3BhY2U6IGZ1bmN0aW9uICggY29sb3JTcGFjZSA9IHRoaXMud29ya2luZ0NvbG9yU3BhY2UgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnNwYWNlc1sgY29sb3JTcGFjZSBdLndvcmtpbmdDb2xvclNwYWNlQ29uZmlnLnVucGFja0NvbG9yU3BhY2U7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqIHNSR0IgZGVmaW5pdGlvbnNcblx0ICovXG5cblx0Y29uc3QgUkVDNzA5X1BSSU1BUklFUyA9IFsgMC42NDAsIDAuMzMwLCAwLjMwMCwgMC42MDAsIDAuMTUwLCAwLjA2MCBdO1xuXHRjb25zdCBSRUM3MDlfTFVNSU5BTkNFX0NPRUZGSUNJRU5UUyA9IFsgMC4yMTI2LCAwLjcxNTIsIDAuMDcyMiBdO1xuXHRjb25zdCBENjUgPSBbIDAuMzEyNywgMC4zMjkwIF07XG5cblx0Q29sb3JNYW5hZ2VtZW50LmRlZmluZSgge1xuXG5cdFx0WyBMaW5lYXJTUkdCQ29sb3JTcGFjZSBdOiB7XG5cdFx0XHRwcmltYXJpZXM6IFJFQzcwOV9QUklNQVJJRVMsXG5cdFx0XHR3aGl0ZVBvaW50OiBENjUsXG5cdFx0XHR0cmFuc2ZlcjogTGluZWFyVHJhbnNmZXIsXG5cdFx0XHR0b1hZWjogTElORUFSX1JFQzcwOV9UT19YWVosXG5cdFx0XHRmcm9tWFlaOiBYWVpfVE9fTElORUFSX1JFQzcwOSxcblx0XHRcdGx1bWluYW5jZUNvZWZmaWNpZW50czogUkVDNzA5X0xVTUlOQU5DRV9DT0VGRklDSUVOVFMsXG5cdFx0XHR3b3JraW5nQ29sb3JTcGFjZUNvbmZpZzogeyB1bnBhY2tDb2xvclNwYWNlOiBTUkdCQ29sb3JTcGFjZSB9LFxuXHRcdFx0b3V0cHV0Q29sb3JTcGFjZUNvbmZpZzogeyBkcmF3aW5nQnVmZmVyQ29sb3JTcGFjZTogU1JHQkNvbG9yU3BhY2UgfVxuXHRcdH0sXG5cblx0XHRbIFNSR0JDb2xvclNwYWNlIF06IHtcblx0XHRcdHByaW1hcmllczogUkVDNzA5X1BSSU1BUklFUyxcblx0XHRcdHdoaXRlUG9pbnQ6IEQ2NSxcblx0XHRcdHRyYW5zZmVyOiBTUkdCVHJhbnNmZXIsXG5cdFx0XHR0b1hZWjogTElORUFSX1JFQzcwOV9UT19YWVosXG5cdFx0XHRmcm9tWFlaOiBYWVpfVE9fTElORUFSX1JFQzcwOSxcblx0XHRcdGx1bWluYW5jZUNvZWZmaWNpZW50czogUkVDNzA5X0xVTUlOQU5DRV9DT0VGRklDSUVOVFMsXG5cdFx0XHRvdXRwdXRDb2xvclNwYWNlQ29uZmlnOiB7IGRyYXdpbmdCdWZmZXJDb2xvclNwYWNlOiBTUkdCQ29sb3JTcGFjZSB9XG5cdFx0fSxcblxuXHR9ICk7XG5cblx0cmV0dXJuIENvbG9yTWFuYWdlbWVudDtcblxufVxuXG5jb25zdCBDb2xvck1hbmFnZW1lbnQgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZUNvbG9yTWFuYWdlbWVudCgpO1xuXG5mdW5jdGlvbiBTUkdCVG9MaW5lYXIoIGMgKSB7XG5cblx0cmV0dXJuICggYyA8IDAuMDQwNDUgKSA/IGMgKiAwLjA3NzM5OTM4MDggOiBNYXRoLnBvdyggYyAqIDAuOTQ3ODY3Mjk4NiArIDAuMDUyMTMyNzAxNCwgMi40ICk7XG5cbn1cblxuZnVuY3Rpb24gTGluZWFyVG9TUkdCKCBjICkge1xuXG5cdHJldHVybiAoIGMgPCAwLjAwMzEzMDggKSA/IGMgKiAxMi45MiA6IDEuMDU1ICogKCBNYXRoLnBvdyggYywgMC40MTY2NiApICkgLSAwLjA1NTtcblxufVxuXG5sZXQgX2NhbnZhcztcblxuY2xhc3MgSW1hZ2VVdGlscyB7XG5cblx0c3RhdGljIGdldERhdGFVUkwoIGltYWdlICkge1xuXG5cdFx0aWYgKCAvXmRhdGE6L2kudGVzdCggaW1hZ2Uuc3JjICkgKSB7XG5cblx0XHRcdHJldHVybiBpbWFnZS5zcmM7XG5cblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cblx0XHRcdHJldHVybiBpbWFnZS5zcmM7XG5cblx0XHR9XG5cblx0XHRsZXQgY2FudmFzO1xuXG5cdFx0aWYgKCBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICkge1xuXG5cdFx0XHRjYW52YXMgPSBpbWFnZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggX2NhbnZhcyA9PT0gdW5kZWZpbmVkICkgX2NhbnZhcyA9IGNyZWF0ZUVsZW1lbnROUyggJ2NhbnZhcycgKTtcblxuXHRcdFx0X2NhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuXHRcdFx0X2NhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cblx0XHRcdGNvbnN0IGNvbnRleHQgPSBfY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcblxuXHRcdFx0aWYgKCBpbWFnZSBpbnN0YW5jZW9mIEltYWdlRGF0YSApIHtcblxuXHRcdFx0XHRjb250ZXh0LnB1dEltYWdlRGF0YSggaW1hZ2UsIDAsIDAgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjYW52YXMgPSBfY2FudmFzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBjYW52YXMud2lkdGggPiAyMDQ4IHx8IGNhbnZhcy5oZWlnaHQgPiAyMDQ4ICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5JbWFnZVV0aWxzLmdldERhdGFVUkw6IEltYWdlIGNvbnZlcnRlZCB0byBqcGcgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMnLCBpbWFnZSApO1xuXG5cdFx0XHRyZXR1cm4gY2FudmFzLnRvRGF0YVVSTCggJ2ltYWdlL2pwZWcnLCAwLjYgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBjYW52YXMudG9EYXRhVVJMKCAnaW1hZ2UvcG5nJyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzdGF0aWMgc1JHQlRvTGluZWFyKCBpbWFnZSApIHtcblxuXHRcdGlmICggKCB0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ICkgfHxcblx0XHRcdCggdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICkgfHxcblx0XHRcdCggdHlwZW9mIEltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwICkgKSB7XG5cblx0XHRcdGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUVsZW1lbnROUyggJ2NhbnZhcycgKTtcblxuXHRcdFx0Y2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXG5cdFx0XHRjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcblx0XHRcdGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xuXG5cdFx0XHRjb25zdCBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSggMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xuXHRcdFx0Y29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRkYXRhWyBpIF0gPSBTUkdCVG9MaW5lYXIoIGRhdGFbIGkgXSAvIDI1NSApICogMjU1O1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnRleHQucHV0SW1hZ2VEYXRhKCBpbWFnZURhdGEsIDAsIDAgKTtcblxuXHRcdFx0cmV0dXJuIGNhbnZhcztcblxuXHRcdH0gZWxzZSBpZiAoIGltYWdlLmRhdGEgKSB7XG5cblx0XHRcdGNvbnN0IGRhdGEgPSBpbWFnZS5kYXRhLnNsaWNlKCAwICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgZGF0YSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICkge1xuXG5cdFx0XHRcdFx0ZGF0YVsgaSBdID0gTWF0aC5mbG9vciggU1JHQlRvTGluZWFyKCBkYXRhWyBpIF0gLyAyNTUgKSAqIDI1NSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBhc3N1bWluZyBmbG9hdFxuXG5cdFx0XHRcdFx0ZGF0YVsgaSBdID0gU1JHQlRvTGluZWFyKCBkYXRhWyBpIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0d2lkdGg6IGltYWdlLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGltYWdlLmhlaWdodFxuXHRcdFx0fTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlVXRpbHMuc1JHQlRvTGluZWFyKCk6IFVuc3VwcG9ydGVkIGltYWdlIHR5cGUuIE5vIGNvbG9yIHNwYWNlIGNvbnZlcnNpb24gYXBwbGllZC4nICk7XG5cdFx0XHRyZXR1cm4gaW1hZ2U7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmxldCBfc291cmNlSWQgPSAwO1xuXG5jbGFzcyBTb3VyY2Uge1xuXG5cdGNvbnN0cnVjdG9yKCBkYXRhID0gbnVsbCApIHtcblxuXHRcdHRoaXMuaXNTb3VyY2UgPSB0cnVlO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBfc291cmNlSWQgKysgfSApO1xuXG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHRcdHRoaXMuZGF0YVJlYWR5ID0gdHJ1ZTtcblxuXHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cblx0fVxuXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xuXG5cdH1cblxuXHR0b0pTT04oIG1ldGEgKSB7XG5cblx0XHRjb25zdCBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZycgKTtcblxuXHRcdGlmICggISBpc1Jvb3RPYmplY3QgJiYgbWV0YS5pbWFnZXNbIHRoaXMudXVpZCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJldHVybiBtZXRhLmltYWdlc1sgdGhpcy51dWlkIF07XG5cblx0XHR9XG5cblx0XHRjb25zdCBvdXRwdXQgPSB7XG5cdFx0XHR1dWlkOiB0aGlzLnV1aWQsXG5cdFx0XHR1cmw6ICcnXG5cdFx0fTtcblxuXHRcdGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG5cblx0XHRpZiAoIGRhdGEgIT09IG51bGwgKSB7XG5cblx0XHRcdGxldCB1cmw7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXG5cdFx0XHRcdC8vIGN1YmUgdGV4dHVyZVxuXG5cdFx0XHRcdHVybCA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGlmICggZGF0YVsgaSBdLmlzRGF0YVRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRcdHVybC5wdXNoKCBzZXJpYWxpemVJbWFnZSggZGF0YVsgaSBdLmltYWdlICkgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHVybC5wdXNoKCBzZXJpYWxpemVJbWFnZSggZGF0YVsgaSBdICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gdGV4dHVyZVxuXG5cdFx0XHRcdHVybCA9IHNlcmlhbGl6ZUltYWdlKCBkYXRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0cHV0LnVybCA9IHVybDtcblxuXHRcdH1cblxuXHRcdGlmICggISBpc1Jvb3RPYmplY3QgKSB7XG5cblx0XHRcdG1ldGEuaW1hZ2VzWyB0aGlzLnV1aWQgXSA9IG91dHB1dDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXQ7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUltYWdlKCBpbWFnZSApIHtcblxuXHRpZiAoICggdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCApIHx8XG5cdFx0KCB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgKSB8fFxuXHRcdCggdHlwZW9mIEltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwICkgKSB7XG5cblx0XHQvLyBkZWZhdWx0IGltYWdlc1xuXG5cdFx0cmV0dXJuIEltYWdlVXRpbHMuZ2V0RGF0YVVSTCggaW1hZ2UgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0aWYgKCBpbWFnZS5kYXRhICkge1xuXG5cdFx0XHQvLyBpbWFnZXMgb2YgRGF0YVRleHR1cmVcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogQXJyYXkuZnJvbSggaW1hZ2UuZGF0YSApLFxuXHRcdFx0XHR3aWR0aDogaW1hZ2Uud2lkdGgsXG5cdFx0XHRcdGhlaWdodDogaW1hZ2UuaGVpZ2h0LFxuXHRcdFx0XHR0eXBlOiBpbWFnZS5kYXRhLmNvbnN0cnVjdG9yLm5hbWVcblx0XHRcdH07XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5UZXh0dXJlOiBVbmFibGUgdG8gc2VyaWFsaXplIFRleHR1cmUuJyApO1xuXHRcdFx0cmV0dXJuIHt9O1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5sZXQgX3RleHR1cmVJZCA9IDA7XG5cbmNsYXNzIFRleHR1cmUgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBpbWFnZSA9IFRleHR1cmUuREVGQVVMVF9JTUFHRSwgbWFwcGluZyA9IFRleHR1cmUuREVGQVVMVF9NQVBQSU5HLCB3cmFwUyA9IENsYW1wVG9FZGdlV3JhcHBpbmcsIHdyYXBUID0gQ2xhbXBUb0VkZ2VXcmFwcGluZywgbWFnRmlsdGVyID0gTGluZWFyRmlsdGVyLCBtaW5GaWx0ZXIgPSBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsIGZvcm1hdCA9IFJHQkFGb3JtYXQsIHR5cGUgPSBVbnNpZ25lZEJ5dGVUeXBlLCBhbmlzb3Ryb3B5ID0gVGV4dHVyZS5ERUZBVUxUX0FOSVNPVFJPUFksIGNvbG9yU3BhY2UgPSBOb0NvbG9yU3BhY2UgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc1RleHR1cmUgPSB0cnVlO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBfdGV4dHVyZUlkICsrIH0gKTtcblxuXHRcdHRoaXMudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cblx0XHR0aGlzLnNvdXJjZSA9IG5ldyBTb3VyY2UoIGltYWdlICk7XG5cdFx0dGhpcy5taXBtYXBzID0gW107XG5cblx0XHR0aGlzLm1hcHBpbmcgPSBtYXBwaW5nO1xuXHRcdHRoaXMuY2hhbm5lbCA9IDA7XG5cblx0XHR0aGlzLndyYXBTID0gd3JhcFM7XG5cdFx0dGhpcy53cmFwVCA9IHdyYXBUO1xuXG5cdFx0dGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXI7XG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXI7XG5cblx0XHR0aGlzLmFuaXNvdHJvcHkgPSBhbmlzb3Ryb3B5O1xuXG5cdFx0dGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG5cdFx0dGhpcy5pbnRlcm5hbEZvcm1hdCA9IG51bGw7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblxuXHRcdHRoaXMub2Zmc2V0ID0gbmV3IFZlY3RvcjIoIDAsIDAgKTtcblx0XHR0aGlzLnJlcGVhdCA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XG5cdFx0dGhpcy5jZW50ZXIgPSBuZXcgVmVjdG9yMiggMCwgMCApO1xuXHRcdHRoaXMucm90YXRpb24gPSAwO1xuXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXgzKCk7XG5cblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHRydWU7XG5cdFx0dGhpcy5wcmVtdWx0aXBseUFscGhhID0gZmFsc2U7XG5cdFx0dGhpcy5mbGlwWSA9IHRydWU7XG5cdFx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSA0O1x0Ly8gdmFsaWQgdmFsdWVzOiAxLCAyLCA0LCA4IChzZWUgaHR0cDovL3d3dy5raHJvbm9zLm9yZy9vcGVuZ2xlcy9zZGsvZG9jcy9tYW4veGh0bWwvZ2xQaXhlbFN0b3JlaS54bWwpXG5cblx0XHR0aGlzLmNvbG9yU3BhY2UgPSBjb2xvclNwYWNlO1xuXG5cdFx0dGhpcy51c2VyRGF0YSA9IHt9O1xuXG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcblx0XHR0aGlzLm9uVXBkYXRlID0gbnVsbDtcblxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0ID0gbnVsbDsgLy8gYXNzaWduIHRleHR1cmUgdG8gYSByZW5kZXIgdGFyZ2V0XG5cdFx0dGhpcy5pc1JlbmRlclRhcmdldFRleHR1cmUgPSBmYWxzZTsgLy8gaW5kaWNhdGVzIHdoZXRoZXIgYSB0ZXh0dXJlIGJlbG9uZ3MgdG8gYSByZW5kZXIgdGFyZ2V0IG9yIG5vdFxuXHRcdHRoaXMucG1yZW1WZXJzaW9uID0gMDsgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyB0ZXh0dXJlIHNob3VsZCBiZSBwcm9jZXNzZWQgYnkgUE1SRU1HZW5lcmF0b3Igb3Igbm90IChvbmx5IHJlbGV2YW50IGZvciByZW5kZXIgdGFyZ2V0IHRleHR1cmVzKVxuXG5cdH1cblxuXHRnZXQgaW1hZ2UoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zb3VyY2UuZGF0YTtcblxuXHR9XG5cblx0c2V0IGltYWdlKCB2YWx1ZSA9IG51bGwgKSB7XG5cblx0XHR0aGlzLnNvdXJjZS5kYXRhID0gdmFsdWU7XG5cblx0fVxuXG5cdHVwZGF0ZU1hdHJpeCgpIHtcblxuXHRcdHRoaXMubWF0cml4LnNldFV2VHJhbnNmb3JtKCB0aGlzLm9mZnNldC54LCB0aGlzLm9mZnNldC55LCB0aGlzLnJlcGVhdC54LCB0aGlzLnJlcGVhdC55LCB0aGlzLnJvdGF0aW9uLCB0aGlzLmNlbnRlci54LCB0aGlzLmNlbnRlci55ICk7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuXHRcdHRoaXMuc291cmNlID0gc291cmNlLnNvdXJjZTtcblx0XHR0aGlzLm1pcG1hcHMgPSBzb3VyY2UubWlwbWFwcy5zbGljZSggMCApO1xuXG5cdFx0dGhpcy5tYXBwaW5nID0gc291cmNlLm1hcHBpbmc7XG5cdFx0dGhpcy5jaGFubmVsID0gc291cmNlLmNoYW5uZWw7XG5cblx0XHR0aGlzLndyYXBTID0gc291cmNlLndyYXBTO1xuXHRcdHRoaXMud3JhcFQgPSBzb3VyY2Uud3JhcFQ7XG5cblx0XHR0aGlzLm1hZ0ZpbHRlciA9IHNvdXJjZS5tYWdGaWx0ZXI7XG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBzb3VyY2UubWluRmlsdGVyO1xuXG5cdFx0dGhpcy5hbmlzb3Ryb3B5ID0gc291cmNlLmFuaXNvdHJvcHk7XG5cblx0XHR0aGlzLmZvcm1hdCA9IHNvdXJjZS5mb3JtYXQ7XG5cdFx0dGhpcy5pbnRlcm5hbEZvcm1hdCA9IHNvdXJjZS5pbnRlcm5hbEZvcm1hdDtcblx0XHR0aGlzLnR5cGUgPSBzb3VyY2UudHlwZTtcblxuXHRcdHRoaXMub2Zmc2V0LmNvcHkoIHNvdXJjZS5vZmZzZXQgKTtcblx0XHR0aGlzLnJlcGVhdC5jb3B5KCBzb3VyY2UucmVwZWF0ICk7XG5cdFx0dGhpcy5jZW50ZXIuY29weSggc291cmNlLmNlbnRlciApO1xuXHRcdHRoaXMucm90YXRpb24gPSBzb3VyY2Uucm90YXRpb247XG5cblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcblx0XHR0aGlzLm1hdHJpeC5jb3B5KCBzb3VyY2UubWF0cml4ICk7XG5cblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHNvdXJjZS5nZW5lcmF0ZU1pcG1hcHM7XG5cdFx0dGhpcy5wcmVtdWx0aXBseUFscGhhID0gc291cmNlLnByZW11bHRpcGx5QWxwaGE7XG5cdFx0dGhpcy5mbGlwWSA9IHNvdXJjZS5mbGlwWTtcblx0XHR0aGlzLnVucGFja0FsaWdubWVudCA9IHNvdXJjZS51bnBhY2tBbGlnbm1lbnQ7XG5cdFx0dGhpcy5jb2xvclNwYWNlID0gc291cmNlLmNvbG9yU3BhY2U7XG5cblx0XHR0aGlzLnJlbmRlclRhcmdldCA9IHNvdXJjZS5yZW5kZXJUYXJnZXQ7XG5cdFx0dGhpcy5pc1JlbmRlclRhcmdldFRleHR1cmUgPSBzb3VyY2UuaXNSZW5kZXJUYXJnZXRUZXh0dXJlO1xuXG5cdFx0dGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBzb3VyY2UudXNlckRhdGEgKSApO1xuXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCBtZXRhICkge1xuXG5cdFx0Y29uc3QgaXNSb290T2JqZWN0ID0gKCBtZXRhID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnICk7XG5cblx0XHRpZiAoICEgaXNSb290T2JqZWN0ICYmIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJldHVybiBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IG91dHB1dCA9IHtcblxuXHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0dmVyc2lvbjogNC42LFxuXHRcdFx0XHR0eXBlOiAnVGV4dHVyZScsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ1RleHR1cmUudG9KU09OJ1xuXHRcdFx0fSxcblxuXHRcdFx0dXVpZDogdGhpcy51dWlkLFxuXHRcdFx0bmFtZTogdGhpcy5uYW1lLFxuXG5cdFx0XHRpbWFnZTogdGhpcy5zb3VyY2UudG9KU09OKCBtZXRhICkudXVpZCxcblxuXHRcdFx0bWFwcGluZzogdGhpcy5tYXBwaW5nLFxuXHRcdFx0Y2hhbm5lbDogdGhpcy5jaGFubmVsLFxuXG5cdFx0XHRyZXBlYXQ6IFsgdGhpcy5yZXBlYXQueCwgdGhpcy5yZXBlYXQueSBdLFxuXHRcdFx0b2Zmc2V0OiBbIHRoaXMub2Zmc2V0LngsIHRoaXMub2Zmc2V0LnkgXSxcblx0XHRcdGNlbnRlcjogWyB0aGlzLmNlbnRlci54LCB0aGlzLmNlbnRlci55IF0sXG5cdFx0XHRyb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcblxuXHRcdFx0d3JhcDogWyB0aGlzLndyYXBTLCB0aGlzLndyYXBUIF0sXG5cblx0XHRcdGZvcm1hdDogdGhpcy5mb3JtYXQsXG5cdFx0XHRpbnRlcm5hbEZvcm1hdDogdGhpcy5pbnRlcm5hbEZvcm1hdCxcblx0XHRcdHR5cGU6IHRoaXMudHlwZSxcblx0XHRcdGNvbG9yU3BhY2U6IHRoaXMuY29sb3JTcGFjZSxcblxuXHRcdFx0bWluRmlsdGVyOiB0aGlzLm1pbkZpbHRlcixcblx0XHRcdG1hZ0ZpbHRlcjogdGhpcy5tYWdGaWx0ZXIsXG5cdFx0XHRhbmlzb3Ryb3B5OiB0aGlzLmFuaXNvdHJvcHksXG5cblx0XHRcdGZsaXBZOiB0aGlzLmZsaXBZLFxuXG5cdFx0XHRnZW5lcmF0ZU1pcG1hcHM6IHRoaXMuZ2VuZXJhdGVNaXBtYXBzLFxuXHRcdFx0cHJlbXVsdGlwbHlBbHBoYTogdGhpcy5wcmVtdWx0aXBseUFscGhhLFxuXHRcdFx0dW5wYWNrQWxpZ25tZW50OiB0aGlzLnVucGFja0FsaWdubWVudFxuXG5cdFx0fTtcblxuXHRcdGlmICggT2JqZWN0LmtleXMoIHRoaXMudXNlckRhdGEgKS5sZW5ndGggPiAwICkgb3V0cHV0LnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcblxuXHRcdGlmICggISBpc1Jvb3RPYmplY3QgKSB7XG5cblx0XHRcdG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdID0gb3V0cHV0O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG5cdH1cblxuXHR0cmFuc2Zvcm1VdiggdXYgKSB7XG5cblx0XHRpZiAoIHRoaXMubWFwcGluZyAhPT0gVVZNYXBwaW5nICkgcmV0dXJuIHV2O1xuXG5cdFx0dXYuYXBwbHlNYXRyaXgzKCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0aWYgKCB1di54IDwgMCB8fCB1di54ID4gMSApIHtcblxuXHRcdFx0c3dpdGNoICggdGhpcy53cmFwUyApIHtcblxuXHRcdFx0XHRjYXNlIFJlcGVhdFdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0dXYueCA9IHV2LnggLSBNYXRoLmZsb29yKCB1di54ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBDbGFtcFRvRWRnZVdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0dXYueCA9IHV2LnggPCAwID8gMCA6IDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggTWF0aC5mbG9vciggdXYueCApICUgMiApID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHR1di54ID0gTWF0aC5jZWlsKCB1di54ICkgLSB1di54O1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dXYueCA9IHV2LnggLSBNYXRoLmZsb29yKCB1di54ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCB1di55IDwgMCB8fCB1di55ID4gMSApIHtcblxuXHRcdFx0c3dpdGNoICggdGhpcy53cmFwVCApIHtcblxuXHRcdFx0XHRjYXNlIFJlcGVhdFdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0dXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKCB1di55ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBDbGFtcFRvRWRnZVdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0dXYueSA9IHV2LnkgPCAwID8gMCA6IDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggTWF0aC5mbG9vciggdXYueSApICUgMiApID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHR1di55ID0gTWF0aC5jZWlsKCB1di55ICkgLSB1di55O1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKCB1di55ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmZsaXBZICkge1xuXG5cdFx0XHR1di55ID0gMSAtIHV2Lnk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdXY7XG5cblx0fVxuXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkge1xuXG5cdFx0XHR0aGlzLnZlcnNpb24gKys7XG5cdFx0XHR0aGlzLnNvdXJjZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldCBuZWVkc1BNUkVNVXBkYXRlKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB7XG5cblx0XHRcdHRoaXMucG1yZW1WZXJzaW9uICsrO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5UZXh0dXJlLkRFRkFVTFRfSU1BR0UgPSBudWxsO1xuVGV4dHVyZS5ERUZBVUxUX01BUFBJTkcgPSBVVk1hcHBpbmc7XG5UZXh0dXJlLkRFRkFVTFRfQU5JU09UUk9QWSA9IDE7XG5cbmNsYXNzIFZlY3RvcjQge1xuXG5cdGNvbnN0cnVjdG9yKCB4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMSApIHtcblxuXHRcdFZlY3RvcjQucHJvdG90eXBlLmlzVmVjdG9yNCA9IHRydWU7XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gejtcblx0XHR0aGlzLncgPSB3O1xuXG5cdH1cblxuXHRnZXQgd2lkdGgoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy56O1xuXG5cdH1cblxuXHRzZXQgd2lkdGgoIHZhbHVlICkge1xuXG5cdFx0dGhpcy56ID0gdmFsdWU7XG5cblx0fVxuXG5cdGdldCBoZWlnaHQoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy53O1xuXG5cdH1cblxuXHRzZXQgaGVpZ2h0KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMudyA9IHZhbHVlO1xuXG5cdH1cblxuXHRzZXQoIHgsIHksIHosIHcgKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gejtcblx0XHR0aGlzLncgPSB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xuXHRcdHRoaXMueSA9IHNjYWxhcjtcblx0XHR0aGlzLnogPSBzY2FsYXI7XG5cdFx0dGhpcy53ID0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFgoIHggKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFkoIHkgKSB7XG5cblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFooIHogKSB7XG5cblx0XHR0aGlzLnogPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFcoIHcgKSB7XG5cblx0XHR0aGlzLncgPSB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldENvbXBvbmVudCggaW5kZXgsIHZhbHVlICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMzogdGhpcy53ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRDb21wb25lbnQoIGluZGV4ICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcblx0XHRcdGNhc2UgMzogcmV0dXJuIHRoaXMudztcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncgKTtcblxuXHR9XG5cblx0Y29weSggdiApIHtcblxuXHRcdHRoaXMueCA9IHYueDtcblx0XHR0aGlzLnkgPSB2Lnk7XG5cdFx0dGhpcy56ID0gdi56O1xuXHRcdHRoaXMudyA9ICggdi53ICE9PSB1bmRlZmluZWQgKSA/IHYudyA6IDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkKCB2ICkge1xuXG5cdFx0dGhpcy54ICs9IHYueDtcblx0XHR0aGlzLnkgKz0gdi55O1xuXHRcdHRoaXMueiArPSB2Lno7XG5cdFx0dGhpcy53ICs9IHYudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGRTY2FsYXIoIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gcztcblx0XHR0aGlzLnkgKz0gcztcblx0XHR0aGlzLnogKz0gcztcblx0XHR0aGlzLncgKz0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGRWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xuXHRcdHRoaXMueSA9IGEueSArIGIueTtcblx0XHR0aGlzLnogPSBhLnogKyBiLno7XG5cdFx0dGhpcy53ID0gYS53ICsgYi53O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFNjYWxlZFZlY3RvciggdiwgcyApIHtcblxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xuXHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXHRcdHRoaXMueiArPSB2LnogKiBzO1xuXHRcdHRoaXMudyArPSB2LncgKiBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YiggdiApIHtcblxuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblx0XHR0aGlzLnogLT0gdi56O1xuXHRcdHRoaXMudyAtPSB2Lnc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3ViU2NhbGFyKCBzICkge1xuXG5cdFx0dGhpcy54IC09IHM7XG5cdFx0dGhpcy55IC09IHM7XG5cdFx0dGhpcy56IC09IHM7XG5cdFx0dGhpcy53IC09IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3ViVmVjdG9ycyggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCAtIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XG5cdFx0dGhpcy56ID0gYS56IC0gYi56O1xuXHRcdHRoaXMudyA9IGEudyAtIGIudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseSggdiApIHtcblxuXHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0dGhpcy55ICo9IHYueTtcblx0XHR0aGlzLnogKj0gdi56O1xuXHRcdHRoaXMudyAqPSB2Lnc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHlTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCAqPSBzY2FsYXI7XG5cdFx0dGhpcy55ICo9IHNjYWxhcjtcblx0XHR0aGlzLnogKj0gc2NhbGFyO1xuXHRcdHRoaXMudyAqPSBzY2FsYXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlNYXRyaXg0KCBtICkge1xuXG5cdFx0Y29uc3QgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMueiwgdyA9IHRoaXMudztcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKiB3O1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogeiArIGVbIDEzIF0gKiB3O1xuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICogdztcblx0XHR0aGlzLncgPSBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSAqIHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGl2aWRlKCB2ICkge1xuXG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXHRcdHRoaXMueiAvPSB2Lno7XG5cdFx0dGhpcy53IC89IHYudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXZpZGVTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XG5cblx0fVxuXG5cdHNldEF4aXNBbmdsZUZyb21RdWF0ZXJuaW9uKCBxICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL3F1YXRlcm5pb25Ub0FuZ2xlL2luZGV4Lmh0bVxuXG5cdFx0Ly8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMudyA9IDIgKiBNYXRoLmFjb3MoIHEudyApO1xuXG5cdFx0Y29uc3QgcyA9IE1hdGguc3FydCggMSAtIHEudyAqIHEudyApO1xuXG5cdFx0aWYgKCBzIDwgMC4wMDAxICkge1xuXG5cdFx0XHR0aGlzLnggPSAxO1xuXHRcdFx0dGhpcy55ID0gMDtcblx0XHRcdHRoaXMueiA9IDA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnggPSBxLnggLyBzO1xuXHRcdFx0dGhpcy55ID0gcS55IC8gcztcblx0XHRcdHRoaXMueiA9IHEueiAvIHM7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0QXhpc0FuZ2xlRnJvbVJvdGF0aW9uTWF0cml4KCBtICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvQW5nbGUvaW5kZXguaHRtXG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0bGV0IGFuZ2xlLCB4LCB5LCB6OyAvLyB2YXJpYWJsZXMgZm9yIHJlc3VsdFxuXHRcdGNvbnN0IGVwc2lsb24gPSAwLjAxLFx0XHQvLyBtYXJnaW4gdG8gYWxsb3cgZm9yIHJvdW5kaW5nIGVycm9yc1xuXHRcdFx0ZXBzaWxvbjIgPSAwLjEsXHRcdC8vIG1hcmdpbiB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIDAgYW5kIDE4MCBkZWdyZWVzXG5cblx0XHRcdHRlID0gbS5lbGVtZW50cyxcblxuXHRcdFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcblx0XHRcdG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF0sXG5cdFx0XHRtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcblxuXHRcdGlmICggKCBNYXRoLmFicyggbTEyIC0gbTIxICkgPCBlcHNpbG9uICkgJiZcblx0XHQgICAgICggTWF0aC5hYnMoIG0xMyAtIG0zMSApIDwgZXBzaWxvbiApICYmXG5cdFx0ICAgICAoIE1hdGguYWJzKCBtMjMgLSBtMzIgKSA8IGVwc2lsb24gKSApIHtcblxuXHRcdFx0Ly8gc2luZ3VsYXJpdHkgZm91bmRcblx0XHRcdC8vIGZpcnN0IGNoZWNrIGZvciBpZGVudGl0eSBtYXRyaXggd2hpY2ggbXVzdCBoYXZlICsxIGZvciBhbGwgdGVybXNcblx0XHRcdC8vIGluIGxlYWRpbmcgZGlhZ29uYWwgYW5kIHplcm8gaW4gb3RoZXIgdGVybXNcblxuXHRcdFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgKyBtMjEgKSA8IGVwc2lsb24yICkgJiZcblx0XHRcdCAgICAgKCBNYXRoLmFicyggbTEzICsgbTMxICkgPCBlcHNpbG9uMiApICYmXG5cdFx0XHQgICAgICggTWF0aC5hYnMoIG0yMyArIG0zMiApIDwgZXBzaWxvbjIgKSAmJlxuXHRcdFx0ICAgICAoIE1hdGguYWJzKCBtMTEgKyBtMjIgKyBtMzMgLSAzICkgPCBlcHNpbG9uMiApICkge1xuXG5cdFx0XHRcdC8vIHRoaXMgc2luZ3VsYXJpdHkgaXMgaWRlbnRpdHkgbWF0cml4IHNvIGFuZ2xlID0gMFxuXG5cdFx0XHRcdHRoaXMuc2V0KCAxLCAwLCAwLCAwICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7IC8vIHplcm8gYW5nbGUsIGFyYml0cmFyeSBheGlzXG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gb3RoZXJ3aXNlIHRoaXMgc2luZ3VsYXJpdHkgaXMgYW5nbGUgPSAxODBcblxuXHRcdFx0YW5nbGUgPSBNYXRoLlBJO1xuXG5cdFx0XHRjb25zdCB4eCA9ICggbTExICsgMSApIC8gMjtcblx0XHRcdGNvbnN0IHl5ID0gKCBtMjIgKyAxICkgLyAyO1xuXHRcdFx0Y29uc3QgenogPSAoIG0zMyArIDEgKSAvIDI7XG5cdFx0XHRjb25zdCB4eSA9ICggbTEyICsgbTIxICkgLyA0O1xuXHRcdFx0Y29uc3QgeHogPSAoIG0xMyArIG0zMSApIC8gNDtcblx0XHRcdGNvbnN0IHl6ID0gKCBtMjMgKyBtMzIgKSAvIDQ7XG5cblx0XHRcdGlmICggKCB4eCA+IHl5ICkgJiYgKCB4eCA+IHp6ICkgKSB7XG5cblx0XHRcdFx0Ly8gbTExIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cblxuXHRcdFx0XHRpZiAoIHh4IDwgZXBzaWxvbiApIHtcblxuXHRcdFx0XHRcdHggPSAwO1xuXHRcdFx0XHRcdHkgPSAwLjcwNzEwNjc4MTtcblx0XHRcdFx0XHR6ID0gMC43MDcxMDY3ODE7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHggPSBNYXRoLnNxcnQoIHh4ICk7XG5cdFx0XHRcdFx0eSA9IHh5IC8geDtcblx0XHRcdFx0XHR6ID0geHogLyB4O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggeXkgPiB6eiApIHtcblxuXHRcdFx0XHQvLyBtMjIgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxuXG5cdFx0XHRcdGlmICggeXkgPCBlcHNpbG9uICkge1xuXG5cdFx0XHRcdFx0eCA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdHkgPSAwO1xuXHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0eSA9IE1hdGguc3FydCggeXkgKTtcblx0XHRcdFx0XHR4ID0geHkgLyB5O1xuXHRcdFx0XHRcdHogPSB5eiAvIHk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIG0zMyBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtIHNvIGJhc2UgcmVzdWx0IG9uIHRoaXNcblxuXHRcdFx0XHRpZiAoIHp6IDwgZXBzaWxvbiApIHtcblxuXHRcdFx0XHRcdHggPSAwLjcwNzEwNjc4MTtcblx0XHRcdFx0XHR5ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0eiA9IDA7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHogPSBNYXRoLnNxcnQoIHp6ICk7XG5cdFx0XHRcdFx0eCA9IHh6IC8gejtcblx0XHRcdFx0XHR5ID0geXogLyB6O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldCggeCwgeSwgeiwgYW5nbGUgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7IC8vIHJldHVybiAxODAgZGVnIHJvdGF0aW9uXG5cblx0XHR9XG5cblx0XHQvLyBhcyB3ZSBoYXZlIHJlYWNoZWQgaGVyZSB0aGVyZSBhcmUgbm8gc2luZ3VsYXJpdGllcyBzbyB3ZSBjYW4gaGFuZGxlIG5vcm1hbGx5XG5cblx0XHRsZXQgcyA9IE1hdGguc3FydCggKCBtMzIgLSBtMjMgKSAqICggbTMyIC0gbTIzICkgK1xuXHRcdFx0KCBtMTMgLSBtMzEgKSAqICggbTEzIC0gbTMxICkgK1xuXHRcdFx0KCBtMjEgLSBtMTIgKSAqICggbTIxIC0gbTEyICkgKTsgLy8gdXNlZCB0byBub3JtYWxpemVcblxuXHRcdGlmICggTWF0aC5hYnMoIHMgKSA8IDAuMDAxICkgcyA9IDE7XG5cblx0XHQvLyBwcmV2ZW50IGRpdmlkZSBieSB6ZXJvLCBzaG91bGQgbm90IGhhcHBlbiBpZiBtYXRyaXggaXMgb3J0aG9nb25hbCBhbmQgc2hvdWxkIGJlXG5cdFx0Ly8gY2F1Z2h0IGJ5IHNpbmd1bGFyaXR5IHRlc3QgYWJvdmUsIGJ1dCBJJ3ZlIGxlZnQgaXQgaW4ganVzdCBpbiBjYXNlXG5cblx0XHR0aGlzLnggPSAoIG0zMiAtIG0yMyApIC8gcztcblx0XHR0aGlzLnkgPSAoIG0xMyAtIG0zMSApIC8gcztcblx0XHR0aGlzLnogPSAoIG0yMSAtIG0xMiApIC8gcztcblx0XHR0aGlzLncgPSBNYXRoLmFjb3MoICggbTExICsgbTIyICsgbTMzIC0gMSApIC8gMiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21NYXRyaXhQb3NpdGlvbiggbSApIHtcblxuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMTIgXTtcblx0XHR0aGlzLnkgPSBlWyAxMyBdO1xuXHRcdHRoaXMueiA9IGVbIDE0IF07XG5cdFx0dGhpcy53ID0gZVsgMTUgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtaW4oIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcblx0XHR0aGlzLncgPSBNYXRoLm1pbiggdGhpcy53LCB2LncgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYXgoIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcblx0XHR0aGlzLncgPSBNYXRoLm1heCggdGhpcy53LCB2LncgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGFtcCggbWluLCBtYXggKSB7XG5cblx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxuXG5cdFx0dGhpcy54ID0gY2xhbXAoIHRoaXMueCwgbWluLngsIG1heC54ICk7XG5cdFx0dGhpcy55ID0gY2xhbXAoIHRoaXMueSwgbWluLnksIG1heC55ICk7XG5cdFx0dGhpcy56ID0gY2xhbXAoIHRoaXMueiwgbWluLnosIG1heC56ICk7XG5cdFx0dGhpcy53ID0gY2xhbXAoIHRoaXMudywgbWluLncsIG1heC53ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0dGhpcy54ID0gY2xhbXAoIHRoaXMueCwgbWluVmFsLCBtYXhWYWwgKTtcblx0XHR0aGlzLnkgPSBjbGFtcCggdGhpcy55LCBtaW5WYWwsIG1heFZhbCApO1xuXHRcdHRoaXMueiA9IGNsYW1wKCB0aGlzLnosIG1pblZhbCwgbWF4VmFsICk7XG5cdFx0dGhpcy53ID0gY2xhbXAoIHRoaXMudywgbWluVmFsLCBtYXhWYWwgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGFtcExlbmd0aCggbWluLCBtYXggKSB7XG5cblx0XHRjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCBsZW5ndGggfHwgMSApLm11bHRpcGx5U2NhbGFyKCBjbGFtcCggbGVuZ3RoLCBtaW4sIG1heCApICk7XG5cblx0fVxuXG5cdGZsb29yKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XG5cdFx0dGhpcy53ID0gTWF0aC5mbG9vciggdGhpcy53ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2VpbCgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuXHRcdHRoaXMudyA9IE1hdGguY2VpbCggdGhpcy53ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm91bmQoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcblx0XHR0aGlzLncgPSBNYXRoLnJvdW5kKCB0aGlzLncgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3VuZFRvWmVybygpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgudHJ1bmMoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGgudHJ1bmMoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGgudHJ1bmMoIHRoaXMueiApO1xuXHRcdHRoaXMudyA9IE1hdGgudHJ1bmMoIHRoaXMudyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG5lZ2F0ZSgpIHtcblxuXHRcdHRoaXMueCA9IC0gdGhpcy54O1xuXHRcdHRoaXMueSA9IC0gdGhpcy55O1xuXHRcdHRoaXMueiA9IC0gdGhpcy56O1xuXHRcdHRoaXMudyA9IC0gdGhpcy53O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRvdCggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2LnogKyB0aGlzLncgKiB2Lnc7XG5cblx0fVxuXG5cdGxlbmd0aFNxKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudztcblxuXHR9XG5cblx0bGVuZ3RoKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53ICk7XG5cblx0fVxuXG5cdG1hbmhhdHRhbkxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICkgKyBNYXRoLmFicyggdGhpcy53ICk7XG5cblx0fVxuXG5cdG5vcm1hbGl6ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSB8fCAxICk7XG5cblx0fVxuXG5cdHNldExlbmd0aCggbGVuZ3RoICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCApO1xuXG5cdH1cblxuXHRsZXJwKCB2LCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xuXHRcdHRoaXMudyArPSAoIHYudyAtIHRoaXMudyApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bGVycFZlY3RvcnMoIHYxLCB2MiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnggPSB2MS54ICsgKCB2Mi54IC0gdjEueCApICogYWxwaGE7XG5cdFx0dGhpcy55ID0gdjEueSArICggdjIueSAtIHYxLnkgKSAqIGFscGhhO1xuXHRcdHRoaXMueiA9IHYxLnogKyAoIHYyLnogLSB2MS56ICkgKiBhbHBoYTtcblx0XHR0aGlzLncgPSB2MS53ICsgKCB2Mi53IC0gdjEudyApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXF1YWxzKCB2ICkge1xuXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgJiYgKCB2LncgPT09IHRoaXMudyApICk7XG5cblx0fVxuXG5cdGZyb21BcnJheSggYXJyYXksIG9mZnNldCA9IDAgKSB7XG5cblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXHRcdHRoaXMudyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMudztcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCApIHtcblxuXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xuXHRcdHRoaXMueiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xuXHRcdHRoaXMudyA9IGF0dHJpYnV0ZS5nZXRXKCBpbmRleCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJhbmRvbSgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucmFuZG9tKCk7XG5cdFx0dGhpcy55ID0gTWF0aC5yYW5kb20oKTtcblx0XHR0aGlzLnogPSBNYXRoLnJhbmRvbSgpO1xuXHRcdHRoaXMudyA9IE1hdGgucmFuZG9tKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0KlsgU3ltYm9sLml0ZXJhdG9yIF0oKSB7XG5cblx0XHR5aWVsZCB0aGlzLng7XG5cdFx0eWllbGQgdGhpcy55O1xuXHRcdHlpZWxkIHRoaXMuejtcblx0XHR5aWVsZCB0aGlzLnc7XG5cblx0fVxuXG59XG5cbi8qXG4gSW4gb3B0aW9ucywgd2UgY2FuIHNwZWNpZnk6XG4gKiBUZXh0dXJlIHBhcmFtZXRlcnMgZm9yIGFuIGF1dG8tZ2VuZXJhdGVkIHRhcmdldCB0ZXh0dXJlXG4gKiBkZXB0aEJ1ZmZlci9zdGVuY2lsQnVmZmVyOiBCb29sZWFucyB0byBpbmRpY2F0ZSBpZiB3ZSBzaG91bGQgZ2VuZXJhdGUgdGhlc2UgYnVmZmVyc1xuKi9cbmNsYXNzIFJlbmRlclRhcmdldCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IoIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNSZW5kZXJUYXJnZXQgPSB0cnVlO1xuXG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHRoaXMuZGVwdGggPSAxO1xuXG5cdFx0dGhpcy5zY2lzc29yID0gbmV3IFZlY3RvcjQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblx0XHR0aGlzLnNjaXNzb3JUZXN0ID0gZmFsc2U7XG5cblx0XHR0aGlzLnZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuXHRcdGNvbnN0IGltYWdlID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBkZXB0aDogMSB9O1xuXG5cdFx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oIHtcblx0XHRcdGdlbmVyYXRlTWlwbWFwczogZmFsc2UsXG5cdFx0XHRpbnRlcm5hbEZvcm1hdDogbnVsbCxcblx0XHRcdG1pbkZpbHRlcjogTGluZWFyRmlsdGVyLFxuXHRcdFx0ZGVwdGhCdWZmZXI6IHRydWUsXG5cdFx0XHRzdGVuY2lsQnVmZmVyOiBmYWxzZSxcblx0XHRcdHJlc29sdmVEZXB0aEJ1ZmZlcjogdHJ1ZSxcblx0XHRcdHJlc29sdmVTdGVuY2lsQnVmZmVyOiB0cnVlLFxuXHRcdFx0ZGVwdGhUZXh0dXJlOiBudWxsLFxuXHRcdFx0c2FtcGxlczogMCxcblx0XHRcdGNvdW50OiAxXG5cdFx0fSwgb3B0aW9ucyApO1xuXG5cdFx0Y29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKCBpbWFnZSwgb3B0aW9ucy5tYXBwaW5nLCBvcHRpb25zLndyYXBTLCBvcHRpb25zLndyYXBULCBvcHRpb25zLm1hZ0ZpbHRlciwgb3B0aW9ucy5taW5GaWx0ZXIsIG9wdGlvbnMuZm9ybWF0LCBvcHRpb25zLnR5cGUsIG9wdGlvbnMuYW5pc290cm9weSwgb3B0aW9ucy5jb2xvclNwYWNlICk7XG5cblx0XHR0ZXh0dXJlLmZsaXBZID0gZmFsc2U7XG5cdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBvcHRpb25zLmdlbmVyYXRlTWlwbWFwcztcblx0XHR0ZXh0dXJlLmludGVybmFsRm9ybWF0ID0gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdDtcblxuXHRcdHRoaXMudGV4dHVyZXMgPSBbXTtcblxuXHRcdGNvbnN0IGNvdW50ID0gb3B0aW9ucy5jb3VudDtcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy50ZXh0dXJlc1sgaSBdID0gdGV4dHVyZS5jbG9uZSgpO1xuXHRcdFx0dGhpcy50ZXh0dXJlc1sgaSBdLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XG5cdFx0XHR0aGlzLnRleHR1cmVzWyBpIF0ucmVuZGVyVGFyZ2V0ID0gdGhpcztcblxuXHRcdH1cblxuXHRcdHRoaXMuZGVwdGhCdWZmZXIgPSBvcHRpb25zLmRlcHRoQnVmZmVyO1xuXHRcdHRoaXMuc3RlbmNpbEJ1ZmZlciA9IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlcjtcblxuXHRcdHRoaXMucmVzb2x2ZURlcHRoQnVmZmVyID0gb3B0aW9ucy5yZXNvbHZlRGVwdGhCdWZmZXI7XG5cdFx0dGhpcy5yZXNvbHZlU3RlbmNpbEJ1ZmZlciA9IG9wdGlvbnMucmVzb2x2ZVN0ZW5jaWxCdWZmZXI7XG5cblx0XHR0aGlzLl9kZXB0aFRleHR1cmUgPSBudWxsO1xuXHRcdHRoaXMuZGVwdGhUZXh0dXJlID0gb3B0aW9ucy5kZXB0aFRleHR1cmU7XG5cblx0XHR0aGlzLnNhbXBsZXMgPSBvcHRpb25zLnNhbXBsZXM7XG5cblx0fVxuXG5cdGdldCB0ZXh0dXJlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudGV4dHVyZXNbIDAgXTtcblxuXHR9XG5cblx0c2V0IHRleHR1cmUoIHZhbHVlICkge1xuXG5cdFx0dGhpcy50ZXh0dXJlc1sgMCBdID0gdmFsdWU7XG5cblx0fVxuXG5cdHNldCBkZXB0aFRleHR1cmUoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2RlcHRoVGV4dHVyZSAhPT0gbnVsbCApIHRoaXMuX2RlcHRoVGV4dHVyZS5yZW5kZXJUYXJnZXQgPSBudWxsO1xuXHRcdGlmICggY3VycmVudCAhPT0gbnVsbCApIGN1cnJlbnQucmVuZGVyVGFyZ2V0ID0gdGhpcztcblxuXHRcdHRoaXMuX2RlcHRoVGV4dHVyZSA9IGN1cnJlbnQ7XG5cblx0fVxuXG5cdGdldCBkZXB0aFRleHR1cmUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fZGVwdGhUZXh0dXJlO1xuXG5cdH1cblxuXHRzZXRTaXplKCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCA9IDEgKSB7XG5cblx0XHRpZiAoIHRoaXMud2lkdGggIT09IHdpZHRoIHx8IHRoaXMuaGVpZ2h0ICE9PSBoZWlnaHQgfHwgdGhpcy5kZXB0aCAhPT0gZGVwdGggKSB7XG5cblx0XHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0dGhpcy5kZXB0aCA9IGRlcHRoO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGhpcy50ZXh0dXJlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLnRleHR1cmVzWyBpIF0uaW1hZ2Uud2lkdGggPSB3aWR0aDtcblx0XHRcdFx0dGhpcy50ZXh0dXJlc1sgaSBdLmltYWdlLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdFx0dGhpcy50ZXh0dXJlc1sgaSBdLmltYWdlLmRlcHRoID0gZGVwdGg7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5kaXNwb3NlKCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnZpZXdwb3J0LnNldCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXHRcdHRoaXMuc2Npc3Nvci5zZXQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMud2lkdGggPSBzb3VyY2Uud2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBzb3VyY2UuaGVpZ2h0O1xuXHRcdHRoaXMuZGVwdGggPSBzb3VyY2UuZGVwdGg7XG5cblx0XHR0aGlzLnNjaXNzb3IuY29weSggc291cmNlLnNjaXNzb3IgKTtcblx0XHR0aGlzLnNjaXNzb3JUZXN0ID0gc291cmNlLnNjaXNzb3JUZXN0O1xuXG5cdFx0dGhpcy52aWV3cG9ydC5jb3B5KCBzb3VyY2Uudmlld3BvcnQgKTtcblxuXHRcdHRoaXMudGV4dHVyZXMubGVuZ3RoID0gMDtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBzb3VyY2UudGV4dHVyZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMudGV4dHVyZXNbIGkgXSA9IHNvdXJjZS50ZXh0dXJlc1sgaSBdLmNsb25lKCk7XG5cdFx0XHR0aGlzLnRleHR1cmVzWyBpIF0uaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gdHJ1ZTtcblx0XHRcdHRoaXMudGV4dHVyZXNbIGkgXS5yZW5kZXJUYXJnZXQgPSB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZW5zdXJlIGltYWdlIG9iamVjdCBpcyBub3Qgc2hhcmVkLCBzZWUgIzIwMzI4XG5cblx0XHRjb25zdCBpbWFnZSA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UudGV4dHVyZS5pbWFnZSApO1xuXHRcdHRoaXMudGV4dHVyZS5zb3VyY2UgPSBuZXcgU291cmNlKCBpbWFnZSApO1xuXG5cdFx0dGhpcy5kZXB0aEJ1ZmZlciA9IHNvdXJjZS5kZXB0aEJ1ZmZlcjtcblx0XHR0aGlzLnN0ZW5jaWxCdWZmZXIgPSBzb3VyY2Uuc3RlbmNpbEJ1ZmZlcjtcblxuXHRcdHRoaXMucmVzb2x2ZURlcHRoQnVmZmVyID0gc291cmNlLnJlc29sdmVEZXB0aEJ1ZmZlcjtcblx0XHR0aGlzLnJlc29sdmVTdGVuY2lsQnVmZmVyID0gc291cmNlLnJlc29sdmVTdGVuY2lsQnVmZmVyO1xuXG5cdFx0aWYgKCBzb3VyY2UuZGVwdGhUZXh0dXJlICE9PSBudWxsICkgdGhpcy5kZXB0aFRleHR1cmUgPSBzb3VyY2UuZGVwdGhUZXh0dXJlLmNsb25lKCk7XG5cblx0XHR0aGlzLnNhbXBsZXMgPSBzb3VyY2Uuc2FtcGxlcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFdlYkdMUmVuZGVyVGFyZ2V0IGV4dGVuZHMgUmVuZGVyVGFyZ2V0IHtcblxuXHRjb25zdHJ1Y3Rvciggd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBvcHRpb25zID0ge30gKSB7XG5cblx0XHRzdXBlciggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApO1xuXG5cdFx0dGhpcy5pc1dlYkdMUmVuZGVyVGFyZ2V0ID0gdHJ1ZTtcblxuXHR9XG5cbn1cblxuY2xhc3MgRGF0YUFycmF5VGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG5cdGNvbnN0cnVjdG9yKCBkYXRhID0gbnVsbCwgd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBkZXB0aCA9IDEgKSB7XG5cblx0XHRzdXBlciggbnVsbCApO1xuXG5cdFx0dGhpcy5pc0RhdGFBcnJheVRleHR1cmUgPSB0cnVlO1xuXG5cdFx0dGhpcy5pbWFnZSA9IHsgZGF0YSwgd2lkdGgsIGhlaWdodCwgZGVwdGggfTtcblxuXHRcdHRoaXMubWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcblx0XHR0aGlzLm1pbkZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG5cblx0XHR0aGlzLndyYXBSID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cdFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuXHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gMTtcblxuXHRcdHRoaXMubGF5ZXJVcGRhdGVzID0gbmV3IFNldCgpO1xuXG5cdH1cblxuXHRhZGRMYXllclVwZGF0ZSggbGF5ZXJJbmRleCApIHtcblxuXHRcdHRoaXMubGF5ZXJVcGRhdGVzLmFkZCggbGF5ZXJJbmRleCApO1xuXG5cdH1cblxuXHRjbGVhckxheWVyVXBkYXRlcygpIHtcblxuXHRcdHRoaXMubGF5ZXJVcGRhdGVzLmNsZWFyKCk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFdlYkdMQXJyYXlSZW5kZXJUYXJnZXQgZXh0ZW5kcyBXZWJHTFJlbmRlclRhcmdldCB7XG5cblx0Y29uc3RydWN0b3IoIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgZGVwdGggPSAxLCBvcHRpb25zID0ge30gKSB7XG5cblx0XHRzdXBlciggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApO1xuXG5cdFx0dGhpcy5pc1dlYkdMQXJyYXlSZW5kZXJUYXJnZXQgPSB0cnVlO1xuXG5cdFx0dGhpcy5kZXB0aCA9IGRlcHRoO1xuXG5cdFx0dGhpcy50ZXh0dXJlID0gbmV3IERhdGFBcnJheVRleHR1cmUoIG51bGwsIHdpZHRoLCBoZWlnaHQsIGRlcHRoICk7XG5cblx0XHR0aGlzLnRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gdHJ1ZTtcblxuXHR9XG5cbn1cblxuY2xhc3MgRGF0YTNEVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG5cdGNvbnN0cnVjdG9yKCBkYXRhID0gbnVsbCwgd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBkZXB0aCA9IDEgKSB7XG5cblx0XHQvLyBXZSdyZSBnb2luZyB0byBhZGQgLnNldFhYWCgpIG1ldGhvZHMgZm9yIHNldHRpbmcgcHJvcGVydGllcyBsYXRlci5cblx0XHQvLyBVc2VycyBjYW4gc3RpbGwgc2V0IGluIERhdGEzRFRleHR1cmUgZGlyZWN0bHkuXG5cdFx0Ly9cblx0XHQvL1x0Y29uc3QgdGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhM0RUZXh0dXJlKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCApO1xuXHRcdC8vIFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gMTY7XG5cdFx0Ly9cblx0XHQvLyBTZWUgIzE0ODM5XG5cblx0XHRzdXBlciggbnVsbCApO1xuXG5cdFx0dGhpcy5pc0RhdGEzRFRleHR1cmUgPSB0cnVlO1xuXG5cdFx0dGhpcy5pbWFnZSA9IHsgZGF0YSwgd2lkdGgsIGhlaWdodCwgZGVwdGggfTtcblxuXHRcdHRoaXMubWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcblx0XHR0aGlzLm1pbkZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG5cblx0XHR0aGlzLndyYXBSID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cdFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuXHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gMTtcblxuXHR9XG5cbn1cblxuY2xhc3MgV2ViR0wzRFJlbmRlclRhcmdldCBleHRlbmRzIFdlYkdMUmVuZGVyVGFyZ2V0IHtcblxuXHRjb25zdHJ1Y3Rvciggd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBkZXB0aCA9IDEsIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdHN1cGVyKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICk7XG5cblx0XHR0aGlzLmlzV2ViR0wzRFJlbmRlclRhcmdldCA9IHRydWU7XG5cblx0XHR0aGlzLmRlcHRoID0gZGVwdGg7XG5cblx0XHR0aGlzLnRleHR1cmUgPSBuZXcgRGF0YTNEVGV4dHVyZSggbnVsbCwgd2lkdGgsIGhlaWdodCwgZGVwdGggKTtcblxuXHRcdHRoaXMudGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0cnVlO1xuXG5cdH1cblxufVxuXG5jbGFzcyBRdWF0ZXJuaW9uIHtcblxuXHRjb25zdHJ1Y3RvciggeCA9IDAsIHkgPSAwLCB6ID0gMCwgdyA9IDEgKSB7XG5cblx0XHR0aGlzLmlzUXVhdGVybmlvbiA9IHRydWU7XG5cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl93ID0gdztcblxuXHR9XG5cblx0c3RhdGljIHNsZXJwRmxhdCggZHN0LCBkc3RPZmZzZXQsIHNyYzAsIHNyY09mZnNldDAsIHNyYzEsIHNyY09mZnNldDEsIHQgKSB7XG5cblx0XHQvLyBmdXp6LWZyZWUsIGFycmF5LWJhc2VkIFF1YXRlcm5pb24gU0xFUlAgb3BlcmF0aW9uXG5cblx0XHRsZXQgeDAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMCBdLFxuXHRcdFx0eTAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMSBdLFxuXHRcdFx0ejAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMiBdLFxuXHRcdFx0dzAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMyBdO1xuXG5cdFx0Y29uc3QgeDEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMCBdLFxuXHRcdFx0eTEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMSBdLFxuXHRcdFx0ejEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMiBdLFxuXHRcdFx0dzEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMyBdO1xuXG5cdFx0aWYgKCB0ID09PSAwICkge1xuXG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDAgXSA9IHgwO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAxIF0gPSB5MDtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMiBdID0gejA7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDMgXSA9IHcwO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0ID09PSAxICkge1xuXG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDAgXSA9IHgxO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAxIF0gPSB5MTtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMiBdID0gejE7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDMgXSA9IHcxO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB3MCAhPT0gdzEgfHwgeDAgIT09IHgxIHx8IHkwICE9PSB5MSB8fCB6MCAhPT0gejEgKSB7XG5cblx0XHRcdGxldCBzID0gMSAtIHQ7XG5cdFx0XHRjb25zdCBjb3MgPSB4MCAqIHgxICsgeTAgKiB5MSArIHowICogejEgKyB3MCAqIHcxLFxuXHRcdFx0XHRkaXIgPSAoIGNvcyA+PSAwID8gMSA6IC0gMSApLFxuXHRcdFx0XHRzcXJTaW4gPSAxIC0gY29zICogY29zO1xuXG5cdFx0XHQvLyBTa2lwIHRoZSBTbGVycCBmb3IgdGlueSBzdGVwcyB0byBhdm9pZCBudW1lcmljIHByb2JsZW1zOlxuXHRcdFx0aWYgKCBzcXJTaW4gPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRjb25zdCBzaW4gPSBNYXRoLnNxcnQoIHNxclNpbiApLFxuXHRcdFx0XHRcdGxlbiA9IE1hdGguYXRhbjIoIHNpbiwgY29zICogZGlyICk7XG5cblx0XHRcdFx0cyA9IE1hdGguc2luKCBzICogbGVuICkgLyBzaW47XG5cdFx0XHRcdHQgPSBNYXRoLnNpbiggdCAqIGxlbiApIC8gc2luO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHREaXIgPSB0ICogZGlyO1xuXG5cdFx0XHR4MCA9IHgwICogcyArIHgxICogdERpcjtcblx0XHRcdHkwID0geTAgKiBzICsgeTEgKiB0RGlyO1xuXHRcdFx0ejAgPSB6MCAqIHMgKyB6MSAqIHREaXI7XG5cdFx0XHR3MCA9IHcwICogcyArIHcxICogdERpcjtcblxuXHRcdFx0Ly8gTm9ybWFsaXplIGluIGNhc2Ugd2UganVzdCBkaWQgYSBsZXJwOlxuXHRcdFx0aWYgKCBzID09PSAxIC0gdCApIHtcblxuXHRcdFx0XHRjb25zdCBmID0gMSAvIE1hdGguc3FydCggeDAgKiB4MCArIHkwICogeTAgKyB6MCAqIHowICsgdzAgKiB3MCApO1xuXG5cdFx0XHRcdHgwICo9IGY7XG5cdFx0XHRcdHkwICo9IGY7XG5cdFx0XHRcdHowICo9IGY7XG5cdFx0XHRcdHcwICo9IGY7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGRzdFsgZHN0T2Zmc2V0IF0gPSB4MDtcblx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkwO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMiBdID0gejA7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MDtcblxuXHR9XG5cblx0c3RhdGljIG11bHRpcGx5UXVhdGVybmlvbnNGbGF0KCBkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSApIHtcblxuXHRcdGNvbnN0IHgwID0gc3JjMFsgc3JjT2Zmc2V0MCBdO1xuXHRcdGNvbnN0IHkwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDEgXTtcblx0XHRjb25zdCB6MCA9IHNyYzBbIHNyY09mZnNldDAgKyAyIF07XG5cdFx0Y29uc3QgdzAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMyBdO1xuXG5cdFx0Y29uc3QgeDEgPSBzcmMxWyBzcmNPZmZzZXQxIF07XG5cdFx0Y29uc3QgeTEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMSBdO1xuXHRcdGNvbnN0IHoxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDIgXTtcblx0XHRjb25zdCB3MSA9IHNyYzFbIHNyY09mZnNldDEgKyAzIF07XG5cblx0XHRkc3RbIGRzdE9mZnNldCBdID0geDAgKiB3MSArIHcwICogeDEgKyB5MCAqIHoxIC0gejAgKiB5MTtcblx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkwICogdzEgKyB3MCAqIHkxICsgejAgKiB4MSAtIHgwICogejE7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MCAqIHcxICsgdzAgKiB6MSArIHgwICogeTEgLSB5MCAqIHgxO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzAgKiB3MSAtIHgwICogeDEgLSB5MCAqIHkxIC0gejAgKiB6MTtcblxuXHRcdHJldHVybiBkc3Q7XG5cblx0fVxuXG5cdGdldCB4KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3g7XG5cblx0fVxuXG5cdHNldCB4KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ggPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdGdldCB5KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cblx0fVxuXG5cdHNldCB5KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3kgPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdGdldCB6KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3o7XG5cblx0fVxuXG5cdHNldCB6KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ogPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdGdldCB3KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3c7XG5cblx0fVxuXG5cdHNldCB3KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3cgPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdHNldCggeCwgeSwgeiwgdyApIHtcblxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3ogPSB6O1xuXHRcdHRoaXMuX3cgPSB3O1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl93ICk7XG5cblx0fVxuXG5cdGNvcHkoIHF1YXRlcm5pb24gKSB7XG5cblx0XHR0aGlzLl94ID0gcXVhdGVybmlvbi54O1xuXHRcdHRoaXMuX3kgPSBxdWF0ZXJuaW9uLnk7XG5cdFx0dGhpcy5feiA9IHF1YXRlcm5pb24uejtcblx0XHR0aGlzLl93ID0gcXVhdGVybmlvbi53O1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21FdWxlciggZXVsZXIsIHVwZGF0ZSA9IHRydWUgKSB7XG5cblx0XHRjb25zdCB4ID0gZXVsZXIuX3gsIHkgPSBldWxlci5feSwgeiA9IGV1bGVyLl96LCBvcmRlciA9IGV1bGVyLl9vcmRlcjtcblxuXHRcdC8vIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS9cblx0XHQvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xuXHRcdC8vXHRjb250ZW50L1NwaW5DYWxjLm1cblxuXHRcdGNvbnN0IGNvcyA9IE1hdGguY29zO1xuXHRcdGNvbnN0IHNpbiA9IE1hdGguc2luO1xuXG5cdFx0Y29uc3QgYzEgPSBjb3MoIHggLyAyICk7XG5cdFx0Y29uc3QgYzIgPSBjb3MoIHkgLyAyICk7XG5cdFx0Y29uc3QgYzMgPSBjb3MoIHogLyAyICk7XG5cblx0XHRjb25zdCBzMSA9IHNpbiggeCAvIDIgKTtcblx0XHRjb25zdCBzMiA9IHNpbiggeSAvIDIgKTtcblx0XHRjb25zdCBzMyA9IHNpbiggeiAvIDIgKTtcblxuXHRcdHN3aXRjaCAoIG9yZGVyICkge1xuXG5cdFx0XHRjYXNlICdYWVonOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVhaJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1pYWSc6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWVgnOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVpYJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1haWSc6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAuc2V0RnJvbUV1bGVyKCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogJyArIG9yZGVyICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHVwZGF0ZSA9PT0gdHJ1ZSApIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9hbmdsZVRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuXHRcdC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXG5cblx0XHRjb25zdCBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsIHMgPSBNYXRoLnNpbiggaGFsZkFuZ2xlICk7XG5cblx0XHR0aGlzLl94ID0gYXhpcy54ICogcztcblx0XHR0aGlzLl95ID0gYXhpcy55ICogcztcblx0XHR0aGlzLl96ID0gYXhpcy56ICogcztcblx0XHR0aGlzLl93ID0gTWF0aC5jb3MoIGhhbGZBbmdsZSApO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApIHtcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0Y29uc3QgdGUgPSBtLmVsZW1lbnRzLFxuXG5cdFx0XHRtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdLFxuXHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcblx0XHRcdG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdLFxuXG5cdFx0XHR0cmFjZSA9IG0xMSArIG0yMiArIG0zMztcblxuXHRcdGlmICggdHJhY2UgPiAwICkge1xuXG5cdFx0XHRjb25zdCBzID0gMC41IC8gTWF0aC5zcXJ0KCB0cmFjZSArIDEuMCApO1xuXG5cdFx0XHR0aGlzLl93ID0gMC4yNSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKCBtMzIgLSBtMjMgKSAqIHM7XG5cdFx0XHR0aGlzLl95ID0gKCBtMTMgLSBtMzEgKSAqIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XG5cblx0XHR9IGVsc2UgaWYgKCBtMTEgPiBtMjIgJiYgbTExID4gbTMzICkge1xuXG5cdFx0XHRjb25zdCBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMTEgLSBtMjIgLSBtMzMgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTMyIC0gbTIzICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9IDAuMjUgKiBzO1xuXHRcdFx0dGhpcy5feSA9ICggbTEyICsgbTIxICkgLyBzO1xuXHRcdFx0dGhpcy5feiA9ICggbTEzICsgbTMxICkgLyBzO1xuXG5cdFx0fSBlbHNlIGlmICggbTIyID4gbTMzICkge1xuXG5cdFx0XHRjb25zdCBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMjIgLSBtMTEgLSBtMzMgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTEzIC0gbTMxICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9ICggbTEyICsgbTIxICkgLyBzO1xuXHRcdFx0dGhpcy5feSA9IDAuMjUgKiBzO1xuXHRcdFx0dGhpcy5feiA9ICggbTIzICsgbTMyICkgLyBzO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3QgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTMzIC0gbTExIC0gbTIyICk7XG5cblx0XHRcdHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcblx0XHRcdHRoaXMuX3ggPSAoIG0xMyArIG0zMSApIC8gcztcblx0XHRcdHRoaXMuX3kgPSAoIG0yMyArIG0zMiApIC8gcztcblx0XHRcdHRoaXMuX3ogPSAwLjI1ICogcztcblxuXHRcdH1cblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tVW5pdFZlY3RvcnMoIHZGcm9tLCB2VG8gKSB7XG5cblx0XHQvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcblxuXHRcdGxldCByID0gdkZyb20uZG90KCB2VG8gKSArIDE7XG5cblx0XHRpZiAoIHIgPCBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0Ly8gdkZyb20gYW5kIHZUbyBwb2ludCBpbiBvcHBvc2l0ZSBkaXJlY3Rpb25zXG5cblx0XHRcdHIgPSAwO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSAtIHZGcm9tLnk7XG5cdFx0XHRcdHRoaXMuX3kgPSB2RnJvbS54O1xuXHRcdFx0XHR0aGlzLl96ID0gMDtcblx0XHRcdFx0dGhpcy5fdyA9IHI7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdHRoaXMuX3kgPSAtIHZGcm9tLno7XG5cdFx0XHRcdHRoaXMuX3ogPSB2RnJvbS55O1xuXHRcdFx0XHR0aGlzLl93ID0gcjtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7IC8vIGlubGluZWQgdG8gYXZvaWQgY3ljbGljIGRlcGVuZGVuY3kgb24gVmVjdG9yM1xuXG5cdFx0XHR0aGlzLl94ID0gdkZyb20ueSAqIHZUby56IC0gdkZyb20ueiAqIHZUby55O1xuXHRcdFx0dGhpcy5feSA9IHZGcm9tLnogKiB2VG8ueCAtIHZGcm9tLnggKiB2VG8uejtcblx0XHRcdHRoaXMuX3ogPSB2RnJvbS54ICogdlRvLnkgLSB2RnJvbS55ICogdlRvLng7XG5cdFx0XHR0aGlzLl93ID0gcjtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xuXG5cdH1cblxuXHRhbmdsZVRvKCBxICkge1xuXG5cdFx0cmV0dXJuIDIgKiBNYXRoLmFjb3MoIE1hdGguYWJzKCBjbGFtcCggdGhpcy5kb3QoIHEgKSwgLSAxLCAxICkgKSApO1xuXG5cdH1cblxuXHRyb3RhdGVUb3dhcmRzKCBxLCBzdGVwICkge1xuXG5cdFx0Y29uc3QgYW5nbGUgPSB0aGlzLmFuZ2xlVG8oIHEgKTtcblxuXHRcdGlmICggYW5nbGUgPT09IDAgKSByZXR1cm4gdGhpcztcblxuXHRcdGNvbnN0IHQgPSBNYXRoLm1pbiggMSwgc3RlcCAvIGFuZ2xlICk7XG5cblx0XHR0aGlzLnNsZXJwKCBxLCB0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aWRlbnRpdHkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoIDAsIDAsIDAsIDEgKTtcblxuXHR9XG5cblx0aW52ZXJ0KCkge1xuXG5cdFx0Ly8gcXVhdGVybmlvbiBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcblxuXHRcdHJldHVybiB0aGlzLmNvbmp1Z2F0ZSgpO1xuXG5cdH1cblxuXHRjb25qdWdhdGUoKSB7XG5cblx0XHR0aGlzLl94ICo9IC0gMTtcblx0XHR0aGlzLl95ICo9IC0gMTtcblx0XHR0aGlzLl96ICo9IC0gMTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkb3QoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feCAqIHYuX3ggKyB0aGlzLl95ICogdi5feSArIHRoaXMuX3ogKiB2Ll96ICsgdGhpcy5fdyAqIHYuX3c7XG5cblx0fVxuXG5cdGxlbmd0aFNxKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93O1xuXG5cdH1cblxuXHRsZW5ndGgoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyApO1xuXG5cdH1cblxuXHRub3JtYWxpemUoKSB7XG5cblx0XHRsZXQgbCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRpZiAoIGwgPT09IDAgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHR0aGlzLl96ID0gMDtcblx0XHRcdHRoaXMuX3cgPSAxO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bCA9IDEgLyBsO1xuXG5cdFx0XHR0aGlzLl94ID0gdGhpcy5feCAqIGw7XG5cdFx0XHR0aGlzLl95ID0gdGhpcy5feSAqIGw7XG5cdFx0XHR0aGlzLl96ID0gdGhpcy5feiAqIGw7XG5cdFx0XHR0aGlzLl93ID0gdGhpcy5fdyAqIGw7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHkoIHEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XG5cblx0fVxuXG5cdHByZW11bHRpcGx5KCBxICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgdGhpcyApO1xuXG5cdH1cblxuXHRtdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkge1xuXG5cdFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXG5cblx0XHRjb25zdCBxYXggPSBhLl94LCBxYXkgPSBhLl95LCBxYXogPSBhLl96LCBxYXcgPSBhLl93O1xuXHRcdGNvbnN0IHFieCA9IGIuX3gsIHFieSA9IGIuX3ksIHFieiA9IGIuX3osIHFidyA9IGIuX3c7XG5cblx0XHR0aGlzLl94ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xuXHRcdHRoaXMuX3kgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XG5cdFx0dGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcblx0XHR0aGlzLl93ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNsZXJwKCBxYiwgdCApIHtcblxuXHRcdGlmICggdCA9PT0gMCApIHJldHVybiB0aGlzO1xuXHRcdGlmICggdCA9PT0gMSApIHJldHVybiB0aGlzLmNvcHkoIHFiICk7XG5cblx0XHRjb25zdCB4ID0gdGhpcy5feCwgeSA9IHRoaXMuX3ksIHogPSB0aGlzLl96LCB3ID0gdGhpcy5fdztcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXG5cblx0XHRsZXQgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xuXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPCAwICkge1xuXG5cdFx0XHR0aGlzLl93ID0gLSBxYi5fdztcblx0XHRcdHRoaXMuX3ggPSAtIHFiLl94O1xuXHRcdFx0dGhpcy5feSA9IC0gcWIuX3k7XG5cdFx0XHR0aGlzLl96ID0gLSBxYi5fejtcblxuXHRcdFx0Y29zSGFsZlRoZXRhID0gLSBjb3NIYWxmVGhldGE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmNvcHkoIHFiICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGNvc0hhbGZUaGV0YSA+PSAxLjAgKSB7XG5cblx0XHRcdHRoaXMuX3cgPSB3O1xuXHRcdFx0dGhpcy5feCA9IHg7XG5cdFx0XHR0aGlzLl95ID0geTtcblx0XHRcdHRoaXMuX3ogPSB6O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGNvbnN0IHNxclNpbkhhbGZUaGV0YSA9IDEuMCAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YTtcblxuXHRcdGlmICggc3FyU2luSGFsZlRoZXRhIDw9IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRjb25zdCBzID0gMSAtIHQ7XG5cdFx0XHR0aGlzLl93ID0gcyAqIHcgKyB0ICogdGhpcy5fdztcblx0XHRcdHRoaXMuX3ggPSBzICogeCArIHQgKiB0aGlzLl94O1xuXHRcdFx0dGhpcy5feSA9IHMgKiB5ICsgdCAqIHRoaXMuX3k7XG5cdFx0XHR0aGlzLl96ID0gcyAqIHogKyB0ICogdGhpcy5fejtcblxuXHRcdFx0dGhpcy5ub3JtYWxpemUoKTsgLy8gbm9ybWFsaXplIGNhbGxzIF9vbkNoYW5nZUNhbGxiYWNrKClcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRjb25zdCBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIHNxclNpbkhhbGZUaGV0YSApO1xuXHRcdGNvbnN0IGhhbGZUaGV0YSA9IE1hdGguYXRhbjIoIHNpbkhhbGZUaGV0YSwgY29zSGFsZlRoZXRhICk7XG5cdFx0Y29uc3QgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxuXHRcdFx0cmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcblxuXHRcdHRoaXMuX3cgPSAoIHcgKiByYXRpb0EgKyB0aGlzLl93ICogcmF0aW9CICk7XG5cdFx0dGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcblx0XHR0aGlzLl95ID0gKCB5ICogcmF0aW9BICsgdGhpcy5feSAqIHJhdGlvQiApO1xuXHRcdHRoaXMuX3ogPSAoIHogKiByYXRpb0EgKyB0aGlzLl96ICogcmF0aW9CICk7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2xlcnBRdWF0ZXJuaW9ucyggcWEsIHFiLCB0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY29weSggcWEgKS5zbGVycCggcWIsIHQgKTtcblxuXHR9XG5cblx0cmFuZG9tKCkge1xuXG5cdFx0Ly8gc2V0cyB0aGlzIHF1YXRlcm5pb24gdG8gYSB1bmlmb3JtIHJhbmRvbSB1bml0IHF1YXRlcm5uaW9uXG5cblx0XHQvLyBLZW4gU2hvZW1ha2Vcblx0XHQvLyBVbmlmb3JtIHJhbmRvbSByb3RhdGlvbnNcblx0XHQvLyBELiBLaXJrLCBlZGl0b3IsIEdyYXBoaWNzIEdlbXMgSUlJLCBwYWdlcyAxMjQtMTMyLiBBY2FkZW1pYyBQcmVzcywgTmV3IFlvcmssIDE5OTIuXG5cblx0XHRjb25zdCB0aGV0YTEgPSAyICogTWF0aC5QSSAqIE1hdGgucmFuZG9tKCk7XG5cdFx0Y29uc3QgdGhldGEyID0gMiAqIE1hdGguUEkgKiBNYXRoLnJhbmRvbSgpO1xuXG5cdFx0Y29uc3QgeDAgPSBNYXRoLnJhbmRvbSgpO1xuXHRcdGNvbnN0IHIxID0gTWF0aC5zcXJ0KCAxIC0geDAgKTtcblx0XHRjb25zdCByMiA9IE1hdGguc3FydCggeDAgKTtcblxuXHRcdHJldHVybiB0aGlzLnNldChcblx0XHRcdHIxICogTWF0aC5zaW4oIHRoZXRhMSApLFxuXHRcdFx0cjEgKiBNYXRoLmNvcyggdGhldGExICksXG5cdFx0XHRyMiAqIE1hdGguc2luKCB0aGV0YTIgKSxcblx0XHRcdHIyICogTWF0aC5jb3MoIHRoZXRhMiApLFxuXHRcdCk7XG5cblx0fVxuXG5cdGVxdWFscyggcXVhdGVybmlvbiApIHtcblxuXHRcdHJldHVybiAoIHF1YXRlcm5pb24uX3ggPT09IHRoaXMuX3ggKSAmJiAoIHF1YXRlcm5pb24uX3kgPT09IHRoaXMuX3kgKSAmJiAoIHF1YXRlcm5pb24uX3ogPT09IHRoaXMuX3ogKSAmJiAoIHF1YXRlcm5pb24uX3cgPT09IHRoaXMuX3cgKTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdHRoaXMuX3ggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy5feSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy5feiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG5cdFx0dGhpcy5fdyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX3c7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG5cdGZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kZXggKSB7XG5cblx0XHR0aGlzLl94ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XG5cdFx0dGhpcy5feSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xuXHRcdHRoaXMuX3ogPSBhdHRyaWJ1dGUuZ2V0WiggaW5kZXggKTtcblx0XHR0aGlzLl93ID0gYXR0cmlidXRlLmdldFcoIGluZGV4ICk7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudG9BcnJheSgpO1xuXG5cdH1cblxuXHRfb25DaGFuZ2UoIGNhbGxiYWNrICkge1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdF9vbkNoYW5nZUNhbGxiYWNrKCkge31cblxuXHQqWyBTeW1ib2wuaXRlcmF0b3IgXSgpIHtcblxuXHRcdHlpZWxkIHRoaXMuX3g7XG5cdFx0eWllbGQgdGhpcy5feTtcblx0XHR5aWVsZCB0aGlzLl96O1xuXHRcdHlpZWxkIHRoaXMuX3c7XG5cblx0fVxuXG59XG5cbmNsYXNzIFZlY3RvcjMge1xuXG5cdGNvbnN0cnVjdG9yKCB4ID0gMCwgeSA9IDAsIHogPSAwICkge1xuXG5cdFx0VmVjdG9yMy5wcm90b3R5cGUuaXNWZWN0b3IzID0gdHJ1ZTtcblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLnogPSB6O1xuXG5cdH1cblxuXHRzZXQoIHgsIHksIHogKSB7XG5cblx0XHRpZiAoIHogPT09IHVuZGVmaW5lZCApIHogPSB0aGlzLno7IC8vIHNwcml0ZS5zY2FsZS5zZXQoeCx5KVxuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0U2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnggPSBzY2FsYXI7XG5cdFx0dGhpcy55ID0gc2NhbGFyO1xuXHRcdHRoaXMueiA9IHNjYWxhcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYKCB4ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRZKCB5ICkge1xuXG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRaKCB6ICkge1xuXG5cdFx0dGhpcy56ID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRDb21wb25lbnQoIGluZGV4LCB2YWx1ZSApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldENvbXBvbmVudCggaW5kZXggKSB7XG5cblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xuXHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xuXHRcdFx0Y2FzZSAyOiByZXR1cm4gdGhpcy56O1xuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55LCB0aGlzLnogKTtcblxuXHR9XG5cblx0Y29weSggdiApIHtcblxuXHRcdHRoaXMueCA9IHYueDtcblx0XHR0aGlzLnkgPSB2Lnk7XG5cdFx0dGhpcy56ID0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZCggdiApIHtcblxuXHRcdHRoaXMueCArPSB2Lng7XG5cdFx0dGhpcy55ICs9IHYueTtcblx0XHR0aGlzLnogKz0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFNjYWxhciggcyApIHtcblxuXHRcdHRoaXMueCArPSBzO1xuXHRcdHRoaXMueSArPSBzO1xuXHRcdHRoaXMueiArPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xuXHRcdHRoaXMueiA9IGEueiArIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGRTY2FsZWRWZWN0b3IoIHYsIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gdi54ICogcztcblx0XHR0aGlzLnkgKz0gdi55ICogcztcblx0XHR0aGlzLnogKz0gdi56ICogcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdWIoIHYgKSB7XG5cblx0XHR0aGlzLnggLT0gdi54O1xuXHRcdHRoaXMueSAtPSB2Lnk7XG5cdFx0dGhpcy56IC09IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdWJTY2FsYXIoIHMgKSB7XG5cblx0XHR0aGlzLnggLT0gcztcblx0XHR0aGlzLnkgLT0gcztcblx0XHR0aGlzLnogLT0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdWJWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHkoIHYgKSB7XG5cblx0XHR0aGlzLnggKj0gdi54O1xuXHRcdHRoaXMueSAqPSB2Lnk7XG5cdFx0dGhpcy56ICo9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy54ICo9IHNjYWxhcjtcblx0XHR0aGlzLnkgKj0gc2NhbGFyO1xuXHRcdHRoaXMueiAqPSBzY2FsYXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHlWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54ICogYi54O1xuXHRcdHRoaXMueSA9IGEueSAqIGIueTtcblx0XHR0aGlzLnogPSBhLnogKiBiLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlFdWxlciggZXVsZXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oIF9xdWF0ZXJuaW9uJDQuc2V0RnJvbUV1bGVyKCBldWxlciApICk7XG5cblx0fVxuXG5cdGFwcGx5QXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggX3F1YXRlcm5pb24kNC5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApICk7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4MyggbSApIHtcblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXSAqIHo7XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA3IF0gKiB6O1xuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOCBdICogejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU5vcm1hbE1hdHJpeCggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4MyggbSApLm5vcm1hbGl6ZSgpO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDQoIG0gKSB7XG5cblx0XHRjb25zdCB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgdyA9IDEgLyAoIGVbIDMgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgMTEgXSAqIHogKyBlWyAxNSBdICk7XG5cblx0XHR0aGlzLnggPSAoIGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKSAqIHc7XG5cdFx0dGhpcy55ID0gKCBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdICkgKiB3O1xuXHRcdHRoaXMueiA9ICggZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKSAqIHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlRdWF0ZXJuaW9uKCBxICkge1xuXG5cdFx0Ly8gcXVhdGVybmlvbiBxIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG5cdFx0Y29uc3QgdnggPSB0aGlzLngsIHZ5ID0gdGhpcy55LCB2eiA9IHRoaXMuejtcblx0XHRjb25zdCBxeCA9IHEueCwgcXkgPSBxLnksIHF6ID0gcS56LCBxdyA9IHEudztcblxuXHRcdC8vIHQgPSAyICogY3Jvc3MoIHEueHl6LCB2ICk7XG5cdFx0Y29uc3QgdHggPSAyICogKCBxeSAqIHZ6IC0gcXogKiB2eSApO1xuXHRcdGNvbnN0IHR5ID0gMiAqICggcXogKiB2eCAtIHF4ICogdnogKTtcblx0XHRjb25zdCB0eiA9IDIgKiAoIHF4ICogdnkgLSBxeSAqIHZ4ICk7XG5cblx0XHQvLyB2ICsgcS53ICogdCArIGNyb3NzKCBxLnh5eiwgdCApO1xuXHRcdHRoaXMueCA9IHZ4ICsgcXcgKiB0eCArIHF5ICogdHogLSBxeiAqIHR5O1xuXHRcdHRoaXMueSA9IHZ5ICsgcXcgKiB0eSArIHF6ICogdHggLSBxeCAqIHR6O1xuXHRcdHRoaXMueiA9IHZ6ICsgcXcgKiB0eiArIHF4ICogdHkgLSBxeSAqIHR4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHByb2plY3QoIGNhbWVyYSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApLmFwcGx5TWF0cml4NCggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHR9XG5cblx0dW5wcm9qZWN0KCBjYW1lcmEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSApLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cblx0fVxuXG5cdHRyYW5zZm9ybURpcmVjdGlvbiggbSApIHtcblxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcblx0XHQvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHo7XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6O1xuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHo7XG5cblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcblxuXHR9XG5cblx0ZGl2aWRlKCB2ICkge1xuXG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXHRcdHRoaXMueiAvPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGl2aWRlU2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xuXG5cdH1cblxuXHRtaW4oIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYXgoIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGFtcCggbWluLCBtYXggKSB7XG5cblx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxuXG5cdFx0dGhpcy54ID0gY2xhbXAoIHRoaXMueCwgbWluLngsIG1heC54ICk7XG5cdFx0dGhpcy55ID0gY2xhbXAoIHRoaXMueSwgbWluLnksIG1heC55ICk7XG5cdFx0dGhpcy56ID0gY2xhbXAoIHRoaXMueiwgbWluLnosIG1heC56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0dGhpcy54ID0gY2xhbXAoIHRoaXMueCwgbWluVmFsLCBtYXhWYWwgKTtcblx0XHR0aGlzLnkgPSBjbGFtcCggdGhpcy55LCBtaW5WYWwsIG1heFZhbCApO1xuXHRcdHRoaXMueiA9IGNsYW1wKCB0aGlzLnosIG1pblZhbCwgbWF4VmFsICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBMZW5ndGgoIG1pbiwgbWF4ICkge1xuXG5cdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggY2xhbXAoIGxlbmd0aCwgbWluLCBtYXggKSApO1xuXG5cdH1cblxuXHRmbG9vcigpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNlaWwoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3VuZCgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdW5kVG9aZXJvKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC50cnVuYyggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC50cnVuYyggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC50cnVuYyggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bmVnYXRlKCkge1xuXG5cdFx0dGhpcy54ID0gLSB0aGlzLng7XG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XG5cdFx0dGhpcy56ID0gLSB0aGlzLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZG90KCB2ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcblxuXHR9XG5cblx0Ly8gVE9ETyBsZW5ndGhTcXVhcmVkP1xuXG5cdGxlbmd0aFNxKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcblxuXHR9XG5cblx0bGVuZ3RoKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XG5cblx0fVxuXG5cdG1hbmhhdHRhbkxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XG5cblx0fVxuXG5cdG5vcm1hbGl6ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSB8fCAxICk7XG5cblx0fVxuXG5cdHNldExlbmd0aCggbGVuZ3RoICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCApO1xuXG5cdH1cblxuXHRsZXJwKCB2LCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGxlcnBWZWN0b3JzKCB2MSwgdjIsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ID0gdjEueCArICggdjIueCAtIHYxLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSA9IHYxLnkgKyAoIHYyLnkgLSB2MS55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogPSB2MS56ICsgKCB2Mi56IC0gdjEueiApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y3Jvc3MoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHRoaXMsIHYgKTtcblxuXHR9XG5cblx0Y3Jvc3NWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0Y29uc3QgYXggPSBhLngsIGF5ID0gYS55LCBheiA9IGEuejtcblx0XHRjb25zdCBieCA9IGIueCwgYnkgPSBiLnksIGJ6ID0gYi56O1xuXG5cdFx0dGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XG5cdFx0dGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG5cdFx0dGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cHJvamVjdE9uVmVjdG9yKCB2ICkge1xuXG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSB2Lmxlbmd0aFNxKCk7XG5cblx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkgcmV0dXJuIHRoaXMuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRjb25zdCBzY2FsYXIgPSB2LmRvdCggdGhpcyApIC8gZGVub21pbmF0b3I7XG5cblx0XHRyZXR1cm4gdGhpcy5jb3B5KCB2ICkubXVsdGlwbHlTY2FsYXIoIHNjYWxhciApO1xuXG5cdH1cblxuXHRwcm9qZWN0T25QbGFuZSggcGxhbmVOb3JtYWwgKSB7XG5cblx0XHRfdmVjdG9yJGMuY29weSggdGhpcyApLnByb2plY3RPblZlY3RvciggcGxhbmVOb3JtYWwgKTtcblxuXHRcdHJldHVybiB0aGlzLnN1YiggX3ZlY3RvciRjICk7XG5cblx0fVxuXG5cdHJlZmxlY3QoIG5vcm1hbCApIHtcblxuXHRcdC8vIHJlZmxlY3QgaW5jaWRlbnQgdmVjdG9yIG9mZiBwbGFuZSBvcnRob2dvbmFsIHRvIG5vcm1hbFxuXHRcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcblxuXHRcdHJldHVybiB0aGlzLnN1YiggX3ZlY3RvciRjLmNvcHkoIG5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAyICogdGhpcy5kb3QoIG5vcm1hbCApICkgKTtcblxuXHR9XG5cblx0YW5nbGVUbyggdiApIHtcblxuXHRcdGNvbnN0IGRlbm9taW5hdG9yID0gTWF0aC5zcXJ0KCB0aGlzLmxlbmd0aFNxKCkgKiB2Lmxlbmd0aFNxKCkgKTtcblxuXHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSByZXR1cm4gTWF0aC5QSSAvIDI7XG5cblx0XHRjb25zdCB0aGV0YSA9IHRoaXMuZG90KCB2ICkgLyBkZW5vbWluYXRvcjtcblxuXHRcdC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXG5cblx0XHRyZXR1cm4gTWF0aC5hY29zKCBjbGFtcCggdGhldGEsIC0gMSwgMSApICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG8oIHYgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcblxuXHR9XG5cblx0ZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSB7XG5cblx0XHRjb25zdCBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2LnksIGR6ID0gdGhpcy56IC0gdi56O1xuXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcblxuXHR9XG5cblx0bWFuaGF0dGFuRGlzdGFuY2VUbyggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54IC0gdi54ICkgKyBNYXRoLmFicyggdGhpcy55IC0gdi55ICkgKyBNYXRoLmFicyggdGhpcy56IC0gdi56ICk7XG5cblx0fVxuXG5cdHNldEZyb21TcGhlcmljYWwoIHMgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tU3BoZXJpY2FsQ29vcmRzKCBzLnJhZGl1cywgcy5waGksIHMudGhldGEgKTtcblxuXHR9XG5cblx0c2V0RnJvbVNwaGVyaWNhbENvb3JkcyggcmFkaXVzLCBwaGksIHRoZXRhICkge1xuXG5cdFx0Y29uc3Qgc2luUGhpUmFkaXVzID0gTWF0aC5zaW4oIHBoaSApICogcmFkaXVzO1xuXG5cdFx0dGhpcy54ID0gc2luUGhpUmFkaXVzICogTWF0aC5zaW4oIHRoZXRhICk7XG5cdFx0dGhpcy55ID0gTWF0aC5jb3MoIHBoaSApICogcmFkaXVzO1xuXHRcdHRoaXMueiA9IHNpblBoaVJhZGl1cyAqIE1hdGguY29zKCB0aGV0YSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21DeWxpbmRyaWNhbCggYyApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21DeWxpbmRyaWNhbENvb3JkcyggYy5yYWRpdXMsIGMudGhldGEsIGMueSApO1xuXG5cdH1cblxuXHRzZXRGcm9tQ3lsaW5kcmljYWxDb29yZHMoIHJhZGl1cywgdGhldGEsIHkgKSB7XG5cblx0XHR0aGlzLnggPSByYWRpdXMgKiBNYXRoLnNpbiggdGhldGEgKTtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21NYXRyaXhQb3NpdGlvbiggbSApIHtcblxuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMTIgXTtcblx0XHR0aGlzLnkgPSBlWyAxMyBdO1xuXHRcdHRoaXMueiA9IGVbIDE0IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU1hdHJpeFNjYWxlKCBtICkge1xuXG5cdFx0Y29uc3Qgc3ggPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDAgKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzeSA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHN6ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAyICkubGVuZ3RoKCk7XG5cblx0XHR0aGlzLnggPSBzeDtcblx0XHR0aGlzLnkgPSBzeTtcblx0XHR0aGlzLnogPSBzejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4Q29sdW1uKCBtLCBpbmRleCApIHtcblxuXHRcdHJldHVybiB0aGlzLmZyb21BcnJheSggbS5lbGVtZW50cywgaW5kZXggKiA0ICk7XG5cblx0fVxuXG5cdHNldEZyb21NYXRyaXgzQ29sdW1uKCBtLCBpbmRleCApIHtcblxuXHRcdHJldHVybiB0aGlzLmZyb21BcnJheSggbS5lbGVtZW50cywgaW5kZXggKiAzICk7XG5cblx0fVxuXG5cdHNldEZyb21FdWxlciggZSApIHtcblxuXHRcdHRoaXMueCA9IGUuX3g7XG5cdFx0dGhpcy55ID0gZS5feTtcblx0XHR0aGlzLnogPSBlLl96O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Db2xvciggYyApIHtcblxuXHRcdHRoaXMueCA9IGMucjtcblx0XHR0aGlzLnkgPSBjLmc7XG5cdFx0dGhpcy56ID0gYy5iO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVxdWFscyggdiApIHtcblxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICk7XG5cblx0fVxuXG5cdGZyb21BcnJheSggYXJyYXksIG9mZnNldCA9IDAgKSB7XG5cblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHRmcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGV4ICkge1xuXG5cdFx0dGhpcy54ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XG5cdFx0dGhpcy55ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XG5cdFx0dGhpcy56ID0gYXR0cmlidXRlLmdldFooIGluZGV4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmFuZG9tKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yYW5kb20oKTtcblx0XHR0aGlzLnkgPSBNYXRoLnJhbmRvbSgpO1xuXHRcdHRoaXMueiA9IE1hdGgucmFuZG9tKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmFuZG9tRGlyZWN0aW9uKCkge1xuXG5cdFx0Ly8gaHR0cHM6Ly9tYXRod29ybGQud29sZnJhbS5jb20vU3BoZXJlUG9pbnRQaWNraW5nLmh0bWxcblxuXHRcdGNvbnN0IHRoZXRhID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xuXHRcdGNvbnN0IHUgPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XG5cdFx0Y29uc3QgYyA9IE1hdGguc3FydCggMSAtIHUgKiB1ICk7XG5cblx0XHR0aGlzLnggPSBjICogTWF0aC5jb3MoIHRoZXRhICk7XG5cdFx0dGhpcy55ID0gdTtcblx0XHR0aGlzLnogPSBjICogTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0KlsgU3ltYm9sLml0ZXJhdG9yIF0oKSB7XG5cblx0XHR5aWVsZCB0aGlzLng7XG5cdFx0eWllbGQgdGhpcy55O1xuXHRcdHlpZWxkIHRoaXMuejtcblxuXHR9XG5cbn1cblxuY29uc3QgX3ZlY3RvciRjID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3F1YXRlcm5pb24kNCA9IC8qQF9fUFVSRV9fKi8gbmV3IFF1YXRlcm5pb24oKTtcblxuY2xhc3MgQm94MyB7XG5cblx0Y29uc3RydWN0b3IoIG1pbiA9IG5ldyBWZWN0b3IzKCArIEluZmluaXR5LCArIEluZmluaXR5LCArIEluZmluaXR5ICksIG1heCA9IG5ldyBWZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICkgKSB7XG5cblx0XHR0aGlzLmlzQm94MyA9IHRydWU7XG5cblx0XHR0aGlzLm1pbiA9IG1pbjtcblx0XHR0aGlzLm1heCA9IG1heDtcblxuXHR9XG5cblx0c2V0KCBtaW4sIG1heCApIHtcblxuXHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xuXHRcdHRoaXMubWF4LmNvcHkoIG1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21BcnJheSggYXJyYXkgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggX3ZlY3RvciRiLmZyb21BcnJheSggYXJyYXksIGkgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYXR0cmlidXRlLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggX3ZlY3RvciRiLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVBvaW50cyggcG9pbnRzICkge1xuXG5cdFx0dGhpcy5tYWtlRW1wdHkoKTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tQ2VudGVyQW5kU2l6ZSggY2VudGVyLCBzaXplICkge1xuXG5cdFx0Y29uc3QgaGFsZlNpemUgPSBfdmVjdG9yJGIuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHRcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcblx0XHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU9iamVjdCggb2JqZWN0LCBwcmVjaXNlID0gZmFsc2UgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kQnlPYmplY3QoIG9iamVjdCwgcHJlY2lzZSApO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0Y29weSggYm94ICkge1xuXG5cdFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xuXHRcdHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlRW1wdHkoKSB7XG5cblx0XHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IHRoaXMubWluLnogPSArIEluZmluaXR5O1xuXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gdGhpcy5tYXgueiA9IC0gSW5maW5pdHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aXNFbXB0eSgpIHtcblxuXHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXG5cblx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKSB8fCAoIHRoaXMubWF4LnogPCB0aGlzLm1pbi56ICk7XG5cblx0fVxuXG5cdGdldENlbnRlciggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gdGFyZ2V0LnNldCggMCwgMCwgMCApIDogdGFyZ2V0LmFkZFZlY3RvcnMoIHRoaXMubWluLCB0aGlzLm1heCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHR9XG5cblx0Z2V0U2l6ZSggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gdGFyZ2V0LnNldCggMCwgMCwgMCApIDogdGFyZ2V0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xuXG5cdH1cblxuXHRleHBhbmRCeVBvaW50KCBwb2ludCApIHtcblxuXHRcdHRoaXMubWluLm1pbiggcG9pbnQgKTtcblx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXhwYW5kQnlWZWN0b3IoIHZlY3RvciApIHtcblxuXHRcdHRoaXMubWluLnN1YiggdmVjdG9yICk7XG5cdFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHBhbmRCeVNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXhwYW5kQnlPYmplY3QoIG9iamVjdCwgcHJlY2lzZSA9IGZhbHNlICkge1xuXG5cdFx0Ly8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcblx0XHQvLyBhY2NvdW50aW5nIGZvciBib3RoIHRoZSBvYmplY3QncywgYW5kIGNoaWxkcmVuJ3MsIHdvcmxkIHRyYW5zZm9ybXNcblxuXHRcdG9iamVjdC51cGRhdGVXb3JsZE1hdHJpeCggZmFsc2UsIGZhbHNlICk7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuXHRcdGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblxuXHRcdFx0Ly8gcHJlY2lzZSBBQUJCIGNvbXB1dGF0aW9uIGJhc2VkIG9uIHZlcnRleCBkYXRhIHJlcXVpcmVzIGF0IGxlYXN0IGEgcG9zaXRpb24gYXR0cmlidXRlLlxuXHRcdFx0Ly8gaW5zdGFuY2luZyBpc24ndCBzdXBwb3J0ZWQgc28gZmFyIGFuZCB1c2VzIHRoZSBub3JtYWwgKGNvbnNlcnZhdGl2ZSkgY29kZSBwYXRoLlxuXG5cdFx0XHRpZiAoIHByZWNpc2UgPT09IHRydWUgJiYgcG9zaXRpb25BdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuaXNJbnN0YW5jZWRNZXNoICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHBvc2l0aW9uQXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGlmICggb2JqZWN0LmlzTWVzaCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0LmdldFZlcnRleFBvc2l0aW9uKCBpLCBfdmVjdG9yJGIgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdF92ZWN0b3IkYi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X3ZlY3RvciRiLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBfdmVjdG9yJGIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QuYm91bmRpbmdCb3ggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdC8vIG9iamVjdC1sZXZlbCBib3VuZGluZyBib3hcblxuXHRcdFx0XHRcdGlmICggb2JqZWN0LmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfYm94JDQuY29weSggb2JqZWN0LmJvdW5kaW5nQm94ICk7XG5cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gZ2VvbWV0cnktbGV2ZWwgYm91bmRpbmcgYm94XG5cblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9ib3gkNC5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfYm94JDQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHR0aGlzLnVuaW9uKCBfYm94JDQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5T2JqZWN0KCBjaGlsZHJlblsgaSBdLCBwcmVjaXNlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29udGFpbnNQb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gcG9pbnQueCA+PSB0aGlzLm1pbi54ICYmIHBvaW50LnggPD0gdGhpcy5tYXgueCAmJlxuXHRcdFx0cG9pbnQueSA+PSB0aGlzLm1pbi55ICYmIHBvaW50LnkgPD0gdGhpcy5tYXgueSAmJlxuXHRcdFx0cG9pbnQueiA+PSB0aGlzLm1pbi56ICYmIHBvaW50LnogPD0gdGhpcy5tYXguejtcblxuXHR9XG5cblx0Y29udGFpbnNCb3goIGJveCApIHtcblxuXHRcdHJldHVybiB0aGlzLm1pbi54IDw9IGJveC5taW4ueCAmJiBib3gubWF4LnggPD0gdGhpcy5tYXgueCAmJlxuXHRcdFx0dGhpcy5taW4ueSA8PSBib3gubWluLnkgJiYgYm94Lm1heC55IDw9IHRoaXMubWF4LnkgJiZcblx0XHRcdHRoaXMubWluLnogPD0gYm94Lm1pbi56ICYmIGJveC5tYXgueiA8PSB0aGlzLm1heC56O1xuXG5cdH1cblxuXHRnZXRQYXJhbWV0ZXIoIHBvaW50LCB0YXJnZXQgKSB7XG5cblx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuXHRcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldChcblx0XHRcdCggcG9pbnQueCAtIHRoaXMubWluLnggKSAvICggdGhpcy5tYXgueCAtIHRoaXMubWluLnggKSxcblx0XHRcdCggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKSxcblx0XHRcdCggcG9pbnQueiAtIHRoaXMubWluLnogKSAvICggdGhpcy5tYXgueiAtIHRoaXMubWluLnogKVxuXHRcdCk7XG5cblx0fVxuXG5cdGludGVyc2VjdHNCb3goIGJveCApIHtcblxuXHRcdC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxuXHRcdHJldHVybiBib3gubWF4LnggPj0gdGhpcy5taW4ueCAmJiBib3gubWluLnggPD0gdGhpcy5tYXgueCAmJlxuXHRcdFx0Ym94Lm1heC55ID49IHRoaXMubWluLnkgJiYgYm94Lm1pbi55IDw9IHRoaXMubWF4LnkgJiZcblx0XHRcdGJveC5tYXgueiA+PSB0aGlzLm1pbi56ICYmIGJveC5taW4ueiA8PSB0aGlzLm1heC56O1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XG5cblx0XHQvLyBGaW5kIHRoZSBwb2ludCBvbiB0aGUgQUFCQiBjbG9zZXN0IHRvIHRoZSBzcGhlcmUgY2VudGVyLlxuXHRcdHRoaXMuY2xhbXBQb2ludCggc3BoZXJlLmNlbnRlciwgX3ZlY3RvciRiICk7XG5cblx0XHQvLyBJZiB0aGF0IHBvaW50IGlzIGluc2lkZSB0aGUgc3BoZXJlLCB0aGUgQUFCQiBhbmQgc3BoZXJlIGludGVyc2VjdC5cblx0XHRyZXR1cm4gX3ZlY3RvciRiLmRpc3RhbmNlVG9TcXVhcmVkKCBzcGhlcmUuY2VudGVyICkgPD0gKCBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cyApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzUGxhbmUoIHBsYW5lICkge1xuXG5cdFx0Ly8gV2UgY29tcHV0ZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBkb3QgcHJvZHVjdCB2YWx1ZXMuIElmIHRob3NlIHZhbHVlc1xuXHRcdC8vIGFyZSBvbiB0aGUgc2FtZSBzaWRlIChiYWNrIG9yIGZyb250KSBvZiB0aGUgcGxhbmUsIHRoZW4gdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9uLlxuXG5cdFx0bGV0IG1pbiwgbWF4O1xuXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueCA+IDAgKSB7XG5cblx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblxuXHRcdH1cblxuXHRcdGlmICggcGxhbmUubm9ybWFsLnkgPiAwICkge1xuXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWF4Lnk7XG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueiA+IDAgKSB7XG5cblx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5tYXguejtcblx0XHRcdG1heCArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gKCBtaW4gPD0gLSBwbGFuZS5jb25zdGFudCAmJiBtYXggPj0gLSBwbGFuZS5jb25zdGFudCApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzVHJpYW5nbGUoIHRyaWFuZ2xlICkge1xuXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29tcHV0ZSBib3ggY2VudGVyIGFuZCBleHRlbnRzXG5cdFx0dGhpcy5nZXRDZW50ZXIoIF9jZW50ZXIgKTtcblx0XHRfZXh0ZW50cy5zdWJWZWN0b3JzKCB0aGlzLm1heCwgX2NlbnRlciApO1xuXG5cdFx0Ly8gdHJhbnNsYXRlIHRyaWFuZ2xlIHRvIGFhYmIgb3JpZ2luXG5cdFx0X3YwJDIuc3ViVmVjdG9ycyggdHJpYW5nbGUuYSwgX2NlbnRlciApO1xuXHRcdF92MSQ3LnN1YlZlY3RvcnMoIHRyaWFuZ2xlLmIsIF9jZW50ZXIgKTtcblx0XHRfdjIkNC5zdWJWZWN0b3JzKCB0cmlhbmdsZS5jLCBfY2VudGVyICk7XG5cblx0XHQvLyBjb21wdXRlIGVkZ2UgdmVjdG9ycyBmb3IgdHJpYW5nbGVcblx0XHRfZjAuc3ViVmVjdG9ycyggX3YxJDcsIF92MCQyICk7XG5cdFx0X2YxLnN1YlZlY3RvcnMoIF92MiQ0LCBfdjEkNyApO1xuXHRcdF9mMi5zdWJWZWN0b3JzKCBfdjAkMiwgX3YyJDQgKTtcblxuXHRcdC8vIHRlc3QgYWdhaW5zdCBheGVzIHRoYXQgYXJlIGdpdmVuIGJ5IGNyb3NzIHByb2R1Y3QgY29tYmluYXRpb25zIG9mIHRoZSBlZGdlcyBvZiB0aGUgdHJpYW5nbGUgYW5kIHRoZSBlZGdlcyBvZiB0aGUgYWFiYlxuXHRcdC8vIG1ha2UgYW4gYXhpcyB0ZXN0aW5nIG9mIGVhY2ggb2YgdGhlIDMgc2lkZXMgb2YgdGhlIGFhYmIgYWdhaW5zdCBlYWNoIG9mIHRoZSAzIHNpZGVzIG9mIHRoZSB0cmlhbmdsZSA9IDkgYXhpcyBvZiBzZXBhcmF0aW9uXG5cdFx0Ly8gYXhpc19paiA9IHVfaSB4IGZfaiAodTAsIHUxLCB1MiA9IGZhY2Ugbm9ybWFscyBvZiBhYWJiID0geCx5LHogYXhlcyB2ZWN0b3JzIHNpbmNlIGFhYmIgaXMgYXhpcyBhbGlnbmVkKVxuXHRcdGxldCBheGVzID0gW1xuXHRcdFx0MCwgLSBfZjAueiwgX2YwLnksIDAsIC0gX2YxLnosIF9mMS55LCAwLCAtIF9mMi56LCBfZjIueSxcblx0XHRcdF9mMC56LCAwLCAtIF9mMC54LCBfZjEueiwgMCwgLSBfZjEueCwgX2YyLnosIDAsIC0gX2YyLngsXG5cdFx0XHQtIF9mMC55LCBfZjAueCwgMCwgLSBfZjEueSwgX2YxLngsIDAsIC0gX2YyLnksIF9mMi54LCAwXG5cdFx0XTtcblx0XHRpZiAoICEgc2F0Rm9yQXhlcyggYXhlcywgX3YwJDIsIF92MSQ3LCBfdjIkNCwgX2V4dGVudHMgKSApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdGVzdCAzIGZhY2Ugbm9ybWFscyBmcm9tIHRoZSBhYWJiXG5cdFx0YXhlcyA9IFsgMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSBdO1xuXHRcdGlmICggISBzYXRGb3JBeGVzKCBheGVzLCBfdjAkMiwgX3YxJDcsIF92MiQ0LCBfZXh0ZW50cyApICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHQvLyBmaW5hbGx5IHRlc3RpbmcgdGhlIGZhY2Ugbm9ybWFsIG9mIHRoZSB0cmlhbmdsZVxuXHRcdC8vIHVzZSBhbHJlYWR5IGV4aXN0aW5nIHRyaWFuZ2xlIGVkZ2UgdmVjdG9ycyBoZXJlXG5cdFx0X3RyaWFuZ2xlTm9ybWFsLmNyb3NzVmVjdG9ycyggX2YwLCBfZjEgKTtcblx0XHRheGVzID0gWyBfdHJpYW5nbGVOb3JtYWwueCwgX3RyaWFuZ2xlTm9ybWFsLnksIF90cmlhbmdsZU5vcm1hbC56IF07XG5cblx0XHRyZXR1cm4gc2F0Rm9yQXhlcyggYXhlcywgX3YwJDIsIF92MSQ3LCBfdjIkNCwgX2V4dGVudHMgKTtcblxuXHR9XG5cblx0Y2xhbXBQb2ludCggcG9pbnQsIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0YXJnZXQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jbGFtcFBvaW50KCBwb2ludCwgX3ZlY3RvciRiICkuZGlzdGFuY2VUbyggcG9pbnQgKTtcblxuXHR9XG5cblx0Z2V0Qm91bmRpbmdTcGhlcmUoIHRhcmdldCApIHtcblxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB7XG5cblx0XHRcdHRhcmdldC5tYWtlRW1wdHkoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuZ2V0Q2VudGVyKCB0YXJnZXQuY2VudGVyICk7XG5cblx0XHRcdHRhcmdldC5yYWRpdXMgPSB0aGlzLmdldFNpemUoIF92ZWN0b3IkYiApLmxlbmd0aCgpICogMC41O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0aW50ZXJzZWN0KCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcblxuXHRcdC8vIGVuc3VyZSB0aGF0IGlmIHRoZXJlIGlzIG5vIG92ZXJsYXAsIHRoZSByZXN1bHQgaXMgZnVsbHkgZW1wdHksIG5vdCBzbGlnaHRseSBlbXB0eSB3aXRoIG5vbi1pbmYvK2luZiB2YWx1ZXMgdGhhdCB3aWxsIGNhdXNlIHN1YnNlcXVlbmNlIGludGVyc2VjdHMgdG8gZXJyb25lb3VzbHkgcmV0dXJuIHZhbGlkIHZhbHVlcy5cblx0XHRpZiAoIHRoaXMuaXNFbXB0eSgpICkgdGhpcy5tYWtlRW1wdHkoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR1bmlvbiggYm94ICkge1xuXG5cdFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XG5cdFx0dGhpcy5tYXgubWF4KCBib3gubWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlNYXRyaXg0KCBtYXRyaXggKSB7XG5cblx0XHQvLyB0cmFuc2Zvcm0gb2YgZW1wdHkgYm94IGlzIGFuIGVtcHR5IGJveC5cblx0XHRpZiAoIHRoaXMuaXNFbXB0eSgpICkgcmV0dXJuIHRoaXM7XG5cblx0XHQvLyBOT1RFOiBJIGFtIHVzaW5nIGEgYmluYXJ5IHBhdHRlcm4gdG8gc3BlY2lmeSBhbGwgMl4zIGNvbWJpbmF0aW9ucyBiZWxvd1xuXHRcdF9wb2ludHNbIDAgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDBcblx0XHRfcG9pbnRzWyAxIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAxXG5cdFx0X3BvaW50c1sgMiBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMFxuXHRcdF9wb2ludHNbIDMgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTFcblx0XHRfcG9pbnRzWyA0IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAwXG5cdFx0X3BvaW50c1sgNSBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMVxuXHRcdF9wb2ludHNbIDYgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTBcblx0XHRfcG9pbnRzWyA3IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTExXG5cblx0XHR0aGlzLnNldEZyb21Qb2ludHMoIF9wb2ludHMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2xhdGUoIG9mZnNldCApIHtcblxuXHRcdHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XG5cdFx0dGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlcXVhbHMoIGJveCApIHtcblxuXHRcdHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcblxuXHR9XG5cbn1cblxuY29uc3QgX3BvaW50cyA9IFtcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKClcbl07XG5cbmNvbnN0IF92ZWN0b3IkYiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX2JveCQ0ID0gLypAX19QVVJFX18qLyBuZXcgQm94MygpO1xuXG4vLyB0cmlhbmdsZSBjZW50ZXJlZCB2ZXJ0aWNlc1xuXG5jb25zdCBfdjAkMiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MSQ3ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YyJDQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbi8vIHRyaWFuZ2xlIGVkZ2UgdmVjdG9yc1xuXG5jb25zdCBfZjAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfZjEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfZjIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNvbnN0IF9jZW50ZXIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfZXh0ZW50cyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF90cmlhbmdsZU5vcm1hbCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF90ZXN0QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuZnVuY3Rpb24gc2F0Rm9yQXhlcyggYXhlcywgdjAsIHYxLCB2MiwgZXh0ZW50cyApIHtcblxuXHRmb3IgKCBsZXQgaSA9IDAsIGogPSBheGVzLmxlbmd0aCAtIDM7IGkgPD0gajsgaSArPSAzICkge1xuXG5cdFx0X3Rlc3RBeGlzLmZyb21BcnJheSggYXhlcywgaSApO1xuXHRcdC8vIHByb2plY3QgdGhlIGFhYmIgb250byB0aGUgc2VwYXJhdGluZyBheGlzXG5cdFx0Y29uc3QgciA9IGV4dGVudHMueCAqIE1hdGguYWJzKCBfdGVzdEF4aXMueCApICsgZXh0ZW50cy55ICogTWF0aC5hYnMoIF90ZXN0QXhpcy55ICkgKyBleHRlbnRzLnogKiBNYXRoLmFicyggX3Rlc3RBeGlzLnogKTtcblx0XHQvLyBwcm9qZWN0IGFsbCAzIHZlcnRpY2VzIG9mIHRoZSB0cmlhbmdsZSBvbnRvIHRoZSBzZXBhcmF0aW5nIGF4aXNcblx0XHRjb25zdCBwMCA9IHYwLmRvdCggX3Rlc3RBeGlzICk7XG5cdFx0Y29uc3QgcDEgPSB2MS5kb3QoIF90ZXN0QXhpcyApO1xuXHRcdGNvbnN0IHAyID0gdjIuZG90KCBfdGVzdEF4aXMgKTtcblx0XHQvLyBhY3R1YWwgdGVzdCwgYmFzaWNhbGx5IHNlZSBpZiBlaXRoZXIgb2YgdGhlIG1vc3QgZXh0cmVtZSBvZiB0aGUgdHJpYW5nbGUgcG9pbnRzIGludGVyc2VjdHMgclxuXHRcdGlmICggTWF0aC5tYXgoIC0gTWF0aC5tYXgoIHAwLCBwMSwgcDIgKSwgTWF0aC5taW4oIHAwLCBwMSwgcDIgKSApID4gciApIHtcblxuXHRcdFx0Ly8gcG9pbnRzIG9mIHRoZSBwcm9qZWN0ZWQgdHJpYW5nbGUgYXJlIG91dHNpZGUgdGhlIHByb2plY3RlZCBoYWxmLWxlbmd0aCBvZiB0aGUgYWFiYlxuXHRcdFx0Ly8gdGhlIGF4aXMgaXMgc2VwYXJhdGluZyBhbmQgd2UgY2FuIGV4aXRcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG5cbn1cblxuY29uc3QgX2JveCQzID0gLypAX19QVVJFX18qLyBuZXcgQm94MygpO1xuY29uc3QgX3YxJDYgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdjIkMyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY2xhc3MgU3BoZXJlIHtcblxuXHRjb25zdHJ1Y3RvciggY2VudGVyID0gbmV3IFZlY3RvcjMoKSwgcmFkaXVzID0gLSAxICkge1xuXG5cdFx0dGhpcy5pc1NwaGVyZSA9IHRydWU7XG5cblx0XHR0aGlzLmNlbnRlciA9IGNlbnRlcjtcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblxuXHR9XG5cblx0c2V0KCBjZW50ZXIsIHJhZGl1cyApIHtcblxuXHRcdHRoaXMuY2VudGVyLmNvcHkoIGNlbnRlciApO1xuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Qb2ludHMoIHBvaW50cywgb3B0aW9uYWxDZW50ZXIgKSB7XG5cblx0XHRjb25zdCBjZW50ZXIgPSB0aGlzLmNlbnRlcjtcblxuXHRcdGlmICggb3B0aW9uYWxDZW50ZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y2VudGVyLmNvcHkoIG9wdGlvbmFsQ2VudGVyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfYm94JDMuc2V0RnJvbVBvaW50cyggcG9pbnRzICkuZ2V0Q2VudGVyKCBjZW50ZXIgKTtcblxuXHRcdH1cblxuXHRcdGxldCBtYXhSYWRpdXNTcSA9IDA7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludHNbIGkgXSApICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb3B5KCBzcGhlcmUgKSB7XG5cblx0XHR0aGlzLmNlbnRlci5jb3B5KCBzcGhlcmUuY2VudGVyICk7XG5cdFx0dGhpcy5yYWRpdXMgPSBzcGhlcmUucmFkaXVzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGlzRW1wdHkoKSB7XG5cblx0XHRyZXR1cm4gKCB0aGlzLnJhZGl1cyA8IDAgKTtcblxuXHR9XG5cblx0bWFrZUVtcHR5KCkge1xuXG5cdFx0dGhpcy5jZW50ZXIuc2V0KCAwLCAwLCAwICk7XG5cdFx0dGhpcy5yYWRpdXMgPSAtIDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29udGFpbnNQb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApO1xuXG5cdH1cblxuXHRkaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuICggcG9pbnQuZGlzdGFuY2VUbyggdGhpcy5jZW50ZXIgKSAtIHRoaXMucmFkaXVzICk7XG5cblx0fVxuXG5cdGludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApIHtcblxuXHRcdGNvbnN0IHJhZGl1c1N1bSA9IHRoaXMucmFkaXVzICsgc3BoZXJlLnJhZGl1cztcblxuXHRcdHJldHVybiBzcGhlcmUuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggcmFkaXVzU3VtICogcmFkaXVzU3VtICk7XG5cblx0fVxuXG5cdGludGVyc2VjdHNCb3goIGJveCApIHtcblxuXHRcdHJldHVybiBib3guaW50ZXJzZWN0c1NwaGVyZSggdGhpcyApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzUGxhbmUoIHBsYW5lICkge1xuXG5cdFx0cmV0dXJuIE1hdGguYWJzKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMuY2VudGVyICkgKSA8PSB0aGlzLnJhZGl1cztcblxuXHR9XG5cblx0Y2xhbXBQb2ludCggcG9pbnQsIHRhcmdldCApIHtcblxuXHRcdGNvbnN0IGRlbHRhTGVuZ3RoU3EgPSB0aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuXHRcdHRhcmdldC5jb3B5KCBwb2ludCApO1xuXG5cdFx0aWYgKCBkZWx0YUxlbmd0aFNxID4gKCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICkgKSB7XG5cblx0XHRcdHRhcmdldC5zdWIoIHRoaXMuY2VudGVyICkubm9ybWFsaXplKCk7XG5cdFx0XHR0YXJnZXQubXVsdGlwbHlTY2FsYXIoIHRoaXMucmFkaXVzICkuYWRkKCB0aGlzLmNlbnRlciApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0Z2V0Qm91bmRpbmdCb3goIHRhcmdldCApIHtcblxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB7XG5cblx0XHRcdC8vIEVtcHR5IHNwaGVyZSBwcm9kdWNlcyBlbXB0eSBib3VuZGluZyBib3hcblx0XHRcdHRhcmdldC5tYWtlRW1wdHkoKTtcblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cblx0XHR9XG5cblx0XHR0YXJnZXQuc2V0KCB0aGlzLmNlbnRlciwgdGhpcy5jZW50ZXIgKTtcblx0XHR0YXJnZXQuZXhwYW5kQnlTY2FsYXIoIHRoaXMucmFkaXVzICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDQoIG1hdHJpeCApIHtcblxuXHRcdHRoaXMuY2VudGVyLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cdFx0dGhpcy5yYWRpdXMgPSB0aGlzLnJhZGl1cyAqIG1hdHJpeC5nZXRNYXhTY2FsZU9uQXhpcygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRyYW5zbGF0ZSggb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5jZW50ZXIuYWRkKCBvZmZzZXQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHBhbmRCeVBvaW50KCBwb2ludCApIHtcblxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB7XG5cblx0XHRcdHRoaXMuY2VudGVyLmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdHRoaXMucmFkaXVzID0gMDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRfdjEkNi5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5jZW50ZXIgKTtcblxuXHRcdGNvbnN0IGxlbmd0aFNxID0gX3YxJDYubGVuZ3RoU3EoKTtcblxuXHRcdGlmICggbGVuZ3RoU3EgPiAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApIHtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSBtaW5pbWFsIHNwaGVyZVxuXG5cdFx0XHRjb25zdCBsZW5ndGggPSBNYXRoLnNxcnQoIGxlbmd0aFNxICk7XG5cblx0XHRcdGNvbnN0IGRlbHRhID0gKCBsZW5ndGggLSB0aGlzLnJhZGl1cyApICogMC41O1xuXG5cdFx0XHR0aGlzLmNlbnRlci5hZGRTY2FsZWRWZWN0b3IoIF92MSQ2LCBkZWx0YSAvIGxlbmd0aCApO1xuXG5cdFx0XHR0aGlzLnJhZGl1cyArPSBkZWx0YTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR1bmlvbiggc3BoZXJlICkge1xuXG5cdFx0aWYgKCBzcGhlcmUuaXNFbXB0eSgpICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB7XG5cblx0XHRcdHRoaXMuY29weSggc3BoZXJlICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmNlbnRlci5lcXVhbHMoIHNwaGVyZS5jZW50ZXIgKSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0IHRoaXMucmFkaXVzID0gTWF0aC5tYXgoIHRoaXMucmFkaXVzLCBzcGhlcmUucmFkaXVzICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfdjIkMy5zdWJWZWN0b3JzKCBzcGhlcmUuY2VudGVyLCB0aGlzLmNlbnRlciApLnNldExlbmd0aCggc3BoZXJlLnJhZGl1cyApO1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIF92MSQ2LmNvcHkoIHNwaGVyZS5jZW50ZXIgKS5hZGQoIF92MiQzICkgKTtcblxuXHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBfdjEkNi5jb3B5KCBzcGhlcmUuY2VudGVyICkuc3ViKCBfdjIkMyApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXF1YWxzKCBzcGhlcmUgKSB7XG5cblx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5lcXVhbHMoIHRoaXMuY2VudGVyICkgJiYgKCBzcGhlcmUucmFkaXVzID09PSB0aGlzLnJhZGl1cyApO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn1cblxuY29uc3QgX3ZlY3RvciRhID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3NlZ0NlbnRlciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9zZWdEaXIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfZGlmZiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX2VkZ2UxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2VkZ2UyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX25vcm1hbCQxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBSYXkge1xuXG5cdGNvbnN0cnVjdG9yKCBvcmlnaW4gPSBuZXcgVmVjdG9yMygpLCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMyggMCwgMCwgLSAxICkgKSB7XG5cblx0XHR0aGlzLm9yaWdpbiA9IG9yaWdpbjtcblx0XHR0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcblxuXHR9XG5cblx0c2V0KCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcblxuXHRcdHRoaXMub3JpZ2luLmNvcHkoIG9yaWdpbiApO1xuXHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIGRpcmVjdGlvbiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHkoIHJheSApIHtcblxuXHRcdHRoaXMub3JpZ2luLmNvcHkoIHJheS5vcmlnaW4gKTtcblx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCByYXkuZGlyZWN0aW9uICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXQoIHQsIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0YXJnZXQuY29weSggdGhpcy5vcmlnaW4gKS5hZGRTY2FsZWRWZWN0b3IoIHRoaXMuZGlyZWN0aW9uLCB0ICk7XG5cblx0fVxuXG5cdGxvb2tBdCggdiApIHtcblxuXHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIHYgKS5zdWIoIHRoaXMub3JpZ2luICkubm9ybWFsaXplKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmVjYXN0KCB0ICkge1xuXG5cdFx0dGhpcy5vcmlnaW4uY29weSggdGhpcy5hdCggdCwgX3ZlY3RvciRhICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCwgdGFyZ2V0ICkge1xuXG5cdFx0dGFyZ2V0LnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApO1xuXG5cdFx0Y29uc3QgZGlyZWN0aW9uRGlzdGFuY2UgPSB0YXJnZXQuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG5cdFx0aWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XG5cblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggdGhpcy5vcmlnaW4gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQuY29weSggdGhpcy5vcmlnaW4gKS5hZGRTY2FsZWRWZWN0b3IoIHRoaXMuZGlyZWN0aW9uLCBkaXJlY3Rpb25EaXN0YW5jZSApO1xuXG5cdH1cblxuXHRkaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSApO1xuXG5cdH1cblxuXHRkaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRjb25zdCBkaXJlY3Rpb25EaXN0YW5jZSA9IF92ZWN0b3IkYS5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cblx0XHQvLyBwb2ludCBiZWhpbmQgdGhlIHJheVxuXG5cdFx0aWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm9yaWdpbi5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuXHRcdH1cblxuXHRcdF92ZWN0b3IkYS5jb3B5KCB0aGlzLm9yaWdpbiApLmFkZFNjYWxlZFZlY3RvciggdGhpcy5kaXJlY3Rpb24sIGRpcmVjdGlvbkRpc3RhbmNlICk7XG5cblx0XHRyZXR1cm4gX3ZlY3RvciRhLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG5cdH1cblxuXHRkaXN0YW5jZVNxVG9TZWdtZW50KCB2MCwgdjEsIG9wdGlvbmFsUG9pbnRPblJheSwgb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcblxuXHRcdC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Btam9uaWFrL0dlb21ldHJpY1Rvb2xzL2Jsb2IvbWFzdGVyL0dURW5naW5lL0luY2x1ZGUvTWF0aGVtYXRpY3MvR3RlRGlzdFJheVNlZ21lbnQuaFxuXHRcdC8vIEl0IHJldHVybnMgdGhlIG1pbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSByYXkgYW5kIHRoZSBzZWdtZW50XG5cdFx0Ly8gZGVmaW5lZCBieSB2MCBhbmQgdjFcblx0XHQvLyBJdCBjYW4gYWxzbyBzZXQgdHdvIG9wdGlvbmFsIHRhcmdldHMgOlxuXHRcdC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHJheVxuXHRcdC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHNlZ21lbnRcblxuXHRcdF9zZWdDZW50ZXIuY29weSggdjAgKS5hZGQoIHYxICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXHRcdF9zZWdEaXIuY29weSggdjEgKS5zdWIoIHYwICkubm9ybWFsaXplKCk7XG5cdFx0X2RpZmYuY29weSggdGhpcy5vcmlnaW4gKS5zdWIoIF9zZWdDZW50ZXIgKTtcblxuXHRcdGNvbnN0IHNlZ0V4dGVudCA9IHYwLmRpc3RhbmNlVG8oIHYxICkgKiAwLjU7XG5cdFx0Y29uc3QgYTAxID0gLSB0aGlzLmRpcmVjdGlvbi5kb3QoIF9zZWdEaXIgKTtcblx0XHRjb25zdCBiMCA9IF9kaWZmLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblx0XHRjb25zdCBiMSA9IC0gX2RpZmYuZG90KCBfc2VnRGlyICk7XG5cdFx0Y29uc3QgYyA9IF9kaWZmLmxlbmd0aFNxKCk7XG5cdFx0Y29uc3QgZGV0ID0gTWF0aC5hYnMoIDEgLSBhMDEgKiBhMDEgKTtcblx0XHRsZXQgczAsIHMxLCBzcXJEaXN0LCBleHREZXQ7XG5cblx0XHRpZiAoIGRldCA+IDAgKSB7XG5cblx0XHRcdC8vIFRoZSByYXkgYW5kIHNlZ21lbnQgYXJlIG5vdCBwYXJhbGxlbC5cblxuXHRcdFx0czAgPSBhMDEgKiBiMSAtIGIwO1xuXHRcdFx0czEgPSBhMDEgKiBiMCAtIGIxO1xuXHRcdFx0ZXh0RGV0ID0gc2VnRXh0ZW50ICogZGV0O1xuXG5cdFx0XHRpZiAoIHMwID49IDAgKSB7XG5cblx0XHRcdFx0aWYgKCBzMSA+PSAtIGV4dERldCApIHtcblxuXHRcdFx0XHRcdGlmICggczEgPD0gZXh0RGV0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyByZWdpb24gMFxuXHRcdFx0XHRcdFx0Ly8gTWluaW11bSBhdCBpbnRlcmlvciBwb2ludHMgb2YgcmF5IGFuZCBzZWdtZW50LlxuXG5cdFx0XHRcdFx0XHRjb25zdCBpbnZEZXQgPSAxIC8gZGV0O1xuXHRcdFx0XHRcdFx0czAgKj0gaW52RGV0O1xuXHRcdFx0XHRcdFx0czEgKj0gaW52RGV0O1xuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IHMwICogKCBzMCArIGEwMSAqIHMxICsgMiAqIGIwICkgKyBzMSAqICggYTAxICogczAgKyBzMSArIDIgKiBiMSApICsgYztcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIHJlZ2lvbiAxXG5cblx0XHRcdFx0XHRcdHMxID0gc2VnRXh0ZW50O1xuXHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gcmVnaW9uIDVcblxuXHRcdFx0XHRcdHMxID0gLSBzZWdFeHRlbnQ7XG5cdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xuXHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggczEgPD0gLSBleHREZXQgKSB7XG5cblx0XHRcdFx0XHQvLyByZWdpb24gNFxuXG5cdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIC0gYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xuXHRcdFx0XHRcdHMxID0gKCBzMCA+IDAgKSA/IC0gc2VnRXh0ZW50IDogTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcblx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHMxIDw9IGV4dERldCApIHtcblxuXHRcdFx0XHRcdC8vIHJlZ2lvbiAzXG5cblx0XHRcdFx0XHRzMCA9IDA7XG5cdFx0XHRcdFx0czEgPSBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xuXHRcdFx0XHRcdHNxckRpc3QgPSBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIHJlZ2lvbiAyXG5cblx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xuXHRcdFx0XHRcdHMxID0gKCBzMCA+IDAgKSA/IHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XG5cdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFJheSBhbmQgc2VnbWVudCBhcmUgcGFyYWxsZWwuXG5cblx0XHRcdHMxID0gKCBhMDEgPiAwICkgPyAtIHNlZ0V4dGVudCA6IHNlZ0V4dGVudDtcblx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcblx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbmFsUG9pbnRPblJheSApIHtcblxuXHRcdFx0b3B0aW9uYWxQb2ludE9uUmF5LmNvcHkoIHRoaXMub3JpZ2luICkuYWRkU2NhbGVkVmVjdG9yKCB0aGlzLmRpcmVjdGlvbiwgczAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcblxuXHRcdFx0b3B0aW9uYWxQb2ludE9uU2VnbWVudC5jb3B5KCBfc2VnQ2VudGVyICkuYWRkU2NhbGVkVmVjdG9yKCBfc2VnRGlyLCBzMSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNxckRpc3Q7XG5cblx0fVxuXG5cdGludGVyc2VjdFNwaGVyZSggc3BoZXJlLCB0YXJnZXQgKSB7XG5cblx0XHRfdmVjdG9yJGEuc3ViVmVjdG9ycyggc3BoZXJlLmNlbnRlciwgdGhpcy5vcmlnaW4gKTtcblx0XHRjb25zdCB0Y2EgPSBfdmVjdG9yJGEuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXHRcdGNvbnN0IGQyID0gX3ZlY3RvciRhLmRvdCggX3ZlY3RvciRhICkgLSB0Y2EgKiB0Y2E7XG5cdFx0Y29uc3QgcmFkaXVzMiA9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xuXG5cdFx0aWYgKCBkMiA+IHJhZGl1czIgKSByZXR1cm4gbnVsbDtcblxuXHRcdGNvbnN0IHRoYyA9IE1hdGguc3FydCggcmFkaXVzMiAtIGQyICk7XG5cblx0XHQvLyB0MCA9IGZpcnN0IGludGVyc2VjdCBwb2ludCAtIGVudHJhbmNlIG9uIGZyb250IG9mIHNwaGVyZVxuXHRcdGNvbnN0IHQwID0gdGNhIC0gdGhjO1xuXG5cdFx0Ly8gdDEgPSBzZWNvbmQgaW50ZXJzZWN0IHBvaW50IC0gZXhpdCBwb2ludCBvbiBiYWNrIG9mIHNwaGVyZVxuXHRcdGNvbnN0IHQxID0gdGNhICsgdGhjO1xuXG5cdFx0Ly8gdGVzdCB0byBzZWUgaWYgdDEgaXMgYmVoaW5kIHRoZSByYXkgLSBpZiBzbywgcmV0dXJuIG51bGxcblx0XHRpZiAoIHQxIDwgMCApIHJldHVybiBudWxsO1xuXG5cdFx0Ly8gdGVzdCB0byBzZWUgaWYgdDAgaXMgYmVoaW5kIHRoZSByYXk6XG5cdFx0Ly8gaWYgaXQgaXMsIHRoZSByYXkgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHNvIHJldHVybiB0aGUgc2Vjb25kIGV4aXQgcG9pbnQgc2NhbGVkIGJ5IHQxLFxuXHRcdC8vIGluIG9yZGVyIHRvIGFsd2F5cyByZXR1cm4gYW4gaW50ZXJzZWN0IHBvaW50IHRoYXQgaXMgaW4gZnJvbnQgb2YgdGhlIHJheS5cblx0XHRpZiAoIHQwIDwgMCApIHJldHVybiB0aGlzLmF0KCB0MSwgdGFyZ2V0ICk7XG5cblx0XHQvLyBlbHNlIHQwIGlzIGluIGZyb250IG9mIHRoZSByYXksIHNvIHJldHVybiB0aGUgZmlyc3QgY29sbGlzaW9uIHBvaW50IHNjYWxlZCBieSB0MFxuXHRcdHJldHVybiB0aGlzLmF0KCB0MCwgdGFyZ2V0ICk7XG5cblx0fVxuXG5cdGludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmRpc3RhbmNlU3FUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgPD0gKCBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cyApO1xuXG5cdH1cblxuXHRkaXN0YW5jZVRvUGxhbmUoIHBsYW5lICkge1xuXG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG5cdFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHtcblxuXHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuXHRcdFx0aWYgKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICkgPT09IDAgKSB7XG5cblx0XHRcdFx0cmV0dXJuIDA7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gTnVsbCBpcyBwcmVmZXJhYmxlIHRvIHVuZGVmaW5lZCBzaW5jZSB1bmRlZmluZWQgbWVhbnMuLi4uIGl0IGlzIHVuZGVmaW5lZFxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHQgPSAtICggdGhpcy5vcmlnaW4uZG90KCBwbGFuZS5ub3JtYWwgKSArIHBsYW5lLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcblxuXHRcdC8vIFJldHVybiBpZiB0aGUgcmF5IG5ldmVyIGludGVyc2VjdHMgdGhlIHBsYW5lXG5cblx0XHRyZXR1cm4gdCA+PSAwID8gdCA6IG51bGw7XG5cblx0fVxuXG5cdGludGVyc2VjdFBsYW5lKCBwbGFuZSwgdGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgdCA9IHRoaXMuZGlzdGFuY2VUb1BsYW5lKCBwbGFuZSApO1xuXG5cdFx0aWYgKCB0ID09PSBudWxsICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmF0KCB0LCB0YXJnZXQgKTtcblxuXHR9XG5cblx0aW50ZXJzZWN0c1BsYW5lKCBwbGFuZSApIHtcblxuXHRcdC8vIGNoZWNrIGlmIHRoZSByYXkgbGllcyBvbiB0aGUgcGxhbmUgZmlyc3RcblxuXHRcdGNvbnN0IGRpc3RUb1BvaW50ID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApO1xuXG5cdFx0aWYgKCBkaXN0VG9Qb2ludCA9PT0gMCApIHtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHRjb25zdCBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cblx0XHRpZiAoIGRlbm9taW5hdG9yICogZGlzdFRvUG9pbnQgPCAwICkge1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdC8vIHJheSBvcmlnaW4gaXMgYmVoaW5kIHRoZSBwbGFuZSAoYW5kIGlzIHBvaW50aW5nIGJlaGluZCBpdClcblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9XG5cblx0aW50ZXJzZWN0Qm94KCBib3gsIHRhcmdldCApIHtcblxuXHRcdGxldCB0bWluLCB0bWF4LCB0eW1pbiwgdHltYXgsIHR6bWluLCB0em1heDtcblxuXHRcdGNvbnN0IGludmRpcnggPSAxIC8gdGhpcy5kaXJlY3Rpb24ueCxcblx0XHRcdGludmRpcnkgPSAxIC8gdGhpcy5kaXJlY3Rpb24ueSxcblx0XHRcdGludmRpcnogPSAxIC8gdGhpcy5kaXJlY3Rpb24uejtcblxuXHRcdGNvbnN0IG9yaWdpbiA9IHRoaXMub3JpZ2luO1xuXG5cdFx0aWYgKCBpbnZkaXJ4ID49IDAgKSB7XG5cblx0XHRcdHRtaW4gPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuXHRcdFx0dG1heCA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0bWluID0gKCBib3gubWF4LnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcblx0XHRcdHRtYXggPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpbnZkaXJ5ID49IDAgKSB7XG5cblx0XHRcdHR5bWluID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblx0XHRcdHR5bWF4ID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHR5bWluID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblx0XHRcdHR5bWF4ID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblxuXHRcdH1cblxuXHRcdGlmICggKCB0bWluID4gdHltYXggKSB8fCAoIHR5bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XG5cblx0XHRpZiAoIHR5bWluID4gdG1pbiB8fCBpc05hTiggdG1pbiApICkgdG1pbiA9IHR5bWluO1xuXG5cdFx0aWYgKCB0eW1heCA8IHRtYXggfHwgaXNOYU4oIHRtYXggKSApIHRtYXggPSB0eW1heDtcblxuXHRcdGlmICggaW52ZGlyeiA+PSAwICkge1xuXG5cdFx0XHR0em1pbiA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cdFx0XHR0em1heCA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0em1pbiA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cdFx0XHR0em1heCA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cblx0XHR9XG5cblx0XHRpZiAoICggdG1pbiA+IHR6bWF4ICkgfHwgKCB0em1pbiA+IHRtYXggKSApIHJldHVybiBudWxsO1xuXG5cdFx0aWYgKCB0em1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0em1pbjtcblxuXHRcdGlmICggdHptYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHptYXg7XG5cblx0XHQvL3JldHVybiBwb2ludCBjbG9zZXN0IHRvIHRoZSByYXkgKHBvc2l0aXZlIHNpZGUpXG5cblx0XHRpZiAoIHRtYXggPCAwICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcy5hdCggdG1pbiA+PSAwID8gdG1pbiA6IHRtYXgsIHRhcmdldCApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RCb3goIGJveCwgX3ZlY3RvciRhICkgIT09IG51bGw7XG5cblx0fVxuXG5cdGludGVyc2VjdFRyaWFuZ2xlKCBhLCBiLCBjLCBiYWNrZmFjZUN1bGxpbmcsIHRhcmdldCApIHtcblxuXHRcdC8vIENvbXB1dGUgdGhlIG9mZnNldCBvcmlnaW4sIGVkZ2VzLCBhbmQgbm9ybWFsLlxuXG5cdFx0Ly8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcG1qb25pYWsvR2VvbWV0cmljVG9vbHMvYmxvYi9tYXN0ZXIvR1RFbmdpbmUvSW5jbHVkZS9NYXRoZW1hdGljcy9HdGVJbnRyUmF5M1RyaWFuZ2xlMy5oXG5cblx0XHRfZWRnZTEuc3ViVmVjdG9ycyggYiwgYSApO1xuXHRcdF9lZGdlMi5zdWJWZWN0b3JzKCBjLCBhICk7XG5cdFx0X25vcm1hbCQxLmNyb3NzVmVjdG9ycyggX2VkZ2UxLCBfZWRnZTIgKTtcblxuXHRcdC8vIFNvbHZlIFEgKyB0KkQgPSBiMSpFMSArIGIyKkUyIChRID0ga0RpZmYsIEQgPSByYXkgZGlyZWN0aW9uLFxuXHRcdC8vIEUxID0ga0VkZ2UxLCBFMiA9IGtFZGdlMiwgTiA9IENyb3NzKEUxLEUyKSkgYnlcblx0XHQvLyAgIHxEb3QoRCxOKXwqYjEgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhRLEUyKSlcblx0XHQvLyAgIHxEb3QoRCxOKXwqYjIgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhFMSxRKSlcblx0XHQvLyAgIHxEb3QoRCxOKXwqdCA9IC1zaWduKERvdChELE4pKSpEb3QoUSxOKVxuXHRcdGxldCBEZE4gPSB0aGlzLmRpcmVjdGlvbi5kb3QoIF9ub3JtYWwkMSApO1xuXHRcdGxldCBzaWduO1xuXG5cdFx0aWYgKCBEZE4gPiAwICkge1xuXG5cdFx0XHRpZiAoIGJhY2tmYWNlQ3VsbGluZyApIHJldHVybiBudWxsO1xuXHRcdFx0c2lnbiA9IDE7XG5cblx0XHR9IGVsc2UgaWYgKCBEZE4gPCAwICkge1xuXG5cdFx0XHRzaWduID0gLSAxO1xuXHRcdFx0RGROID0gLSBEZE47XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdF9kaWZmLnN1YlZlY3RvcnMoIHRoaXMub3JpZ2luLCBhICk7XG5cdFx0Y29uc3QgRGRReEUyID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdCggX2VkZ2UyLmNyb3NzVmVjdG9ycyggX2RpZmYsIF9lZGdlMiApICk7XG5cblx0XHQvLyBiMSA8IDAsIG5vIGludGVyc2VjdGlvblxuXHRcdGlmICggRGRReEUyIDwgMCApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRjb25zdCBEZEUxeFEgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBfZWRnZTEuY3Jvc3MoIF9kaWZmICkgKTtcblxuXHRcdC8vIGIyIDwgMCwgbm8gaW50ZXJzZWN0aW9uXG5cdFx0aWYgKCBEZEUxeFEgPCAwICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdC8vIGIxK2IyID4gMSwgbm8gaW50ZXJzZWN0aW9uXG5cdFx0aWYgKCBEZFF4RTIgKyBEZEUxeFEgPiBEZE4gKSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Ly8gTGluZSBpbnRlcnNlY3RzIHRyaWFuZ2xlLCBjaGVjayBpZiByYXkgZG9lcy5cblx0XHRjb25zdCBRZE4gPSAtIHNpZ24gKiBfZGlmZi5kb3QoIF9ub3JtYWwkMSApO1xuXG5cdFx0Ly8gdCA8IDAsIG5vIGludGVyc2VjdGlvblxuXHRcdGlmICggUWROIDwgMCApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHQvLyBSYXkgaW50ZXJzZWN0cyB0cmlhbmdsZS5cblx0XHRyZXR1cm4gdGhpcy5hdCggUWROIC8gRGROLCB0YXJnZXQgKTtcblxuXHR9XG5cblx0YXBwbHlNYXRyaXg0KCBtYXRyaXg0ICkge1xuXG5cdFx0dGhpcy5vcmlnaW4uYXBwbHlNYXRyaXg0KCBtYXRyaXg0ICk7XG5cdFx0dGhpcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCBtYXRyaXg0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXF1YWxzKCByYXkgKSB7XG5cblx0XHRyZXR1cm4gcmF5Lm9yaWdpbi5lcXVhbHMoIHRoaXMub3JpZ2luICkgJiYgcmF5LmRpcmVjdGlvbi5lcXVhbHMoIHRoaXMuZGlyZWN0aW9uICk7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBNYXRyaXg0IHtcblxuXHRjb25zdHJ1Y3RvciggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xuXG5cdFx0TWF0cml4NC5wcm90b3R5cGUuaXNNYXRyaXg0ID0gdHJ1ZTtcblxuXHRcdHRoaXMuZWxlbWVudHMgPSBbXG5cblx0XHRcdDEsIDAsIDAsIDAsXG5cdFx0XHQwLCAxLCAwLCAwLFxuXHRcdFx0MCwgMCwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdF07XG5cblx0XHRpZiAoIG4xMSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLnNldCggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldCggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSA9IG4xMTsgdGVbIDQgXSA9IG4xMjsgdGVbIDggXSA9IG4xMzsgdGVbIDEyIF0gPSBuMTQ7XG5cdFx0dGVbIDEgXSA9IG4yMTsgdGVbIDUgXSA9IG4yMjsgdGVbIDkgXSA9IG4yMzsgdGVbIDEzIF0gPSBuMjQ7XG5cdFx0dGVbIDIgXSA9IG4zMTsgdGVbIDYgXSA9IG4zMjsgdGVbIDEwIF0gPSBuMzM7IHRlWyAxNCBdID0gbjM0O1xuXHRcdHRlWyAzIF0gPSBuNDE7IHRlWyA3IF0gPSBuNDI7IHRlWyAxMSBdID0gbjQzOyB0ZVsgMTUgXSA9IG40NDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpZGVudGl0eSgpIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCwgMCxcblx0XHRcdDAsIDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XG5cblx0fVxuXG5cdGNvcHkoIG0gKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSA9IG1lWyAwIF07IHRlWyAxIF0gPSBtZVsgMSBdOyB0ZVsgMiBdID0gbWVbIDIgXTsgdGVbIDMgXSA9IG1lWyAzIF07XG5cdFx0dGVbIDQgXSA9IG1lWyA0IF07IHRlWyA1IF0gPSBtZVsgNSBdOyB0ZVsgNiBdID0gbWVbIDYgXTsgdGVbIDcgXSA9IG1lWyA3IF07XG5cdFx0dGVbIDggXSA9IG1lWyA4IF07IHRlWyA5IF0gPSBtZVsgOSBdOyB0ZVsgMTAgXSA9IG1lWyAxMCBdOyB0ZVsgMTEgXSA9IG1lWyAxMSBdO1xuXHRcdHRlWyAxMiBdID0gbWVbIDEyIF07IHRlWyAxMyBdID0gbWVbIDEzIF07IHRlWyAxNCBdID0gbWVbIDE0IF07IHRlWyAxNSBdID0gbWVbIDE1IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weVBvc2l0aW9uKCBtICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzLCBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdO1xuXHRcdHRlWyAxMyBdID0gbWVbIDEzIF07XG5cdFx0dGVbIDE0IF0gPSBtZVsgMTQgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4MyggbSApIHtcblxuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRtZVsgMCBdLCBtZVsgMyBdLCBtZVsgNiBdLCAwLFxuXHRcdFx0bWVbIDEgXSwgbWVbIDQgXSwgbWVbIDcgXSwgMCxcblx0XHRcdG1lWyAyIF0sIG1lWyA1IF0sIG1lWyA4IF0sIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGV4dHJhY3RCYXNpcyggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcblxuXHRcdHhBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDAgKTtcblx0XHR5QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAxICk7XG5cdFx0ekF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VCYXNpcyggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcblxuXHRcdHRoaXMuc2V0KFxuXHRcdFx0eEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcblx0XHRcdHhBeGlzLnksIHlBeGlzLnksIHpBeGlzLnksIDAsXG5cdFx0XHR4QXhpcy56LCB5QXhpcy56LCB6QXhpcy56LCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXh0cmFjdFJvdGF0aW9uKCBtICkge1xuXG5cdFx0Ly8gdGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCByZWZsZWN0aW9uIG1hdHJpY2VzXG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3Qgc2NhbGVYID0gMSAvIF92MSQ1LnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDAgKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzY2FsZVkgPSAxIC8gX3YxJDUuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHNjYWxlWiA9IDEgLyBfdjEkNS5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAyICkubGVuZ3RoKCk7XG5cblx0XHR0ZVsgMCBdID0gbWVbIDAgXSAqIHNjYWxlWDtcblx0XHR0ZVsgMSBdID0gbWVbIDEgXSAqIHNjYWxlWDtcblx0XHR0ZVsgMiBdID0gbWVbIDIgXSAqIHNjYWxlWDtcblx0XHR0ZVsgMyBdID0gMDtcblxuXHRcdHRlWyA0IF0gPSBtZVsgNCBdICogc2NhbGVZO1xuXHRcdHRlWyA1IF0gPSBtZVsgNSBdICogc2NhbGVZO1xuXHRcdHRlWyA2IF0gPSBtZVsgNiBdICogc2NhbGVZO1xuXHRcdHRlWyA3IF0gPSAwO1xuXG5cdFx0dGVbIDggXSA9IG1lWyA4IF0gKiBzY2FsZVo7XG5cdFx0dGVbIDkgXSA9IG1lWyA5IF0gKiBzY2FsZVo7XG5cdFx0dGVbIDEwIF0gPSBtZVsgMTAgXSAqIHNjYWxlWjtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHR0ZVsgMTIgXSA9IDA7XG5cdFx0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAxNCBdID0gMDtcblx0XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVJvdGF0aW9uRnJvbUV1bGVyKCBldWxlciApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGNvbnN0IHggPSBldWxlci54LCB5ID0gZXVsZXIueSwgeiA9IGV1bGVyLno7XG5cdFx0Y29uc3QgYSA9IE1hdGguY29zKCB4ICksIGIgPSBNYXRoLnNpbiggeCApO1xuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggeSApLCBkID0gTWF0aC5zaW4oIHkgKTtcblx0XHRjb25zdCBlID0gTWF0aC5jb3MoIHogKSwgZiA9IE1hdGguc2luKCB6ICk7XG5cblx0XHRpZiAoIGV1bGVyLm9yZGVyID09PSAnWFlaJyApIHtcblxuXHRcdFx0Y29uc3QgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0dGVbIDQgXSA9IC0gYyAqIGY7XG5cdFx0XHR0ZVsgOCBdID0gZDtcblxuXHRcdFx0dGVbIDEgXSA9IGFmICsgYmUgKiBkO1xuXHRcdFx0dGVbIDUgXSA9IGFlIC0gYmYgKiBkO1xuXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGM7XG5cblx0XHRcdHRlWyAyIF0gPSBiZiAtIGFlICogZDtcblx0XHRcdHRlWyA2IF0gPSBiZSArIGFmICogZDtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1lYWicgKSB7XG5cblx0XHRcdGNvbnN0IGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjZSArIGRmICogYjtcblx0XHRcdHRlWyA0IF0gPSBkZSAqIGIgLSBjZjtcblx0XHRcdHRlWyA4IF0gPSBhICogZDtcblxuXHRcdFx0dGVbIDEgXSA9IGEgKiBmO1xuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuXHRcdFx0dGVbIDkgXSA9IC0gYjtcblxuXHRcdFx0dGVbIDIgXSA9IGNmICogYiAtIGRlO1xuXHRcdFx0dGVbIDYgXSA9IGRmICsgY2UgKiBiO1xuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWlhZJyApIHtcblxuXHRcdFx0Y29uc3QgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGNlIC0gZGYgKiBiO1xuXHRcdFx0dGVbIDQgXSA9IC0gYSAqIGY7XG5cdFx0XHR0ZVsgOCBdID0gZGUgKyBjZiAqIGI7XG5cblx0XHRcdHRlWyAxIF0gPSBjZiArIGRlICogYjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSBkZiAtIGNlICogYjtcblxuXHRcdFx0dGVbIDIgXSA9IC0gYSAqIGQ7XG5cdFx0XHR0ZVsgNiBdID0gYjtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pZWCcgKSB7XG5cblx0XHRcdGNvbnN0IGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSBiZSAqIGQgLSBhZjtcblx0XHRcdHRlWyA4IF0gPSBhZSAqIGQgKyBiZjtcblxuXHRcdFx0dGVbIDEgXSA9IGMgKiBmO1xuXHRcdFx0dGVbIDUgXSA9IGJmICogZCArIGFlO1xuXHRcdFx0dGVbIDkgXSA9IGFmICogZCAtIGJlO1xuXG5cdFx0XHR0ZVsgMiBdID0gLSBkO1xuXHRcdFx0dGVbIDYgXSA9IGIgKiBjO1xuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVpYJyApIHtcblxuXHRcdFx0Y29uc3QgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcblxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0dGVbIDQgXSA9IGJkIC0gYWMgKiBmO1xuXHRcdFx0dGVbIDggXSA9IGJjICogZiArIGFkO1xuXG5cdFx0XHR0ZVsgMSBdID0gZjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSAtIGIgKiBlO1xuXG5cdFx0XHR0ZVsgMiBdID0gLSBkICogZTtcblx0XHRcdHRlWyA2IF0gPSBhZCAqIGYgKyBiYztcblx0XHRcdHRlWyAxMCBdID0gYWMgLSBiZCAqIGY7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1haWScgKSB7XG5cblx0XHRcdGNvbnN0IGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSAtIGY7XG5cdFx0XHR0ZVsgOCBdID0gZCAqIGU7XG5cblx0XHRcdHRlWyAxIF0gPSBhYyAqIGYgKyBiZDtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSBhZCAqIGYgLSBiYztcblxuXHRcdFx0dGVbIDIgXSA9IGJjICogZiAtIGFkO1xuXHRcdFx0dGVbIDYgXSA9IGIgKiBlO1xuXHRcdFx0dGVbIDEwIF0gPSBiZCAqIGYgKyBhYztcblxuXHRcdH1cblxuXHRcdC8vIGJvdHRvbSByb3dcblx0XHR0ZVsgMyBdID0gMDtcblx0XHR0ZVsgNyBdID0gMDtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHQvLyBsYXN0IGNvbHVtblxuXHRcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMTMgXSA9IDA7XG5cdFx0dGVbIDE0IF0gPSAwO1xuXHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApIHtcblxuXHRcdHJldHVybiB0aGlzLmNvbXBvc2UoIF96ZXJvLCBxLCBfb25lICk7XG5cblx0fVxuXG5cdGxvb2tBdCggZXllLCB0YXJnZXQsIHVwICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0X3ouc3ViVmVjdG9ycyggZXllLCB0YXJnZXQgKTtcblxuXHRcdGlmICggX3oubGVuZ3RoU3EoKSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gZXllIGFuZCB0YXJnZXQgYXJlIGluIHRoZSBzYW1lIHBvc2l0aW9uXG5cblx0XHRcdF96LnogPSAxO1xuXG5cdFx0fVxuXG5cdFx0X3oubm9ybWFsaXplKCk7XG5cdFx0X3guY3Jvc3NWZWN0b3JzKCB1cCwgX3ogKTtcblxuXHRcdGlmICggX3gubGVuZ3RoU3EoKSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gdXAgYW5kIHogYXJlIHBhcmFsbGVsXG5cblx0XHRcdGlmICggTWF0aC5hYnMoIHVwLnogKSA9PT0gMSApIHtcblxuXHRcdFx0XHRfei54ICs9IDAuMDAwMTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfei56ICs9IDAuMDAwMTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfei5ub3JtYWxpemUoKTtcblx0XHRcdF94LmNyb3NzVmVjdG9ycyggdXAsIF96ICk7XG5cblx0XHR9XG5cblx0XHRfeC5ub3JtYWxpemUoKTtcblx0XHRfeS5jcm9zc1ZlY3RvcnMoIF96LCBfeCApO1xuXG5cdFx0dGVbIDAgXSA9IF94Lng7IHRlWyA0IF0gPSBfeS54OyB0ZVsgOCBdID0gX3oueDtcblx0XHR0ZVsgMSBdID0gX3gueTsgdGVbIDUgXSA9IF95Lnk7IHRlWyA5IF0gPSBfei55O1xuXHRcdHRlWyAyIF0gPSBfeC56OyB0ZVsgNiBdID0gX3kuejsgdGVbIDEwIF0gPSBfei56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5KCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xuXG5cdH1cblxuXHRwcmVtdWx0aXBseSggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIHRoaXMgKTtcblxuXHR9XG5cblx0bXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIHtcblxuXHRcdGNvbnN0IGFlID0gYS5lbGVtZW50cztcblx0XHRjb25zdCBiZSA9IGIuZWxlbWVudHM7XG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDQgXSwgYTEzID0gYWVbIDggXSwgYTE0ID0gYWVbIDEyIF07XG5cdFx0Y29uc3QgYTIxID0gYWVbIDEgXSwgYTIyID0gYWVbIDUgXSwgYTIzID0gYWVbIDkgXSwgYTI0ID0gYWVbIDEzIF07XG5cdFx0Y29uc3QgYTMxID0gYWVbIDIgXSwgYTMyID0gYWVbIDYgXSwgYTMzID0gYWVbIDEwIF0sIGEzNCA9IGFlWyAxNCBdO1xuXHRcdGNvbnN0IGE0MSA9IGFlWyAzIF0sIGE0MiA9IGFlWyA3IF0sIGE0MyA9IGFlWyAxMSBdLCBhNDQgPSBhZVsgMTUgXTtcblxuXHRcdGNvbnN0IGIxMSA9IGJlWyAwIF0sIGIxMiA9IGJlWyA0IF0sIGIxMyA9IGJlWyA4IF0sIGIxNCA9IGJlWyAxMiBdO1xuXHRcdGNvbnN0IGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA1IF0sIGIyMyA9IGJlWyA5IF0sIGIyNCA9IGJlWyAxMyBdO1xuXHRcdGNvbnN0IGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA2IF0sIGIzMyA9IGJlWyAxMCBdLCBiMzQgPSBiZVsgMTQgXTtcblx0XHRjb25zdCBiNDEgPSBiZVsgMyBdLCBiNDIgPSBiZVsgNyBdLCBiNDMgPSBiZVsgMTEgXSwgYjQ0ID0gYmVbIDE1IF07XG5cblx0XHR0ZVsgMCBdID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxICsgYTE0ICogYjQxO1xuXHRcdHRlWyA0IF0gPSBhMTEgKiBiMTIgKyBhMTIgKiBiMjIgKyBhMTMgKiBiMzIgKyBhMTQgKiBiNDI7XG5cdFx0dGVbIDggXSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMyArIGExNCAqIGI0Mztcblx0XHR0ZVsgMTIgXSA9IGExMSAqIGIxNCArIGExMiAqIGIyNCArIGExMyAqIGIzNCArIGExNCAqIGI0NDtcblxuXHRcdHRlWyAxIF0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzEgKyBhMjQgKiBiNDE7XG5cdFx0dGVbIDUgXSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMiArIGEyNCAqIGI0Mjtcblx0XHR0ZVsgOSBdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xuXHRcdHRlWyAxMyBdID0gYTIxICogYjE0ICsgYTIyICogYjI0ICsgYTIzICogYjM0ICsgYTI0ICogYjQ0O1xuXG5cdFx0dGVbIDIgXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcblx0XHR0ZVsgNiBdID0gYTMxICogYjEyICsgYTMyICogYjIyICsgYTMzICogYjMyICsgYTM0ICogYjQyO1xuXHRcdHRlWyAxMCBdID0gYTMxICogYjEzICsgYTMyICogYjIzICsgYTMzICogYjMzICsgYTM0ICogYjQzO1xuXHRcdHRlWyAxNCBdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xuXG5cdFx0dGVbIDMgXSA9IGE0MSAqIGIxMSArIGE0MiAqIGIyMSArIGE0MyAqIGIzMSArIGE0NCAqIGI0MTtcblx0XHR0ZVsgNyBdID0gYTQxICogYjEyICsgYTQyICogYjIyICsgYTQzICogYjMyICsgYTQ0ICogYjQyO1xuXHRcdHRlWyAxMSBdID0gYTQxICogYjEzICsgYTQyICogYjIzICsgYTQzICogYjMzICsgYTQ0ICogYjQzO1xuXHRcdHRlWyAxNSBdID0gYTQxICogYjE0ICsgYTQyICogYjI0ICsgYTQzICogYjM0ICsgYTQ0ICogYjQ0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5U2NhbGFyKCBzICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA4IF0gKj0gczsgdGVbIDEyIF0gKj0gcztcblx0XHR0ZVsgMSBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDkgXSAqPSBzOyB0ZVsgMTMgXSAqPSBzO1xuXHRcdHRlWyAyIF0gKj0gczsgdGVbIDYgXSAqPSBzOyB0ZVsgMTAgXSAqPSBzOyB0ZVsgMTQgXSAqPSBzO1xuXHRcdHRlWyAzIF0gKj0gczsgdGVbIDcgXSAqPSBzOyB0ZVsgMTEgXSAqPSBzOyB0ZVsgMTUgXSAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRldGVybWluYW50KCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgbjExID0gdGVbIDAgXSwgbjEyID0gdGVbIDQgXSwgbjEzID0gdGVbIDggXSwgbjE0ID0gdGVbIDEyIF07XG5cdFx0Y29uc3QgbjIxID0gdGVbIDEgXSwgbjIyID0gdGVbIDUgXSwgbjIzID0gdGVbIDkgXSwgbjI0ID0gdGVbIDEzIF07XG5cdFx0Y29uc3QgbjMxID0gdGVbIDIgXSwgbjMyID0gdGVbIDYgXSwgbjMzID0gdGVbIDEwIF0sIG4zNCA9IHRlWyAxNCBdO1xuXHRcdGNvbnN0IG40MSA9IHRlWyAzIF0sIG40MiA9IHRlWyA3IF0sIG40MyA9IHRlWyAxMSBdLCBuNDQgPSB0ZVsgMTUgXTtcblxuXHRcdC8vVE9ETzogbWFrZSB0aGlzIG1vcmUgZWZmaWNpZW50XG5cdFx0Ly8oIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSApXG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0bjQxICogKFxuXHRcdFx0XHQrIG4xNCAqIG4yMyAqIG4zMlxuXHRcdFx0XHQgLSBuMTMgKiBuMjQgKiBuMzJcblx0XHRcdFx0IC0gbjE0ICogbjIyICogbjMzXG5cdFx0XHRcdCArIG4xMiAqIG4yNCAqIG4zM1xuXHRcdFx0XHQgKyBuMTMgKiBuMjIgKiBuMzRcblx0XHRcdFx0IC0gbjEyICogbjIzICogbjM0XG5cdFx0XHQpICtcblx0XHRcdG40MiAqIChcblx0XHRcdFx0KyBuMTEgKiBuMjMgKiBuMzRcblx0XHRcdFx0IC0gbjExICogbjI0ICogbjMzXG5cdFx0XHRcdCArIG4xNCAqIG4yMSAqIG4zM1xuXHRcdFx0XHQgLSBuMTMgKiBuMjEgKiBuMzRcblx0XHRcdFx0ICsgbjEzICogbjI0ICogbjMxXG5cdFx0XHRcdCAtIG4xNCAqIG4yMyAqIG4zMVxuXHRcdFx0KSArXG5cdFx0XHRuNDMgKiAoXG5cdFx0XHRcdCsgbjExICogbjI0ICogbjMyXG5cdFx0XHRcdCAtIG4xMSAqIG4yMiAqIG4zNFxuXHRcdFx0XHQgLSBuMTQgKiBuMjEgKiBuMzJcblx0XHRcdFx0ICsgbjEyICogbjIxICogbjM0XG5cdFx0XHRcdCArIG4xNCAqIG4yMiAqIG4zMVxuXHRcdFx0XHQgLSBuMTIgKiBuMjQgKiBuMzFcblx0XHRcdCkgK1xuXHRcdFx0bjQ0ICogKFxuXHRcdFx0XHQtIG4xMyAqIG4yMiAqIG4zMVxuXHRcdFx0XHQgLSBuMTEgKiBuMjMgKiBuMzJcblx0XHRcdFx0ICsgbjExICogbjIyICogbjMzXG5cdFx0XHRcdCArIG4xMyAqIG4yMSAqIG4zMlxuXHRcdFx0XHQgLSBuMTIgKiBuMjEgKiBuMzNcblx0XHRcdFx0ICsgbjEyICogbjIzICogbjMxXG5cdFx0XHQpXG5cblx0XHQpO1xuXG5cdH1cblxuXHR0cmFuc3Bvc2UoKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0bGV0IHRtcDtcblxuXHRcdHRtcCA9IHRlWyAxIF07IHRlWyAxIF0gPSB0ZVsgNCBdOyB0ZVsgNCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAyIF07IHRlWyAyIF0gPSB0ZVsgOCBdOyB0ZVsgOCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyA2IF07IHRlWyA2IF0gPSB0ZVsgOSBdOyB0ZVsgOSBdID0gdG1wO1xuXG5cdFx0dG1wID0gdGVbIDMgXTsgdGVbIDMgXSA9IHRlWyAxMiBdOyB0ZVsgMTIgXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgNyBdOyB0ZVsgNyBdID0gdGVbIDEzIF07IHRlWyAxMyBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAxMSBdOyB0ZVsgMTEgXSA9IHRlWyAxNCBdOyB0ZVsgMTQgXSA9IHRtcDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRQb3NpdGlvbiggeCwgeSwgeiApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGlmICggeC5pc1ZlY3RvcjMgKSB7XG5cblx0XHRcdHRlWyAxMiBdID0geC54O1xuXHRcdFx0dGVbIDEzIF0gPSB4Lnk7XG5cdFx0XHR0ZVsgMTQgXSA9IHguejtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRlWyAxMiBdID0geDtcblx0XHRcdHRlWyAxMyBdID0geTtcblx0XHRcdHRlWyAxNCBdID0gejtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpbnZlcnQoKSB7XG5cblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG1cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHMsXG5cblx0XHRcdG4xMSA9IHRlWyAwIF0sIG4yMSA9IHRlWyAxIF0sIG4zMSA9IHRlWyAyIF0sIG40MSA9IHRlWyAzIF0sXG5cdFx0XHRuMTIgPSB0ZVsgNCBdLCBuMjIgPSB0ZVsgNSBdLCBuMzIgPSB0ZVsgNiBdLCBuNDIgPSB0ZVsgNyBdLFxuXHRcdFx0bjEzID0gdGVbIDggXSwgbjIzID0gdGVbIDkgXSwgbjMzID0gdGVbIDEwIF0sIG40MyA9IHRlWyAxMSBdLFxuXHRcdFx0bjE0ID0gdGVbIDEyIF0sIG4yNCA9IHRlWyAxMyBdLCBuMzQgPSB0ZVsgMTQgXSwgbjQ0ID0gdGVbIDE1IF0sXG5cblx0XHRcdHQxMSA9IG4yMyAqIG4zNCAqIG40MiAtIG4yNCAqIG4zMyAqIG40MiArIG4yNCAqIG4zMiAqIG40MyAtIG4yMiAqIG4zNCAqIG40MyAtIG4yMyAqIG4zMiAqIG40NCArIG4yMiAqIG4zMyAqIG40NCxcblx0XHRcdHQxMiA9IG4xNCAqIG4zMyAqIG40MiAtIG4xMyAqIG4zNCAqIG40MiAtIG4xNCAqIG4zMiAqIG40MyArIG4xMiAqIG4zNCAqIG40MyArIG4xMyAqIG4zMiAqIG40NCAtIG4xMiAqIG4zMyAqIG40NCxcblx0XHRcdHQxMyA9IG4xMyAqIG4yNCAqIG40MiAtIG4xNCAqIG4yMyAqIG40MiArIG4xNCAqIG4yMiAqIG40MyAtIG4xMiAqIG4yNCAqIG40MyAtIG4xMyAqIG4yMiAqIG40NCArIG4xMiAqIG4yMyAqIG40NCxcblx0XHRcdHQxNCA9IG4xNCAqIG4yMyAqIG4zMiAtIG4xMyAqIG4yNCAqIG4zMiAtIG4xNCAqIG4yMiAqIG4zMyArIG4xMiAqIG4yNCAqIG4zMyArIG4xMyAqIG4yMiAqIG4zNCAtIG4xMiAqIG4yMyAqIG4zNDtcblxuXHRcdGNvbnN0IGRldCA9IG4xMSAqIHQxMSArIG4yMSAqIHQxMiArIG4zMSAqIHQxMyArIG40MSAqIHQxNDtcblxuXHRcdGlmICggZGV0ID09PSAwICkgcmV0dXJuIHRoaXMuc2V0KCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwICk7XG5cblx0XHRjb25zdCBkZXRJbnYgPSAxIC8gZGV0O1xuXG5cdFx0dGVbIDAgXSA9IHQxMSAqIGRldEludjtcblx0XHR0ZVsgMSBdID0gKCBuMjQgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzEgKiBuNDMgKyBuMjEgKiBuMzQgKiBuNDMgKyBuMjMgKiBuMzEgKiBuNDQgLSBuMjEgKiBuMzMgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgMiBdID0gKCBuMjIgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzIgKiBuNDEgKyBuMjQgKiBuMzEgKiBuNDIgLSBuMjEgKiBuMzQgKiBuNDIgLSBuMjIgKiBuMzEgKiBuNDQgKyBuMjEgKiBuMzIgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgMyBdID0gKCBuMjMgKiBuMzIgKiBuNDEgLSBuMjIgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzEgKiBuNDIgKyBuMjEgKiBuMzMgKiBuNDIgKyBuMjIgKiBuMzEgKiBuNDMgLSBuMjEgKiBuMzIgKiBuNDMgKSAqIGRldEludjtcblxuXHRcdHRlWyA0IF0gPSB0MTIgKiBkZXRJbnY7XG5cdFx0dGVbIDUgXSA9ICggbjEzICogbjM0ICogbjQxIC0gbjE0ICogbjMzICogbjQxICsgbjE0ICogbjMxICogbjQzIC0gbjExICogbjM0ICogbjQzIC0gbjEzICogbjMxICogbjQ0ICsgbjExICogbjMzICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDYgXSA9ICggbjE0ICogbjMyICogbjQxIC0gbjEyICogbjM0ICogbjQxIC0gbjE0ICogbjMxICogbjQyICsgbjExICogbjM0ICogbjQyICsgbjEyICogbjMxICogbjQ0IC0gbjExICogbjMyICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDcgXSA9ICggbjEyICogbjMzICogbjQxIC0gbjEzICogbjMyICogbjQxICsgbjEzICogbjMxICogbjQyIC0gbjExICogbjMzICogbjQyIC0gbjEyICogbjMxICogbjQzICsgbjExICogbjMyICogbjQzICkgKiBkZXRJbnY7XG5cblx0XHR0ZVsgOCBdID0gdDEzICogZGV0SW52O1xuXHRcdHRlWyA5IF0gPSAoIG4xNCAqIG4yMyAqIG40MSAtIG4xMyAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMSAqIG40MyArIG4xMSAqIG4yNCAqIG40MyArIG4xMyAqIG4yMSAqIG40NCAtIG4xMSAqIG4yMyAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAxMCBdID0gKCBuMTIgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjIgKiBuNDEgKyBuMTQgKiBuMjEgKiBuNDIgLSBuMTEgKiBuMjQgKiBuNDIgLSBuMTIgKiBuMjEgKiBuNDQgKyBuMTEgKiBuMjIgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgMTEgXSA9ICggbjEzICogbjIyICogbjQxIC0gbjEyICogbjIzICogbjQxIC0gbjEzICogbjIxICogbjQyICsgbjExICogbjIzICogbjQyICsgbjEyICogbjIxICogbjQzIC0gbjExICogbjIyICogbjQzICkgKiBkZXRJbnY7XG5cblx0XHR0ZVsgMTIgXSA9IHQxNCAqIGRldEludjtcblx0XHR0ZVsgMTMgXSA9ICggbjEzICogbjI0ICogbjMxIC0gbjE0ICogbjIzICogbjMxICsgbjE0ICogbjIxICogbjMzIC0gbjExICogbjI0ICogbjMzIC0gbjEzICogbjIxICogbjM0ICsgbjExICogbjIzICogbjM0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDE0IF0gPSAoIG4xNCAqIG4yMiAqIG4zMSAtIG4xMiAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMSAqIG4zMiArIG4xMSAqIG4yNCAqIG4zMiArIG4xMiAqIG4yMSAqIG4zNCAtIG4xMSAqIG4yMiAqIG4zNCApICogZGV0SW52O1xuXHRcdHRlWyAxNSBdID0gKCBuMTIgKiBuMjMgKiBuMzEgLSBuMTMgKiBuMjIgKiBuMzEgKyBuMTMgKiBuMjEgKiBuMzIgLSBuMTEgKiBuMjMgKiBuMzIgLSBuMTIgKiBuMjEgKiBuMzMgKyBuMTEgKiBuMjIgKiBuMzMgKSAqIGRldEludjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzY2FsZSggdiApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCB4ID0gdi54LCB5ID0gdi55LCB6ID0gdi56O1xuXG5cdFx0dGVbIDAgXSAqPSB4OyB0ZVsgNCBdICo9IHk7IHRlWyA4IF0gKj0gejtcblx0XHR0ZVsgMSBdICo9IHg7IHRlWyA1IF0gKj0geTsgdGVbIDkgXSAqPSB6O1xuXHRcdHRlWyAyIF0gKj0geDsgdGVbIDYgXSAqPSB5OyB0ZVsgMTAgXSAqPSB6O1xuXHRcdHRlWyAzIF0gKj0geDsgdGVbIDcgXSAqPSB5OyB0ZVsgMTEgXSAqPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldE1heFNjYWxlT25BeGlzKCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3Qgc2NhbGVYU3EgPSB0ZVsgMCBdICogdGVbIDAgXSArIHRlWyAxIF0gKiB0ZVsgMSBdICsgdGVbIDIgXSAqIHRlWyAyIF07XG5cdFx0Y29uc3Qgc2NhbGVZU3EgPSB0ZVsgNCBdICogdGVbIDQgXSArIHRlWyA1IF0gKiB0ZVsgNSBdICsgdGVbIDYgXSAqIHRlWyA2IF07XG5cdFx0Y29uc3Qgc2NhbGVaU3EgPSB0ZVsgOCBdICogdGVbIDggXSArIHRlWyA5IF0gKiB0ZVsgOSBdICsgdGVbIDEwIF0gKiB0ZVsgMTAgXTtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIE1hdGgubWF4KCBzY2FsZVhTcSwgc2NhbGVZU3EsIHNjYWxlWlNxICkgKTtcblxuXHR9XG5cblx0bWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICkge1xuXG5cdFx0aWYgKCB4LmlzVmVjdG9yMyApIHtcblxuXHRcdFx0dGhpcy5zZXQoXG5cblx0XHRcdFx0MSwgMCwgMCwgeC54LFxuXHRcdFx0XHQwLCAxLCAwLCB4LnksXG5cdFx0XHRcdDAsIDAsIDEsIHgueixcblx0XHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0XHQpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5zZXQoXG5cblx0XHRcdFx0MSwgMCwgMCwgeCxcblx0XHRcdFx0MCwgMSwgMCwgeSxcblx0XHRcdFx0MCwgMCwgMSwgeixcblx0XHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0XHQpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvblgoIHRoZXRhICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCwgMCxcblx0XHRcdDAsIGMsIC0gcywgMCxcblx0XHRcdDAsIHMsIGMsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvblkoIHRoZXRhICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0IGMsIDAsIHMsIDAsXG5cdFx0XHQgMCwgMSwgMCwgMCxcblx0XHRcdC0gcywgMCwgYywgMCxcblx0XHRcdCAwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvblooIHRoZXRhICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0YywgLSBzLCAwLCAwLFxuXHRcdFx0cywgYywgMCwgMCxcblx0XHRcdDAsIDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvbkF4aXMoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gQmFzZWQgb24gaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9yZWZlcmVuY2UvYXJ0aWNsZXMvYXJ0aWNsZTExOTkuYXNwXG5cblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIGFuZ2xlICk7XG5cdFx0Y29uc3QgcyA9IE1hdGguc2luKCBhbmdsZSApO1xuXHRcdGNvbnN0IHQgPSAxIC0gYztcblx0XHRjb25zdCB4ID0gYXhpcy54LCB5ID0gYXhpcy55LCB6ID0gYXhpcy56O1xuXHRcdGNvbnN0IHR4ID0gdCAqIHgsIHR5ID0gdCAqIHk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0dHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxuXHRcdFx0dHggKiB5ICsgcyAqIHosIHR5ICogeSArIGMsIHR5ICogeiAtIHMgKiB4LCAwLFxuXHRcdFx0dHggKiB6IC0gcyAqIHksIHR5ICogeiArIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlU2NhbGUoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0eCwgMCwgMCwgMCxcblx0XHRcdDAsIHksIDAsIDAsXG5cdFx0XHQwLCAwLCB6LCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlU2hlYXIoIHh5LCB4eiwgeXgsIHl6LCB6eCwgenkgKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgeXgsIHp4LCAwLFxuXHRcdFx0eHksIDEsIHp5LCAwLFxuXHRcdFx0eHosIHl6LCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRjb25zdCB4ID0gcXVhdGVybmlvbi5feCwgeSA9IHF1YXRlcm5pb24uX3ksIHogPSBxdWF0ZXJuaW9uLl96LCB3ID0gcXVhdGVybmlvbi5fdztcblx0XHRjb25zdCB4MiA9IHggKyB4LFx0eTIgPSB5ICsgeSwgejIgPSB6ICsgejtcblx0XHRjb25zdCB4eCA9IHggKiB4MiwgeHkgPSB4ICogeTIsIHh6ID0geCAqIHoyO1xuXHRcdGNvbnN0IHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XG5cdFx0Y29uc3Qgd3ggPSB3ICogeDIsIHd5ID0gdyAqIHkyLCB3eiA9IHcgKiB6MjtcblxuXHRcdGNvbnN0IHN4ID0gc2NhbGUueCwgc3kgPSBzY2FsZS55LCBzeiA9IHNjYWxlLno7XG5cblx0XHR0ZVsgMCBdID0gKCAxIC0gKCB5eSArIHp6ICkgKSAqIHN4O1xuXHRcdHRlWyAxIF0gPSAoIHh5ICsgd3ogKSAqIHN4O1xuXHRcdHRlWyAyIF0gPSAoIHh6IC0gd3kgKSAqIHN4O1xuXHRcdHRlWyAzIF0gPSAwO1xuXG5cdFx0dGVbIDQgXSA9ICggeHkgLSB3eiApICogc3k7XG5cdFx0dGVbIDUgXSA9ICggMSAtICggeHggKyB6eiApICkgKiBzeTtcblx0XHR0ZVsgNiBdID0gKCB5eiArIHd4ICkgKiBzeTtcblx0XHR0ZVsgNyBdID0gMDtcblxuXHRcdHRlWyA4IF0gPSAoIHh6ICsgd3kgKSAqIHN6O1xuXHRcdHRlWyA5IF0gPSAoIHl6IC0gd3ggKSAqIHN6O1xuXHRcdHRlWyAxMCBdID0gKCAxIC0gKCB4eCArIHl5ICkgKSAqIHN6O1xuXHRcdHRlWyAxMSBdID0gMDtcblxuXHRcdHRlWyAxMiBdID0gcG9zaXRpb24ueDtcblx0XHR0ZVsgMTMgXSA9IHBvc2l0aW9uLnk7XG5cdFx0dGVbIDE0IF0gPSBwb3NpdGlvbi56O1xuXHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGxldCBzeCA9IF92MSQ1LnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHN5ID0gX3YxJDUuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc3ogPSBfdjEkNS5zZXQoIHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdICkubGVuZ3RoKCk7XG5cblx0XHQvLyBpZiBkZXRlcm1pbmUgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gaW52ZXJ0IG9uZSBzY2FsZVxuXHRcdGNvbnN0IGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQoKTtcblx0XHRpZiAoIGRldCA8IDAgKSBzeCA9IC0gc3g7XG5cblx0XHRwb3NpdGlvbi54ID0gdGVbIDEyIF07XG5cdFx0cG9zaXRpb24ueSA9IHRlWyAxMyBdO1xuXHRcdHBvc2l0aW9uLnogPSB0ZVsgMTQgXTtcblxuXHRcdC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG5cdFx0X20xJDIuY29weSggdGhpcyApO1xuXG5cdFx0Y29uc3QgaW52U1ggPSAxIC8gc3g7XG5cdFx0Y29uc3QgaW52U1kgPSAxIC8gc3k7XG5cdFx0Y29uc3QgaW52U1ogPSAxIC8gc3o7XG5cblx0XHRfbTEkMi5lbGVtZW50c1sgMCBdICo9IGludlNYO1xuXHRcdF9tMSQyLmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XG5cdFx0X20xJDIuZWxlbWVudHNbIDIgXSAqPSBpbnZTWDtcblxuXHRcdF9tMSQyLmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XG5cdFx0X20xJDIuZWxlbWVudHNbIDUgXSAqPSBpbnZTWTtcblx0XHRfbTEkMi5lbGVtZW50c1sgNiBdICo9IGludlNZO1xuXG5cdFx0X20xJDIuZWxlbWVudHNbIDggXSAqPSBpbnZTWjtcblx0XHRfbTEkMi5lbGVtZW50c1sgOSBdICo9IGludlNaO1xuXHRcdF9tMSQyLmVsZW1lbnRzWyAxMCBdICo9IGludlNaO1xuXG5cdFx0cXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9tMSQyICk7XG5cblx0XHRzY2FsZS54ID0gc3g7XG5cdFx0c2NhbGUueSA9IHN5O1xuXHRcdHNjYWxlLnogPSBzejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUGVyc3BlY3RpdmUoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyLCBjb29yZGluYXRlU3lzdGVtID0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IHggPSAyICogbmVhciAvICggcmlnaHQgLSBsZWZ0ICk7XG5cdFx0Y29uc3QgeSA9IDIgKiBuZWFyIC8gKCB0b3AgLSBib3R0b20gKTtcblxuXHRcdGNvbnN0IGEgPSAoIHJpZ2h0ICsgbGVmdCApIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHRjb25zdCBiID0gKCB0b3AgKyBib3R0b20gKSAvICggdG9wIC0gYm90dG9tICk7XG5cblx0XHRsZXQgYywgZDtcblxuXHRcdGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHRjID0gLSAoIGZhciArIG5lYXIgKSAvICggZmFyIC0gbmVhciApO1xuXHRcdFx0ZCA9ICggLSAyICogZmFyICogbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHR9IGVsc2UgaWYgKCBjb29yZGluYXRlU3lzdGVtID09PSBXZWJHUFVDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHRjID0gLSBmYXIgLyAoIGZhciAtIG5lYXIgKTtcblx0XHRcdGQgPSAoIC0gZmFyICogbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5NYXRyaXg0Lm1ha2VQZXJzcGVjdGl2ZSgpOiBJbnZhbGlkIGNvb3JkaW5hdGUgc3lzdGVtOiAnICsgY29vcmRpbmF0ZVN5c3RlbSApO1xuXG5cdFx0fVxuXG5cdFx0dGVbIDAgXSA9IHg7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSBhOyBcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMSBdID0gMDtcdHRlWyA1IF0gPSB5O1x0dGVbIDkgXSA9IGI7IFx0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAyIF0gPSAwO1x0dGVbIDYgXSA9IDA7XHR0ZVsgMTAgXSA9IGM7IFx0dGVbIDE0IF0gPSBkO1xuXHRcdHRlWyAzIF0gPSAwO1x0dGVbIDcgXSA9IDA7XHR0ZVsgMTEgXSA9IC0gMTtcdHRlWyAxNSBdID0gMDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlT3J0aG9ncmFwaGljKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciwgY29vcmRpbmF0ZVN5c3RlbSA9IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCB3ID0gMS4wIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHRjb25zdCBoID0gMS4wIC8gKCB0b3AgLSBib3R0b20gKTtcblx0XHRjb25zdCBwID0gMS4wIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHRjb25zdCB4ID0gKCByaWdodCArIGxlZnQgKSAqIHc7XG5cdFx0Y29uc3QgeSA9ICggdG9wICsgYm90dG9tICkgKiBoO1xuXG5cdFx0bGV0IHosIHpJbnY7XG5cblx0XHRpZiAoIGNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0eiA9ICggZmFyICsgbmVhciApICogcDtcblx0XHRcdHpJbnYgPSAtIDIgKiBwO1xuXG5cdFx0fSBlbHNlIGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0eiA9IG5lYXIgKiBwO1xuXHRcdFx0ekludiA9IC0gMSAqIHA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5NYXRyaXg0Lm1ha2VPcnRob2dyYXBoaWMoKTogSW52YWxpZCBjb29yZGluYXRlIHN5c3RlbTogJyArIGNvb3JkaW5hdGVTeXN0ZW0gKTtcblxuXHRcdH1cblxuXHRcdHRlWyAwIF0gPSAyICogdztcdHRlWyA0IF0gPSAwO1x0XHR0ZVsgOCBdID0gMDsgXHRcdHRlWyAxMiBdID0gLSB4O1xuXHRcdHRlWyAxIF0gPSAwOyBcdFx0dGVbIDUgXSA9IDIgKiBoO1x0dGVbIDkgXSA9IDA7IFx0XHR0ZVsgMTMgXSA9IC0geTtcblx0XHR0ZVsgMiBdID0gMDsgXHRcdHRlWyA2IF0gPSAwO1x0XHR0ZVsgMTAgXSA9IHpJbnY7XHR0ZVsgMTQgXSA9IC0gejtcblx0XHR0ZVsgMyBdID0gMDsgXHRcdHRlWyA3IF0gPSAwO1x0XHR0ZVsgMTEgXSA9IDA7XHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlcXVhbHMoIG1hdHJpeCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmVsZW1lbnRzWyBpIF0gPSBhcnJheVsgaSArIG9mZnNldCBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdID0gdGVbIDggXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgOSBdID0gdGVbIDkgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTAgXSA9IHRlWyAxMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMSBdID0gdGVbIDExIF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMyBdID0gdGVbIDEzIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDE0IF0gPSB0ZVsgMTQgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxufVxuXG5jb25zdCBfdjEkNSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9tMSQyID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3plcm8gPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAwLCAwLCAwICk7XG5jb25zdCBfb25lID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggMSwgMSwgMSApO1xuY29uc3QgX3ggPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfeSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF96ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfbWF0cml4JDIgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfcXVhdGVybmlvbiQzID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xuXG5jbGFzcyBFdWxlciB7XG5cblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCwgeiA9IDAsIG9yZGVyID0gRXVsZXIuREVGQVVMVF9PUkRFUiApIHtcblxuXHRcdHRoaXMuaXNFdWxlciA9IHRydWU7XG5cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdH1cblxuXHRnZXQgeCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl94O1xuXG5cdH1cblxuXHRzZXQgeCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl94ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgeSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl95O1xuXG5cdH1cblxuXHRzZXQgeSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl95ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgeigpIHtcblxuXHRcdHJldHVybiB0aGlzLl96O1xuXG5cdH1cblxuXHRzZXQgeiggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgb3JkZXIoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fb3JkZXI7XG5cblx0fVxuXG5cdHNldCBvcmRlciggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl9vcmRlciA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0c2V0KCB4LCB5LCB6LCBvcmRlciA9IHRoaXMuX29yZGVyICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIgKTtcblxuXHR9XG5cblx0Y29weSggZXVsZXIgKSB7XG5cblx0XHR0aGlzLl94ID0gZXVsZXIuX3g7XG5cdFx0dGhpcy5feSA9IGV1bGVyLl95O1xuXHRcdHRoaXMuX3ogPSBldWxlci5fejtcblx0XHR0aGlzLl9vcmRlciA9IGV1bGVyLl9vcmRlcjtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUm90YXRpb25NYXRyaXgoIG0sIG9yZGVyID0gdGhpcy5fb3JkZXIsIHVwZGF0ZSA9IHRydWUgKSB7XG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0Y29uc3QgdGUgPSBtLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF07XG5cdFx0Y29uc3QgbTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXTtcblx0XHRjb25zdCBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcblxuXHRcdHN3aXRjaCAoIG9yZGVyICkge1xuXG5cdFx0XHRjYXNlICdYWVonOlxuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIGNsYW1wKCBtMTMsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTExICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVhaJzpcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMjMsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1pYWSc6XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWVgnOlxuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0zMSwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVpYJzpcblxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCBjbGFtcCggbTIxLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMjIgKTtcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1haWSc6XG5cblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggLSBjbGFtcCggbTEyLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feSA9IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogJyArIG9yZGVyICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdFx0aWYgKCB1cGRhdGUgPT09IHRydWUgKSB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVF1YXRlcm5pb24oIHEsIG9yZGVyLCB1cGRhdGUgKSB7XG5cblx0XHRfbWF0cml4JDIubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggX21hdHJpeCQyLCBvcmRlciwgdXBkYXRlICk7XG5cblx0fVxuXG5cdHNldEZyb21WZWN0b3IzKCB2LCBvcmRlciA9IHRoaXMuX29yZGVyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0KCB2LngsIHYueSwgdi56LCBvcmRlciApO1xuXG5cdH1cblxuXHRyZW9yZGVyKCBuZXdPcmRlciApIHtcblxuXHRcdC8vIFdBUk5JTkc6IHRoaXMgZGlzY2FyZHMgcmV2b2x1dGlvbiBpbmZvcm1hdGlvbiAtYmhvdXN0b25cblxuXHRcdF9xdWF0ZXJuaW9uJDMuc2V0RnJvbUV1bGVyKCB0aGlzICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUXVhdGVybmlvbiggX3F1YXRlcm5pb24kMywgbmV3T3JkZXIgKTtcblxuXHR9XG5cblx0ZXF1YWxzKCBldWxlciApIHtcblxuXHRcdHJldHVybiAoIGV1bGVyLl94ID09PSB0aGlzLl94ICkgJiYgKCBldWxlci5feSA9PT0gdGhpcy5feSApICYmICggZXVsZXIuX3ogPT09IHRoaXMuX3ogKSAmJiAoIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXIgKTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSApIHtcblxuXHRcdHRoaXMuX3ggPSBhcnJheVsgMCBdO1xuXHRcdHRoaXMuX3kgPSBhcnJheVsgMSBdO1xuXHRcdHRoaXMuX3ogPSBhcnJheVsgMiBdO1xuXHRcdGlmICggYXJyYXlbIDMgXSAhPT0gdW5kZWZpbmVkICkgdGhpcy5fb3JkZXIgPSBhcnJheVsgMyBdO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl9vcmRlcjtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0X29uQ2hhbmdlKCBjYWxsYmFjayApIHtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRfb25DaGFuZ2VDYWxsYmFjaygpIHt9XG5cblx0KlsgU3ltYm9sLml0ZXJhdG9yIF0oKSB7XG5cblx0XHR5aWVsZCB0aGlzLl94O1xuXHRcdHlpZWxkIHRoaXMuX3k7XG5cdFx0eWllbGQgdGhpcy5fejtcblx0XHR5aWVsZCB0aGlzLl9vcmRlcjtcblxuXHR9XG5cbn1cblxuRXVsZXIuREVGQVVMVF9PUkRFUiA9ICdYWVonO1xuXG5jbGFzcyBMYXllcnMge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy5tYXNrID0gMSB8IDA7XG5cblx0fVxuXG5cdHNldCggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayA9ICggMSA8PCBjaGFubmVsIHwgMCApID4+PiAwO1xuXG5cdH1cblxuXHRlbmFibGUoIGNoYW5uZWwgKSB7XG5cblx0XHR0aGlzLm1hc2sgfD0gMSA8PCBjaGFubmVsIHwgMDtcblxuXHR9XG5cblx0ZW5hYmxlQWxsKCkge1xuXG5cdFx0dGhpcy5tYXNrID0gMHhmZmZmZmZmZiB8IDA7XG5cblx0fVxuXG5cdHRvZ2dsZSggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayBePSAxIDw8IGNoYW5uZWwgfCAwO1xuXG5cdH1cblxuXHRkaXNhYmxlKCBjaGFubmVsICkge1xuXG5cdFx0dGhpcy5tYXNrICY9IH4gKCAxIDw8IGNoYW5uZWwgfCAwICk7XG5cblx0fVxuXG5cdGRpc2FibGVBbGwoKSB7XG5cblx0XHR0aGlzLm1hc2sgPSAwO1xuXG5cdH1cblxuXHR0ZXN0KCBsYXllcnMgKSB7XG5cblx0XHRyZXR1cm4gKCB0aGlzLm1hc2sgJiBsYXllcnMubWFzayApICE9PSAwO1xuXG5cdH1cblxuXHRpc0VuYWJsZWQoIGNoYW5uZWwgKSB7XG5cblx0XHRyZXR1cm4gKCB0aGlzLm1hc2sgJiAoIDEgPDwgY2hhbm5lbCB8IDAgKSApICE9PSAwO1xuXG5cdH1cblxufVxuXG5sZXQgX29iamVjdDNESWQgPSAwO1xuXG5jb25zdCBfdjEkNCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9xMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFF1YXRlcm5pb24oKTtcbmNvbnN0IF9tMSQxID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3RhcmdldCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX3Bvc2l0aW9uJDMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfc2NhbGUkMiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9xdWF0ZXJuaW9uJDIgPSAvKkBfX1BVUkVfXyovIG5ldyBRdWF0ZXJuaW9uKCk7XG5cbmNvbnN0IF94QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDEsIDAsIDAgKTtcbmNvbnN0IF95QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcbmNvbnN0IF96QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIDAsIDEgKTtcblxuY29uc3QgX2FkZGVkRXZlbnQgPSB7IHR5cGU6ICdhZGRlZCcgfTtcbmNvbnN0IF9yZW1vdmVkRXZlbnQgPSB7IHR5cGU6ICdyZW1vdmVkJyB9O1xuXG5jb25zdCBfY2hpbGRhZGRlZEV2ZW50ID0geyB0eXBlOiAnY2hpbGRhZGRlZCcsIGNoaWxkOiBudWxsIH07XG5jb25zdCBfY2hpbGRyZW1vdmVkRXZlbnQgPSB7IHR5cGU6ICdjaGlsZHJlbW92ZWQnLCBjaGlsZDogbnVsbCB9O1xuXG5jbGFzcyBPYmplY3QzRCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc09iamVjdDNEID0gdHJ1ZTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogX29iamVjdDNESWQgKysgfSApO1xuXG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLm5hbWUgPSAnJztcblx0XHR0aGlzLnR5cGUgPSAnT2JqZWN0M0QnO1xuXG5cdFx0dGhpcy5wYXJlbnQgPSBudWxsO1xuXHRcdHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuXHRcdHRoaXMudXAgPSBPYmplY3QzRC5ERUZBVUxUX1VQLmNsb25lKCk7XG5cblx0XHRjb25zdCBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3Qgcm90YXRpb24gPSBuZXcgRXVsZXIoKTtcblx0XHRjb25zdCBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblx0XHRjb25zdCBzY2FsZSA9IG5ldyBWZWN0b3IzKCAxLCAxLCAxICk7XG5cblx0XHRmdW5jdGlvbiBvblJvdGF0aW9uQ2hhbmdlKCkge1xuXG5cdFx0XHRxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggcm90YXRpb24sIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblF1YXRlcm5pb25DaGFuZ2UoKSB7XG5cblx0XHRcdHJvdGF0aW9uLnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB1bmRlZmluZWQsIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHRyb3RhdGlvbi5fb25DaGFuZ2UoIG9uUm90YXRpb25DaGFuZ2UgKTtcblx0XHRxdWF0ZXJuaW9uLl9vbkNoYW5nZSggb25RdWF0ZXJuaW9uQ2hhbmdlICk7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuXHRcdFx0cG9zaXRpb246IHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogcG9zaXRpb25cblx0XHRcdH0sXG5cdFx0XHRyb3RhdGlvbjoge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiByb3RhdGlvblxuXHRcdFx0fSxcblx0XHRcdHF1YXRlcm5pb246IHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogcXVhdGVybmlvblxuXHRcdFx0fSxcblx0XHRcdHNjYWxlOiB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHNjYWxlXG5cdFx0XHR9LFxuXHRcdFx0bW9kZWxWaWV3TWF0cml4OiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgTWF0cml4NCgpXG5cdFx0XHR9LFxuXHRcdFx0bm9ybWFsTWF0cml4OiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgTWF0cml4MygpXG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXHRcdHRoaXMubWF0cml4V29ybGQgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gT2JqZWN0M0QuREVGQVVMVF9NQVRSSVhfQVVUT19VUERBVEU7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9IE9iamVjdDNELkRFRkFVTFRfTUFUUklYX1dPUkxEX0FVVE9fVVBEQVRFOyAvLyBjaGVja2VkIGJ5IHRoZSByZW5kZXJlclxuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5sYXllcnMgPSBuZXcgTGF5ZXJzKCk7XG5cdFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuXHRcdHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xuXHRcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gdHJ1ZTtcblx0XHR0aGlzLnJlbmRlck9yZGVyID0gMDtcblxuXHRcdHRoaXMuYW5pbWF0aW9ucyA9IFtdO1xuXG5cdFx0dGhpcy51c2VyRGF0YSA9IHt9O1xuXG5cdH1cblxuXHRvbkJlZm9yZVNoYWRvdyggLyogcmVuZGVyZXIsIG9iamVjdCwgY2FtZXJhLCBzaGFkb3dDYW1lcmEsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBncm91cCAqLyApIHt9XG5cblx0b25BZnRlclNoYWRvdyggLyogcmVuZGVyZXIsIG9iamVjdCwgY2FtZXJhLCBzaGFkb3dDYW1lcmEsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBncm91cCAqLyApIHt9XG5cblx0b25CZWZvcmVSZW5kZXIoIC8qIHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICovICkge31cblxuXHRvbkFmdGVyUmVuZGVyKCAvKiByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCAqLyApIHt9XG5cblx0YXBwbHlNYXRyaXg0KCBtYXRyaXggKSB7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHR0aGlzLm1hdHJpeC5wcmVtdWx0aXBseSggbWF0cml4ICk7XG5cblx0XHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG5cdH1cblxuXHRhcHBseVF1YXRlcm5pb24oIHEgKSB7XG5cblx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIHEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21FdWxlciggZXVsZXIgKSB7XG5cblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciwgdHJ1ZSApO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21NYXRyaXgoIG0gKSB7XG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBxIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBxICk7XG5cblx0fVxuXG5cdHJvdGF0ZU9uQXhpcyggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gb2JqZWN0IHNwYWNlXG5cdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdF9xMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KCBfcTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVPbldvcmxkQXhpcyggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gd29ybGQgc3BhY2Vcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXHRcdC8vIG1ldGhvZCBhc3N1bWVzIG5vIHJvdGF0ZWQgcGFyZW50XG5cblx0XHRfcTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuXHRcdHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseSggX3ExICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm90YXRlWCggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF94QXhpcywgYW5nbGUgKTtcblxuXHR9XG5cblx0cm90YXRlWSggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF95QXhpcywgYW5nbGUgKTtcblxuXHR9XG5cblx0cm90YXRlWiggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF96QXhpcywgYW5nbGUgKTtcblxuXHR9XG5cblx0dHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIHtcblxuXHRcdC8vIHRyYW5zbGF0ZSBvYmplY3QgYnkgZGlzdGFuY2UgYWxvbmcgYXhpcyBpbiBvYmplY3Qgc3BhY2Vcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0X3YxJDQuY29weSggYXhpcyApLmFwcGx5UXVhdGVybmlvbiggdGhpcy5xdWF0ZXJuaW9uICk7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmFkZCggX3YxJDQubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2xhdGVYKCBkaXN0YW5jZSApIHtcblxuXHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggX3hBeGlzLCBkaXN0YW5jZSApO1xuXG5cdH1cblxuXHR0cmFuc2xhdGVZKCBkaXN0YW5jZSApIHtcblxuXHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggX3lBeGlzLCBkaXN0YW5jZSApO1xuXG5cdH1cblxuXHR0cmFuc2xhdGVaKCBkaXN0YW5jZSApIHtcblxuXHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggX3pBeGlzLCBkaXN0YW5jZSApO1xuXG5cdH1cblxuXHRsb2NhbFRvV29ybGQoIHZlY3RvciApIHtcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdH1cblxuXHR3b3JsZFRvTG9jYWwoIHZlY3RvciApIHtcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggX20xJDEuY29weSggdGhpcy5tYXRyaXhXb3JsZCApLmludmVydCgpICk7XG5cblx0fVxuXG5cdGxvb2tBdCggeCwgeSwgeiApIHtcblxuXHRcdC8vIFRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0cyBoYXZpbmcgbm9uLXVuaWZvcm1seS1zY2FsZWQgcGFyZW50KHMpXG5cblx0XHRpZiAoIHguaXNWZWN0b3IzICkge1xuXG5cdFx0XHRfdGFyZ2V0LmNvcHkoIHggKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF90YXJnZXQuc2V0KCB4LCB5LCB6ICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRfcG9zaXRpb24kMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdGlmICggdGhpcy5pc0NhbWVyYSB8fCB0aGlzLmlzTGlnaHQgKSB7XG5cblx0XHRcdF9tMSQxLmxvb2tBdCggX3Bvc2l0aW9uJDMsIF90YXJnZXQsIHRoaXMudXAgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9tMSQxLmxvb2tBdCggX3RhcmdldCwgX3Bvc2l0aW9uJDMsIHRoaXMudXAgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9tMSQxICk7XG5cblx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0X20xJDEuZXh0cmFjdFJvdGF0aW9uKCBwYXJlbnQubWF0cml4V29ybGQgKTtcblx0XHRcdF9xMS5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9tMSQxICk7XG5cdFx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIF9xMS5pbnZlcnQoKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRhZGQoIG9iamVjdCApIHtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5hZGQoIGFyZ3VtZW50c1sgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9iamVjdCA9PT0gdGhpcyApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhblxcJ3QgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiBpdHNlbGYuJywgb2JqZWN0ICk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0ICYmIG9iamVjdC5pc09iamVjdDNEICkge1xuXG5cdFx0XHRvYmplY3QucmVtb3ZlRnJvbVBhcmVudCgpO1xuXHRcdFx0b2JqZWN0LnBhcmVudCA9IHRoaXM7XG5cdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goIG9iamVjdCApO1xuXG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggX2FkZGVkRXZlbnQgKTtcblxuXHRcdFx0X2NoaWxkYWRkZWRFdmVudC5jaGlsZCA9IG9iamVjdDtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggX2NoaWxkYWRkZWRFdmVudCApO1xuXHRcdFx0X2NoaWxkYWRkZWRFdmVudC5jaGlsZCA9IG51bGw7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3Qgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk9iamVjdDNELicsIG9iamVjdCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJlbW92ZSggb2JqZWN0ICkge1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLnJlbW92ZSggYXJndW1lbnRzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKCBvYmplY3QgKTtcblxuXHRcdGlmICggaW5kZXggIT09IC0gMSApIHtcblxuXHRcdFx0b2JqZWN0LnBhcmVudCA9IG51bGw7XG5cdFx0XHR0aGlzLmNoaWxkcmVuLnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIF9yZW1vdmVkRXZlbnQgKTtcblxuXHRcdFx0X2NoaWxkcmVtb3ZlZEV2ZW50LmNoaWxkID0gb2JqZWN0O1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCBfY2hpbGRyZW1vdmVkRXZlbnQgKTtcblx0XHRcdF9jaGlsZHJlbW92ZWRFdmVudC5jaGlsZCA9IG51bGw7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmVtb3ZlRnJvbVBhcmVudCgpIHtcblxuXHRcdGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0aWYgKCBwYXJlbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdHBhcmVudC5yZW1vdmUoIHRoaXMgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGVhcigpIHtcblxuXHRcdHJldHVybiB0aGlzLnJlbW92ZSggLi4uIHRoaXMuY2hpbGRyZW4gKTtcblxuXHR9XG5cblx0YXR0YWNoKCBvYmplY3QgKSB7XG5cblx0XHQvLyBhZGRzIG9iamVjdCBhcyBhIGNoaWxkIG9mIHRoaXMsIHdoaWxlIG1haW50YWluaW5nIHRoZSBvYmplY3QncyB3b3JsZCB0cmFuc2Zvcm1cblxuXHRcdC8vIE5vdGU6IFRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgc2NlbmUgZ3JhcGhzIGhhdmluZyBub24tdW5pZm9ybWx5LXNjYWxlZCBub2RlcyhzKVxuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdF9tMSQxLmNvcHkoIHRoaXMubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblxuXHRcdGlmICggb2JqZWN0LnBhcmVudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0b2JqZWN0LnBhcmVudC51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdFx0X20xJDEubXVsdGlwbHkoIG9iamVjdC5wYXJlbnQubWF0cml4V29ybGQgKTtcblxuXHRcdH1cblxuXHRcdG9iamVjdC5hcHBseU1hdHJpeDQoIF9tMSQxICk7XG5cblx0XHRvYmplY3QucmVtb3ZlRnJvbVBhcmVudCgpO1xuXHRcdG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuXHRcdHRoaXMuY2hpbGRyZW4ucHVzaCggb2JqZWN0ICk7XG5cblx0XHRvYmplY3QudXBkYXRlV29ybGRNYXRyaXgoIGZhbHNlLCB0cnVlICk7XG5cblx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggX2FkZGVkRXZlbnQgKTtcblxuXHRcdF9jaGlsZGFkZGVkRXZlbnQuY2hpbGQgPSBvYmplY3Q7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCBfY2hpbGRhZGRlZEV2ZW50ICk7XG5cdFx0X2NoaWxkYWRkZWRFdmVudC5jaGlsZCA9IG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0T2JqZWN0QnlJZCggaWQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnaWQnLCBpZCApO1xuXG5cdH1cblxuXHRnZXRPYmplY3RCeU5hbWUoIG5hbWUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnbmFtZScsIG5hbWUgKTtcblxuXHR9XG5cblx0Z2V0T2JqZWN0QnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXR1cm4gdGhpcztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuWyBpIF07XG5cdFx0XHRjb25zdCBvYmplY3QgPSBjaGlsZC5nZXRPYmplY3RCeVByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXG5cdFx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiBvYmplY3Q7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0fVxuXG5cdGdldE9iamVjdHNCeVByb3BlcnR5KCBuYW1lLCB2YWx1ZSwgcmVzdWx0ID0gW10gKSB7XG5cblx0XHRpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXN1bHQucHVzaCggdGhpcyApO1xuXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y2hpbGRyZW5bIGkgXS5nZXRPYmplY3RzQnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUsIHJlc3VsdCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0Z2V0V29ybGRQb3NpdGlvbiggdGFyZ2V0ICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdHJldHVybiB0YXJnZXQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0fVxuXG5cdGdldFdvcmxkUXVhdGVybmlvbiggdGFyZ2V0ICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBfcG9zaXRpb24kMywgdGFyZ2V0LCBfc2NhbGUkMiApO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0Z2V0V29ybGRTY2FsZSggdGFyZ2V0ICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBfcG9zaXRpb24kMywgX3F1YXRlcm5pb24kMiwgdGFyZ2V0ICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRnZXRXb3JsZERpcmVjdGlvbiggdGFyZ2V0ICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdGNvbnN0IGUgPSB0aGlzLm1hdHJpeFdvcmxkLmVsZW1lbnRzO1xuXG5cdFx0cmV0dXJuIHRhcmdldC5zZXQoIGVbIDggXSwgZVsgOSBdLCBlWyAxMCBdICkubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdHJheWNhc3QoIC8qIHJheWNhc3RlciwgaW50ZXJzZWN0cyAqLyApIHt9XG5cblx0dHJhdmVyc2UoIGNhbGxiYWNrICkge1xuXG5cdFx0Y2FsbGJhY2soIHRoaXMgKTtcblxuXHRcdGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNoaWxkcmVuWyBpIF0udHJhdmVyc2UoIGNhbGxiYWNrICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRyYXZlcnNlVmlzaWJsZSggY2FsbGJhY2sgKSB7XG5cblx0XHRpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRjYWxsYmFjayggdGhpcyApO1xuXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZVZpc2libGUoIGNhbGxiYWNrICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRyYXZlcnNlQW5jZXN0b3JzKCBjYWxsYmFjayApIHtcblxuXHRcdGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0aWYgKCBwYXJlbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdGNhbGxiYWNrKCBwYXJlbnQgKTtcblxuXHRcdFx0cGFyZW50LnRyYXZlcnNlQW5jZXN0b3JzKCBjYWxsYmFjayApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR1cGRhdGVNYXRyaXgoKSB7XG5cblx0XHR0aGlzLm1hdHJpeC5jb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcblxuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG5cdHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcblxuXHRcdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuXHRcdGlmICggdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlIHx8IGZvcmNlICkge1xuXG5cdFx0XHRpZiAoIHRoaXMubWF0cml4V29ybGRBdXRvVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHRmb3JjZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHQvLyBtYWtlIHN1cmUgZGVzY2VuZGFudHMgYXJlIHVwZGF0ZWQgaWYgcmVxdWlyZWRcblxuXHRcdGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bIGkgXTtcblxuXHRcdFx0Y2hpbGQudXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZVdvcmxkTWF0cml4KCB1cGRhdGVQYXJlbnRzLCB1cGRhdGVDaGlsZHJlbiApIHtcblxuXHRcdGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0aWYgKCB1cGRhdGVQYXJlbnRzID09PSB0cnVlICYmIHBhcmVudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0cGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gbWFrZSBzdXJlIGRlc2NlbmRhbnRzIGFyZSB1cGRhdGVkXG5cblx0XHRpZiAoIHVwZGF0ZUNoaWxkcmVuID09PSB0cnVlICkge1xuXG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSBjaGlsZHJlblsgaSBdO1xuXG5cdFx0XHRcdGNoaWxkLnVwZGF0ZVdvcmxkTWF0cml4KCBmYWxzZSwgdHJ1ZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHRvSlNPTiggbWV0YSApIHtcblxuXHRcdC8vIG1ldGEgaXMgYSBzdHJpbmcgd2hlbiBjYWxsZWQgZnJvbSBKU09OLnN0cmluZ2lmeVxuXHRcdGNvbnN0IGlzUm9vdE9iamVjdCA9ICggbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJyApO1xuXG5cdFx0Y29uc3Qgb3V0cHV0ID0ge307XG5cblx0XHQvLyBtZXRhIGlzIGEgaGFzaCB1c2VkIHRvIGNvbGxlY3QgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLlxuXHRcdC8vIG5vdCBwcm92aWRpbmcgaXQgaW1wbGllcyB0aGF0IHRoaXMgaXMgdGhlIHJvb3Qgb2JqZWN0XG5cdFx0Ly8gYmVpbmcgc2VyaWFsaXplZC5cblx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuXHRcdFx0Ly8gaW5pdGlhbGl6ZSBtZXRhIG9ialxuXHRcdFx0bWV0YSA9IHtcblx0XHRcdFx0Z2VvbWV0cmllczoge30sXG5cdFx0XHRcdG1hdGVyaWFsczoge30sXG5cdFx0XHRcdHRleHR1cmVzOiB7fSxcblx0XHRcdFx0aW1hZ2VzOiB7fSxcblx0XHRcdFx0c2hhcGVzOiB7fSxcblx0XHRcdFx0c2tlbGV0b25zOiB7fSxcblx0XHRcdFx0YW5pbWF0aW9uczoge30sXG5cdFx0XHRcdG5vZGVzOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0b3V0cHV0Lm1ldGFkYXRhID0ge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjYsXG5cdFx0XHRcdHR5cGU6ICdPYmplY3QnLFxuXHRcdFx0XHRnZW5lcmF0b3I6ICdPYmplY3QzRC50b0pTT04nXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0Ly8gc3RhbmRhcmQgT2JqZWN0M0Qgc2VyaWFsaXphdGlvblxuXG5cdFx0Y29uc3Qgb2JqZWN0ID0ge307XG5cblx0XHRvYmplY3QudXVpZCA9IHRoaXMudXVpZDtcblx0XHRvYmplY3QudHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIG9iamVjdC5uYW1lID0gdGhpcy5uYW1lO1xuXHRcdGlmICggdGhpcy5jYXN0U2hhZG93ID09PSB0cnVlICkgb2JqZWN0LmNhc3RTaGFkb3cgPSB0cnVlO1xuXHRcdGlmICggdGhpcy5yZWNlaXZlU2hhZG93ID09PSB0cnVlICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuXHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIG9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cdFx0aWYgKCB0aGlzLmZydXN0dW1DdWxsZWQgPT09IGZhbHNlICkgb2JqZWN0LmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcblx0XHRpZiAoIHRoaXMucmVuZGVyT3JkZXIgIT09IDAgKSBvYmplY3QucmVuZGVyT3JkZXIgPSB0aGlzLnJlbmRlck9yZGVyO1xuXHRcdGlmICggT2JqZWN0LmtleXMoIHRoaXMudXNlckRhdGEgKS5sZW5ndGggPiAwICkgb2JqZWN0LnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcblxuXHRcdG9iamVjdC5sYXllcnMgPSB0aGlzLmxheWVycy5tYXNrO1xuXHRcdG9iamVjdC5tYXRyaXggPSB0aGlzLm1hdHJpeC50b0FycmF5KCk7XG5cdFx0b2JqZWN0LnVwID0gdGhpcy51cC50b0FycmF5KCk7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9PT0gZmFsc2UgKSBvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0Ly8gb2JqZWN0IHNwZWNpZmljIHByb3BlcnRpZXNcblxuXHRcdGlmICggdGhpcy5pc0luc3RhbmNlZE1lc2ggKSB7XG5cblx0XHRcdG9iamVjdC50eXBlID0gJ0luc3RhbmNlZE1lc2gnO1xuXHRcdFx0b2JqZWN0LmNvdW50ID0gdGhpcy5jb3VudDtcblx0XHRcdG9iamVjdC5pbnN0YW5jZU1hdHJpeCA9IHRoaXMuaW5zdGFuY2VNYXRyaXgudG9KU09OKCk7XG5cdFx0XHRpZiAoIHRoaXMuaW5zdGFuY2VDb2xvciAhPT0gbnVsbCApIG9iamVjdC5pbnN0YW5jZUNvbG9yID0gdGhpcy5pbnN0YW5jZUNvbG9yLnRvSlNPTigpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmlzQmF0Y2hlZE1lc2ggKSB7XG5cblx0XHRcdG9iamVjdC50eXBlID0gJ0JhdGNoZWRNZXNoJztcblx0XHRcdG9iamVjdC5wZXJPYmplY3RGcnVzdHVtQ3VsbGVkID0gdGhpcy5wZXJPYmplY3RGcnVzdHVtQ3VsbGVkO1xuXHRcdFx0b2JqZWN0LnNvcnRPYmplY3RzID0gdGhpcy5zb3J0T2JqZWN0cztcblxuXHRcdFx0b2JqZWN0LmRyYXdSYW5nZXMgPSB0aGlzLl9kcmF3UmFuZ2VzO1xuXHRcdFx0b2JqZWN0LnJlc2VydmVkUmFuZ2VzID0gdGhpcy5fcmVzZXJ2ZWRSYW5nZXM7XG5cblx0XHRcdG9iamVjdC52aXNpYmlsaXR5ID0gdGhpcy5fdmlzaWJpbGl0eTtcblx0XHRcdG9iamVjdC5hY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG5cdFx0XHRvYmplY3QuYm91bmRzID0gdGhpcy5fYm91bmRzLm1hcCggYm91bmQgPT4gKCB7XG5cdFx0XHRcdGJveEluaXRpYWxpemVkOiBib3VuZC5ib3hJbml0aWFsaXplZCxcblx0XHRcdFx0Ym94TWluOiBib3VuZC5ib3gubWluLnRvQXJyYXkoKSxcblx0XHRcdFx0Ym94TWF4OiBib3VuZC5ib3gubWF4LnRvQXJyYXkoKSxcblxuXHRcdFx0XHRzcGhlcmVJbml0aWFsaXplZDogYm91bmQuc3BoZXJlSW5pdGlhbGl6ZWQsXG5cdFx0XHRcdHNwaGVyZVJhZGl1czogYm91bmQuc3BoZXJlLnJhZGl1cyxcblx0XHRcdFx0c3BoZXJlQ2VudGVyOiBib3VuZC5zcGhlcmUuY2VudGVyLnRvQXJyYXkoKVxuXHRcdFx0fSApICk7XG5cblx0XHRcdG9iamVjdC5tYXhJbnN0YW5jZUNvdW50ID0gdGhpcy5fbWF4SW5zdGFuY2VDb3VudDtcblx0XHRcdG9iamVjdC5tYXhWZXJ0ZXhDb3VudCA9IHRoaXMuX21heFZlcnRleENvdW50O1xuXHRcdFx0b2JqZWN0Lm1heEluZGV4Q291bnQgPSB0aGlzLl9tYXhJbmRleENvdW50O1xuXG5cdFx0XHRvYmplY3QuZ2VvbWV0cnlJbml0aWFsaXplZCA9IHRoaXMuX2dlb21ldHJ5SW5pdGlhbGl6ZWQ7XG5cdFx0XHRvYmplY3QuZ2VvbWV0cnlDb3VudCA9IHRoaXMuX2dlb21ldHJ5Q291bnQ7XG5cblx0XHRcdG9iamVjdC5tYXRyaWNlc1RleHR1cmUgPSB0aGlzLl9tYXRyaWNlc1RleHR1cmUudG9KU09OKCBtZXRhICk7XG5cblx0XHRcdGlmICggdGhpcy5fY29sb3JzVGV4dHVyZSAhPT0gbnVsbCApIG9iamVjdC5jb2xvcnNUZXh0dXJlID0gdGhpcy5fY29sb3JzVGV4dHVyZS50b0pTT04oIG1ldGEgKTtcblxuXHRcdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdG9iamVjdC5ib3VuZGluZ1NwaGVyZSA9IHtcblx0XHRcdFx0XHRjZW50ZXI6IG9iamVjdC5ib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxuXHRcdFx0XHRcdHJhZGl1czogb2JqZWN0LmJvdW5kaW5nU3BoZXJlLnJhZGl1c1xuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRvYmplY3QuYm91bmRpbmdCb3ggPSB7XG5cdFx0XHRcdFx0bWluOiBvYmplY3QuYm91bmRpbmdCb3gubWluLnRvQXJyYXkoKSxcblx0XHRcdFx0XHRtYXg6IG9iamVjdC5ib3VuZGluZ0JveC5tYXgudG9BcnJheSgpXG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRmdW5jdGlvbiBzZXJpYWxpemUoIGxpYnJhcnksIGVsZW1lbnQgKSB7XG5cblx0XHRcdGlmICggbGlicmFyeVsgZWxlbWVudC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRsaWJyYXJ5WyBlbGVtZW50LnV1aWQgXSA9IGVsZW1lbnQudG9KU09OKCBtZXRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW1lbnQudXVpZDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5pc1NjZW5lICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuYmFja2dyb3VuZCApIHtcblxuXHRcdFx0XHRpZiAoIHRoaXMuYmFja2dyb3VuZC5pc0NvbG9yICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LmJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmQudG9KU09OKCk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy5iYWNrZ3JvdW5kLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdG9iamVjdC5iYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5lbnZpcm9ubWVudCAmJiB0aGlzLmVudmlyb25tZW50LmlzVGV4dHVyZSAmJiB0aGlzLmVudmlyb25tZW50LmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRvYmplY3QuZW52aXJvbm1lbnQgPSB0aGlzLmVudmlyb25tZW50LnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaXNNZXNoIHx8IHRoaXMuaXNMaW5lIHx8IHRoaXMuaXNQb2ludHMgKSB7XG5cblx0XHRcdG9iamVjdC5nZW9tZXRyeSA9IHNlcmlhbGl6ZSggbWV0YS5nZW9tZXRyaWVzLCB0aGlzLmdlb21ldHJ5ICk7XG5cblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLmdlb21ldHJ5LnBhcmFtZXRlcnM7XG5cblx0XHRcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICYmIHBhcmFtZXRlcnMuc2hhcGVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2hhcGVzID0gcGFyYW1ldGVycy5zaGFwZXM7XG5cblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBzaGFwZSA9IHNoYXBlc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5pc1NraW5uZWRNZXNoICkge1xuXG5cdFx0XHRvYmplY3QuYmluZE1vZGUgPSB0aGlzLmJpbmRNb2RlO1xuXHRcdFx0b2JqZWN0LmJpbmRNYXRyaXggPSB0aGlzLmJpbmRNYXRyaXgudG9BcnJheSgpO1xuXG5cdFx0XHRpZiAoIHRoaXMuc2tlbGV0b24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2tlbGV0b25zLCB0aGlzLnNrZWxldG9uICk7XG5cblx0XHRcdFx0b2JqZWN0LnNrZWxldG9uID0gdGhpcy5za2VsZXRvbi51dWlkO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB0aGlzLm1hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0Y29uc3QgdXVpZHMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLm1hdGVyaWFsLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR1dWlkcy5wdXNoKCBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsWyBpIF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvYmplY3QubWF0ZXJpYWwgPSB1dWlkcztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRvYmplY3QubWF0ZXJpYWwgPSBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0b2JqZWN0LmNoaWxkcmVuID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdG9iamVjdC5jaGlsZHJlbi5wdXNoKCB0aGlzLmNoaWxkcmVuWyBpIF0udG9KU09OKCBtZXRhICkub2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuYW5pbWF0aW9ucy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRvYmplY3QuYW5pbWF0aW9ucyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdG9iamVjdC5hbmltYXRpb25zLnB1c2goIHNlcmlhbGl6ZSggbWV0YS5hbmltYXRpb25zLCBhbmltYXRpb24gKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cmllcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuZ2VvbWV0cmllcyApO1xuXHRcdFx0Y29uc3QgbWF0ZXJpYWxzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5tYXRlcmlhbHMgKTtcblx0XHRcdGNvbnN0IHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xuXHRcdFx0Y29uc3QgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcblx0XHRcdGNvbnN0IHNoYXBlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuc2hhcGVzICk7XG5cdFx0XHRjb25zdCBza2VsZXRvbnMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnNrZWxldG9ucyApO1xuXHRcdFx0Y29uc3QgYW5pbWF0aW9ucyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuYW5pbWF0aW9ucyApO1xuXHRcdFx0Y29uc3Qgbm9kZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLm5vZGVzICk7XG5cblx0XHRcdGlmICggZ2VvbWV0cmllcy5sZW5ndGggPiAwICkgb3V0cHV0Lmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xuXHRcdFx0aWYgKCBtYXRlcmlhbHMubGVuZ3RoID4gMCApIG91dHB1dC5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XG5cdFx0XHRpZiAoIHRleHR1cmVzLmxlbmd0aCA+IDAgKSBvdXRwdXQudGV4dHVyZXMgPSB0ZXh0dXJlcztcblx0XHRcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBvdXRwdXQuaW1hZ2VzID0gaW1hZ2VzO1xuXHRcdFx0aWYgKCBzaGFwZXMubGVuZ3RoID4gMCApIG91dHB1dC5zaGFwZXMgPSBzaGFwZXM7XG5cdFx0XHRpZiAoIHNrZWxldG9ucy5sZW5ndGggPiAwICkgb3V0cHV0LnNrZWxldG9ucyA9IHNrZWxldG9ucztcblx0XHRcdGlmICggYW5pbWF0aW9ucy5sZW5ndGggPiAwICkgb3V0cHV0LmFuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuXHRcdFx0aWYgKCBub2Rlcy5sZW5ndGggPiAwICkgb3V0cHV0Lm5vZGVzID0gbm9kZXM7XG5cblx0XHR9XG5cblx0XHRvdXRwdXQub2JqZWN0ID0gb2JqZWN0O1xuXG5cdFx0cmV0dXJuIG91dHB1dDtcblxuXHRcdC8vIGV4dHJhY3QgZGF0YSBmcm9tIHRoZSBjYWNoZSBoYXNoXG5cdFx0Ly8gcmVtb3ZlIG1ldGFkYXRhIG9uIGVhY2ggaXRlbVxuXHRcdC8vIGFuZCByZXR1cm4gYXMgYXJyYXlcblx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKCBjYWNoZSApIHtcblxuXHRcdFx0Y29uc3QgdmFsdWVzID0gW107XG5cdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gY2FjaGUgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9IGNhY2hlWyBrZXkgXTtcblx0XHRcdFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XG5cdFx0XHRcdHZhbHVlcy5wdXNoKCBkYXRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlcztcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xvbmUoIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMsIHJlY3Vyc2l2ZSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSA9IHRydWUgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuXHRcdHRoaXMudXAuY29weSggc291cmNlLnVwICk7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIHNvdXJjZS5wb3NpdGlvbiApO1xuXHRcdHRoaXMucm90YXRpb24ub3JkZXIgPSBzb3VyY2Uucm90YXRpb24ub3JkZXI7XG5cdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHNvdXJjZS5xdWF0ZXJuaW9uICk7XG5cdFx0dGhpcy5zY2FsZS5jb3B5KCBzb3VyY2Uuc2NhbGUgKTtcblxuXHRcdHRoaXMubWF0cml4LmNvcHkoIHNvdXJjZS5tYXRyaXggKTtcblx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHNvdXJjZS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhXb3JsZEF1dG9VcGRhdGU7XG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gc291cmNlLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XG5cblx0XHR0aGlzLmxheWVycy5tYXNrID0gc291cmNlLmxheWVycy5tYXNrO1xuXHRcdHRoaXMudmlzaWJsZSA9IHNvdXJjZS52aXNpYmxlO1xuXG5cdFx0dGhpcy5jYXN0U2hhZG93ID0gc291cmNlLmNhc3RTaGFkb3c7XG5cdFx0dGhpcy5yZWNlaXZlU2hhZG93ID0gc291cmNlLnJlY2VpdmVTaGFkb3c7XG5cblx0XHR0aGlzLmZydXN0dW1DdWxsZWQgPSBzb3VyY2UuZnJ1c3R1bUN1bGxlZDtcblx0XHR0aGlzLnJlbmRlck9yZGVyID0gc291cmNlLnJlbmRlck9yZGVyO1xuXG5cdFx0dGhpcy5hbmltYXRpb25zID0gc291cmNlLmFuaW1hdGlvbnMuc2xpY2UoKTtcblxuXHRcdHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggc291cmNlLnVzZXJEYXRhICkgKTtcblxuXHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gc291cmNlLmNoaWxkcmVuWyBpIF07XG5cdFx0XHRcdHRoaXMuYWRkKCBjaGlsZC5jbG9uZSgpICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5PYmplY3QzRC5ERUZBVUxUX1VQID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xuT2JqZWN0M0QuREVGQVVMVF9NQVRSSVhfQVVUT19VUERBVEUgPSB0cnVlO1xuT2JqZWN0M0QuREVGQVVMVF9NQVRSSVhfV09STERfQVVUT19VUERBVEUgPSB0cnVlO1xuXG5jb25zdCBfdjAkMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MSQzID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YyJDIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdjMkMiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX3ZhYiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92YWMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdmJjID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZhcCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92YnAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdmNwID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfdjQwID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yNCgpO1xuY29uc3QgX3Y0MSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjQoKTtcbmNvbnN0IF92NDIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3I0KCk7XG5cbmNsYXNzIFRyaWFuZ2xlIHtcblxuXHRjb25zdHJ1Y3RvciggYSA9IG5ldyBWZWN0b3IzKCksIGIgPSBuZXcgVmVjdG9yMygpLCBjID0gbmV3IFZlY3RvcjMoKSApIHtcblxuXHRcdHRoaXMuYSA9IGE7XG5cdFx0dGhpcy5iID0gYjtcblx0XHR0aGlzLmMgPSBjO1xuXG5cdH1cblxuXHRzdGF0aWMgZ2V0Tm9ybWFsKCBhLCBiLCBjLCB0YXJnZXQgKSB7XG5cblx0XHR0YXJnZXQuc3ViVmVjdG9ycyggYywgYiApO1xuXHRcdF92MCQxLnN1YlZlY3RvcnMoIGEsIGIgKTtcblx0XHR0YXJnZXQuY3Jvc3MoIF92MCQxICk7XG5cblx0XHRjb25zdCB0YXJnZXRMZW5ndGhTcSA9IHRhcmdldC5sZW5ndGhTcSgpO1xuXHRcdGlmICggdGFyZ2V0TGVuZ3RoU3EgPiAwICkge1xuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0Lm11bHRpcGx5U2NhbGFyKCAxIC8gTWF0aC5zcXJ0KCB0YXJnZXRMZW5ndGhTcSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldCggMCwgMCwgMCApO1xuXG5cdH1cblxuXHQvLyBzdGF0aWMvaW5zdGFuY2UgbWV0aG9kIHRvIGNhbGN1bGF0ZSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlc1xuXHQvLyBiYXNlZCBvbjogaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L2RlZmF1bHQuaHRtbFxuXHRzdGF0aWMgZ2V0QmFyeWNvb3JkKCBwb2ludCwgYSwgYiwgYywgdGFyZ2V0ICkge1xuXG5cdFx0X3YwJDEuc3ViVmVjdG9ycyggYywgYSApO1xuXHRcdF92MSQzLnN1YlZlY3RvcnMoIGIsIGEgKTtcblx0XHRfdjIkMi5zdWJWZWN0b3JzKCBwb2ludCwgYSApO1xuXG5cdFx0Y29uc3QgZG90MDAgPSBfdjAkMS5kb3QoIF92MCQxICk7XG5cdFx0Y29uc3QgZG90MDEgPSBfdjAkMS5kb3QoIF92MSQzICk7XG5cdFx0Y29uc3QgZG90MDIgPSBfdjAkMS5kb3QoIF92MiQyICk7XG5cdFx0Y29uc3QgZG90MTEgPSBfdjEkMy5kb3QoIF92MSQzICk7XG5cdFx0Y29uc3QgZG90MTIgPSBfdjEkMy5kb3QoIF92MiQyICk7XG5cblx0XHRjb25zdCBkZW5vbSA9ICggZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEgKTtcblxuXHRcdC8vIGNvbGxpbmVhciBvciBzaW5ndWxhciB0cmlhbmdsZVxuXHRcdGlmICggZGVub20gPT09IDAgKSB7XG5cblx0XHRcdHRhcmdldC5zZXQoIDAsIDAsIDAgKTtcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaW52RGVub20gPSAxIC8gZGVub207XG5cdFx0Y29uc3QgdSA9ICggZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIgKSAqIGludkRlbm9tO1xuXHRcdGNvbnN0IHYgPSAoIGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyICkgKiBpbnZEZW5vbTtcblxuXHRcdC8vIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIG11c3QgYWx3YXlzIHN1bSB0byAxXG5cdFx0cmV0dXJuIHRhcmdldC5zZXQoIDEgLSB1IC0gdiwgdiwgdSApO1xuXG5cdH1cblxuXHRzdGF0aWMgY29udGFpbnNQb2ludCggcG9pbnQsIGEsIGIsIGMgKSB7XG5cblx0XHQvLyBpZiB0aGUgdHJpYW5nbGUgaXMgZGVnZW5lcmF0ZSB0aGVuIHdlIGNhbid0IGNvbnRhaW4gYSBwb2ludFxuXHRcdGlmICggdGhpcy5nZXRCYXJ5Y29vcmQoIHBvaW50LCBhLCBiLCBjLCBfdjMkMiApID09PSBudWxsICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gKCBfdjMkMi54ID49IDAgKSAmJiAoIF92MyQyLnkgPj0gMCApICYmICggKCBfdjMkMi54ICsgX3YzJDIueSApIDw9IDEgKTtcblxuXHR9XG5cblx0c3RhdGljIGdldEludGVycG9sYXRpb24oIHBvaW50LCBwMSwgcDIsIHAzLCB2MSwgdjIsIHYzLCB0YXJnZXQgKSB7XG5cblx0XHRpZiAoIHRoaXMuZ2V0QmFyeWNvb3JkKCBwb2ludCwgcDEsIHAyLCBwMywgX3YzJDIgKSA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGFyZ2V0LnggPSAwO1xuXHRcdFx0dGFyZ2V0LnkgPSAwO1xuXHRcdFx0aWYgKCAneicgaW4gdGFyZ2V0ICkgdGFyZ2V0LnogPSAwO1xuXHRcdFx0aWYgKCAndycgaW4gdGFyZ2V0ICkgdGFyZ2V0LncgPSAwO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHR0YXJnZXQuc2V0U2NhbGFyKCAwICk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggdjEsIF92MyQyLnggKTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCB2MiwgX3YzJDIueSApO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIHYzLCBfdjMkMi56ICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRzdGF0aWMgZ2V0SW50ZXJwb2xhdGVkQXR0cmlidXRlKCBhdHRyLCBpMSwgaTIsIGkzLCBiYXJ5Y29vcmQsIHRhcmdldCApIHtcblxuXHRcdF92NDAuc2V0U2NhbGFyKCAwICk7XG5cdFx0X3Y0MS5zZXRTY2FsYXIoIDAgKTtcblx0XHRfdjQyLnNldFNjYWxhciggMCApO1xuXG5cdFx0X3Y0MC5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyLCBpMSApO1xuXHRcdF92NDEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0ciwgaTIgKTtcblx0XHRfdjQyLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHIsIGkzICk7XG5cblx0XHR0YXJnZXQuc2V0U2NhbGFyKCAwICk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggX3Y0MCwgYmFyeWNvb3JkLnggKTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBfdjQxLCBiYXJ5Y29vcmQueSApO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIF92NDIsIGJhcnljb29yZC56ICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRzdGF0aWMgaXNGcm9udEZhY2luZyggYSwgYiwgYywgZGlyZWN0aW9uICkge1xuXG5cdFx0X3YwJDEuc3ViVmVjdG9ycyggYywgYiApO1xuXHRcdF92MSQzLnN1YlZlY3RvcnMoIGEsIGIgKTtcblxuXHRcdC8vIHN0cmljdGx5IGZyb250IGZhY2luZ1xuXHRcdHJldHVybiAoIF92MCQxLmNyb3NzKCBfdjEkMyApLmRvdCggZGlyZWN0aW9uICkgPCAwICkgPyB0cnVlIDogZmFsc2U7XG5cblx0fVxuXG5cdHNldCggYSwgYiwgYyApIHtcblxuXHRcdHRoaXMuYS5jb3B5KCBhICk7XG5cdFx0dGhpcy5iLmNvcHkoIGIgKTtcblx0XHR0aGlzLmMuY29weSggYyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Qb2ludHNBbmRJbmRpY2VzKCBwb2ludHMsIGkwLCBpMSwgaTIgKSB7XG5cblx0XHR0aGlzLmEuY29weSggcG9pbnRzWyBpMCBdICk7XG5cdFx0dGhpcy5iLmNvcHkoIHBvaW50c1sgaTEgXSApO1xuXHRcdHRoaXMuYy5jb3B5KCBwb2ludHNbIGkyIF0gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tQXR0cmlidXRlQW5kSW5kaWNlcyggYXR0cmlidXRlLCBpMCwgaTEsIGkyICkge1xuXG5cdFx0dGhpcy5hLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaTAgKTtcblx0XHR0aGlzLmIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpMSApO1xuXHRcdHRoaXMuYy5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGkyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG5cdGNvcHkoIHRyaWFuZ2xlICkge1xuXG5cdFx0dGhpcy5hLmNvcHkoIHRyaWFuZ2xlLmEgKTtcblx0XHR0aGlzLmIuY29weSggdHJpYW5nbGUuYiApO1xuXHRcdHRoaXMuYy5jb3B5KCB0cmlhbmdsZS5jICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0QXJlYSgpIHtcblxuXHRcdF92MCQxLnN1YlZlY3RvcnMoIHRoaXMuYywgdGhpcy5iICk7XG5cdFx0X3YxJDMuc3ViVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKTtcblxuXHRcdHJldHVybiBfdjAkMS5jcm9zcyggX3YxJDMgKS5sZW5ndGgoKSAqIDAuNTtcblxuXHR9XG5cblx0Z2V0TWlkcG9pbnQoIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0YXJnZXQuYWRkVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKS5hZGQoIHRoaXMuYyApLm11bHRpcGx5U2NhbGFyKCAxIC8gMyApO1xuXG5cdH1cblxuXHRnZXROb3JtYWwoIHRhcmdldCApIHtcblxuXHRcdHJldHVybiBUcmlhbmdsZS5nZXROb3JtYWwoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRhcmdldCApO1xuXG5cdH1cblxuXHRnZXRQbGFuZSggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRhcmdldC5zZXRGcm9tQ29wbGFuYXJQb2ludHMoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcblxuXHR9XG5cblx0Z2V0QmFyeWNvb3JkKCBwb2ludCwgdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmdldEJhcnljb29yZCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRhcmdldCApO1xuXG5cdH1cblxuXHRnZXRJbnRlcnBvbGF0aW9uKCBwb2ludCwgdjEsIHYyLCB2MywgdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB2MSwgdjIsIHYzLCB0YXJnZXQgKTtcblxuXHR9XG5cblx0Y29udGFpbnNQb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gVHJpYW5nbGUuY29udGFpbnNQb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcblxuXHR9XG5cblx0aXNGcm9udEZhY2luZyggZGlyZWN0aW9uICkge1xuXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmlzRnJvbnRGYWNpbmcoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIGRpcmVjdGlvbiApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNUcmlhbmdsZSggdGhpcyApO1xuXG5cdH1cblxuXHRjbG9zZXN0UG9pbnRUb1BvaW50KCBwLCB0YXJnZXQgKSB7XG5cblx0XHRjb25zdCBhID0gdGhpcy5hLCBiID0gdGhpcy5iLCBjID0gdGhpcy5jO1xuXHRcdGxldCB2LCB3O1xuXG5cdFx0Ly8gYWxnb3JpdGhtIHRoYW5rcyB0byBSZWFsLVRpbWUgQ29sbGlzaW9uIERldGVjdGlvbiBieSBDaHJpc3RlciBFcmljc29uLFxuXHRcdC8vIHB1Ymxpc2hlZCBieSBNb3JnYW4gS2F1Zm1hbm4gUHVibGlzaGVycywgKGMpIDIwMDUgRWxzZXZpZXIgSW5jLixcblx0XHQvLyB1bmRlciB0aGUgYWNjb21wYW55aW5nIGxpY2Vuc2U7IHNlZSBjaGFwdGVyIDUuMS41IGZvciBkZXRhaWxlZCBleHBsYW5hdGlvbi5cblx0XHQvLyBiYXNpY2FsbHksIHdlJ3JlIGRpc3Rpbmd1aXNoaW5nIHdoaWNoIG9mIHRoZSB2b3Jvbm9pIHJlZ2lvbnMgb2YgdGhlIHRyaWFuZ2xlXG5cdFx0Ly8gdGhlIHBvaW50IGxpZXMgaW4gd2l0aCB0aGUgbWluaW11bSBhbW91bnQgb2YgcmVkdW5kYW50IGNvbXB1dGF0aW9uLlxuXG5cdFx0X3ZhYi5zdWJWZWN0b3JzKCBiLCBhICk7XG5cdFx0X3ZhYy5zdWJWZWN0b3JzKCBjLCBhICk7XG5cdFx0X3ZhcC5zdWJWZWN0b3JzKCBwLCBhICk7XG5cdFx0Y29uc3QgZDEgPSBfdmFiLmRvdCggX3ZhcCApO1xuXHRcdGNvbnN0IGQyID0gX3ZhYy5kb3QoIF92YXAgKTtcblx0XHRpZiAoIGQxIDw9IDAgJiYgZDIgPD0gMCApIHtcblxuXHRcdFx0Ly8gdmVydGV4IHJlZ2lvbiBvZiBBOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDEsIDAsIDApXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGEgKTtcblxuXHRcdH1cblxuXHRcdF92YnAuc3ViVmVjdG9ycyggcCwgYiApO1xuXHRcdGNvbnN0IGQzID0gX3ZhYi5kb3QoIF92YnAgKTtcblx0XHRjb25zdCBkNCA9IF92YWMuZG90KCBfdmJwICk7XG5cdFx0aWYgKCBkMyA+PSAwICYmIGQ0IDw9IGQzICkge1xuXG5cdFx0XHQvLyB2ZXJ0ZXggcmVnaW9uIG9mIEI7IGJhcnljZW50cmljIGNvb3JkcyAoMCwgMSwgMClcblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggYiApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdmMgPSBkMSAqIGQ0IC0gZDMgKiBkMjtcblx0XHRpZiAoIHZjIDw9IDAgJiYgZDEgPj0gMCAmJiBkMyA8PSAwICkge1xuXG5cdFx0XHR2ID0gZDEgLyAoIGQxIC0gZDMgKTtcblx0XHRcdC8vIGVkZ2UgcmVnaW9uIG9mIEFCOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDEtdiwgdiwgMClcblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggYSApLmFkZFNjYWxlZFZlY3RvciggX3ZhYiwgdiApO1xuXG5cdFx0fVxuXG5cdFx0X3ZjcC5zdWJWZWN0b3JzKCBwLCBjICk7XG5cdFx0Y29uc3QgZDUgPSBfdmFiLmRvdCggX3ZjcCApO1xuXHRcdGNvbnN0IGQ2ID0gX3ZhYy5kb3QoIF92Y3AgKTtcblx0XHRpZiAoIGQ2ID49IDAgJiYgZDUgPD0gZDYgKSB7XG5cblx0XHRcdC8vIHZlcnRleCByZWdpb24gb2YgQzsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAwLCAxKVxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBjICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB2YiA9IGQ1ICogZDIgLSBkMSAqIGQ2O1xuXHRcdGlmICggdmIgPD0gMCAmJiBkMiA+PSAwICYmIGQ2IDw9IDAgKSB7XG5cblx0XHRcdHcgPSBkMiAvICggZDIgLSBkNiApO1xuXHRcdFx0Ly8gZWRnZSByZWdpb24gb2YgQUM7IGJhcnljZW50cmljIGNvb3JkcyAoMS13LCAwLCB3KVxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBhICkuYWRkU2NhbGVkVmVjdG9yKCBfdmFjLCB3ICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB2YSA9IGQzICogZDYgLSBkNSAqIGQ0O1xuXHRcdGlmICggdmEgPD0gMCAmJiAoIGQ0IC0gZDMgKSA+PSAwICYmICggZDUgLSBkNiApID49IDAgKSB7XG5cblx0XHRcdF92YmMuc3ViVmVjdG9ycyggYywgYiApO1xuXHRcdFx0dyA9ICggZDQgLSBkMyApIC8gKCAoIGQ0IC0gZDMgKSArICggZDUgLSBkNiApICk7XG5cdFx0XHQvLyBlZGdlIHJlZ2lvbiBvZiBCQzsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAxLXcsIHcpXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGIgKS5hZGRTY2FsZWRWZWN0b3IoIF92YmMsIHcgKTsgLy8gZWRnZSByZWdpb24gb2YgQkNcblxuXHRcdH1cblxuXHRcdC8vIGZhY2UgcmVnaW9uXG5cdFx0Y29uc3QgZGVub20gPSAxIC8gKCB2YSArIHZiICsgdmMgKTtcblx0XHQvLyB1ID0gdmEgKiBkZW5vbVxuXHRcdHYgPSB2YiAqIGRlbm9tO1xuXHRcdHcgPSB2YyAqIGRlbm9tO1xuXG5cdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBhICkuYWRkU2NhbGVkVmVjdG9yKCBfdmFiLCB2ICkuYWRkU2NhbGVkVmVjdG9yKCBfdmFjLCB3ICk7XG5cblx0fVxuXG5cdGVxdWFscyggdHJpYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdHJpYW5nbGUuYS5lcXVhbHMoIHRoaXMuYSApICYmIHRyaWFuZ2xlLmIuZXF1YWxzKCB0aGlzLmIgKSAmJiB0cmlhbmdsZS5jLmVxdWFscyggdGhpcy5jICk7XG5cblx0fVxuXG59XG5cbmNvbnN0IF9jb2xvcktleXdvcmRzID0geyAnYWxpY2VibHVlJzogMHhGMEY4RkYsICdhbnRpcXVld2hpdGUnOiAweEZBRUJENywgJ2FxdWEnOiAweDAwRkZGRiwgJ2FxdWFtYXJpbmUnOiAweDdGRkZENCwgJ2F6dXJlJzogMHhGMEZGRkYsXG5cdCdiZWlnZSc6IDB4RjVGNURDLCAnYmlzcXVlJzogMHhGRkU0QzQsICdibGFjayc6IDB4MDAwMDAwLCAnYmxhbmNoZWRhbG1vbmQnOiAweEZGRUJDRCwgJ2JsdWUnOiAweDAwMDBGRiwgJ2JsdWV2aW9sZXQnOiAweDhBMkJFMixcblx0J2Jyb3duJzogMHhBNTJBMkEsICdidXJseXdvb2QnOiAweERFQjg4NywgJ2NhZGV0Ymx1ZSc6IDB4NUY5RUEwLCAnY2hhcnRyZXVzZSc6IDB4N0ZGRjAwLCAnY2hvY29sYXRlJzogMHhEMjY5MUUsICdjb3JhbCc6IDB4RkY3RjUwLFxuXHQnY29ybmZsb3dlcmJsdWUnOiAweDY0OTVFRCwgJ2Nvcm5zaWxrJzogMHhGRkY4REMsICdjcmltc29uJzogMHhEQzE0M0MsICdjeWFuJzogMHgwMEZGRkYsICdkYXJrYmx1ZSc6IDB4MDAwMDhCLCAnZGFya2N5YW4nOiAweDAwOEI4Qixcblx0J2Rhcmtnb2xkZW5yb2QnOiAweEI4ODYwQiwgJ2RhcmtncmF5JzogMHhBOUE5QTksICdkYXJrZ3JlZW4nOiAweDAwNjQwMCwgJ2RhcmtncmV5JzogMHhBOUE5QTksICdkYXJra2hha2knOiAweEJEQjc2QiwgJ2RhcmttYWdlbnRhJzogMHg4QjAwOEIsXG5cdCdkYXJrb2xpdmVncmVlbic6IDB4NTU2QjJGLCAnZGFya29yYW5nZSc6IDB4RkY4QzAwLCAnZGFya29yY2hpZCc6IDB4OTkzMkNDLCAnZGFya3JlZCc6IDB4OEIwMDAwLCAnZGFya3NhbG1vbic6IDB4RTk5NjdBLCAnZGFya3NlYWdyZWVuJzogMHg4RkJDOEYsXG5cdCdkYXJrc2xhdGVibHVlJzogMHg0ODNEOEIsICdkYXJrc2xhdGVncmF5JzogMHgyRjRGNEYsICdkYXJrc2xhdGVncmV5JzogMHgyRjRGNEYsICdkYXJrdHVycXVvaXNlJzogMHgwMENFRDEsICdkYXJrdmlvbGV0JzogMHg5NDAwRDMsXG5cdCdkZWVwcGluayc6IDB4RkYxNDkzLCAnZGVlcHNreWJsdWUnOiAweDAwQkZGRiwgJ2RpbWdyYXknOiAweDY5Njk2OSwgJ2RpbWdyZXknOiAweDY5Njk2OSwgJ2RvZGdlcmJsdWUnOiAweDFFOTBGRiwgJ2ZpcmVicmljayc6IDB4QjIyMjIyLFxuXHQnZmxvcmFsd2hpdGUnOiAweEZGRkFGMCwgJ2ZvcmVzdGdyZWVuJzogMHgyMjhCMjIsICdmdWNoc2lhJzogMHhGRjAwRkYsICdnYWluc2Jvcm8nOiAweERDRENEQywgJ2dob3N0d2hpdGUnOiAweEY4RjhGRiwgJ2dvbGQnOiAweEZGRDcwMCxcblx0J2dvbGRlbnJvZCc6IDB4REFBNTIwLCAnZ3JheSc6IDB4ODA4MDgwLCAnZ3JlZW4nOiAweDAwODAwMCwgJ2dyZWVueWVsbG93JzogMHhBREZGMkYsICdncmV5JzogMHg4MDgwODAsICdob25leWRldyc6IDB4RjBGRkYwLCAnaG90cGluayc6IDB4RkY2OUI0LFxuXHQnaW5kaWFucmVkJzogMHhDRDVDNUMsICdpbmRpZ28nOiAweDRCMDA4MiwgJ2l2b3J5JzogMHhGRkZGRjAsICdraGFraSc6IDB4RjBFNjhDLCAnbGF2ZW5kZXInOiAweEU2RTZGQSwgJ2xhdmVuZGVyYmx1c2gnOiAweEZGRjBGNSwgJ2xhd25ncmVlbic6IDB4N0NGQzAwLFxuXHQnbGVtb25jaGlmZm9uJzogMHhGRkZBQ0QsICdsaWdodGJsdWUnOiAweEFERDhFNiwgJ2xpZ2h0Y29yYWwnOiAweEYwODA4MCwgJ2xpZ2h0Y3lhbic6IDB4RTBGRkZGLCAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiAweEZBRkFEMiwgJ2xpZ2h0Z3JheSc6IDB4RDNEM0QzLFxuXHQnbGlnaHRncmVlbic6IDB4OTBFRTkwLCAnbGlnaHRncmV5JzogMHhEM0QzRDMsICdsaWdodHBpbmsnOiAweEZGQjZDMSwgJ2xpZ2h0c2FsbW9uJzogMHhGRkEwN0EsICdsaWdodHNlYWdyZWVuJzogMHgyMEIyQUEsICdsaWdodHNreWJsdWUnOiAweDg3Q0VGQSxcblx0J2xpZ2h0c2xhdGVncmF5JzogMHg3Nzg4OTksICdsaWdodHNsYXRlZ3JleSc6IDB4Nzc4ODk5LCAnbGlnaHRzdGVlbGJsdWUnOiAweEIwQzRERSwgJ2xpZ2h0eWVsbG93JzogMHhGRkZGRTAsICdsaW1lJzogMHgwMEZGMDAsICdsaW1lZ3JlZW4nOiAweDMyQ0QzMixcblx0J2xpbmVuJzogMHhGQUYwRTYsICdtYWdlbnRhJzogMHhGRjAwRkYsICdtYXJvb24nOiAweDgwMDAwMCwgJ21lZGl1bWFxdWFtYXJpbmUnOiAweDY2Q0RBQSwgJ21lZGl1bWJsdWUnOiAweDAwMDBDRCwgJ21lZGl1bW9yY2hpZCc6IDB4QkE1NUQzLFxuXHQnbWVkaXVtcHVycGxlJzogMHg5MzcwREIsICdtZWRpdW1zZWFncmVlbic6IDB4M0NCMzcxLCAnbWVkaXVtc2xhdGVibHVlJzogMHg3QjY4RUUsICdtZWRpdW1zcHJpbmdncmVlbic6IDB4MDBGQTlBLCAnbWVkaXVtdHVycXVvaXNlJzogMHg0OEQxQ0MsXG5cdCdtZWRpdW12aW9sZXRyZWQnOiAweEM3MTU4NSwgJ21pZG5pZ2h0Ymx1ZSc6IDB4MTkxOTcwLCAnbWludGNyZWFtJzogMHhGNUZGRkEsICdtaXN0eXJvc2UnOiAweEZGRTRFMSwgJ21vY2Nhc2luJzogMHhGRkU0QjUsICduYXZham93aGl0ZSc6IDB4RkZERUFELFxuXHQnbmF2eSc6IDB4MDAwMDgwLCAnb2xkbGFjZSc6IDB4RkRGNUU2LCAnb2xpdmUnOiAweDgwODAwMCwgJ29saXZlZHJhYic6IDB4NkI4RTIzLCAnb3JhbmdlJzogMHhGRkE1MDAsICdvcmFuZ2VyZWQnOiAweEZGNDUwMCwgJ29yY2hpZCc6IDB4REE3MEQ2LFxuXHQncGFsZWdvbGRlbnJvZCc6IDB4RUVFOEFBLCAncGFsZWdyZWVuJzogMHg5OEZCOTgsICdwYWxldHVycXVvaXNlJzogMHhBRkVFRUUsICdwYWxldmlvbGV0cmVkJzogMHhEQjcwOTMsICdwYXBheWF3aGlwJzogMHhGRkVGRDUsICdwZWFjaHB1ZmYnOiAweEZGREFCOSxcblx0J3BlcnUnOiAweENEODUzRiwgJ3BpbmsnOiAweEZGQzBDQiwgJ3BsdW0nOiAweEREQTBERCwgJ3Bvd2RlcmJsdWUnOiAweEIwRTBFNiwgJ3B1cnBsZSc6IDB4ODAwMDgwLCAncmViZWNjYXB1cnBsZSc6IDB4NjYzMzk5LCAncmVkJzogMHhGRjAwMDAsICdyb3N5YnJvd24nOiAweEJDOEY4Rixcblx0J3JveWFsYmx1ZSc6IDB4NDE2OUUxLCAnc2FkZGxlYnJvd24nOiAweDhCNDUxMywgJ3NhbG1vbic6IDB4RkE4MDcyLCAnc2FuZHlicm93bic6IDB4RjRBNDYwLCAnc2VhZ3JlZW4nOiAweDJFOEI1NywgJ3NlYXNoZWxsJzogMHhGRkY1RUUsXG5cdCdzaWVubmEnOiAweEEwNTIyRCwgJ3NpbHZlcic6IDB4QzBDMEMwLCAnc2t5Ymx1ZSc6IDB4ODdDRUVCLCAnc2xhdGVibHVlJzogMHg2QTVBQ0QsICdzbGF0ZWdyYXknOiAweDcwODA5MCwgJ3NsYXRlZ3JleSc6IDB4NzA4MDkwLCAnc25vdyc6IDB4RkZGQUZBLFxuXHQnc3ByaW5nZ3JlZW4nOiAweDAwRkY3RiwgJ3N0ZWVsYmx1ZSc6IDB4NDY4MkI0LCAndGFuJzogMHhEMkI0OEMsICd0ZWFsJzogMHgwMDgwODAsICd0aGlzdGxlJzogMHhEOEJGRDgsICd0b21hdG8nOiAweEZGNjM0NywgJ3R1cnF1b2lzZSc6IDB4NDBFMEQwLFxuXHQndmlvbGV0JzogMHhFRTgyRUUsICd3aGVhdCc6IDB4RjVERUIzLCAnd2hpdGUnOiAweEZGRkZGRiwgJ3doaXRlc21va2UnOiAweEY1RjVGNSwgJ3llbGxvdyc6IDB4RkZGRjAwLCAneWVsbG93Z3JlZW4nOiAweDlBQ0QzMiB9O1xuXG5jb25zdCBfaHNsQSA9IHsgaDogMCwgczogMCwgbDogMCB9O1xuY29uc3QgX2hzbEIgPSB7IGg6IDAsIHM6IDAsIGw6IDAgfTtcblxuZnVuY3Rpb24gaHVlMnJnYiggcCwgcSwgdCApIHtcblxuXHRpZiAoIHQgPCAwICkgdCArPSAxO1xuXHRpZiAoIHQgPiAxICkgdCAtPSAxO1xuXHRpZiAoIHQgPCAxIC8gNiApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqIHQ7XG5cdGlmICggdCA8IDEgLyAyICkgcmV0dXJuIHE7XG5cdGlmICggdCA8IDIgLyAzICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogKCAyIC8gMyAtIHQgKTtcblx0cmV0dXJuIHA7XG5cbn1cblxuY2xhc3MgQ29sb3Ige1xuXG5cdGNvbnN0cnVjdG9yKCByLCBnLCBiICkge1xuXG5cdFx0dGhpcy5pc0NvbG9yID0gdHJ1ZTtcblxuXHRcdHRoaXMuciA9IDE7XG5cdFx0dGhpcy5nID0gMTtcblx0XHR0aGlzLmIgPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0KCByLCBnLCBiICk7XG5cblx0fVxuXG5cdHNldCggciwgZywgYiApIHtcblxuXHRcdGlmICggZyA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gciBpcyBUSFJFRS5Db2xvciwgaGV4IG9yIHN0cmluZ1xuXG5cdFx0XHRjb25zdCB2YWx1ZSA9IHI7XG5cblx0XHRcdGlmICggdmFsdWUgJiYgdmFsdWUuaXNDb2xvciApIHtcblxuXHRcdFx0XHR0aGlzLmNvcHkoIHZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKSB7XG5cblx0XHRcdFx0dGhpcy5zZXRIZXgoIHZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgKSB7XG5cblx0XHRcdFx0dGhpcy5zZXRTdHlsZSggdmFsdWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5zZXRSR0IoIHIsIGcsIGIgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHRoaXMuciA9IHNjYWxhcjtcblx0XHR0aGlzLmcgPSBzY2FsYXI7XG5cdFx0dGhpcy5iID0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEhleCggaGV4LCBjb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2UgKSB7XG5cblx0XHRoZXggPSBNYXRoLmZsb29yKCBoZXggKTtcblxuXHRcdHRoaXMuciA9ICggaGV4ID4+IDE2ICYgMjU1ICkgLyAyNTU7XG5cdFx0dGhpcy5nID0gKCBoZXggPj4gOCAmIDI1NSApIC8gMjU1O1xuXHRcdHRoaXMuYiA9ICggaGV4ICYgMjU1ICkgLyAyNTU7XG5cblx0XHRDb2xvck1hbmFnZW1lbnQudG9Xb3JraW5nQ29sb3JTcGFjZSggdGhpcywgY29sb3JTcGFjZSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFJHQiggciwgZywgYiwgY29sb3JTcGFjZSA9IENvbG9yTWFuYWdlbWVudC53b3JraW5nQ29sb3JTcGFjZSApIHtcblxuXHRcdHRoaXMuciA9IHI7XG5cdFx0dGhpcy5nID0gZztcblx0XHR0aGlzLmIgPSBiO1xuXG5cdFx0Q29sb3JNYW5hZ2VtZW50LnRvV29ya2luZ0NvbG9yU3BhY2UoIHRoaXMsIGNvbG9yU3BhY2UgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRIU0woIGgsIHMsIGwsIGNvbG9yU3BhY2UgPSBDb2xvck1hbmFnZW1lbnQud29ya2luZ0NvbG9yU3BhY2UgKSB7XG5cblx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuXHRcdGggPSBldWNsaWRlYW5Nb2R1bG8oIGgsIDEgKTtcblx0XHRzID0gY2xhbXAoIHMsIDAsIDEgKTtcblx0XHRsID0gY2xhbXAoIGwsIDAsIDEgKTtcblxuXHRcdGlmICggcyA9PT0gMCApIHtcblxuXHRcdFx0dGhpcy5yID0gdGhpcy5nID0gdGhpcy5iID0gbDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IHAgPSBsIDw9IDAuNSA/IGwgKiAoIDEgKyBzICkgOiBsICsgcyAtICggbCAqIHMgKTtcblx0XHRcdGNvbnN0IHEgPSAoIDIgKiBsICkgLSBwO1xuXG5cdFx0XHR0aGlzLnIgPSBodWUycmdiKCBxLCBwLCBoICsgMSAvIDMgKTtcblx0XHRcdHRoaXMuZyA9IGh1ZTJyZ2IoIHEsIHAsIGggKTtcblx0XHRcdHRoaXMuYiA9IGh1ZTJyZ2IoIHEsIHAsIGggLSAxIC8gMyApO1xuXG5cdFx0fVxuXG5cdFx0Q29sb3JNYW5hZ2VtZW50LnRvV29ya2luZ0NvbG9yU3BhY2UoIHRoaXMsIGNvbG9yU3BhY2UgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRTdHlsZSggc3R5bGUsIGNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZSApIHtcblxuXHRcdGZ1bmN0aW9uIGhhbmRsZUFscGhhKCBzdHJpbmcgKSB7XG5cblx0XHRcdGlmICggc3RyaW5nID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRcdGlmICggcGFyc2VGbG9hdCggc3RyaW5nICkgPCAxICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbG9yOiBBbHBoYSBjb21wb25lbnQgb2YgJyArIHN0eWxlICsgJyB3aWxsIGJlIGlnbm9yZWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblxuXHRcdGxldCBtO1xuXG5cdFx0aWYgKCBtID0gL14oXFx3KylcXCgoW15cXCldKilcXCkvLmV4ZWMoIHN0eWxlICkgKSB7XG5cblx0XHRcdC8vIHJnYiAvIGhzbFxuXG5cdFx0XHRsZXQgY29sb3I7XG5cdFx0XHRjb25zdCBuYW1lID0gbVsgMSBdO1xuXHRcdFx0Y29uc3QgY29tcG9uZW50cyA9IG1bIDIgXTtcblxuXHRcdFx0c3dpdGNoICggbmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdyZ2InOlxuXHRcdFx0XHRjYXNlICdyZ2JhJzpcblxuXHRcdFx0XHRcdGlmICggY29sb3IgPSAvXlxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKD86LFxccyooXFxkKlxcLj9cXGQrKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcmdiKDI1NSwwLDApIHJnYmEoMjU1LDAsMCwwLjUpXG5cblx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNCBdICk7XG5cblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnNldFJHQihcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NSxcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NSxcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDI1NSxcblx0XHRcdFx0XHRcdFx0Y29sb3JTcGFjZVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggY29sb3IgPSAvXlxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKD86LFxccyooXFxkKlxcLj9cXGQrKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcmdiKDEwMCUsMCUsMCUpIHJnYmEoMTAwJSwwJSwwJSwwLjUpXG5cblx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNCBdICk7XG5cblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnNldFJHQihcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDEwMCxcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDEwMCxcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDEwMCxcblx0XHRcdFx0XHRcdFx0Y29sb3JTcGFjZVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2hzbCc6XG5cdFx0XHRcdGNhc2UgJ2hzbGEnOlxuXG5cdFx0XHRcdFx0aWYgKCBjb2xvciA9IC9eXFxzKihcXGQqXFwuP1xcZCspXFxzKixcXHMqKFxcZCpcXC4/XFxkKylcXCVcXHMqLFxccyooXFxkKlxcLj9cXGQrKVxcJVxccyooPzosXFxzKihcXGQqXFwuP1xcZCspXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBoc2woMTIwLDUwJSw1MCUpIGhzbGEoMTIwLDUwJSw1MCUsMC41KVxuXG5cdFx0XHRcdFx0XHRoYW5kbGVBbHBoYSggY29sb3JbIDQgXSApO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRIU0woXG5cdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIGNvbG9yWyAxIF0gKSAvIDM2MCxcblx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggY29sb3JbIDIgXSApIC8gMTAwLFxuXHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBjb2xvclsgMyBdICkgLyAxMDAsXG5cdFx0XHRcdFx0XHRcdGNvbG9yU3BhY2Vcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgbW9kZWwgJyArIHN0eWxlICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG0gPSAvXlxcIyhbQS1GYS1mXFxkXSspJC8uZXhlYyggc3R5bGUgKSApIHtcblxuXHRcdFx0Ly8gaGV4IGNvbG9yXG5cblx0XHRcdGNvbnN0IGhleCA9IG1bIDEgXTtcblx0XHRcdGNvbnN0IHNpemUgPSBoZXgubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHNpemUgPT09IDMgKSB7XG5cblx0XHRcdFx0Ly8gI2ZmMFxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRSR0IoXG5cdFx0XHRcdFx0cGFyc2VJbnQoIGhleC5jaGFyQXQoIDAgKSwgMTYgKSAvIDE1LFxuXHRcdFx0XHRcdHBhcnNlSW50KCBoZXguY2hhckF0KCAxICksIDE2ICkgLyAxNSxcblx0XHRcdFx0XHRwYXJzZUludCggaGV4LmNoYXJBdCggMiApLCAxNiApIC8gMTUsXG5cdFx0XHRcdFx0Y29sb3JTcGFjZVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBzaXplID09PSA2ICkge1xuXG5cdFx0XHRcdC8vICNmZjAwMDBcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0SGV4KCBwYXJzZUludCggaGV4LCAxNiApLCBjb2xvclNwYWNlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IEludmFsaWQgaGV4IGNvbG9yICcgKyBzdHlsZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBzdHlsZSAmJiBzdHlsZS5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDb2xvck5hbWUoIHN0eWxlLCBjb2xvclNwYWNlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0Q29sb3JOYW1lKCBzdHlsZSwgY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlICkge1xuXG5cdFx0Ly8gY29sb3Iga2V5d29yZHNcblx0XHRjb25zdCBoZXggPSBfY29sb3JLZXl3b3Jkc1sgc3R5bGUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0aWYgKCBoZXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gcmVkXG5cdFx0XHR0aGlzLnNldEhleCggaGV4LCBjb2xvclNwYWNlICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyB1bmtub3duIGNvbG9yXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xvcjogVW5rbm93biBjb2xvciAnICsgc3R5bGUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiApO1xuXG5cdH1cblxuXHRjb3B5KCBjb2xvciApIHtcblxuXHRcdHRoaXMuciA9IGNvbG9yLnI7XG5cdFx0dGhpcy5nID0gY29sb3IuZztcblx0XHR0aGlzLmIgPSBjb2xvci5iO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHlTUkdCVG9MaW5lYXIoIGNvbG9yICkge1xuXG5cdFx0dGhpcy5yID0gU1JHQlRvTGluZWFyKCBjb2xvci5yICk7XG5cdFx0dGhpcy5nID0gU1JHQlRvTGluZWFyKCBjb2xvci5nICk7XG5cdFx0dGhpcy5iID0gU1JHQlRvTGluZWFyKCBjb2xvci5iICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weUxpbmVhclRvU1JHQiggY29sb3IgKSB7XG5cblx0XHR0aGlzLnIgPSBMaW5lYXJUb1NSR0IoIGNvbG9yLnIgKTtcblx0XHR0aGlzLmcgPSBMaW5lYXJUb1NSR0IoIGNvbG9yLmcgKTtcblx0XHR0aGlzLmIgPSBMaW5lYXJUb1NSR0IoIGNvbG9yLmIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb252ZXJ0U1JHQlRvTGluZWFyKCkge1xuXG5cdFx0dGhpcy5jb3B5U1JHQlRvTGluZWFyKCB0aGlzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29udmVydExpbmVhclRvU1JHQigpIHtcblxuXHRcdHRoaXMuY29weUxpbmVhclRvU1JHQiggdGhpcyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldEhleCggY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlICkge1xuXG5cdFx0Q29sb3JNYW5hZ2VtZW50LmZyb21Xb3JraW5nQ29sb3JTcGFjZSggX2NvbG9yLmNvcHkoIHRoaXMgKSwgY29sb3JTcGFjZSApO1xuXG5cdFx0cmV0dXJuIE1hdGgucm91bmQoIGNsYW1wKCBfY29sb3IuciAqIDI1NSwgMCwgMjU1ICkgKSAqIDY1NTM2ICsgTWF0aC5yb3VuZCggY2xhbXAoIF9jb2xvci5nICogMjU1LCAwLCAyNTUgKSApICogMjU2ICsgTWF0aC5yb3VuZCggY2xhbXAoIF9jb2xvci5iICogMjU1LCAwLCAyNTUgKSApO1xuXG5cdH1cblxuXHRnZXRIZXhTdHJpbmcoIGNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZSApIHtcblxuXHRcdHJldHVybiAoICcwMDAwMDAnICsgdGhpcy5nZXRIZXgoIGNvbG9yU3BhY2UgKS50b1N0cmluZyggMTYgKSApLnNsaWNlKCAtIDYgKTtcblxuXHR9XG5cblx0Z2V0SFNMKCB0YXJnZXQsIGNvbG9yU3BhY2UgPSBDb2xvck1hbmFnZW1lbnQud29ya2luZ0NvbG9yU3BhY2UgKSB7XG5cblx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuXG5cdFx0Q29sb3JNYW5hZ2VtZW50LmZyb21Xb3JraW5nQ29sb3JTcGFjZSggX2NvbG9yLmNvcHkoIHRoaXMgKSwgY29sb3JTcGFjZSApO1xuXG5cdFx0Y29uc3QgciA9IF9jb2xvci5yLCBnID0gX2NvbG9yLmcsIGIgPSBfY29sb3IuYjtcblxuXHRcdGNvbnN0IG1heCA9IE1hdGgubWF4KCByLCBnLCBiICk7XG5cdFx0Y29uc3QgbWluID0gTWF0aC5taW4oIHIsIGcsIGIgKTtcblxuXHRcdGxldCBodWUsIHNhdHVyYXRpb247XG5cdFx0Y29uc3QgbGlnaHRuZXNzID0gKCBtaW4gKyBtYXggKSAvIDIuMDtcblxuXHRcdGlmICggbWluID09PSBtYXggKSB7XG5cblx0XHRcdGh1ZSA9IDA7XG5cdFx0XHRzYXR1cmF0aW9uID0gMDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGRlbHRhID0gbWF4IC0gbWluO1xuXG5cdFx0XHRzYXR1cmF0aW9uID0gbGlnaHRuZXNzIDw9IDAuNSA/IGRlbHRhIC8gKCBtYXggKyBtaW4gKSA6IGRlbHRhIC8gKCAyIC0gbWF4IC0gbWluICk7XG5cblx0XHRcdHN3aXRjaCAoIG1heCApIHtcblxuXHRcdFx0XHRjYXNlIHI6IGh1ZSA9ICggZyAtIGIgKSAvIGRlbHRhICsgKCBnIDwgYiA/IDYgOiAwICk7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIGc6IGh1ZSA9ICggYiAtIHIgKSAvIGRlbHRhICsgMjsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgYjogaHVlID0gKCByIC0gZyApIC8gZGVsdGEgKyA0OyBicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRodWUgLz0gNjtcblxuXHRcdH1cblxuXHRcdHRhcmdldC5oID0gaHVlO1xuXHRcdHRhcmdldC5zID0gc2F0dXJhdGlvbjtcblx0XHR0YXJnZXQubCA9IGxpZ2h0bmVzcztcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdGdldFJHQiggdGFyZ2V0LCBjb2xvclNwYWNlID0gQ29sb3JNYW5hZ2VtZW50LndvcmtpbmdDb2xvclNwYWNlICkge1xuXG5cdFx0Q29sb3JNYW5hZ2VtZW50LmZyb21Xb3JraW5nQ29sb3JTcGFjZSggX2NvbG9yLmNvcHkoIHRoaXMgKSwgY29sb3JTcGFjZSApO1xuXG5cdFx0dGFyZ2V0LnIgPSBfY29sb3Iucjtcblx0XHR0YXJnZXQuZyA9IF9jb2xvci5nO1xuXHRcdHRhcmdldC5iID0gX2NvbG9yLmI7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRnZXRTdHlsZSggY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlICkge1xuXG5cdFx0Q29sb3JNYW5hZ2VtZW50LmZyb21Xb3JraW5nQ29sb3JTcGFjZSggX2NvbG9yLmNvcHkoIHRoaXMgKSwgY29sb3JTcGFjZSApO1xuXG5cdFx0Y29uc3QgciA9IF9jb2xvci5yLCBnID0gX2NvbG9yLmcsIGIgPSBfY29sb3IuYjtcblxuXHRcdGlmICggY29sb3JTcGFjZSAhPT0gU1JHQkNvbG9yU3BhY2UgKSB7XG5cblx0XHRcdC8vIFJlcXVpcmVzIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgNCAoaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci00LykuXG5cdFx0XHRyZXR1cm4gYGNvbG9yKCR7IGNvbG9yU3BhY2UgfSAkeyByLnRvRml4ZWQoIDMgKSB9ICR7IGcudG9GaXhlZCggMyApIH0gJHsgYi50b0ZpeGVkKCAzICkgfSlgO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGByZ2IoJHsgTWF0aC5yb3VuZCggciAqIDI1NSApIH0sJHsgTWF0aC5yb3VuZCggZyAqIDI1NSApIH0sJHsgTWF0aC5yb3VuZCggYiAqIDI1NSApIH0pYDtcblxuXHR9XG5cblx0b2Zmc2V0SFNMKCBoLCBzLCBsICkge1xuXG5cdFx0dGhpcy5nZXRIU0woIF9oc2xBICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRIU0woIF9oc2xBLmggKyBoLCBfaHNsQS5zICsgcywgX2hzbEEubCArIGwgKTtcblxuXHR9XG5cblx0YWRkKCBjb2xvciApIHtcblxuXHRcdHRoaXMuciArPSBjb2xvci5yO1xuXHRcdHRoaXMuZyArPSBjb2xvci5nO1xuXHRcdHRoaXMuYiArPSBjb2xvci5iO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZENvbG9ycyggY29sb3IxLCBjb2xvcjIgKSB7XG5cblx0XHR0aGlzLnIgPSBjb2xvcjEuciArIGNvbG9yMi5yO1xuXHRcdHRoaXMuZyA9IGNvbG9yMS5nICsgY29sb3IyLmc7XG5cdFx0dGhpcy5iID0gY29sb3IxLmIgKyBjb2xvcjIuYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGRTY2FsYXIoIHMgKSB7XG5cblx0XHR0aGlzLnIgKz0gcztcblx0XHR0aGlzLmcgKz0gcztcblx0XHR0aGlzLmIgKz0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdWIoIGNvbG9yICkge1xuXG5cdFx0dGhpcy5yID0gTWF0aC5tYXgoIDAsIHRoaXMuciAtIGNvbG9yLnIgKTtcblx0XHR0aGlzLmcgPSBNYXRoLm1heCggMCwgdGhpcy5nIC0gY29sb3IuZyApO1xuXHRcdHRoaXMuYiA9IE1hdGgubWF4KCAwLCB0aGlzLmIgLSBjb2xvci5iICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHkoIGNvbG9yICkge1xuXG5cdFx0dGhpcy5yICo9IGNvbG9yLnI7XG5cdFx0dGhpcy5nICo9IGNvbG9yLmc7XG5cdFx0dGhpcy5iICo9IGNvbG9yLmI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHlTY2FsYXIoIHMgKSB7XG5cblx0XHR0aGlzLnIgKj0gcztcblx0XHR0aGlzLmcgKj0gcztcblx0XHR0aGlzLmIgKj0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRsZXJwKCBjb2xvciwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnIgKz0gKCBjb2xvci5yIC0gdGhpcy5yICkgKiBhbHBoYTtcblx0XHR0aGlzLmcgKz0gKCBjb2xvci5nIC0gdGhpcy5nICkgKiBhbHBoYTtcblx0XHR0aGlzLmIgKz0gKCBjb2xvci5iIC0gdGhpcy5iICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRsZXJwQ29sb3JzKCBjb2xvcjEsIGNvbG9yMiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnIgPSBjb2xvcjEuciArICggY29sb3IyLnIgLSBjb2xvcjEuciApICogYWxwaGE7XG5cdFx0dGhpcy5nID0gY29sb3IxLmcgKyAoIGNvbG9yMi5nIC0gY29sb3IxLmcgKSAqIGFscGhhO1xuXHRcdHRoaXMuYiA9IGNvbG9yMS5iICsgKCBjb2xvcjIuYiAtIGNvbG9yMS5iICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRsZXJwSFNMKCBjb2xvciwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLmdldEhTTCggX2hzbEEgKTtcblx0XHRjb2xvci5nZXRIU0woIF9oc2xCICk7XG5cblx0XHRjb25zdCBoID0gbGVycCggX2hzbEEuaCwgX2hzbEIuaCwgYWxwaGEgKTtcblx0XHRjb25zdCBzID0gbGVycCggX2hzbEEucywgX2hzbEIucywgYWxwaGEgKTtcblx0XHRjb25zdCBsID0gbGVycCggX2hzbEEubCwgX2hzbEIubCwgYWxwaGEgKTtcblxuXHRcdHRoaXMuc2V0SFNMKCBoLCBzLCBsICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVZlY3RvcjMoIHYgKSB7XG5cblx0XHR0aGlzLnIgPSB2Lng7XG5cdFx0dGhpcy5nID0gdi55O1xuXHRcdHRoaXMuYiA9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDMoIG0gKSB7XG5cblx0XHRjb25zdCByID0gdGhpcy5yLCBnID0gdGhpcy5nLCBiID0gdGhpcy5iO1xuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy5yID0gZVsgMCBdICogciArIGVbIDMgXSAqIGcgKyBlWyA2IF0gKiBiO1xuXHRcdHRoaXMuZyA9IGVbIDEgXSAqIHIgKyBlWyA0IF0gKiBnICsgZVsgNyBdICogYjtcblx0XHR0aGlzLmIgPSBlWyAyIF0gKiByICsgZVsgNSBdICogZyArIGVbIDggXSAqIGI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXF1YWxzKCBjICkge1xuXG5cdFx0cmV0dXJuICggYy5yID09PSB0aGlzLnIgKSAmJiAoIGMuZyA9PT0gdGhpcy5nICkgJiYgKCBjLmIgPT09IHRoaXMuYiApO1xuXG5cdH1cblxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xuXG5cdFx0dGhpcy5yID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMuZyA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy5iID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5yO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLmc7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuYjtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCApIHtcblxuXHRcdHRoaXMuciA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xuXHRcdHRoaXMuZyA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xuXHRcdHRoaXMuYiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdHJldHVybiB0aGlzLmdldEhleCgpO1xuXG5cdH1cblxuXHQqWyBTeW1ib2wuaXRlcmF0b3IgXSgpIHtcblxuXHRcdHlpZWxkIHRoaXMucjtcblx0XHR5aWVsZCB0aGlzLmc7XG5cdFx0eWllbGQgdGhpcy5iO1xuXG5cdH1cblxufVxuXG5jb25zdCBfY29sb3IgPSAvKkBfX1BVUkVfXyovIG5ldyBDb2xvcigpO1xuXG5Db2xvci5OQU1FUyA9IF9jb2xvcktleXdvcmRzO1xuXG5sZXQgX21hdGVyaWFsSWQgPSAwO1xuXG5jbGFzcyBNYXRlcmlhbCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc01hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogX21hdGVyaWFsSWQgKysgfSApO1xuXG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLm5hbWUgPSAnJztcblx0XHR0aGlzLnR5cGUgPSAnTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5ibGVuZGluZyA9IE5vcm1hbEJsZW5kaW5nO1xuXHRcdHRoaXMuc2lkZSA9IEZyb250U2lkZTtcblx0XHR0aGlzLnZlcnRleENvbG9ycyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5vcGFjaXR5ID0gMTtcblx0XHR0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XG5cdFx0dGhpcy5hbHBoYUhhc2ggPSBmYWxzZTtcblxuXHRcdHRoaXMuYmxlbmRTcmMgPSBTcmNBbHBoYUZhY3Rvcjtcblx0XHR0aGlzLmJsZW5kRHN0ID0gT25lTWludXNTcmNBbHBoYUZhY3Rvcjtcblx0XHR0aGlzLmJsZW5kRXF1YXRpb24gPSBBZGRFcXVhdGlvbjtcblx0XHR0aGlzLmJsZW5kU3JjQWxwaGEgPSBudWxsO1xuXHRcdHRoaXMuYmxlbmREc3RBbHBoYSA9IG51bGw7XG5cdFx0dGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuXHRcdHRoaXMuYmxlbmRDb2xvciA9IG5ldyBDb2xvciggMCwgMCwgMCApO1xuXHRcdHRoaXMuYmxlbmRBbHBoYSA9IDA7XG5cblx0XHR0aGlzLmRlcHRoRnVuYyA9IExlc3NFcXVhbERlcHRoO1xuXHRcdHRoaXMuZGVwdGhUZXN0ID0gdHJ1ZTtcblx0XHR0aGlzLmRlcHRoV3JpdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5zdGVuY2lsV3JpdGVNYXNrID0gMHhmZjtcblx0XHR0aGlzLnN0ZW5jaWxGdW5jID0gQWx3YXlzU3RlbmNpbEZ1bmM7XG5cdFx0dGhpcy5zdGVuY2lsUmVmID0gMDtcblx0XHR0aGlzLnN0ZW5jaWxGdW5jTWFzayA9IDB4ZmY7XG5cdFx0dGhpcy5zdGVuY2lsRmFpbCA9IEtlZXBTdGVuY2lsT3A7XG5cdFx0dGhpcy5zdGVuY2lsWkZhaWwgPSBLZWVwU3RlbmNpbE9wO1xuXHRcdHRoaXMuc3RlbmNpbFpQYXNzID0gS2VlcFN0ZW5jaWxPcDtcblx0XHR0aGlzLnN0ZW5jaWxXcml0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5jbGlwcGluZ1BsYW5lcyA9IG51bGw7XG5cdFx0dGhpcy5jbGlwSW50ZXJzZWN0aW9uID0gZmFsc2U7XG5cdFx0dGhpcy5jbGlwU2hhZG93cyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zaGFkb3dTaWRlID0gbnVsbDtcblxuXHRcdHRoaXMuY29sb3JXcml0ZSA9IHRydWU7XG5cblx0XHR0aGlzLnByZWNpc2lvbiA9IG51bGw7IC8vIG92ZXJyaWRlIHRoZSByZW5kZXJlcidzIGRlZmF1bHQgcHJlY2lzaW9uIGZvciB0aGlzIG1hdGVyaWFsXG5cblx0XHR0aGlzLnBvbHlnb25PZmZzZXQgPSBmYWxzZTtcblx0XHR0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAwO1xuXHRcdHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gMDtcblxuXHRcdHRoaXMuZGl0aGVyaW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLmFscGhhVG9Db3ZlcmFnZSA9IGZhbHNlO1xuXHRcdHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gZmFsc2U7XG5cdFx0dGhpcy5mb3JjZVNpbmdsZVBhc3MgPSBmYWxzZTtcblxuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cblx0XHR0aGlzLnRvbmVNYXBwZWQgPSB0cnVlO1xuXG5cdFx0dGhpcy51c2VyRGF0YSA9IHt9O1xuXG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcblxuXHRcdHRoaXMuX2FscGhhVGVzdCA9IDA7XG5cblx0fVxuXG5cdGdldCBhbHBoYVRlc3QoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fYWxwaGFUZXN0O1xuXG5cdH1cblxuXHRzZXQgYWxwaGFUZXN0KCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy5fYWxwaGFUZXN0ID4gMCAhPT0gdmFsdWUgPiAwICkge1xuXG5cdFx0XHR0aGlzLnZlcnNpb24gKys7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9hbHBoYVRlc3QgPSB2YWx1ZTtcblxuXHR9XG5cblx0Ly8gb25CZWZvcmVSZW5kZXIgYW5kIG9uQmVmb3JlQ29tcGlsZSBvbmx5IHN1cHBvcnRlZCBpbiBXZWJHTFJlbmRlcmVyXG5cblx0b25CZWZvcmVSZW5kZXIoIC8qIHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgb2JqZWN0LCBncm91cCAqLyApIHt9XG5cblx0b25CZWZvcmVDb21waWxlKCAvKiBzaGFkZXJvYmplY3QsIHJlbmRlcmVyICovICkge31cblxuXHRjdXN0b21Qcm9ncmFtQ2FjaGVLZXkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5vbkJlZm9yZUNvbXBpbGUudG9TdHJpbmcoKTtcblxuXHR9XG5cblx0c2V0VmFsdWVzKCB2YWx1ZXMgKSB7XG5cblx0XHRpZiAoIHZhbHVlcyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0Zm9yICggY29uc3Qga2V5IGluIHZhbHVlcyApIHtcblxuXHRcdFx0Y29uc3QgbmV3VmFsdWUgPSB2YWx1ZXNbIGtleSBdO1xuXG5cdFx0XHRpZiAoIG5ld1ZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCBgVEhSRUUuTWF0ZXJpYWw6IHBhcmFtZXRlciAnJHsga2V5IH0nIGhhcyB2YWx1ZSBvZiB1bmRlZmluZWQuYCApO1xuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzWyBrZXkgXTtcblxuXHRcdFx0aWYgKCBjdXJyZW50VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oIGBUSFJFRS5NYXRlcmlhbDogJyR7IGtleSB9JyBpcyBub3QgYSBwcm9wZXJ0eSBvZiBUSFJFRS4keyB0aGlzLnR5cGUgfS5gICk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggY3VycmVudFZhbHVlICYmIGN1cnJlbnRWYWx1ZS5pc0NvbG9yICkge1xuXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZS5zZXQoIG5ld1ZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoICggY3VycmVudFZhbHVlICYmIGN1cnJlbnRWYWx1ZS5pc1ZlY3RvcjMgKSAmJiAoIG5ld1ZhbHVlICYmIG5ld1ZhbHVlLmlzVmVjdG9yMyApICkge1xuXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZS5jb3B5KCBuZXdWYWx1ZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXNbIGtleSBdID0gbmV3VmFsdWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0dG9KU09OKCBtZXRhICkge1xuXG5cdFx0Y29uc3QgaXNSb290T2JqZWN0ID0gKCBtZXRhID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnICk7XG5cblx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuXHRcdFx0bWV0YSA9IHtcblx0XHRcdFx0dGV4dHVyZXM6IHt9LFxuXHRcdFx0XHRpbWFnZXM6IHt9XG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdHZlcnNpb246IDQuNixcblx0XHRcdFx0dHlwZTogJ01hdGVyaWFsJyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnTWF0ZXJpYWwudG9KU09OJ1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBzdGFuZGFyZCBNYXRlcmlhbCBzZXJpYWxpemF0aW9uXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblxuXHRcdGlmICggdGhpcy5jb2xvciAmJiB0aGlzLmNvbG9yLmlzQ29sb3IgKSBkYXRhLmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcblxuXHRcdGlmICggdGhpcy5yb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEucm91Z2huZXNzID0gdGhpcy5yb3VnaG5lc3M7XG5cdFx0aWYgKCB0aGlzLm1ldGFsbmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5tZXRhbG5lc3MgPSB0aGlzLm1ldGFsbmVzcztcblxuXHRcdGlmICggdGhpcy5zaGVlbiAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaGVlbiA9IHRoaXMuc2hlZW47XG5cdFx0aWYgKCB0aGlzLnNoZWVuQ29sb3IgJiYgdGhpcy5zaGVlbkNvbG9yLmlzQ29sb3IgKSBkYXRhLnNoZWVuQ29sb3IgPSB0aGlzLnNoZWVuQ29sb3IuZ2V0SGV4KCk7XG5cdFx0aWYgKCB0aGlzLnNoZWVuUm91Z2huZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLnNoZWVuUm91Z2huZXNzID0gdGhpcy5zaGVlblJvdWdobmVzcztcblx0XHRpZiAoIHRoaXMuZW1pc3NpdmUgJiYgdGhpcy5lbWlzc2l2ZS5pc0NvbG9yICkgZGF0YS5lbWlzc2l2ZSA9IHRoaXMuZW1pc3NpdmUuZ2V0SGV4KCk7XG5cdFx0aWYgKCB0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5lbWlzc2l2ZUludGVuc2l0eSAhPT0gMSApIGRhdGEuZW1pc3NpdmVJbnRlbnNpdHkgPSB0aGlzLmVtaXNzaXZlSW50ZW5zaXR5O1xuXG5cdFx0aWYgKCB0aGlzLnNwZWN1bGFyICYmIHRoaXMuc3BlY3VsYXIuaXNDb2xvciApIGRhdGEuc3BlY3VsYXIgPSB0aGlzLnNwZWN1bGFyLmdldEhleCgpO1xuXHRcdGlmICggdGhpcy5zcGVjdWxhckludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgZGF0YS5zcGVjdWxhckludGVuc2l0eSA9IHRoaXMuc3BlY3VsYXJJbnRlbnNpdHk7XG5cdFx0aWYgKCB0aGlzLnNwZWN1bGFyQ29sb3IgJiYgdGhpcy5zcGVjdWxhckNvbG9yLmlzQ29sb3IgKSBkYXRhLnNwZWN1bGFyQ29sb3IgPSB0aGlzLnNwZWN1bGFyQ29sb3IuZ2V0SGV4KCk7XG5cdFx0aWYgKCB0aGlzLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaGluaW5lc3MgPSB0aGlzLnNoaW5pbmVzcztcblx0XHRpZiAoIHRoaXMuY2xlYXJjb2F0ICE9PSB1bmRlZmluZWQgKSBkYXRhLmNsZWFyY29hdCA9IHRoaXMuY2xlYXJjb2F0O1xuXHRcdGlmICggdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEuY2xlYXJjb2F0Um91Z2huZXNzID0gdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3M7XG5cblx0XHRpZiAoIHRoaXMuY2xlYXJjb2F0TWFwICYmIHRoaXMuY2xlYXJjb2F0TWFwLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0ZGF0YS5jbGVhcmNvYXRNYXAgPSB0aGlzLmNsZWFyY29hdE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmNsZWFyY29hdFJvdWdobmVzc01hcCAmJiB0aGlzLmNsZWFyY29hdFJvdWdobmVzc01hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEuY2xlYXJjb2F0Um91Z2huZXNzTWFwID0gdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5jbGVhcmNvYXROb3JtYWxNYXAgJiYgdGhpcy5jbGVhcmNvYXROb3JtYWxNYXAuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRkYXRhLmNsZWFyY29hdE5vcm1hbE1hcCA9IHRoaXMuY2xlYXJjb2F0Tm9ybWFsTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0XHRkYXRhLmNsZWFyY29hdE5vcm1hbFNjYWxlID0gdGhpcy5jbGVhcmNvYXROb3JtYWxTY2FsZS50b0FycmF5KCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuZGlzcGVyc2lvbiAhPT0gdW5kZWZpbmVkICkgZGF0YS5kaXNwZXJzaW9uID0gdGhpcy5kaXNwZXJzaW9uO1xuXG5cdFx0aWYgKCB0aGlzLmlyaWRlc2NlbmNlICE9PSB1bmRlZmluZWQgKSBkYXRhLmlyaWRlc2NlbmNlID0gdGhpcy5pcmlkZXNjZW5jZTtcblx0XHRpZiAoIHRoaXMuaXJpZGVzY2VuY2VJT1IgIT09IHVuZGVmaW5lZCApIGRhdGEuaXJpZGVzY2VuY2VJT1IgPSB0aGlzLmlyaWRlc2NlbmNlSU9SO1xuXHRcdGlmICggdGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlICE9PSB1bmRlZmluZWQgKSBkYXRhLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgPSB0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2U7XG5cblx0XHRpZiAoIHRoaXMuaXJpZGVzY2VuY2VNYXAgJiYgdGhpcy5pcmlkZXNjZW5jZU1hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEuaXJpZGVzY2VuY2VNYXAgPSB0aGlzLmlyaWRlc2NlbmNlTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgJiYgdGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgPSB0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuYW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkgZGF0YS5hbmlzb3Ryb3B5ID0gdGhpcy5hbmlzb3Ryb3B5O1xuXHRcdGlmICggdGhpcy5hbmlzb3Ryb3B5Um90YXRpb24gIT09IHVuZGVmaW5lZCApIGRhdGEuYW5pc290cm9weVJvdGF0aW9uID0gdGhpcy5hbmlzb3Ryb3B5Um90YXRpb247XG5cblx0XHRpZiAoIHRoaXMuYW5pc290cm9weU1hcCAmJiB0aGlzLmFuaXNvdHJvcHlNYXAuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRkYXRhLmFuaXNvdHJvcHlNYXAgPSB0aGlzLmFuaXNvdHJvcHlNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5tYXAgJiYgdGhpcy5tYXAuaXNUZXh0dXJlICkgZGF0YS5tYXAgPSB0aGlzLm1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdGlmICggdGhpcy5tYXRjYXAgJiYgdGhpcy5tYXRjYXAuaXNUZXh0dXJlICkgZGF0YS5tYXRjYXAgPSB0aGlzLm1hdGNhcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdGlmICggdGhpcy5hbHBoYU1hcCAmJiB0aGlzLmFscGhhTWFwLmlzVGV4dHVyZSApIGRhdGEuYWxwaGFNYXAgPSB0aGlzLmFscGhhTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHRpZiAoIHRoaXMubGlnaHRNYXAgJiYgdGhpcy5saWdodE1hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0XHRkYXRhLmxpZ2h0TWFwSW50ZW5zaXR5ID0gdGhpcy5saWdodE1hcEludGVuc2l0eTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hb01hcCAmJiB0aGlzLmFvTWFwLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0ZGF0YS5hb01hcCA9IHRoaXMuYW9NYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRcdGRhdGEuYW9NYXBJbnRlbnNpdHkgPSB0aGlzLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmJ1bXBNYXAgJiYgdGhpcy5idW1wTWFwLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0ZGF0YS5idW1wTWFwID0gdGhpcy5idW1wTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0XHRkYXRhLmJ1bXBTY2FsZSA9IHRoaXMuYnVtcFNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbE1hcCAmJiB0aGlzLm5vcm1hbE1hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEubm9ybWFsTWFwID0gdGhpcy5ub3JtYWxNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRcdGRhdGEubm9ybWFsTWFwVHlwZSA9IHRoaXMubm9ybWFsTWFwVHlwZTtcblx0XHRcdGRhdGEubm9ybWFsU2NhbGUgPSB0aGlzLm5vcm1hbFNjYWxlLnRvQXJyYXkoKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5kaXNwbGFjZW1lbnRNYXAgJiYgdGhpcy5kaXNwbGFjZW1lbnRNYXAuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRkYXRhLmRpc3BsYWNlbWVudE1hcCA9IHRoaXMuZGlzcGxhY2VtZW50TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0XHRkYXRhLmRpc3BsYWNlbWVudFNjYWxlID0gdGhpcy5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdGRhdGEuZGlzcGxhY2VtZW50QmlhcyA9IHRoaXMuZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5yb3VnaG5lc3NNYXAgJiYgdGhpcy5yb3VnaG5lc3NNYXAuaXNUZXh0dXJlICkgZGF0YS5yb3VnaG5lc3NNYXAgPSB0aGlzLnJvdWdobmVzc01hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdGlmICggdGhpcy5tZXRhbG5lc3NNYXAgJiYgdGhpcy5tZXRhbG5lc3NNYXAuaXNUZXh0dXJlICkgZGF0YS5tZXRhbG5lc3NNYXAgPSB0aGlzLm1ldGFsbmVzc01hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXG5cdFx0aWYgKCB0aGlzLmVtaXNzaXZlTWFwICYmIHRoaXMuZW1pc3NpdmVNYXAuaXNUZXh0dXJlICkgZGF0YS5lbWlzc2l2ZU1hcCA9IHRoaXMuZW1pc3NpdmVNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRpZiAoIHRoaXMuc3BlY3VsYXJNYXAgJiYgdGhpcy5zcGVjdWxhck1hcC5pc1RleHR1cmUgKSBkYXRhLnNwZWN1bGFyTWFwID0gdGhpcy5zcGVjdWxhck1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdGlmICggdGhpcy5zcGVjdWxhckludGVuc2l0eU1hcCAmJiB0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwLmlzVGV4dHVyZSApIGRhdGEuc3BlY3VsYXJJbnRlbnNpdHlNYXAgPSB0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0aWYgKCB0aGlzLnNwZWN1bGFyQ29sb3JNYXAgJiYgdGhpcy5zcGVjdWxhckNvbG9yTWFwLmlzVGV4dHVyZSApIGRhdGEuc3BlY3VsYXJDb2xvck1hcCA9IHRoaXMuc3BlY3VsYXJDb2xvck1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXG5cdFx0aWYgKCB0aGlzLmVudk1hcCAmJiB0aGlzLmVudk1hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEuZW52TWFwID0gdGhpcy5lbnZNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblxuXHRcdFx0aWYgKCB0aGlzLmNvbWJpbmUgIT09IHVuZGVmaW5lZCApIGRhdGEuY29tYmluZSA9IHRoaXMuY29tYmluZTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5lbnZNYXBSb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgZGF0YS5lbnZNYXBSb3RhdGlvbiA9IHRoaXMuZW52TWFwUm90YXRpb24udG9BcnJheSgpO1xuXHRcdGlmICggdGhpcy5lbnZNYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIGRhdGEuZW52TWFwSW50ZW5zaXR5ID0gdGhpcy5lbnZNYXBJbnRlbnNpdHk7XG5cdFx0aWYgKCB0aGlzLnJlZmxlY3Rpdml0eSAhPT0gdW5kZWZpbmVkICkgZGF0YS5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTtcblx0XHRpZiAoIHRoaXMucmVmcmFjdGlvblJhdGlvICE9PSB1bmRlZmluZWQgKSBkYXRhLnJlZnJhY3Rpb25SYXRpbyA9IHRoaXMucmVmcmFjdGlvblJhdGlvO1xuXG5cdFx0aWYgKCB0aGlzLmdyYWRpZW50TWFwICYmIHRoaXMuZ3JhZGllbnRNYXAuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRkYXRhLmdyYWRpZW50TWFwID0gdGhpcy5ncmFkaWVudE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnRyYW5zbWlzc2lvbiAhPT0gdW5kZWZpbmVkICkgZGF0YS50cmFuc21pc3Npb24gPSB0aGlzLnRyYW5zbWlzc2lvbjtcblx0XHRpZiAoIHRoaXMudHJhbnNtaXNzaW9uTWFwICYmIHRoaXMudHJhbnNtaXNzaW9uTWFwLmlzVGV4dHVyZSApIGRhdGEudHJhbnNtaXNzaW9uTWFwID0gdGhpcy50cmFuc21pc3Npb25NYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRpZiAoIHRoaXMudGhpY2tuZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLnRoaWNrbmVzcyA9IHRoaXMudGhpY2tuZXNzO1xuXHRcdGlmICggdGhpcy50aGlja25lc3NNYXAgJiYgdGhpcy50aGlja25lc3NNYXAuaXNUZXh0dXJlICkgZGF0YS50aGlja25lc3NNYXAgPSB0aGlzLnRoaWNrbmVzc01hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdGlmICggdGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlICE9PSBJbmZpbml0eSApIGRhdGEuYXR0ZW51YXRpb25EaXN0YW5jZSA9IHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZTtcblx0XHRpZiAoIHRoaXMuYXR0ZW51YXRpb25Db2xvciAhPT0gdW5kZWZpbmVkICkgZGF0YS5hdHRlbnVhdGlvbkNvbG9yID0gdGhpcy5hdHRlbnVhdGlvbkNvbG9yLmdldEhleCgpO1xuXG5cdFx0aWYgKCB0aGlzLnNpemUgIT09IHVuZGVmaW5lZCApIGRhdGEuc2l6ZSA9IHRoaXMuc2l6ZTtcblx0XHRpZiAoIHRoaXMuc2hhZG93U2lkZSAhPT0gbnVsbCApIGRhdGEuc2hhZG93U2lkZSA9IHRoaXMuc2hhZG93U2lkZTtcblx0XHRpZiAoIHRoaXMuc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBkYXRhLnNpemVBdHRlbnVhdGlvbiA9IHRoaXMuc2l6ZUF0dGVudWF0aW9uO1xuXG5cdFx0aWYgKCB0aGlzLmJsZW5kaW5nICE9PSBOb3JtYWxCbGVuZGluZyApIGRhdGEuYmxlbmRpbmcgPSB0aGlzLmJsZW5kaW5nO1xuXHRcdGlmICggdGhpcy5zaWRlICE9PSBGcm9udFNpZGUgKSBkYXRhLnNpZGUgPSB0aGlzLnNpZGU7XG5cdFx0aWYgKCB0aGlzLnZlcnRleENvbG9ycyA9PT0gdHJ1ZSApIGRhdGEudmVydGV4Q29sb3JzID0gdHJ1ZTtcblxuXHRcdGlmICggdGhpcy5vcGFjaXR5IDwgMSApIGRhdGEub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcblx0XHRpZiAoIHRoaXMudHJhbnNwYXJlbnQgPT09IHRydWUgKSBkYXRhLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdGlmICggdGhpcy5ibGVuZFNyYyAhPT0gU3JjQWxwaGFGYWN0b3IgKSBkYXRhLmJsZW5kU3JjID0gdGhpcy5ibGVuZFNyYztcblx0XHRpZiAoIHRoaXMuYmxlbmREc3QgIT09IE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgKSBkYXRhLmJsZW5kRHN0ID0gdGhpcy5ibGVuZERzdDtcblx0XHRpZiAoIHRoaXMuYmxlbmRFcXVhdGlvbiAhPT0gQWRkRXF1YXRpb24gKSBkYXRhLmJsZW5kRXF1YXRpb24gPSB0aGlzLmJsZW5kRXF1YXRpb247XG5cdFx0aWYgKCB0aGlzLmJsZW5kU3JjQWxwaGEgIT09IG51bGwgKSBkYXRhLmJsZW5kU3JjQWxwaGEgPSB0aGlzLmJsZW5kU3JjQWxwaGE7XG5cdFx0aWYgKCB0aGlzLmJsZW5kRHN0QWxwaGEgIT09IG51bGwgKSBkYXRhLmJsZW5kRHN0QWxwaGEgPSB0aGlzLmJsZW5kRHN0QWxwaGE7XG5cdFx0aWYgKCB0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSAhPT0gbnVsbCApIGRhdGEuYmxlbmRFcXVhdGlvbkFscGhhID0gdGhpcy5ibGVuZEVxdWF0aW9uQWxwaGE7XG5cdFx0aWYgKCB0aGlzLmJsZW5kQ29sb3IgJiYgdGhpcy5ibGVuZENvbG9yLmlzQ29sb3IgKSBkYXRhLmJsZW5kQ29sb3IgPSB0aGlzLmJsZW5kQ29sb3IuZ2V0SGV4KCk7XG5cdFx0aWYgKCB0aGlzLmJsZW5kQWxwaGEgIT09IDAgKSBkYXRhLmJsZW5kQWxwaGEgPSB0aGlzLmJsZW5kQWxwaGE7XG5cblx0XHRpZiAoIHRoaXMuZGVwdGhGdW5jICE9PSBMZXNzRXF1YWxEZXB0aCApIGRhdGEuZGVwdGhGdW5jID0gdGhpcy5kZXB0aEZ1bmM7XG5cdFx0aWYgKCB0aGlzLmRlcHRoVGVzdCA9PT0gZmFsc2UgKSBkYXRhLmRlcHRoVGVzdCA9IHRoaXMuZGVwdGhUZXN0O1xuXHRcdGlmICggdGhpcy5kZXB0aFdyaXRlID09PSBmYWxzZSApIGRhdGEuZGVwdGhXcml0ZSA9IHRoaXMuZGVwdGhXcml0ZTtcblx0XHRpZiAoIHRoaXMuY29sb3JXcml0ZSA9PT0gZmFsc2UgKSBkYXRhLmNvbG9yV3JpdGUgPSB0aGlzLmNvbG9yV3JpdGU7XG5cblx0XHRpZiAoIHRoaXMuc3RlbmNpbFdyaXRlTWFzayAhPT0gMHhmZiApIGRhdGEuc3RlbmNpbFdyaXRlTWFzayA9IHRoaXMuc3RlbmNpbFdyaXRlTWFzaztcblx0XHRpZiAoIHRoaXMuc3RlbmNpbEZ1bmMgIT09IEFsd2F5c1N0ZW5jaWxGdW5jICkgZGF0YS5zdGVuY2lsRnVuYyA9IHRoaXMuc3RlbmNpbEZ1bmM7XG5cdFx0aWYgKCB0aGlzLnN0ZW5jaWxSZWYgIT09IDAgKSBkYXRhLnN0ZW5jaWxSZWYgPSB0aGlzLnN0ZW5jaWxSZWY7XG5cdFx0aWYgKCB0aGlzLnN0ZW5jaWxGdW5jTWFzayAhPT0gMHhmZiApIGRhdGEuc3RlbmNpbEZ1bmNNYXNrID0gdGhpcy5zdGVuY2lsRnVuY01hc2s7XG5cdFx0aWYgKCB0aGlzLnN0ZW5jaWxGYWlsICE9PSBLZWVwU3RlbmNpbE9wICkgZGF0YS5zdGVuY2lsRmFpbCA9IHRoaXMuc3RlbmNpbEZhaWw7XG5cdFx0aWYgKCB0aGlzLnN0ZW5jaWxaRmFpbCAhPT0gS2VlcFN0ZW5jaWxPcCApIGRhdGEuc3RlbmNpbFpGYWlsID0gdGhpcy5zdGVuY2lsWkZhaWw7XG5cdFx0aWYgKCB0aGlzLnN0ZW5jaWxaUGFzcyAhPT0gS2VlcFN0ZW5jaWxPcCApIGRhdGEuc3RlbmNpbFpQYXNzID0gdGhpcy5zdGVuY2lsWlBhc3M7XG5cdFx0aWYgKCB0aGlzLnN0ZW5jaWxXcml0ZSA9PT0gdHJ1ZSApIGRhdGEuc3RlbmNpbFdyaXRlID0gdGhpcy5zdGVuY2lsV3JpdGU7XG5cblx0XHQvLyByb3RhdGlvbiAoU3ByaXRlTWF0ZXJpYWwpXG5cdFx0aWYgKCB0aGlzLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yb3RhdGlvbiAhPT0gMCApIGRhdGEucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuXG5cdFx0aWYgKCB0aGlzLnBvbHlnb25PZmZzZXQgPT09IHRydWUgKSBkYXRhLnBvbHlnb25PZmZzZXQgPSB0cnVlO1xuXHRcdGlmICggdGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yICE9PSAwICkgZGF0YS5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gdGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yO1xuXHRcdGlmICggdGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgIT09IDAgKSBkYXRhLnBvbHlnb25PZmZzZXRVbml0cyA9IHRoaXMucG9seWdvbk9mZnNldFVuaXRzO1xuXG5cdFx0aWYgKCB0aGlzLmxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubGluZXdpZHRoICE9PSAxICkgZGF0YS5saW5ld2lkdGggPSB0aGlzLmxpbmV3aWR0aDtcblx0XHRpZiAoIHRoaXMuZGFzaFNpemUgIT09IHVuZGVmaW5lZCApIGRhdGEuZGFzaFNpemUgPSB0aGlzLmRhc2hTaXplO1xuXHRcdGlmICggdGhpcy5nYXBTaXplICE9PSB1bmRlZmluZWQgKSBkYXRhLmdhcFNpemUgPSB0aGlzLmdhcFNpemU7XG5cdFx0aWYgKCB0aGlzLnNjYWxlICE9PSB1bmRlZmluZWQgKSBkYXRhLnNjYWxlID0gdGhpcy5zY2FsZTtcblxuXHRcdGlmICggdGhpcy5kaXRoZXJpbmcgPT09IHRydWUgKSBkYXRhLmRpdGhlcmluZyA9IHRydWU7XG5cblx0XHRpZiAoIHRoaXMuYWxwaGFUZXN0ID4gMCApIGRhdGEuYWxwaGFUZXN0ID0gdGhpcy5hbHBoYVRlc3Q7XG5cdFx0aWYgKCB0aGlzLmFscGhhSGFzaCA9PT0gdHJ1ZSApIGRhdGEuYWxwaGFIYXNoID0gdHJ1ZTtcblx0XHRpZiAoIHRoaXMuYWxwaGFUb0NvdmVyYWdlID09PSB0cnVlICkgZGF0YS5hbHBoYVRvQ292ZXJhZ2UgPSB0cnVlO1xuXHRcdGlmICggdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEgPT09IHRydWUgKSBkYXRhLnByZW11bHRpcGxpZWRBbHBoYSA9IHRydWU7XG5cdFx0aWYgKCB0aGlzLmZvcmNlU2luZ2xlUGFzcyA9PT0gdHJ1ZSApIGRhdGEuZm9yY2VTaW5nbGVQYXNzID0gdHJ1ZTtcblxuXHRcdGlmICggdGhpcy53aXJlZnJhbWUgPT09IHRydWUgKSBkYXRhLndpcmVmcmFtZSA9IHRydWU7XG5cdFx0aWYgKCB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA+IDEgKSBkYXRhLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdGlmICggdGhpcy53aXJlZnJhbWVMaW5lY2FwICE9PSAncm91bmQnICkgZGF0YS53aXJlZnJhbWVMaW5lY2FwID0gdGhpcy53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdGlmICggdGhpcy53aXJlZnJhbWVMaW5lam9pbiAhPT0gJ3JvdW5kJyApIGRhdGEud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVqb2luO1xuXG5cdFx0aWYgKCB0aGlzLmZsYXRTaGFkaW5nID09PSB0cnVlICkgZGF0YS5mbGF0U2hhZGluZyA9IHRydWU7XG5cblx0XHRpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSBkYXRhLnZpc2libGUgPSBmYWxzZTtcblxuXHRcdGlmICggdGhpcy50b25lTWFwcGVkID09PSBmYWxzZSApIGRhdGEudG9uZU1hcHBlZCA9IGZhbHNlO1xuXG5cdFx0aWYgKCB0aGlzLmZvZyA9PT0gZmFsc2UgKSBkYXRhLmZvZyA9IGZhbHNlO1xuXG5cdFx0aWYgKCBPYmplY3Qua2V5cyggdGhpcy51c2VyRGF0YSApLmxlbmd0aCA+IDAgKSBkYXRhLnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcblxuXHRcdC8vIFRPRE86IENvcGllZCBmcm9tIE9iamVjdDNELnRvSlNPTlxuXG5cdFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZSggY2FjaGUgKSB7XG5cblx0XHRcdGNvbnN0IHZhbHVlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gY2FjaGUgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9IGNhY2hlWyBrZXkgXTtcblx0XHRcdFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XG5cdFx0XHRcdHZhbHVlcy5wdXNoKCBkYXRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlcztcblxuXHRcdH1cblxuXHRcdGlmICggaXNSb290T2JqZWN0ICkge1xuXG5cdFx0XHRjb25zdCB0ZXh0dXJlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEudGV4dHVyZXMgKTtcblx0XHRcdGNvbnN0IGltYWdlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuaW1hZ2VzICk7XG5cblx0XHRcdGlmICggdGV4dHVyZXMubGVuZ3RoID4gMCApIGRhdGEudGV4dHVyZXMgPSB0ZXh0dXJlcztcblx0XHRcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBkYXRhLmltYWdlcyA9IGltYWdlcztcblxuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG5cblx0XHR0aGlzLmJsZW5kaW5nID0gc291cmNlLmJsZW5kaW5nO1xuXHRcdHRoaXMuc2lkZSA9IHNvdXJjZS5zaWRlO1xuXHRcdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcblxuXHRcdHRoaXMub3BhY2l0eSA9IHNvdXJjZS5vcGFjaXR5O1xuXHRcdHRoaXMudHJhbnNwYXJlbnQgPSBzb3VyY2UudHJhbnNwYXJlbnQ7XG5cblx0XHR0aGlzLmJsZW5kU3JjID0gc291cmNlLmJsZW5kU3JjO1xuXHRcdHRoaXMuYmxlbmREc3QgPSBzb3VyY2UuYmxlbmREc3Q7XG5cdFx0dGhpcy5ibGVuZEVxdWF0aW9uID0gc291cmNlLmJsZW5kRXF1YXRpb247XG5cdFx0dGhpcy5ibGVuZFNyY0FscGhhID0gc291cmNlLmJsZW5kU3JjQWxwaGE7XG5cdFx0dGhpcy5ibGVuZERzdEFscGhhID0gc291cmNlLmJsZW5kRHN0QWxwaGE7XG5cdFx0dGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEgPSBzb3VyY2UuYmxlbmRFcXVhdGlvbkFscGhhO1xuXHRcdHRoaXMuYmxlbmRDb2xvci5jb3B5KCBzb3VyY2UuYmxlbmRDb2xvciApO1xuXHRcdHRoaXMuYmxlbmRBbHBoYSA9IHNvdXJjZS5ibGVuZEFscGhhO1xuXG5cdFx0dGhpcy5kZXB0aEZ1bmMgPSBzb3VyY2UuZGVwdGhGdW5jO1xuXHRcdHRoaXMuZGVwdGhUZXN0ID0gc291cmNlLmRlcHRoVGVzdDtcblx0XHR0aGlzLmRlcHRoV3JpdGUgPSBzb3VyY2UuZGVwdGhXcml0ZTtcblxuXHRcdHRoaXMuc3RlbmNpbFdyaXRlTWFzayA9IHNvdXJjZS5zdGVuY2lsV3JpdGVNYXNrO1xuXHRcdHRoaXMuc3RlbmNpbEZ1bmMgPSBzb3VyY2Uuc3RlbmNpbEZ1bmM7XG5cdFx0dGhpcy5zdGVuY2lsUmVmID0gc291cmNlLnN0ZW5jaWxSZWY7XG5cdFx0dGhpcy5zdGVuY2lsRnVuY01hc2sgPSBzb3VyY2Uuc3RlbmNpbEZ1bmNNYXNrO1xuXHRcdHRoaXMuc3RlbmNpbEZhaWwgPSBzb3VyY2Uuc3RlbmNpbEZhaWw7XG5cdFx0dGhpcy5zdGVuY2lsWkZhaWwgPSBzb3VyY2Uuc3RlbmNpbFpGYWlsO1xuXHRcdHRoaXMuc3RlbmNpbFpQYXNzID0gc291cmNlLnN0ZW5jaWxaUGFzcztcblx0XHR0aGlzLnN0ZW5jaWxXcml0ZSA9IHNvdXJjZS5zdGVuY2lsV3JpdGU7XG5cblx0XHRjb25zdCBzcmNQbGFuZXMgPSBzb3VyY2UuY2xpcHBpbmdQbGFuZXM7XG5cdFx0bGV0IGRzdFBsYW5lcyA9IG51bGw7XG5cblx0XHRpZiAoIHNyY1BsYW5lcyAhPT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgbiA9IHNyY1BsYW5lcy5sZW5ndGg7XG5cdFx0XHRkc3RQbGFuZXMgPSBuZXcgQXJyYXkoIG4gKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRcdGRzdFBsYW5lc1sgaSBdID0gc3JjUGxhbmVzWyBpIF0uY2xvbmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5jbGlwcGluZ1BsYW5lcyA9IGRzdFBsYW5lcztcblx0XHR0aGlzLmNsaXBJbnRlcnNlY3Rpb24gPSBzb3VyY2UuY2xpcEludGVyc2VjdGlvbjtcblx0XHR0aGlzLmNsaXBTaGFkb3dzID0gc291cmNlLmNsaXBTaGFkb3dzO1xuXG5cdFx0dGhpcy5zaGFkb3dTaWRlID0gc291cmNlLnNoYWRvd1NpZGU7XG5cblx0XHR0aGlzLmNvbG9yV3JpdGUgPSBzb3VyY2UuY29sb3JXcml0ZTtcblxuXHRcdHRoaXMucHJlY2lzaW9uID0gc291cmNlLnByZWNpc2lvbjtcblxuXHRcdHRoaXMucG9seWdvbk9mZnNldCA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0O1xuXHRcdHRoaXMucG9seWdvbk9mZnNldEZhY3RvciA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0RmFjdG9yO1xuXHRcdHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gc291cmNlLnBvbHlnb25PZmZzZXRVbml0cztcblxuXHRcdHRoaXMuZGl0aGVyaW5nID0gc291cmNlLmRpdGhlcmluZztcblxuXHRcdHRoaXMuYWxwaGFUZXN0ID0gc291cmNlLmFscGhhVGVzdDtcblx0XHR0aGlzLmFscGhhSGFzaCA9IHNvdXJjZS5hbHBoYUhhc2g7XG5cdFx0dGhpcy5hbHBoYVRvQ292ZXJhZ2UgPSBzb3VyY2UuYWxwaGFUb0NvdmVyYWdlO1xuXHRcdHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gc291cmNlLnByZW11bHRpcGxpZWRBbHBoYTtcblx0XHR0aGlzLmZvcmNlU2luZ2xlUGFzcyA9IHNvdXJjZS5mb3JjZVNpbmdsZVBhc3M7XG5cblx0XHR0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcblxuXHRcdHRoaXMudG9uZU1hcHBlZCA9IHNvdXJjZS50b25lTWFwcGVkO1xuXG5cdFx0dGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBzb3VyY2UudXNlckRhdGEgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cblx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XG5cblx0fVxuXG5cdG9uQnVpbGQoIC8qIHNoYWRlcm9iamVjdCwgcmVuZGVyZXIgKi8gKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdNYXRlcmlhbDogb25CdWlsZCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApOyAvLyBAZGVwcmVjYXRlZCwgcjE2NlxuXG5cdH1cblxufVxuXG5jbGFzcyBNZXNoQmFzaWNNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzTWVzaEJhc2ljTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ01lc2hCYXNpY01hdGVyaWFsJztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGVtaXNzaXZlXG5cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0dGhpcy5hb01hcCA9IG51bGw7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdFx0dGhpcy5lbnZNYXBSb3RhdGlvbiA9IG5ldyBFdWxlcigpO1xuXHRcdHRoaXMuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xuXHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cblx0XHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG5cdFx0dGhpcy5lbnZNYXBSb3RhdGlvbi5jb3B5KCBzb3VyY2UuZW52TWFwUm90YXRpb24gKTtcblx0XHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbi8vIEZhc3QgSGFsZiBGbG9hdCBDb252ZXJzaW9ucywgaHR0cDovL3d3dy5mb3gtdG9vbGtpdC5vcmcvZnRwL2Zhc3RoYWxmZmxvYXRjb252ZXJzaW9uLnBkZlxuXG5jb25zdCBfdGFibGVzID0gLypAX19QVVJFX18qLyBfZ2VuZXJhdGVUYWJsZXMoKTtcblxuZnVuY3Rpb24gX2dlbmVyYXRlVGFibGVzKCkge1xuXG5cdC8vIGZsb2F0MzIgdG8gZmxvYXQxNiBoZWxwZXJzXG5cblx0Y29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKCA0ICk7XG5cdGNvbnN0IGZsb2F0VmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoIGJ1ZmZlciApO1xuXHRjb25zdCB1aW50MzJWaWV3ID0gbmV3IFVpbnQzMkFycmF5KCBidWZmZXIgKTtcblxuXHRjb25zdCBiYXNlVGFibGUgPSBuZXcgVWludDMyQXJyYXkoIDUxMiApO1xuXHRjb25zdCBzaGlmdFRhYmxlID0gbmV3IFVpbnQzMkFycmF5KCA1MTIgKTtcblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAyNTY7ICsrIGkgKSB7XG5cblx0XHRjb25zdCBlID0gaSAtIDEyNztcblxuXHRcdC8vIHZlcnkgc21hbGwgbnVtYmVyICgwLCAtMClcblxuXHRcdGlmICggZSA8IC0gMjcgKSB7XG5cblx0XHRcdGJhc2VUYWJsZVsgaSBdID0gMHgwMDAwO1xuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9IDB4ODAwMDtcblx0XHRcdHNoaWZ0VGFibGVbIGkgXSA9IDI0O1xuXHRcdFx0c2hpZnRUYWJsZVsgaSB8IDB4MTAwIF0gPSAyNDtcblxuXHRcdFx0Ly8gc21hbGwgbnVtYmVyIChkZW5vcm0pXG5cblx0XHR9IGVsc2UgaWYgKCBlIDwgLSAxNCApIHtcblxuXHRcdFx0YmFzZVRhYmxlWyBpIF0gPSAweDA0MDAgPj4gKCAtIGUgLSAxNCApO1xuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9ICggMHgwNDAwID4+ICggLSBlIC0gMTQgKSApIHwgMHg4MDAwO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSBdID0gLSBlIC0gMTtcblx0XHRcdHNoaWZ0VGFibGVbIGkgfCAweDEwMCBdID0gLSBlIC0gMTtcblxuXHRcdFx0Ly8gbm9ybWFsIG51bWJlclxuXG5cdFx0fSBlbHNlIGlmICggZSA8PSAxNSApIHtcblxuXHRcdFx0YmFzZVRhYmxlWyBpIF0gPSAoIGUgKyAxNSApIDw8IDEwO1xuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9ICggKCBlICsgMTUgKSA8PCAxMCApIHwgMHg4MDAwO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSBdID0gMTM7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIHwgMHgxMDAgXSA9IDEzO1xuXG5cdFx0XHQvLyBsYXJnZSBudW1iZXIgKEluZmluaXR5LCAtSW5maW5pdHkpXG5cblx0XHR9IGVsc2UgaWYgKCBlIDwgMTI4ICkge1xuXG5cdFx0XHRiYXNlVGFibGVbIGkgXSA9IDB4N2MwMDtcblx0XHRcdGJhc2VUYWJsZVsgaSB8IDB4MTAwIF0gPSAweGZjMDA7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIF0gPSAyNDtcblx0XHRcdHNoaWZ0VGFibGVbIGkgfCAweDEwMCBdID0gMjQ7XG5cblx0XHRcdC8vIHN0YXkgKE5hTiwgSW5maW5pdHksIC1JbmZpbml0eSlcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGJhc2VUYWJsZVsgaSBdID0gMHg3YzAwO1xuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9IDB4ZmMwMDtcblx0XHRcdHNoaWZ0VGFibGVbIGkgXSA9IDEzO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSB8IDB4MTAwIF0gPSAxMztcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gZmxvYXQxNiB0byBmbG9hdDMyIGhlbHBlcnNcblxuXHRjb25zdCBtYW50aXNzYVRhYmxlID0gbmV3IFVpbnQzMkFycmF5KCAyMDQ4ICk7XG5cdGNvbnN0IGV4cG9uZW50VGFibGUgPSBuZXcgVWludDMyQXJyYXkoIDY0ICk7XG5cdGNvbnN0IG9mZnNldFRhYmxlID0gbmV3IFVpbnQzMkFycmF5KCA2NCApO1xuXG5cdGZvciAoIGxldCBpID0gMTsgaSA8IDEwMjQ7ICsrIGkgKSB7XG5cblx0XHRsZXQgbSA9IGkgPDwgMTM7IC8vIHplcm8gcGFkIG1hbnRpc3NhIGJpdHNcblx0XHRsZXQgZSA9IDA7IC8vIHplcm8gZXhwb25lbnRcblxuXHRcdC8vIG5vcm1hbGl6ZWRcblx0XHR3aGlsZSAoICggbSAmIDB4MDA4MDAwMDAgKSA9PT0gMCApIHtcblxuXHRcdFx0bSA8PD0gMTtcblx0XHRcdGUgLT0gMHgwMDgwMDAwMDsgLy8gZGVjcmVtZW50IGV4cG9uZW50XG5cblx0XHR9XG5cblx0XHRtICY9IH4gMHgwMDgwMDAwMDsgLy8gY2xlYXIgbGVhZGluZyAxIGJpdFxuXHRcdGUgKz0gMHgzODgwMDAwMDsgLy8gYWRqdXN0IGJpYXNcblxuXHRcdG1hbnRpc3NhVGFibGVbIGkgXSA9IG0gfCBlO1xuXG5cdH1cblxuXHRmb3IgKCBsZXQgaSA9IDEwMjQ7IGkgPCAyMDQ4OyArKyBpICkge1xuXG5cdFx0bWFudGlzc2FUYWJsZVsgaSBdID0gMHgzODAwMDAwMCArICggKCBpIC0gMTAyNCApIDw8IDEzICk7XG5cblx0fVxuXG5cdGZvciAoIGxldCBpID0gMTsgaSA8IDMxOyArKyBpICkge1xuXG5cdFx0ZXhwb25lbnRUYWJsZVsgaSBdID0gaSA8PCAyMztcblxuXHR9XG5cblx0ZXhwb25lbnRUYWJsZVsgMzEgXSA9IDB4NDc4MDAwMDA7XG5cdGV4cG9uZW50VGFibGVbIDMyIF0gPSAweDgwMDAwMDAwO1xuXG5cdGZvciAoIGxldCBpID0gMzM7IGkgPCA2MzsgKysgaSApIHtcblxuXHRcdGV4cG9uZW50VGFibGVbIGkgXSA9IDB4ODAwMDAwMDAgKyAoICggaSAtIDMyICkgPDwgMjMgKTtcblxuXHR9XG5cblx0ZXhwb25lbnRUYWJsZVsgNjMgXSA9IDB4Yzc4MDAwMDA7XG5cblx0Zm9yICggbGV0IGkgPSAxOyBpIDwgNjQ7ICsrIGkgKSB7XG5cblx0XHRpZiAoIGkgIT09IDMyICkge1xuXG5cdFx0XHRvZmZzZXRUYWJsZVsgaSBdID0gMTAyNDtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRmbG9hdFZpZXc6IGZsb2F0Vmlldyxcblx0XHR1aW50MzJWaWV3OiB1aW50MzJWaWV3LFxuXHRcdGJhc2VUYWJsZTogYmFzZVRhYmxlLFxuXHRcdHNoaWZ0VGFibGU6IHNoaWZ0VGFibGUsXG5cdFx0bWFudGlzc2FUYWJsZTogbWFudGlzc2FUYWJsZSxcblx0XHRleHBvbmVudFRhYmxlOiBleHBvbmVudFRhYmxlLFxuXHRcdG9mZnNldFRhYmxlOiBvZmZzZXRUYWJsZVxuXHR9O1xuXG59XG5cbi8vIGZsb2F0MzIgdG8gZmxvYXQxNlxuXG5mdW5jdGlvbiB0b0hhbGZGbG9hdCggdmFsICkge1xuXG5cdGlmICggTWF0aC5hYnMoIHZhbCApID4gNjU1MDQgKSBjb25zb2xlLndhcm4oICdUSFJFRS5EYXRhVXRpbHMudG9IYWxmRmxvYXQoKTogVmFsdWUgb3V0IG9mIHJhbmdlLicgKTtcblxuXHR2YWwgPSBjbGFtcCggdmFsLCAtIDY1NTA0LCA2NTUwNCApO1xuXG5cdF90YWJsZXMuZmxvYXRWaWV3WyAwIF0gPSB2YWw7XG5cdGNvbnN0IGYgPSBfdGFibGVzLnVpbnQzMlZpZXdbIDAgXTtcblx0Y29uc3QgZSA9ICggZiA+PiAyMyApICYgMHgxZmY7XG5cdHJldHVybiBfdGFibGVzLmJhc2VUYWJsZVsgZSBdICsgKCAoIGYgJiAweDAwN2ZmZmZmICkgPj4gX3RhYmxlcy5zaGlmdFRhYmxlWyBlIF0gKTtcblxufVxuXG4vLyBmbG9hdDE2IHRvIGZsb2F0MzJcblxuZnVuY3Rpb24gZnJvbUhhbGZGbG9hdCggdmFsICkge1xuXG5cdGNvbnN0IG0gPSB2YWwgPj4gMTA7XG5cdF90YWJsZXMudWludDMyVmlld1sgMCBdID0gX3RhYmxlcy5tYW50aXNzYVRhYmxlWyBfdGFibGVzLm9mZnNldFRhYmxlWyBtIF0gKyAoIHZhbCAmIDB4M2ZmICkgXSArIF90YWJsZXMuZXhwb25lbnRUYWJsZVsgbSBdO1xuXHRyZXR1cm4gX3RhYmxlcy5mbG9hdFZpZXdbIDAgXTtcblxufVxuXG5jb25zdCBEYXRhVXRpbHMgPSB7XG5cdHRvSGFsZkZsb2F0OiB0b0hhbGZGbG9hdCxcblx0ZnJvbUhhbGZGbG9hdDogZnJvbUhhbGZGbG9hdCxcbn07XG5cbmNvbnN0IF92ZWN0b3IkOSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92ZWN0b3IyJDEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XG5cbmNsYXNzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCA9IGZhbHNlICkge1xuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBhcnJheSApICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlOiBhcnJheSBzaG91bGQgYmUgYSBUeXBlZCBBcnJheS4nICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmlzQnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcblxuXHRcdHRoaXMubmFtZSA9ICcnO1xuXG5cdFx0dGhpcy5hcnJheSA9IGFycmF5O1xuXHRcdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblx0XHR0aGlzLmNvdW50ID0gYXJyYXkgIT09IHVuZGVmaW5lZCA/IGFycmF5Lmxlbmd0aCAvIGl0ZW1TaXplIDogMDtcblx0XHR0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkO1xuXG5cdFx0dGhpcy51c2FnZSA9IFN0YXRpY0RyYXdVc2FnZTtcblx0XHR0aGlzLnVwZGF0ZVJhbmdlcyA9IFtdO1xuXHRcdHRoaXMuZ3B1VHlwZSA9IEZsb2F0VHlwZTtcblxuXHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cblx0fVxuXG5cdG9uVXBsb2FkQ2FsbGJhY2soKSB7fVxuXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xuXG5cdH1cblxuXHRzZXRVc2FnZSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnVzYWdlID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkVXBkYXRlUmFuZ2UoIHN0YXJ0LCBjb3VudCApIHtcblxuXHRcdHRoaXMudXBkYXRlUmFuZ2VzLnB1c2goIHsgc3RhcnQsIGNvdW50IH0gKTtcblxuXHR9XG5cblx0Y2xlYXJVcGRhdGVSYW5nZXMoKSB7XG5cblx0XHR0aGlzLnVwZGF0ZVJhbmdlcy5sZW5ndGggPSAwO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblx0XHR0aGlzLmFycmF5ID0gbmV3IHNvdXJjZS5hcnJheS5jb25zdHJ1Y3Rvciggc291cmNlLmFycmF5ICk7XG5cdFx0dGhpcy5pdGVtU2l6ZSA9IHNvdXJjZS5pdGVtU2l6ZTtcblx0XHR0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xuXHRcdHRoaXMubm9ybWFsaXplZCA9IHNvdXJjZS5ub3JtYWxpemVkO1xuXG5cdFx0dGhpcy51c2FnZSA9IHNvdXJjZS51c2FnZTtcblx0XHR0aGlzLmdwdVR5cGUgPSBzb3VyY2UuZ3B1VHlwZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb3B5QXQoIGluZGV4MSwgYXR0cmlidXRlLCBpbmRleDIgKSB7XG5cblx0XHRpbmRleDEgKj0gdGhpcy5pdGVtU2l6ZTtcblx0XHRpbmRleDIgKj0gYXR0cmlidXRlLml0ZW1TaXplO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5pdGVtU2l6ZTsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4MSArIGkgXSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXgyICsgaSBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHlBcnJheSggYXJyYXkgKSB7XG5cblx0XHR0aGlzLmFycmF5LnNldCggYXJyYXkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDMoIG0gKSB7XG5cblx0XHRpZiAoIHRoaXMuaXRlbVNpemUgPT09IDIgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdF92ZWN0b3IyJDEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xuXHRcdFx0XHRfdmVjdG9yMiQxLmFwcGx5TWF0cml4MyggbSApO1xuXG5cdFx0XHRcdHRoaXMuc2V0WFkoIGksIF92ZWN0b3IyJDEueCwgX3ZlY3RvcjIkMS55ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaXRlbVNpemUgPT09IDMgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdF92ZWN0b3IkOS5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XG5cdFx0XHRcdF92ZWN0b3IkOS5hcHBseU1hdHJpeDMoIG0gKTtcblxuXHRcdFx0XHR0aGlzLnNldFhZWiggaSwgX3ZlY3RvciQ5LngsIF92ZWN0b3IkOS55LCBfdmVjdG9yJDkueiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlNYXRyaXg0KCBtICkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdF92ZWN0b3IkOS5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XG5cblx0XHRcdF92ZWN0b3IkOS5hcHBseU1hdHJpeDQoIG0gKTtcblxuXHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IkOS54LCBfdmVjdG9yJDkueSwgX3ZlY3RvciQ5LnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU5vcm1hbE1hdHJpeCggbSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRfdmVjdG9yJDkuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xuXG5cdFx0XHRfdmVjdG9yJDkuYXBwbHlOb3JtYWxNYXRyaXgoIG0gKTtcblxuXHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IkOS54LCBfdmVjdG9yJDkueSwgX3ZlY3RvciQ5LnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2Zvcm1EaXJlY3Rpb24oIG0gKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0X3ZlY3RvciQ5LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHRoaXMsIGkgKTtcblxuXHRcdFx0X3ZlY3RvciQ5LnRyYW5zZm9ybURpcmVjdGlvbiggbSApO1xuXG5cdFx0XHR0aGlzLnNldFhZWiggaSwgX3ZlY3RvciQ5LngsIF92ZWN0b3IkOS55LCBfdmVjdG9yJDkueiApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldCggdmFsdWUsIG9mZnNldCA9IDAgKSB7XG5cblx0XHQvLyBNYXRjaGluZyBCdWZmZXJBdHRyaWJ1dGUgY29uc3RydWN0b3IsIGRvIG5vdCBub3JtYWxpemUgdGhlIGFycmF5LlxuXHRcdHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Q29tcG9uZW50KCBpbmRleCwgY29tcG9uZW50ICkge1xuXG5cdFx0bGV0IHZhbHVlID0gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgY29tcG9uZW50IF07XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHZhbHVlID0gZGVub3JtYWxpemUoIHZhbHVlLCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cblx0fVxuXG5cdHNldENvbXBvbmVudCggaW5kZXgsIGNvbXBvbmVudCwgdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHZhbHVlID0gbm9ybWFsaXplKCB2YWx1ZSwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgY29tcG9uZW50IF0gPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRYKCBpbmRleCApIHtcblxuXHRcdGxldCB4ID0gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF07XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHggPSBkZW5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHg7XG5cblx0fVxuXG5cdHNldFgoIGluZGV4LCB4ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXSA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0WSggaW5kZXggKSB7XG5cblx0XHRsZXQgeSA9IHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeSA9IGRlbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4geTtcblxuXHR9XG5cblx0c2V0WSggaW5kZXgsIHkgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0WiggaW5kZXggKSB7XG5cblx0XHRsZXQgeiA9IHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeiA9IGRlbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4gejtcblxuXHR9XG5cblx0c2V0WiggaW5kZXgsIHogKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHogPSBub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXSA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0VyggaW5kZXggKSB7XG5cblx0XHRsZXQgdyA9IHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdyA9IGRlbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4gdztcblxuXHR9XG5cblx0c2V0VyggaW5kZXgsIHcgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHcgPSBub3JtYWxpemUoIHcsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXSA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WFkoIGluZGV4LCB4LCB5ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFhZWiggaW5kZXgsIHgsIHksIHogKSB7XG5cblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblx0XHRcdHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblx0XHRcdHogPSBub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFhZWlcoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR3ID0gbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0b25VcGxvYWQoIGNhbGxiYWNrICkge1xuXG5cdFx0dGhpcy5vblVwbG9hZENhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuYXJyYXksIHRoaXMuaXRlbVNpemUgKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRpdGVtU2l6ZTogdGhpcy5pdGVtU2l6ZSxcblx0XHRcdHR5cGU6IHRoaXMuYXJyYXkuY29uc3RydWN0b3IubmFtZSxcblx0XHRcdGFycmF5OiBBcnJheS5mcm9tKCB0aGlzLmFycmF5ICksXG5cdFx0XHRub3JtYWxpemVkOiB0aGlzLm5vcm1hbGl6ZWRcblx0XHR9O1xuXG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXHRcdGlmICggdGhpcy51c2FnZSAhPT0gU3RhdGljRHJhd1VzYWdlICkgZGF0YS51c2FnZSA9IHRoaXMudXNhZ2U7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cbn1cblxuLy9cblxuY2xhc3MgSW50OEJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgSW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBVaW50OEJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgVWludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBVaW50OENsYW1wZWRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgSW50MTZCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRzdXBlciggbmV3IEludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgVWludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIEludDMyQnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBJbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRzdXBlciggbmV3IFVpbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBGbG9hdDE2QnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBVaW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHRcdHRoaXMuaXNGbG9hdDE2QnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0Z2V0WCggaW5kZXggKSB7XG5cblx0XHRsZXQgeCA9IGZyb21IYWxmRmxvYXQoIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdICk7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHggPSBkZW5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHg7XG5cblx0fVxuXG5cdHNldFgoIGluZGV4LCB4ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXSA9IHRvSGFsZkZsb2F0KCB4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0WSggaW5kZXggKSB7XG5cblx0XHRsZXQgeSA9IGZyb21IYWxmRmxvYXQoIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXSApO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB5ID0gZGVub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB5O1xuXG5cdH1cblxuXHRzZXRZKCBpbmRleCwgeSApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdID0gdG9IYWxmRmxvYXQoIHkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRaKCBpbmRleCApIHtcblxuXHRcdGxldCB6ID0gZnJvbUhhbGZGbG9hdCggdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdICk7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHogPSBkZW5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHo7XG5cblx0fVxuXG5cdHNldFooIGluZGV4LCB6ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF0gPSB0b0hhbGZGbG9hdCggeiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldFcoIGluZGV4ICkge1xuXG5cdFx0bGV0IHcgPSBmcm9tSGFsZkZsb2F0KCB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF0gKTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdyA9IGRlbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4gdztcblxuXHR9XG5cblx0c2V0VyggaW5kZXgsIHcgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHcgPSBub3JtYWxpemUoIHcsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXSA9IHRvSGFsZkZsb2F0KCB3ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WFkoIGluZGV4LCB4LCB5ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHRvSGFsZkZsb2F0KCB4ICk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB0b0hhbGZGbG9hdCggeSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFhZWiggaW5kZXgsIHgsIHksIHogKSB7XG5cblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblx0XHRcdHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblx0XHRcdHogPSBub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0gdG9IYWxmRmxvYXQoIHggKTtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHRvSGFsZkZsb2F0KCB5ICk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB0b0hhbGZGbG9hdCggeiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFhZWlcoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR3ID0gbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHRvSGFsZkZsb2F0KCB4ICk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB0b0hhbGZGbG9hdCggeSApO1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gdG9IYWxmRmxvYXQoIHogKTtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDMgXSA9IHRvSGFsZkZsb2F0KCB3ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuXG5jbGFzcyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBGbG9hdDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbmxldCBfaWQkMSA9IDA7XG5cbmNvbnN0IF9tMSA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9vYmogPSAvKkBfX1BVUkVfXyovIG5ldyBPYmplY3QzRCgpO1xuY29uc3QgX29mZnNldCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9ib3gkMiA9IC8qQF9fUFVSRV9fKi8gbmV3IEJveDMoKTtcbmNvbnN0IF9ib3hNb3JwaFRhcmdldHMgPSAvKkBfX1BVUkVfXyovIG5ldyBCb3gzKCk7XG5jb25zdCBfdmVjdG9yJDggPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNsYXNzIEJ1ZmZlckdlb21ldHJ5IGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzQnVmZmVyR2VvbWV0cnkgPSB0cnVlO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBfaWQkMSArKyB9ICk7XG5cblx0XHR0aGlzLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblxuXHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XG5cblx0XHR0aGlzLmluZGV4ID0gbnVsbDtcblx0XHR0aGlzLmluZGlyZWN0ID0gbnVsbDtcblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcblxuXHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XG5cdFx0dGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5ncm91cHMgPSBbXTtcblxuXHRcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG5cdFx0dGhpcy5kcmF3UmFuZ2UgPSB7IHN0YXJ0OiAwLCBjb3VudDogSW5maW5pdHkgfTtcblxuXHRcdHRoaXMudXNlckRhdGEgPSB7fTtcblxuXHR9XG5cblx0Z2V0SW5kZXgoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5pbmRleDtcblxuXHR9XG5cblx0c2V0SW5kZXgoIGluZGV4ICkge1xuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBpbmRleCApICkge1xuXG5cdFx0XHR0aGlzLmluZGV4ID0gbmV3ICggYXJyYXlOZWVkc1VpbnQzMiggaW5kZXggKSA/IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSA6IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSApKCBpbmRleCwgMSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5pbmRleCA9IGluZGV4O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEluZGlyZWN0KCBpbmRpcmVjdCApIHtcblxuXHRcdHRoaXMuaW5kaXJlY3QgPSBpbmRpcmVjdDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRJbmRpcmVjdCgpIHtcblxuXHRcdHJldHVybiB0aGlzLmluZGlyZWN0O1xuXG5cdH1cblxuXHRnZXRBdHRyaWJ1dGUoIG5hbWUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0fVxuXG5cdHNldEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlICkge1xuXG5cdFx0dGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gPSBhdHRyaWJ1dGU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGVsZXRlQXR0cmlidXRlKCBuYW1lICkge1xuXG5cdFx0ZGVsZXRlIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGhhc0F0dHJpYnV0ZSggbmFtZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXSAhPT0gdW5kZWZpbmVkO1xuXG5cdH1cblxuXHRhZGRHcm91cCggc3RhcnQsIGNvdW50LCBtYXRlcmlhbEluZGV4ID0gMCApIHtcblxuXHRcdHRoaXMuZ3JvdXBzLnB1c2goIHtcblxuXHRcdFx0c3RhcnQ6IHN0YXJ0LFxuXHRcdFx0Y291bnQ6IGNvdW50LFxuXHRcdFx0bWF0ZXJpYWxJbmRleDogbWF0ZXJpYWxJbmRleFxuXG5cdFx0fSApO1xuXG5cdH1cblxuXHRjbGVhckdyb3VwcygpIHtcblxuXHRcdHRoaXMuZ3JvdXBzID0gW107XG5cblx0fVxuXG5cdHNldERyYXdSYW5nZSggc3RhcnQsIGNvdW50ICkge1xuXG5cdFx0dGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBzdGFydDtcblx0XHR0aGlzLmRyYXdSYW5nZS5jb3VudCA9IGNvdW50O1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDQoIG1hdHJpeCApIHtcblxuXHRcdGNvbnN0IHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0aWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwb3NpdGlvbi5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0XHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRjb25zdCBub3JtYWwgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xuXG5cdFx0aWYgKCBub3JtYWwgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3Qgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXG5cdFx0XHRub3JtYWwuYXBwbHlOb3JtYWxNYXRyaXgoIG5vcm1hbE1hdHJpeCApO1xuXG5cdFx0XHRub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdGFuZ2VudCA9IHRoaXMuYXR0cmlidXRlcy50YW5nZW50O1xuXG5cdFx0aWYgKCB0YW5nZW50ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRhbmdlbnQudHJhbnNmb3JtRGlyZWN0aW9uKCBtYXRyaXggKTtcblxuXHRcdFx0dGFuZ2VudC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlRdWF0ZXJuaW9uKCBxICkge1xuXG5cdFx0X20xLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XG5cblx0XHR0aGlzLmFwcGx5TWF0cml4NCggX20xICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm90YXRlWCggYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHgtYXhpc1xuXG5cdFx0X20xLm1ha2VSb3RhdGlvblgoIGFuZ2xlICk7XG5cblx0XHR0aGlzLmFwcGx5TWF0cml4NCggX20xICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm90YXRlWSggYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xuXG5cdFx0X20xLm1ha2VSb3RhdGlvblkoIGFuZ2xlICk7XG5cblx0XHR0aGlzLmFwcGx5TWF0cml4NCggX20xICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm90YXRlWiggYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHotYXhpc1xuXG5cdFx0X20xLm1ha2VSb3RhdGlvblooIGFuZ2xlICk7XG5cblx0XHR0aGlzLmFwcGx5TWF0cml4NCggX20xICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dHJhbnNsYXRlKCB4LCB5LCB6ICkge1xuXG5cdFx0Ly8gdHJhbnNsYXRlIGdlb21ldHJ5XG5cblx0XHRfbTEubWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICk7XG5cblx0XHR0aGlzLmFwcGx5TWF0cml4NCggX20xICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2NhbGUoIHgsIHksIHogKSB7XG5cblx0XHQvLyBzY2FsZSBnZW9tZXRyeVxuXG5cdFx0X20xLm1ha2VTY2FsZSggeCwgeSwgeiApO1xuXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9tMSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGxvb2tBdCggdmVjdG9yICkge1xuXG5cdFx0X29iai5sb29rQXQoIHZlY3RvciApO1xuXG5cdFx0X29iai51cGRhdGVNYXRyaXgoKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfb2JqLm1hdHJpeCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNlbnRlcigpIHtcblxuXHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHR0aGlzLmJvdW5kaW5nQm94LmdldENlbnRlciggX29mZnNldCApLm5lZ2F0ZSgpO1xuXG5cdFx0dGhpcy50cmFuc2xhdGUoIF9vZmZzZXQueCwgX29mZnNldC55LCBfb2Zmc2V0LnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUG9pbnRzKCBwb2ludHMgKSB7XG5cblx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cblx0XHRpZiAoIHBvc2l0aW9uQXR0cmlidXRlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IHBvc2l0aW9uID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHBvaW50ID0gcG9pbnRzWyBpIF07XG5cdFx0XHRcdHBvc2l0aW9uLnB1c2goIHBvaW50LngsIHBvaW50LnksIHBvaW50LnogfHwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIDMgKSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3QgbCA9IE1hdGgubWluKCBwb2ludHMubGVuZ3RoLCBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCApOyAvLyBtYWtlIHN1cmUgZGF0YSBkbyBub3QgZXhjZWVkIGJ1ZmZlciBzaXplXG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgcG9pbnQgPSBwb2ludHNbIGkgXTtcblx0XHRcdFx0cG9zaXRpb25BdHRyaWJ1dGUuc2V0WFlaKCBpLCBwb2ludC54LCBwb2ludC55LCBwb2ludC56IHx8IDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHBvaW50cy5sZW5ndGggPiBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogQnVmZmVyIHNpemUgdG9vIHNtYWxsIGZvciBwb2ludHMgZGF0YS4gVXNlIC5kaXNwb3NlKCkgYW5kIGNyZWF0ZSBhIG5ldyBnZW9tZXRyeS4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cG9zaXRpb25BdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvbXB1dGVCb3VuZGluZ0JveCgpIHtcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbiA9IHRoaXMubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0aWYgKCBwb3NpdGlvbiAmJiBwb3NpdGlvbi5pc0dMQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk6IEdMQnVmZmVyQXR0cmlidXRlIHJlcXVpcmVzIGEgbWFudWFsIGJvdW5kaW5nIGJveC4nLCB0aGlzICk7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3guc2V0KFxuXHRcdFx0XHRuZXcgVmVjdG9yMyggLSBJbmZpbml0eSwgLSBJbmZpbml0eSwgLSBJbmZpbml0eSApLFxuXHRcdFx0XHRuZXcgVmVjdG9yMyggKyBJbmZpbml0eSwgKyBJbmZpbml0eSwgKyBJbmZpbml0eSApXG5cdFx0XHQpO1xuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24gKTtcblxuXHRcdFx0Ly8gcHJvY2VzcyBtb3JwaCBhdHRyaWJ1dGVzIGlmIHByZXNlbnRcblxuXHRcdFx0aWYgKCBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbiApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24ubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uWyBpIF07XG5cdFx0XHRcdFx0X2JveCQyLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoQXR0cmlidXRlICk7XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgKSB7XG5cblx0XHRcdFx0XHRcdF92ZWN0b3IkOC5hZGRWZWN0b3JzKCB0aGlzLmJvdW5kaW5nQm94Lm1pbiwgX2JveCQyLm1pbiApO1xuXHRcdFx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KCBfdmVjdG9yJDggKTtcblxuXHRcdFx0XHRcdFx0X3ZlY3RvciQ4LmFkZFZlY3RvcnMoIHRoaXMuYm91bmRpbmdCb3gubWF4LCBfYm94JDIubWF4ICk7XG5cdFx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IkOCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KCBfYm94JDIubWluICk7XG5cdFx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoIF9ib3gkMi5tYXggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3gubWFrZUVtcHR5KCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi54ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnkgKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueiApICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlKCkge1xuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gPSB0aGlzLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdGlmICggcG9zaXRpb24gJiYgcG9zaXRpb24uaXNHTEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBHTEJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBhIG1hbnVhbCBib3VuZGluZyBzcGhlcmUuJywgdGhpcyApO1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnNldCggbmV3IFZlY3RvcjMoKSwgSW5maW5pdHkgKTtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwb3NpdGlvbiApIHtcblxuXHRcdFx0Ly8gZmlyc3QsIGZpbmQgdGhlIGNlbnRlciBvZiB0aGUgYm91bmRpbmcgc3BoZXJlXG5cblx0XHRcdGNvbnN0IGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xuXG5cdFx0XHRfYm94JDIuc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24gKTtcblxuXHRcdFx0Ly8gcHJvY2VzcyBtb3JwaCBhdHRyaWJ1dGVzIGlmIHByZXNlbnRcblxuXHRcdFx0aWYgKCBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbiApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24ubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uWyBpIF07XG5cdFx0XHRcdFx0X2JveE1vcnBoVGFyZ2V0cy5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBtb3JwaEF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdFx0aWYgKCB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlICkge1xuXG5cdFx0XHRcdFx0XHRfdmVjdG9yJDguYWRkVmVjdG9ycyggX2JveCQyLm1pbiwgX2JveE1vcnBoVGFyZ2V0cy5taW4gKTtcblx0XHRcdFx0XHRcdF9ib3gkMi5leHBhbmRCeVBvaW50KCBfdmVjdG9yJDggKTtcblxuXHRcdFx0XHRcdFx0X3ZlY3RvciQ4LmFkZFZlY3RvcnMoIF9ib3gkMi5tYXgsIF9ib3hNb3JwaFRhcmdldHMubWF4ICk7XG5cdFx0XHRcdFx0XHRfYm94JDIuZXhwYW5kQnlQb2ludCggX3ZlY3RvciQ4ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRfYm94JDIuZXhwYW5kQnlQb2ludCggX2JveE1vcnBoVGFyZ2V0cy5taW4gKTtcblx0XHRcdFx0XHRcdF9ib3gkMi5leHBhbmRCeVBvaW50KCBfYm94TW9ycGhUYXJnZXRzLm1heCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRfYm94JDIuZ2V0Q2VudGVyKCBjZW50ZXIgKTtcblxuXHRcdFx0Ly8gc2Vjb25kLCB0cnkgdG8gZmluZCBhIGJvdW5kaW5nU3BoZXJlIHdpdGggYSByYWRpdXMgc21hbGxlciB0aGFuIHRoZVxuXHRcdFx0Ly8gYm91bmRpbmdTcGhlcmUgb2YgdGhlIGJvdW5kaW5nQm94OiBzcXJ0KDMpIHNtYWxsZXIgaW4gdGhlIGJlc3QgY2FzZVxuXG5cdFx0XHRsZXQgbWF4UmFkaXVzU3EgPSAwO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gcG9zaXRpb24uY291bnQ7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRfdmVjdG9yJDguZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGkgKTtcblxuXHRcdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBfdmVjdG9yJDggKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2Nlc3MgbW9ycGggYXR0cmlidXRlcyBpZiBwcmVzZW50XG5cblx0XHRcdGlmICggbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvblsgaSBdO1xuXHRcdFx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBtb3JwaEF0dHJpYnV0ZS5jb3VudDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRfdmVjdG9yJDguZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhBdHRyaWJ1dGUsIGogKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBtb3JwaFRhcmdldHNSZWxhdGl2ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRfb2Zmc2V0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBqICk7XG5cdFx0XHRcdFx0XHRcdF92ZWN0b3IkOC5hZGQoIF9vZmZzZXQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBfdmVjdG9yJDggKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuXHRcdFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgKSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IENvbXB1dGVkIHJhZGl1cyBpcyBOYU4uIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbXB1dGVUYW5nZW50cygpIHtcblxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy50ZXJhdGhvbi5jb20vY29kZS90YW5nZW50Lmh0bWxcblx0XHQvLyAocGVyIHZlcnRleCB0YW5nZW50cylcblxuXHRcdGlmICggaW5kZXggPT09IG51bGwgfHxcblx0XHRcdCBhdHRyaWJ1dGVzLnBvc2l0aW9uID09PSB1bmRlZmluZWQgfHxcblx0XHRcdCBhdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHQgYXR0cmlidXRlcy51diA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBmYWlsZWQuIE1pc3NpbmcgcmVxdWlyZWQgYXR0cmlidXRlcyAoaW5kZXgsIHBvc2l0aW9uLCBub3JtYWwgb3IgdXYpJyApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGNvbnN0IG5vcm1hbEF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMubm9ybWFsO1xuXHRcdGNvbnN0IHV2QXR0cmlidXRlID0gYXR0cmlidXRlcy51djtcblxuXHRcdGlmICggdGhpcy5oYXNBdHRyaWJ1dGUoICd0YW5nZW50JyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd0YW5nZW50JywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggNCAqIHBvc2l0aW9uQXR0cmlidXRlLmNvdW50ICksIDQgKSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdGFuZ2VudEF0dHJpYnV0ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCAndGFuZ2VudCcgKTtcblxuXHRcdGNvbnN0IHRhbjEgPSBbXSwgdGFuMiA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcG9zaXRpb25BdHRyaWJ1dGUuY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdHRhbjFbIGkgXSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR0YW4yWyBpIF0gPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdkEgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0dkIgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0dkMgPSBuZXcgVmVjdG9yMygpLFxuXG5cdFx0XHR1dkEgPSBuZXcgVmVjdG9yMigpLFxuXHRcdFx0dXZCID0gbmV3IFZlY3RvcjIoKSxcblx0XHRcdHV2QyA9IG5ldyBWZWN0b3IyKCksXG5cblx0XHRcdHNkaXIgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0dGRpciA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUcmlhbmdsZSggYSwgYiwgYyApIHtcblxuXHRcdFx0dkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGEgKTtcblx0XHRcdHZCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBiICk7XG5cdFx0XHR2Qy5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgYyApO1xuXG5cdFx0XHR1dkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXZBdHRyaWJ1dGUsIGEgKTtcblx0XHRcdHV2Qi5mcm9tQnVmZmVyQXR0cmlidXRlKCB1dkF0dHJpYnV0ZSwgYiApO1xuXHRcdFx0dXZDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2QXR0cmlidXRlLCBjICk7XG5cblx0XHRcdHZCLnN1YiggdkEgKTtcblx0XHRcdHZDLnN1YiggdkEgKTtcblxuXHRcdFx0dXZCLnN1YiggdXZBICk7XG5cdFx0XHR1dkMuc3ViKCB1dkEgKTtcblxuXHRcdFx0Y29uc3QgciA9IDEuMCAvICggdXZCLnggKiB1dkMueSAtIHV2Qy54ICogdXZCLnkgKTtcblxuXHRcdFx0Ly8gc2lsZW50bHkgaWdub3JlIGRlZ2VuZXJhdGUgdXYgdHJpYW5nbGVzIGhhdmluZyBjb2luY2lkZW50IG9yIGNvbGluZWFyIHZlcnRpY2VzXG5cblx0XHRcdGlmICggISBpc0Zpbml0ZSggciApICkgcmV0dXJuO1xuXG5cdFx0XHRzZGlyLmNvcHkoIHZCICkubXVsdGlwbHlTY2FsYXIoIHV2Qy55ICkuYWRkU2NhbGVkVmVjdG9yKCB2QywgLSB1dkIueSApLm11bHRpcGx5U2NhbGFyKCByICk7XG5cdFx0XHR0ZGlyLmNvcHkoIHZDICkubXVsdGlwbHlTY2FsYXIoIHV2Qi54ICkuYWRkU2NhbGVkVmVjdG9yKCB2QiwgLSB1dkMueCApLm11bHRpcGx5U2NhbGFyKCByICk7XG5cblx0XHRcdHRhbjFbIGEgXS5hZGQoIHNkaXIgKTtcblx0XHRcdHRhbjFbIGIgXS5hZGQoIHNkaXIgKTtcblx0XHRcdHRhbjFbIGMgXS5hZGQoIHNkaXIgKTtcblxuXHRcdFx0dGFuMlsgYSBdLmFkZCggdGRpciApO1xuXHRcdFx0dGFuMlsgYiBdLmFkZCggdGRpciApO1xuXHRcdFx0dGFuMlsgYyBdLmFkZCggdGRpciApO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG5cdFx0aWYgKCBncm91cHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRncm91cHMgPSBbIHtcblx0XHRcdFx0c3RhcnQ6IDAsXG5cdFx0XHRcdGNvdW50OiBpbmRleC5jb3VudFxuXHRcdFx0fSBdO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcblxuXHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcblxuXHRcdFx0Y29uc3Qgc3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdGNvbnN0IGNvdW50ID0gZ3JvdXAuY291bnQ7XG5cblx0XHRcdGZvciAoIGxldCBqID0gc3RhcnQsIGpsID0gc3RhcnQgKyBjb3VudDsgaiA8IGpsOyBqICs9IDMgKSB7XG5cblx0XHRcdFx0aGFuZGxlVHJpYW5nbGUoXG5cdFx0XHRcdFx0aW5kZXguZ2V0WCggaiArIDAgKSxcblx0XHRcdFx0XHRpbmRleC5nZXRYKCBqICsgMSApLFxuXHRcdFx0XHRcdGluZGV4LmdldFgoIGogKyAyIClcblx0XHRcdFx0KTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdG1wID0gbmV3IFZlY3RvcjMoKSwgdG1wMiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgbiA9IG5ldyBWZWN0b3IzKCksIG4yID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVZlcnRleCggdiApIHtcblxuXHRcdFx0bi5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWxBdHRyaWJ1dGUsIHYgKTtcblx0XHRcdG4yLmNvcHkoIG4gKTtcblxuXHRcdFx0Y29uc3QgdCA9IHRhbjFbIHYgXTtcblxuXHRcdFx0Ly8gR3JhbS1TY2htaWR0IG9ydGhvZ29uYWxpemVcblxuXHRcdFx0dG1wLmNvcHkoIHQgKTtcblx0XHRcdHRtcC5zdWIoIG4ubXVsdGlwbHlTY2FsYXIoIG4uZG90KCB0ICkgKSApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHQvLyBDYWxjdWxhdGUgaGFuZGVkbmVzc1xuXG5cdFx0XHR0bXAyLmNyb3NzVmVjdG9ycyggbjIsIHQgKTtcblx0XHRcdGNvbnN0IHRlc3QgPSB0bXAyLmRvdCggdGFuMlsgdiBdICk7XG5cdFx0XHRjb25zdCB3ID0gKCB0ZXN0IDwgMC4wICkgPyAtIDEuMCA6IDEuMDtcblxuXHRcdFx0dGFuZ2VudEF0dHJpYnV0ZS5zZXRYWVpXKCB2LCB0bXAueCwgdG1wLnksIHRtcC56LCB3ICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXG5cdFx0XHRjb25zdCBzdGFydCA9IGdyb3VwLnN0YXJ0O1xuXHRcdFx0Y29uc3QgY291bnQgPSBncm91cC5jb3VudDtcblxuXHRcdFx0Zm9yICggbGV0IGogPSBzdGFydCwgamwgPSBzdGFydCArIGNvdW50OyBqIDwgamw7IGogKz0gMyApIHtcblxuXHRcdFx0XHRoYW5kbGVWZXJ0ZXgoIGluZGV4LmdldFgoIGogKyAwICkgKTtcblx0XHRcdFx0aGFuZGxlVmVydGV4KCBpbmRleC5nZXRYKCBqICsgMSApICk7XG5cdFx0XHRcdGhhbmRsZVZlcnRleCggaW5kZXguZ2V0WCggaiArIDIgKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCkge1xuXG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLmluZGV4O1xuXHRcdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gdGhpcy5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblxuXHRcdGlmICggcG9zaXRpb25BdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bGV0IG5vcm1hbEF0dHJpYnV0ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCAnbm9ybWFsJyApO1xuXG5cdFx0XHRpZiAoIG5vcm1hbEF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHBvc2l0aW9uQXR0cmlidXRlLmNvdW50ICogMyApLCAzICk7XG5cdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbm9ybWFsQXR0cmlidXRlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gcmVzZXQgZXhpc3Rpbmcgbm9ybWFscyB0byB6ZXJvXG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG5vcm1hbEF0dHJpYnV0ZS5jb3VudDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWiggaSwgMCwgMCwgMCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBwQSA9IG5ldyBWZWN0b3IzKCksIHBCID0gbmV3IFZlY3RvcjMoKSwgcEMgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgbkEgPSBuZXcgVmVjdG9yMygpLCBuQiA9IG5ldyBWZWN0b3IzKCksIG5DID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IGNiID0gbmV3IFZlY3RvcjMoKSwgYWIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHQvLyBpbmRleGVkIGVsZW1lbnRzXG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGluZGV4LmNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHZBID0gaW5kZXguZ2V0WCggaSArIDAgKTtcblx0XHRcdFx0XHRjb25zdCB2QiA9IGluZGV4LmdldFgoIGkgKyAxICk7XG5cdFx0XHRcdFx0Y29uc3QgdkMgPSBpbmRleC5nZXRYKCBpICsgMiApO1xuXG5cdFx0XHRcdFx0cEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIHZBICk7XG5cdFx0XHRcdFx0cEIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIHZCICk7XG5cdFx0XHRcdFx0cEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIHZDICk7XG5cblx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcblx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcblxuXHRcdFx0XHRcdG5BLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbEF0dHJpYnV0ZSwgdkEgKTtcblx0XHRcdFx0XHRuQi5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWxBdHRyaWJ1dGUsIHZCICk7XG5cdFx0XHRcdFx0bkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsQXR0cmlidXRlLCB2QyApO1xuXG5cdFx0XHRcdFx0bkEuYWRkKCBjYiApO1xuXHRcdFx0XHRcdG5CLmFkZCggY2IgKTtcblx0XHRcdFx0XHRuQy5hZGQoIGNiICk7XG5cblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCB2QSwgbkEueCwgbkEueSwgbkEueiApO1xuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIHZCLCBuQi54LCBuQi55LCBuQi56ICk7XG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWiggdkMsIG5DLngsIG5DLnksIG5DLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gbm9uLWluZGV4ZWQgZWxlbWVudHMgKHVuY29ubmVjdGVkIHRyaWFuZ2xlIHNvdXApXG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHBvc2l0aW9uQXR0cmlidXRlLmNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdHBBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBpICsgMCApO1xuXHRcdFx0XHRcdHBCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBpICsgMSApO1xuXHRcdFx0XHRcdHBDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBpICsgMiApO1xuXG5cdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XG5cdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XG5cdFx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XG5cblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCBpICsgMCwgY2IueCwgY2IueSwgY2IueiApO1xuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIGkgKyAxLCBjYi54LCBjYi55LCBjYi56ICk7XG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWiggaSArIDIsIGNiLngsIGNiLnksIGNiLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5ub3JtYWxpemVOb3JtYWxzKCk7XG5cblx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0fVxuXG5cdG5vcm1hbGl6ZU5vcm1hbHMoKSB7XG5cblx0XHRjb25zdCBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBub3JtYWxzLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdF92ZWN0b3IkOC5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCBpICk7XG5cblx0XHRcdF92ZWN0b3IkOC5ub3JtYWxpemUoKTtcblxuXHRcdFx0bm9ybWFscy5zZXRYWVooIGksIF92ZWN0b3IkOC54LCBfdmVjdG9yJDgueSwgX3ZlY3RvciQ4LnogKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dG9Ob25JbmRleGVkKCkge1xuXG5cdFx0ZnVuY3Rpb24gY29udmVydEJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRpY2VzICkge1xuXG5cdFx0XHRjb25zdCBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcblx0XHRcdGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuXHRcdFx0Y29uc3Qgbm9ybWFsaXplZCA9IGF0dHJpYnV0ZS5ub3JtYWxpemVkO1xuXG5cdFx0XHRjb25zdCBhcnJheTIgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IoIGluZGljZXMubGVuZ3RoICogaXRlbVNpemUgKTtcblxuXHRcdFx0bGV0IGluZGV4ID0gMCwgaW5kZXgyID0gMDtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNbIGkgXSAqIGF0dHJpYnV0ZS5kYXRhLnN0cmlkZSArIGF0dHJpYnV0ZS5vZmZzZXQ7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGluZGV4ID0gaW5kaWNlc1sgaSBdICogaXRlbVNpemU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IGl0ZW1TaXplOyBqICsrICkge1xuXG5cdFx0XHRcdFx0YXJyYXkyWyBpbmRleDIgKysgXSA9IGFycmF5WyBpbmRleCArKyBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXkyLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGlmICggdGhpcy5pbmRleCA9PT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkudG9Ob25JbmRleGVkKCk6IEJ1ZmZlckdlb21ldHJ5IGlzIGFscmVhZHkgbm9uLWluZGV4ZWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRjb25zdCBnZW9tZXRyeTIgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdGNvbnN0IGluZGljZXMgPSB0aGlzLmluZGV4LmFycmF5O1xuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBhdHRyaWJ1dGVzXG5cblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0Y29uc3QgbmV3QXR0cmlidXRlID0gY29udmVydEJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRpY2VzICk7XG5cblx0XHRcdGdlb21ldHJ5Mi5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5ld0F0dHJpYnV0ZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gbW9ycGggYXR0cmlidXRlc1xuXG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIG1vcnBoQXR0cmlidXRlcyApIHtcblxuXHRcdFx0Y29uc3QgbW9ycGhBcnJheSA9IFtdO1xuXHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXTsgLy8gbW9ycGhBdHRyaWJ1dGU6IGFycmF5IG9mIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGVzXG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZVsgaSBdO1xuXG5cdFx0XHRcdGNvbnN0IG5ld0F0dHJpYnV0ZSA9IGNvbnZlcnRCdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kaWNlcyApO1xuXG5cdFx0XHRcdG1vcnBoQXJyYXkucHVzaCggbmV3QXR0cmlidXRlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkyLm1vcnBoQXR0cmlidXRlc1sgbmFtZSBdID0gbW9ycGhBcnJheTtcblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5Mi5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG5cblx0XHQvLyBncm91cHNcblxuXHRcdGNvbnN0IGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cdFx0XHRnZW9tZXRyeTIuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdlb21ldHJ5MjtcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdHZlcnNpb246IDQuNixcblx0XHRcdFx0dHlwZTogJ0J1ZmZlckdlb21ldHJ5Jyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnQnVmZmVyR2VvbWV0cnkudG9KU09OJ1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBzdGFuZGFyZCBCdWZmZXJHZW9tZXRyeSBzZXJpYWxpemF0aW9uXG5cblx0XHRkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG5cdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblx0XHRpZiAoIE9iamVjdC5rZXlzKCB0aGlzLnVzZXJEYXRhICkubGVuZ3RoID4gMCApIGRhdGEudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhO1xuXG5cdFx0aWYgKCB0aGlzLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdFx0Zm9yICggY29uc3Qga2V5IGluIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdC8vIGZvciBzaW1wbGljaXR5IHRoZSBjb2RlIGFzc3VtZXMgYXR0cmlidXRlcyBhcmUgbm90IHNoYXJlZCBhY3Jvc3MgZ2VvbWV0cmllcywgc2VlICMxNTgxMVxuXG5cdFx0ZGF0YS5kYXRhID0geyBhdHRyaWJ1dGVzOiB7fSB9O1xuXG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLmluZGV4O1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0ZGF0YS5kYXRhLmluZGV4ID0ge1xuXHRcdFx0XHR0eXBlOiBpbmRleC5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuXHRcdFx0XHRhcnJheTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGluZGV4LmFycmF5IClcblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG5cdFx0Zm9yICggY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xuXG5cdFx0XHRkYXRhLmRhdGEuYXR0cmlidXRlc1sga2V5IF0gPSBhdHRyaWJ1dGUudG9KU09OKCBkYXRhLmRhdGEgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHt9O1xuXHRcdGxldCBoYXNNb3JwaEF0dHJpYnV0ZXMgPSBmYWxzZTtcblxuXHRcdGZvciAoIGNvbnN0IGtleSBpbiB0aGlzLm1vcnBoQXR0cmlidXRlcyApIHtcblxuXHRcdFx0Y29uc3QgYXR0cmlidXRlQXJyYXkgPSB0aGlzLm1vcnBoQXR0cmlidXRlc1sga2V5IF07XG5cblx0XHRcdGNvbnN0IGFycmF5ID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBhdHRyaWJ1dGVBcnJheS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVBcnJheVsgaSBdO1xuXG5cdFx0XHRcdGFycmF5LnB1c2goIGF0dHJpYnV0ZS50b0pTT04oIGRhdGEuZGF0YSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdG1vcnBoQXR0cmlidXRlc1sga2V5IF0gPSBhcnJheTtcblxuXHRcdFx0XHRoYXNNb3JwaEF0dHJpYnV0ZXMgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGhhc01vcnBoQXR0cmlidXRlcyApIHtcblxuXHRcdFx0ZGF0YS5kYXRhLm1vcnBoQXR0cmlidXRlcyA9IG1vcnBoQXR0cmlidXRlcztcblx0XHRcdGRhdGEuZGF0YS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG5cblx0XHR9XG5cblx0XHRjb25zdCBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuXHRcdGlmICggZ3JvdXBzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdGRhdGEuZGF0YS5ncm91cHMgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggZ3JvdXBzICkgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ1NwaGVyZTtcblxuXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cblx0XHRcdGRhdGEuZGF0YS5ib3VuZGluZ1NwaGVyZSA9IHtcblx0XHRcdFx0Y2VudGVyOiBib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxuXHRcdFx0XHRyYWRpdXM6IGJvdW5kaW5nU3BoZXJlLnJhZGl1c1xuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0Ly8gcmVzZXRcblxuXHRcdHRoaXMuaW5kZXggPSBudWxsO1xuXHRcdHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuXHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XG5cdFx0dGhpcy5ncm91cHMgPSBbXTtcblx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxuXHRcdC8vIHVzZWQgZm9yIHN0b3JpbmcgY2xvbmVkLCBzaGFyZWQgZGF0YVxuXG5cdFx0Y29uc3QgZGF0YSA9IHt9O1xuXG5cdFx0Ly8gbmFtZVxuXG5cdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG5cblx0XHQvLyBpbmRleFxuXG5cdFx0Y29uc3QgaW5kZXggPSBzb3VyY2UuaW5kZXg7XG5cblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLnNldEluZGV4KCBpbmRleC5jbG9uZSggZGF0YSApICk7XG5cblx0XHR9XG5cblx0XHQvLyBhdHRyaWJ1dGVzXG5cblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gc291cmNlLmF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBuYW1lLCBhdHRyaWJ1dGUuY2xvbmUoIGRhdGEgKSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gbW9ycGggYXR0cmlidXRlc1xuXG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0gc291cmNlLm1vcnBoQXR0cmlidXRlcztcblxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhcnJheSA9IFtdO1xuXHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXTsgLy8gbW9ycGhBdHRyaWJ1dGU6IGFycmF5IG9mIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGVzXG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0YXJyYXkucHVzaCggbW9ycGhBdHRyaWJ1dGVbIGkgXS5jbG9uZSggZGF0YSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXSA9IGFycmF5O1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHNvdXJjZS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcblxuXHRcdC8vIGdyb3Vwc1xuXG5cdFx0Y29uc3QgZ3JvdXBzID0gc291cmNlLmdyb3VwcztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXHRcdFx0dGhpcy5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4ICk7XG5cblx0XHR9XG5cblx0XHQvLyBib3VuZGluZyBib3hcblxuXHRcdGNvbnN0IGJvdW5kaW5nQm94ID0gc291cmNlLmJvdW5kaW5nQm94O1xuXG5cdFx0aWYgKCBib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94LmNsb25lKCk7XG5cblx0XHR9XG5cblx0XHQvLyBib3VuZGluZyBzcGhlcmVcblxuXHRcdGNvbnN0IGJvdW5kaW5nU3BoZXJlID0gc291cmNlLmJvdW5kaW5nU3BoZXJlO1xuXG5cdFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG5cblx0XHR9XG5cblx0XHQvLyBkcmF3IHJhbmdlXG5cblx0XHR0aGlzLmRyYXdSYW5nZS5zdGFydCA9IHNvdXJjZS5kcmF3UmFuZ2Uuc3RhcnQ7XG5cdFx0dGhpcy5kcmF3UmFuZ2UuY291bnQgPSBzb3VyY2UuZHJhd1JhbmdlLmNvdW50O1xuXG5cdFx0Ly8gdXNlciBkYXRhXG5cblx0XHR0aGlzLnVzZXJEYXRhID0gc291cmNlLnVzZXJEYXRhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cbn1cblxuY29uc3QgX2ludmVyc2VNYXRyaXgkMyA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9yYXkkMyA9IC8qQF9fUFVSRV9fKi8gbmV3IFJheSgpO1xuY29uc3QgX3NwaGVyZSQ2ID0gLypAX19QVVJFX18qLyBuZXcgU3BoZXJlKCk7XG5jb25zdCBfc3BoZXJlSGl0QXQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNvbnN0IF92QSQxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZCJDEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdkMkMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX3RlbXBBID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX21vcnBoQSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX2ludGVyc2VjdGlvblBvaW50ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2ludGVyc2VjdGlvblBvaW50V29ybGQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNsYXNzIE1lc2ggZXh0ZW5kcyBPYmplY3QzRCB7XG5cblx0Y29uc3RydWN0b3IoIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCksIG1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCkgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc01lc2ggPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ01lc2gnO1xuXG5cdFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuXHRcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblxuXHRcdHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlLCByZWN1cnNpdmUgKTtcblxuXHRcdGlmICggc291cmNlLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IHNvdXJjZS5tb3JwaFRhcmdldEluZmx1ZW5jZXMuc2xpY2UoKTtcblxuXHRcdH1cblxuXHRcdGlmICggc291cmNlLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UubW9ycGhUYXJnZXREaWN0aW9uYXJ5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLm1hdGVyaWFsID0gQXJyYXkuaXNBcnJheSggc291cmNlLm1hdGVyaWFsICkgPyBzb3VyY2UubWF0ZXJpYWwuc2xpY2UoKSA6IHNvdXJjZS5tYXRlcmlhbDtcblx0XHR0aGlzLmdlb21ldHJ5ID0gc291cmNlLmdlb21ldHJ5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHVwZGF0ZU1vcnBoVGFyZ2V0cygpIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblx0XHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoIG1vcnBoQXR0cmlidXRlcyApO1xuXG5cdFx0aWYgKCBrZXlzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBrZXlzWyAwIF0gXTtcblxuXHRcdFx0aWYgKCBtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG5cblx0XHRcdFx0Zm9yICggbGV0IG0gPSAwLCBtbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IG1vcnBoQXR0cmlidXRlWyBtIF0ubmFtZSB8fCBTdHJpbmcoIG0gKTtcblxuXHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goIDAgKTtcblx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdID0gbTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Z2V0VmVydGV4UG9zaXRpb24oIGluZGV4LCB0YXJnZXQgKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGNvbnN0IG1vcnBoUG9zaXRpb24gPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcblxuXHRcdHRhcmdldC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaW5kZXggKTtcblxuXHRcdGNvbnN0IG1vcnBoSW5mbHVlbmNlcyA9IHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG5cdFx0aWYgKCBtb3JwaFBvc2l0aW9uICYmIG1vcnBoSW5mbHVlbmNlcyApIHtcblxuXHRcdFx0X21vcnBoQS5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1vcnBoUG9zaXRpb24ubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzWyBpIF07XG5cdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhQb3NpdGlvblsgaSBdO1xuXG5cdFx0XHRcdGlmICggaW5mbHVlbmNlID09PSAwICkgY29udGludWU7XG5cblx0XHRcdFx0X3RlbXBBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoQXR0cmlidXRlLCBpbmRleCApO1xuXG5cdFx0XHRcdGlmICggbW9ycGhUYXJnZXRzUmVsYXRpdmUgKSB7XG5cblx0XHRcdFx0XHRfbW9ycGhBLmFkZFNjYWxlZFZlY3RvciggX3RlbXBBLCBpbmZsdWVuY2UgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0X21vcnBoQS5hZGRTY2FsZWRWZWN0b3IoIF90ZW1wQS5zdWIoIHRhcmdldCApLCBpbmZsdWVuY2UgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGFyZ2V0LmFkZCggX21vcnBoQSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0cmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGNvbnN0IG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblx0XHRjb25zdCBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG5cblx0XHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHQvLyB0ZXN0IHdpdGggYm91bmRpbmcgc3BoZXJlIGluIHdvcmxkIHNwYWNlXG5cblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRfc3BoZXJlJDYuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcblx0XHRfc3BoZXJlJDYuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xuXG5cdFx0Ly8gY2hlY2sgZGlzdGFuY2UgZnJvbSByYXkgb3JpZ2luIHRvIGJvdW5kaW5nIHNwaGVyZVxuXG5cdFx0X3JheSQzLmNvcHkoIHJheWNhc3Rlci5yYXkgKS5yZWNhc3QoIHJheWNhc3Rlci5uZWFyICk7XG5cblx0XHRpZiAoIF9zcGhlcmUkNi5jb250YWluc1BvaW50KCBfcmF5JDMub3JpZ2luICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRpZiAoIF9yYXkkMy5pbnRlcnNlY3RTcGhlcmUoIF9zcGhlcmUkNiwgX3NwaGVyZUhpdEF0ICkgPT09IG51bGwgKSByZXR1cm47XG5cblx0XHRcdGlmICggX3JheSQzLm9yaWdpbi5kaXN0YW5jZVRvU3F1YXJlZCggX3NwaGVyZUhpdEF0ICkgPiAoIHJheWNhc3Rlci5mYXIgLSByYXljYXN0ZXIubmVhciApICoqIDIgKSByZXR1cm47XG5cblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHJheSB0byBsb2NhbCBzcGFjZSBvZiBtZXNoXG5cblx0XHRfaW52ZXJzZU1hdHJpeCQzLmNvcHkoIG1hdHJpeFdvcmxkICkuaW52ZXJ0KCk7XG5cdFx0X3JheSQzLmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIF9pbnZlcnNlTWF0cml4JDMgKTtcblxuXHRcdC8vIHRlc3Qgd2l0aCBib3VuZGluZyBib3ggaW4gbG9jYWwgc3BhY2VcblxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdGlmICggX3JheSQzLmludGVyc2VjdHNCb3goIGdlb21ldHJ5LmJvdW5kaW5nQm94ICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdGVzdCBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIGdlb21ldHJ5XG5cblx0XHR0aGlzLl9jb21wdXRlSW50ZXJzZWN0aW9ucyggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCBfcmF5JDMgKTtcblxuXHR9XG5cblx0X2NvbXB1dGVJbnRlcnNlY3Rpb25zKCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHJheUxvY2FsU3BhY2UgKSB7XG5cblx0XHRsZXQgaW50ZXJzZWN0aW9uO1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGNvbnN0IG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblxuXHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGNvbnN0IHV2ID0gZ2VvbWV0cnkuYXR0cmlidXRlcy51djtcblx0XHRjb25zdCB1djEgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnV2MTtcblx0XHRjb25zdCBub3JtYWwgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbDtcblx0XHRjb25zdCBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cdFx0Y29uc3QgZHJhd1JhbmdlID0gZ2VvbWV0cnkuZHJhd1JhbmdlO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gaW5kZXhlZCBidWZmZXIgZ2VvbWV0cnlcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBtYXRlcmlhbCApICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXHRcdFx0XHRcdGNvbnN0IGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFsgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xuXG5cdFx0XHRcdFx0Y29uc3Qgc3RhcnQgPSBNYXRoLm1heCggZ3JvdXAuc3RhcnQsIGRyYXdSYW5nZS5zdGFydCApO1xuXHRcdFx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKCBpbmRleC5jb3VudCwgTWF0aC5taW4oICggZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCApLCAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApICkgKTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gc3RhcnQsIGpsID0gZW5kOyBqIDwgamw7IGogKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYSA9IGluZGV4LmdldFgoIGogKTtcblx0XHRcdFx0XHRcdGNvbnN0IGIgPSBpbmRleC5nZXRYKCBqICsgMSApO1xuXHRcdFx0XHRcdFx0Y29uc3QgYyA9IGluZGV4LmdldFgoIGogKyAyICk7XG5cblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHRoaXMsIGdyb3VwTWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5TG9jYWxTcGFjZSwgdXYsIHV2MSwgbm9ybWFsLCBhLCBiLCBjICk7XG5cblx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xuXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBNYXRoLmZsb29yKCBqIC8gMyApOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gaW5kZXhlZCBidWZmZXIgc2VtYW50aWNzXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlLm1hdGVyaWFsSW5kZXggPSBncm91cC5tYXRlcmlhbEluZGV4O1xuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoIDAsIGRyYXdSYW5nZS5zdGFydCApO1xuXHRcdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbiggaW5kZXguY291bnQsICggZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50ICkgKTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IHN0YXJ0LCBpbCA9IGVuZDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBhID0gaW5kZXguZ2V0WCggaSApO1xuXHRcdFx0XHRcdGNvbnN0IGIgPSBpbmRleC5nZXRYKCBpICsgMSApO1xuXHRcdFx0XHRcdGNvbnN0IGMgPSBpbmRleC5nZXRYKCBpICsgMiApO1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gY2hlY2tHZW9tZXRyeUludGVyc2VjdGlvbiggdGhpcywgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5TG9jYWxTcGFjZSwgdXYsIHV2MSwgbm9ybWFsLCBhLCBiLCBjICk7XG5cblx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoIGkgLyAzICk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBpbmRleGVkIGJ1ZmZlciBzZW1hbnRpY3Ncblx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBub24taW5kZXhlZCBidWZmZXIgZ2VvbWV0cnlcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBtYXRlcmlhbCApICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXHRcdFx0XHRcdGNvbnN0IGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFsgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xuXG5cdFx0XHRcdFx0Y29uc3Qgc3RhcnQgPSBNYXRoLm1heCggZ3JvdXAuc3RhcnQsIGRyYXdSYW5nZS5zdGFydCApO1xuXHRcdFx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKCBwb3NpdGlvbi5jb3VudCwgTWF0aC5taW4oICggZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCApLCAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApICkgKTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gc3RhcnQsIGpsID0gZW5kOyBqIDwgamw7IGogKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYSA9IGo7XG5cdFx0XHRcdFx0XHRjb25zdCBiID0gaiArIDE7XG5cdFx0XHRcdFx0XHRjb25zdCBjID0gaiArIDI7XG5cblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHRoaXMsIGdyb3VwTWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5TG9jYWxTcGFjZSwgdXYsIHV2MSwgbm9ybWFsLCBhLCBiLCBjICk7XG5cblx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xuXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBNYXRoLmZsb29yKCBqIC8gMyApOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gbm9uLWluZGV4ZWQgYnVmZmVyIHNlbWFudGljc1xuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZS5tYXRlcmlhbEluZGV4ID0gZ3JvdXAubWF0ZXJpYWxJbmRleDtcblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KCAwLCBkcmF3UmFuZ2Uuc3RhcnQgKTtcblx0XHRcdFx0Y29uc3QgZW5kID0gTWF0aC5taW4oIHBvc2l0aW9uLmNvdW50LCAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApICk7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYSA9IGk7XG5cdFx0XHRcdFx0Y29uc3QgYiA9IGkgKyAxO1xuXHRcdFx0XHRcdGNvbnN0IGMgPSBpICsgMjtcblxuXHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHRoaXMsIG1hdGVyaWFsLCByYXljYXN0ZXIsIHJheUxvY2FsU3BhY2UsIHV2LCB1djEsIG5vcm1hbCwgYSwgYiwgYyApO1xuXG5cdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XG5cblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBNYXRoLmZsb29yKCBpIC8gMyApOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gbm9uLWluZGV4ZWQgYnVmZmVyIHNlbWFudGljc1xuXHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24kMSggb2JqZWN0LCBtYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXksIHBBLCBwQiwgcEMsIHBvaW50ICkge1xuXG5cdGxldCBpbnRlcnNlY3Q7XG5cblx0aWYgKCBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSApIHtcblxuXHRcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggcEMsIHBCLCBwQSwgdHJ1ZSwgcG9pbnQgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0aW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQSwgcEIsIHBDLCAoIG1hdGVyaWFsLnNpZGUgPT09IEZyb250U2lkZSApLCBwb2ludCApO1xuXG5cdH1cblxuXHRpZiAoIGludGVyc2VjdCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xuXG5cdF9pbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNvcHkoIHBvaW50ICk7XG5cdF9pbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0Y29uc3QgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBfaW50ZXJzZWN0aW9uUG9pbnRXb3JsZCApO1xuXG5cdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm4gbnVsbDtcblxuXHRyZXR1cm4ge1xuXHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcblx0XHRwb2ludDogX2ludGVyc2VjdGlvblBvaW50V29ybGQuY2xvbmUoKSxcblx0XHRvYmplY3Q6IG9iamVjdFxuXHR9O1xuXG59XG5cbmZ1bmN0aW9uIGNoZWNrR2VvbWV0cnlJbnRlcnNlY3Rpb24oIG9iamVjdCwgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCB1diwgdXYxLCBub3JtYWwsIGEsIGIsIGMgKSB7XG5cblx0b2JqZWN0LmdldFZlcnRleFBvc2l0aW9uKCBhLCBfdkEkMSApO1xuXHRvYmplY3QuZ2V0VmVydGV4UG9zaXRpb24oIGIsIF92QiQxICk7XG5cdG9iamVjdC5nZXRWZXJ0ZXhQb3NpdGlvbiggYywgX3ZDJDEgKTtcblxuXHRjb25zdCBpbnRlcnNlY3Rpb24gPSBjaGVja0ludGVyc2VjdGlvbiQxKCBvYmplY3QsIG1hdGVyaWFsLCByYXljYXN0ZXIsIHJheSwgX3ZBJDEsIF92QiQxLCBfdkMkMSwgX2ludGVyc2VjdGlvblBvaW50ICk7XG5cblx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XG5cblx0XHRjb25zdCBiYXJ5Y29vcmQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFRyaWFuZ2xlLmdldEJhcnljb29yZCggX2ludGVyc2VjdGlvblBvaW50LCBfdkEkMSwgX3ZCJDEsIF92QyQxLCBiYXJ5Y29vcmQgKTtcblxuXHRcdGlmICggdXYgKSB7XG5cblx0XHRcdGludGVyc2VjdGlvbi51diA9IFRyaWFuZ2xlLmdldEludGVycG9sYXRlZEF0dHJpYnV0ZSggdXYsIGEsIGIsIGMsIGJhcnljb29yZCwgbmV3IFZlY3RvcjIoKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1djEgKSB7XG5cblx0XHRcdGludGVyc2VjdGlvbi51djEgPSBUcmlhbmdsZS5nZXRJbnRlcnBvbGF0ZWRBdHRyaWJ1dGUoIHV2MSwgYSwgYiwgYywgYmFyeWNvb3JkLCBuZXcgVmVjdG9yMigpICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG5vcm1hbCApIHtcblxuXHRcdFx0aW50ZXJzZWN0aW9uLm5vcm1hbCA9IFRyaWFuZ2xlLmdldEludGVycG9sYXRlZEF0dHJpYnV0ZSggbm9ybWFsLCBhLCBiLCBjLCBiYXJ5Y29vcmQsIG5ldyBWZWN0b3IzKCkgKTtcblxuXHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24ubm9ybWFsLmRvdCggcmF5LmRpcmVjdGlvbiApID4gMCApIHtcblxuXHRcdFx0XHRpbnRlcnNlY3Rpb24ubm9ybWFsLm11bHRpcGx5U2NhbGFyKCAtIDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZmFjZSA9IHtcblx0XHRcdGE6IGEsXG5cdFx0XHRiOiBiLFxuXHRcdFx0YzogYyxcblx0XHRcdG5vcm1hbDogbmV3IFZlY3RvcjMoKSxcblx0XHRcdG1hdGVyaWFsSW5kZXg6IDBcblx0XHR9O1xuXG5cdFx0VHJpYW5nbGUuZ2V0Tm9ybWFsKCBfdkEkMSwgX3ZCJDEsIF92QyQxLCBmYWNlLm5vcm1hbCApO1xuXG5cdFx0aW50ZXJzZWN0aW9uLmZhY2UgPSBmYWNlO1xuXHRcdGludGVyc2VjdGlvbi5iYXJ5Y29vcmQgPSBiYXJ5Y29vcmQ7XG5cblx0fVxuXG5cdHJldHVybiBpbnRlcnNlY3Rpb247XG5cbn1cblxuY2xhc3MgQm94R2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgZGVwdGggPSAxLCB3aWR0aFNlZ21lbnRzID0gMSwgaGVpZ2h0U2VnbWVudHMgPSAxLCBkZXB0aFNlZ21lbnRzID0gMSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQm94R2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHRkZXB0aDogZGVwdGgsXG5cdFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0ZGVwdGhTZWdtZW50czogZGVwdGhTZWdtZW50c1xuXHRcdH07XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHQvLyBzZWdtZW50c1xuXG5cdFx0d2lkdGhTZWdtZW50cyA9IE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKTtcblx0XHRoZWlnaHRTZWdtZW50cyA9IE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICk7XG5cdFx0ZGVwdGhTZWdtZW50cyA9IE1hdGguZmxvb3IoIGRlcHRoU2VnbWVudHMgKTtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGxldCBudW1iZXJPZlZlcnRpY2VzID0gMDtcblx0XHRsZXQgZ3JvdXBTdGFydCA9IDA7XG5cblx0XHQvLyBidWlsZCBlYWNoIHNpZGUgb2YgdGhlIGJveCBnZW9tZXRyeVxuXG5cdFx0YnVpbGRQbGFuZSggJ3onLCAneScsICd4JywgLSAxLCAtIDEsIGRlcHRoLCBoZWlnaHQsIHdpZHRoLCBkZXB0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgMCApOyAvLyBweFxuXHRcdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAneCcsIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgLSB3aWR0aCwgZGVwdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDEgKTsgLy8gbnhcblx0XHRidWlsZFBsYW5lKCAneCcsICd6JywgJ3knLCAxLCAxLCB3aWR0aCwgZGVwdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgZGVwdGhTZWdtZW50cywgMiApOyAvLyBweVxuXHRcdGJ1aWxkUGxhbmUoICd4JywgJ3onLCAneScsIDEsIC0gMSwgd2lkdGgsIGRlcHRoLCAtIGhlaWdodCwgd2lkdGhTZWdtZW50cywgZGVwdGhTZWdtZW50cywgMyApOyAvLyBueVxuXHRcdGJ1aWxkUGxhbmUoICd4JywgJ3knLCAneicsIDEsIC0gMSwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCA0ICk7IC8vIHB6XG5cdFx0YnVpbGRQbGFuZSggJ3gnLCAneScsICd6JywgLSAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIC0gZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCA1ICk7IC8vIG56XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHRcdGZ1bmN0aW9uIGJ1aWxkUGxhbmUoIHUsIHYsIHcsIHVkaXIsIHZkaXIsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBncmlkWCwgZ3JpZFksIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHRcdGNvbnN0IHNlZ21lbnRXaWR0aCA9IHdpZHRoIC8gZ3JpZFg7XG5cdFx0XHRjb25zdCBzZWdtZW50SGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFk7XG5cblx0XHRcdGNvbnN0IHdpZHRoSGFsZiA9IHdpZHRoIC8gMjtcblx0XHRcdGNvbnN0IGhlaWdodEhhbGYgPSBoZWlnaHQgLyAyO1xuXHRcdFx0Y29uc3QgZGVwdGhIYWxmID0gZGVwdGggLyAyO1xuXG5cdFx0XHRjb25zdCBncmlkWDEgPSBncmlkWCArIDE7XG5cdFx0XHRjb25zdCBncmlkWTEgPSBncmlkWSArIDE7XG5cblx0XHRcdGxldCB2ZXJ0ZXhDb3VudGVyID0gMDtcblx0XHRcdGxldCBncm91cENvdW50ID0gMDtcblxuXHRcdFx0Y29uc3QgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0XHRmb3IgKCBsZXQgaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgeSA9IGl5ICogc2VnbWVudEhlaWdodCAtIGhlaWdodEhhbGY7XG5cblx0XHRcdFx0Zm9yICggbGV0IGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgeCA9IGl4ICogc2VnbWVudFdpZHRoIC0gd2lkdGhIYWxmO1xuXG5cdFx0XHRcdFx0Ly8gc2V0IHZhbHVlcyB0byBjb3JyZWN0IHZlY3RvciBjb21wb25lbnRcblxuXHRcdFx0XHRcdHZlY3RvclsgdSBdID0geCAqIHVkaXI7XG5cdFx0XHRcdFx0dmVjdG9yWyB2IF0gPSB5ICogdmRpcjtcblx0XHRcdFx0XHR2ZWN0b3JbIHcgXSA9IGRlcHRoSGFsZjtcblxuXHRcdFx0XHRcdC8vIG5vdyBhcHBseSB2ZWN0b3IgdG8gdmVydGV4IGJ1ZmZlclxuXG5cdFx0XHRcdFx0dmVydGljZXMucHVzaCggdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiApO1xuXG5cdFx0XHRcdFx0Ly8gc2V0IHZhbHVlcyB0byBjb3JyZWN0IHZlY3RvciBjb21wb25lbnRcblxuXHRcdFx0XHRcdHZlY3RvclsgdSBdID0gMDtcblx0XHRcdFx0XHR2ZWN0b3JbIHYgXSA9IDA7XG5cdFx0XHRcdFx0dmVjdG9yWyB3IF0gPSBkZXB0aCA+IDAgPyAxIDogLSAxO1xuXG5cdFx0XHRcdFx0Ly8gbm93IGFwcGx5IHZlY3RvciB0byBub3JtYWwgYnVmZmVyXG5cblx0XHRcdFx0XHRub3JtYWxzLnB1c2goIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnogKTtcblxuXHRcdFx0XHRcdC8vIHV2c1xuXG5cdFx0XHRcdFx0dXZzLnB1c2goIGl4IC8gZ3JpZFggKTtcblx0XHRcdFx0XHR1dnMucHVzaCggMSAtICggaXkgLyBncmlkWSApICk7XG5cblx0XHRcdFx0XHQvLyBjb3VudGVyc1xuXG5cdFx0XHRcdFx0dmVydGV4Q291bnRlciArPSAxO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbmRpY2VzXG5cblx0XHRcdC8vIDEuIHlvdSBuZWVkIHRocmVlIGluZGljZXMgdG8gZHJhdyBhIHNpbmdsZSBmYWNlXG5cdFx0XHQvLyAyLiBhIHNpbmdsZSBzZWdtZW50IGNvbnNpc3RzIG9mIHR3byBmYWNlc1xuXHRcdFx0Ly8gMy4gc28gd2UgbmVlZCB0byBnZW5lcmF0ZSBzaXggKDIqMykgaW5kaWNlcyBwZXIgc2VnbWVudFxuXG5cdFx0XHRmb3IgKCBsZXQgaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGEgPSBudW1iZXJPZlZlcnRpY2VzICsgaXggKyBncmlkWDEgKiBpeTtcblx0XHRcdFx0XHRjb25zdCBiID0gbnVtYmVyT2ZWZXJ0aWNlcyArIGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcblx0XHRcdFx0XHRjb25zdCBjID0gbnVtYmVyT2ZWZXJ0aWNlcyArICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHRcdGNvbnN0IGQgPSBudW1iZXJPZlZlcnRpY2VzICsgKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xuXG5cdFx0XHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHRcdFx0Ly8gaW5jcmVhc2UgY291bnRlclxuXG5cdFx0XHRcdFx0Z3JvdXBDb3VudCArPSA2O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBhZGQgYSBncm91cCB0byB0aGUgZ2VvbWV0cnkuIHRoaXMgd2lsbCBlbnN1cmUgbXVsdGkgbWF0ZXJpYWwgc3VwcG9ydFxuXG5cdFx0XHRzY29wZS5hZGRHcm91cCggZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgbWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IHZhbHVlIGZvciBncm91cHNcblxuXHRcdFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xuXG5cdFx0XHQvLyB1cGRhdGUgdG90YWwgbnVtYmVyIG9mIHZlcnRpY2VzXG5cblx0XHRcdG51bWJlck9mVmVydGljZXMgKz0gdmVydGV4Q291bnRlcjtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IEJveEdlb21ldHJ5KCBkYXRhLndpZHRoLCBkYXRhLmhlaWdodCwgZGF0YS5kZXB0aCwgZGF0YS53aWR0aFNlZ21lbnRzLCBkYXRhLmhlaWdodFNlZ21lbnRzLCBkYXRhLmRlcHRoU2VnbWVudHMgKTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBVbmlmb3JtIFV0aWxpdGllc1xuICovXG5cbmZ1bmN0aW9uIGNsb25lVW5pZm9ybXMoIHNyYyApIHtcblxuXHRjb25zdCBkc3QgPSB7fTtcblxuXHRmb3IgKCBjb25zdCB1IGluIHNyYyApIHtcblxuXHRcdGRzdFsgdSBdID0ge307XG5cblx0XHRmb3IgKCBjb25zdCBwIGluIHNyY1sgdSBdICkge1xuXG5cdFx0XHRjb25zdCBwcm9wZXJ0eSA9IHNyY1sgdSBdWyBwIF07XG5cblx0XHRcdGlmICggcHJvcGVydHkgJiYgKCBwcm9wZXJ0eS5pc0NvbG9yIHx8XG5cdFx0XHRcdHByb3BlcnR5LmlzTWF0cml4MyB8fCBwcm9wZXJ0eS5pc01hdHJpeDQgfHxcblx0XHRcdFx0cHJvcGVydHkuaXNWZWN0b3IyIHx8IHByb3BlcnR5LmlzVmVjdG9yMyB8fCBwcm9wZXJ0eS5pc1ZlY3RvcjQgfHxcblx0XHRcdFx0cHJvcGVydHkuaXNUZXh0dXJlIHx8IHByb3BlcnR5LmlzUXVhdGVybmlvbiApICkge1xuXG5cdFx0XHRcdGlmICggcHJvcGVydHkuaXNSZW5kZXJUYXJnZXRUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVW5pZm9ybXNVdGlsczogVGV4dHVyZXMgb2YgcmVuZGVyIHRhcmdldHMgY2Fubm90IGJlIGNsb25lZCB2aWEgY2xvbmVVbmlmb3JtcygpIG9yIG1lcmdlVW5pZm9ybXMoKS4nICk7XG5cdFx0XHRcdFx0ZHN0WyB1IF1bIHAgXSA9IG51bGw7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGRzdFsgdSBdWyBwIF0gPSBwcm9wZXJ0eS5jbG9uZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggcHJvcGVydHkgKSApIHtcblxuXHRcdFx0XHRkc3RbIHUgXVsgcCBdID0gcHJvcGVydHkuc2xpY2UoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRkc3RbIHUgXVsgcCBdID0gcHJvcGVydHk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIGRzdDtcblxufVxuXG5mdW5jdGlvbiBtZXJnZVVuaWZvcm1zKCB1bmlmb3JtcyApIHtcblxuXHRjb25zdCBtZXJnZWQgPSB7fTtcblxuXHRmb3IgKCBsZXQgdSA9IDA7IHUgPCB1bmlmb3Jtcy5sZW5ndGg7IHUgKysgKSB7XG5cblx0XHRjb25zdCB0bXAgPSBjbG9uZVVuaWZvcm1zKCB1bmlmb3Jtc1sgdSBdICk7XG5cblx0XHRmb3IgKCBjb25zdCBwIGluIHRtcCApIHtcblxuXHRcdFx0bWVyZ2VkWyBwIF0gPSB0bXBbIHAgXTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIG1lcmdlZDtcblxufVxuXG5mdW5jdGlvbiBjbG9uZVVuaWZvcm1zR3JvdXBzKCBzcmMgKSB7XG5cblx0Y29uc3QgZHN0ID0gW107XG5cblx0Zm9yICggbGV0IHUgPSAwOyB1IDwgc3JjLmxlbmd0aDsgdSArKyApIHtcblxuXHRcdGRzdC5wdXNoKCBzcmNbIHUgXS5jbG9uZSgpICk7XG5cblx0fVxuXG5cdHJldHVybiBkc3Q7XG5cbn1cblxuZnVuY3Rpb24gZ2V0VW5saXRVbmlmb3JtQ29sb3JTcGFjZSggcmVuZGVyZXIgKSB7XG5cblx0Y29uc3QgY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuXG5cdGlmICggY3VycmVudFJlbmRlclRhcmdldCA9PT0gbnVsbCApIHtcblxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yMzkzNyNpc3N1ZWNvbW1lbnQtMTExMTA2NzM5OFxuXHRcdHJldHVybiByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlO1xuXG5cdH1cblxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8yNzg2OFxuXHRpZiAoIGN1cnJlbnRSZW5kZXJUYXJnZXQuaXNYUlJlbmRlclRhcmdldCA9PT0gdHJ1ZSApIHtcblxuXHRcdHJldHVybiBjdXJyZW50UmVuZGVyVGFyZ2V0LnRleHR1cmUuY29sb3JTcGFjZTtcblxuXHR9XG5cblx0cmV0dXJuIENvbG9yTWFuYWdlbWVudC53b3JraW5nQ29sb3JTcGFjZTtcblxufVxuXG4vLyBMZWdhY3lcblxuY29uc3QgVW5pZm9ybXNVdGlscyA9IHsgY2xvbmU6IGNsb25lVW5pZm9ybXMsIG1lcmdlOiBtZXJnZVVuaWZvcm1zIH07XG5cbnZhciBkZWZhdWx0X3ZlcnRleCA9IFwidm9pZCBtYWluKCkge1xcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG59XCI7XG5cbnZhciBkZWZhdWx0X2ZyYWdtZW50ID0gXCJ2b2lkIG1haW4oKSB7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMS4wLCAwLjAsIDAuMCwgMS4wICk7XFxufVwiO1xuXG5jbGFzcyBTaGFkZXJNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzU2hhZGVyTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1NoYWRlck1hdGVyaWFsJztcblxuXHRcdHRoaXMuZGVmaW5lcyA9IHt9O1xuXHRcdHRoaXMudW5pZm9ybXMgPSB7fTtcblx0XHR0aGlzLnVuaWZvcm1zR3JvdXBzID0gW107XG5cblx0XHR0aGlzLnZlcnRleFNoYWRlciA9IGRlZmF1bHRfdmVydGV4O1xuXHRcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBkZWZhdWx0X2ZyYWdtZW50O1xuXG5cdFx0dGhpcy5saW5ld2lkdGggPSAxO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cblx0XHR0aGlzLmZvZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGZvZ1xuXHRcdHRoaXMubGlnaHRzID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgbGlnaHRzXG5cdFx0dGhpcy5jbGlwcGluZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHVzZXItZGVmaW5lZCBjbGlwcGluZyBwbGFuZXNcblxuXHRcdHRoaXMuZm9yY2VTaW5nbGVQYXNzID0gdHJ1ZTtcblxuXHRcdHRoaXMuZXh0ZW5zaW9ucyA9IHtcblx0XHRcdGNsaXBDdWxsRGlzdGFuY2U6IGZhbHNlLCAvLyBzZXQgdG8gdXNlIHZlcnRleCBzaGFkZXIgY2xpcHBpbmdcblx0XHRcdG11bHRpRHJhdzogZmFsc2UgLy8gc2V0IHRvIHVzZSB2ZXJ0ZXggc2hhZGVyIG11bHRpX2RyYXcgLyBlbmFibGUgZ2xfRHJhd0lEXG5cdFx0fTtcblxuXHRcdC8vIFdoZW4gcmVuZGVyZWQgZ2VvbWV0cnkgZG9lc24ndCBpbmNsdWRlIHRoZXNlIGF0dHJpYnV0ZXMgYnV0IHRoZSBtYXRlcmlhbCBkb2VzLFxuXHRcdC8vIHVzZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpbiBXZWJHTC4gVGhpcyBhdm9pZHMgZXJyb3JzIHdoZW4gYnVmZmVyIGRhdGEgaXMgbWlzc2luZy5cblx0XHR0aGlzLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgPSB7XG5cdFx0XHQnY29sb3InOiBbIDEsIDEsIDEgXSxcblx0XHRcdCd1dic6IFsgMCwgMCBdLFxuXHRcdFx0J3V2MSc6IFsgMCwgMCBdXG5cdFx0fTtcblxuXHRcdHRoaXMuaW5kZXgwQXR0cmlidXRlTmFtZSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnVuaWZvcm1zTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5nbHNsVmVyc2lvbiA9IG51bGw7XG5cblx0XHRpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmZyYWdtZW50U2hhZGVyID0gc291cmNlLmZyYWdtZW50U2hhZGVyO1xuXHRcdHRoaXMudmVydGV4U2hhZGVyID0gc291cmNlLnZlcnRleFNoYWRlcjtcblxuXHRcdHRoaXMudW5pZm9ybXMgPSBjbG9uZVVuaWZvcm1zKCBzb3VyY2UudW5pZm9ybXMgKTtcblx0XHR0aGlzLnVuaWZvcm1zR3JvdXBzID0gY2xvbmVVbmlmb3Jtc0dyb3Vwcyggc291cmNlLnVuaWZvcm1zR3JvdXBzICk7XG5cblx0XHR0aGlzLmRlZmluZXMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLmRlZmluZXMgKTtcblxuXHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cdFx0dGhpcy5saWdodHMgPSBzb3VyY2UubGlnaHRzO1xuXHRcdHRoaXMuY2xpcHBpbmcgPSBzb3VyY2UuY2xpcHBpbmc7XG5cblx0XHR0aGlzLmV4dGVuc2lvbnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLmV4dGVuc2lvbnMgKTtcblxuXHRcdHRoaXMuZ2xzbFZlcnNpb24gPSBzb3VyY2UuZ2xzbFZlcnNpb247XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCBtZXRhICkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTiggbWV0YSApO1xuXG5cdFx0ZGF0YS5nbHNsVmVyc2lvbiA9IHRoaXMuZ2xzbFZlcnNpb247XG5cdFx0ZGF0YS51bmlmb3JtcyA9IHt9O1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiB0aGlzLnVuaWZvcm1zICkge1xuXG5cdFx0XHRjb25zdCB1bmlmb3JtID0gdGhpcy51bmlmb3Jtc1sgbmFtZSBdO1xuXHRcdFx0Y29uc3QgdmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xuXG5cdFx0XHRpZiAoIHZhbHVlICYmIHZhbHVlLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0XHRkYXRhLnVuaWZvcm1zWyBuYW1lIF0gPSB7XG5cdFx0XHRcdFx0dHlwZTogJ3QnLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0pTT04oIG1ldGEgKS51dWlkXG5cdFx0XHRcdH07XG5cblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIHZhbHVlLmlzQ29sb3IgKSB7XG5cblx0XHRcdFx0ZGF0YS51bmlmb3Jtc1sgbmFtZSBdID0ge1xuXHRcdFx0XHRcdHR5cGU6ICdjJyxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWUuZ2V0SGV4KClcblx0XHRcdFx0fTtcblxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgdmFsdWUuaXNWZWN0b3IyICkge1xuXG5cdFx0XHRcdGRhdGEudW5pZm9ybXNbIG5hbWUgXSA9IHtcblx0XHRcdFx0XHR0eXBlOiAndjInLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0FycmF5KClcblx0XHRcdFx0fTtcblxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgdmFsdWUuaXNWZWN0b3IzICkge1xuXG5cdFx0XHRcdGRhdGEudW5pZm9ybXNbIG5hbWUgXSA9IHtcblx0XHRcdFx0XHR0eXBlOiAndjMnLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0FycmF5KClcblx0XHRcdFx0fTtcblxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgdmFsdWUuaXNWZWN0b3I0ICkge1xuXG5cdFx0XHRcdGRhdGEudW5pZm9ybXNbIG5hbWUgXSA9IHtcblx0XHRcdFx0XHR0eXBlOiAndjQnLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0FycmF5KClcblx0XHRcdFx0fTtcblxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgdmFsdWUuaXNNYXRyaXgzICkge1xuXG5cdFx0XHRcdGRhdGEudW5pZm9ybXNbIG5hbWUgXSA9IHtcblx0XHRcdFx0XHR0eXBlOiAnbTMnLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0FycmF5KClcblx0XHRcdFx0fTtcblxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgdmFsdWUuaXNNYXRyaXg0ICkge1xuXG5cdFx0XHRcdGRhdGEudW5pZm9ybXNbIG5hbWUgXSA9IHtcblx0XHRcdFx0XHR0eXBlOiAnbTQnLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0FycmF5KClcblx0XHRcdFx0fTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRkYXRhLnVuaWZvcm1zWyBuYW1lIF0gPSB7XG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gbm90ZTogdGhlIGFycmF5IHZhcmlhbnRzIHYydiwgdjN2LCB2NHYsIG00diBhbmQgdHYgYXJlIG5vdCBzdXBwb3J0ZWQgc28gZmFyXG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggT2JqZWN0LmtleXMoIHRoaXMuZGVmaW5lcyApLmxlbmd0aCA+IDAgKSBkYXRhLmRlZmluZXMgPSB0aGlzLmRlZmluZXM7XG5cblx0XHRkYXRhLnZlcnRleFNoYWRlciA9IHRoaXMudmVydGV4U2hhZGVyO1xuXHRcdGRhdGEuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xuXG5cdFx0ZGF0YS5saWdodHMgPSB0aGlzLmxpZ2h0cztcblx0XHRkYXRhLmNsaXBwaW5nID0gdGhpcy5jbGlwcGluZztcblxuXHRcdGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcblxuXHRcdGZvciAoIGNvbnN0IGtleSBpbiB0aGlzLmV4dGVuc2lvbnMgKSB7XG5cblx0XHRcdGlmICggdGhpcy5leHRlbnNpb25zWyBrZXkgXSA9PT0gdHJ1ZSApIGV4dGVuc2lvbnNbIGtleSBdID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggT2JqZWN0LmtleXMoIGV4dGVuc2lvbnMgKS5sZW5ndGggPiAwICkgZGF0YS5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxufVxuXG5jbGFzcyBDYW1lcmEgZXh0ZW5kcyBPYmplY3QzRCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0NhbWVyYSA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnQ2FtZXJhJztcblxuXHRcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHR0aGlzLmNvb3JkaW5hdGVTeXN0ZW0gPSBXZWJHTENvb3JkaW5hdGVTeXN0ZW07XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlLCByZWN1cnNpdmUgKTtcblxuXHRcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoIHNvdXJjZS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBzb3VyY2UucHJvamVjdGlvbk1hdHJpeCApO1xuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weSggc291cmNlLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlICk7XG5cblx0XHR0aGlzLmNvb3JkaW5hdGVTeXN0ZW0gPSBzb3VyY2UuY29vcmRpbmF0ZVN5c3RlbTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRXb3JsZERpcmVjdGlvbiggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHN1cGVyLmdldFdvcmxkRGlyZWN0aW9uKCB0YXJnZXQgKS5uZWdhdGUoKTtcblxuXHR9XG5cblx0dXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG5cdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KCB0aGlzLm1hdHJpeFdvcmxkICkuaW52ZXJ0KCk7XG5cblx0fVxuXG5cdHVwZGF0ZVdvcmxkTWF0cml4KCB1cGRhdGVQYXJlbnRzLCB1cGRhdGVDaGlsZHJlbiApIHtcblxuXHRcdHN1cGVyLnVwZGF0ZVdvcmxkTWF0cml4KCB1cGRhdGVQYXJlbnRzLCB1cGRhdGVDaGlsZHJlbiApO1xuXG5cdFx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSggdGhpcy5tYXRyaXhXb3JsZCApLmludmVydCgpO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn1cblxuY29uc3QgX3YzJDEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfbWluVGFyZ2V0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMigpO1xuY29uc3QgX21heFRhcmdldCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcblxuXG5jbGFzcyBQZXJzcGVjdGl2ZUNhbWVyYSBleHRlbmRzIENhbWVyYSB7XG5cblx0Y29uc3RydWN0b3IoIGZvdiA9IDUwLCBhc3BlY3QgPSAxLCBuZWFyID0gMC4xLCBmYXIgPSAyMDAwICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNQZXJzcGVjdGl2ZUNhbWVyYSA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnUGVyc3BlY3RpdmVDYW1lcmEnO1xuXG5cdFx0dGhpcy5mb3YgPSBmb3Y7XG5cdFx0dGhpcy56b29tID0gMTtcblxuXHRcdHRoaXMubmVhciA9IG5lYXI7XG5cdFx0dGhpcy5mYXIgPSBmYXI7XG5cdFx0dGhpcy5mb2N1cyA9IDEwO1xuXG5cdFx0dGhpcy5hc3BlY3QgPSBhc3BlY3Q7XG5cdFx0dGhpcy52aWV3ID0gbnVsbDtcblxuXHRcdHRoaXMuZmlsbUdhdWdlID0gMzU7XHQvLyB3aWR0aCBvZiB0aGUgZmlsbSAoZGVmYXVsdCBpbiBtaWxsaW1ldGVycylcblx0XHR0aGlzLmZpbG1PZmZzZXQgPSAwO1x0Ly8gaG9yaXpvbnRhbCBmaWxtIG9mZnNldCAoc2FtZSB1bml0IGFzIGdhdWdlKVxuXG5cdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlLCByZWN1cnNpdmUgKTtcblxuXHRcdHRoaXMuZm92ID0gc291cmNlLmZvdjtcblx0XHR0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcblxuXHRcdHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xuXHRcdHRoaXMuZmFyID0gc291cmNlLmZhcjtcblx0XHR0aGlzLmZvY3VzID0gc291cmNlLmZvY3VzO1xuXG5cdFx0dGhpcy5hc3BlY3QgPSBzb3VyY2UuYXNwZWN0O1xuXHRcdHRoaXMudmlldyA9IHNvdXJjZS52aWV3ID09PSBudWxsID8gbnVsbCA6IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UudmlldyApO1xuXG5cdFx0dGhpcy5maWxtR2F1Z2UgPSBzb3VyY2UuZmlsbUdhdWdlO1xuXHRcdHRoaXMuZmlsbU9mZnNldCA9IHNvdXJjZS5maWxtT2Zmc2V0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBGT1YgYnkgZm9jYWwgbGVuZ3RoIGluIHJlc3BlY3QgdG8gdGhlIGN1cnJlbnQgLmZpbG1HYXVnZS5cblx0ICpcblx0ICogVGhlIGRlZmF1bHQgZmlsbSBnYXVnZSBpcyAzNSwgc28gdGhhdCB0aGUgZm9jYWwgbGVuZ3RoIGNhbiBiZSBzcGVjaWZpZWQgZm9yXG5cdCAqIGEgMzVtbSAoZnVsbCBmcmFtZSkgY2FtZXJhLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZm9jYWxMZW5ndGggLSBWYWx1ZXMgZm9yIGZvY2FsIGxlbmd0aCBhbmQgZmlsbSBnYXVnZSBtdXN0IGhhdmUgdGhlIHNhbWUgdW5pdC5cblx0ICovXG5cdHNldEZvY2FsTGVuZ3RoKCBmb2NhbExlbmd0aCApIHtcblxuXHRcdC8qKiBzZWUge0BsaW5rIGh0dHA6Ly93d3cuYm9iYXRraW5zLmNvbS9waG90b2dyYXBoeS90ZWNobmljYWwvZmllbGRfb2Zfdmlldy5odG1sfSAqL1xuXHRcdGNvbnN0IHZFeHRlbnRTbG9wZSA9IDAuNSAqIHRoaXMuZ2V0RmlsbUhlaWdodCgpIC8gZm9jYWxMZW5ndGg7XG5cblx0XHR0aGlzLmZvdiA9IFJBRDJERUcgKiAyICogTWF0aC5hdGFuKCB2RXh0ZW50U2xvcGUgKTtcblx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZXMgdGhlIGZvY2FsIGxlbmd0aCBmcm9tIHRoZSBjdXJyZW50IC5mb3YgYW5kIC5maWxtR2F1Z2UuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRGb2NhbExlbmd0aCgpIHtcblxuXHRcdGNvbnN0IHZFeHRlbnRTbG9wZSA9IE1hdGgudGFuKCBERUcyUkFEICogMC41ICogdGhpcy5mb3YgKTtcblxuXHRcdHJldHVybiAwLjUgKiB0aGlzLmdldEZpbG1IZWlnaHQoKSAvIHZFeHRlbnRTbG9wZTtcblxuXHR9XG5cblx0Z2V0RWZmZWN0aXZlRk9WKCkge1xuXG5cdFx0cmV0dXJuIFJBRDJERUcgKiAyICogTWF0aC5hdGFuKFxuXHRcdFx0TWF0aC50YW4oIERFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdiApIC8gdGhpcy56b29tICk7XG5cblx0fVxuXG5cdGdldEZpbG1XaWR0aCgpIHtcblxuXHRcdC8vIGZpbG0gbm90IGNvbXBsZXRlbHkgY292ZXJlZCBpbiBwb3J0cmFpdCBmb3JtYXQgKGFzcGVjdCA8IDEpXG5cdFx0cmV0dXJuIHRoaXMuZmlsbUdhdWdlICogTWF0aC5taW4oIHRoaXMuYXNwZWN0LCAxICk7XG5cblx0fVxuXG5cdGdldEZpbG1IZWlnaHQoKSB7XG5cblx0XHQvLyBmaWxtIG5vdCBjb21wbGV0ZWx5IGNvdmVyZWQgaW4gbGFuZHNjYXBlIGZvcm1hdCAoYXNwZWN0ID4gMSlcblx0XHRyZXR1cm4gdGhpcy5maWxtR2F1Z2UgLyBNYXRoLm1heCggdGhpcy5hc3BlY3QsIDEgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSAyRCBib3VuZHMgb2YgdGhlIGNhbWVyYSdzIHZpZXdhYmxlIHJlY3RhbmdsZSBhdCBhIGdpdmVuIGRpc3RhbmNlIGFsb25nIHRoZSB2aWV3aW5nIGRpcmVjdGlvbi5cblx0ICogU2V0cyBtaW5UYXJnZXQgYW5kIG1heFRhcmdldCB0byB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGxvd2VyLWxlZnQgYW5kIHVwcGVyLXJpZ2h0IGNvcm5lcnMgb2YgdGhlIHZpZXcgcmVjdGFuZ2xlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2Vcblx0ICogQHBhcmFtIHtWZWN0b3IyfSBtaW5UYXJnZXRcblx0ICogQHBhcmFtIHtWZWN0b3IyfSBtYXhUYXJnZXRcblx0ICovXG5cdGdldFZpZXdCb3VuZHMoIGRpc3RhbmNlLCBtaW5UYXJnZXQsIG1heFRhcmdldCApIHtcblxuXHRcdF92MyQxLnNldCggLSAxLCAtIDEsIDAuNSApLmFwcGx5TWF0cml4NCggdGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSApO1xuXG5cdFx0bWluVGFyZ2V0LnNldCggX3YzJDEueCwgX3YzJDEueSApLm11bHRpcGx5U2NhbGFyKCAtIGRpc3RhbmNlIC8gX3YzJDEueiApO1xuXG5cdFx0X3YzJDEuc2V0KCAxLCAxLCAwLjUgKS5hcHBseU1hdHJpeDQoIHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UgKTtcblxuXHRcdG1heFRhcmdldC5zZXQoIF92MyQxLngsIF92MyQxLnkgKS5tdWx0aXBseVNjYWxhciggLSBkaXN0YW5jZSAvIF92MyQxLnogKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBjYW1lcmEncyB2aWV3YWJsZSByZWN0YW5nbGUgYXQgYSBnaXZlbiBkaXN0YW5jZSBhbG9uZyB0aGUgdmlld2luZyBkaXJlY3Rpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IHRhcmdldCAtIFZlY3RvcjIgdGFyZ2V0IHVzZWQgdG8gc3RvcmUgcmVzdWx0IHdoZXJlIHggaXMgd2lkdGggYW5kIHkgaXMgaGVpZ2h0LlxuXHQgKiBAcmV0dXJucyB7VmVjdG9yMn1cblx0ICovXG5cdGdldFZpZXdTaXplKCBkaXN0YW5jZSwgdGFyZ2V0ICkge1xuXG5cdFx0dGhpcy5nZXRWaWV3Qm91bmRzKCBkaXN0YW5jZSwgX21pblRhcmdldCwgX21heFRhcmdldCApO1xuXG5cdFx0cmV0dXJuIHRhcmdldC5zdWJWZWN0b3JzKCBfbWF4VGFyZ2V0LCBfbWluVGFyZ2V0ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIGFuIG9mZnNldCBpbiBhIGxhcmdlciBmcnVzdHVtLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbXVsdGktd2luZG93IG9yXG5cdCAqIG11bHRpLW1vbml0b3IvbXVsdGktbWFjaGluZSBzZXR1cHMuXG5cdCAqXG5cdCAqIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSAzeDIgbW9uaXRvcnMgYW5kIGVhY2ggbW9uaXRvciBpcyAxOTIweDEwODAgYW5kXG5cdCAqIHRoZSBtb25pdG9ycyBhcmUgaW4gZ3JpZCBsaWtlIHRoaXNcblx0ICpcblx0ICogICArLS0tKy0tLSstLS0rXG5cdCAqICAgfCBBIHwgQiB8IEMgfFxuXHQgKiAgICstLS0rLS0tKy0tLStcblx0ICogICB8IEQgfCBFIHwgRiB8XG5cdCAqICAgKy0tLSstLS0rLS0tK1xuXHQgKlxuXHQgKiB0aGVuIGZvciBlYWNoIG1vbml0b3IgeW91IHdvdWxkIGNhbGwgaXQgbGlrZSB0aGlzXG5cdCAqXG5cdCAqICAgY29uc3QgdyA9IDE5MjA7XG5cdCAqICAgY29uc3QgaCA9IDEwODA7XG5cdCAqICAgY29uc3QgZnVsbFdpZHRoID0gdyAqIDM7XG5cdCAqICAgY29uc3QgZnVsbEhlaWdodCA9IGggKiAyO1xuXHQgKlxuXHQgKiAgIC0tQS0tXG5cdCAqICAgY2FtZXJhLnNldFZpZXdPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAwLCB3LCBoICk7XG5cdCAqICAgLS1CLS1cblx0ICogICBjYW1lcmEuc2V0Vmlld09mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDAsIHcsIGggKTtcblx0ICogICAtLUMtLVxuXHQgKiAgIGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMCwgdywgaCApO1xuXHQgKiAgIC0tRC0tXG5cdCAqICAgY2FtZXJhLnNldFZpZXdPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAxLCB3LCBoICk7XG5cdCAqICAgLS1FLS1cblx0ICogICBjYW1lcmEuc2V0Vmlld09mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDEsIHcsIGggKTtcblx0ICogICAtLUYtLVxuXHQgKiAgIGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMSwgdywgaCApO1xuXHQgKlxuXHQgKiAgIE5vdGUgdGhlcmUgaXMgbm8gcmVhc29uIG1vbml0b3JzIGhhdmUgdG8gYmUgdGhlIHNhbWUgc2l6ZSBvciBpbiBhIGdyaWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBmdWxsV2lkdGhcblx0ICogQHBhcmFtIHtudW1iZXJ9IGZ1bGxIZWlnaHRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHhcblx0ICogQHBhcmFtIHtudW1iZXJ9IHlcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcblx0ICovXG5cdHNldFZpZXdPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcblxuXHRcdHRoaXMuYXNwZWN0ID0gZnVsbFdpZHRoIC8gZnVsbEhlaWdodDtcblxuXHRcdGlmICggdGhpcy52aWV3ID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLnZpZXcgPSB7XG5cdFx0XHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0XHRcdGZ1bGxXaWR0aDogMSxcblx0XHRcdFx0ZnVsbEhlaWdodDogMSxcblx0XHRcdFx0b2Zmc2V0WDogMCxcblx0XHRcdFx0b2Zmc2V0WTogMCxcblx0XHRcdFx0d2lkdGg6IDEsXG5cdFx0XHRcdGhlaWdodDogMVxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdHRoaXMudmlldy5lbmFibGVkID0gdHJ1ZTtcblx0XHR0aGlzLnZpZXcuZnVsbFdpZHRoID0gZnVsbFdpZHRoO1xuXHRcdHRoaXMudmlldy5mdWxsSGVpZ2h0ID0gZnVsbEhlaWdodDtcblx0XHR0aGlzLnZpZXcub2Zmc2V0WCA9IHg7XG5cdFx0dGhpcy52aWV3Lm9mZnNldFkgPSB5O1xuXHRcdHRoaXMudmlldy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMudmlldy5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHR9XG5cblx0Y2xlYXJWaWV3T2Zmc2V0KCkge1xuXG5cdFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMudmlldy5lbmFibGVkID0gZmFsc2U7XG5cblx0XHR9XG5cblx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHR9XG5cblx0dXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpIHtcblxuXHRcdGNvbnN0IG5lYXIgPSB0aGlzLm5lYXI7XG5cdFx0bGV0IHRvcCA9IG5lYXIgKiBNYXRoLnRhbiggREVHMlJBRCAqIDAuNSAqIHRoaXMuZm92ICkgLyB0aGlzLnpvb207XG5cdFx0bGV0IGhlaWdodCA9IDIgKiB0b3A7XG5cdFx0bGV0IHdpZHRoID0gdGhpcy5hc3BlY3QgKiBoZWlnaHQ7XG5cdFx0bGV0IGxlZnQgPSAtIDAuNSAqIHdpZHRoO1xuXHRcdGNvbnN0IHZpZXcgPSB0aGlzLnZpZXc7XG5cblx0XHRpZiAoIHRoaXMudmlldyAhPT0gbnVsbCAmJiB0aGlzLnZpZXcuZW5hYmxlZCApIHtcblxuXHRcdFx0Y29uc3QgZnVsbFdpZHRoID0gdmlldy5mdWxsV2lkdGgsXG5cdFx0XHRcdGZ1bGxIZWlnaHQgPSB2aWV3LmZ1bGxIZWlnaHQ7XG5cblx0XHRcdGxlZnQgKz0gdmlldy5vZmZzZXRYICogd2lkdGggLyBmdWxsV2lkdGg7XG5cdFx0XHR0b3AgLT0gdmlldy5vZmZzZXRZICogaGVpZ2h0IC8gZnVsbEhlaWdodDtcblx0XHRcdHdpZHRoICo9IHZpZXcud2lkdGggLyBmdWxsV2lkdGg7XG5cdFx0XHRoZWlnaHQgKj0gdmlldy5oZWlnaHQgLyBmdWxsSGVpZ2h0O1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2tldyA9IHRoaXMuZmlsbU9mZnNldDtcblx0XHRpZiAoIHNrZXcgIT09IDAgKSBsZWZ0ICs9IG5lYXIgKiBza2V3IC8gdGhpcy5nZXRGaWxtV2lkdGgoKTtcblxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUoIGxlZnQsIGxlZnQgKyB3aWR0aCwgdG9wLCB0b3AgLSBoZWlnaHQsIG5lYXIsIHRoaXMuZmFyLCB0aGlzLmNvb3JkaW5hdGVTeXN0ZW0gKTtcblxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weSggdGhpcy5wcm9qZWN0aW9uTWF0cml4ICkuaW52ZXJ0KCk7XG5cblx0fVxuXG5cdHRvSlNPTiggbWV0YSApIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oIG1ldGEgKTtcblxuXHRcdGRhdGEub2JqZWN0LmZvdiA9IHRoaXMuZm92O1xuXHRcdGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XG5cblx0XHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xuXHRcdGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xuXHRcdGRhdGEub2JqZWN0LmZvY3VzID0gdGhpcy5mb2N1cztcblxuXHRcdGRhdGEub2JqZWN0LmFzcGVjdCA9IHRoaXMuYXNwZWN0O1xuXG5cdFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSBkYXRhLm9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbigge30sIHRoaXMudmlldyApO1xuXG5cdFx0ZGF0YS5vYmplY3QuZmlsbUdhdWdlID0gdGhpcy5maWxtR2F1Z2U7XG5cdFx0ZGF0YS5vYmplY3QuZmlsbU9mZnNldCA9IHRoaXMuZmlsbU9mZnNldDtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxufVxuXG5jb25zdCBmb3YgPSAtIDkwOyAvLyBuZWdhdGl2ZSBmb3YgaXMgbm90IGFuIGVycm9yXG5jb25zdCBhc3BlY3QgPSAxO1xuXG5jbGFzcyBDdWJlQ2FtZXJhIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdGNvbnN0cnVjdG9yKCBuZWFyLCBmYXIsIHJlbmRlclRhcmdldCApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQ3ViZUNhbWVyYSc7XG5cblx0XHR0aGlzLnJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcblx0XHR0aGlzLmNvb3JkaW5hdGVTeXN0ZW0gPSBudWxsO1xuXHRcdHRoaXMuYWN0aXZlTWlwbWFwTGV2ZWwgPSAwO1xuXG5cdFx0Y29uc3QgY2FtZXJhUFggPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0XHRjYW1lcmFQWC5sYXllcnMgPSB0aGlzLmxheWVycztcblx0XHR0aGlzLmFkZCggY2FtZXJhUFggKTtcblxuXHRcdGNvbnN0IGNhbWVyYU5YID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdFx0Y2FtZXJhTlgubGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0dGhpcy5hZGQoIGNhbWVyYU5YICk7XG5cblx0XHRjb25zdCBjYW1lcmFQWSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHRcdGNhbWVyYVBZLmxheWVycyA9IHRoaXMubGF5ZXJzO1xuXHRcdHRoaXMuYWRkKCBjYW1lcmFQWSApO1xuXG5cdFx0Y29uc3QgY2FtZXJhTlkgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0XHRjYW1lcmFOWS5sYXllcnMgPSB0aGlzLmxheWVycztcblx0XHR0aGlzLmFkZCggY2FtZXJhTlkgKTtcblxuXHRcdGNvbnN0IGNhbWVyYVBaID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdFx0Y2FtZXJhUFoubGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0dGhpcy5hZGQoIGNhbWVyYVBaICk7XG5cblx0XHRjb25zdCBjYW1lcmFOWiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHRcdGNhbWVyYU5aLmxheWVycyA9IHRoaXMubGF5ZXJzO1xuXHRcdHRoaXMuYWRkKCBjYW1lcmFOWiApO1xuXG5cdH1cblxuXHR1cGRhdGVDb29yZGluYXRlU3lzdGVtKCkge1xuXG5cdFx0Y29uc3QgY29vcmRpbmF0ZVN5c3RlbSA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbTtcblxuXHRcdGNvbnN0IGNhbWVyYXMgPSB0aGlzLmNoaWxkcmVuLmNvbmNhdCgpO1xuXG5cdFx0Y29uc3QgWyBjYW1lcmFQWCwgY2FtZXJhTlgsIGNhbWVyYVBZLCBjYW1lcmFOWSwgY2FtZXJhUFosIGNhbWVyYU5aIF0gPSBjYW1lcmFzO1xuXG5cdFx0Zm9yICggY29uc3QgY2FtZXJhIG9mIGNhbWVyYXMgKSB0aGlzLnJlbW92ZSggY2FtZXJhICk7XG5cblx0XHRpZiAoIGNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0Y2FtZXJhUFgudXAuc2V0KCAwLCAxLCAwICk7XG5cdFx0XHRjYW1lcmFQWC5sb29rQXQoIDEsIDAsIDAgKTtcblxuXHRcdFx0Y2FtZXJhTlgudXAuc2V0KCAwLCAxLCAwICk7XG5cdFx0XHRjYW1lcmFOWC5sb29rQXQoIC0gMSwgMCwgMCApO1xuXG5cdFx0XHRjYW1lcmFQWS51cC5zZXQoIDAsIDAsIC0gMSApO1xuXHRcdFx0Y2FtZXJhUFkubG9va0F0KCAwLCAxLCAwICk7XG5cblx0XHRcdGNhbWVyYU5ZLnVwLnNldCggMCwgMCwgMSApO1xuXHRcdFx0Y2FtZXJhTlkubG9va0F0KCAwLCAtIDEsIDAgKTtcblxuXHRcdFx0Y2FtZXJhUFoudXAuc2V0KCAwLCAxLCAwICk7XG5cdFx0XHRjYW1lcmFQWi5sb29rQXQoIDAsIDAsIDEgKTtcblxuXHRcdFx0Y2FtZXJhTloudXAuc2V0KCAwLCAxLCAwICk7XG5cdFx0XHRjYW1lcmFOWi5sb29rQXQoIDAsIDAsIC0gMSApO1xuXG5cdFx0fSBlbHNlIGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0Y2FtZXJhUFgudXAuc2V0KCAwLCAtIDEsIDAgKTtcblx0XHRcdGNhbWVyYVBYLmxvb2tBdCggLSAxLCAwLCAwICk7XG5cblx0XHRcdGNhbWVyYU5YLnVwLnNldCggMCwgLSAxLCAwICk7XG5cdFx0XHRjYW1lcmFOWC5sb29rQXQoIDEsIDAsIDAgKTtcblxuXHRcdFx0Y2FtZXJhUFkudXAuc2V0KCAwLCAwLCAxICk7XG5cdFx0XHRjYW1lcmFQWS5sb29rQXQoIDAsIDEsIDAgKTtcblxuXHRcdFx0Y2FtZXJhTlkudXAuc2V0KCAwLCAwLCAtIDEgKTtcblx0XHRcdGNhbWVyYU5ZLmxvb2tBdCggMCwgLSAxLCAwICk7XG5cblx0XHRcdGNhbWVyYVBaLnVwLnNldCggMCwgLSAxLCAwICk7XG5cdFx0XHRjYW1lcmFQWi5sb29rQXQoIDAsIDAsIDEgKTtcblxuXHRcdFx0Y2FtZXJhTloudXAuc2V0KCAwLCAtIDEsIDAgKTtcblx0XHRcdGNhbWVyYU5aLmxvb2tBdCggMCwgMCwgLSAxICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5DdWJlQ2FtZXJhLnVwZGF0ZUNvb3JkaW5hdGVTeXN0ZW0oKTogSW52YWxpZCBjb29yZGluYXRlIHN5c3RlbTogJyArIGNvb3JkaW5hdGVTeXN0ZW0gKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGNvbnN0IGNhbWVyYSBvZiBjYW1lcmFzICkge1xuXG5cdFx0XHR0aGlzLmFkZCggY2FtZXJhICk7XG5cblx0XHRcdGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR1cGRhdGUoIHJlbmRlcmVyLCBzY2VuZSApIHtcblxuXHRcdGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHRjb25zdCB7IHJlbmRlclRhcmdldCwgYWN0aXZlTWlwbWFwTGV2ZWwgfSA9IHRoaXM7XG5cblx0XHRpZiAoIHRoaXMuY29vcmRpbmF0ZVN5c3RlbSAhPT0gcmVuZGVyZXIuY29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0dGhpcy5jb29yZGluYXRlU3lzdGVtID0gcmVuZGVyZXIuY29vcmRpbmF0ZVN5c3RlbTtcblxuXHRcdFx0dGhpcy51cGRhdGVDb29yZGluYXRlU3lzdGVtKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBbIGNhbWVyYVBYLCBjYW1lcmFOWCwgY2FtZXJhUFksIGNhbWVyYU5ZLCBjYW1lcmFQWiwgY2FtZXJhTlogXSA9IHRoaXMuY2hpbGRyZW47XG5cblx0XHRjb25zdCBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cdFx0Y29uc3QgY3VycmVudEFjdGl2ZUN1YmVGYWNlID0gcmVuZGVyZXIuZ2V0QWN0aXZlQ3ViZUZhY2UoKTtcblx0XHRjb25zdCBjdXJyZW50QWN0aXZlTWlwbWFwTGV2ZWwgPSByZW5kZXJlci5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpO1xuXG5cdFx0Y29uc3QgY3VycmVudFhyRW5hYmxlZCA9IHJlbmRlcmVyLnhyLmVuYWJsZWQ7XG5cblx0XHRyZW5kZXJlci54ci5lbmFibGVkID0gZmFsc2U7XG5cblx0XHRjb25zdCBnZW5lcmF0ZU1pcG1hcHMgPSByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XG5cblx0XHRyZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0LCAwLCBhY3RpdmVNaXBtYXBMZXZlbCApO1xuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBYICk7XG5cblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCwgMSwgYWN0aXZlTWlwbWFwTGV2ZWwgKTtcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWCApO1xuXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQsIDIsIGFjdGl2ZU1pcG1hcExldmVsICk7XG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFkgKTtcblxuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0LCAzLCBhY3RpdmVNaXBtYXBMZXZlbCApO1xuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5ZICk7XG5cblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCwgNCwgYWN0aXZlTWlwbWFwTGV2ZWwgKTtcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWiApO1xuXG5cdFx0Ly8gbWlwbWFwcyBhcmUgZ2VuZXJhdGVkIGR1cmluZyB0aGUgbGFzdCBjYWxsIG9mIHJlbmRlcigpXG5cdFx0Ly8gYXQgdGhpcyBwb2ludCwgYWxsIHNpZGVzIG9mIHRoZSBjdWJlIHJlbmRlciB0YXJnZXQgYXJlIGRlZmluZWRcblxuXHRcdHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGdlbmVyYXRlTWlwbWFwcztcblxuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0LCA1LCBhY3RpdmVNaXBtYXBMZXZlbCApO1xuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5aICk7XG5cblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIGN1cnJlbnRSZW5kZXJUYXJnZXQsIGN1cnJlbnRBY3RpdmVDdWJlRmFjZSwgY3VycmVudEFjdGl2ZU1pcG1hcExldmVsICk7XG5cblx0XHRyZW5kZXJlci54ci5lbmFibGVkID0gY3VycmVudFhyRW5hYmxlZDtcblxuXHRcdHJlbmRlclRhcmdldC50ZXh0dXJlLm5lZWRzUE1SRU1VcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxufVxuXG5jbGFzcyBDdWJlVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG5cdGNvbnN0cnVjdG9yKCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgY29sb3JTcGFjZSApIHtcblxuXHRcdGltYWdlcyA9IGltYWdlcyAhPT0gdW5kZWZpbmVkID8gaW1hZ2VzIDogW107XG5cdFx0bWFwcGluZyA9IG1hcHBpbmcgIT09IHVuZGVmaW5lZCA/IG1hcHBpbmcgOiBDdWJlUmVmbGVjdGlvbk1hcHBpbmc7XG5cblx0XHRzdXBlciggaW1hZ2VzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHksIGNvbG9yU3BhY2UgKTtcblxuXHRcdHRoaXMuaXNDdWJlVGV4dHVyZSA9IHRydWU7XG5cblx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XG5cblx0fVxuXG5cdGdldCBpbWFnZXMoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5pbWFnZTtcblxuXHR9XG5cblx0c2V0IGltYWdlcyggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmltYWdlID0gdmFsdWU7XG5cblx0fVxuXG59XG5cbmNsYXNzIFdlYkdMQ3ViZVJlbmRlclRhcmdldCBleHRlbmRzIFdlYkdMUmVuZGVyVGFyZ2V0IHtcblxuXHRjb25zdHJ1Y3Rvciggc2l6ZSA9IDEsIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdHN1cGVyKCBzaXplLCBzaXplLCBvcHRpb25zICk7XG5cblx0XHR0aGlzLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ID0gdHJ1ZTtcblxuXHRcdGNvbnN0IGltYWdlID0geyB3aWR0aDogc2l6ZSwgaGVpZ2h0OiBzaXplLCBkZXB0aDogMSB9O1xuXHRcdGNvbnN0IGltYWdlcyA9IFsgaW1hZ2UsIGltYWdlLCBpbWFnZSwgaW1hZ2UsIGltYWdlLCBpbWFnZSBdO1xuXG5cdFx0dGhpcy50ZXh0dXJlID0gbmV3IEN1YmVUZXh0dXJlKCBpbWFnZXMsIG9wdGlvbnMubWFwcGluZywgb3B0aW9ucy53cmFwUywgb3B0aW9ucy53cmFwVCwgb3B0aW9ucy5tYWdGaWx0ZXIsIG9wdGlvbnMubWluRmlsdGVyLCBvcHRpb25zLmZvcm1hdCwgb3B0aW9ucy50eXBlLCBvcHRpb25zLmFuaXNvdHJvcHksIG9wdGlvbnMuY29sb3JTcGFjZSApO1xuXG5cdFx0Ly8gQnkgY29udmVudGlvbiAtLSBsaWtlbHkgYmFzZWQgb24gdGhlIFJlbmRlck1hbiBzcGVjIGZyb20gdGhlIDE5OTAncyAtLSBjdWJlIG1hcHMgYXJlIHNwZWNpZmllZCBieSBXZWJHTCAoYW5kIHRocmVlLmpzKVxuXHRcdC8vIGluIGEgY29vcmRpbmF0ZSBzeXN0ZW0gaW4gd2hpY2ggcG9zaXRpdmUteCBpcyB0byB0aGUgcmlnaHQgd2hlbiBsb29raW5nIHVwIHRoZSBwb3NpdGl2ZS16IGF4aXMgLS0gaW4gb3RoZXIgd29yZHMsXG5cdFx0Ly8gaW4gYSBsZWZ0LWhhbmRlZCBjb29yZGluYXRlIHN5c3RlbS4gQnkgY29udGludWluZyB0aGlzIGNvbnZlbnRpb24sIHByZWV4aXN0aW5nIGN1YmUgbWFwcyBjb250aW51ZWQgdG8gcmVuZGVyIGNvcnJlY3RseS5cblxuXHRcdC8vIHRocmVlLmpzIHVzZXMgYSByaWdodC1oYW5kZWQgY29vcmRpbmF0ZSBzeXN0ZW0uIFNvIGVudmlyb25tZW50IG1hcHMgdXNlZCBpbiB0aHJlZS5qcyBhcHBlYXIgdG8gaGF2ZSBweCBhbmQgbnggc3dhcHBlZFxuXHRcdC8vIGFuZCB0aGUgZmxhZyBpc1JlbmRlclRhcmdldFRleHR1cmUgY29udHJvbHMgdGhpcyBjb252ZXJzaW9uLiBUaGUgZmxpcCBpcyBub3QgcmVxdWlyZWQgd2hlbiB1c2luZyBXZWJHTEN1YmVSZW5kZXJUYXJnZXQudGV4dHVyZVxuXHRcdC8vIGFzIGEgY3ViZSB0ZXh0dXJlICh0aGlzIGlzIGRldGVjdGVkIHdoZW4gaXNSZW5kZXJUYXJnZXRUZXh0dXJlIGlzIHNldCB0byB0cnVlIGZvciBjdWJlIHRleHR1cmVzKS5cblxuXHRcdHRoaXMudGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0cnVlO1xuXG5cdFx0dGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IG9wdGlvbnMuZ2VuZXJhdGVNaXBtYXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmdlbmVyYXRlTWlwbWFwcyA6IGZhbHNlO1xuXHRcdHRoaXMudGV4dHVyZS5taW5GaWx0ZXIgPSBvcHRpb25zLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5GaWx0ZXIgOiBMaW5lYXJGaWx0ZXI7XG5cblx0fVxuXG5cdGZyb21FcXVpcmVjdGFuZ3VsYXJUZXh0dXJlKCByZW5kZXJlciwgdGV4dHVyZSApIHtcblxuXHRcdHRoaXMudGV4dHVyZS50eXBlID0gdGV4dHVyZS50eXBlO1xuXHRcdHRoaXMudGV4dHVyZS5jb2xvclNwYWNlID0gdGV4dHVyZS5jb2xvclNwYWNlO1xuXG5cdFx0dGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzO1xuXHRcdHRoaXMudGV4dHVyZS5taW5GaWx0ZXIgPSB0ZXh0dXJlLm1pbkZpbHRlcjtcblx0XHR0aGlzLnRleHR1cmUubWFnRmlsdGVyID0gdGV4dHVyZS5tYWdGaWx0ZXI7XG5cblx0XHRjb25zdCBzaGFkZXIgPSB7XG5cblx0XHRcdHVuaWZvcm1zOiB7XG5cdFx0XHRcdHRFcXVpcmVjdDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0fSxcblxuXHRcdFx0dmVydGV4U2hhZGVyOiAvKiBnbHNsICovYFxuXG5cdFx0XHRcdHZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247XG5cblx0XHRcdFx0dmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggZGlyLCAwLjAgKSApLnh5eiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2b2lkIG1haW4oKSB7XG5cblx0XHRcdFx0XHR2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xuXG5cdFx0XHRcdFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cblx0XHRcdFx0XHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XG5cblx0XHRcdFx0fVxuXHRcdFx0YCxcblxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IC8qIGdsc2wgKi9gXG5cblx0XHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdEVxdWlyZWN0O1xuXG5cdFx0XHRcdHZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247XG5cblx0XHRcdFx0I2luY2x1ZGUgPGNvbW1vbj5cblxuXHRcdFx0XHR2b2lkIG1haW4oKSB7XG5cblx0XHRcdFx0XHR2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdldvcmxkRGlyZWN0aW9uICk7XG5cblx0XHRcdFx0XHR2ZWMyIHNhbXBsZVVWID0gZXF1aXJlY3RVdiggZGlyZWN0aW9uICk7XG5cblx0XHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHRFcXVpcmVjdCwgc2FtcGxlVVYgKTtcblxuXHRcdFx0XHR9XG5cdFx0XHRgXG5cdFx0fTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJveEdlb21ldHJ5KCA1LCA1LCA1ICk7XG5cblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBTaGFkZXJNYXRlcmlhbCgge1xuXG5cdFx0XHRuYW1lOiAnQ3ViZW1hcEZyb21FcXVpcmVjdCcsXG5cblx0XHRcdHVuaWZvcm1zOiBjbG9uZVVuaWZvcm1zKCBzaGFkZXIudW5pZm9ybXMgKSxcblx0XHRcdHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBzaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG5cdFx0XHRzaWRlOiBCYWNrU2lkZSxcblx0XHRcdGJsZW5kaW5nOiBOb0JsZW5kaW5nXG5cblx0XHR9ICk7XG5cblx0XHRtYXRlcmlhbC51bmlmb3Jtcy50RXF1aXJlY3QudmFsdWUgPSB0ZXh0dXJlO1xuXG5cdFx0Y29uc3QgbWVzaCA9IG5ldyBNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdGNvbnN0IGN1cnJlbnRNaW5GaWx0ZXIgPSB0ZXh0dXJlLm1pbkZpbHRlcjtcblxuXHRcdC8vIEF2b2lkIGJsdXJyZWQgcG9sZXNcblx0XHRpZiAoIHRleHR1cmUubWluRmlsdGVyID09PSBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIgKSB0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcblxuXHRcdGNvbnN0IGNhbWVyYSA9IG5ldyBDdWJlQ2FtZXJhKCAxLCAxMCwgdGhpcyApO1xuXHRcdGNhbWVyYS51cGRhdGUoIHJlbmRlcmVyLCBtZXNoICk7XG5cblx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IGN1cnJlbnRNaW5GaWx0ZXI7XG5cblx0XHRtZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHRtZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGVhciggcmVuZGVyZXIsIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcblxuXHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggdGhpcywgaSApO1xuXG5cdFx0XHRyZW5kZXJlci5jbGVhciggY29sb3IsIGRlcHRoLCBzdGVuY2lsICk7XG5cblx0XHR9XG5cblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIGN1cnJlbnRSZW5kZXJUYXJnZXQgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgRm9nRXhwMiB7XG5cblx0Y29uc3RydWN0b3IoIGNvbG9yLCBkZW5zaXR5ID0gMC4wMDAyNSApIHtcblxuXHRcdHRoaXMuaXNGb2dFeHAyID0gdHJ1ZTtcblxuXHRcdHRoaXMubmFtZSA9ICcnO1xuXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggY29sb3IgKTtcblx0XHR0aGlzLmRlbnNpdHkgPSBkZW5zaXR5O1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgRm9nRXhwMiggdGhpcy5jb2xvciwgdGhpcy5kZW5zaXR5ICk7XG5cblx0fVxuXG5cdHRvSlNPTiggLyogbWV0YSAqLyApIHtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiAnRm9nRXhwMicsXG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsXG5cdFx0XHRjb2xvcjogdGhpcy5jb2xvci5nZXRIZXgoKSxcblx0XHRcdGRlbnNpdHk6IHRoaXMuZGVuc2l0eVxuXHRcdH07XG5cblx0fVxuXG59XG5cbmNsYXNzIEZvZyB7XG5cblx0Y29uc3RydWN0b3IoIGNvbG9yLCBuZWFyID0gMSwgZmFyID0gMTAwMCApIHtcblxuXHRcdHRoaXMuaXNGb2cgPSB0cnVlO1xuXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCBjb2xvciApO1xuXG5cdFx0dGhpcy5uZWFyID0gbmVhcjtcblx0XHR0aGlzLmZhciA9IGZhcjtcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IEZvZyggdGhpcy5jb2xvciwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xuXG5cdH1cblxuXHR0b0pTT04oIC8qIG1ldGEgKi8gKSB7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogJ0ZvZycsXG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsXG5cdFx0XHRjb2xvcjogdGhpcy5jb2xvci5nZXRIZXgoKSxcblx0XHRcdG5lYXI6IHRoaXMubmVhcixcblx0XHRcdGZhcjogdGhpcy5mYXJcblx0XHR9O1xuXG5cdH1cblxufVxuXG5jbGFzcyBTY2VuZSBleHRlbmRzIE9iamVjdDNEIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzU2NlbmUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1NjZW5lJztcblxuXHRcdHRoaXMuYmFja2dyb3VuZCA9IG51bGw7XG5cdFx0dGhpcy5lbnZpcm9ubWVudCA9IG51bGw7XG5cdFx0dGhpcy5mb2cgPSBudWxsO1xuXG5cdFx0dGhpcy5iYWNrZ3JvdW5kQmx1cnJpbmVzcyA9IDA7XG5cdFx0dGhpcy5iYWNrZ3JvdW5kSW50ZW5zaXR5ID0gMTtcblx0XHR0aGlzLmJhY2tncm91bmRSb3RhdGlvbiA9IG5ldyBFdWxlcigpO1xuXG5cdFx0dGhpcy5lbnZpcm9ubWVudEludGVuc2l0eSA9IDE7XG5cdFx0dGhpcy5lbnZpcm9ubWVudFJvdGF0aW9uID0gbmV3IEV1bGVyKCk7XG5cblx0XHR0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBudWxsO1xuXG5cdFx0aWYgKCB0eXBlb2YgX19USFJFRV9ERVZUT09MU19fICE9PSAndW5kZWZpbmVkJyApIHtcblxuXHRcdFx0X19USFJFRV9ERVZUT09MU19fLmRpc3BhdGNoRXZlbnQoIG5ldyBDdXN0b21FdmVudCggJ29ic2VydmUnLCB7IGRldGFpbDogdGhpcyB9ICkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0aWYgKCBzb3VyY2UuYmFja2dyb3VuZCAhPT0gbnVsbCApIHRoaXMuYmFja2dyb3VuZCA9IHNvdXJjZS5iYWNrZ3JvdW5kLmNsb25lKCk7XG5cdFx0aWYgKCBzb3VyY2UuZW52aXJvbm1lbnQgIT09IG51bGwgKSB0aGlzLmVudmlyb25tZW50ID0gc291cmNlLmVudmlyb25tZW50LmNsb25lKCk7XG5cdFx0aWYgKCBzb3VyY2UuZm9nICE9PSBudWxsICkgdGhpcy5mb2cgPSBzb3VyY2UuZm9nLmNsb25lKCk7XG5cblx0XHR0aGlzLmJhY2tncm91bmRCbHVycmluZXNzID0gc291cmNlLmJhY2tncm91bmRCbHVycmluZXNzO1xuXHRcdHRoaXMuYmFja2dyb3VuZEludGVuc2l0eSA9IHNvdXJjZS5iYWNrZ3JvdW5kSW50ZW5zaXR5O1xuXHRcdHRoaXMuYmFja2dyb3VuZFJvdGF0aW9uLmNvcHkoIHNvdXJjZS5iYWNrZ3JvdW5kUm90YXRpb24gKTtcblxuXHRcdHRoaXMuZW52aXJvbm1lbnRJbnRlbnNpdHkgPSBzb3VyY2UuZW52aXJvbm1lbnRJbnRlbnNpdHk7XG5cdFx0dGhpcy5lbnZpcm9ubWVudFJvdGF0aW9uLmNvcHkoIHNvdXJjZS5lbnZpcm9ubWVudFJvdGF0aW9uICk7XG5cblx0XHRpZiAoIHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsICE9PSBudWxsICkgdGhpcy5vdmVycmlkZU1hdGVyaWFsID0gc291cmNlLm92ZXJyaWRlTWF0ZXJpYWwuY2xvbmUoKTtcblxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTiggbWV0YSApIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oIG1ldGEgKTtcblxuXHRcdGlmICggdGhpcy5mb2cgIT09IG51bGwgKSBkYXRhLm9iamVjdC5mb2cgPSB0aGlzLmZvZy50b0pTT04oKTtcblxuXHRcdGlmICggdGhpcy5iYWNrZ3JvdW5kQmx1cnJpbmVzcyA+IDAgKSBkYXRhLm9iamVjdC5iYWNrZ3JvdW5kQmx1cnJpbmVzcyA9IHRoaXMuYmFja2dyb3VuZEJsdXJyaW5lc3M7XG5cdFx0aWYgKCB0aGlzLmJhY2tncm91bmRJbnRlbnNpdHkgIT09IDEgKSBkYXRhLm9iamVjdC5iYWNrZ3JvdW5kSW50ZW5zaXR5ID0gdGhpcy5iYWNrZ3JvdW5kSW50ZW5zaXR5O1xuXHRcdGRhdGEub2JqZWN0LmJhY2tncm91bmRSb3RhdGlvbiA9IHRoaXMuYmFja2dyb3VuZFJvdGF0aW9uLnRvQXJyYXkoKTtcblxuXHRcdGlmICggdGhpcy5lbnZpcm9ubWVudEludGVuc2l0eSAhPT0gMSApIGRhdGEub2JqZWN0LmVudmlyb25tZW50SW50ZW5zaXR5ID0gdGhpcy5lbnZpcm9ubWVudEludGVuc2l0eTtcblx0XHRkYXRhLm9iamVjdC5lbnZpcm9ubWVudFJvdGF0aW9uID0gdGhpcy5lbnZpcm9ubWVudFJvdGF0aW9uLnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxufVxuXG5jbGFzcyBJbnRlcmxlYXZlZEJ1ZmZlciB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBzdHJpZGUgKSB7XG5cblx0XHR0aGlzLmlzSW50ZXJsZWF2ZWRCdWZmZXIgPSB0cnVlO1xuXG5cdFx0dGhpcy5hcnJheSA9IGFycmF5O1xuXHRcdHRoaXMuc3RyaWRlID0gc3RyaWRlO1xuXHRcdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gc3RyaWRlIDogMDtcblxuXHRcdHRoaXMudXNhZ2UgPSBTdGF0aWNEcmF3VXNhZ2U7XG5cdFx0dGhpcy51cGRhdGVSYW5nZXMgPSBbXTtcblxuXHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cblx0XHR0aGlzLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblxuXHR9XG5cblx0b25VcGxvYWRDYWxsYmFjaygpIHt9XG5cblx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XG5cblx0fVxuXG5cdHNldFVzYWdlKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMudXNhZ2UgPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGRVcGRhdGVSYW5nZSggc3RhcnQsIGNvdW50ICkge1xuXG5cdFx0dGhpcy51cGRhdGVSYW5nZXMucHVzaCggeyBzdGFydCwgY291bnQgfSApO1xuXG5cdH1cblxuXHRjbGVhclVwZGF0ZVJhbmdlcygpIHtcblxuXHRcdHRoaXMudXBkYXRlUmFuZ2VzLmxlbmd0aCA9IDA7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcblx0XHR0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xuXHRcdHRoaXMuc3RyaWRlID0gc291cmNlLnN0cmlkZTtcblx0XHR0aGlzLnVzYWdlID0gc291cmNlLnVzYWdlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHlBdCggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcblxuXHRcdGluZGV4MSAqPSB0aGlzLnN0cmlkZTtcblx0XHRpbmRleDIgKj0gYXR0cmlidXRlLnN0cmlkZTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuc3RyaWRlOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5hcnJheVsgaW5kZXgxICsgaSBdID0gYXR0cmlidXRlLmFycmF5WyBpbmRleDIgKyBpIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0KCB2YWx1ZSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoIGRhdGEgKSB7XG5cblx0XHRpZiAoIGRhdGEuYXJyYXlCdWZmZXJzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGRhdGEuYXJyYXlCdWZmZXJzID0ge307XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGRhdGEuYXJyYXlCdWZmZXJzWyB0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGRhdGEuYXJyYXlCdWZmZXJzWyB0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCBdID0gdGhpcy5hcnJheS5zbGljZSggMCApLmJ1ZmZlcjtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGFycmF5ID0gbmV3IHRoaXMuYXJyYXkuY29uc3RydWN0b3IoIGRhdGEuYXJyYXlCdWZmZXJzWyB0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCBdICk7XG5cblx0XHRjb25zdCBpYiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCBhcnJheSwgdGhpcy5zdHJpZGUgKTtcblx0XHRpYi5zZXRVc2FnZSggdGhpcy51c2FnZSApO1xuXG5cdFx0cmV0dXJuIGliO1xuXG5cdH1cblxuXHRvblVwbG9hZCggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLm9uVXBsb2FkQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oIGRhdGEgKSB7XG5cblx0XHRpZiAoIGRhdGEuYXJyYXlCdWZmZXJzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGRhdGEuYXJyYXlCdWZmZXJzID0ge307XG5cblx0XHR9XG5cblx0XHQvLyBnZW5lcmF0ZSBVVUlEIGZvciBhcnJheSBidWZmZXIgaWYgbmVjZXNzYXJ5XG5cblx0XHRpZiAoIHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGRhdGEuYXJyYXlCdWZmZXJzWyB0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGRhdGEuYXJyYXlCdWZmZXJzWyB0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCBdID0gQXJyYXkuZnJvbSggbmV3IFVpbnQzMkFycmF5KCB0aGlzLmFycmF5LmJ1ZmZlciApICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcblx0XHRcdGJ1ZmZlcjogdGhpcy5hcnJheS5idWZmZXIuX3V1aWQsXG5cdFx0XHR0eXBlOiB0aGlzLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG5cdFx0XHRzdHJpZGU6IHRoaXMuc3RyaWRlXG5cdFx0fTtcblxuXHR9XG5cbn1cblxuY29uc3QgX3ZlY3RvciQ3ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGludGVybGVhdmVkQnVmZmVyLCBpdGVtU2l6ZSwgb2Zmc2V0LCBub3JtYWxpemVkID0gZmFsc2UgKSB7XG5cblx0XHR0aGlzLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cblx0XHR0aGlzLmRhdGEgPSBpbnRlcmxlYXZlZEJ1ZmZlcjtcblx0XHR0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XG5cdFx0dGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG5cblx0XHR0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkO1xuXG5cdH1cblxuXHRnZXQgY291bnQoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kYXRhLmNvdW50O1xuXG5cdH1cblxuXHRnZXQgYXJyYXkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5O1xuXG5cdH1cblxuXHRzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5kYXRhLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4NCggbSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuZGF0YS5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdF92ZWN0b3IkNy5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XG5cblx0XHRcdF92ZWN0b3IkNy5hcHBseU1hdHJpeDQoIG0gKTtcblxuXHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IkNy54LCBfdmVjdG9yJDcueSwgX3ZlY3RvciQ3LnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU5vcm1hbE1hdHJpeCggbSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRfdmVjdG9yJDcuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xuXG5cdFx0XHRfdmVjdG9yJDcuYXBwbHlOb3JtYWxNYXRyaXgoIG0gKTtcblxuXHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IkNy54LCBfdmVjdG9yJDcueSwgX3ZlY3RvciQ3LnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2Zvcm1EaXJlY3Rpb24oIG0gKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0X3ZlY3RvciQ3LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHRoaXMsIGkgKTtcblxuXHRcdFx0X3ZlY3RvciQ3LnRyYW5zZm9ybURpcmVjdGlvbiggbSApO1xuXG5cdFx0XHR0aGlzLnNldFhZWiggaSwgX3ZlY3RvciQ3LngsIF92ZWN0b3IkNy55LCBfdmVjdG9yJDcueiApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldENvbXBvbmVudCggaW5kZXgsIGNvbXBvbmVudCApIHtcblxuXHRcdGxldCB2YWx1ZSA9IHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgY29tcG9uZW50IF07XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHZhbHVlID0gZGVub3JtYWxpemUoIHZhbHVlLCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cblx0fVxuXG5cdHNldENvbXBvbmVudCggaW5kZXgsIGNvbXBvbmVudCwgdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHZhbHVlID0gbm9ybWFsaXplKCB2YWx1ZSwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIGNvbXBvbmVudCBdID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WCggaW5kZXgsIHggKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgXSA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WSggaW5kZXgsIHkgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxIF0gPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFooIGluZGV4LCB6ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRXKCBpbmRleCwgdyApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdyA9IG5vcm1hbGl6ZSggdywgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDMgXSA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0WCggaW5kZXggKSB7XG5cblx0XHRsZXQgeCA9IHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeCA9IGRlbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4geDtcblxuXHR9XG5cblx0Z2V0WSggaW5kZXggKSB7XG5cblx0XHRsZXQgeSA9IHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxIF07XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHkgPSBkZW5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHk7XG5cblx0fVxuXG5cdGdldFooIGluZGV4ICkge1xuXG5cdFx0bGV0IHogPSB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gZGVub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB6O1xuXG5cdH1cblxuXHRnZXRXKCBpbmRleCApIHtcblxuXHRcdGxldCB3ID0gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDMgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdyA9IGRlbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4gdztcblxuXHR9XG5cblx0c2V0WFkoIGluZGV4LCB4LCB5ICkge1xuXG5cdFx0aW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYWVooIGluZGV4LCB4LCB5LCB6ICkge1xuXG5cdFx0aW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYWVpXKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcblxuXHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHtcblxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXHRcdFx0eSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXHRcdFx0eiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXHRcdFx0dyA9IG5vcm1hbGl6ZSggdywgdGhpcy5hcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoIGRhdGEgKSB7XG5cblx0XHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5jbG9uZSgpOiBDbG9uaW5nIGFuIGludGVybGVhdmVkIGJ1ZmZlciBhdHRyaWJ1dGUgd2lsbCBkZS1pbnRlcmxlYXZlIGJ1ZmZlciBkYXRhLicgKTtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy5jb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGkgKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgdGhpcy5pdGVtU2l6ZTsgaiArKyApIHtcblxuXHRcdFx0XHRcdGFycmF5LnB1c2goIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyBqIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyB0aGlzLmFycmF5LmNvbnN0cnVjdG9yKCBhcnJheSApLCB0aGlzLml0ZW1TaXplLCB0aGlzLm5vcm1hbGl6ZWQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRkYXRhLmludGVybGVhdmVkQnVmZmVycyA9IHt9O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnNbIHRoaXMuZGF0YS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRkYXRhLmludGVybGVhdmVkQnVmZmVyc1sgdGhpcy5kYXRhLnV1aWQgXSA9IHRoaXMuZGF0YS5jbG9uZSggZGF0YSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoIGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzWyB0aGlzLmRhdGEudXVpZCBdLCB0aGlzLml0ZW1TaXplLCB0aGlzLm9mZnNldCwgdGhpcy5ub3JtYWxpemVkICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRvSlNPTiggZGF0YSApIHtcblxuXHRcdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLmxvZyggJ1RIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLnRvSlNPTigpOiBTZXJpYWxpemluZyBhbiBpbnRlcmxlYXZlZCBidWZmZXIgYXR0cmlidXRlIHdpbGwgZGUtaW50ZXJsZWF2ZSBidWZmZXIgZGF0YS4nICk7XG5cblx0XHRcdGNvbnN0IGFycmF5ID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMuY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW5kZXggPSBpICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IHRoaXMuaXRlbVNpemU7IGogKysgKSB7XG5cblx0XHRcdFx0XHRhcnJheS5wdXNoKCB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgaiBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGRlLWludGVybGVhdmUgZGF0YSBhbmQgc2F2ZSBpdCBhcyBhbiBvcmRpbmFyeSBidWZmZXIgYXR0cmlidXRlIGZvciBub3dcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aXRlbVNpemU6IHRoaXMuaXRlbVNpemUsXG5cdFx0XHRcdHR5cGU6IHRoaXMuYXJyYXkuY29uc3RydWN0b3IubmFtZSxcblx0XHRcdFx0YXJyYXk6IGFycmF5LFxuXHRcdFx0XHRub3JtYWxpemVkOiB0aGlzLm5vcm1hbGl6ZWRcblx0XHRcdH07XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBzYXZlIGFzIHRydWUgaW50ZXJsZWF2ZWQgYXR0cmlidXRlXG5cblx0XHRcdGlmICggZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRkYXRhLmludGVybGVhdmVkQnVmZmVycyA9IHt9O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnNbIHRoaXMuZGF0YS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRkYXRhLmludGVybGVhdmVkQnVmZmVyc1sgdGhpcy5kYXRhLnV1aWQgXSA9IHRoaXMuZGF0YS50b0pTT04oIGRhdGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRpc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlOiB0cnVlLFxuXHRcdFx0XHRpdGVtU2l6ZTogdGhpcy5pdGVtU2l6ZSxcblx0XHRcdFx0ZGF0YTogdGhpcy5kYXRhLnV1aWQsXG5cdFx0XHRcdG9mZnNldDogdGhpcy5vZmZzZXQsXG5cdFx0XHRcdG5vcm1hbGl6ZWQ6IHRoaXMubm9ybWFsaXplZFxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuY2xhc3MgU3ByaXRlTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc1Nwcml0ZU1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdTcHJpdGVNYXRlcmlhbCc7XG5cblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xuXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cblx0XHR0aGlzLnJvdGF0aW9uID0gMDtcblxuXHRcdHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gdHJ1ZTtcblxuXHRcdHRoaXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuXHRcdHRoaXMucm90YXRpb24gPSBzb3VyY2Uucm90YXRpb247XG5cblx0XHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XG5cblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxubGV0IF9nZW9tZXRyeTtcblxuY29uc3QgX2ludGVyc2VjdFBvaW50ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3dvcmxkU2NhbGUgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfbXZQb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX2FsaWduZWRQb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcbmNvbnN0IF9yb3RhdGVkUG9zaXRpb24gPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XG5jb25zdCBfdmlld1dvcmxkTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuXG5jb25zdCBfdkEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdkIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdkMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNvbnN0IF91dkEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XG5jb25zdCBfdXZCID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMigpO1xuY29uc3QgX3V2QyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcblxuY2xhc3MgU3ByaXRlIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdGNvbnN0cnVjdG9yKCBtYXRlcmlhbCA9IG5ldyBTcHJpdGVNYXRlcmlhbCgpICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNTcHJpdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1Nwcml0ZSc7XG5cblx0XHRpZiAoIF9nZW9tZXRyeSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRfZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdFx0Y29uc3QgZmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggW1xuXHRcdFx0XHQtIDAuNSwgLSAwLjUsIDAsIDAsIDAsXG5cdFx0XHRcdDAuNSwgLSAwLjUsIDAsIDEsIDAsXG5cdFx0XHRcdDAuNSwgMC41LCAwLCAxLCAxLFxuXHRcdFx0XHQtIDAuNSwgMC41LCAwLCAwLCAxXG5cdFx0XHRdICk7XG5cblx0XHRcdGNvbnN0IGludGVybGVhdmVkQnVmZmVyID0gbmV3IEludGVybGVhdmVkQnVmZmVyKCBmbG9hdDMyQXJyYXksIDUgKTtcblxuXHRcdFx0X2dlb21ldHJ5LnNldEluZGV4KCBbIDAsIDEsIDIsXHQwLCAyLCAzIF0gKTtcblx0XHRcdF9nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSggaW50ZXJsZWF2ZWRCdWZmZXIsIDMsIDAsIGZhbHNlICkgKTtcblx0XHRcdF9nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSggaW50ZXJsZWF2ZWRCdWZmZXIsIDIsIDMsIGZhbHNlICkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBfZ2VvbWV0cnk7XG5cdFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXG5cdFx0dGhpcy5jZW50ZXIgPSBuZXcgVmVjdG9yMiggMC41LCAwLjUgKTtcblxuXHR9XG5cblx0cmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0aWYgKCByYXljYXN0ZXIuY2FtZXJhID09PSBudWxsICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuU3ByaXRlOiBcIlJheWNhc3Rlci5jYW1lcmFcIiBuZWVkcyB0byBiZSBzZXQgaW4gb3JkZXIgdG8gcmF5Y2FzdCBhZ2FpbnN0IHNwcml0ZXMuJyApO1xuXG5cdFx0fVxuXG5cdFx0X3dvcmxkU2NhbGUuc2V0RnJvbU1hdHJpeFNjYWxlKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHRfdmlld1dvcmxkTWF0cml4LmNvcHkoIHJheWNhc3Rlci5jYW1lcmEubWF0cml4V29ybGQgKTtcblx0XHR0aGlzLm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCByYXljYXN0ZXIuY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0X212UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1vZGVsVmlld01hdHJpeCApO1xuXG5cdFx0aWYgKCByYXljYXN0ZXIuY2FtZXJhLmlzUGVyc3BlY3RpdmVDYW1lcmEgJiYgdGhpcy5tYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPT09IGZhbHNlICkge1xuXG5cdFx0XHRfd29ybGRTY2FsZS5tdWx0aXBseVNjYWxhciggLSBfbXZQb3NpdGlvbi56ICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCByb3RhdGlvbiA9IHRoaXMubWF0ZXJpYWwucm90YXRpb247XG5cdFx0bGV0IHNpbiwgY29zO1xuXG5cdFx0aWYgKCByb3RhdGlvbiAhPT0gMCApIHtcblxuXHRcdFx0Y29zID0gTWF0aC5jb3MoIHJvdGF0aW9uICk7XG5cdFx0XHRzaW4gPSBNYXRoLnNpbiggcm90YXRpb24gKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGNlbnRlciA9IHRoaXMuY2VudGVyO1xuXG5cdFx0dHJhbnNmb3JtVmVydGV4KCBfdkEuc2V0KCAtIDAuNSwgLSAwLjUsIDAgKSwgX212UG9zaXRpb24sIGNlbnRlciwgX3dvcmxkU2NhbGUsIHNpbiwgY29zICk7XG5cdFx0dHJhbnNmb3JtVmVydGV4KCBfdkIuc2V0KCAwLjUsIC0gMC41LCAwICksIF9tdlBvc2l0aW9uLCBjZW50ZXIsIF93b3JsZFNjYWxlLCBzaW4sIGNvcyApO1xuXHRcdHRyYW5zZm9ybVZlcnRleCggX3ZDLnNldCggMC41LCAwLjUsIDAgKSwgX212UG9zaXRpb24sIGNlbnRlciwgX3dvcmxkU2NhbGUsIHNpbiwgY29zICk7XG5cblx0XHRfdXZBLnNldCggMCwgMCApO1xuXHRcdF91dkIuc2V0KCAxLCAwICk7XG5cdFx0X3V2Qy5zZXQoIDEsIDEgKTtcblxuXHRcdC8vIGNoZWNrIGZpcnN0IHRyaWFuZ2xlXG5cdFx0bGV0IGludGVyc2VjdCA9IHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0VHJpYW5nbGUoIF92QSwgX3ZCLCBfdkMsIGZhbHNlLCBfaW50ZXJzZWN0UG9pbnQgKTtcblxuXHRcdGlmICggaW50ZXJzZWN0ID09PSBudWxsICkge1xuXG5cdFx0XHQvLyBjaGVjayBzZWNvbmQgdHJpYW5nbGVcblx0XHRcdHRyYW5zZm9ybVZlcnRleCggX3ZCLnNldCggLSAwLjUsIDAuNSwgMCApLCBfbXZQb3NpdGlvbiwgY2VudGVyLCBfd29ybGRTY2FsZSwgc2luLCBjb3MgKTtcblx0XHRcdF91dkIuc2V0KCAwLCAxICk7XG5cblx0XHRcdGludGVyc2VjdCA9IHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0VHJpYW5nbGUoIF92QSwgX3ZDLCBfdkIsIGZhbHNlLCBfaW50ZXJzZWN0UG9pbnQgKTtcblx0XHRcdGlmICggaW50ZXJzZWN0ID09PSBudWxsICkge1xuXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBfaW50ZXJzZWN0UG9pbnQgKTtcblxuXHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm47XG5cblx0XHRpbnRlcnNlY3RzLnB1c2goIHtcblxuXHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0cG9pbnQ6IF9pbnRlcnNlY3RQb2ludC5jbG9uZSgpLFxuXHRcdFx0dXY6IFRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIF9pbnRlcnNlY3RQb2ludCwgX3ZBLCBfdkIsIF92QywgX3V2QSwgX3V2QiwgX3V2QywgbmV3IFZlY3RvcjIoKSApLFxuXHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdG9iamVjdDogdGhpc1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XG5cblx0XHRpZiAoIHNvdXJjZS5jZW50ZXIgIT09IHVuZGVmaW5lZCApIHRoaXMuY2VudGVyLmNvcHkoIHNvdXJjZS5jZW50ZXIgKTtcblxuXHRcdHRoaXMubWF0ZXJpYWwgPSBzb3VyY2UubWF0ZXJpYWw7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtVmVydGV4KCB2ZXJ0ZXhQb3NpdGlvbiwgbXZQb3NpdGlvbiwgY2VudGVyLCBzY2FsZSwgc2luLCBjb3MgKSB7XG5cblx0Ly8gY29tcHV0ZSBwb3NpdGlvbiBpbiBjYW1lcmEgc3BhY2Vcblx0X2FsaWduZWRQb3NpdGlvbi5zdWJWZWN0b3JzKCB2ZXJ0ZXhQb3NpdGlvbiwgY2VudGVyICkuYWRkU2NhbGFyKCAwLjUgKS5tdWx0aXBseSggc2NhbGUgKTtcblxuXHQvLyB0byBjaGVjayBpZiByb3RhdGlvbiBpcyBub3QgemVyb1xuXHRpZiAoIHNpbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0X3JvdGF0ZWRQb3NpdGlvbi54ID0gKCBjb3MgKiBfYWxpZ25lZFBvc2l0aW9uLnggKSAtICggc2luICogX2FsaWduZWRQb3NpdGlvbi55ICk7XG5cdFx0X3JvdGF0ZWRQb3NpdGlvbi55ID0gKCBzaW4gKiBfYWxpZ25lZFBvc2l0aW9uLnggKSArICggY29zICogX2FsaWduZWRQb3NpdGlvbi55ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdF9yb3RhdGVkUG9zaXRpb24uY29weSggX2FsaWduZWRQb3NpdGlvbiApO1xuXG5cdH1cblxuXG5cdHZlcnRleFBvc2l0aW9uLmNvcHkoIG12UG9zaXRpb24gKTtcblx0dmVydGV4UG9zaXRpb24ueCArPSBfcm90YXRlZFBvc2l0aW9uLng7XG5cdHZlcnRleFBvc2l0aW9uLnkgKz0gX3JvdGF0ZWRQb3NpdGlvbi55O1xuXG5cdC8vIHRyYW5zZm9ybSB0byB3b3JsZCBzcGFjZVxuXHR2ZXJ0ZXhQb3NpdGlvbi5hcHBseU1hdHJpeDQoIF92aWV3V29ybGRNYXRyaXggKTtcblxufVxuXG5jb25zdCBfdjEkMiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MiQxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBMT0QgZXh0ZW5kcyBPYmplY3QzRCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5fY3VycmVudExldmVsID0gMDtcblxuXHRcdHRoaXMudHlwZSA9ICdMT0QnO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblx0XHRcdGxldmVsczoge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogW11cblx0XHRcdH0sXG5cdFx0XHRpc0xPRDoge1xuXHRcdFx0XHR2YWx1ZTogdHJ1ZSxcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIGZhbHNlICk7XG5cblx0XHRjb25zdCBsZXZlbHMgPSBzb3VyY2UubGV2ZWxzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGxldmVsID0gbGV2ZWxzWyBpIF07XG5cblx0XHRcdHRoaXMuYWRkTGV2ZWwoIGxldmVsLm9iamVjdC5jbG9uZSgpLCBsZXZlbC5kaXN0YW5jZSwgbGV2ZWwuaHlzdGVyZXNpcyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hdXRvVXBkYXRlID0gc291cmNlLmF1dG9VcGRhdGU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkTGV2ZWwoIG9iamVjdCwgZGlzdGFuY2UgPSAwLCBoeXN0ZXJlc2lzID0gMCApIHtcblxuXHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoIGRpc3RhbmNlICk7XG5cblx0XHRjb25zdCBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuXHRcdGxldCBsO1xuXG5cdFx0Zm9yICggbCA9IDA7IGwgPCBsZXZlbHMubGVuZ3RoOyBsICsrICkge1xuXG5cdFx0XHRpZiAoIGRpc3RhbmNlIDwgbGV2ZWxzWyBsIF0uZGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGxldmVscy5zcGxpY2UoIGwsIDAsIHsgZGlzdGFuY2U6IGRpc3RhbmNlLCBoeXN0ZXJlc2lzOiBoeXN0ZXJlc2lzLCBvYmplY3Q6IG9iamVjdCB9ICk7XG5cblx0XHR0aGlzLmFkZCggb2JqZWN0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmVtb3ZlTGV2ZWwoIGRpc3RhbmNlICkge1xuXG5cdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIGxldmVsc1sgaSBdLmRpc3RhbmNlID09PSBkaXN0YW5jZSApIHtcblxuXHRcdFx0XHRjb25zdCByZW1vdmVkRWxlbWVudHMgPSBsZXZlbHMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdHRoaXMucmVtb3ZlKCByZW1vdmVkRWxlbWVudHNbIDAgXS5vYmplY3QgKTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHRnZXRDdXJyZW50TGV2ZWwoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fY3VycmVudExldmVsO1xuXG5cdH1cblxuXG5cblx0Z2V0T2JqZWN0Rm9yRGlzdGFuY2UoIGRpc3RhbmNlICkge1xuXG5cdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0XHRpZiAoIGxldmVscy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRsZXQgaSwgbDtcblxuXHRcdFx0Zm9yICggaSA9IDEsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRsZXQgbGV2ZWxEaXN0YW5jZSA9IGxldmVsc1sgaSBdLmRpc3RhbmNlO1xuXG5cdFx0XHRcdGlmICggbGV2ZWxzWyBpIF0ub2JqZWN0LnZpc2libGUgKSB7XG5cblx0XHRcdFx0XHRsZXZlbERpc3RhbmNlIC09IGxldmVsRGlzdGFuY2UgKiBsZXZlbHNbIGkgXS5oeXN0ZXJlc2lzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgbGV2ZWxEaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbGV2ZWxzWyBpIC0gMSBdLm9iamVjdDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH1cblxuXHRyYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHRjb25zdCBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuXHRcdGlmICggbGV2ZWxzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdF92MSQyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRjb25zdCBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIF92MSQyICk7XG5cblx0XHRcdHRoaXMuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UoIGRpc3RhbmNlICkucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZSggY2FtZXJhICkge1xuXG5cdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0XHRpZiAoIGxldmVscy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRfdjEkMi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuXHRcdFx0X3YyJDEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdGNvbnN0IGRpc3RhbmNlID0gX3YxJDIuZGlzdGFuY2VUbyggX3YyJDEgKSAvIGNhbWVyYS56b29tO1xuXG5cdFx0XHRsZXZlbHNbIDAgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG5cblx0XHRcdGxldCBpLCBsO1xuXG5cdFx0XHRmb3IgKCBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGxldCBsZXZlbERpc3RhbmNlID0gbGV2ZWxzWyBpIF0uZGlzdGFuY2U7XG5cblx0XHRcdFx0aWYgKCBsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSApIHtcblxuXHRcdFx0XHRcdGxldmVsRGlzdGFuY2UgLT0gbGV2ZWxEaXN0YW5jZSAqIGxldmVsc1sgaSBdLmh5c3RlcmVzaXM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZGlzdGFuY2UgPj0gbGV2ZWxEaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdGxldmVsc1sgaSAtIDEgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2N1cnJlbnRMZXZlbCA9IGkgLSAxO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0dG9KU09OKCBtZXRhICkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTiggbWV0YSApO1xuXG5cdFx0aWYgKCB0aGlzLmF1dG9VcGRhdGUgPT09IGZhbHNlICkgZGF0YS5vYmplY3QuYXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0ZGF0YS5vYmplY3QubGV2ZWxzID0gW107XG5cblx0XHRjb25zdCBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBsZXZlbCA9IGxldmVsc1sgaSBdO1xuXG5cdFx0XHRkYXRhLm9iamVjdC5sZXZlbHMucHVzaCgge1xuXHRcdFx0XHRvYmplY3Q6IGxldmVsLm9iamVjdC51dWlkLFxuXHRcdFx0XHRkaXN0YW5jZTogbGV2ZWwuZGlzdGFuY2UsXG5cdFx0XHRcdGh5c3RlcmVzaXM6IGxldmVsLmh5c3RlcmVzaXNcblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxufVxuXG5jb25zdCBfYmFzZVBvc2l0aW9uID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfc2tpbkluZGV4ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yNCgpO1xuY29uc3QgX3NraW5XZWlnaHQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3I0KCk7XG5cbmNvbnN0IF92ZWN0b3IzID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX21hdHJpeDQgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfdmVydGV4ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfc3BoZXJlJDUgPSAvKkBfX1BVUkVfXyovIG5ldyBTcGhlcmUoKTtcbmNvbnN0IF9pbnZlcnNlTWF0cml4JDIgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfcmF5JDIgPSAvKkBfX1BVUkVfXyovIG5ldyBSYXkoKTtcblxuY2xhc3MgU2tpbm5lZE1lc2ggZXh0ZW5kcyBNZXNoIHtcblxuXHRjb25zdHJ1Y3RvciggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0dGhpcy5pc1NraW5uZWRNZXNoID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdTa2lubmVkTWVzaCc7XG5cblx0XHR0aGlzLmJpbmRNb2RlID0gQXR0YWNoZWRCaW5kTW9kZTtcblx0XHR0aGlzLmJpbmRNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0fVxuXG5cdGNvbXB1dGVCb3VuZGluZ0JveCgpIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmJvdW5kaW5nQm94Lm1ha2VFbXB0eSgpO1xuXG5cdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHBvc2l0aW9uQXR0cmlidXRlLmNvdW50OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmdldFZlcnRleFBvc2l0aW9uKCBpLCBfdmVydGV4ICk7XG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoIF92ZXJ0ZXggKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlKCkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5tYWtlRW1wdHkoKTtcblxuXHRcdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5nZXRWZXJ0ZXhQb3NpdGlvbiggaSwgX3ZlcnRleCApO1xuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5leHBhbmRCeVBvaW50KCBfdmVydGV4ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlLCByZWN1cnNpdmUgKTtcblxuXHRcdHRoaXMuYmluZE1vZGUgPSBzb3VyY2UuYmluZE1vZGU7XG5cdFx0dGhpcy5iaW5kTWF0cml4LmNvcHkoIHNvdXJjZS5iaW5kTWF0cml4ICk7XG5cdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5jb3B5KCBzb3VyY2UuYmluZE1hdHJpeEludmVyc2UgKTtcblxuXHRcdHRoaXMuc2tlbGV0b24gPSBzb3VyY2Uuc2tlbGV0b247XG5cblx0XHRpZiAoIHNvdXJjZS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHRoaXMuYm91bmRpbmdCb3ggPSBzb3VyY2UuYm91bmRpbmdCb3guY2xvbmUoKTtcblx0XHRpZiAoIHNvdXJjZS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBzb3VyY2UuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHRjb25zdCBtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG5cdFx0Y29uc3QgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xuXG5cdFx0aWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0Ly8gdGVzdCB3aXRoIGJvdW5kaW5nIHNwaGVyZSBpbiB3b3JsZCBzcGFjZVxuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgdGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdF9zcGhlcmUkNS5jb3B5KCB0aGlzLmJvdW5kaW5nU3BoZXJlICk7XG5cdFx0X3NwaGVyZSQ1LmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBfc3BoZXJlJDUgKSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHQvLyBjb252ZXJ0IHJheSB0byBsb2NhbCBzcGFjZSBvZiBza2lubmVkIG1lc2hcblxuXHRcdF9pbnZlcnNlTWF0cml4JDIuY29weSggbWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblx0XHRfcmF5JDIuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggX2ludmVyc2VNYXRyaXgkMiApO1xuXG5cdFx0Ly8gdGVzdCB3aXRoIGJvdW5kaW5nIGJveCBpbiBsb2NhbCBzcGFjZVxuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG5cdFx0XHRpZiAoIF9yYXkkMi5pbnRlcnNlY3RzQm94KCB0aGlzLmJvdW5kaW5nQm94ICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdGVzdCBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIGdlb21ldHJ5XG5cblx0XHR0aGlzLl9jb21wdXRlSW50ZXJzZWN0aW9ucyggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCBfcmF5JDIgKTtcblxuXHR9XG5cblx0Z2V0VmVydGV4UG9zaXRpb24oIGluZGV4LCB0YXJnZXQgKSB7XG5cblx0XHRzdXBlci5nZXRWZXJ0ZXhQb3NpdGlvbiggaW5kZXgsIHRhcmdldCApO1xuXG5cdFx0dGhpcy5hcHBseUJvbmVUcmFuc2Zvcm0oIGluZGV4LCB0YXJnZXQgKTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdGJpbmQoIHNrZWxldG9uLCBiaW5kTWF0cml4ICkge1xuXG5cdFx0dGhpcy5za2VsZXRvbiA9IHNrZWxldG9uO1xuXG5cdFx0aWYgKCBiaW5kTWF0cml4ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdFx0dGhpcy5za2VsZXRvbi5jYWxjdWxhdGVJbnZlcnNlcygpO1xuXG5cdFx0XHRiaW5kTWF0cml4ID0gdGhpcy5tYXRyaXhXb3JsZDtcblxuXHRcdH1cblxuXHRcdHRoaXMuYmluZE1hdHJpeC5jb3B5KCBiaW5kTWF0cml4ICk7XG5cdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5jb3B5KCBiaW5kTWF0cml4ICkuaW52ZXJ0KCk7XG5cblx0fVxuXG5cdHBvc2UoKSB7XG5cblx0XHR0aGlzLnNrZWxldG9uLnBvc2UoKTtcblxuXHR9XG5cblx0bm9ybWFsaXplU2tpbldlaWdodHMoKSB7XG5cblx0XHRjb25zdCB2ZWN0b3IgPSBuZXcgVmVjdG9yNCgpO1xuXG5cdFx0Y29uc3Qgc2tpbldlaWdodCA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5za2luV2VpZ2h0O1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc2tpbldlaWdodC5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCBza2luV2VpZ2h0LCBpICk7XG5cblx0XHRcdGNvbnN0IHNjYWxlID0gMS4wIC8gdmVjdG9yLm1hbmhhdHRhbkxlbmd0aCgpO1xuXG5cdFx0XHRpZiAoIHNjYWxlICE9PSBJbmZpbml0eSApIHtcblxuXHRcdFx0XHR2ZWN0b3IubXVsdGlwbHlTY2FsYXIoIHNjYWxlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmVjdG9yLnNldCggMSwgMCwgMCwgMCApOyAvLyBkbyBzb21ldGhpbmcgcmVhc29uYWJsZVxuXG5cdFx0XHR9XG5cblx0XHRcdHNraW5XZWlnaHQuc2V0WFlaVyggaSwgdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiwgdmVjdG9yLncgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG5cdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XG5cblx0XHRpZiAoIHRoaXMuYmluZE1vZGUgPT09IEF0dGFjaGVkQmluZE1vZGUgKSB7XG5cblx0XHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuY29weSggdGhpcy5tYXRyaXhXb3JsZCApLmludmVydCgpO1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcy5iaW5kTW9kZSA9PT0gRGV0YWNoZWRCaW5kTW9kZSApIHtcblxuXHRcdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5jb3B5KCB0aGlzLmJpbmRNYXRyaXggKS5pbnZlcnQoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNraW5uZWRNZXNoOiBVbnJlY29nbml6ZWQgYmluZE1vZGU6ICcgKyB0aGlzLmJpbmRNb2RlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGFwcGx5Qm9uZVRyYW5zZm9ybSggaW5kZXgsIHZlY3RvciApIHtcblxuXHRcdGNvbnN0IHNrZWxldG9uID0gdGhpcy5za2VsZXRvbjtcblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cblx0XHRfc2tpbkluZGV4LmZyb21CdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LmF0dHJpYnV0ZXMuc2tpbkluZGV4LCBpbmRleCApO1xuXHRcdF9za2luV2VpZ2h0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LmF0dHJpYnV0ZXMuc2tpbldlaWdodCwgaW5kZXggKTtcblxuXHRcdF9iYXNlUG9zaXRpb24uY29weSggdmVjdG9yICkuYXBwbHlNYXRyaXg0KCB0aGlzLmJpbmRNYXRyaXggKTtcblxuXHRcdHZlY3Rvci5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHdlaWdodCA9IF9za2luV2VpZ2h0LmdldENvbXBvbmVudCggaSApO1xuXG5cdFx0XHRpZiAoIHdlaWdodCAhPT0gMCApIHtcblxuXHRcdFx0XHRjb25zdCBib25lSW5kZXggPSBfc2tpbkluZGV4LmdldENvbXBvbmVudCggaSApO1xuXG5cdFx0XHRcdF9tYXRyaXg0Lm11bHRpcGx5TWF0cmljZXMoIHNrZWxldG9uLmJvbmVzWyBib25lSW5kZXggXS5tYXRyaXhXb3JsZCwgc2tlbGV0b24uYm9uZUludmVyc2VzWyBib25lSW5kZXggXSApO1xuXG5cdFx0XHRcdHZlY3Rvci5hZGRTY2FsZWRWZWN0b3IoIF92ZWN0b3IzLmNvcHkoIF9iYXNlUG9zaXRpb24gKS5hcHBseU1hdHJpeDQoIF9tYXRyaXg0ICksIHdlaWdodCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcy5iaW5kTWF0cml4SW52ZXJzZSApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBCb25lIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNCb25lID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdCb25lJztcblxuXHR9XG5cbn1cblxuY2xhc3MgRGF0YVRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblxuXHRjb25zdHJ1Y3RvciggZGF0YSA9IG51bGwsIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXIsIG1pbkZpbHRlciA9IE5lYXJlc3RGaWx0ZXIsIGFuaXNvdHJvcHksIGNvbG9yU3BhY2UgKSB7XG5cblx0XHRzdXBlciggbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBjb2xvclNwYWNlICk7XG5cblx0XHR0aGlzLmlzRGF0YVRleHR1cmUgPSB0cnVlO1xuXG5cdFx0dGhpcy5pbWFnZSA9IHsgZGF0YTogZGF0YSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xuXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XG5cdFx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSAxO1xuXG5cdH1cblxufVxuXG5jb25zdCBfb2Zmc2V0TWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX2lkZW50aXR5TWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuXG5jbGFzcyBTa2VsZXRvbiB7XG5cblx0Y29uc3RydWN0b3IoIGJvbmVzID0gW10sIGJvbmVJbnZlcnNlcyA9IFtdICkge1xuXG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLmJvbmVzID0gYm9uZXMuc2xpY2UoIDAgKTtcblx0XHR0aGlzLmJvbmVJbnZlcnNlcyA9IGJvbmVJbnZlcnNlcztcblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG51bGw7XG5cblx0XHR0aGlzLmJvbmVUZXh0dXJlID0gbnVsbDtcblxuXHRcdHRoaXMuaW5pdCgpO1xuXG5cdH1cblxuXHRpbml0KCkge1xuXG5cdFx0Y29uc3QgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXHRcdGNvbnN0IGJvbmVJbnZlcnNlcyA9IHRoaXMuYm9uZUludmVyc2VzO1xuXG5cdFx0dGhpcy5ib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBib25lcy5sZW5ndGggKiAxNiApO1xuXG5cdFx0Ly8gY2FsY3VsYXRlIGludmVyc2UgYm9uZSBtYXRyaWNlcyBpZiBuZWNlc3NhcnlcblxuXHRcdGlmICggYm9uZUludmVyc2VzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0dGhpcy5jYWxjdWxhdGVJbnZlcnNlcygpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gaGFuZGxlIHNwZWNpYWwgY2FzZVxuXG5cdFx0XHRpZiAoIGJvbmVzLmxlbmd0aCAhPT0gYm9uZUludmVyc2VzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Ta2VsZXRvbjogTnVtYmVyIG9mIGludmVyc2UgYm9uZSBtYXRyaWNlcyBkb2VzIG5vdCBtYXRjaCBhbW91bnQgb2YgYm9uZXMuJyApO1xuXG5cdFx0XHRcdHRoaXMuYm9uZUludmVyc2VzID0gW107XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBuZXcgTWF0cml4NCgpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGNhbGN1bGF0ZUludmVyc2VzKCkge1xuXG5cdFx0dGhpcy5ib25lSW52ZXJzZXMubGVuZ3RoID0gMDtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBpbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0aWYgKCB0aGlzLmJvbmVzWyBpIF0gKSB7XG5cblx0XHRcdFx0aW52ZXJzZS5jb3B5KCB0aGlzLmJvbmVzWyBpIF0ubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBpbnZlcnNlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHBvc2UoKSB7XG5cblx0XHQvLyByZWNvdmVyIHRoZSBiaW5kLXRpbWUgd29ybGQgbWF0cmljZXNcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBib25lID0gdGhpcy5ib25lc1sgaSBdO1xuXG5cdFx0XHRpZiAoIGJvbmUgKSB7XG5cblx0XHRcdFx0Ym9uZS5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLmJvbmVJbnZlcnNlc1sgaSBdICkuaW52ZXJ0KCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGNvbXB1dGUgdGhlIGxvY2FsIG1hdHJpY2VzLCBwb3NpdGlvbnMsIHJvdGF0aW9ucyBhbmQgc2NhbGVzXG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGhpcy5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgYm9uZSA9IHRoaXMuYm9uZXNbIGkgXTtcblxuXHRcdFx0aWYgKCBib25lICkge1xuXG5cdFx0XHRcdGlmICggYm9uZS5wYXJlbnQgJiYgYm9uZS5wYXJlbnQuaXNCb25lICkge1xuXG5cdFx0XHRcdFx0Ym9uZS5tYXRyaXguY29weSggYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblx0XHRcdFx0XHRib25lLm1hdHJpeC5tdWx0aXBseSggYm9uZS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRib25lLm1hdHJpeC5jb3B5KCBib25lLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJvbmUubWF0cml4LmRlY29tcG9zZSggYm9uZS5wb3NpdGlvbiwgYm9uZS5xdWF0ZXJuaW9uLCBib25lLnNjYWxlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0dXBkYXRlKCkge1xuXG5cdFx0Y29uc3QgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXHRcdGNvbnN0IGJvbmVJbnZlcnNlcyA9IHRoaXMuYm9uZUludmVyc2VzO1xuXHRcdGNvbnN0IGJvbmVNYXRyaWNlcyA9IHRoaXMuYm9uZU1hdHJpY2VzO1xuXHRcdGNvbnN0IGJvbmVUZXh0dXJlID0gdGhpcy5ib25lVGV4dHVyZTtcblxuXHRcdC8vIGZsYXR0ZW4gYm9uZSBtYXRyaWNlcyB0byBhcnJheVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHQvLyBjb21wdXRlIHRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIG9yaWdpbmFsIHRyYW5zZm9ybVxuXG5cdFx0XHRjb25zdCBtYXRyaXggPSBib25lc1sgaSBdID8gYm9uZXNbIGkgXS5tYXRyaXhXb3JsZCA6IF9pZGVudGl0eU1hdHJpeDtcblxuXHRcdFx0X29mZnNldE1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXgsIGJvbmVJbnZlcnNlc1sgaSBdICk7XG5cdFx0XHRfb2Zmc2V0TWF0cml4LnRvQXJyYXkoIGJvbmVNYXRyaWNlcywgaSAqIDE2ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGJvbmVUZXh0dXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRib25lVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBTa2VsZXRvbiggdGhpcy5ib25lcywgdGhpcy5ib25lSW52ZXJzZXMgKTtcblxuXHR9XG5cblx0Y29tcHV0ZUJvbmVUZXh0dXJlKCkge1xuXG5cdFx0Ly8gbGF5b3V0ICgxIG1hdHJpeCA9IDQgcGl4ZWxzKVxuXHRcdC8vICAgICAgUkdCQSBSR0JBIFJHQkEgUkdCQSAoPT4gY29sdW1uMSwgY29sdW1uMiwgY29sdW1uMywgY29sdW1uNClcblx0XHQvLyAgd2l0aCAgOHg4ICBwaXhlbCB0ZXh0dXJlIG1heCAgIDE2IGJvbmVzICogNCBwaXhlbHMgPSAgKDggKiA4KVxuXHRcdC8vICAgICAgIDE2eDE2IHBpeGVsIHRleHR1cmUgbWF4ICAgNjQgYm9uZXMgKiA0IHBpeGVscyA9ICgxNiAqIDE2KVxuXHRcdC8vICAgICAgIDMyeDMyIHBpeGVsIHRleHR1cmUgbWF4ICAyNTYgYm9uZXMgKiA0IHBpeGVscyA9ICgzMiAqIDMyKVxuXHRcdC8vICAgICAgIDY0eDY0IHBpeGVsIHRleHR1cmUgbWF4IDEwMjQgYm9uZXMgKiA0IHBpeGVscyA9ICg2NCAqIDY0KVxuXG5cdFx0bGV0IHNpemUgPSBNYXRoLnNxcnQoIHRoaXMuYm9uZXMubGVuZ3RoICogNCApOyAvLyA0IHBpeGVscyBuZWVkZWQgZm9yIDEgbWF0cml4XG5cdFx0c2l6ZSA9IE1hdGguY2VpbCggc2l6ZSAvIDQgKSAqIDQ7XG5cdFx0c2l6ZSA9IE1hdGgubWF4KCBzaXplLCA0ICk7XG5cblx0XHRjb25zdCBib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBzaXplICogc2l6ZSAqIDQgKTsgLy8gNCBmbG9hdHMgcGVyIFJHQkEgcGl4ZWxcblx0XHRib25lTWF0cmljZXMuc2V0KCB0aGlzLmJvbmVNYXRyaWNlcyApOyAvLyBjb3B5IGN1cnJlbnQgdmFsdWVzXG5cblx0XHRjb25zdCBib25lVGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSggYm9uZU1hdHJpY2VzLCBzaXplLCBzaXplLCBSR0JBRm9ybWF0LCBGbG9hdFR5cGUgKTtcblx0XHRib25lVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IGJvbmVNYXRyaWNlcztcblx0XHR0aGlzLmJvbmVUZXh0dXJlID0gYm9uZVRleHR1cmU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Qm9uZUJ5TmFtZSggbmFtZSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBib25lID0gdGhpcy5ib25lc1sgaSBdO1xuXG5cdFx0XHRpZiAoIGJvbmUubmFtZSA9PT0gbmFtZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gYm9uZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuXHR9XG5cblx0ZGlzcG9zZSggKSB7XG5cblx0XHRpZiAoIHRoaXMuYm9uZVRleHR1cmUgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm9uZVRleHR1cmUuZGlzcG9zZSgpO1xuXG5cdFx0XHR0aGlzLmJvbmVUZXh0dXJlID0gbnVsbDtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnJvbUpTT04oIGpzb24sIGJvbmVzICkge1xuXG5cdFx0dGhpcy51dWlkID0ganNvbi51dWlkO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0ganNvbi5ib25lcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCB1dWlkID0ganNvbi5ib25lc1sgaSBdO1xuXHRcdFx0bGV0IGJvbmUgPSBib25lc1sgdXVpZCBdO1xuXG5cdFx0XHRpZiAoIGJvbmUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Ta2VsZXRvbjogTm8gYm9uZSBmb3VuZCB3aXRoIFVVSUQ6JywgdXVpZCApO1xuXHRcdFx0XHRib25lID0gbmV3IEJvbmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmJvbmVzLnB1c2goIGJvbmUgKTtcblx0XHRcdHRoaXMuYm9uZUludmVyc2VzLnB1c2goIG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCBqc29uLmJvbmVJbnZlcnNlc1sgaSBdICkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuaW5pdCgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjYsXG5cdFx0XHRcdHR5cGU6ICdTa2VsZXRvbicsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ1NrZWxldG9uLnRvSlNPTidcblx0XHRcdH0sXG5cdFx0XHRib25lczogW10sXG5cdFx0XHRib25lSW52ZXJzZXM6IFtdXG5cdFx0fTtcblxuXHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcblxuXHRcdGNvbnN0IGJvbmVzID0gdGhpcy5ib25lcztcblx0XHRjb25zdCBib25lSW52ZXJzZXMgPSB0aGlzLmJvbmVJbnZlcnNlcztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGJvbmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGJvbmUgPSBib25lc1sgaSBdO1xuXHRcdFx0ZGF0YS5ib25lcy5wdXNoKCBib25lLnV1aWQgKTtcblxuXHRcdFx0Y29uc3QgYm9uZUludmVyc2UgPSBib25lSW52ZXJzZXNbIGkgXTtcblx0XHRcdGRhdGEuYm9uZUludmVyc2VzLnB1c2goIGJvbmVJbnZlcnNlLnRvQXJyYXkoKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59XG5cbmNsYXNzIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCwgbWVzaFBlckF0dHJpYnV0ZSA9IDEgKSB7XG5cblx0XHRzdXBlciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0XHR0aGlzLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcblxuXHRcdHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IG1lc2hQZXJBdHRyaWJ1dGU7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0ZGF0YS5tZXNoUGVyQXR0cmlidXRlID0gdGhpcy5tZXNoUGVyQXR0cmlidXRlO1xuXG5cdFx0ZGF0YS5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA9IHRydWU7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cbn1cblxuY29uc3QgX2luc3RhbmNlTG9jYWxNYXRyaXggPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfaW5zdGFuY2VXb3JsZE1hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcblxuY29uc3QgX2luc3RhbmNlSW50ZXJzZWN0cyA9IFtdO1xuXG5jb25zdCBfYm94MyA9IC8qQF9fUFVSRV9fKi8gbmV3IEJveDMoKTtcbmNvbnN0IF9pZGVudGl0eSA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9tZXNoJDEgPSAvKkBfX1BVUkVfXyovIG5ldyBNZXNoKCk7XG5jb25zdCBfc3BoZXJlJDQgPSAvKkBfX1BVUkVfXyovIG5ldyBTcGhlcmUoKTtcblxuY2xhc3MgSW5zdGFuY2VkTWVzaCBleHRlbmRzIE1lc2gge1xuXG5cdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGNvdW50ICkge1xuXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0dGhpcy5pc0luc3RhbmNlZE1lc2ggPSB0cnVlO1xuXG5cdFx0dGhpcy5pbnN0YW5jZU1hdHJpeCA9IG5ldyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIGNvdW50ICogMTYgKSwgMTYgKTtcblx0XHR0aGlzLmluc3RhbmNlQ29sb3IgPSBudWxsO1xuXHRcdHRoaXMubW9ycGhUZXh0dXJlID0gbnVsbDtcblxuXHRcdHRoaXMuY291bnQgPSBjb3VudDtcblxuXHRcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuc2V0TWF0cml4QXQoIGksIF9pZGVudGl0eSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb21wdXRlQm91bmRpbmdCb3goKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgY291bnQgPSB0aGlzLmNvdW50O1xuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJveDMoKTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5ib3VuZGluZ0JveC5tYWtlRW1wdHkoKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNvdW50OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmdldE1hdHJpeEF0KCBpLCBfaW5zdGFuY2VMb2NhbE1hdHJpeCApO1xuXG5cdFx0XHRfYm94My5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApLmFwcGx5TWF0cml4NCggX2luc3RhbmNlTG9jYWxNYXRyaXggKTtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveC51bmlvbiggX2JveDMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlKCkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGNvbnN0IGNvdW50ID0gdGhpcy5jb3VudDtcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XG5cblx0XHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5tYWtlRW1wdHkoKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNvdW50OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmdldE1hdHJpeEF0KCBpLCBfaW5zdGFuY2VMb2NhbE1hdHJpeCApO1xuXG5cdFx0XHRfc3BoZXJlJDQuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKS5hcHBseU1hdHJpeDQoIF9pbnN0YW5jZUxvY2FsTWF0cml4ICk7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUudW5pb24oIF9zcGhlcmUkNCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XG5cblx0XHR0aGlzLmluc3RhbmNlTWF0cml4LmNvcHkoIHNvdXJjZS5pbnN0YW5jZU1hdHJpeCApO1xuXG5cdFx0aWYgKCBzb3VyY2UubW9ycGhUZXh0dXJlICE9PSBudWxsICkgdGhpcy5tb3JwaFRleHR1cmUgPSBzb3VyY2UubW9ycGhUZXh0dXJlLmNsb25lKCk7XG5cdFx0aWYgKCBzb3VyY2UuaW5zdGFuY2VDb2xvciAhPT0gbnVsbCApIHRoaXMuaW5zdGFuY2VDb2xvciA9IHNvdXJjZS5pbnN0YW5jZUNvbG9yLmNsb25lKCk7XG5cblx0XHR0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xuXG5cdFx0aWYgKCBzb3VyY2UuYm91bmRpbmdCb3ggIT09IG51bGwgKSB0aGlzLmJvdW5kaW5nQm94ID0gc291cmNlLmJvdW5kaW5nQm94LmNsb25lKCk7XG5cdFx0aWYgKCBzb3VyY2UuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB0aGlzLmJvdW5kaW5nU3BoZXJlID0gc291cmNlLmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Q29sb3JBdCggaW5kZXgsIGNvbG9yICkge1xuXG5cdFx0Y29sb3IuZnJvbUFycmF5KCB0aGlzLmluc3RhbmNlQ29sb3IuYXJyYXksIGluZGV4ICogMyApO1xuXG5cdH1cblxuXHRnZXRNYXRyaXhBdCggaW5kZXgsIG1hdHJpeCApIHtcblxuXHRcdG1hdHJpeC5mcm9tQXJyYXkoIHRoaXMuaW5zdGFuY2VNYXRyaXguYXJyYXksIGluZGV4ICogMTYgKTtcblxuXHR9XG5cblx0Z2V0TW9ycGhBdCggaW5kZXgsIG9iamVjdCApIHtcblxuXHRcdGNvbnN0IG9iamVjdEluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG5cdFx0Y29uc3QgYXJyYXkgPSB0aGlzLm1vcnBoVGV4dHVyZS5zb3VyY2UuZGF0YS5kYXRhO1xuXG5cdFx0Y29uc3QgbGVuID0gb2JqZWN0SW5mbHVlbmNlcy5sZW5ndGggKyAxOyAvLyBBbGwgaW5mbHVlbmNlcyArIHRoZSBiYXNlSW5mbHVlbmNlU3VtXG5cblx0XHRjb25zdCBkYXRhSW5kZXggPSBpbmRleCAqIGxlbiArIDE7IC8vIFNraXAgdGhlIGJhc2VJbmZsdWVuY2VTdW0gYXQgdGhlIGJlZ2lubmluZ1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgb2JqZWN0SW5mbHVlbmNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdG9iamVjdEluZmx1ZW5jZXNbIGkgXSA9IGFycmF5WyBkYXRhSW5kZXggKyBpIF07XG5cblx0XHR9XG5cblx0fVxuXG5cdHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuXHRcdGNvbnN0IG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcblx0XHRjb25zdCByYXljYXN0VGltZXMgPSB0aGlzLmNvdW50O1xuXG5cdFx0X21lc2gkMS5nZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0X21lc2gkMS5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG5cblx0XHRpZiAoIF9tZXNoJDEubWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdC8vIHRlc3Qgd2l0aCBib3VuZGluZyBzcGhlcmUgZmlyc3RcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRfc3BoZXJlJDQuY29weSggdGhpcy5ib3VuZGluZ1NwaGVyZSApO1xuXHRcdF9zcGhlcmUkNC5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cblx0XHRpZiAoIHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZSggX3NwaGVyZSQ0ICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0Ly8gbm93IHRlc3QgZWFjaCBpbnN0YW5jZVxuXG5cdFx0Zm9yICggbGV0IGluc3RhbmNlSWQgPSAwOyBpbnN0YW5jZUlkIDwgcmF5Y2FzdFRpbWVzOyBpbnN0YW5jZUlkICsrICkge1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgdGhlIHdvcmxkIG1hdHJpeCBmb3IgZWFjaCBpbnN0YW5jZVxuXG5cdFx0XHR0aGlzLmdldE1hdHJpeEF0KCBpbnN0YW5jZUlkLCBfaW5zdGFuY2VMb2NhbE1hdHJpeCApO1xuXG5cdFx0XHRfaW5zdGFuY2VXb3JsZE1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZCwgX2luc3RhbmNlTG9jYWxNYXRyaXggKTtcblxuXHRcdFx0Ly8gdGhlIG1lc2ggcmVwcmVzZW50cyB0aGlzIHNpbmdsZSBpbnN0YW5jZVxuXG5cdFx0XHRfbWVzaCQxLm1hdHJpeFdvcmxkID0gX2luc3RhbmNlV29ybGRNYXRyaXg7XG5cblx0XHRcdF9tZXNoJDEucmF5Y2FzdCggcmF5Y2FzdGVyLCBfaW5zdGFuY2VJbnRlcnNlY3RzICk7XG5cblx0XHRcdC8vIHByb2Nlc3MgdGhlIHJlc3VsdCBvZiByYXljYXN0XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IF9pbnN0YW5jZUludGVyc2VjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbnRlcnNlY3QgPSBfaW5zdGFuY2VJbnRlcnNlY3RzWyBpIF07XG5cdFx0XHRcdGludGVyc2VjdC5pbnN0YW5jZUlkID0gaW5zdGFuY2VJZDtcblx0XHRcdFx0aW50ZXJzZWN0Lm9iamVjdCA9IHRoaXM7XG5cdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X2luc3RhbmNlSW50ZXJzZWN0cy5sZW5ndGggPSAwO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXRDb2xvckF0KCBpbmRleCwgY29sb3IgKSB7XG5cblx0XHRpZiAoIHRoaXMuaW5zdGFuY2VDb2xvciA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5pbnN0YW5jZUNvbG9yID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdGhpcy5pbnN0YW5jZU1hdHJpeC5jb3VudCAqIDMgKS5maWxsKCAxICksIDMgKTtcblxuXHRcdH1cblxuXHRcdGNvbG9yLnRvQXJyYXkoIHRoaXMuaW5zdGFuY2VDb2xvci5hcnJheSwgaW5kZXggKiAzICk7XG5cblx0fVxuXG5cdHNldE1hdHJpeEF0KCBpbmRleCwgbWF0cml4ICkge1xuXG5cdFx0bWF0cml4LnRvQXJyYXkoIHRoaXMuaW5zdGFuY2VNYXRyaXguYXJyYXksIGluZGV4ICogMTYgKTtcblxuXHR9XG5cblx0c2V0TW9ycGhBdCggaW5kZXgsIG9iamVjdCApIHtcblxuXHRcdGNvbnN0IG9iamVjdEluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG5cdFx0Y29uc3QgbGVuID0gb2JqZWN0SW5mbHVlbmNlcy5sZW5ndGggKyAxOyAvLyBtb3JwaEJhc2VJbmZsdWVuY2UgKyBhbGwgaW5mbHVlbmNlc1xuXG5cdFx0aWYgKCB0aGlzLm1vcnBoVGV4dHVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5tb3JwaFRleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUoIG5ldyBGbG9hdDMyQXJyYXkoIGxlbiAqIHRoaXMuY291bnQgKSwgbGVuLCB0aGlzLmNvdW50LCBSZWRGb3JtYXQsIEZsb2F0VHlwZSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYXJyYXkgPSB0aGlzLm1vcnBoVGV4dHVyZS5zb3VyY2UuZGF0YS5kYXRhO1xuXG5cdFx0bGV0IG1vcnBoSW5mbHVlbmNlc1N1bSA9IDA7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBvYmplY3RJbmZsdWVuY2VzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0bW9ycGhJbmZsdWVuY2VzU3VtICs9IG9iamVjdEluZmx1ZW5jZXNbIGkgXTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IG1vcnBoQmFzZUluZmx1ZW5jZSA9IHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmUgPyAxIDogMSAtIG1vcnBoSW5mbHVlbmNlc1N1bTtcblxuXHRcdGNvbnN0IGRhdGFJbmRleCA9IGxlbiAqIGluZGV4O1xuXG5cdFx0YXJyYXlbIGRhdGFJbmRleCBdID0gbW9ycGhCYXNlSW5mbHVlbmNlO1xuXG5cdFx0YXJyYXkuc2V0KCBvYmplY3RJbmZsdWVuY2VzLCBkYXRhSW5kZXggKyAxICk7XG5cblx0fVxuXG5cdHVwZGF0ZU1vcnBoVGFyZ2V0cygpIHtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG5cdFx0aWYgKCB0aGlzLm1vcnBoVGV4dHVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5tb3JwaFRleHR1cmUuZGlzcG9zZSgpO1xuXHRcdFx0dGhpcy5tb3JwaFRleHR1cmUgPSBudWxsO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNvbnN0IF92ZWN0b3IxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZlY3RvcjIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfbm9ybWFsTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpO1xuXG5jbGFzcyBQbGFuZSB7XG5cblx0Y29uc3RydWN0b3IoIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCAxLCAwLCAwICksIGNvbnN0YW50ID0gMCApIHtcblxuXHRcdHRoaXMuaXNQbGFuZSA9IHRydWU7XG5cblx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHR0aGlzLm5vcm1hbCA9IG5vcm1hbDtcblx0XHR0aGlzLmNvbnN0YW50ID0gY29uc3RhbnQ7XG5cblx0fVxuXG5cdHNldCggbm9ybWFsLCBjb25zdGFudCApIHtcblxuXHRcdHRoaXMubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xuXHRcdHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRDb21wb25lbnRzKCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0dGhpcy5ub3JtYWwuc2V0KCB4LCB5LCB6ICk7XG5cdFx0dGhpcy5jb25zdGFudCA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5vcm1hbCwgcG9pbnQgKSB7XG5cblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcblx0XHR0aGlzLmNvbnN0YW50ID0gLSBwb2ludC5kb3QoIHRoaXMubm9ybWFsICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbUNvcGxhbmFyUG9pbnRzKCBhLCBiLCBjICkge1xuXG5cdFx0Y29uc3Qgbm9ybWFsID0gX3ZlY3RvcjEuc3ViVmVjdG9ycyggYywgYiApLmNyb3NzKCBfdmVjdG9yMi5zdWJWZWN0b3JzKCBhLCBiICkgKS5ub3JtYWxpemUoKTtcblxuXHRcdC8vIFE6IHNob3VsZCBhbiBlcnJvciBiZSB0aHJvd24gaWYgbm9ybWFsIGlzIHplcm8gKGUuZy4gZGVnZW5lcmF0ZSBwbGFuZSk/XG5cblx0XHR0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBub3JtYWwsIGEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb3B5KCBwbGFuZSApIHtcblxuXHRcdHRoaXMubm9ybWFsLmNvcHkoIHBsYW5lLm5vcm1hbCApO1xuXHRcdHRoaXMuY29uc3RhbnQgPSBwbGFuZS5jb25zdGFudDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRub3JtYWxpemUoKSB7XG5cblx0XHQvLyBOb3RlOiB3aWxsIGxlYWQgdG8gYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgcGxhbmUgaXMgaW52YWxpZC5cblxuXHRcdGNvbnN0IGludmVyc2VOb3JtYWxMZW5ndGggPSAxLjAgLyB0aGlzLm5vcm1hbC5sZW5ndGgoKTtcblx0XHR0aGlzLm5vcm1hbC5tdWx0aXBseVNjYWxhciggaW52ZXJzZU5vcm1hbExlbmd0aCApO1xuXHRcdHRoaXMuY29uc3RhbnQgKj0gaW52ZXJzZU5vcm1hbExlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRuZWdhdGUoKSB7XG5cblx0XHR0aGlzLmNvbnN0YW50ICo9IC0gMTtcblx0XHR0aGlzLm5vcm1hbC5uZWdhdGUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsLmRvdCggcG9pbnQgKSArIHRoaXMuY29uc3RhbnQ7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG9TcGhlcmUoIHNwaGVyZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIC0gc3BoZXJlLnJhZGl1cztcblxuXHR9XG5cblx0cHJvamVjdFBvaW50KCBwb2ludCwgdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBwb2ludCApLmFkZFNjYWxlZFZlY3RvciggdGhpcy5ub3JtYWwsIC0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkgKTtcblxuXHR9XG5cblx0aW50ZXJzZWN0TGluZSggbGluZSwgdGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgZGlyZWN0aW9uID0gbGluZS5kZWx0YSggX3ZlY3RvcjEgKTtcblxuXHRcdGNvbnN0IGRlbm9taW5hdG9yID0gdGhpcy5ub3JtYWwuZG90KCBkaXJlY3Rpb24gKTtcblxuXHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSB7XG5cblx0XHRcdC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cblx0XHRcdGlmICggdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKSA9PT0gMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGxpbmUuc3RhcnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBVbnN1cmUgaWYgdGhpcyBpcyB0aGUgY29ycmVjdCBtZXRob2QgdG8gaGFuZGxlIHRoaXMgY2FzZS5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdCA9IC0gKCBsaW5lLnN0YXJ0LmRvdCggdGhpcy5ub3JtYWwgKSArIHRoaXMuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xuXG5cdFx0aWYgKCB0IDwgMCB8fCB0ID4gMSApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGxpbmUuc3RhcnQgKS5hZGRTY2FsZWRWZWN0b3IoIGRpcmVjdGlvbiwgdCApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzTGluZSggbGluZSApIHtcblxuXHRcdC8vIE5vdGU6IHRoaXMgdGVzdHMgaWYgYSBsaW5lIGludGVyc2VjdHMgdGhlIHBsYW5lLCBub3Qgd2hldGhlciBpdCAob3IgaXRzIGVuZC1wb2ludHMpIGFyZSBjb3BsYW5hciB3aXRoIGl0LlxuXG5cdFx0Y29uc3Qgc3RhcnRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKTtcblx0XHRjb25zdCBlbmRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuZW5kICk7XG5cblx0XHRyZXR1cm4gKCBzdGFydFNpZ24gPCAwICYmIGVuZFNpZ24gPiAwICkgfHwgKCBlbmRTaWduIDwgMCAmJiBzdGFydFNpZ24gPiAwICk7XG5cblx0fVxuXG5cdGludGVyc2VjdHNCb3goIGJveCApIHtcblxuXHRcdHJldHVybiBib3guaW50ZXJzZWN0c1BsYW5lKCB0aGlzICk7XG5cblx0fVxuXG5cdGludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApIHtcblxuXHRcdHJldHVybiBzcGhlcmUuaW50ZXJzZWN0c1BsYW5lKCB0aGlzICk7XG5cblx0fVxuXG5cdGNvcGxhbmFyUG9pbnQoIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0YXJnZXQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggLSB0aGlzLmNvbnN0YW50ICk7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4NCggbWF0cml4LCBvcHRpb25hbE5vcm1hbE1hdHJpeCApIHtcblxuXHRcdGNvbnN0IG5vcm1hbE1hdHJpeCA9IG9wdGlvbmFsTm9ybWFsTWF0cml4IHx8IF9ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuXHRcdGNvbnN0IHJlZmVyZW5jZVBvaW50ID0gdGhpcy5jb3BsYW5hclBvaW50KCBfdmVjdG9yMSApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHRjb25zdCBub3JtYWwgPSB0aGlzLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0dGhpcy5jb25zdGFudCA9IC0gcmVmZXJlbmNlUG9pbnQuZG90KCBub3JtYWwgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2xhdGUoIG9mZnNldCApIHtcblxuXHRcdHRoaXMuY29uc3RhbnQgLT0gb2Zmc2V0LmRvdCggdGhpcy5ub3JtYWwgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlcXVhbHMoIHBsYW5lICkge1xuXG5cdFx0cmV0dXJuIHBsYW5lLm5vcm1hbC5lcXVhbHMoIHRoaXMubm9ybWFsICkgJiYgKCBwbGFuZS5jb25zdGFudCA9PT0gdGhpcy5jb25zdGFudCApO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn1cblxuY29uc3QgX3NwaGVyZSQzID0gLypAX19QVVJFX18qLyBuZXcgU3BoZXJlKCk7XG5jb25zdCBfdmVjdG9yJDYgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNsYXNzIEZydXN0dW0ge1xuXG5cdGNvbnN0cnVjdG9yKCBwMCA9IG5ldyBQbGFuZSgpLCBwMSA9IG5ldyBQbGFuZSgpLCBwMiA9IG5ldyBQbGFuZSgpLCBwMyA9IG5ldyBQbGFuZSgpLCBwNCA9IG5ldyBQbGFuZSgpLCBwNSA9IG5ldyBQbGFuZSgpICkge1xuXG5cdFx0dGhpcy5wbGFuZXMgPSBbIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUgXTtcblxuXHR9XG5cblx0c2V0KCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xuXG5cdFx0Y29uc3QgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cblx0XHRwbGFuZXNbIDAgXS5jb3B5KCBwMCApO1xuXHRcdHBsYW5lc1sgMSBdLmNvcHkoIHAxICk7XG5cdFx0cGxhbmVzWyAyIF0uY29weSggcDIgKTtcblx0XHRwbGFuZXNbIDMgXS5jb3B5KCBwMyApO1xuXHRcdHBsYW5lc1sgNCBdLmNvcHkoIHA0ICk7XG5cdFx0cGxhbmVzWyA1IF0uY29weSggcDUgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb3B5KCBmcnVzdHVtICkge1xuXG5cdFx0Y29uc3QgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRwbGFuZXNbIGkgXS5jb3B5KCBmcnVzdHVtLnBsYW5lc1sgaSBdICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVByb2plY3Rpb25NYXRyaXgoIG0sIGNvb3JkaW5hdGVTeXN0ZW0gPSBXZWJHTENvb3JkaW5hdGVTeXN0ZW0gKSB7XG5cblx0XHRjb25zdCBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUwID0gbWVbIDAgXSwgbWUxID0gbWVbIDEgXSwgbWUyID0gbWVbIDIgXSwgbWUzID0gbWVbIDMgXTtcblx0XHRjb25zdCBtZTQgPSBtZVsgNCBdLCBtZTUgPSBtZVsgNSBdLCBtZTYgPSBtZVsgNiBdLCBtZTcgPSBtZVsgNyBdO1xuXHRcdGNvbnN0IG1lOCA9IG1lWyA4IF0sIG1lOSA9IG1lWyA5IF0sIG1lMTAgPSBtZVsgMTAgXSwgbWUxMSA9IG1lWyAxMSBdO1xuXHRcdGNvbnN0IG1lMTIgPSBtZVsgMTIgXSwgbWUxMyA9IG1lWyAxMyBdLCBtZTE0ID0gbWVbIDE0IF0sIG1lMTUgPSBtZVsgMTUgXTtcblxuXHRcdHBsYW5lc1sgMCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMCwgbWU3IC0gbWU0LCBtZTExIC0gbWU4LCBtZTE1IC0gbWUxMiApLm5vcm1hbGl6ZSgpO1xuXHRcdHBsYW5lc1sgMSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMCwgbWU3ICsgbWU0LCBtZTExICsgbWU4LCBtZTE1ICsgbWUxMiApLm5vcm1hbGl6ZSgpO1xuXHRcdHBsYW5lc1sgMiBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMSwgbWU3ICsgbWU1LCBtZTExICsgbWU5LCBtZTE1ICsgbWUxMyApLm5vcm1hbGl6ZSgpO1xuXHRcdHBsYW5lc1sgMyBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMSwgbWU3IC0gbWU1LCBtZTExIC0gbWU5LCBtZTE1IC0gbWUxMyApLm5vcm1hbGl6ZSgpO1xuXHRcdHBsYW5lc1sgNCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMiwgbWU3IC0gbWU2LCBtZTExIC0gbWUxMCwgbWUxNSAtIG1lMTQgKS5ub3JtYWxpemUoKTtcblxuXHRcdGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHRwbGFuZXNbIDUgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTIsIG1lNyArIG1lNiwgbWUxMSArIG1lMTAsIG1lMTUgKyBtZTE0ICkubm9ybWFsaXplKCk7XG5cblx0XHR9IGVsc2UgaWYgKCBjb29yZGluYXRlU3lzdGVtID09PSBXZWJHUFVDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHRwbGFuZXNbIDUgXS5zZXRDb21wb25lbnRzKCBtZTIsIG1lNiwgbWUxMCwgbWUxNCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuRnJ1c3R1bS5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeCgpOiBJbnZhbGlkIGNvb3JkaW5hdGUgc3lzdGVtOiAnICsgY29vcmRpbmF0ZVN5c3RlbSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGludGVyc2VjdHNPYmplY3QoIG9iamVjdCApIHtcblxuXHRcdGlmICggb2JqZWN0LmJvdW5kaW5nU3BoZXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggb2JqZWN0LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgb2JqZWN0LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0XHRfc3BoZXJlJDMuY29weSggb2JqZWN0LmJvdW5kaW5nU3BoZXJlICkuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRcdF9zcGhlcmUkMy5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKCBfc3BoZXJlJDMgKTtcblxuXHR9XG5cblx0aW50ZXJzZWN0c1Nwcml0ZSggc3ByaXRlICkge1xuXG5cdFx0X3NwaGVyZSQzLmNlbnRlci5zZXQoIDAsIDAsIDAgKTtcblx0XHRfc3BoZXJlJDMucmFkaXVzID0gMC43MDcxMDY3ODExODY1NDc2O1xuXHRcdF9zcGhlcmUkMy5hcHBseU1hdHJpeDQoIHNwcml0ZS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggX3NwaGVyZSQzICk7XG5cblx0fVxuXG5cdGludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApIHtcblxuXHRcdGNvbnN0IHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXHRcdGNvbnN0IGNlbnRlciA9IHNwaGVyZS5jZW50ZXI7XG5cdFx0Y29uc3QgbmVnUmFkaXVzID0gLSBzcGhlcmUucmFkaXVzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgZGlzdGFuY2UgPSBwbGFuZXNbIGkgXS5kaXN0YW5jZVRvUG9pbnQoIGNlbnRlciApO1xuXG5cdFx0XHRpZiAoIGRpc3RhbmNlIDwgbmVnUmFkaXVzICkge1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdGludGVyc2VjdHNCb3goIGJveCApIHtcblxuXHRcdGNvbnN0IHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcGxhbmUgPSBwbGFuZXNbIGkgXTtcblxuXHRcdFx0Ly8gY29ybmVyIGF0IG1heCBkaXN0YW5jZVxuXG5cdFx0XHRfdmVjdG9yJDYueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5tYXgueCA6IGJveC5taW4ueDtcblx0XHRcdF92ZWN0b3IkNi55ID0gcGxhbmUubm9ybWFsLnkgPiAwID8gYm94Lm1heC55IDogYm94Lm1pbi55O1xuXHRcdFx0X3ZlY3RvciQ2LnogPSBwbGFuZS5ub3JtYWwueiA+IDAgPyBib3gubWF4LnogOiBib3gubWluLno7XG5cblx0XHRcdGlmICggcGxhbmUuZGlzdGFuY2VUb1BvaW50KCBfdmVjdG9yJDYgKSA8IDAgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0Y29udGFpbnNQb2ludCggcG9pbnQgKSB7XG5cblx0XHRjb25zdCBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdGlmICggcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIDwgMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gYXNjSWRTb3J0KCBhLCBiICkge1xuXG5cdHJldHVybiBhIC0gYjtcblxufVxuXG5mdW5jdGlvbiBzb3J0T3BhcXVlKCBhLCBiICkge1xuXG5cdHJldHVybiBhLnogLSBiLno7XG5cbn1cblxuZnVuY3Rpb24gc29ydFRyYW5zcGFyZW50KCBhLCBiICkge1xuXG5cdHJldHVybiBiLnogLSBhLno7XG5cbn1cblxuY2xhc3MgTXVsdGlEcmF3UmVuZGVyTGlzdCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHR0aGlzLmluZGV4ID0gMDtcblx0XHR0aGlzLnBvb2wgPSBbXTtcblx0XHR0aGlzLmxpc3QgPSBbXTtcblxuXHR9XG5cblx0cHVzaCggc3RhcnQsIGNvdW50LCB6LCBpbmRleCApIHtcblxuXHRcdGNvbnN0IHBvb2wgPSB0aGlzLnBvb2w7XG5cdFx0Y29uc3QgbGlzdCA9IHRoaXMubGlzdDtcblx0XHRpZiAoIHRoaXMuaW5kZXggPj0gcG9vbC5sZW5ndGggKSB7XG5cblx0XHRcdHBvb2wucHVzaCgge1xuXG5cdFx0XHRcdHN0YXJ0OiAtIDEsXG5cdFx0XHRcdGNvdW50OiAtIDEsXG5cdFx0XHRcdHo6IC0gMSxcblx0XHRcdFx0aW5kZXg6IC0gMSxcblxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaXRlbSA9IHBvb2xbIHRoaXMuaW5kZXggXTtcblx0XHRsaXN0LnB1c2goIGl0ZW0gKTtcblx0XHR0aGlzLmluZGV4ICsrO1xuXG5cdFx0aXRlbS5zdGFydCA9IHN0YXJ0O1xuXHRcdGl0ZW0uY291bnQgPSBjb3VudDtcblx0XHRpdGVtLnogPSB6O1xuXHRcdGl0ZW0uaW5kZXggPSBpbmRleDtcblxuXHR9XG5cblx0cmVzZXQoKSB7XG5cblx0XHR0aGlzLmxpc3QubGVuZ3RoID0gMDtcblx0XHR0aGlzLmluZGV4ID0gMDtcblxuXHR9XG5cbn1cblxuY29uc3QgX21hdHJpeCQxID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3doaXRlQ29sb3IgPSAvKkBfX1BVUkVfXyovIG5ldyBDb2xvciggMSwgMSwgMSApO1xuY29uc3QgX2ZydXN0dW0gPSAvKkBfX1BVUkVfXyovIG5ldyBGcnVzdHVtKCk7XG5jb25zdCBfYm94JDEgPSAvKkBfX1BVUkVfXyovIG5ldyBCb3gzKCk7XG5jb25zdCBfc3BoZXJlJDIgPSAvKkBfX1BVUkVfXyovIG5ldyBTcGhlcmUoKTtcbmNvbnN0IF92ZWN0b3IkNSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9mb3J3YXJkID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3RlbXAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfcmVuZGVyTGlzdCA9IC8qQF9fUFVSRV9fKi8gbmV3IE11bHRpRHJhd1JlbmRlckxpc3QoKTtcbmNvbnN0IF9tZXNoID0gLypAX19QVVJFX18qLyBuZXcgTWVzaCgpO1xuY29uc3QgX2JhdGNoSW50ZXJzZWN0cyA9IFtdO1xuXG4vLyBjb3BpZXMgZGF0YSBmcm9tIGF0dHJpYnV0ZSBcInNyY1wiIGludG8gXCJ0YXJnZXRcIiBzdGFydGluZyBhdCBcInRhcmdldE9mZnNldFwiXG5mdW5jdGlvbiBjb3B5QXR0cmlidXRlRGF0YSggc3JjLCB0YXJnZXQsIHRhcmdldE9mZnNldCA9IDAgKSB7XG5cblx0Y29uc3QgaXRlbVNpemUgPSB0YXJnZXQuaXRlbVNpemU7XG5cdGlmICggc3JjLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgfHwgc3JjLmFycmF5LmNvbnN0cnVjdG9yICE9PSB0YXJnZXQuYXJyYXkuY29uc3RydWN0b3IgKSB7XG5cblx0XHQvLyB1c2UgdGhlIGNvbXBvbmVudCBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGlmIHRoZSBhcnJheSBkYXRhIGNhbm5vdFxuXHRcdC8vIGJlIGNvcGllZCBkaXJlY3RseVxuXHRcdGNvbnN0IHZlcnRleENvdW50ID0gc3JjLmNvdW50O1xuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpICsrICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgYyA9IDA7IGMgPCBpdGVtU2l6ZTsgYyArKyApIHtcblxuXHRcdFx0XHR0YXJnZXQuc2V0Q29tcG9uZW50KCBpICsgdGFyZ2V0T2Zmc2V0LCBjLCBzcmMuZ2V0Q29tcG9uZW50KCBpLCBjICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBmYXN0ZXIgY29weSBhcHByb2FjaCB1c2luZyB0eXBlZCBhcnJheSBzZXQgZnVuY3Rpb25cblx0XHR0YXJnZXQuYXJyYXkuc2V0KCBzcmMuYXJyYXksIHRhcmdldE9mZnNldCAqIGl0ZW1TaXplICk7XG5cblx0fVxuXG5cdHRhcmdldC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbn1cblxuLy8gc2FmZWx5IGNvcGllcyBhcnJheSBjb250ZW50cyB0byBhIHBvdGVudGlhbGx5IHNtYWxsZXIgYXJyYXlcbmZ1bmN0aW9uIGNvcHlBcnJheUNvbnRlbnRzKCBzcmMsIHRhcmdldCApIHtcblxuXHRpZiAoIHNyYy5jb25zdHJ1Y3RvciAhPT0gdGFyZ2V0LmNvbnN0cnVjdG9yICkge1xuXG5cdFx0Ly8gaWYgYXJyYXlzIGFyZSBvZiBhIGRpZmZlcmVudCB0eXBlIChlZyBkdWUgdG8gaW5kZXggc2l6ZSBpbmNyZWFzaW5nKSB0aGVuIGRhdGEgbXVzdCBiZSBwZXItZWxlbWVudCBjb3BpZWRcblx0XHRjb25zdCBsZW4gPSBNYXRoLm1pbiggc3JjLmxlbmd0aCwgdGFyZ2V0Lmxlbmd0aCApO1xuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGxlbjsgaSArKyApIHtcblxuXHRcdFx0dGFyZ2V0WyBpIF0gPSBzcmNbIGkgXTtcblxuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gaWYgdGhlIGFycmF5cyB1c2UgdGhlIHNhbWUgZGF0YSBsYXlvdXQgd2UgY2FuIHVzZSBhIGZhc3QgYmxvY2sgY29weVxuXHRcdGNvbnN0IGxlbiA9IE1hdGgubWluKCBzcmMubGVuZ3RoLCB0YXJnZXQubGVuZ3RoICk7XG5cdFx0dGFyZ2V0LnNldCggbmV3IHNyYy5jb25zdHJ1Y3Rvciggc3JjLmJ1ZmZlciwgMCwgbGVuICkgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgQmF0Y2hlZE1lc2ggZXh0ZW5kcyBNZXNoIHtcblxuXHRnZXQgbWF4SW5zdGFuY2VDb3VudCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9tYXhJbnN0YW5jZUNvdW50O1xuXG5cdH1cblxuXHRnZXQgaW5zdGFuY2VDb3VudCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9pbnN0YW5jZUluZm8ubGVuZ3RoIC0gdGhpcy5fYXZhaWxhYmxlSW5zdGFuY2VJZHMubGVuZ3RoO1xuXG5cdH1cblxuXHRnZXQgdW51c2VkVmVydGV4Q291bnQoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fbWF4VmVydGV4Q291bnQgLSB0aGlzLl9uZXh0VmVydGV4U3RhcnQ7XG5cblx0fVxuXG5cdGdldCB1bnVzZWRJbmRleENvdW50KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX21heEluZGV4Q291bnQgLSB0aGlzLl9uZXh0SW5kZXhTdGFydDtcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIG1heEluc3RhbmNlQ291bnQsIG1heFZlcnRleENvdW50LCBtYXhJbmRleENvdW50ID0gbWF4VmVydGV4Q291bnQgKiAyLCBtYXRlcmlhbCApIHtcblxuXHRcdHN1cGVyKCBuZXcgQnVmZmVyR2VvbWV0cnkoKSwgbWF0ZXJpYWwgKTtcblxuXHRcdHRoaXMuaXNCYXRjaGVkTWVzaCA9IHRydWU7XG5cdFx0dGhpcy5wZXJPYmplY3RGcnVzdHVtQ3VsbGVkID0gdHJ1ZTtcblx0XHR0aGlzLnNvcnRPYmplY3RzID0gdHJ1ZTtcblx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblx0XHR0aGlzLmN1c3RvbVNvcnQgPSBudWxsO1xuXG5cdFx0Ly8gc3RvcmVzIHZpc2libGUsIGFjdGl2ZSwgYW5kIGdlb21ldHJ5IGlkIHBlciBpbnN0YW5jZSBhbmQgcmVzZXJ2ZWQgYnVmZmVyIHJhbmdlcyBmb3IgZ2VvbWV0cmllc1xuXHRcdHRoaXMuX2luc3RhbmNlSW5mbyA9IFtdO1xuXHRcdHRoaXMuX2dlb21ldHJ5SW5mbyA9IFtdO1xuXG5cdFx0Ly8gaW5zdGFuY2UsIGdlb21ldHJ5IGlkcyB0aGF0IGhhdmUgYmVlbiBzZXQgYXMgaW5hY3RpdmUsIGFuZCBhcmUgYXZhaWxhYmxlIHRvIGJlIG92ZXJ3cml0dGVuXG5cdFx0dGhpcy5fYXZhaWxhYmxlSW5zdGFuY2VJZHMgPSBbXTtcblx0XHR0aGlzLl9hdmFpbGFibGVHZW9tZXRyeUlkcyA9IFtdO1xuXG5cdFx0Ly8gdXNlZCB0byB0cmFjayB3aGVyZSB0aGUgbmV4dCBwb2ludCBpcyB0aGF0IGdlb21ldHJ5IHNob3VsZCBiZSBpbnNlcnRlZFxuXHRcdHRoaXMuX25leHRJbmRleFN0YXJ0ID0gMDtcblx0XHR0aGlzLl9uZXh0VmVydGV4U3RhcnQgPSAwO1xuXHRcdHRoaXMuX2dlb21ldHJ5Q291bnQgPSAwO1xuXG5cdFx0Ly8gZmxhZ3Ncblx0XHR0aGlzLl92aXNpYmlsaXR5Q2hhbmdlZCA9IHRydWU7XG5cdFx0dGhpcy5fZ2VvbWV0cnlJbml0aWFsaXplZCA9IGZhbHNlO1xuXG5cdFx0Ly8gY2FjaGVkIHVzZXIgb3B0aW9uc1xuXHRcdHRoaXMuX21heEluc3RhbmNlQ291bnQgPSBtYXhJbnN0YW5jZUNvdW50O1xuXHRcdHRoaXMuX21heFZlcnRleENvdW50ID0gbWF4VmVydGV4Q291bnQ7XG5cdFx0dGhpcy5fbWF4SW5kZXhDb3VudCA9IG1heEluZGV4Q291bnQ7XG5cblx0XHQvLyBidWZmZXJzIGZvciBtdWx0aSBkcmF3XG5cdFx0dGhpcy5fbXVsdGlEcmF3Q291bnRzID0gbmV3IEludDMyQXJyYXkoIG1heEluc3RhbmNlQ291bnQgKTtcblx0XHR0aGlzLl9tdWx0aURyYXdTdGFydHMgPSBuZXcgSW50MzJBcnJheSggbWF4SW5zdGFuY2VDb3VudCApO1xuXHRcdHRoaXMuX211bHRpRHJhd0NvdW50ID0gMDtcblx0XHR0aGlzLl9tdWx0aURyYXdJbnN0YW5jZXMgPSBudWxsO1xuXG5cdFx0Ly8gTG9jYWwgbWF0cml4IHBlciBnZW9tZXRyeSBieSB1c2luZyBkYXRhIHRleHR1cmVcblx0XHR0aGlzLl9tYXRyaWNlc1RleHR1cmUgPSBudWxsO1xuXHRcdHRoaXMuX2luZGlyZWN0VGV4dHVyZSA9IG51bGw7XG5cdFx0dGhpcy5fY29sb3JzVGV4dHVyZSA9IG51bGw7XG5cblx0XHR0aGlzLl9pbml0TWF0cmljZXNUZXh0dXJlKCk7XG5cdFx0dGhpcy5faW5pdEluZGlyZWN0VGV4dHVyZSgpO1xuXG5cdH1cblxuXHRfaW5pdE1hdHJpY2VzVGV4dHVyZSgpIHtcblxuXHRcdC8vIGxheW91dCAoMSBtYXRyaXggPSA0IHBpeGVscylcblx0XHQvLyAgICAgIFJHQkEgUkdCQSBSR0JBIFJHQkEgKD0+IGNvbHVtbjEsIGNvbHVtbjIsIGNvbHVtbjMsIGNvbHVtbjQpXG5cdFx0Ly8gIHdpdGggIDh4OCAgcGl4ZWwgdGV4dHVyZSBtYXggICAxNiBtYXRyaWNlcyAqIDQgcGl4ZWxzID0gICg4ICogOClcblx0XHQvLyAgICAgICAxNngxNiBwaXhlbCB0ZXh0dXJlIG1heCAgIDY0IG1hdHJpY2VzICogNCBwaXhlbHMgPSAoMTYgKiAxNilcblx0XHQvLyAgICAgICAzMngzMiBwaXhlbCB0ZXh0dXJlIG1heCAgMjU2IG1hdHJpY2VzICogNCBwaXhlbHMgPSAoMzIgKiAzMilcblx0XHQvLyAgICAgICA2NHg2NCBwaXhlbCB0ZXh0dXJlIG1heCAxMDI0IG1hdHJpY2VzICogNCBwaXhlbHMgPSAoNjQgKiA2NClcblxuXHRcdGxldCBzaXplID0gTWF0aC5zcXJ0KCB0aGlzLl9tYXhJbnN0YW5jZUNvdW50ICogNCApOyAvLyA0IHBpeGVscyBuZWVkZWQgZm9yIDEgbWF0cml4XG5cdFx0c2l6ZSA9IE1hdGguY2VpbCggc2l6ZSAvIDQgKSAqIDQ7XG5cdFx0c2l6ZSA9IE1hdGgubWF4KCBzaXplLCA0ICk7XG5cblx0XHRjb25zdCBtYXRyaWNlc0FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggc2l6ZSAqIHNpemUgKiA0ICk7IC8vIDQgZmxvYXRzIHBlciBSR0JBIHBpeGVsXG5cdFx0Y29uc3QgbWF0cmljZXNUZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCBtYXRyaWNlc0FycmF5LCBzaXplLCBzaXplLCBSR0JBRm9ybWF0LCBGbG9hdFR5cGUgKTtcblxuXHRcdHRoaXMuX21hdHJpY2VzVGV4dHVyZSA9IG1hdHJpY2VzVGV4dHVyZTtcblxuXHR9XG5cblx0X2luaXRJbmRpcmVjdFRleHR1cmUoKSB7XG5cblx0XHRsZXQgc2l6ZSA9IE1hdGguc3FydCggdGhpcy5fbWF4SW5zdGFuY2VDb3VudCApO1xuXHRcdHNpemUgPSBNYXRoLmNlaWwoIHNpemUgKTtcblxuXHRcdGNvbnN0IGluZGlyZWN0QXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIHNpemUgKiBzaXplICk7XG5cdFx0Y29uc3QgaW5kaXJlY3RUZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCBpbmRpcmVjdEFycmF5LCBzaXplLCBzaXplLCBSZWRJbnRlZ2VyRm9ybWF0LCBVbnNpZ25lZEludFR5cGUgKTtcblxuXHRcdHRoaXMuX2luZGlyZWN0VGV4dHVyZSA9IGluZGlyZWN0VGV4dHVyZTtcblxuXHR9XG5cblx0X2luaXRDb2xvcnNUZXh0dXJlKCkge1xuXG5cdFx0bGV0IHNpemUgPSBNYXRoLnNxcnQoIHRoaXMuX21heEluc3RhbmNlQ291bnQgKTtcblx0XHRzaXplID0gTWF0aC5jZWlsKCBzaXplICk7XG5cblx0XHQvLyA0IGZsb2F0cyBwZXIgUkdCQSBwaXhlbCBpbml0aWFsaXplZCB0byB3aGl0ZVxuXHRcdGNvbnN0IGNvbG9yc0FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggc2l6ZSAqIHNpemUgKiA0ICkuZmlsbCggMSApO1xuXHRcdGNvbnN0IGNvbG9yc1RleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUoIGNvbG9yc0FycmF5LCBzaXplLCBzaXplLCBSR0JBRm9ybWF0LCBGbG9hdFR5cGUgKTtcblx0XHRjb2xvcnNUZXh0dXJlLmNvbG9yU3BhY2UgPSBDb2xvck1hbmFnZW1lbnQud29ya2luZ0NvbG9yU3BhY2U7XG5cblx0XHR0aGlzLl9jb2xvcnNUZXh0dXJlID0gY29sb3JzVGV4dHVyZTtcblxuXHR9XG5cblx0X2luaXRpYWxpemVHZW9tZXRyeSggcmVmZXJlbmNlICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGNvbnN0IG1heFZlcnRleENvdW50ID0gdGhpcy5fbWF4VmVydGV4Q291bnQ7XG5cdFx0Y29uc3QgbWF4SW5kZXhDb3VudCA9IHRoaXMuX21heEluZGV4Q291bnQ7XG5cdFx0aWYgKCB0aGlzLl9nZW9tZXRyeUluaXRpYWxpemVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0Zm9yICggY29uc3QgYXR0cmlidXRlTmFtZSBpbiByZWZlcmVuY2UuYXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHRjb25zdCBzcmNBdHRyaWJ1dGUgPSByZWZlcmVuY2UuZ2V0QXR0cmlidXRlKCBhdHRyaWJ1dGVOYW1lICk7XG5cdFx0XHRcdGNvbnN0IHsgYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkIH0gPSBzcmNBdHRyaWJ1dGU7XG5cblx0XHRcdFx0Y29uc3QgZHN0QXJyYXkgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IoIG1heFZlcnRleENvdW50ICogaXRlbVNpemUgKTtcblx0XHRcdFx0Y29uc3QgZHN0QXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggZHN0QXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCBhdHRyaWJ1dGVOYW1lLCBkc3RBdHRyaWJ1dGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHJlZmVyZW5jZS5nZXRJbmRleCgpICE9PSBudWxsICkge1xuXG5cdFx0XHRcdC8vIFJlc2VydmUgbGFzdCB1MTYgaW5kZXggZm9yIHByaW1pdGl2ZSByZXN0YXJ0LlxuXHRcdFx0XHRjb25zdCBpbmRleEFycmF5ID0gbWF4VmVydGV4Q291bnQgPiA2NTUzNVxuXHRcdFx0XHRcdD8gbmV3IFVpbnQzMkFycmF5KCBtYXhJbmRleENvdW50IClcblx0XHRcdFx0XHQ6IG5ldyBVaW50MTZBcnJheSggbWF4SW5kZXhDb3VudCApO1xuXG5cdFx0XHRcdGdlb21ldHJ5LnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCBpbmRleEFycmF5LCAxICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9nZW9tZXRyeUluaXRpYWxpemVkID0gdHJ1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoZSBnZW9tZXRyeSBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGV4aXN0aW5nIGNvbWJpbmVkIGdlb21ldHJ5IGF0dHJpYnV0ZXNcblx0X3ZhbGlkYXRlR2VvbWV0cnkoIGdlb21ldHJ5ICkge1xuXG5cdFx0Ly8gY2hlY2sgdG8gZW5zdXJlIHRoZSBnZW9tZXRyaWVzIGFyZSB1c2luZyBjb25zaXN0ZW50IGF0dHJpYnV0ZXMgYW5kIGluZGljZXNcblx0XHRjb25zdCBiYXRjaEdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRpZiAoIEJvb2xlYW4oIGdlb21ldHJ5LmdldEluZGV4KCkgKSAhPT0gQm9vbGVhbiggYmF0Y2hHZW9tZXRyeS5nZXRJbmRleCgpICkgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkJhdGNoZWRNZXNoOiBBbGwgZ2VvbWV0cmllcyBtdXN0IGNvbnNpc3RlbnRseSBoYXZlIFwiaW5kZXhcIi4nICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGJhdGNoR2VvbWV0cnkuYXR0cmlidXRlcyApIHtcblxuXHRcdFx0aWYgKCAhIGdlb21ldHJ5Lmhhc0F0dHJpYnV0ZSggYXR0cmlidXRlTmFtZSApICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggYFRIUkVFLkJhdGNoZWRNZXNoOiBBZGRlZCBnZW9tZXRyeSBtaXNzaW5nIFwiJHsgYXR0cmlidXRlTmFtZSB9XCIuIEFsbCBnZW9tZXRyaWVzIG11c3QgaGF2ZSBjb25zaXN0ZW50IGF0dHJpYnV0ZXMuYCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNyY0F0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggYXR0cmlidXRlTmFtZSApO1xuXHRcdFx0Y29uc3QgZHN0QXR0cmlidXRlID0gYmF0Y2hHZW9tZXRyeS5nZXRBdHRyaWJ1dGUoIGF0dHJpYnV0ZU5hbWUgKTtcblx0XHRcdGlmICggc3JjQXR0cmlidXRlLml0ZW1TaXplICE9PSBkc3RBdHRyaWJ1dGUuaXRlbVNpemUgfHwgc3JjQXR0cmlidXRlLm5vcm1hbGl6ZWQgIT09IGRzdEF0dHJpYnV0ZS5ub3JtYWxpemVkICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkJhdGNoZWRNZXNoOiBBbGwgYXR0cmlidXRlcyBtdXN0IGhhdmUgYSBjb25zaXN0ZW50IGl0ZW1TaXplIGFuZCBub3JtYWxpemVkIHZhbHVlLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR2YWxpZGF0ZUluc3RhbmNlSWQoIGluc3RhbmNlSWQgKSB7XG5cblx0XHRjb25zdCBpbnN0YW5jZUluZm8gPSB0aGlzLl9pbnN0YW5jZUluZm87XG5cdFx0aWYgKCBpbnN0YW5jZUlkIDwgMCB8fCBpbnN0YW5jZUlkID49IGluc3RhbmNlSW5mby5sZW5ndGggfHwgaW5zdGFuY2VJbmZvWyBpbnN0YW5jZUlkIF0uYWN0aXZlID09PSBmYWxzZSApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgVEhSRUUuQmF0Y2hlZE1lc2g6IEludmFsaWQgaW5zdGFuY2VJZCAke2luc3RhbmNlSWR9LiBJbnN0YW5jZSBpcyBlaXRoZXIgb3V0IG9mIHJhbmdlIG9yIGhhcyBiZWVuIGRlbGV0ZWQuYCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR2YWxpZGF0ZUdlb21ldHJ5SWQoIGdlb21ldHJ5SWQgKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeUluZm9MaXN0ID0gdGhpcy5fZ2VvbWV0cnlJbmZvO1xuXHRcdGlmICggZ2VvbWV0cnlJZCA8IDAgfHwgZ2VvbWV0cnlJZCA+PSBnZW9tZXRyeUluZm9MaXN0Lmxlbmd0aCB8fCBnZW9tZXRyeUluZm9MaXN0WyBnZW9tZXRyeUlkIF0uYWN0aXZlID09PSBmYWxzZSApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgVEhSRUUuQmF0Y2hlZE1lc2g6IEludmFsaWQgZ2VvbWV0cnlJZCAke2dlb21ldHJ5SWR9LiBHZW9tZXRyeSBpcyBlaXRoZXIgb3V0IG9mIHJhbmdlIG9yIGhhcyBiZWVuIGRlbGV0ZWQuYCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXG5cdHNldEN1c3RvbVNvcnQoIGZ1bmMgKSB7XG5cblx0XHR0aGlzLmN1c3RvbVNvcnQgPSBmdW5jO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb21wdXRlQm91bmRpbmdCb3goKSB7XG5cblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYm91bmRpbmdCb3ggPSB0aGlzLmJvdW5kaW5nQm94O1xuXHRcdGNvbnN0IGluc3RhbmNlSW5mbyA9IHRoaXMuX2luc3RhbmNlSW5mbztcblxuXHRcdGJvdW5kaW5nQm94Lm1ha2VFbXB0eSgpO1xuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluc3RhbmNlSW5mby5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIGluc3RhbmNlSW5mb1sgaSBdLmFjdGl2ZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnlJZCA9IGluc3RhbmNlSW5mb1sgaSBdLmdlb21ldHJ5SW5kZXg7XG5cdFx0XHR0aGlzLmdldE1hdHJpeEF0KCBpLCBfbWF0cml4JDEgKTtcblx0XHRcdHRoaXMuZ2V0Qm91bmRpbmdCb3hBdCggZ2VvbWV0cnlJZCwgX2JveCQxICkuYXBwbHlNYXRyaXg0KCBfbWF0cml4JDEgKTtcblx0XHRcdGJvdW5kaW5nQm94LnVuaW9uKCBfYm94JDEgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlKCkge1xuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xuXHRcdGNvbnN0IGluc3RhbmNlSW5mbyA9IHRoaXMuX2luc3RhbmNlSW5mbztcblxuXHRcdGJvdW5kaW5nU3BoZXJlLm1ha2VFbXB0eSgpO1xuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluc3RhbmNlSW5mby5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIGluc3RhbmNlSW5mb1sgaSBdLmFjdGl2ZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnlJZCA9IGluc3RhbmNlSW5mb1sgaSBdLmdlb21ldHJ5SW5kZXg7XG5cdFx0XHR0aGlzLmdldE1hdHJpeEF0KCBpLCBfbWF0cml4JDEgKTtcblx0XHRcdHRoaXMuZ2V0Qm91bmRpbmdTcGhlcmVBdCggZ2VvbWV0cnlJZCwgX3NwaGVyZSQyICkuYXBwbHlNYXRyaXg0KCBfbWF0cml4JDEgKTtcblx0XHRcdGJvdW5kaW5nU3BoZXJlLnVuaW9uKCBfc3BoZXJlJDIgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0YWRkSW5zdGFuY2UoIGdlb21ldHJ5SWQgKSB7XG5cblx0XHRjb25zdCBhdENhcGFjaXR5ID0gdGhpcy5faW5zdGFuY2VJbmZvLmxlbmd0aCA+PSB0aGlzLm1heEluc3RhbmNlQ291bnQ7XG5cblx0XHQvLyBlbnN1cmUgd2UncmUgbm90IG92ZXIgZ2VvbWV0cnlcblx0XHRpZiAoIGF0Q2FwYWNpdHkgJiYgdGhpcy5fYXZhaWxhYmxlSW5zdGFuY2VJZHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5CYXRjaGVkTWVzaDogTWF4aW11bSBpdGVtIGNvdW50IHJlYWNoZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5zdGFuY2VJbmZvID0ge1xuXHRcdFx0dmlzaWJsZTogdHJ1ZSxcblx0XHRcdGFjdGl2ZTogdHJ1ZSxcblx0XHRcdGdlb21ldHJ5SW5kZXg6IGdlb21ldHJ5SWQsXG5cdFx0fTtcblxuXHRcdGxldCBkcmF3SWQgPSBudWxsO1xuXG5cdFx0Ly8gUHJpb3JpdGl6ZSB1c2luZyBwcmV2aW91c2x5IGZyZWVkIGluc3RhbmNlIGlkc1xuXHRcdGlmICggdGhpcy5fYXZhaWxhYmxlSW5zdGFuY2VJZHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0dGhpcy5fYXZhaWxhYmxlSW5zdGFuY2VJZHMuc29ydCggYXNjSWRTb3J0ICk7XG5cblx0XHRcdGRyYXdJZCA9IHRoaXMuX2F2YWlsYWJsZUluc3RhbmNlSWRzLnNoaWZ0KCk7XG5cdFx0XHR0aGlzLl9pbnN0YW5jZUluZm9bIGRyYXdJZCBdID0gaW5zdGFuY2VJbmZvO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0ZHJhd0lkID0gdGhpcy5faW5zdGFuY2VJbmZvLmxlbmd0aDtcblx0XHRcdHRoaXMuX2luc3RhbmNlSW5mby5wdXNoKCBpbnN0YW5jZUluZm8gKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IG1hdHJpY2VzVGV4dHVyZSA9IHRoaXMuX21hdHJpY2VzVGV4dHVyZTtcblx0XHRfbWF0cml4JDEuaWRlbnRpdHkoKS50b0FycmF5KCBtYXRyaWNlc1RleHR1cmUuaW1hZ2UuZGF0YSwgZHJhd0lkICogMTYgKTtcblx0XHRtYXRyaWNlc1RleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0Y29uc3QgY29sb3JzVGV4dHVyZSA9IHRoaXMuX2NvbG9yc1RleHR1cmU7XG5cdFx0aWYgKCBjb2xvcnNUZXh0dXJlICkge1xuXG5cdFx0XHRfd2hpdGVDb2xvci50b0FycmF5KCBjb2xvcnNUZXh0dXJlLmltYWdlLmRhdGEsIGRyYXdJZCAqIDQgKTtcblx0XHRcdGNvbG9yc1RleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fdmlzaWJpbGl0eUNoYW5nZWQgPSB0cnVlO1xuXHRcdHJldHVybiBkcmF3SWQ7XG5cblx0fVxuXG5cdGFkZEdlb21ldHJ5KCBnZW9tZXRyeSwgcmVzZXJ2ZWRWZXJ0ZXhDb3VudCA9IC0gMSwgcmVzZXJ2ZWRJbmRleENvdW50ID0gLSAxICkge1xuXG5cdFx0dGhpcy5faW5pdGlhbGl6ZUdlb21ldHJ5KCBnZW9tZXRyeSApO1xuXG5cdFx0dGhpcy5fdmFsaWRhdGVHZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5SW5mbyA9IHtcblx0XHRcdC8vIGdlb21ldHJ5IGluZm9ybWF0aW9uXG5cdFx0XHR2ZXJ0ZXhTdGFydDogLSAxLFxuXHRcdFx0dmVydGV4Q291bnQ6IC0gMSxcblx0XHRcdHJlc2VydmVkVmVydGV4Q291bnQ6IC0gMSxcblxuXHRcdFx0aW5kZXhTdGFydDogLSAxLFxuXHRcdFx0aW5kZXhDb3VudDogLSAxLFxuXHRcdFx0cmVzZXJ2ZWRJbmRleENvdW50OiAtIDEsXG5cblx0XHRcdC8vIGRyYXcgcmFuZ2UgaW5mb3JtYXRpb25cblx0XHRcdHN0YXJ0OiAtIDEsXG5cdFx0XHRjb3VudDogLSAxLFxuXG5cdFx0XHQvLyBzdGF0ZVxuXHRcdFx0Ym91bmRpbmdCb3g6IG51bGwsXG5cdFx0XHRib3VuZGluZ1NwaGVyZTogbnVsbCxcblx0XHRcdGFjdGl2ZTogdHJ1ZSxcblx0XHR9O1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnlJbmZvTGlzdCA9IHRoaXMuX2dlb21ldHJ5SW5mbztcblx0XHRnZW9tZXRyeUluZm8udmVydGV4U3RhcnQgPSB0aGlzLl9uZXh0VmVydGV4U3RhcnQ7XG5cdFx0Z2VvbWV0cnlJbmZvLnJlc2VydmVkVmVydGV4Q291bnQgPSByZXNlcnZlZFZlcnRleENvdW50ID09PSAtIDEgPyBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKS5jb3VudCA6IHJlc2VydmVkVmVydGV4Q291bnQ7XG5cblx0XHRjb25zdCBpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG5cdFx0Y29uc3QgaGFzSW5kZXggPSBpbmRleCAhPT0gbnVsbDtcblx0XHRpZiAoIGhhc0luZGV4ICkge1xuXG5cdFx0XHRnZW9tZXRyeUluZm8uaW5kZXhTdGFydCA9IHRoaXMuX25leHRJbmRleFN0YXJ0O1xuXHRcdFx0Z2VvbWV0cnlJbmZvLnJlc2VydmVkSW5kZXhDb3VudCA9IHJlc2VydmVkSW5kZXhDb3VudCA9PT0gLSAxID8gaW5kZXguY291bnQgOiByZXNlcnZlZEluZGV4Q291bnQ7XG5cblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHRnZW9tZXRyeUluZm8uaW5kZXhTdGFydCAhPT0gLSAxICYmXG5cdFx0XHRnZW9tZXRyeUluZm8uaW5kZXhTdGFydCArIGdlb21ldHJ5SW5mby5yZXNlcnZlZEluZGV4Q291bnQgPiB0aGlzLl9tYXhJbmRleENvdW50IHx8XG5cdFx0XHRnZW9tZXRyeUluZm8udmVydGV4U3RhcnQgKyBnZW9tZXRyeUluZm8ucmVzZXJ2ZWRWZXJ0ZXhDb3VudCA+IHRoaXMuX21heFZlcnRleENvdW50XG5cdFx0KSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkJhdGNoZWRNZXNoOiBSZXNlcnZlZCBzcGFjZSByZXF1ZXN0IGV4Y2VlZHMgdGhlIG1heGltdW0gYnVmZmVyIHNpemUuJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIGlkXG5cdFx0bGV0IGdlb21ldHJ5SWQ7XG5cdFx0aWYgKCB0aGlzLl9hdmFpbGFibGVHZW9tZXRyeUlkcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHR0aGlzLl9hdmFpbGFibGVHZW9tZXRyeUlkcy5zb3J0KCBhc2NJZFNvcnQgKTtcblxuXHRcdFx0Z2VvbWV0cnlJZCA9IHRoaXMuX2F2YWlsYWJsZUdlb21ldHJ5SWRzLnNoaWZ0KCk7XG5cdFx0XHRnZW9tZXRyeUluZm9MaXN0WyBnZW9tZXRyeUlkIF0gPSBnZW9tZXRyeUluZm87XG5cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGdlb21ldHJ5SWQgPSB0aGlzLl9nZW9tZXRyeUNvdW50O1xuXHRcdFx0dGhpcy5fZ2VvbWV0cnlDb3VudCArKztcblx0XHRcdGdlb21ldHJ5SW5mb0xpc3QucHVzaCggZ2VvbWV0cnlJbmZvICk7XG5cblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgdGhlIGdlb21ldHJ5XG5cdFx0dGhpcy5zZXRHZW9tZXRyeUF0KCBnZW9tZXRyeUlkLCBnZW9tZXRyeSApO1xuXG5cdFx0Ly8gaW5jcmVtZW50IHRoZSBuZXh0IGdlb21ldHJ5IHBvc2l0aW9uXG5cdFx0dGhpcy5fbmV4dEluZGV4U3RhcnQgPSBnZW9tZXRyeUluZm8uaW5kZXhTdGFydCArIGdlb21ldHJ5SW5mby5yZXNlcnZlZEluZGV4Q291bnQ7XG5cdFx0dGhpcy5fbmV4dFZlcnRleFN0YXJ0ID0gZ2VvbWV0cnlJbmZvLnZlcnRleFN0YXJ0ICsgZ2VvbWV0cnlJbmZvLnJlc2VydmVkVmVydGV4Q291bnQ7XG5cblx0XHRyZXR1cm4gZ2VvbWV0cnlJZDtcblxuXHR9XG5cblx0c2V0R2VvbWV0cnlBdCggZ2VvbWV0cnlJZCwgZ2VvbWV0cnkgKSB7XG5cblx0XHRpZiAoIGdlb21ldHJ5SWQgPj0gdGhpcy5fZ2VvbWV0cnlDb3VudCApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuQmF0Y2hlZE1lc2g6IE1heGltdW0gZ2VvbWV0cnkgY291bnQgcmVhY2hlZC4nICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl92YWxpZGF0ZUdlb21ldHJ5KCBnZW9tZXRyeSApO1xuXG5cdFx0Y29uc3QgYmF0Y2hHZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgaGFzSW5kZXggPSBiYXRjaEdlb21ldHJ5LmdldEluZGV4KCkgIT09IG51bGw7XG5cdFx0Y29uc3QgZHN0SW5kZXggPSBiYXRjaEdlb21ldHJ5LmdldEluZGV4KCk7XG5cdFx0Y29uc3Qgc3JjSW5kZXggPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuXHRcdGNvbnN0IGdlb21ldHJ5SW5mbyA9IHRoaXMuX2dlb21ldHJ5SW5mb1sgZ2VvbWV0cnlJZCBdO1xuXHRcdGlmIChcblx0XHRcdGhhc0luZGV4ICYmXG5cdFx0XHRzcmNJbmRleC5jb3VudCA+IGdlb21ldHJ5SW5mby5yZXNlcnZlZEluZGV4Q291bnQgfHxcblx0XHRcdGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQgPiBnZW9tZXRyeUluZm8ucmVzZXJ2ZWRWZXJ0ZXhDb3VudFxuXHRcdCkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5CYXRjaGVkTWVzaDogUmVzZXJ2ZWQgc3BhY2Ugbm90IGxhcmdlIGVub3VnaCBmb3IgcHJvdmlkZWQgZ2VvbWV0cnkuJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29weSBnZW9tZXRyeSBidWZmZXIgZGF0YSBvdmVyXG5cdFx0Y29uc3QgdmVydGV4U3RhcnQgPSBnZW9tZXRyeUluZm8udmVydGV4U3RhcnQ7XG5cdFx0Y29uc3QgcmVzZXJ2ZWRWZXJ0ZXhDb3VudCA9IGdlb21ldHJ5SW5mby5yZXNlcnZlZFZlcnRleENvdW50O1xuXHRcdGdlb21ldHJ5SW5mby52ZXJ0ZXhDb3VudCA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApLmNvdW50O1xuXG5cdFx0Zm9yICggY29uc3QgYXR0cmlidXRlTmFtZSBpbiBiYXRjaEdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdC8vIGNvcHkgYXR0cmlidXRlIGRhdGFcblx0XHRcdGNvbnN0IHNyY0F0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggYXR0cmlidXRlTmFtZSApO1xuXHRcdFx0Y29uc3QgZHN0QXR0cmlidXRlID0gYmF0Y2hHZW9tZXRyeS5nZXRBdHRyaWJ1dGUoIGF0dHJpYnV0ZU5hbWUgKTtcblx0XHRcdGNvcHlBdHRyaWJ1dGVEYXRhKCBzcmNBdHRyaWJ1dGUsIGRzdEF0dHJpYnV0ZSwgdmVydGV4U3RhcnQgKTtcblxuXHRcdFx0Ly8gZmlsbCB0aGUgcmVzdCBpbiB3aXRoIHplcm9lc1xuXHRcdFx0Y29uc3QgaXRlbVNpemUgPSBzcmNBdHRyaWJ1dGUuaXRlbVNpemU7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IHNyY0F0dHJpYnV0ZS5jb3VudCwgbCA9IHJlc2VydmVkVmVydGV4Q291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gdmVydGV4U3RhcnQgKyBpO1xuXHRcdFx0XHRmb3IgKCBsZXQgYyA9IDA7IGMgPCBpdGVtU2l6ZTsgYyArKyApIHtcblxuXHRcdFx0XHRcdGRzdEF0dHJpYnV0ZS5zZXRDb21wb25lbnQoIGluZGV4LCBjLCAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGRzdEF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRkc3RBdHRyaWJ1dGUuYWRkVXBkYXRlUmFuZ2UoIHZlcnRleFN0YXJ0ICogaXRlbVNpemUsIHJlc2VydmVkVmVydGV4Q291bnQgKiBpdGVtU2l6ZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29weSBpbmRleFxuXHRcdGlmICggaGFzSW5kZXggKSB7XG5cblx0XHRcdGNvbnN0IGluZGV4U3RhcnQgPSBnZW9tZXRyeUluZm8uaW5kZXhTdGFydDtcblx0XHRcdGNvbnN0IHJlc2VydmVkSW5kZXhDb3VudCA9IGdlb21ldHJ5SW5mby5yZXNlcnZlZEluZGV4Q291bnQ7XG5cdFx0XHRnZW9tZXRyeUluZm8uaW5kZXhDb3VudCA9IGdlb21ldHJ5LmdldEluZGV4KCkuY291bnQ7XG5cblx0XHRcdC8vIGNvcHkgaW5kZXggZGF0YSBvdmVyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzcmNJbmRleC5jb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHRkc3RJbmRleC5zZXRYKCBpbmRleFN0YXJ0ICsgaSwgdmVydGV4U3RhcnQgKyBzcmNJbmRleC5nZXRYKCBpICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBmaWxsIHRoZSByZXN0IGluIHdpdGggemVyb2VzXG5cdFx0XHRmb3IgKCBsZXQgaSA9IHNyY0luZGV4LmNvdW50LCBsID0gcmVzZXJ2ZWRJbmRleENvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRkc3RJbmRleC5zZXRYKCBpbmRleFN0YXJ0ICsgaSwgdmVydGV4U3RhcnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRkc3RJbmRleC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRkc3RJbmRleC5hZGRVcGRhdGVSYW5nZSggaW5kZXhTdGFydCwgZ2VvbWV0cnlJbmZvLnJlc2VydmVkSW5kZXhDb3VudCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIHRoZSBkcmF3IHJhbmdlXG5cdFx0Z2VvbWV0cnlJbmZvLnN0YXJ0ID0gaGFzSW5kZXggPyBnZW9tZXRyeUluZm8uaW5kZXhTdGFydCA6IGdlb21ldHJ5SW5mby52ZXJ0ZXhTdGFydDtcblx0XHRnZW9tZXRyeUluZm8uY291bnQgPSBoYXNJbmRleCA/IGdlb21ldHJ5SW5mby5pbmRleENvdW50IDogZ2VvbWV0cnlJbmZvLnZlcnRleENvdW50O1xuXG5cdFx0Ly8gc3RvcmUgdGhlIGJvdW5kaW5nIGJveGVzXG5cdFx0Z2VvbWV0cnlJbmZvLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG5cdFx0XHRnZW9tZXRyeUluZm8uYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Z2VvbWV0cnlJbmZvLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRnZW9tZXRyeUluZm8uYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fdmlzaWJpbGl0eUNoYW5nZWQgPSB0cnVlO1xuXHRcdHJldHVybiBnZW9tZXRyeUlkO1xuXG5cdH1cblxuXHRkZWxldGVHZW9tZXRyeSggZ2VvbWV0cnlJZCApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5SW5mb0xpc3QgPSB0aGlzLl9nZW9tZXRyeUluZm87XG5cdFx0aWYgKCBnZW9tZXRyeUlkID49IGdlb21ldHJ5SW5mb0xpc3QubGVuZ3RoIHx8IGdlb21ldHJ5SW5mb0xpc3RbIGdlb21ldHJ5SWQgXS5hY3RpdmUgPT09IGZhbHNlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdC8vIGRlbGV0ZSBhbnkgaW5zdGFuY2VzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGdlb21ldHJ5XG5cdFx0Y29uc3QgaW5zdGFuY2VJbmZvID0gdGhpcy5faW5zdGFuY2VJbmZvO1xuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluc3RhbmNlSW5mby5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIGluc3RhbmNlSW5mb1sgaSBdLmdlb21ldHJ5SW5kZXggPT09IGdlb21ldHJ5SWQgKSB7XG5cblx0XHRcdFx0dGhpcy5kZWxldGVJbnN0YW5jZSggaSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeUluZm9MaXN0WyBnZW9tZXRyeUlkIF0uYWN0aXZlID0gZmFsc2U7XG5cdFx0dGhpcy5fYXZhaWxhYmxlR2VvbWV0cnlJZHMucHVzaCggZ2VvbWV0cnlJZCApO1xuXHRcdHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2VkID0gdHJ1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkZWxldGVJbnN0YW5jZSggaW5zdGFuY2VJZCApIHtcblxuXHRcdHRoaXMudmFsaWRhdGVJbnN0YW5jZUlkKCBpbnN0YW5jZUlkICk7XG5cblx0XHR0aGlzLl9pbnN0YW5jZUluZm9bIGluc3RhbmNlSWQgXS5hY3RpdmUgPSBmYWxzZTtcblx0XHR0aGlzLl9hdmFpbGFibGVJbnN0YW5jZUlkcy5wdXNoKCBpbnN0YW5jZUlkICk7XG5cdFx0dGhpcy5fdmlzaWJpbGl0eUNoYW5nZWQgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG9wdGltaXplKCkge1xuXG5cdFx0Ly8gdHJhY2sgdGhlIG5leHQgaW5kaWNlcyB0byBjb3B5IGRhdGEgdG9cblx0XHRsZXQgbmV4dFZlcnRleFN0YXJ0ID0gMDtcblx0XHRsZXQgbmV4dEluZGV4U3RhcnQgPSAwO1xuXG5cdFx0Ly8gSXRlcmF0ZSBvdmVyIGFsbCBnZW9tZXRyeSByYW5nZXMgaW4gb3JkZXIgc29ydGVkIGZyb20gZWFybGllc3QgaW4gdGhlIGdlb21ldHJ5IGJ1ZmZlciB0byBsYXRlc3Rcblx0XHQvLyBpbiB0aGUgZ2VvbWV0cnkgYnVmZmVyLiBCZWNhdXNlIGRyYXcgcmFuZ2Ugb2JqZWN0cyBjYW4gYmUgcmV1c2VkIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSBvZiB0aGVpciBvcmRlci5cblx0XHRjb25zdCBnZW9tZXRyeUluZm9MaXN0ID0gdGhpcy5fZ2VvbWV0cnlJbmZvO1xuXHRcdGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeUluZm9MaXN0XG5cdFx0XHQubWFwKCAoIGUsIGkgKSA9PiBpIClcblx0XHRcdC5zb3J0KCAoIGEsIGIgKSA9PiB7XG5cblx0XHRcdFx0cmV0dXJuIGdlb21ldHJ5SW5mb0xpc3RbIGEgXS52ZXJ0ZXhTdGFydCAtIGdlb21ldHJ5SW5mb0xpc3RbIGIgXS52ZXJ0ZXhTdGFydDtcblxuXHRcdFx0fSApO1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGdlb21ldHJ5SW5mb0xpc3QubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Ly8gaWYgYSBnZW9tZXRyeSByYW5nZSBpcyBpbmFjdGl2ZSB0aGVuIGRvbid0IGNvcHkgYW55dGhpbmdcblx0XHRcdGNvbnN0IGluZGV4ID0gaW5kaWNlc1sgaSBdO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnlJbmZvID0gZ2VvbWV0cnlJbmZvTGlzdFsgaW5kZXggXTtcblx0XHRcdGlmICggZ2VvbWV0cnlJbmZvLmFjdGl2ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgYSBnZW9tZXRyeSBjb250YWlucyBhbiBpbmRleCBidWZmZXIgdGhlbiBzaGlmdCBpdCwgYXMgd2VsbFxuXHRcdFx0aWYgKCBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5SW5mby5pbmRleFN0YXJ0ICE9PSBuZXh0SW5kZXhTdGFydCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHsgaW5kZXhTdGFydCwgdmVydGV4U3RhcnQsIHJlc2VydmVkSW5kZXhDb3VudCB9ID0gZ2VvbWV0cnlJbmZvO1xuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRcdFx0Y29uc3QgYXJyYXkgPSBpbmRleC5hcnJheTtcblxuXHRcdFx0XHRcdC8vIHNoaWZ0IHRoZSBpbmRleCBwb2ludGVycyBiYXNlZCBvbiBob3cgdGhlIHZlcnRleCBkYXRhIHdpbGwgc2hpZnRcblx0XHRcdFx0XHQvLyBhZGp1c3RpbmcgdGhlIGluZGV4IG11c3QgaGFwcGVuIGZpcnN0IHNvIHRoZSBvcmlnaW5hbCB2ZXJ0ZXggc3RhcnQgdmFsdWUgaXMgYXZhaWxhYmxlXG5cdFx0XHRcdFx0Y29uc3QgZWxlbWVudERlbHRhID0gbmV4dFZlcnRleFN0YXJ0IC0gdmVydGV4U3RhcnQ7XG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSBpbmRleFN0YXJ0OyBqIDwgaW5kZXhTdGFydCArIHJlc2VydmVkSW5kZXhDb3VudDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0YXJyYXlbIGogXSA9IGFycmF5WyBqIF0gKyBlbGVtZW50RGVsdGE7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbmRleC5hcnJheS5jb3B5V2l0aGluKCBuZXh0SW5kZXhTdGFydCwgaW5kZXhTdGFydCwgaW5kZXhTdGFydCArIHJlc2VydmVkSW5kZXhDb3VudCApO1xuXHRcdFx0XHRcdGluZGV4LmFkZFVwZGF0ZVJhbmdlKCBuZXh0SW5kZXhTdGFydCwgcmVzZXJ2ZWRJbmRleENvdW50ICk7XG5cblx0XHRcdFx0XHRnZW9tZXRyeUluZm8uaW5kZXhTdGFydCA9IG5leHRJbmRleFN0YXJ0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRuZXh0SW5kZXhTdGFydCArPSBnZW9tZXRyeUluZm8ucmVzZXJ2ZWRJbmRleENvdW50O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIGEgZ2VvbWV0cnkgbmVlZHMgdG8gYmUgbW92ZWQgdGhlbiBjb3B5IGF0dHJpYnV0ZSBkYXRhIHRvIG92ZXJ3cml0ZSB1bnVzZWQgc3BhY2Vcblx0XHRcdGlmICggZ2VvbWV0cnlJbmZvLnZlcnRleFN0YXJ0ICE9PSBuZXh0VmVydGV4U3RhcnQgKSB7XG5cblx0XHRcdFx0Y29uc3QgeyB2ZXJ0ZXhTdGFydCwgcmVzZXJ2ZWRWZXJ0ZXhDb3VudCB9ID0gZ2VvbWV0cnlJbmZvO1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRcdFx0Zm9yICggY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcblx0XHRcdFx0XHRjb25zdCB7IGFycmF5LCBpdGVtU2l6ZSB9ID0gYXR0cmlidXRlO1xuXHRcdFx0XHRcdGFycmF5LmNvcHlXaXRoaW4oIG5leHRWZXJ0ZXhTdGFydCAqIGl0ZW1TaXplLCB2ZXJ0ZXhTdGFydCAqIGl0ZW1TaXplLCAoIHZlcnRleFN0YXJ0ICsgcmVzZXJ2ZWRWZXJ0ZXhDb3VudCApICogaXRlbVNpemUgKTtcblx0XHRcdFx0XHRhdHRyaWJ1dGUuYWRkVXBkYXRlUmFuZ2UoIG5leHRWZXJ0ZXhTdGFydCAqIGl0ZW1TaXplLCByZXNlcnZlZFZlcnRleENvdW50ICogaXRlbVNpemUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnlJbmZvLnZlcnRleFN0YXJ0ID0gbmV4dFZlcnRleFN0YXJ0O1xuXG5cdFx0XHR9XG5cblx0XHRcdG5leHRWZXJ0ZXhTdGFydCArPSBnZW9tZXRyeUluZm8ucmVzZXJ2ZWRWZXJ0ZXhDb3VudDtcblx0XHRcdGdlb21ldHJ5SW5mby5zdGFydCA9IGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnlJbmZvLmluZGV4U3RhcnQgOiBnZW9tZXRyeUluZm8udmVydGV4U3RhcnQ7XG5cblx0XHRcdC8vIHN0ZXAgdGhlIG5leHQgZ2VvbWV0cnkgcG9pbnRzIHRvIHRoZSBzaGlmdGVkIHBvc2l0aW9uXG5cdFx0XHR0aGlzLl9uZXh0SW5kZXhTdGFydCA9IGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnlJbmZvLmluZGV4U3RhcnQgKyBnZW9tZXRyeUluZm8ucmVzZXJ2ZWRJbmRleENvdW50IDogMDtcblx0XHRcdHRoaXMuX25leHRWZXJ0ZXhTdGFydCA9IGdlb21ldHJ5SW5mby52ZXJ0ZXhTdGFydCArIGdlb21ldHJ5SW5mby5yZXNlcnZlZFZlcnRleENvdW50O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vIGdldCBib3VuZGluZyBib3ggYW5kIGNvbXB1dGUgaXQgaWYgaXQgZG9lc24ndCBleGlzdFxuXHRnZXRCb3VuZGluZ0JveEF0KCBnZW9tZXRyeUlkLCB0YXJnZXQgKSB7XG5cblx0XHRpZiAoIGdlb21ldHJ5SWQgPj0gdGhpcy5fZ2VvbWV0cnlDb3VudCApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHQvLyBjb21wdXRlIGJvdW5kaW5nIGJveFxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRjb25zdCBnZW9tZXRyeUluZm8gPSB0aGlzLl9nZW9tZXRyeUluZm9bIGdlb21ldHJ5SWQgXTtcblx0XHRpZiAoIGdlb21ldHJ5SW5mby5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgYm94ID0gbmV3IEJveDMoKTtcblx0XHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRmb3IgKCBsZXQgaSA9IGdlb21ldHJ5SW5mby5zdGFydCwgbCA9IGdlb21ldHJ5SW5mby5zdGFydCArIGdlb21ldHJ5SW5mby5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0bGV0IGl2ID0gaTtcblx0XHRcdFx0aWYgKCBpbmRleCApIHtcblxuXHRcdFx0XHRcdGl2ID0gaW5kZXguZ2V0WCggaXYgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ym94LmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IkNS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaXYgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5SW5mby5ib3VuZGluZ0JveCA9IGJveDtcblxuXHRcdH1cblxuXHRcdHRhcmdldC5jb3B5KCBnZW9tZXRyeUluZm8uYm91bmRpbmdCb3ggKTtcblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHQvLyBnZXQgYm91bmRpbmcgc3BoZXJlIGFuZCBjb21wdXRlIGl0IGlmIGl0IGRvZXNuJ3QgZXhpc3Rcblx0Z2V0Qm91bmRpbmdTcGhlcmVBdCggZ2VvbWV0cnlJZCwgdGFyZ2V0ICkge1xuXG5cdFx0aWYgKCBnZW9tZXRyeUlkID49IHRoaXMuX2dlb21ldHJ5Q291bnQgKSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29tcHV0ZSBib3VuZGluZyBzcGhlcmVcblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgZ2VvbWV0cnlJbmZvID0gdGhpcy5fZ2VvbWV0cnlJbmZvWyBnZW9tZXRyeUlkIF07XG5cdFx0aWYgKCBnZW9tZXRyeUluZm8uYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnN0IHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblx0XHRcdHRoaXMuZ2V0Qm91bmRpbmdCb3hBdCggZ2VvbWV0cnlJZCwgX2JveCQxICk7XG5cdFx0XHRfYm94JDEuZ2V0Q2VudGVyKCBzcGhlcmUuY2VudGVyICk7XG5cblx0XHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdGxldCBtYXhSYWRpdXNTcSA9IDA7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IGdlb21ldHJ5SW5mby5zdGFydCwgbCA9IGdlb21ldHJ5SW5mby5zdGFydCArIGdlb21ldHJ5SW5mby5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0bGV0IGl2ID0gaTtcblx0XHRcdFx0aWYgKCBpbmRleCApIHtcblxuXHRcdFx0XHRcdGl2ID0gaW5kZXguZ2V0WCggaXYgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X3ZlY3RvciQ1LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpdiApO1xuXHRcdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggX3ZlY3RvciQ1ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzcGhlcmUucmFkaXVzID0gTWF0aC5zcXJ0KCBtYXhSYWRpdXNTcSApO1xuXHRcdFx0Z2VvbWV0cnlJbmZvLmJvdW5kaW5nU3BoZXJlID0gc3BoZXJlO1xuXG5cdFx0fVxuXG5cdFx0dGFyZ2V0LmNvcHkoIGdlb21ldHJ5SW5mby5ib3VuZGluZ1NwaGVyZSApO1xuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdHNldE1hdHJpeEF0KCBpbnN0YW5jZUlkLCBtYXRyaXggKSB7XG5cblx0XHR0aGlzLnZhbGlkYXRlSW5zdGFuY2VJZCggaW5zdGFuY2VJZCApO1xuXG5cdFx0Y29uc3QgbWF0cmljZXNUZXh0dXJlID0gdGhpcy5fbWF0cmljZXNUZXh0dXJlO1xuXHRcdGNvbnN0IG1hdHJpY2VzQXJyYXkgPSB0aGlzLl9tYXRyaWNlc1RleHR1cmUuaW1hZ2UuZGF0YTtcblx0XHRtYXRyaXgudG9BcnJheSggbWF0cmljZXNBcnJheSwgaW5zdGFuY2VJZCAqIDE2ICk7XG5cdFx0bWF0cmljZXNUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRNYXRyaXhBdCggaW5zdGFuY2VJZCwgbWF0cml4ICkge1xuXG5cdFx0dGhpcy52YWxpZGF0ZUluc3RhbmNlSWQoIGluc3RhbmNlSWQgKTtcblx0XHRyZXR1cm4gbWF0cml4LmZyb21BcnJheSggdGhpcy5fbWF0cmljZXNUZXh0dXJlLmltYWdlLmRhdGEsIGluc3RhbmNlSWQgKiAxNiApO1xuXG5cdH1cblxuXHRzZXRDb2xvckF0KCBpbnN0YW5jZUlkLCBjb2xvciApIHtcblxuXHRcdHRoaXMudmFsaWRhdGVJbnN0YW5jZUlkKCBpbnN0YW5jZUlkICk7XG5cblx0XHRpZiAoIHRoaXMuX2NvbG9yc1RleHR1cmUgPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX2luaXRDb2xvcnNUZXh0dXJlKCk7XG5cblx0XHR9XG5cblx0XHRjb2xvci50b0FycmF5KCB0aGlzLl9jb2xvcnNUZXh0dXJlLmltYWdlLmRhdGEsIGluc3RhbmNlSWQgKiA0ICk7XG5cdFx0dGhpcy5fY29sb3JzVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Q29sb3JBdCggaW5zdGFuY2VJZCwgY29sb3IgKSB7XG5cblx0XHR0aGlzLnZhbGlkYXRlSW5zdGFuY2VJZCggaW5zdGFuY2VJZCApO1xuXHRcdHJldHVybiBjb2xvci5mcm9tQXJyYXkoIHRoaXMuX2NvbG9yc1RleHR1cmUuaW1hZ2UuZGF0YSwgaW5zdGFuY2VJZCAqIDQgKTtcblxuXHR9XG5cblx0c2V0VmlzaWJsZUF0KCBpbnN0YW5jZUlkLCB2YWx1ZSApIHtcblxuXHRcdHRoaXMudmFsaWRhdGVJbnN0YW5jZUlkKCBpbnN0YW5jZUlkICk7XG5cblx0XHRpZiAoIHRoaXMuX2luc3RhbmNlSW5mb1sgaW5zdGFuY2VJZCBdLnZpc2libGUgPT09IHZhbHVlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdHRoaXMuX2luc3RhbmNlSW5mb1sgaW5zdGFuY2VJZCBdLnZpc2libGUgPSB2YWx1ZTtcblx0XHR0aGlzLl92aXNpYmlsaXR5Q2hhbmdlZCA9IHRydWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0VmlzaWJsZUF0KCBpbnN0YW5jZUlkICkge1xuXG5cdFx0dGhpcy52YWxpZGF0ZUluc3RhbmNlSWQoIGluc3RhbmNlSWQgKTtcblxuXHRcdHJldHVybiB0aGlzLl9pbnN0YW5jZUluZm9bIGluc3RhbmNlSWQgXS52aXNpYmxlO1xuXG5cdH1cblxuXHRzZXRHZW9tZXRyeUlkQXQoIGluc3RhbmNlSWQsIGdlb21ldHJ5SWQgKSB7XG5cblx0XHR0aGlzLnZhbGlkYXRlSW5zdGFuY2VJZCggaW5zdGFuY2VJZCApO1xuXHRcdHRoaXMudmFsaWRhdGVHZW9tZXRyeUlkKCBnZW9tZXRyeUlkICk7XG5cblx0XHR0aGlzLl9pbnN0YW5jZUluZm9bIGluc3RhbmNlSWQgXS5nZW9tZXRyeUluZGV4ID0gZ2VvbWV0cnlJZDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRHZW9tZXRyeUlkQXQoIGluc3RhbmNlSWQgKSB7XG5cblx0XHR0aGlzLnZhbGlkYXRlSW5zdGFuY2VJZCggaW5zdGFuY2VJZCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuX2luc3RhbmNlSW5mb1sgaW5zdGFuY2VJZCBdLmdlb21ldHJ5SW5kZXg7XG5cblx0fVxuXG5cdGdldEdlb21ldHJ5UmFuZ2VBdCggZ2VvbWV0cnlJZCwgdGFyZ2V0ID0ge30gKSB7XG5cblx0XHR0aGlzLnZhbGlkYXRlR2VvbWV0cnlJZCggZ2VvbWV0cnlJZCApO1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnlJbmZvID0gdGhpcy5fZ2VvbWV0cnlJbmZvWyBnZW9tZXRyeUlkIF07XG5cdFx0dGFyZ2V0LnZlcnRleFN0YXJ0ID0gZ2VvbWV0cnlJbmZvLnZlcnRleFN0YXJ0O1xuXHRcdHRhcmdldC52ZXJ0ZXhDb3VudCA9IGdlb21ldHJ5SW5mby52ZXJ0ZXhDb3VudDtcblx0XHR0YXJnZXQucmVzZXJ2ZWRWZXJ0ZXhDb3VudCA9IGdlb21ldHJ5SW5mby5yZXNlcnZlZFZlcnRleENvdW50O1xuXG5cdFx0dGFyZ2V0LmluZGV4U3RhcnQgPSBnZW9tZXRyeUluZm8uaW5kZXhTdGFydDtcblx0XHR0YXJnZXQuaW5kZXhDb3VudCA9IGdlb21ldHJ5SW5mby5pbmRleENvdW50O1xuXHRcdHRhcmdldC5yZXNlcnZlZEluZGV4Q291bnQgPSBnZW9tZXRyeUluZm8ucmVzZXJ2ZWRJbmRleENvdW50O1xuXG5cdFx0dGFyZ2V0LnN0YXJ0ID0gZ2VvbWV0cnlJbmZvLnN0YXJ0O1xuXHRcdHRhcmdldC5jb3VudCA9IGdlb21ldHJ5SW5mby5jb3VudDtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdHNldEluc3RhbmNlQ291bnQoIG1heEluc3RhbmNlQ291bnQgKSB7XG5cblx0XHQvLyBzaHJpbmsgdGhlIGF2YWlsYWJsZSBpbnN0YW5jZXMgYXMgbXVjaCBhcyBwb3NzaWJsZVxuXHRcdGNvbnN0IGF2YWlsYWJsZUluc3RhbmNlSWRzID0gdGhpcy5fYXZhaWxhYmxlSW5zdGFuY2VJZHM7XG5cdFx0Y29uc3QgaW5zdGFuY2VJbmZvID0gdGhpcy5faW5zdGFuY2VJbmZvO1xuXHRcdGF2YWlsYWJsZUluc3RhbmNlSWRzLnNvcnQoIGFzY0lkU29ydCApO1xuXHRcdHdoaWxlICggYXZhaWxhYmxlSW5zdGFuY2VJZHNbIGF2YWlsYWJsZUluc3RhbmNlSWRzLmxlbmd0aCAtIDEgXSA9PT0gaW5zdGFuY2VJbmZvLmxlbmd0aCApIHtcblxuXHRcdFx0aW5zdGFuY2VJbmZvLnBvcCgpO1xuXHRcdFx0YXZhaWxhYmxlSW5zdGFuY2VJZHMucG9wKCk7XG5cblx0XHR9XG5cblx0XHQvLyB0aHJvdyBhbiBlcnJvciBpZiBpdCBjYW4ndCBiZSBzaHJ1bmsgdG8gdGhlIGRlc2lyZWQgc2l6ZVxuXHRcdGlmICggbWF4SW5zdGFuY2VDb3VudCA8IGluc3RhbmNlSW5mby5sZW5ndGggKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggYEJhdGNoZWRNZXNoOiBJbnN0YW5jZSBpZHMgb3V0c2lkZSB0aGUgcmFuZ2UgJHsgbWF4SW5zdGFuY2VDb3VudCB9IGFyZSBiZWluZyB1c2VkLiBDYW5ub3Qgc2hyaW5rIGluc3RhbmNlIGNvdW50LmAgKTtcblxuXHRcdH1cblxuXHRcdC8vIGNvcHkgdGhlIG11bHRpIGRyYXcgY291bnRzXG5cdFx0Y29uc3QgbXVsdGlEcmF3Q291bnRzID0gbmV3IEludDMyQXJyYXkoIG1heEluc3RhbmNlQ291bnQgKTtcblx0XHRjb25zdCBtdWx0aURyYXdTdGFydHMgPSBuZXcgSW50MzJBcnJheSggbWF4SW5zdGFuY2VDb3VudCApO1xuXHRcdGNvcHlBcnJheUNvbnRlbnRzKCB0aGlzLl9tdWx0aURyYXdDb3VudHMsIG11bHRpRHJhd0NvdW50cyApO1xuXHRcdGNvcHlBcnJheUNvbnRlbnRzKCB0aGlzLl9tdWx0aURyYXdTdGFydHMsIG11bHRpRHJhd1N0YXJ0cyApO1xuXG5cdFx0dGhpcy5fbXVsdGlEcmF3Q291bnRzID0gbXVsdGlEcmF3Q291bnRzO1xuXHRcdHRoaXMuX211bHRpRHJhd1N0YXJ0cyA9IG11bHRpRHJhd1N0YXJ0cztcblx0XHR0aGlzLl9tYXhJbnN0YW5jZUNvdW50ID0gbWF4SW5zdGFuY2VDb3VudDtcblxuXHRcdC8vIHVwZGF0ZSB0ZXh0dXJlIGRhdGEgZm9yIGluc3RhbmNlIHNhbXBsaW5nXG5cdFx0Y29uc3QgaW5kaXJlY3RUZXh0dXJlID0gdGhpcy5faW5kaXJlY3RUZXh0dXJlO1xuXHRcdGNvbnN0IG1hdHJpY2VzVGV4dHVyZSA9IHRoaXMuX21hdHJpY2VzVGV4dHVyZTtcblx0XHRjb25zdCBjb2xvcnNUZXh0dXJlID0gdGhpcy5fY29sb3JzVGV4dHVyZTtcblxuXHRcdGluZGlyZWN0VGV4dHVyZS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5faW5pdEluZGlyZWN0VGV4dHVyZSgpO1xuXHRcdGNvcHlBcnJheUNvbnRlbnRzKCBpbmRpcmVjdFRleHR1cmUuaW1hZ2UuZGF0YSwgdGhpcy5faW5kaXJlY3RUZXh0dXJlLmltYWdlLmRhdGEgKTtcblxuXHRcdG1hdHJpY2VzVGV4dHVyZS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5faW5pdE1hdHJpY2VzVGV4dHVyZSgpO1xuXHRcdGNvcHlBcnJheUNvbnRlbnRzKCBtYXRyaWNlc1RleHR1cmUuaW1hZ2UuZGF0YSwgdGhpcy5fbWF0cmljZXNUZXh0dXJlLmltYWdlLmRhdGEgKTtcblxuXHRcdGlmICggY29sb3JzVGV4dHVyZSApIHtcblxuXHRcdFx0Y29sb3JzVGV4dHVyZS5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLl9pbml0Q29sb3JzVGV4dHVyZSgpO1xuXHRcdFx0Y29weUFycmF5Q29udGVudHMoIGNvbG9yc1RleHR1cmUuaW1hZ2UuZGF0YSwgdGhpcy5fY29sb3JzVGV4dHVyZS5pbWFnZS5kYXRhICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldEdlb21ldHJ5U2l6ZSggbWF4VmVydGV4Q291bnQsIG1heEluZGV4Q291bnQgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB3ZSBjYW4gc2hyaW5rIHRvIHRoZSByZXF1ZXN0ZWQgdmVydGV4IGF0dHJpYnV0ZSBzaXplXG5cdFx0Y29uc3QgdmFsaWRSYW5nZXMgPSBbIC4uLnRoaXMuX2dlb21ldHJ5SW5mbyBdLmZpbHRlciggaW5mbyA9PiBpbmZvLmFjdGl2ZSApO1xuXHRcdGNvbnN0IHJlcXVpcmVkVmVydGV4TGVuZ3RoID0gTWF0aC5tYXgoIC4uLnZhbGlkUmFuZ2VzLm1hcCggcmFuZ2UgPT4gcmFuZ2UudmVydGV4U3RhcnQgKyByYW5nZS5yZXNlcnZlZFZlcnRleENvdW50ICkgKTtcblx0XHRpZiAoIHJlcXVpcmVkVmVydGV4TGVuZ3RoID4gbWF4VmVydGV4Q291bnQgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggYEJhdGNoZWRNZXNoOiBHZW9tZXRyeSB2ZXJ0ZXggdmFsdWVzIGFyZSBiZWluZyB1c2VkIG91dHNpZGUgdGhlIHJhbmdlICR7IG1heEluZGV4Q291bnQgfS4gQ2Fubm90IHNocmluayBmdXJ0aGVyLmAgKTtcblxuXHRcdH1cblxuXHRcdC8vIENoZWNrIGlmIHdlIGNhbiBzaHJpbmsgdG8gdGhlIHJlcXVlc3RlZCBpbmRleCBhdHRyaWJ1dGUgc2l6ZVxuXHRcdGlmICggdGhpcy5nZW9tZXRyeS5pbmRleCApIHtcblxuXHRcdFx0Y29uc3QgcmVxdWlyZWRJbmRleExlbmd0aCA9IE1hdGgubWF4KCAuLi52YWxpZFJhbmdlcy5tYXAoIHJhbmdlID0+IHJhbmdlLmluZGV4U3RhcnQgKyByYW5nZS5yZXNlcnZlZEluZGV4Q291bnQgKSApO1xuXHRcdFx0aWYgKCByZXF1aXJlZEluZGV4TGVuZ3RoID4gbWF4SW5kZXhDb3VudCApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBCYXRjaGVkTWVzaDogR2VvbWV0cnkgaW5kZXggdmFsdWVzIGFyZSBiZWluZyB1c2VkIG91dHNpZGUgdGhlIHJhbmdlICR7IG1heEluZGV4Q291bnQgfS4gQ2Fubm90IHNocmluayBmdXJ0aGVyLmAgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdC8vIGRpc3Bvc2Ugb2YgdGhlIHByZXZpb3VzIGdlb21ldHJ5XG5cdFx0Y29uc3Qgb2xkR2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdG9sZEdlb21ldHJ5LmRpc3Bvc2UoKTtcblxuXHRcdC8vIHJlY3JlYXRlIHRoZSBnZW9tZXRyeSBuZWVkZWQgYmFzZWQgb24gdGhlIHByZXZpb3VzIHZhcmlhbnRcblx0XHR0aGlzLl9tYXhWZXJ0ZXhDb3VudCA9IG1heFZlcnRleENvdW50O1xuXHRcdHRoaXMuX21heEluZGV4Q291bnQgPSBtYXhJbmRleENvdW50O1xuXG5cdFx0aWYgKCB0aGlzLl9nZW9tZXRyeUluaXRpYWxpemVkICkge1xuXG5cdFx0XHR0aGlzLl9nZW9tZXRyeUluaXRpYWxpemVkID0gZmFsc2U7XG5cdFx0XHR0aGlzLmdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHR0aGlzLl9pbml0aWFsaXplR2VvbWV0cnkoIG9sZEdlb21ldHJ5ICk7XG5cblx0XHR9XG5cblx0XHQvLyBjb3B5IGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgZ2VvbWV0cnlcblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0aWYgKCBvbGRHZW9tZXRyeS5pbmRleCApIHtcblxuXHRcdFx0Y29weUFycmF5Q29udGVudHMoIG9sZEdlb21ldHJ5LmluZGV4LmFycmF5LCBnZW9tZXRyeS5pbmRleC5hcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggY29uc3Qga2V5IGluIG9sZEdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvcHlBcnJheUNvbnRlbnRzKCBvbGRHZW9tZXRyeS5hdHRyaWJ1dGVzWyBrZXkgXS5hcnJheSwgZ2VvbWV0cnkuYXR0cmlidXRlc1sga2V5IF0uYXJyYXkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0Y29uc3QgaW5zdGFuY2VJbmZvID0gdGhpcy5faW5zdGFuY2VJbmZvO1xuXHRcdGNvbnN0IGdlb21ldHJ5SW5mb0xpc3QgPSB0aGlzLl9nZW9tZXRyeUluZm87XG5cdFx0Y29uc3QgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xuXHRcdGNvbnN0IGJhdGNoR2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0Ly8gaXRlcmF0ZSBvdmVyIGVhY2ggZ2VvbWV0cnlcblx0XHRfbWVzaC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG5cdFx0X21lc2guZ2VvbWV0cnkuaW5kZXggPSBiYXRjaEdlb21ldHJ5LmluZGV4O1xuXHRcdF9tZXNoLmdlb21ldHJ5LmF0dHJpYnV0ZXMgPSBiYXRjaEdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cdFx0aWYgKCBfbWVzaC5nZW9tZXRyeS5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuXHRcdFx0X21lc2guZ2VvbWV0cnkuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBfbWVzaC5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0X21lc2guZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBpbnN0YW5jZUluZm8ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0aWYgKCAhIGluc3RhbmNlSW5mb1sgaSBdLnZpc2libGUgfHwgISBpbnN0YW5jZUluZm9bIGkgXS5hY3RpdmUgKSB7XG5cblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnlJZCA9IGluc3RhbmNlSW5mb1sgaSBdLmdlb21ldHJ5SW5kZXg7XG5cdFx0XHRjb25zdCBnZW9tZXRyeUluZm8gPSBnZW9tZXRyeUluZm9MaXN0WyBnZW9tZXRyeUlkIF07XG5cdFx0XHRfbWVzaC5nZW9tZXRyeS5zZXREcmF3UmFuZ2UoIGdlb21ldHJ5SW5mby5zdGFydCwgZ2VvbWV0cnlJbmZvLmNvdW50ICk7XG5cblx0XHRcdC8vIGdldCB0aGUgaW50ZXJzZWN0c1xuXHRcdFx0dGhpcy5nZXRNYXRyaXhBdCggaSwgX21lc2gubWF0cml4V29ybGQgKS5wcmVtdWx0aXBseSggbWF0cml4V29ybGQgKTtcblx0XHRcdHRoaXMuZ2V0Qm91bmRpbmdCb3hBdCggZ2VvbWV0cnlJZCwgX21lc2guZ2VvbWV0cnkuYm91bmRpbmdCb3ggKTtcblx0XHRcdHRoaXMuZ2V0Qm91bmRpbmdTcGhlcmVBdCggZ2VvbWV0cnlJZCwgX21lc2guZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcblx0XHRcdF9tZXNoLnJheWNhc3QoIHJheWNhc3RlciwgX2JhdGNoSW50ZXJzZWN0cyApO1xuXG5cdFx0XHQvLyBhZGQgYmF0Y2ggaWQgdG8gdGhlIGludGVyc2VjdHNcblx0XHRcdGZvciAoIGxldCBqID0gMCwgbCA9IF9iYXRjaEludGVyc2VjdHMubGVuZ3RoOyBqIDwgbDsgaiArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbnRlcnNlY3QgPSBfYmF0Y2hJbnRlcnNlY3RzWyBqIF07XG5cdFx0XHRcdGludGVyc2VjdC5vYmplY3QgPSB0aGlzO1xuXHRcdFx0XHRpbnRlcnNlY3QuYmF0Y2hJZCA9IGk7XG5cdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X2JhdGNoSW50ZXJzZWN0cy5sZW5ndGggPSAwO1xuXG5cdFx0fVxuXG5cdFx0X21lc2gubWF0ZXJpYWwgPSBudWxsO1xuXHRcdF9tZXNoLmdlb21ldHJ5LmluZGV4ID0gbnVsbDtcblx0XHRfbWVzaC5nZW9tZXRyeS5hdHRyaWJ1dGVzID0ge307XG5cdFx0X21lc2guZ2VvbWV0cnkuc2V0RHJhd1JhbmdlKCAwLCBJbmZpbml0eSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBzb3VyY2UuZ2VvbWV0cnkuY2xvbmUoKTtcblx0XHR0aGlzLnBlck9iamVjdEZydXN0dW1DdWxsZWQgPSBzb3VyY2UucGVyT2JqZWN0RnJ1c3R1bUN1bGxlZDtcblx0XHR0aGlzLnNvcnRPYmplY3RzID0gc291cmNlLnNvcnRPYmplY3RzO1xuXHRcdHRoaXMuYm91bmRpbmdCb3ggPSBzb3VyY2UuYm91bmRpbmdCb3ggIT09IG51bGwgPyBzb3VyY2UuYm91bmRpbmdCb3guY2xvbmUoKSA6IG51bGw7XG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IHNvdXJjZS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCA/IHNvdXJjZS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpIDogbnVsbDtcblxuXHRcdHRoaXMuX2dlb21ldHJ5SW5mbyA9IHNvdXJjZS5fZ2VvbWV0cnlJbmZvLm1hcCggaW5mbyA9PiAoIHtcblx0XHRcdC4uLmluZm8sXG5cblx0XHRcdGJvdW5kaW5nQm94OiBpbmZvLmJvdW5kaW5nQm94ICE9PSBudWxsID8gaW5mby5ib3VuZGluZ0JveC5jbG9uZSgpIDogbnVsbCxcblx0XHRcdGJvdW5kaW5nU3BoZXJlOiBpbmZvLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsID8gaW5mby5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpIDogbnVsbCxcblx0XHR9ICkgKTtcblx0XHR0aGlzLl9pbnN0YW5jZUluZm8gPSBzb3VyY2UuX2luc3RhbmNlSW5mby5tYXAoIGluZm8gPT4gKCB7IC4uLmluZm8gfSApICk7XG5cblx0XHR0aGlzLl9tYXhJbnN0YW5jZUNvdW50ID0gc291cmNlLl9tYXhJbnN0YW5jZUNvdW50O1xuXHRcdHRoaXMuX21heFZlcnRleENvdW50ID0gc291cmNlLl9tYXhWZXJ0ZXhDb3VudDtcblx0XHR0aGlzLl9tYXhJbmRleENvdW50ID0gc291cmNlLl9tYXhJbmRleENvdW50O1xuXG5cdFx0dGhpcy5fZ2VvbWV0cnlJbml0aWFsaXplZCA9IHNvdXJjZS5fZ2VvbWV0cnlJbml0aWFsaXplZDtcblx0XHR0aGlzLl9nZW9tZXRyeUNvdW50ID0gc291cmNlLl9nZW9tZXRyeUNvdW50O1xuXHRcdHRoaXMuX211bHRpRHJhd0NvdW50cyA9IHNvdXJjZS5fbXVsdGlEcmF3Q291bnRzLnNsaWNlKCk7XG5cdFx0dGhpcy5fbXVsdGlEcmF3U3RhcnRzID0gc291cmNlLl9tdWx0aURyYXdTdGFydHMuc2xpY2UoKTtcblxuXHRcdHRoaXMuX21hdHJpY2VzVGV4dHVyZSA9IHNvdXJjZS5fbWF0cmljZXNUZXh0dXJlLmNsb25lKCk7XG5cdFx0dGhpcy5fbWF0cmljZXNUZXh0dXJlLmltYWdlLmRhdGEgPSB0aGlzLl9tYXRyaWNlc1RleHR1cmUuaW1hZ2UuZGF0YS5zbGljZSgpO1xuXG5cdFx0aWYgKCB0aGlzLl9jb2xvcnNUZXh0dXJlICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLl9jb2xvcnNUZXh0dXJlID0gc291cmNlLl9jb2xvcnNUZXh0dXJlLmNsb25lKCk7XG5cdFx0XHR0aGlzLl9jb2xvcnNUZXh0dXJlLmltYWdlLmRhdGEgPSB0aGlzLl9jb2xvcnNUZXh0dXJlLmltYWdlLmRhdGEuc2xpY2UoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0Ly8gQXNzdW1pbmcgdGhlIGdlb21ldHJ5IGlzIG5vdCBzaGFyZWQgd2l0aCBvdGhlciBtZXNoZXNcblx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblxuXHRcdHRoaXMuX21hdHJpY2VzVGV4dHVyZS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5fbWF0cmljZXNUZXh0dXJlID0gbnVsbDtcblxuXHRcdHRoaXMuX2luZGlyZWN0VGV4dHVyZS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5faW5kaXJlY3RUZXh0dXJlID0gbnVsbDtcblxuXHRcdGlmICggdGhpcy5fY29sb3JzVGV4dHVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5fY29sb3JzVGV4dHVyZS5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLl9jb2xvcnNUZXh0dXJlID0gbnVsbDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRvbkJlZm9yZVJlbmRlciggcmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbC8qLCBfZ3JvdXAqLyApIHtcblxuXHRcdC8vIGlmIHZpc2liaWxpdHkgaGFzIG5vdCBjaGFuZ2VkIGFuZCBmcnVzdHVtIGN1bGxpbmcgYW5kIG9iamVjdCBzb3J0aW5nIGlzIG5vdCByZXF1aXJlZFxuXHRcdC8vIHRoZW4gc2tpcCBpdGVyYXRpbmcgb3ZlciBhbGwgaXRlbXNcblx0XHRpZiAoICEgdGhpcy5fdmlzaWJpbGl0eUNoYW5nZWQgJiYgISB0aGlzLnBlck9iamVjdEZydXN0dW1DdWxsZWQgJiYgISB0aGlzLnNvcnRPYmplY3RzICkge1xuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHQvLyB0aGUgaW5kZXhlZCB2ZXJzaW9uIG9mIHRoZSBtdWx0aSBkcmF3IGZ1bmN0aW9uIHJlcXVpcmVzIHNwZWNpZnlpbmcgdGhlIHN0YXJ0XG5cdFx0Ly8gb2Zmc2V0IGluIGJ5dGVzLlxuXHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcblx0XHRjb25zdCBieXRlc1BlckVsZW1lbnQgPSBpbmRleCA9PT0gbnVsbCA/IDEgOiBpbmRleC5hcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcblxuXHRcdGNvbnN0IGluc3RhbmNlSW5mbyA9IHRoaXMuX2luc3RhbmNlSW5mbztcblx0XHRjb25zdCBtdWx0aURyYXdTdGFydHMgPSB0aGlzLl9tdWx0aURyYXdTdGFydHM7XG5cdFx0Y29uc3QgbXVsdGlEcmF3Q291bnRzID0gdGhpcy5fbXVsdGlEcmF3Q291bnRzO1xuXHRcdGNvbnN0IGdlb21ldHJ5SW5mb0xpc3QgPSB0aGlzLl9nZW9tZXRyeUluZm87XG5cdFx0Y29uc3QgcGVyT2JqZWN0RnJ1c3R1bUN1bGxlZCA9IHRoaXMucGVyT2JqZWN0RnJ1c3R1bUN1bGxlZDtcblx0XHRjb25zdCBpbmRpcmVjdFRleHR1cmUgPSB0aGlzLl9pbmRpcmVjdFRleHR1cmU7XG5cdFx0Y29uc3QgaW5kaXJlY3RBcnJheSA9IGluZGlyZWN0VGV4dHVyZS5pbWFnZS5kYXRhO1xuXG5cdFx0Ly8gcHJlcGFyZSB0aGUgZnJ1c3R1bSBpbiB0aGUgbG9jYWwgZnJhbWVcblx0XHRpZiAoIHBlck9iamVjdEZydXN0dW1DdWxsZWQgKSB7XG5cblx0XHRcdF9tYXRyaXgkMVxuXHRcdFx0XHQubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKVxuXHRcdFx0XHQubXVsdGlwbHkoIHRoaXMubWF0cml4V29ybGQgKTtcblx0XHRcdF9mcnVzdHVtLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KFxuXHRcdFx0XHRfbWF0cml4JDEsXG5cdFx0XHRcdHJlbmRlcmVyLmNvb3JkaW5hdGVTeXN0ZW1cblx0XHRcdCk7XG5cblx0XHR9XG5cblx0XHRsZXQgbXVsdGlEcmF3Q291bnQgPSAwO1xuXHRcdGlmICggdGhpcy5zb3J0T2JqZWN0cyApIHtcblxuXHRcdFx0Ly8gZ2V0IHRoZSBjYW1lcmEgcG9zaXRpb24gaW4gdGhlIGxvY2FsIGZyYW1lXG5cdFx0XHRfbWF0cml4JDEuY29weSggdGhpcy5tYXRyaXhXb3JsZCApLmludmVydCgpO1xuXHRcdFx0X3ZlY3RvciQ1LnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICkuYXBwbHlNYXRyaXg0KCBfbWF0cml4JDEgKTtcblx0XHRcdF9mb3J3YXJkLnNldCggMCwgMCwgLSAxICkudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKS50cmFuc2Zvcm1EaXJlY3Rpb24oIF9tYXRyaXgkMSApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBpbnN0YW5jZUluZm8ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGluc3RhbmNlSW5mb1sgaSBdLnZpc2libGUgJiYgaW5zdGFuY2VJbmZvWyBpIF0uYWN0aXZlICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZ2VvbWV0cnlJZCA9IGluc3RhbmNlSW5mb1sgaSBdLmdlb21ldHJ5SW5kZXg7XG5cblx0XHRcdFx0XHQvLyBnZXQgdGhlIGJvdW5kcyBpbiB3b3JsZCBzcGFjZVxuXHRcdFx0XHRcdHRoaXMuZ2V0TWF0cml4QXQoIGksIF9tYXRyaXgkMSApO1xuXHRcdFx0XHRcdHRoaXMuZ2V0Qm91bmRpbmdTcGhlcmVBdCggZ2VvbWV0cnlJZCwgX3NwaGVyZSQyICkuYXBwbHlNYXRyaXg0KCBfbWF0cml4JDEgKTtcblxuXHRcdFx0XHRcdC8vIGRldGVybWluZSB3aGV0aGVyIHRoZSBiYXRjaGVkIGdlb21ldHJ5IGlzIHdpdGhpbiB0aGUgZnJ1c3R1bVxuXHRcdFx0XHRcdGxldCBjdWxsZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAoIHBlck9iamVjdEZydXN0dW1DdWxsZWQgKSB7XG5cblx0XHRcdFx0XHRcdGN1bGxlZCA9ICEgX2ZydXN0dW0uaW50ZXJzZWN0c1NwaGVyZSggX3NwaGVyZSQyICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoICEgY3VsbGVkICkge1xuXG5cdFx0XHRcdFx0XHQvLyBnZXQgdGhlIGRpc3RhbmNlIGZyb20gY2FtZXJhIHVzZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRcdGNvbnN0IGdlb21ldHJ5SW5mbyA9IGdlb21ldHJ5SW5mb0xpc3RbIGdlb21ldHJ5SWQgXTtcblx0XHRcdFx0XHRcdGNvbnN0IHogPSBfdGVtcC5zdWJWZWN0b3JzKCBfc3BoZXJlJDIuY2VudGVyLCBfdmVjdG9yJDUgKS5kb3QoIF9mb3J3YXJkICk7XG5cdFx0XHRcdFx0XHRfcmVuZGVyTGlzdC5wdXNoKCBnZW9tZXRyeUluZm8uc3RhcnQsIGdlb21ldHJ5SW5mby5jb3VudCwgeiwgaSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTb3J0IHRoZSBkcmF3IHJhbmdlcyBhbmQgcHJlcCBmb3IgcmVuZGVyaW5nXG5cdFx0XHRjb25zdCBsaXN0ID0gX3JlbmRlckxpc3QubGlzdDtcblx0XHRcdGNvbnN0IGN1c3RvbVNvcnQgPSB0aGlzLmN1c3RvbVNvcnQ7XG5cdFx0XHRpZiAoIGN1c3RvbVNvcnQgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0bGlzdC5zb3J0KCBtYXRlcmlhbC50cmFuc3BhcmVudCA/IHNvcnRUcmFuc3BhcmVudCA6IHNvcnRPcGFxdWUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjdXN0b21Tb3J0LmNhbGwoIHRoaXMsIGxpc3QsIGNhbWVyYSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpdGVtID0gbGlzdFsgaSBdO1xuXHRcdFx0XHRtdWx0aURyYXdTdGFydHNbIG11bHRpRHJhd0NvdW50IF0gPSBpdGVtLnN0YXJ0ICogYnl0ZXNQZXJFbGVtZW50O1xuXHRcdFx0XHRtdWx0aURyYXdDb3VudHNbIG11bHRpRHJhd0NvdW50IF0gPSBpdGVtLmNvdW50O1xuXHRcdFx0XHRpbmRpcmVjdEFycmF5WyBtdWx0aURyYXdDb3VudCBdID0gaXRlbS5pbmRleDtcblx0XHRcdFx0bXVsdGlEcmF3Q291bnQgKys7XG5cblx0XHRcdH1cblxuXHRcdFx0X3JlbmRlckxpc3QucmVzZXQoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluc3RhbmNlSW5mby5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggaW5zdGFuY2VJbmZvWyBpIF0udmlzaWJsZSAmJiBpbnN0YW5jZUluZm9bIGkgXS5hY3RpdmUgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBnZW9tZXRyeUlkID0gaW5zdGFuY2VJbmZvWyBpIF0uZ2VvbWV0cnlJbmRleDtcblxuXHRcdFx0XHRcdC8vIGRldGVybWluZSB3aGV0aGVyIHRoZSBiYXRjaGVkIGdlb21ldHJ5IGlzIHdpdGhpbiB0aGUgZnJ1c3R1bVxuXHRcdFx0XHRcdGxldCBjdWxsZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAoIHBlck9iamVjdEZydXN0dW1DdWxsZWQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGdldCB0aGUgYm91bmRzIGluIHdvcmxkIHNwYWNlXG5cdFx0XHRcdFx0XHR0aGlzLmdldE1hdHJpeEF0KCBpLCBfbWF0cml4JDEgKTtcblx0XHRcdFx0XHRcdHRoaXMuZ2V0Qm91bmRpbmdTcGhlcmVBdCggZ2VvbWV0cnlJZCwgX3NwaGVyZSQyICkuYXBwbHlNYXRyaXg0KCBfbWF0cml4JDEgKTtcblx0XHRcdFx0XHRcdGN1bGxlZCA9ICEgX2ZydXN0dW0uaW50ZXJzZWN0c1NwaGVyZSggX3NwaGVyZSQyICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoICEgY3VsbGVkICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBnZW9tZXRyeUluZm8gPSBnZW9tZXRyeUluZm9MaXN0WyBnZW9tZXRyeUlkIF07XG5cdFx0XHRcdFx0XHRtdWx0aURyYXdTdGFydHNbIG11bHRpRHJhd0NvdW50IF0gPSBnZW9tZXRyeUluZm8uc3RhcnQgKiBieXRlc1BlckVsZW1lbnQ7XG5cdFx0XHRcdFx0XHRtdWx0aURyYXdDb3VudHNbIG11bHRpRHJhd0NvdW50IF0gPSBnZW9tZXRyeUluZm8uY291bnQ7XG5cdFx0XHRcdFx0XHRpbmRpcmVjdEFycmF5WyBtdWx0aURyYXdDb3VudCBdID0gaTtcblx0XHRcdFx0XHRcdG11bHRpRHJhd0NvdW50ICsrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aW5kaXJlY3RUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLl9tdWx0aURyYXdDb3VudCA9IG11bHRpRHJhd0NvdW50O1xuXHRcdHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2VkID0gZmFsc2U7XG5cblx0fVxuXG5cdG9uQmVmb3JlU2hhZG93KCByZW5kZXJlciwgb2JqZWN0LCBjYW1lcmEsIHNoYWRvd0NhbWVyYSwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwvKiAsIGdyb3VwICovICkge1xuXG5cdFx0dGhpcy5vbkJlZm9yZVJlbmRlciggcmVuZGVyZXIsIG51bGwsIHNoYWRvd0NhbWVyYSwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgTGluZUJhc2ljTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0xpbmVCYXNpY01hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdMaW5lQmFzaWNNYXRlcmlhbCc7XG5cblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xuXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5saW5ld2lkdGggPSAxO1xuXHRcdHRoaXMubGluZWNhcCA9ICdyb3VuZCc7XG5cdFx0dGhpcy5saW5lam9pbiA9ICdyb3VuZCc7XG5cblx0XHR0aGlzLmZvZyA9IHRydWU7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuXHRcdHRoaXMubGluZXdpZHRoID0gc291cmNlLmxpbmV3aWR0aDtcblx0XHR0aGlzLmxpbmVjYXAgPSBzb3VyY2UubGluZWNhcDtcblx0XHR0aGlzLmxpbmVqb2luID0gc291cmNlLmxpbmVqb2luO1xuXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNvbnN0IF92U3RhcnQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdkVuZCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX2ludmVyc2VNYXRyaXgkMSA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9yYXkkMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFJheSgpO1xuY29uc3QgX3NwaGVyZSQxID0gLypAX19QVVJFX18qLyBuZXcgU3BoZXJlKCk7XG5cbmNvbnN0IF9pbnRlcnNlY3RQb2ludE9uUmF5ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2ludGVyc2VjdFBvaW50T25TZWdtZW50ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBMaW5lIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpLCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCgpICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNMaW5lID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdMaW5lJztcblxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cblx0XHR0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XG5cblx0XHR0aGlzLm1hdGVyaWFsID0gQXJyYXkuaXNBcnJheSggc291cmNlLm1hdGVyaWFsICkgPyBzb3VyY2UubWF0ZXJpYWwuc2xpY2UoKSA6IHNvdXJjZS5tYXRlcmlhbDtcblx0XHR0aGlzLmdlb21ldHJ5ID0gc291cmNlLmdlb21ldHJ5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvbXB1dGVMaW5lRGlzdGFuY2VzKCkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0Ly8gd2UgYXNzdW1lIG5vbi1pbmRleGVkIGdlb21ldHJ5XG5cblx0XHRpZiAoIGdlb21ldHJ5LmluZGV4ID09PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRjb25zdCBsaW5lRGlzdGFuY2VzID0gWyAwIF07XG5cblx0XHRcdGZvciAoIGxldCBpID0gMSwgbCA9IHBvc2l0aW9uQXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRfdlN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBpIC0gMSApO1xuXHRcdFx0XHRfdkVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSApO1xuXG5cdFx0XHRcdGxpbmVEaXN0YW5jZXNbIGkgXSA9IGxpbmVEaXN0YW5jZXNbIGkgLSAxIF07XG5cdFx0XHRcdGxpbmVEaXN0YW5jZXNbIGkgXSArPSBfdlN0YXJ0LmRpc3RhbmNlVG8oIF92RW5kICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbGluZURpc3RhbmNlJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGxpbmVEaXN0YW5jZXMsIDEgKSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGluZS5jb21wdXRlTGluZURpc3RhbmNlcygpOiBDb21wdXRhdGlvbiBvbmx5IHBvc3NpYmxlIHdpdGggbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnkuJyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRjb25zdCBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG5cdFx0Y29uc3QgdGhyZXNob2xkID0gcmF5Y2FzdGVyLnBhcmFtcy5MaW5lLnRocmVzaG9sZDtcblx0XHRjb25zdCBkcmF3UmFuZ2UgPSBnZW9tZXRyeS5kcmF3UmFuZ2U7XG5cblx0XHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcblxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdF9zcGhlcmUkMS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xuXHRcdF9zcGhlcmUkMS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cdFx0X3NwaGVyZSQxLnJhZGl1cyArPSB0aHJlc2hvbGQ7XG5cblx0XHRpZiAoIHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZSggX3NwaGVyZSQxICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0Ly9cblxuXHRcdF9pbnZlcnNlTWF0cml4JDEuY29weSggbWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblx0XHRfcmF5JDEuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggX2ludmVyc2VNYXRyaXgkMSApO1xuXG5cdFx0Y29uc3QgbG9jYWxUaHJlc2hvbGQgPSB0aHJlc2hvbGQgLyAoICggdGhpcy5zY2FsZS54ICsgdGhpcy5zY2FsZS55ICsgdGhpcy5zY2FsZS56ICkgLyAzICk7XG5cdFx0Y29uc3QgbG9jYWxUaHJlc2hvbGRTcSA9IGxvY2FsVGhyZXNob2xkICogbG9jYWxUaHJlc2hvbGQ7XG5cblx0XHRjb25zdCBzdGVwID0gdGhpcy5pc0xpbmVTZWdtZW50cyA/IDIgOiAxO1xuXG5cdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KCAwLCBkcmF3UmFuZ2Uuc3RhcnQgKTtcblx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKCBpbmRleC5jb3VudCwgKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IHN0YXJ0LCBsID0gZW5kIC0gMTsgaSA8IGw7IGkgKz0gc3RlcCApIHtcblxuXHRcdFx0XHRjb25zdCBhID0gaW5kZXguZ2V0WCggaSApO1xuXHRcdFx0XHRjb25zdCBiID0gaW5kZXguZ2V0WCggaSArIDEgKTtcblxuXHRcdFx0XHRjb25zdCBpbnRlcnNlY3QgPSBjaGVja0ludGVyc2VjdGlvbiggdGhpcywgcmF5Y2FzdGVyLCBfcmF5JDEsIGxvY2FsVGhyZXNob2xkU3EsIGEsIGIgKTtcblxuXHRcdFx0XHRpZiAoIGludGVyc2VjdCApIHtcblxuXHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5pc0xpbmVMb29wICkge1xuXG5cdFx0XHRcdGNvbnN0IGEgPSBpbmRleC5nZXRYKCBlbmQgLSAxICk7XG5cdFx0XHRcdGNvbnN0IGIgPSBpbmRleC5nZXRYKCBzdGFydCApO1xuXG5cdFx0XHRcdGNvbnN0IGludGVyc2VjdCA9IGNoZWNrSW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIF9yYXkkMSwgbG9jYWxUaHJlc2hvbGRTcSwgYSwgYiApO1xuXG5cdFx0XHRcdGlmICggaW50ZXJzZWN0ICkge1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoIDAsIGRyYXdSYW5nZS5zdGFydCApO1xuXHRcdFx0Y29uc3QgZW5kID0gTWF0aC5taW4oIHBvc2l0aW9uQXR0cmlidXRlLmNvdW50LCAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gc3RhcnQsIGwgPSBlbmQgLSAxOyBpIDwgbDsgaSArPSBzdGVwICkge1xuXG5cdFx0XHRcdGNvbnN0IGludGVyc2VjdCA9IGNoZWNrSW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIF9yYXkkMSwgbG9jYWxUaHJlc2hvbGRTcSwgaSwgaSArIDEgKTtcblxuXHRcdFx0XHRpZiAoIGludGVyc2VjdCApIHtcblxuXHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5pc0xpbmVMb29wICkge1xuXG5cdFx0XHRcdGNvbnN0IGludGVyc2VjdCA9IGNoZWNrSW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIF9yYXkkMSwgbG9jYWxUaHJlc2hvbGRTcSwgZW5kIC0gMSwgc3RhcnQgKTtcblxuXHRcdFx0XHRpZiAoIGludGVyc2VjdCApIHtcblxuXHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZU1vcnBoVGFyZ2V0cygpIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblx0XHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoIG1vcnBoQXR0cmlidXRlcyApO1xuXG5cdFx0aWYgKCBrZXlzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBrZXlzWyAwIF0gXTtcblxuXHRcdFx0aWYgKCBtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG5cblx0XHRcdFx0Zm9yICggbGV0IG0gPSAwLCBtbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IG1vcnBoQXR0cmlidXRlWyBtIF0ubmFtZSB8fCBTdHJpbmcoIG0gKTtcblxuXHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goIDAgKTtcblx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdID0gbTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHRocmVzaG9sZFNxLCBhLCBiICkge1xuXG5cdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gb2JqZWN0Lmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0X3ZTdGFydC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgYSApO1xuXHRfdkVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgYiApO1xuXG5cdGNvbnN0IGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCBfdlN0YXJ0LCBfdkVuZCwgX2ludGVyc2VjdFBvaW50T25SYXksIF9pbnRlcnNlY3RQb2ludE9uU2VnbWVudCApO1xuXG5cdGlmICggZGlzdFNxID4gdGhyZXNob2xkU3EgKSByZXR1cm47XG5cblx0X2ludGVyc2VjdFBvaW50T25SYXkuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTsgLy8gTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxuXG5cdGNvbnN0IGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggX2ludGVyc2VjdFBvaW50T25SYXkgKTtcblxuXHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgcmV0dXJuO1xuXG5cdHJldHVybiB7XG5cblx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0Ly8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XG5cdFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXG5cdFx0cG9pbnQ6IF9pbnRlcnNlY3RQb2ludE9uU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICksXG5cdFx0aW5kZXg6IGEsXG5cdFx0ZmFjZTogbnVsbCxcblx0XHRmYWNlSW5kZXg6IG51bGwsXG5cdFx0YmFyeWNvb3JkOiBudWxsLFxuXHRcdG9iamVjdDogb2JqZWN0XG5cblx0fTtcblxufVxuXG5jb25zdCBfc3RhcnQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfZW5kID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBMaW5lU2VnbWVudHMgZXh0ZW5kcyBMaW5lIHtcblxuXHRjb25zdHJ1Y3RvciggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0dGhpcy5pc0xpbmVTZWdtZW50cyA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnTGluZVNlZ21lbnRzJztcblxuXHR9XG5cblx0Y29tcHV0ZUxpbmVEaXN0YW5jZXMoKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cblx0XHQvLyB3ZSBhc3N1bWUgbm9uLWluZGV4ZWQgZ2VvbWV0cnlcblxuXHRcdGlmICggZ2VvbWV0cnkuaW5kZXggPT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdGNvbnN0IGxpbmVEaXN0YW5jZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gcG9zaXRpb25BdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICs9IDIgKSB7XG5cblx0XHRcdFx0X3N0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBpICk7XG5cdFx0XHRcdF9lbmQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGkgKyAxICk7XG5cblx0XHRcdFx0bGluZURpc3RhbmNlc1sgaSBdID0gKCBpID09PSAwICkgPyAwIDogbGluZURpc3RhbmNlc1sgaSAtIDEgXTtcblx0XHRcdFx0bGluZURpc3RhbmNlc1sgaSArIDEgXSA9IGxpbmVEaXN0YW5jZXNbIGkgXSArIF9zdGFydC5kaXN0YW5jZVRvKCBfZW5kICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbGluZURpc3RhbmNlJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGxpbmVEaXN0YW5jZXMsIDEgKSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGluZVNlZ21lbnRzLmNvbXB1dGVMaW5lRGlzdGFuY2VzKCk6IENvbXB1dGF0aW9uIG9ubHkgcG9zc2libGUgd2l0aCBub24taW5kZXhlZCBCdWZmZXJHZW9tZXRyeS4nICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY2xhc3MgTGluZUxvb3AgZXh0ZW5kcyBMaW5lIHtcblxuXHRjb25zdHJ1Y3RvciggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0dGhpcy5pc0xpbmVMb29wID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdMaW5lTG9vcCc7XG5cblx0fVxuXG59XG5cbmNsYXNzIFBvaW50c01hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNQb2ludHNNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnUG9pbnRzTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcblxuXHRcdHRoaXMubWFwID0gbnVsbDtcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5zaXplID0gMTtcblx0XHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHRydWU7XG5cblx0XHR0aGlzLmZvZyA9IHRydWU7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdFx0dGhpcy5zaXplID0gc291cmNlLnNpemU7XG5cdFx0dGhpcy5zaXplQXR0ZW51YXRpb24gPSBzb3VyY2Uuc2l6ZUF0dGVudWF0aW9uO1xuXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNvbnN0IF9pbnZlcnNlTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3JheSA9IC8qQF9fUFVSRV9fKi8gbmV3IFJheSgpO1xuY29uc3QgX3NwaGVyZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFNwaGVyZSgpO1xuY29uc3QgX3Bvc2l0aW9uJDIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNsYXNzIFBvaW50cyBleHRlbmRzIE9iamVjdDNEIHtcblxuXHRjb25zdHJ1Y3RvciggZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKSwgbWF0ZXJpYWwgPSBuZXcgUG9pbnRzTWF0ZXJpYWwoKSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzUG9pbnRzID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdQb2ludHMnO1xuXG5cdFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuXHRcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblxuXHRcdHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlLCByZWN1cnNpdmUgKTtcblxuXHRcdHRoaXMubWF0ZXJpYWwgPSBBcnJheS5pc0FycmF5KCBzb3VyY2UubWF0ZXJpYWwgKSA/IHNvdXJjZS5tYXRlcmlhbC5zbGljZSgpIDogc291cmNlLm1hdGVyaWFsO1xuXHRcdHRoaXMuZ2VvbWV0cnkgPSBzb3VyY2UuZ2VvbWV0cnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGNvbnN0IG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcblx0XHRjb25zdCB0aHJlc2hvbGQgPSByYXljYXN0ZXIucGFyYW1zLlBvaW50cy50aHJlc2hvbGQ7XG5cdFx0Y29uc3QgZHJhd1JhbmdlID0gZ2VvbWV0cnkuZHJhd1JhbmdlO1xuXG5cdFx0Ly8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XG5cblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRfc3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG5cdFx0X3NwaGVyZS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cdFx0X3NwaGVyZS5yYWRpdXMgKz0gdGhyZXNob2xkO1xuXG5cdFx0aWYgKCByYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoIF9zcGhlcmUgKSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHQvL1xuXG5cdFx0X2ludmVyc2VNYXRyaXguY29weSggbWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblx0XHRfcmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIF9pbnZlcnNlTWF0cml4ICk7XG5cblx0XHRjb25zdCBsb2NhbFRocmVzaG9sZCA9IHRocmVzaG9sZCAvICggKCB0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnogKSAvIDMgKTtcblx0XHRjb25zdCBsb2NhbFRocmVzaG9sZFNxID0gbG9jYWxUaHJlc2hvbGQgKiBsb2NhbFRocmVzaG9sZDtcblxuXHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3Qgc3RhcnQgPSBNYXRoLm1heCggMCwgZHJhd1JhbmdlLnN0YXJ0ICk7XG5cdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbiggaW5kZXguY291bnQsICggZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50ICkgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBhID0gaW5kZXguZ2V0WCggaSApO1xuXG5cdFx0XHRcdF9wb3NpdGlvbiQyLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBhICk7XG5cblx0XHRcdFx0dGVzdFBvaW50KCBfcG9zaXRpb24kMiwgYSwgbG9jYWxUaHJlc2hvbGRTcSwgbWF0cml4V29ybGQsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdGhpcyApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KCAwLCBkcmF3UmFuZ2Uuc3RhcnQgKTtcblx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKCBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCwgKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IHN0YXJ0LCBsID0gZW5kOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRfcG9zaXRpb24kMi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSApO1xuXG5cdFx0XHRcdHRlc3RQb2ludCggX3Bvc2l0aW9uJDIsIGksIGxvY2FsVGhyZXNob2xkU3EsIG1hdHJpeFdvcmxkLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHRoaXMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR1cGRhdGVNb3JwaFRhcmdldHMoKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cblx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XG5cdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKCBtb3JwaEF0dHJpYnV0ZXMgKTtcblxuXHRcdGlmICgga2V5cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1sga2V5c1sgMCBdIF07XG5cblx0XHRcdGlmICggbW9ycGhBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IFtdO1xuXHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuXG5cdFx0XHRcdGZvciAoIGxldCBtID0gMCwgbWwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IG0gPCBtbDsgbSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSBtb3JwaEF0dHJpYnV0ZVsgbSBdLm5hbWUgfHwgU3RyaW5nKCBtICk7XG5cblx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKCAwICk7XG5cdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXSA9IG07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIHRlc3RQb2ludCggcG9pbnQsIGluZGV4LCBsb2NhbFRocmVzaG9sZFNxLCBtYXRyaXhXb3JsZCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCBvYmplY3QgKSB7XG5cblx0Y29uc3QgcmF5UG9pbnREaXN0YW5jZVNxID0gX3JheS5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKTtcblxuXHRpZiAoIHJheVBvaW50RGlzdGFuY2VTcSA8IGxvY2FsVGhyZXNob2xkU3EgKSB7XG5cblx0XHRjb25zdCBpbnRlcnNlY3RQb2ludCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRfcmF5LmNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50LCBpbnRlcnNlY3RQb2ludCApO1xuXHRcdGludGVyc2VjdFBvaW50LmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdGNvbnN0IGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0UG9pbnQgKTtcblxuXHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm47XG5cblx0XHRpbnRlcnNlY3RzLnB1c2goIHtcblxuXHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0ZGlzdGFuY2VUb1JheTogTWF0aC5zcXJ0KCByYXlQb2ludERpc3RhbmNlU3EgKSxcblx0XHRcdHBvaW50OiBpbnRlcnNlY3RQb2ludCxcblx0XHRcdGluZGV4OiBpbmRleCxcblx0XHRcdGZhY2U6IG51bGwsXG5cdFx0XHRmYWNlSW5kZXg6IG51bGwsXG5cdFx0XHRiYXJ5Y29vcmQ6IG51bGwsXG5cdFx0XHRvYmplY3Q6IG9iamVjdFxuXG5cdFx0fSApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBHcm91cCBleHRlbmRzIE9iamVjdDNEIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzR3JvdXAgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0dyb3VwJztcblxuXHR9XG5cbn1cblxuY2xhc3MgVmlkZW9UZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cblx0Y29uc3RydWN0b3IoIHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XG5cblx0XHRzdXBlciggdmlkZW8sIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG5cdFx0dGhpcy5pc1ZpZGVvVGV4dHVyZSA9IHRydWU7XG5cblx0XHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogTGluZWFyRmlsdGVyO1xuXHRcdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBMaW5lYXJGaWx0ZXI7XG5cblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlVmlkZW8oKSB7XG5cblx0XHRcdHNjb3BlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdHZpZGVvLnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2soIHVwZGF0ZVZpZGVvICk7XG5cblx0XHR9XG5cblx0XHRpZiAoICdyZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrJyBpbiB2aWRlbyApIHtcblxuXHRcdFx0dmlkZW8ucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayggdXBkYXRlVmlkZW8gKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuaW1hZ2UgKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG5cdHVwZGF0ZSgpIHtcblxuXHRcdGNvbnN0IHZpZGVvID0gdGhpcy5pbWFnZTtcblx0XHRjb25zdCBoYXNWaWRlb0ZyYW1lQ2FsbGJhY2sgPSAncmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaycgaW4gdmlkZW87XG5cblx0XHRpZiAoIGhhc1ZpZGVvRnJhbWVDYWxsYmFjayA9PT0gZmFsc2UgJiYgdmlkZW8ucmVhZHlTdGF0ZSA+PSB2aWRlby5IQVZFX0NVUlJFTlRfREFUQSApIHtcblxuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmNsYXNzIEZyYW1lYnVmZmVyVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG5cdGNvbnN0cnVjdG9yKCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0c3VwZXIoIHsgd2lkdGgsIGhlaWdodCB9ICk7XG5cblx0XHR0aGlzLmlzRnJhbWVidWZmZXJUZXh0dXJlID0gdHJ1ZTtcblxuXHRcdHRoaXMubWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcblx0XHR0aGlzLm1pbkZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG5cblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG59XG5cbmNsYXNzIENvbXByZXNzZWRUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cblx0Y29uc3RydWN0b3IoIG1pcG1hcHMsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSwgY29sb3JTcGFjZSApIHtcblxuXHRcdHN1cGVyKCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHksIGNvbG9yU3BhY2UgKTtcblxuXHRcdHRoaXMuaXNDb21wcmVzc2VkVGV4dHVyZSA9IHRydWU7XG5cblx0XHR0aGlzLmltYWdlID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG5cdFx0dGhpcy5taXBtYXBzID0gbWlwbWFwcztcblxuXHRcdC8vIG5vIGZsaXBwaW5nIGZvciBjdWJlIHRleHR1cmVzXG5cdFx0Ly8gKGFsc28gZmxpcHBpbmcgZG9lc24ndCB3b3JrIGZvciBjb21wcmVzc2VkIHRleHR1cmVzIClcblxuXHRcdHRoaXMuZmxpcFkgPSBmYWxzZTtcblxuXHRcdC8vIGNhbid0IGdlbmVyYXRlIG1pcG1hcHMgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXNcblx0XHQvLyBtaXBzIG11c3QgYmUgZW1iZWRkZWQgaW4gRERTIGZpbGVzXG5cblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdH1cblxufVxuXG5jbGFzcyBDb21wcmVzc2VkQXJyYXlUZXh0dXJlIGV4dGVuZHMgQ29tcHJlc3NlZFRleHR1cmUge1xuXG5cdGNvbnN0cnVjdG9yKCBtaXBtYXBzLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgZm9ybWF0LCB0eXBlICkge1xuXG5cdFx0c3VwZXIoIG1pcG1hcHMsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSApO1xuXG5cdFx0dGhpcy5pc0NvbXByZXNzZWRBcnJheVRleHR1cmUgPSB0cnVlO1xuXHRcdHRoaXMuaW1hZ2UuZGVwdGggPSBkZXB0aDtcblx0XHR0aGlzLndyYXBSID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuXHRcdHRoaXMubGF5ZXJVcGRhdGVzID0gbmV3IFNldCgpO1xuXG5cdH1cblxuXHRhZGRMYXllclVwZGF0ZSggbGF5ZXJJbmRleCApIHtcblxuXHRcdHRoaXMubGF5ZXJVcGRhdGVzLmFkZCggbGF5ZXJJbmRleCApO1xuXG5cdH1cblxuXHRjbGVhckxheWVyVXBkYXRlcygpIHtcblxuXHRcdHRoaXMubGF5ZXJVcGRhdGVzLmNsZWFyKCk7XG5cblx0fVxuXG59XG5cbmNsYXNzIENvbXByZXNzZWRDdWJlVGV4dHVyZSBleHRlbmRzIENvbXByZXNzZWRUZXh0dXJlIHtcblxuXHRjb25zdHJ1Y3RvciggaW1hZ2VzLCBmb3JtYXQsIHR5cGUgKSB7XG5cblx0XHRzdXBlciggdW5kZWZpbmVkLCBpbWFnZXNbIDAgXS53aWR0aCwgaW1hZ2VzWyAwIF0uaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIEN1YmVSZWZsZWN0aW9uTWFwcGluZyApO1xuXG5cdFx0dGhpcy5pc0NvbXByZXNzZWRDdWJlVGV4dHVyZSA9IHRydWU7XG5cdFx0dGhpcy5pc0N1YmVUZXh0dXJlID0gdHJ1ZTtcblxuXHRcdHRoaXMuaW1hZ2UgPSBpbWFnZXM7XG5cblx0fVxuXG59XG5cbmNsYXNzIENhbnZhc1RleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblxuXHRjb25zdHJ1Y3RvciggY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XG5cblx0XHRzdXBlciggY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuXHRcdHRoaXMuaXNDYW52YXNUZXh0dXJlID0gdHJ1ZTtcblxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxufVxuXG5jbGFzcyBEZXB0aFRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblxuXHRjb25zdHJ1Y3Rvciggd2lkdGgsIGhlaWdodCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSwgZm9ybWF0ID0gRGVwdGhGb3JtYXQgKSB7XG5cblx0XHRpZiAoIGZvcm1hdCAhPT0gRGVwdGhGb3JtYXQgJiYgZm9ybWF0ICE9PSBEZXB0aFN0ZW5jaWxGb3JtYXQgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0RlcHRoVGV4dHVyZSBmb3JtYXQgbXVzdCBiZSBlaXRoZXIgVEhSRUUuRGVwdGhGb3JtYXQgb3IgVEhSRUUuRGVwdGhTdGVuY2lsRm9ybWF0JyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlID09PSB1bmRlZmluZWQgJiYgZm9ybWF0ID09PSBEZXB0aEZvcm1hdCApIHR5cGUgPSBVbnNpZ25lZEludFR5cGU7XG5cdFx0aWYgKCB0eXBlID09PSB1bmRlZmluZWQgJiYgZm9ybWF0ID09PSBEZXB0aFN0ZW5jaWxGb3JtYXQgKSB0eXBlID0gVW5zaWduZWRJbnQyNDhUeXBlO1xuXG5cdFx0c3VwZXIoIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG5cdFx0dGhpcy5pc0RlcHRoVGV4dHVyZSA9IHRydWU7XG5cblx0XHR0aGlzLmltYWdlID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG5cblx0XHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogTmVhcmVzdEZpbHRlcjtcblx0XHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogTmVhcmVzdEZpbHRlcjtcblxuXHRcdHRoaXMuZmxpcFkgPSBmYWxzZTtcblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5jb21wYXJlRnVuY3Rpb24gPSBudWxsO1xuXG5cdH1cblxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jb21wYXJlRnVuY3Rpb24gPSBzb3VyY2UuY29tcGFyZUZ1bmN0aW9uO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTiggbWV0YSApIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oIG1ldGEgKTtcblxuXHRcdGlmICggdGhpcy5jb21wYXJlRnVuY3Rpb24gIT09IG51bGwgKSBkYXRhLmNvbXBhcmVGdW5jdGlvbiA9IHRoaXMuY29tcGFyZUZ1bmN0aW9uO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59XG5cbi8qKlxuICogRXh0ZW5zaWJsZSBjdXJ2ZSBvYmplY3QuXG4gKlxuICogU29tZSBjb21tb24gb2YgY3VydmUgbWV0aG9kczpcbiAqIC5nZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgKSwgLmdldFRhbmdlbnQoIHQsIG9wdGlvbmFsVGFyZ2V0IClcbiAqIC5nZXRQb2ludEF0KCB1LCBvcHRpb25hbFRhcmdldCApLCAuZ2V0VGFuZ2VudEF0KCB1LCBvcHRpb25hbFRhcmdldCApXG4gKiAuZ2V0UG9pbnRzKCksIC5nZXRTcGFjZWRQb2ludHMoKVxuICogLmdldExlbmd0aCgpXG4gKiAudXBkYXRlQXJjTGVuZ3RocygpXG4gKlxuICogVGhpcyBmb2xsb3dpbmcgY3VydmVzIGluaGVyaXQgZnJvbSBUSFJFRS5DdXJ2ZTpcbiAqXG4gKiAtLSAyRCBjdXJ2ZXMgLS1cbiAqIFRIUkVFLkFyY0N1cnZlXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlXG4gKiBUSFJFRS5FbGxpcHNlQ3VydmVcbiAqIFRIUkVFLkxpbmVDdXJ2ZVxuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmVcbiAqIFRIUkVFLlNwbGluZUN1cnZlXG4gKlxuICogLS0gM0QgY3VydmVzIC0tXG4gKiBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlM1xuICogVEhSRUUuTGluZUN1cnZlM1xuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzXG4gKlxuICogQSBzZXJpZXMgb2YgY3VydmVzIGNhbiBiZSByZXByZXNlbnRlZCBhcyBhIFRIUkVFLkN1cnZlUGF0aC5cbiAqXG4gKiovXG5cbmNsYXNzIEN1cnZlIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMudHlwZSA9ICdDdXJ2ZSc7XG5cblx0XHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IDIwMDtcblxuXHR9XG5cblx0Ly8gVmlydHVhbCBiYXNlIGNsYXNzIG1ldGhvZCB0byBvdmVyd3JpdGUgYW5kIGltcGxlbWVudCBpbiBzdWJjbGFzc2VzXG5cdC8vXHQtIHQgWzAgLi4gMV1cblxuXHRnZXRQb2ludCggLyogdCwgb3B0aW9uYWxUYXJnZXQgKi8gKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5DdXJ2ZTogLmdldFBvaW50KCkgbm90IGltcGxlbWVudGVkLicgKTtcblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cblx0Ly8gR2V0IHBvaW50IGF0IHJlbGF0aXZlIHBvc2l0aW9uIGluIGN1cnZlIGFjY29yZGluZyB0byBhcmMgbGVuZ3RoXG5cdC8vIC0gdSBbMCAuLiAxXVxuXG5cdGdldFBvaW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHR9XG5cblx0Ly8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludCggdCApXG5cblx0Z2V0UG9pbnRzKCBkaXZpc2lvbnMgPSA1ICkge1xuXG5cdFx0Y29uc3QgcG9pbnRzID0gW107XG5cblx0XHRmb3IgKCBsZXQgZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xuXG5cdFx0XHRwb2ludHMucHVzaCggdGhpcy5nZXRQb2ludCggZCAvIGRpdmlzaW9ucyApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnRzO1xuXG5cdH1cblxuXHQvLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50QXQoIHUgKVxuXG5cdGdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zID0gNSApIHtcblxuXHRcdGNvbnN0IHBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCArKyApIHtcblxuXHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnRBdCggZCAvIGRpdmlzaW9ucyApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnRzO1xuXG5cdH1cblxuXHQvLyBHZXQgdG90YWwgY3VydmUgYXJjIGxlbmd0aFxuXG5cdGdldExlbmd0aCgpIHtcblxuXHRcdGNvbnN0IGxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcblx0XHRyZXR1cm4gbGVuZ3Roc1sgbGVuZ3Rocy5sZW5ndGggLSAxIF07XG5cblx0fVxuXG5cdC8vIEdldCBsaXN0IG9mIGN1bXVsYXRpdmUgc2VnbWVudCBsZW5ndGhzXG5cblx0Z2V0TGVuZ3RocyggZGl2aXNpb25zID0gdGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgKSB7XG5cblx0XHRpZiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzICYmXG5cdFx0XHQoIHRoaXMuY2FjaGVBcmNMZW5ndGhzLmxlbmd0aCA9PT0gZGl2aXNpb25zICsgMSApICYmXG5cdFx0XHQhIHRoaXMubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3RocztcblxuXHRcdH1cblxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdGNvbnN0IGNhY2hlID0gW107XG5cdFx0bGV0IGN1cnJlbnQsIGxhc3QgPSB0aGlzLmdldFBvaW50KCAwICk7XG5cdFx0bGV0IHN1bSA9IDA7XG5cblx0XHRjYWNoZS5wdXNoKCAwICk7XG5cblx0XHRmb3IgKCBsZXQgcCA9IDE7IHAgPD0gZGl2aXNpb25zOyBwICsrICkge1xuXG5cdFx0XHRjdXJyZW50ID0gdGhpcy5nZXRQb2ludCggcCAvIGRpdmlzaW9ucyApO1xuXHRcdFx0c3VtICs9IGN1cnJlbnQuZGlzdGFuY2VUbyggbGFzdCApO1xuXHRcdFx0Y2FjaGUucHVzaCggc3VtICk7XG5cdFx0XHRsYXN0ID0gY3VycmVudDtcblxuXHRcdH1cblxuXHRcdHRoaXMuY2FjaGVBcmNMZW5ndGhzID0gY2FjaGU7XG5cblx0XHRyZXR1cm4gY2FjaGU7IC8vIHsgc3VtczogY2FjaGUsIHN1bTogc3VtIH07IFN1bSBpcyBpbiB0aGUgbGFzdCBlbGVtZW50LlxuXG5cdH1cblxuXHR1cGRhdGVBcmNMZW5ndGhzKCkge1xuXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5nZXRMZW5ndGhzKCk7XG5cblx0fVxuXG5cdC8vIEdpdmVuIHUgKCAwIC4uIDEgKSwgZ2V0IGEgdCB0byBmaW5kIHAuIFRoaXMgZ2l2ZXMgeW91IHBvaW50cyB3aGljaCBhcmUgZXF1aWRpc3RhbnRcblxuXHRnZXRVdG9UbWFwcGluZyggdSwgZGlzdGFuY2UgKSB7XG5cblx0XHRjb25zdCBhcmNMZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XG5cblx0XHRsZXQgaSA9IDA7XG5cdFx0Y29uc3QgaWwgPSBhcmNMZW5ndGhzLmxlbmd0aDtcblxuXHRcdGxldCB0YXJnZXRBcmNMZW5ndGg7IC8vIFRoZSB0YXJnZXRlZCB1IGRpc3RhbmNlIHZhbHVlIHRvIGdldFxuXG5cdFx0aWYgKCBkaXN0YW5jZSApIHtcblxuXHRcdFx0dGFyZ2V0QXJjTGVuZ3RoID0gZGlzdGFuY2U7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0YXJnZXRBcmNMZW5ndGggPSB1ICogYXJjTGVuZ3Roc1sgaWwgLSAxIF07XG5cblx0XHR9XG5cblx0XHQvLyBiaW5hcnkgc2VhcmNoIGZvciB0aGUgaW5kZXggd2l0aCBsYXJnZXN0IHZhbHVlIHNtYWxsZXIgdGhhbiB0YXJnZXQgdSBkaXN0YW5jZVxuXG5cdFx0bGV0IGxvdyA9IDAsIGhpZ2ggPSBpbCAtIDEsIGNvbXBhcmlzb247XG5cblx0XHR3aGlsZSAoIGxvdyA8PSBoaWdoICkge1xuXG5cdFx0XHRpID0gTWF0aC5mbG9vciggbG93ICsgKCBoaWdoIC0gbG93ICkgLyAyICk7IC8vIGxlc3MgbGlrZWx5IHRvIG92ZXJmbG93LCB0aG91Z2ggcHJvYmFibHkgbm90IGlzc3VlIGhlcmUsIEpTIGRvZXNuJ3QgcmVhbGx5IGhhdmUgaW50ZWdlcnMsIGFsbCBudW1iZXJzIGFyZSBmbG9hdHNcblxuXHRcdFx0Y29tcGFyaXNvbiA9IGFyY0xlbmd0aHNbIGkgXSAtIHRhcmdldEFyY0xlbmd0aDtcblxuXHRcdFx0aWYgKCBjb21wYXJpc29uIDwgMCApIHtcblxuXHRcdFx0XHRsb3cgPSBpICsgMTtcblxuXHRcdFx0fSBlbHNlIGlmICggY29tcGFyaXNvbiA+IDAgKSB7XG5cblx0XHRcdFx0aGlnaCA9IGkgLSAxO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGhpZ2ggPSBpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHQvLyBET05FXG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGkgPSBoaWdoO1xuXG5cdFx0aWYgKCBhcmNMZW5ndGhzWyBpIF0gPT09IHRhcmdldEFyY0xlbmd0aCApIHtcblxuXHRcdFx0cmV0dXJuIGkgLyAoIGlsIC0gMSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gd2UgY291bGQgZ2V0IGZpbmVyIGdyYWluIGF0IGxlbmd0aHMsIG9yIHVzZSBzaW1wbGUgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcblxuXHRcdGNvbnN0IGxlbmd0aEJlZm9yZSA9IGFyY0xlbmd0aHNbIGkgXTtcblx0XHRjb25zdCBsZW5ndGhBZnRlciA9IGFyY0xlbmd0aHNbIGkgKyAxIF07XG5cblx0XHRjb25zdCBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7XG5cblx0XHQvLyBkZXRlcm1pbmUgd2hlcmUgd2UgYXJlIGJldHdlZW4gdGhlICdiZWZvcmUnIGFuZCAnYWZ0ZXInIHBvaW50c1xuXG5cdFx0Y29uc3Qgc2VnbWVudEZyYWN0aW9uID0gKCB0YXJnZXRBcmNMZW5ndGggLSBsZW5ndGhCZWZvcmUgKSAvIHNlZ21lbnRMZW5ndGg7XG5cblx0XHQvLyBhZGQgdGhhdCBmcmFjdGlvbmFsIGFtb3VudCB0byB0XG5cblx0XHRjb25zdCB0ID0gKCBpICsgc2VnbWVudEZyYWN0aW9uICkgLyAoIGlsIC0gMSApO1xuXG5cdFx0cmV0dXJuIHQ7XG5cblx0fVxuXG5cdC8vIFJldHVybnMgYSB1bml0IHZlY3RvciB0YW5nZW50IGF0IHRcblx0Ly8gSW4gY2FzZSBhbnkgc3ViIGN1cnZlIGRvZXMgbm90IGltcGxlbWVudCBpdHMgdGFuZ2VudCBkZXJpdmF0aW9uLFxuXHQvLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxuXHQvLyB3aGljaCBzZWVtcyB0byBnaXZlIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uXG5cblx0Z2V0VGFuZ2VudCggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRjb25zdCBkZWx0YSA9IDAuMDAwMTtcblx0XHRsZXQgdDEgPSB0IC0gZGVsdGE7XG5cdFx0bGV0IHQyID0gdCArIGRlbHRhO1xuXG5cdFx0Ly8gQ2FwcGluZyBpbiBjYXNlIG9mIGRhbmdlclxuXG5cdFx0aWYgKCB0MSA8IDAgKSB0MSA9IDA7XG5cdFx0aWYgKCB0MiA+IDEgKSB0MiA9IDE7XG5cblx0XHRjb25zdCBwdDEgPSB0aGlzLmdldFBvaW50KCB0MSApO1xuXHRcdGNvbnN0IHB0MiA9IHRoaXMuZ2V0UG9pbnQoIHQyICk7XG5cblx0XHRjb25zdCB0YW5nZW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgKCAoIHB0MS5pc1ZlY3RvcjIgKSA/IG5ldyBWZWN0b3IyKCkgOiBuZXcgVmVjdG9yMygpICk7XG5cblx0XHR0YW5nZW50LmNvcHkoIHB0MiApLnN1YiggcHQxICkubm9ybWFsaXplKCk7XG5cblx0XHRyZXR1cm4gdGFuZ2VudDtcblxuXHR9XG5cblx0Z2V0VGFuZ2VudEF0KCB1LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdGNvbnN0IHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VGFuZ2VudCggdCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHR9XG5cblx0Y29tcHV0ZUZyZW5ldEZyYW1lcyggc2VnbWVudHMsIGNsb3NlZCApIHtcblxuXHRcdC8vIHNlZSBodHRwOi8vd3d3LmNzLmluZGlhbmEuZWR1L3B1Yi90ZWNocmVwb3J0cy9UUjQyNS5wZGZcblxuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRjb25zdCB0YW5nZW50cyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCBiaW5vcm1hbHMgPSBbXTtcblxuXHRcdGNvbnN0IHZlYyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgbWF0ID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdC8vIGNvbXB1dGUgdGhlIHRhbmdlbnQgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBjdXJ2ZVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCB1ID0gaSAvIHNlZ21lbnRzO1xuXG5cdFx0XHR0YW5nZW50c1sgaSBdID0gdGhpcy5nZXRUYW5nZW50QXQoIHUsIG5ldyBWZWN0b3IzKCkgKTtcblxuXHRcdH1cblxuXHRcdC8vIHNlbGVjdCBhbiBpbml0aWFsIG5vcm1hbCB2ZWN0b3IgcGVycGVuZGljdWxhciB0byB0aGUgZmlyc3QgdGFuZ2VudCB2ZWN0b3IsXG5cdFx0Ly8gYW5kIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG1pbmltdW0gdGFuZ2VudCB4eXogY29tcG9uZW50XG5cblx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVmVjdG9yMygpO1xuXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFZlY3RvcjMoKTtcblx0XHRsZXQgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcblx0XHRjb25zdCB0eCA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnggKTtcblx0XHRjb25zdCB0eSA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnkgKTtcblx0XHRjb25zdCB0eiA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnogKTtcblxuXHRcdGlmICggdHggPD0gbWluICkge1xuXG5cdFx0XHRtaW4gPSB0eDtcblx0XHRcdG5vcm1hbC5zZXQoIDEsIDAsIDAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHkgPD0gbWluICkge1xuXG5cdFx0XHRtaW4gPSB0eTtcblx0XHRcdG5vcm1hbC5zZXQoIDAsIDEsIDAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHogPD0gbWluICkge1xuXG5cdFx0XHRub3JtYWwuc2V0KCAwLCAwLCAxICk7XG5cblx0XHR9XG5cblx0XHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWwgKS5ub3JtYWxpemUoKTtcblxuXHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIHZlYyApO1xuXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XG5cblxuXHRcdC8vIGNvbXB1dGUgdGhlIHNsb3dseS12YXJ5aW5nIG5vcm1hbCBhbmQgYmlub3JtYWwgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBjdXJ2ZVxuXG5cdFx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRub3JtYWxzWyBpIF0gPSBub3JtYWxzWyBpIC0gMSBdLmNsb25lKCk7XG5cblx0XHRcdGJpbm9ybWFsc1sgaSBdID0gYmlub3JtYWxzWyBpIC0gMSBdLmNsb25lKCk7XG5cblx0XHRcdHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIC0gMSBdLCB0YW5nZW50c1sgaSBdICk7XG5cblx0XHRcdGlmICggdmVjLmxlbmd0aCgpID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0dmVjLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdGNvbnN0IHRoZXRhID0gTWF0aC5hY29zKCBjbGFtcCggdGFuZ2VudHNbIGkgLSAxIF0uZG90KCB0YW5nZW50c1sgaSBdICksIC0gMSwgMSApICk7IC8vIGNsYW1wIGZvciBmbG9hdGluZyBwdCBlcnJvcnNcblxuXHRcdFx0XHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdmVjLCB0aGV0YSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ymlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcblxuXHRcdH1cblxuXHRcdC8vIGlmIHRoZSBjdXJ2ZSBpcyBjbG9zZWQsIHBvc3Rwcm9jZXNzIHRoZSB2ZWN0b3JzIHNvIHRoZSBmaXJzdCBhbmQgbGFzdCBub3JtYWwgdmVjdG9ycyBhcmUgdGhlIHNhbWVcblxuXHRcdGlmICggY2xvc2VkID09PSB0cnVlICkge1xuXG5cdFx0XHRsZXQgdGhldGEgPSBNYXRoLmFjb3MoIGNsYW1wKCBub3JtYWxzWyAwIF0uZG90KCBub3JtYWxzWyBzZWdtZW50cyBdICksIC0gMSwgMSApICk7XG5cdFx0XHR0aGV0YSAvPSBzZWdtZW50cztcblxuXHRcdFx0aWYgKCB0YW5nZW50c1sgMCBdLmRvdCggdmVjLmNyb3NzVmVjdG9ycyggbm9ybWFsc1sgMCBdLCBub3JtYWxzWyBzZWdtZW50cyBdICkgKSA+IDAgKSB7XG5cblx0XHRcdFx0dGhldGEgPSAtIHRoZXRhO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGxldCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHQvLyB0d2lzdCBhIGxpdHRsZS4uLlxuXHRcdFx0XHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdGFuZ2VudHNbIGkgXSwgdGhldGEgKiBpICkgKTtcblx0XHRcdFx0Ymlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRhbmdlbnRzOiB0YW5nZW50cyxcblx0XHRcdG5vcm1hbHM6IG5vcm1hbHMsXG5cdFx0XHRiaW5vcm1hbHM6IGJpbm9ybWFsc1xuXHRcdH07XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IHNvdXJjZS5hcmNMZW5ndGhEaXZpc2lvbnM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdHZlcnNpb246IDQuNixcblx0XHRcdFx0dHlwZTogJ0N1cnZlJyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnQ3VydmUudG9KU09OJ1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRkYXRhLmFyY0xlbmd0aERpdmlzaW9ucyA9IHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zO1xuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zID0ganNvbi5hcmNMZW5ndGhEaXZpc2lvbnM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY2xhc3MgRWxsaXBzZUN1cnZlIGV4dGVuZHMgQ3VydmUge1xuXG5cdGNvbnN0cnVjdG9yKCBhWCA9IDAsIGFZID0gMCwgeFJhZGl1cyA9IDEsIHlSYWRpdXMgPSAxLCBhU3RhcnRBbmdsZSA9IDAsIGFFbmRBbmdsZSA9IE1hdGguUEkgKiAyLCBhQ2xvY2t3aXNlID0gZmFsc2UsIGFSb3RhdGlvbiA9IDAgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0VsbGlwc2VDdXJ2ZSA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnRWxsaXBzZUN1cnZlJztcblxuXHRcdHRoaXMuYVggPSBhWDtcblx0XHR0aGlzLmFZID0gYVk7XG5cblx0XHR0aGlzLnhSYWRpdXMgPSB4UmFkaXVzO1xuXHRcdHRoaXMueVJhZGl1cyA9IHlSYWRpdXM7XG5cblx0XHR0aGlzLmFTdGFydEFuZ2xlID0gYVN0YXJ0QW5nbGU7XG5cdFx0dGhpcy5hRW5kQW5nbGUgPSBhRW5kQW5nbGU7XG5cblx0XHR0aGlzLmFDbG9ja3dpc2UgPSBhQ2xvY2t3aXNlO1xuXG5cdFx0dGhpcy5hUm90YXRpb24gPSBhUm90YXRpb247XG5cblx0fVxuXG5cdGdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IyKCkgKSB7XG5cblx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuXG5cdFx0Y29uc3QgdHdvUGkgPSBNYXRoLlBJICogMjtcblx0XHRsZXQgZGVsdGFBbmdsZSA9IHRoaXMuYUVuZEFuZ2xlIC0gdGhpcy5hU3RhcnRBbmdsZTtcblx0XHRjb25zdCBzYW1lUG9pbnRzID0gTWF0aC5hYnMoIGRlbHRhQW5nbGUgKSA8IE51bWJlci5FUFNJTE9OO1xuXG5cdFx0Ly8gZW5zdXJlcyB0aGF0IGRlbHRhQW5nbGUgaXMgMCAuLiAyIFBJXG5cdFx0d2hpbGUgKCBkZWx0YUFuZ2xlIDwgMCApIGRlbHRhQW5nbGUgKz0gdHdvUGk7XG5cdFx0d2hpbGUgKCBkZWx0YUFuZ2xlID4gdHdvUGkgKSBkZWx0YUFuZ2xlIC09IHR3b1BpO1xuXG5cdFx0aWYgKCBkZWx0YUFuZ2xlIDwgTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdGlmICggc2FtZVBvaW50cyApIHtcblxuXHRcdFx0XHRkZWx0YUFuZ2xlID0gMDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRkZWx0YUFuZ2xlID0gdHdvUGk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hQ2xvY2t3aXNlID09PSB0cnVlICYmICEgc2FtZVBvaW50cyApIHtcblxuXHRcdFx0aWYgKCBkZWx0YUFuZ2xlID09PSB0d29QaSApIHtcblxuXHRcdFx0XHRkZWx0YUFuZ2xlID0gLSB0d29QaTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRkZWx0YUFuZ2xlID0gZGVsdGFBbmdsZSAtIHR3b1BpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zdCBhbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcblx0XHRsZXQgeCA9IHRoaXMuYVggKyB0aGlzLnhSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcblx0XHRsZXQgeSA9IHRoaXMuYVkgKyB0aGlzLnlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblxuXHRcdGlmICggdGhpcy5hUm90YXRpb24gIT09IDAgKSB7XG5cblx0XHRcdGNvbnN0IGNvcyA9IE1hdGguY29zKCB0aGlzLmFSb3RhdGlvbiApO1xuXHRcdFx0Y29uc3Qgc2luID0gTWF0aC5zaW4oIHRoaXMuYVJvdGF0aW9uICk7XG5cblx0XHRcdGNvbnN0IHR4ID0geCAtIHRoaXMuYVg7XG5cdFx0XHRjb25zdCB0eSA9IHkgLSB0aGlzLmFZO1xuXG5cdFx0XHQvLyBSb3RhdGUgdGhlIHBvaW50IGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXG5cdFx0XHR4ID0gdHggKiBjb3MgLSB0eSAqIHNpbiArIHRoaXMuYVg7XG5cdFx0XHR5ID0gdHggKiBzaW4gKyB0eSAqIGNvcyArIHRoaXMuYVk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnQuc2V0KCB4LCB5ICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5hWCA9IHNvdXJjZS5hWDtcblx0XHR0aGlzLmFZID0gc291cmNlLmFZO1xuXG5cdFx0dGhpcy54UmFkaXVzID0gc291cmNlLnhSYWRpdXM7XG5cdFx0dGhpcy55UmFkaXVzID0gc291cmNlLnlSYWRpdXM7XG5cblx0XHR0aGlzLmFTdGFydEFuZ2xlID0gc291cmNlLmFTdGFydEFuZ2xlO1xuXHRcdHRoaXMuYUVuZEFuZ2xlID0gc291cmNlLmFFbmRBbmdsZTtcblxuXHRcdHRoaXMuYUNsb2Nrd2lzZSA9IHNvdXJjZS5hQ2xvY2t3aXNlO1xuXG5cdFx0dGhpcy5hUm90YXRpb24gPSBzb3VyY2UuYVJvdGF0aW9uO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGRhdGEuYVggPSB0aGlzLmFYO1xuXHRcdGRhdGEuYVkgPSB0aGlzLmFZO1xuXG5cdFx0ZGF0YS54UmFkaXVzID0gdGhpcy54UmFkaXVzO1xuXHRcdGRhdGEueVJhZGl1cyA9IHRoaXMueVJhZGl1cztcblxuXHRcdGRhdGEuYVN0YXJ0QW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlO1xuXHRcdGRhdGEuYUVuZEFuZ2xlID0gdGhpcy5hRW5kQW5nbGU7XG5cblx0XHRkYXRhLmFDbG9ja3dpc2UgPSB0aGlzLmFDbG9ja3dpc2U7XG5cblx0XHRkYXRhLmFSb3RhdGlvbiA9IHRoaXMuYVJvdGF0aW9uO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMuYVggPSBqc29uLmFYO1xuXHRcdHRoaXMuYVkgPSBqc29uLmFZO1xuXG5cdFx0dGhpcy54UmFkaXVzID0ganNvbi54UmFkaXVzO1xuXHRcdHRoaXMueVJhZGl1cyA9IGpzb24ueVJhZGl1cztcblxuXHRcdHRoaXMuYVN0YXJ0QW5nbGUgPSBqc29uLmFTdGFydEFuZ2xlO1xuXHRcdHRoaXMuYUVuZEFuZ2xlID0ganNvbi5hRW5kQW5nbGU7XG5cblx0XHR0aGlzLmFDbG9ja3dpc2UgPSBqc29uLmFDbG9ja3dpc2U7XG5cblx0XHR0aGlzLmFSb3RhdGlvbiA9IGpzb24uYVJvdGF0aW9uO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNsYXNzIEFyY0N1cnZlIGV4dGVuZHMgRWxsaXBzZUN1cnZlIHtcblxuXHRjb25zdHJ1Y3RvciggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG5cdFx0c3VwZXIoIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG5cdFx0dGhpcy5pc0FyY0N1cnZlID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdBcmNDdXJ2ZSc7XG5cblx0fVxuXG59XG5cbi8qKlxuICogQ2VudHJpcGV0YWwgQ2F0bXVsbFJvbSBDdXJ2ZSAtIHdoaWNoIGlzIHVzZWZ1bCBmb3IgYXZvaWRpbmdcbiAqIGN1c3BzIGFuZCBzZWxmLWludGVyc2VjdGlvbnMgaW4gbm9uLXVuaWZvcm0gY2F0bXVsbCByb20gY3VydmVzLlxuICogaHR0cDovL3d3dy5jZW15dWtzZWwuY29tL3Jlc2VhcmNoL2NhdG11bGxyb21fcGFyYW0vY2F0bXVsbHJvbS5wZGZcbiAqXG4gKiBjdXJ2ZS50eXBlIGFjY2VwdHMgY2VudHJpcGV0YWwoZGVmYXVsdCksIGNob3JkYWwgYW5kIGNhdG11bGxyb21cbiAqIGN1cnZlLnRlbnNpb24gaXMgdXNlZCBmb3IgY2F0bXVsbHJvbSB3aGljaCBkZWZhdWx0cyB0byAwLjVcbiAqL1xuXG5cbi8qXG5CYXNlZCBvbiBhbiBvcHRpbWl6ZWQgYysrIHNvbHV0aW9uIGluXG4gLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk0ODk3MzYvY2F0bXVsbC1yb20tY3VydmUtd2l0aC1uby1jdXNwcy1hbmQtbm8tc2VsZi1pbnRlcnNlY3Rpb25zL1xuIC0gaHR0cDovL2lkZW9uZS5jb20vTm9FYlZNXG5cblRoaXMgQ3ViaWNQb2x5IGNsYXNzIGNvdWxkIGJlIHVzZWQgZm9yIHJldXNpbmcgc29tZSB2YXJpYWJsZXMgYW5kIGNhbGN1bGF0aW9ucyxcbmJ1dCBmb3IgdGhyZWUuanMgY3VydmUgdXNlLCBpdCBjb3VsZCBiZSBwb3NzaWJsZSBpbmxpbmVkIGFuZCBmbGF0dGVuIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gY2FsbFxud2hpY2ggY2FuIGJlIHBsYWNlZCBpbiBDdXJ2ZVV0aWxzLlxuKi9cblxuZnVuY3Rpb24gQ3ViaWNQb2x5KCkge1xuXG5cdGxldCBjMCA9IDAsIGMxID0gMCwgYzIgPSAwLCBjMyA9IDA7XG5cblx0Lypcblx0ICogQ29tcHV0ZSBjb2VmZmljaWVudHMgZm9yIGEgY3ViaWMgcG9seW5vbWlhbFxuXHQgKiAgIHAocykgPSBjMCArIGMxKnMgKyBjMipzXjIgKyBjMypzXjNcblx0ICogc3VjaCB0aGF0XG5cdCAqICAgcCgwKSA9IHgwLCBwKDEpID0geDFcblx0ICogIGFuZFxuXHQgKiAgIHAnKDApID0gdDAsIHAnKDEpID0gdDEuXG5cdCAqL1xuXHRmdW5jdGlvbiBpbml0KCB4MCwgeDEsIHQwLCB0MSApIHtcblxuXHRcdGMwID0geDA7XG5cdFx0YzEgPSB0MDtcblx0XHRjMiA9IC0gMyAqIHgwICsgMyAqIHgxIC0gMiAqIHQwIC0gdDE7XG5cdFx0YzMgPSAyICogeDAgLSAyICogeDEgKyB0MCArIHQxO1xuXG5cdH1cblxuXHRyZXR1cm4ge1xuXG5cdFx0aW5pdENhdG11bGxSb206IGZ1bmN0aW9uICggeDAsIHgxLCB4MiwgeDMsIHRlbnNpb24gKSB7XG5cblx0XHRcdGluaXQoIHgxLCB4MiwgdGVuc2lvbiAqICggeDIgLSB4MCApLCB0ZW5zaW9uICogKCB4MyAtIHgxICkgKTtcblxuXHRcdH0sXG5cblx0XHRpbml0Tm9udW5pZm9ybUNhdG11bGxSb206IGZ1bmN0aW9uICggeDAsIHgxLCB4MiwgeDMsIGR0MCwgZHQxLCBkdDIgKSB7XG5cblx0XHRcdC8vIGNvbXB1dGUgdGFuZ2VudHMgd2hlbiBwYXJhbWV0ZXJpemVkIGluIFt0MSx0Ml1cblx0XHRcdGxldCB0MSA9ICggeDEgLSB4MCApIC8gZHQwIC0gKCB4MiAtIHgwICkgLyAoIGR0MCArIGR0MSApICsgKCB4MiAtIHgxICkgLyBkdDE7XG5cdFx0XHRsZXQgdDIgPSAoIHgyIC0geDEgKSAvIGR0MSAtICggeDMgLSB4MSApIC8gKCBkdDEgKyBkdDIgKSArICggeDMgLSB4MiApIC8gZHQyO1xuXG5cdFx0XHQvLyByZXNjYWxlIHRhbmdlbnRzIGZvciBwYXJhbWV0cml6YXRpb24gaW4gWzAsMV1cblx0XHRcdHQxICo9IGR0MTtcblx0XHRcdHQyICo9IGR0MTtcblxuXHRcdFx0aW5pdCggeDEsIHgyLCB0MSwgdDIgKTtcblxuXHRcdH0sXG5cblx0XHRjYWxjOiBmdW5jdGlvbiAoIHQgKSB7XG5cblx0XHRcdGNvbnN0IHQyID0gdCAqIHQ7XG5cdFx0XHRjb25zdCB0MyA9IHQyICogdDtcblx0XHRcdHJldHVybiBjMCArIGMxICogdCArIGMyICogdDIgKyBjMyAqIHQzO1xuXG5cdFx0fVxuXG5cdH07XG5cbn1cblxuLy9cblxuY29uc3QgdG1wID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgcHggPSAvKkBfX1BVUkVfXyovIG5ldyBDdWJpY1BvbHkoKTtcbmNvbnN0IHB5ID0gLypAX19QVVJFX18qLyBuZXcgQ3ViaWNQb2x5KCk7XG5jb25zdCBweiA9IC8qQF9fUFVSRV9fKi8gbmV3IEN1YmljUG9seSgpO1xuXG5jbGFzcyBDYXRtdWxsUm9tQ3VydmUzIGV4dGVuZHMgQ3VydmUge1xuXG5cdGNvbnN0cnVjdG9yKCBwb2ludHMgPSBbXSwgY2xvc2VkID0gZmFsc2UsIGN1cnZlVHlwZSA9ICdjZW50cmlwZXRhbCcsIHRlbnNpb24gPSAwLjUgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0NhdG11bGxSb21DdXJ2ZTMgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0NhdG11bGxSb21DdXJ2ZTMnO1xuXG5cdFx0dGhpcy5wb2ludHMgPSBwb2ludHM7XG5cdFx0dGhpcy5jbG9zZWQgPSBjbG9zZWQ7XG5cdFx0dGhpcy5jdXJ2ZVR5cGUgPSBjdXJ2ZVR5cGU7XG5cdFx0dGhpcy50ZW5zaW9uID0gdGVuc2lvbjtcblxuXHR9XG5cblx0Z2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKSApIHtcblxuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG5cblx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRjb25zdCBsID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdGNvbnN0IHAgPSAoIGwgLSAoIHRoaXMuY2xvc2VkID8gMCA6IDEgKSApICogdDtcblx0XHRsZXQgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwICk7XG5cdFx0bGV0IHdlaWdodCA9IHAgLSBpbnRQb2ludDtcblxuXHRcdGlmICggdGhpcy5jbG9zZWQgKSB7XG5cblx0XHRcdGludFBvaW50ICs9IGludFBvaW50ID4gMCA/IDAgOiAoIE1hdGguZmxvb3IoIE1hdGguYWJzKCBpbnRQb2ludCApIC8gbCApICsgMSApICogbDtcblxuXHRcdH0gZWxzZSBpZiAoIHdlaWdodCA9PT0gMCAmJiBpbnRQb2ludCA9PT0gbCAtIDEgKSB7XG5cblx0XHRcdGludFBvaW50ID0gbCAtIDI7XG5cdFx0XHR3ZWlnaHQgPSAxO1xuXG5cdFx0fVxuXG5cdFx0bGV0IHAwLCBwMzsgLy8gNCBwb2ludHMgKHAxICYgcDIgZGVmaW5lZCBiZWxvdylcblxuXHRcdGlmICggdGhpcy5jbG9zZWQgfHwgaW50UG9pbnQgPiAwICkge1xuXG5cdFx0XHRwMCA9IHBvaW50c1sgKCBpbnRQb2ludCAtIDEgKSAlIGwgXTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGV4dHJhcG9sYXRlIGZpcnN0IHBvaW50XG5cdFx0XHR0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyAwIF0sIHBvaW50c1sgMSBdICkuYWRkKCBwb2ludHNbIDAgXSApO1xuXHRcdFx0cDAgPSB0bXA7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwMSA9IHBvaW50c1sgaW50UG9pbnQgJSBsIF07XG5cdFx0Y29uc3QgcDIgPSBwb2ludHNbICggaW50UG9pbnQgKyAxICkgJSBsIF07XG5cblx0XHRpZiAoIHRoaXMuY2xvc2VkIHx8IGludFBvaW50ICsgMiA8IGwgKSB7XG5cblx0XHRcdHAzID0gcG9pbnRzWyAoIGludFBvaW50ICsgMiApICUgbCBdO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gZXh0cmFwb2xhdGUgbGFzdCBwb2ludFxuXHRcdFx0dG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgbCAtIDEgXSwgcG9pbnRzWyBsIC0gMiBdICkuYWRkKCBwb2ludHNbIGwgLSAxIF0gKTtcblx0XHRcdHAzID0gdG1wO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmN1cnZlVHlwZSA9PT0gJ2NlbnRyaXBldGFsJyB8fCB0aGlzLmN1cnZlVHlwZSA9PT0gJ2Nob3JkYWwnICkge1xuXG5cdFx0XHQvLyBpbml0IENlbnRyaXBldGFsIC8gQ2hvcmRhbCBDYXRtdWxsLVJvbVxuXHRcdFx0Y29uc3QgcG93ID0gdGhpcy5jdXJ2ZVR5cGUgPT09ICdjaG9yZGFsJyA/IDAuNSA6IDAuMjU7XG5cdFx0XHRsZXQgZHQwID0gTWF0aC5wb3coIHAwLmRpc3RhbmNlVG9TcXVhcmVkKCBwMSApLCBwb3cgKTtcblx0XHRcdGxldCBkdDEgPSBNYXRoLnBvdyggcDEuZGlzdGFuY2VUb1NxdWFyZWQoIHAyICksIHBvdyApO1xuXHRcdFx0bGV0IGR0MiA9IE1hdGgucG93KCBwMi5kaXN0YW5jZVRvU3F1YXJlZCggcDMgKSwgcG93ICk7XG5cblx0XHRcdC8vIHNhZmV0eSBjaGVjayBmb3IgcmVwZWF0ZWQgcG9pbnRzXG5cdFx0XHRpZiAoIGR0MSA8IDFlLTQgKSBkdDEgPSAxLjA7XG5cdFx0XHRpZiAoIGR0MCA8IDFlLTQgKSBkdDAgPSBkdDE7XG5cdFx0XHRpZiAoIGR0MiA8IDFlLTQgKSBkdDIgPSBkdDE7XG5cblx0XHRcdHB4LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgZHQwLCBkdDEsIGR0MiApO1xuXHRcdFx0cHkuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCBkdDAsIGR0MSwgZHQyICk7XG5cdFx0XHRwei5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnosIHAxLnosIHAyLnosIHAzLnosIGR0MCwgZHQxLCBkdDIgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuY3VydmVUeXBlID09PSAnY2F0bXVsbHJvbScgKSB7XG5cblx0XHRcdHB4LmluaXRDYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCB0aGlzLnRlbnNpb24gKTtcblx0XHRcdHB5LmluaXRDYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCB0aGlzLnRlbnNpb24gKTtcblx0XHRcdHB6LmluaXRDYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCB0aGlzLnRlbnNpb24gKTtcblxuXHRcdH1cblxuXHRcdHBvaW50LnNldChcblx0XHRcdHB4LmNhbGMoIHdlaWdodCApLFxuXHRcdFx0cHkuY2FsYyggd2VpZ2h0ICksXG5cdFx0XHRwei5jYWxjKCB3ZWlnaHQgKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNvdXJjZS5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSBzb3VyY2UucG9pbnRzWyBpIF07XG5cblx0XHRcdHRoaXMucG9pbnRzLnB1c2goIHBvaW50LmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuY2xvc2VkID0gc291cmNlLmNsb3NlZDtcblx0XHR0aGlzLmN1cnZlVHlwZSA9IHNvdXJjZS5jdXJ2ZVR5cGU7XG5cdFx0dGhpcy50ZW5zaW9uID0gc291cmNlLnRlbnNpb247XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0ZGF0YS5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHBvaW50ID0gdGhpcy5wb2ludHNbIGkgXTtcblx0XHRcdGRhdGEucG9pbnRzLnB1c2goIHBvaW50LnRvQXJyYXkoKSApO1xuXG5cdFx0fVxuXG5cdFx0ZGF0YS5jbG9zZWQgPSB0aGlzLmNsb3NlZDtcblx0XHRkYXRhLmN1cnZlVHlwZSA9IHRoaXMuY3VydmVUeXBlO1xuXHRcdGRhdGEudGVuc2lvbiA9IHRoaXMudGVuc2lvbjtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLnBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0ganNvbi5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSBqc29uLnBvaW50c1sgaSBdO1xuXHRcdFx0dGhpcy5wb2ludHMucHVzaCggbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoIHBvaW50ICkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuY2xvc2VkID0ganNvbi5jbG9zZWQ7XG5cdFx0dGhpcy5jdXJ2ZVR5cGUgPSBqc29uLmN1cnZlVHlwZTtcblx0XHR0aGlzLnRlbnNpb24gPSBqc29uLnRlbnNpb247XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBCZXppZXIgQ3VydmVzIGZvcm11bGFzIG9idGFpbmVkIGZyb21cbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0IlQzMlQTl6aWVyX2N1cnZlXG4gKi9cblxuZnVuY3Rpb24gQ2F0bXVsbFJvbSggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XG5cblx0Y29uc3QgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNTtcblx0Y29uc3QgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcblx0Y29uc3QgdDIgPSB0ICogdDtcblx0Y29uc3QgdDMgPSB0ICogdDI7XG5cdHJldHVybiAoIDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xuXG59XG5cbi8vXG5cbmZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAwKCB0LCBwICkge1xuXG5cdGNvbnN0IGsgPSAxIC0gdDtcblx0cmV0dXJuIGsgKiBrICogcDtcblxufVxuXG5mdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJQMSggdCwgcCApIHtcblxuXHRyZXR1cm4gMiAqICggMSAtIHQgKSAqIHQgKiBwO1xuXG59XG5cbmZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAyKCB0LCBwICkge1xuXG5cdHJldHVybiB0ICogdCAqIHA7XG5cbn1cblxuZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyKCB0LCBwMCwgcDEsIHAyICkge1xuXG5cdHJldHVybiBRdWFkcmF0aWNCZXppZXJQMCggdCwgcDAgKSArIFF1YWRyYXRpY0JlemllclAxKCB0LCBwMSApICtcblx0XHRRdWFkcmF0aWNCZXppZXJQMiggdCwgcDIgKTtcblxufVxuXG4vL1xuXG5mdW5jdGlvbiBDdWJpY0JlemllclAwKCB0LCBwICkge1xuXG5cdGNvbnN0IGsgPSAxIC0gdDtcblx0cmV0dXJuIGsgKiBrICogayAqIHA7XG5cbn1cblxuZnVuY3Rpb24gQ3ViaWNCZXppZXJQMSggdCwgcCApIHtcblxuXHRjb25zdCBrID0gMSAtIHQ7XG5cdHJldHVybiAzICogayAqIGsgKiB0ICogcDtcblxufVxuXG5mdW5jdGlvbiBDdWJpY0JlemllclAyKCB0LCBwICkge1xuXG5cdHJldHVybiAzICogKCAxIC0gdCApICogdCAqIHQgKiBwO1xuXG59XG5cbmZ1bmN0aW9uIEN1YmljQmV6aWVyUDMoIHQsIHAgKSB7XG5cblx0cmV0dXJuIHQgKiB0ICogdCAqIHA7XG5cbn1cblxuZnVuY3Rpb24gQ3ViaWNCZXppZXIoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG5cdHJldHVybiBDdWJpY0JlemllclAwKCB0LCBwMCApICsgQ3ViaWNCZXppZXJQMSggdCwgcDEgKSArIEN1YmljQmV6aWVyUDIoIHQsIHAyICkgK1xuXHRcdEN1YmljQmV6aWVyUDMoIHQsIHAzICk7XG5cbn1cblxuY2xhc3MgQ3ViaWNCZXppZXJDdXJ2ZSBleHRlbmRzIEN1cnZlIHtcblxuXHRjb25zdHJ1Y3RvciggdjAgPSBuZXcgVmVjdG9yMigpLCB2MSA9IG5ldyBWZWN0b3IyKCksIHYyID0gbmV3IFZlY3RvcjIoKSwgdjMgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNDdWJpY0JlemllckN1cnZlID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdDdWJpY0JlemllckN1cnZlJztcblxuXHRcdHRoaXMudjAgPSB2MDtcblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXHRcdHRoaXMudjMgPSB2MztcblxuXHR9XG5cblx0Z2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjIoKSApIHtcblxuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG5cblx0XHRjb25zdCB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyLCB2MyA9IHRoaXMudjM7XG5cblx0XHRwb2ludC5zZXQoXG5cdFx0XHRDdWJpY0JlemllciggdCwgdjAueCwgdjEueCwgdjIueCwgdjMueCApLFxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnksIHYzLnkgKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XG5cdFx0dGhpcy52My5jb3B5KCBzb3VyY2UudjMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYzID0gdGhpcy52My50b0FycmF5KCk7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xuXG5cdFx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcblx0XHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xuXHRcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XG5cdFx0dGhpcy52My5mcm9tQXJyYXkoIGpzb24udjMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBDdWJpY0JlemllckN1cnZlMyBleHRlbmRzIEN1cnZlIHtcblxuXHRjb25zdHJ1Y3RvciggdjAgPSBuZXcgVmVjdG9yMygpLCB2MSA9IG5ldyBWZWN0b3IzKCksIHYyID0gbmV3IFZlY3RvcjMoKSwgdjMgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNDdWJpY0JlemllckN1cnZlMyA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnQ3ViaWNCZXppZXJDdXJ2ZTMnO1xuXG5cdFx0dGhpcy52MCA9IHYwO1xuXHRcdHRoaXMudjEgPSB2MTtcblx0XHR0aGlzLnYyID0gdjI7XG5cdFx0dGhpcy52MyA9IHYzO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGNvbnN0IHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjIsIHYzID0gdGhpcy52MztcblxuXHRcdHBvaW50LnNldChcblx0XHRcdEN1YmljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54LCB2My54ICksXG5cdFx0XHRDdWJpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSwgdjMueSApLFxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLnosIHYxLnosIHYyLnosIHYzLnogKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XG5cdFx0dGhpcy52My5jb3B5KCBzb3VyY2UudjMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYzID0gdGhpcy52My50b0FycmF5KCk7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xuXG5cdFx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcblx0XHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xuXHRcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XG5cdFx0dGhpcy52My5mcm9tQXJyYXkoIGpzb24udjMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBMaW5lQ3VydmUgZXh0ZW5kcyBDdXJ2ZSB7XG5cblx0Y29uc3RydWN0b3IoIHYxID0gbmV3IFZlY3RvcjIoKSwgdjIgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNMaW5lQ3VydmUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0xpbmVDdXJ2ZSc7XG5cblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGlmICggdCA9PT0gMSApIHtcblxuXHRcdFx0cG9pbnQuY29weSggdGhpcy52MiApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cG9pbnQuY29weSggdGhpcy52MiApLnN1YiggdGhpcy52MSApO1xuXHRcdFx0cG9pbnQubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMudjEgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwb2ludDtcblxuXHR9XG5cblx0Ly8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XG5cdGdldFBvaW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHUsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0fVxuXG5cdGdldFRhbmdlbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjIoKSApIHtcblxuXHRcdHJldHVybiBvcHRpb25hbFRhcmdldC5zdWJWZWN0b3JzKCB0aGlzLnYyLCB0aGlzLnYxICkubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdGdldFRhbmdlbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB1LCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XG5cdFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG5cdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBMaW5lQ3VydmUzIGV4dGVuZHMgQ3VydmUge1xuXG5cdGNvbnN0cnVjdG9yKCB2MSA9IG5ldyBWZWN0b3IzKCksIHYyID0gbmV3IFZlY3RvcjMoKSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzTGluZUN1cnZlMyA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnTGluZUN1cnZlMyc7XG5cblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGlmICggdCA9PT0gMSApIHtcblxuXHRcdFx0cG9pbnQuY29weSggdGhpcy52MiApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cG9pbnQuY29weSggdGhpcy52MiApLnN1YiggdGhpcy52MSApO1xuXHRcdFx0cG9pbnQubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMudjEgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwb2ludDtcblxuXHR9XG5cblx0Ly8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XG5cdGdldFBvaW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHUsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0fVxuXG5cdGdldFRhbmdlbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKSApIHtcblxuXHRcdHJldHVybiBvcHRpb25hbFRhcmdldC5zdWJWZWN0b3JzKCB0aGlzLnYyLCB0aGlzLnYxICkubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdGdldFRhbmdlbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB1LCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XG5cdFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG5cdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBRdWFkcmF0aWNCZXppZXJDdXJ2ZSBleHRlbmRzIEN1cnZlIHtcblxuXHRjb25zdHJ1Y3RvciggdjAgPSBuZXcgVmVjdG9yMigpLCB2MSA9IG5ldyBWZWN0b3IyKCksIHYyID0gbmV3IFZlY3RvcjIoKSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzUXVhZHJhdGljQmV6aWVyQ3VydmUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1F1YWRyYXRpY0JlemllckN1cnZlJztcblxuXHRcdHRoaXMudjAgPSB2MDtcblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGNvbnN0IHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjI7XG5cblx0XHRwb2ludC5zZXQoXG5cdFx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLnggKSxcblx0XHRcdFF1YWRyYXRpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSApXG5cdFx0KTtcblxuXHRcdHJldHVybiBwb2ludDtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnYwLmNvcHkoIHNvdXJjZS52MCApO1xuXHRcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XG5cdFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLnYwLmZyb21BcnJheSgganNvbi52MCApO1xuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBRdWFkcmF0aWNCZXppZXJDdXJ2ZTMgZXh0ZW5kcyBDdXJ2ZSB7XG5cblx0Y29uc3RydWN0b3IoIHYwID0gbmV3IFZlY3RvcjMoKSwgdjEgPSBuZXcgVmVjdG9yMygpLCB2MiA9IG5ldyBWZWN0b3IzKCkgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc1F1YWRyYXRpY0JlemllckN1cnZlMyA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnUXVhZHJhdGljQmV6aWVyQ3VydmUzJztcblxuXHRcdHRoaXMudjAgPSB2MDtcblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGNvbnN0IHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjI7XG5cblx0XHRwb2ludC5zZXQoXG5cdFx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLnggKSxcblx0XHRcdFF1YWRyYXRpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSApLFxuXHRcdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC56LCB2MS56LCB2Mi56IClcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHBvaW50O1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMudjAuY29weSggc291cmNlLnYwICk7XG5cdFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcblx0XHR0aGlzLnYyLmNvcHkoIHNvdXJjZS52MiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG5cdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMudjAuZnJvbUFycmF5KCBqc29uLnYwICk7XG5cdFx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcblx0XHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNsYXNzIFNwbGluZUN1cnZlIGV4dGVuZHMgQ3VydmUge1xuXG5cdGNvbnN0cnVjdG9yKCBwb2ludHMgPSBbXSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzU3BsaW5lQ3VydmUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1NwbGluZUN1cnZlJztcblxuXHRcdHRoaXMucG9pbnRzID0gcG9pbnRzO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdGNvbnN0IHAgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xuXG5cdFx0Y29uc3QgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwICk7XG5cdFx0Y29uc3Qgd2VpZ2h0ID0gcCAtIGludFBvaW50O1xuXG5cdFx0Y29uc3QgcDAgPSBwb2ludHNbIGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDEgXTtcblx0XHRjb25zdCBwMSA9IHBvaW50c1sgaW50UG9pbnQgXTtcblx0XHRjb25zdCBwMiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XG5cdFx0Y29uc3QgcDMgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMiBdO1xuXG5cdFx0cG9pbnQuc2V0KFxuXHRcdFx0Q2F0bXVsbFJvbSggd2VpZ2h0LCBwMC54LCBwMS54LCBwMi54LCBwMy54ICksXG5cdFx0XHRDYXRtdWxsUm9tKCB3ZWlnaHQsIHAwLnksIHAxLnksIHAyLnksIHAzLnkgKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNvdXJjZS5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSBzb3VyY2UucG9pbnRzWyBpIF07XG5cblx0XHRcdHRoaXMucG9pbnRzLnB1c2goIHBvaW50LmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSB0aGlzLnBvaW50c1sgaSBdO1xuXHRcdFx0ZGF0YS5wb2ludHMucHVzaCggcG9pbnQudG9BcnJheSgpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xuXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGpzb24ucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHBvaW50ID0ganNvbi5wb2ludHNbIGkgXTtcblx0XHRcdHRoaXMucG9pbnRzLnB1c2goIG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KCBwb2ludCApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxudmFyIEN1cnZlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRBcmNDdXJ2ZTogQXJjQ3VydmUsXG5cdENhdG11bGxSb21DdXJ2ZTM6IENhdG11bGxSb21DdXJ2ZTMsXG5cdEN1YmljQmV6aWVyQ3VydmU6IEN1YmljQmV6aWVyQ3VydmUsXG5cdEN1YmljQmV6aWVyQ3VydmUzOiBDdWJpY0JlemllckN1cnZlMyxcblx0RWxsaXBzZUN1cnZlOiBFbGxpcHNlQ3VydmUsXG5cdExpbmVDdXJ2ZTogTGluZUN1cnZlLFxuXHRMaW5lQ3VydmUzOiBMaW5lQ3VydmUzLFxuXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZTogUXVhZHJhdGljQmV6aWVyQ3VydmUsXG5cdFF1YWRyYXRpY0JlemllckN1cnZlMzogUXVhZHJhdGljQmV6aWVyQ3VydmUzLFxuXHRTcGxpbmVDdXJ2ZTogU3BsaW5lQ3VydmVcbn0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRDdXJ2ZWQgUGF0aCAtIGEgY3VydmUgcGF0aCBpcyBzaW1wbHkgYSBhcnJheSBvZiBjb25uZWN0ZWRcbiAqICBjdXJ2ZXMsIGJ1dCByZXRhaW5zIHRoZSBhcGkgb2YgYSBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5jbGFzcyBDdXJ2ZVBhdGggZXh0ZW5kcyBDdXJ2ZSB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ0N1cnZlUGF0aCc7XG5cblx0XHR0aGlzLmN1cnZlcyA9IFtdO1xuXHRcdHRoaXMuYXV0b0Nsb3NlID0gZmFsc2U7IC8vIEF1dG9tYXRpY2FsbHkgY2xvc2VzIHRoZSBwYXRoXG5cblx0fVxuXG5cdGFkZCggY3VydmUgKSB7XG5cblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdH1cblxuXHRjbG9zZVBhdGgoKSB7XG5cblx0XHQvLyBBZGQgYSBsaW5lIGN1cnZlIGlmIHN0YXJ0IGFuZCBlbmQgb2YgbGluZXMgYXJlIG5vdCBjb25uZWN0ZWRcblx0XHRjb25zdCBzdGFydFBvaW50ID0gdGhpcy5jdXJ2ZXNbIDAgXS5nZXRQb2ludCggMCApO1xuXHRcdGNvbnN0IGVuZFBvaW50ID0gdGhpcy5jdXJ2ZXNbIHRoaXMuY3VydmVzLmxlbmd0aCAtIDEgXS5nZXRQb2ludCggMSApO1xuXG5cdFx0aWYgKCAhIHN0YXJ0UG9pbnQuZXF1YWxzKCBlbmRQb2ludCApICkge1xuXG5cdFx0XHRjb25zdCBsaW5lVHlwZSA9ICggc3RhcnRQb2ludC5pc1ZlY3RvcjIgPT09IHRydWUgKSA/ICdMaW5lQ3VydmUnIDogJ0xpbmVDdXJ2ZTMnO1xuXHRcdFx0dGhpcy5jdXJ2ZXMucHVzaCggbmV3IEN1cnZlc1sgbGluZVR5cGUgXSggZW5kUG9pbnQsIHN0YXJ0UG9pbnQgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vIFRvIGdldCBhY2N1cmF0ZSBwb2ludCB3aXRoIHJlZmVyZW5jZSB0b1xuXHQvLyBlbnRpcmUgcGF0aCBkaXN0YW5jZSBhdCB0aW1lIHQsXG5cdC8vIGZvbGxvd2luZyBoYXMgdG8gYmUgZG9uZTpcblxuXHQvLyAxLiBMZW5ndGggb2YgZWFjaCBzdWIgcGF0aCBoYXZlIHRvIGJlIGtub3duXG5cdC8vIDIuIExvY2F0ZSBhbmQgaWRlbnRpZnkgdHlwZSBvZiBjdXJ2ZVxuXHQvLyAzLiBHZXQgdCBmb3IgdGhlIGN1cnZlXG5cdC8vIDQuIFJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KHQnKVxuXG5cdGdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdGNvbnN0IGQgPSB0ICogdGhpcy5nZXRMZW5ndGgoKTtcblx0XHRjb25zdCBjdXJ2ZUxlbmd0aHMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXHRcdGxldCBpID0gMDtcblxuXHRcdC8vIFRvIHRoaW5rIGFib3V0IGJvdW5kYXJpZXMgcG9pbnRzLlxuXG5cdFx0d2hpbGUgKCBpIDwgY3VydmVMZW5ndGhzLmxlbmd0aCApIHtcblxuXHRcdFx0aWYgKCBjdXJ2ZUxlbmd0aHNbIGkgXSA+PSBkICkge1xuXG5cdFx0XHRcdGNvbnN0IGRpZmYgPSBjdXJ2ZUxlbmd0aHNbIGkgXSAtIGQ7XG5cdFx0XHRcdGNvbnN0IGN1cnZlID0gdGhpcy5jdXJ2ZXNbIGkgXTtcblxuXHRcdFx0XHRjb25zdCBzZWdtZW50TGVuZ3RoID0gY3VydmUuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRcdGNvbnN0IHUgPSBzZWdtZW50TGVuZ3RoID09PSAwID8gMCA6IDEgLSBkaWZmIC8gc2VnbWVudExlbmd0aDtcblxuXHRcdFx0XHRyZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpICsrO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0XHQvLyBsb29wIHdoZXJlIHN1bSAhPSAwLCBzdW0gPiBkICwgc3VtKzEgPGRcblxuXHR9XG5cblx0Ly8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxuXHQvLyBUSFJFRS5DdXJ2ZSwgZ2V0TGVuZ3RoKCkgZGVwZW5kcyBvbiBnZXRQb2ludCgpIGJ1dCBpbiBUSFJFRS5DdXJ2ZVBhdGhcblx0Ly8gZ2V0UG9pbnQoKSBkZXBlbmRzIG9uIGdldExlbmd0aFxuXG5cdGdldExlbmd0aCgpIHtcblxuXHRcdGNvbnN0IGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXHRcdHJldHVybiBsZW5zWyBsZW5zLmxlbmd0aCAtIDEgXTtcblxuXHR9XG5cblx0Ly8gY2FjaGVMZW5ndGhzIG11c3QgYmUgcmVjYWxjdWxhdGVkLlxuXHR1cGRhdGVBcmNMZW5ndGhzKCkge1xuXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBudWxsO1xuXHRcdHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XG5cblx0fVxuXG5cdC8vIENvbXB1dGUgbGVuZ3RocyBhbmQgY2FjaGUgdGhlbVxuXHQvLyBXZSBjYW5ub3Qgb3ZlcndyaXRlIGdldExlbmd0aHMoKSBiZWNhdXNlIFV0b1QgbWFwcGluZyB1c2VzIGl0LlxuXG5cdGdldEN1cnZlTGVuZ3RocygpIHtcblxuXHRcdC8vIFdlIHVzZSBjYWNoZSB2YWx1ZXMgaWYgY3VydmVzIGFuZCBjYWNoZSBhcnJheSBhcmUgc2FtZSBsZW5ndGhcblxuXHRcdGlmICggdGhpcy5jYWNoZUxlbmd0aHMgJiYgdGhpcy5jYWNoZUxlbmd0aHMubGVuZ3RoID09PSB0aGlzLmN1cnZlcy5sZW5ndGggKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmNhY2hlTGVuZ3RocztcblxuXHRcdH1cblxuXHRcdC8vIEdldCBsZW5ndGggb2Ygc3ViLWN1cnZlXG5cdFx0Ly8gUHVzaCBzdW1zIGludG8gY2FjaGVkIGFycmF5XG5cblx0XHRjb25zdCBsZW5ndGhzID0gW107XG5cdFx0bGV0IHN1bXMgPSAwO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0c3VtcyArPSB0aGlzLmN1cnZlc1sgaSBdLmdldExlbmd0aCgpO1xuXHRcdFx0bGVuZ3Rocy5wdXNoKCBzdW1zICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmNhY2hlTGVuZ3RocyA9IGxlbmd0aHM7XG5cblx0XHRyZXR1cm4gbGVuZ3RocztcblxuXHR9XG5cblx0Z2V0U3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMgPSA0MCApIHtcblxuXHRcdGNvbnN0IHBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IGRpdmlzaW9uczsgaSArKyApIHtcblxuXHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmF1dG9DbG9zZSApIHtcblxuXHRcdFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnRzO1xuXG5cdH1cblxuXHRnZXRQb2ludHMoIGRpdmlzaW9ucyA9IDEyICkge1xuXG5cdFx0Y29uc3QgcG9pbnRzID0gW107XG5cdFx0bGV0IGxhc3Q7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGN1cnZlcyA9IHRoaXMuY3VydmVzOyBpIDwgY3VydmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY3VydmUgPSBjdXJ2ZXNbIGkgXTtcblx0XHRcdGNvbnN0IHJlc29sdXRpb24gPSBjdXJ2ZS5pc0VsbGlwc2VDdXJ2ZSA/IGRpdmlzaW9ucyAqIDJcblx0XHRcdFx0OiAoIGN1cnZlLmlzTGluZUN1cnZlIHx8IGN1cnZlLmlzTGluZUN1cnZlMyApID8gMVxuXHRcdFx0XHRcdDogY3VydmUuaXNTcGxpbmVDdXJ2ZSA/IGRpdmlzaW9ucyAqIGN1cnZlLnBvaW50cy5sZW5ndGhcblx0XHRcdFx0XHRcdDogZGl2aXNpb25zO1xuXG5cdFx0XHRjb25zdCBwdHMgPSBjdXJ2ZS5nZXRQb2ludHMoIHJlc29sdXRpb24gKTtcblxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgcHRzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRjb25zdCBwb2ludCA9IHB0c1sgaiBdO1xuXG5cdFx0XHRcdGlmICggbGFzdCAmJiBsYXN0LmVxdWFscyggcG9pbnQgKSApIGNvbnRpbnVlOyAvLyBlbnN1cmVzIG5vIGNvbnNlY3V0aXZlIHBvaW50cyBhcmUgZHVwbGljYXRlc1xuXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBwb2ludCApO1xuXHRcdFx0XHRsYXN0ID0gcG9pbnQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hdXRvQ2xvc2UgJiYgcG9pbnRzLmxlbmd0aCA+IDEgJiYgISBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF0uZXF1YWxzKCBwb2ludHNbIDAgXSApICkge1xuXG5cdFx0XHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwb2ludHM7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jdXJ2ZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNvdXJjZS5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY3VydmUgPSBzb3VyY2UuY3VydmVzWyBpIF07XG5cblx0XHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXV0b0Nsb3NlID0gc291cmNlLmF1dG9DbG9zZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLmF1dG9DbG9zZSA9IHRoaXMuYXV0b0Nsb3NlO1xuXHRcdGRhdGEuY3VydmVzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBjdXJ2ZSA9IHRoaXMuY3VydmVzWyBpIF07XG5cdFx0XHRkYXRhLmN1cnZlcy5wdXNoKCBjdXJ2ZS50b0pTT04oKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMuYXV0b0Nsb3NlID0ganNvbi5hdXRvQ2xvc2U7XG5cdFx0dGhpcy5jdXJ2ZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGpzb24uY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGN1cnZlID0ganNvbi5jdXJ2ZXNbIGkgXTtcblx0XHRcdHRoaXMuY3VydmVzLnB1c2goIG5ldyBDdXJ2ZXNbIGN1cnZlLnR5cGUgXSgpLmZyb21KU09OKCBjdXJ2ZSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY2xhc3MgUGF0aCBleHRlbmRzIEN1cnZlUGF0aCB7XG5cblx0Y29uc3RydWN0b3IoIHBvaW50cyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnUGF0aCc7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludCA9IG5ldyBWZWN0b3IyKCk7XG5cblx0XHRpZiAoIHBvaW50cyApIHtcblxuXHRcdFx0dGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0c2V0RnJvbVBvaW50cyggcG9pbnRzICkge1xuXG5cdFx0dGhpcy5tb3ZlVG8oIHBvaW50c1sgMCBdLngsIHBvaW50c1sgMCBdLnkgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMSwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmxpbmVUbyggcG9pbnRzWyBpIF0ueCwgcG9pbnRzWyBpIF0ueSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1vdmVUbyggeCwgeSApIHtcblxuXHRcdHRoaXMuY3VycmVudFBvaW50LnNldCggeCwgeSApOyAvLyBUT0RPIGNvbnNpZGVyIHJlZmVyZW5jaW5nIHZlY3RvcnMgaW5zdGVhZCBvZiBjb3B5aW5nP1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGxpbmVUbyggeCwgeSApIHtcblxuXHRcdGNvbnN0IGN1cnZlID0gbmV3IExpbmVDdXJ2ZSggdGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSwgbmV3IFZlY3RvcjIoIHgsIHkgKSApO1xuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIHgsIHkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRxdWFkcmF0aWNDdXJ2ZVRvKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKSB7XG5cblx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBRdWFkcmF0aWNCZXppZXJDdXJ2ZShcblx0XHRcdHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksXG5cdFx0XHRuZXcgVmVjdG9yMiggYUNQeCwgYUNQeSApLFxuXHRcdFx0bmV3IFZlY3RvcjIoIGFYLCBhWSApXG5cdFx0KTtcblxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIGFYLCBhWSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGJlemllckN1cnZlVG8oIGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkgKSB7XG5cblx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBDdWJpY0JlemllckN1cnZlKFxuXHRcdFx0dGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSxcblx0XHRcdG5ldyBWZWN0b3IyKCBhQ1AxeCwgYUNQMXkgKSxcblx0XHRcdG5ldyBWZWN0b3IyKCBhQ1AyeCwgYUNQMnkgKSxcblx0XHRcdG5ldyBWZWN0b3IyKCBhWCwgYVkgKVxuXHRcdCk7XG5cblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCBhWCwgYVkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzcGxpbmVUaHJ1KCBwdHMgLypBcnJheSBvZiBWZWN0b3IqLyApIHtcblxuXHRcdGNvbnN0IG5wdHMgPSBbIHRoaXMuY3VycmVudFBvaW50LmNsb25lKCkgXS5jb25jYXQoIHB0cyApO1xuXG5cdFx0Y29uc3QgY3VydmUgPSBuZXcgU3BsaW5lQ3VydmUoIG5wdHMgKTtcblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuY29weSggcHRzWyBwdHMubGVuZ3RoIC0gMSBdICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXJjKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cblx0XHRjb25zdCB4MCA9IHRoaXMuY3VycmVudFBvaW50Lng7XG5cdFx0Y29uc3QgeTAgPSB0aGlzLmN1cnJlbnRQb2ludC55O1xuXG5cdFx0dGhpcy5hYnNhcmMoIGFYICsgeDAsIGFZICsgeTAsIGFSYWRpdXMsXG5cdFx0XHRhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWJzYXJjKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cblx0XHR0aGlzLmFic2VsbGlwc2UoIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVsbGlwc2UoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xuXG5cdFx0Y29uc3QgeDAgPSB0aGlzLmN1cnJlbnRQb2ludC54O1xuXHRcdGNvbnN0IHkwID0gdGhpcy5jdXJyZW50UG9pbnQueTtcblxuXHRcdHRoaXMuYWJzZWxsaXBzZSggYVggKyB4MCwgYVkgKyB5MCwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWJzZWxsaXBzZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XG5cblx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBFbGxpcHNlQ3VydmUoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICk7XG5cblx0XHRpZiAoIHRoaXMuY3VydmVzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdC8vIGlmIGEgcHJldmlvdXMgY3VydmUgaXMgcHJlc2VudCwgYXR0ZW1wdCB0byBqb2luXG5cdFx0XHRjb25zdCBmaXJzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoIDAgKTtcblxuXHRcdFx0aWYgKCAhIGZpcnN0UG9pbnQuZXF1YWxzKCB0aGlzLmN1cnJlbnRQb2ludCApICkge1xuXG5cdFx0XHRcdHRoaXMubGluZVRvKCBmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdFx0Y29uc3QgbGFzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoIDEgKTtcblx0XHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KCBsYXN0UG9pbnQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuY3VycmVudFBvaW50LmNvcHkoIHNvdXJjZS5jdXJyZW50UG9pbnQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLmN1cnJlbnRQb2ludCA9IHRoaXMuY3VycmVudFBvaW50LnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludC5mcm9tQXJyYXkoIGpzb24uY3VycmVudFBvaW50ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY2xhc3MgTGF0aGVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcG9pbnRzID0gWyBuZXcgVmVjdG9yMiggMCwgLSAwLjUgKSwgbmV3IFZlY3RvcjIoIDAuNSwgMCApLCBuZXcgVmVjdG9yMiggMCwgMC41ICkgXSwgc2VnbWVudHMgPSAxMiwgcGhpU3RhcnQgPSAwLCBwaGlMZW5ndGggPSBNYXRoLlBJICogMiApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnTGF0aGVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRwb2ludHM6IHBvaW50cyxcblx0XHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcblx0XHRcdHBoaVN0YXJ0OiBwaGlTdGFydCxcblx0XHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoXG5cdFx0fTtcblxuXHRcdHNlZ21lbnRzID0gTWF0aC5mbG9vciggc2VnbWVudHMgKTtcblxuXHRcdC8vIGNsYW1wIHBoaUxlbmd0aCBzbyBpdCdzIGluIHJhbmdlIG9mIFsgMCwgMlBJIF1cblxuXHRcdHBoaUxlbmd0aCA9IGNsYW1wKCBwaGlMZW5ndGgsIDAsIE1hdGguUEkgKiAyICk7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblx0XHRjb25zdCBpbml0Tm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGNvbnN0IGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgY3VyTm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBwcmV2Tm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRsZXQgZHggPSAwO1xuXHRcdGxldCBkeSA9IDA7XG5cblx0XHQvLyBwcmUtY29tcHV0ZSBub3JtYWxzIGZvciBpbml0aWFsIFwibWVyaWRpYW5cIlxuXG5cdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcblxuXHRcdFx0c3dpdGNoICggaiApIHtcblxuXHRcdFx0XHRjYXNlIDA6XHRcdFx0XHQvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciAxc3QgdmVydGV4IG9uIHBhdGhcblxuXHRcdFx0XHRcdGR4ID0gcG9pbnRzWyBqICsgMSBdLnggLSBwb2ludHNbIGogXS54O1xuXHRcdFx0XHRcdGR5ID0gcG9pbnRzWyBqICsgMSBdLnkgLSBwb2ludHNbIGogXS55O1xuXG5cdFx0XHRcdFx0bm9ybWFsLnggPSBkeSAqIDEuMDtcblx0XHRcdFx0XHRub3JtYWwueSA9IC0gZHg7XG5cdFx0XHRcdFx0bm9ybWFsLnogPSBkeSAqIDAuMDtcblxuXHRcdFx0XHRcdHByZXZOb3JtYWwuY29weSggbm9ybWFsICk7XG5cblx0XHRcdFx0XHRub3JtYWwubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0XHRpbml0Tm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICggcG9pbnRzLmxlbmd0aCAtIDEgKTpcdC8vIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGxhc3QgVmVydGV4IG9uIHBhdGhcblxuXHRcdFx0XHRcdGluaXROb3JtYWxzLnB1c2goIHByZXZOb3JtYWwueCwgcHJldk5vcm1hbC55LCBwcmV2Tm9ybWFsLnogKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XHRcdFx0Ly8gZGVmYXVsdCBoYW5kbGluZyBmb3IgYWxsIHZlcnRpY2VzIGluIGJldHdlZW5cblxuXHRcdFx0XHRcdGR4ID0gcG9pbnRzWyBqICsgMSBdLnggLSBwb2ludHNbIGogXS54O1xuXHRcdFx0XHRcdGR5ID0gcG9pbnRzWyBqICsgMSBdLnkgLSBwb2ludHNbIGogXS55O1xuXG5cdFx0XHRcdFx0bm9ybWFsLnggPSBkeSAqIDEuMDtcblx0XHRcdFx0XHRub3JtYWwueSA9IC0gZHg7XG5cdFx0XHRcdFx0bm9ybWFsLnogPSBkeSAqIDAuMDtcblxuXHRcdFx0XHRcdGN1ck5vcm1hbC5jb3B5KCBub3JtYWwgKTtcblxuXHRcdFx0XHRcdG5vcm1hbC54ICs9IHByZXZOb3JtYWwueDtcblx0XHRcdFx0XHRub3JtYWwueSArPSBwcmV2Tm9ybWFsLnk7XG5cdFx0XHRcdFx0bm9ybWFsLnogKz0gcHJldk5vcm1hbC56O1xuXG5cdFx0XHRcdFx0bm9ybWFsLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdFx0aW5pdE5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdFx0cHJldk5vcm1hbC5jb3B5KCBjdXJOb3JtYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIHV2cyBhbmQgbm9ybWFsc1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBwaGkgPSBwaGlTdGFydCArIGkgKiBpbnZlcnNlU2VnbWVudHMgKiBwaGlMZW5ndGg7XG5cblx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc2luKCBwaGkgKTtcblx0XHRcdGNvbnN0IGNvcyA9IE1hdGguY29zKCBwaGkgKTtcblxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHBvaW50c1sgaiBdLnggKiBzaW47XG5cdFx0XHRcdHZlcnRleC55ID0gcG9pbnRzWyBqIF0ueTtcblx0XHRcdFx0dmVydGV4LnogPSBwb2ludHNbIGogXS54ICogY29zO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHQvLyB1dlxuXG5cdFx0XHRcdHV2LnggPSBpIC8gc2VnbWVudHM7XG5cdFx0XHRcdHV2LnkgPSBqIC8gKCBwb2ludHMubGVuZ3RoIC0gMSApO1xuXG5cdFx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0Y29uc3QgeCA9IGluaXROb3JtYWxzWyAzICogaiArIDAgXSAqIHNpbjtcblx0XHRcdFx0Y29uc3QgeSA9IGluaXROb3JtYWxzWyAzICogaiArIDEgXTtcblx0XHRcdFx0Y29uc3QgeiA9IGluaXROb3JtYWxzWyAzICogaiArIDAgXSAqIGNvcztcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goIHgsIHksIHogKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gaW5kaWNlc1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgc2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcblxuXHRcdFx0XHRjb25zdCBiYXNlID0gaiArIGkgKiBwb2ludHMubGVuZ3RoO1xuXG5cdFx0XHRcdGNvbnN0IGEgPSBiYXNlO1xuXHRcdFx0XHRjb25zdCBiID0gYmFzZSArIHBvaW50cy5sZW5ndGg7XG5cdFx0XHRcdGNvbnN0IGMgPSBiYXNlICsgcG9pbnRzLmxlbmd0aCArIDE7XG5cdFx0XHRcdGNvbnN0IGQgPSBiYXNlICsgMTtcblxuXHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGMsIGQsIGIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBMYXRoZUdlb21ldHJ5KCBkYXRhLnBvaW50cywgZGF0YS5zZWdtZW50cywgZGF0YS5waGlTdGFydCwgZGF0YS5waGlMZW5ndGggKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgQ2Fwc3VsZUdlb21ldHJ5IGV4dGVuZHMgTGF0aGVHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIGxlbmd0aCA9IDEsIGNhcFNlZ21lbnRzID0gNCwgcmFkaWFsU2VnbWVudHMgPSA4ICkge1xuXG5cdFx0Y29uc3QgcGF0aCA9IG5ldyBQYXRoKCk7XG5cdFx0cGF0aC5hYnNhcmMoIDAsIC0gbGVuZ3RoIC8gMiwgcmFkaXVzLCBNYXRoLlBJICogMS41LCAwICk7XG5cdFx0cGF0aC5hYnNhcmMoIDAsIGxlbmd0aCAvIDIsIHJhZGl1cywgMCwgTWF0aC5QSSAqIDAuNSApO1xuXG5cdFx0c3VwZXIoIHBhdGguZ2V0UG9pbnRzKCBjYXBTZWdtZW50cyApLCByYWRpYWxTZWdtZW50cyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0NhcHN1bGVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdGxlbmd0aDogbGVuZ3RoLFxuXHRcdFx0Y2FwU2VnbWVudHM6IGNhcFNlZ21lbnRzLFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdH07XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgQ2Fwc3VsZUdlb21ldHJ5KCBkYXRhLnJhZGl1cywgZGF0YS5sZW5ndGgsIGRhdGEuY2FwU2VnbWVudHMsIGRhdGEucmFkaWFsU2VnbWVudHMgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgQ2lyY2xlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIHNlZ21lbnRzID0gMzIsIHRoZXRhU3RhcnQgPSAwLCB0aGV0YUxlbmd0aCA9IE1hdGguUEkgKiAyICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDaXJjbGVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcblx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0XHR9O1xuXG5cdFx0c2VnbWVudHMgPSBNYXRoLm1heCggMywgc2VnbWVudHMgKTtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0Ly8gY2VudGVyIHBvaW50XG5cblx0XHR2ZXJ0aWNlcy5wdXNoKCAwLCAwLCAwICk7XG5cdFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XG5cdFx0dXZzLnB1c2goIDAuNSwgMC41ICk7XG5cblx0XHRmb3IgKCBsZXQgcyA9IDAsIGkgPSAzOyBzIDw9IHNlZ21lbnRzOyBzICsrLCBpICs9IDMgKSB7XG5cblx0XHRcdGNvbnN0IHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgcyAvIHNlZ21lbnRzICogdGhldGFMZW5ndGg7XG5cblx0XHRcdC8vIHZlcnRleFxuXG5cdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XG5cdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XG5cblx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xuXG5cdFx0XHQvLyB1dnNcblxuXHRcdFx0dXYueCA9ICggdmVydGljZXNbIGkgXSAvIHJhZGl1cyArIDEgKSAvIDI7XG5cdFx0XHR1di55ID0gKCB2ZXJ0aWNlc1sgaSArIDEgXSAvIHJhZGl1cyArIDEgKSAvIDI7XG5cblx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cblx0XHR9XG5cblx0XHQvLyBpbmRpY2VzXG5cblx0XHRmb3IgKCBsZXQgaSA9IDE7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdGluZGljZXMucHVzaCggaSwgaSArIDEsIDAgKTtcblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgQ2lyY2xlR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLnNlZ21lbnRzLCBkYXRhLnRoZXRhU3RhcnQsIGRhdGEudGhldGFMZW5ndGggKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgQ3lsaW5kZXJHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcmFkaXVzVG9wID0gMSwgcmFkaXVzQm90dG9tID0gMSwgaGVpZ2h0ID0gMSwgcmFkaWFsU2VnbWVudHMgPSAzMiwgaGVpZ2h0U2VnbWVudHMgPSAxLCBvcGVuRW5kZWQgPSBmYWxzZSwgdGhldGFTdGFydCA9IDAsIHRoZXRhTGVuZ3RoID0gTWF0aC5QSSAqIDIgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ0N5bGluZGVyR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzVG9wOiByYWRpdXNUb3AsXG5cdFx0XHRyYWRpdXNCb3R0b206IHJhZGl1c0JvdHRvbSxcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0b3BlbkVuZGVkOiBvcGVuRW5kZWQsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vciggcmFkaWFsU2VnbWVudHMgKTtcblx0XHRoZWlnaHRTZWdtZW50cyA9IE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICk7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdGNvbnN0IGluZGV4QXJyYXkgPSBbXTtcblx0XHRjb25zdCBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcblx0XHRsZXQgZ3JvdXBTdGFydCA9IDA7XG5cblx0XHQvLyBnZW5lcmF0ZSBnZW9tZXRyeVxuXG5cdFx0Z2VuZXJhdGVUb3JzbygpO1xuXG5cdFx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRpZiAoIHJhZGl1c1RvcCA+IDAgKSBnZW5lcmF0ZUNhcCggdHJ1ZSApO1xuXHRcdFx0aWYgKCByYWRpdXNCb3R0b20gPiAwICkgZ2VuZXJhdGVDYXAoIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlVG9yc28oKSB7XG5cblx0XHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRsZXQgZ3JvdXBDb3VudCA9IDA7XG5cblx0XHRcdC8vIHRoaXMgd2lsbCBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgbm9ybWFsXG5cdFx0XHRjb25zdCBzbG9wZSA9ICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgLyBoZWlnaHQ7XG5cblx0XHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdFx0Zm9yICggbGV0IHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGluZGV4Um93ID0gW107XG5cblx0XHRcdFx0Y29uc3QgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcblxuXHRcdFx0XHQvLyBjYWxjdWxhdGUgdGhlIHJhZGl1cyBvZiB0aGUgY3VycmVudCByb3dcblxuXHRcdFx0XHRjb25zdCByYWRpdXMgPSB2ICogKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSArIHJhZGl1c1RvcDtcblxuXHRcdFx0XHRmb3IgKCBsZXQgeCA9IDA7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB1ID0geCAvIHJhZGlhbFNlZ21lbnRzO1xuXG5cdFx0XHRcdFx0Y29uc3QgdGhldGEgPSB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0O1xuXG5cdFx0XHRcdFx0Y29uc3Qgc2luVGhldGEgPSBNYXRoLnNpbiggdGhldGEgKTtcblx0XHRcdFx0XHRjb25zdCBjb3NUaGV0YSA9IE1hdGguY29zKCB0aGV0YSApO1xuXG5cdFx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIHNpblRoZXRhO1xuXHRcdFx0XHRcdHZlcnRleC55ID0gLSB2ICogaGVpZ2h0ICsgaGFsZkhlaWdodDtcblx0XHRcdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIGNvc1RoZXRhO1xuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdFx0bm9ybWFsLnNldCggc2luVGhldGEsIHNsb3BlLCBjb3NUaGV0YSApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdFx0Ly8gdXZcblxuXHRcdFx0XHRcdHV2cy5wdXNoKCB1LCAxIC0gdiApO1xuXG5cdFx0XHRcdFx0Ly8gc2F2ZSBpbmRleCBvZiB2ZXJ0ZXggaW4gcmVzcGVjdGl2ZSByb3dcblxuXHRcdFx0XHRcdGluZGV4Um93LnB1c2goIGluZGV4ICsrICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG5vdyBzYXZlIHZlcnRpY2VzIG9mIHRoZSByb3cgaW4gb3VyIGluZGV4IGFycmF5XG5cblx0XHRcdFx0aW5kZXhBcnJheS5wdXNoKCBpbmRleFJvdyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdlbmVyYXRlIGluZGljZXNcblxuXHRcdFx0Zm9yICggbGV0IHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IHkgPSAwOyB5IDwgaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cblx0XHRcdFx0XHQvLyB3ZSB1c2UgdGhlIGluZGV4IGFycmF5IHRvIGFjY2VzcyB0aGUgY29ycmVjdCBpbmRpY2VzXG5cblx0XHRcdFx0XHRjb25zdCBhID0gaW5kZXhBcnJheVsgeSBdWyB4IF07XG5cdFx0XHRcdFx0Y29uc3QgYiA9IGluZGV4QXJyYXlbIHkgKyAxIF1bIHggXTtcblx0XHRcdFx0XHRjb25zdCBjID0gaW5kZXhBcnJheVsgeSArIDEgXVsgeCArIDEgXTtcblx0XHRcdFx0XHRjb25zdCBkID0gaW5kZXhBcnJheVsgeSBdWyB4ICsgMSBdO1xuXG5cdFx0XHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0XHRcdGlmICggcmFkaXVzVG9wID4gMCB8fCB5ICE9PSAwICkge1xuXG5cdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdFx0XHRcdGdyb3VwQ291bnQgKz0gMztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggcmFkaXVzQm90dG9tID4gMCB8fCB5ICE9PSBoZWlnaHRTZWdtZW50cyAtIDEgKSB7XG5cblx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXHRcdFx0XHRcdFx0Z3JvdXBDb3VudCArPSAzO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBhZGQgYSBncm91cCB0byB0aGUgZ2VvbWV0cnkuIHRoaXMgd2lsbCBlbnN1cmUgbXVsdGkgbWF0ZXJpYWwgc3VwcG9ydFxuXG5cdFx0XHRzY29wZS5hZGRHcm91cCggZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgMCApO1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IHZhbHVlIGZvciBncm91cHNcblxuXHRcdFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVDYXAoIHRvcCApIHtcblxuXHRcdFx0Ly8gc2F2ZSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNlbnRlciB2ZXJ0ZXhcblx0XHRcdGNvbnN0IGNlbnRlckluZGV4U3RhcnQgPSBpbmRleDtcblxuXHRcdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0bGV0IGdyb3VwQ291bnQgPSAwO1xuXG5cdFx0XHRjb25zdCByYWRpdXMgPSAoIHRvcCA9PT0gdHJ1ZSApID8gcmFkaXVzVG9wIDogcmFkaXVzQm90dG9tO1xuXHRcdFx0Y29uc3Qgc2lnbiA9ICggdG9wID09PSB0cnVlICkgPyAxIDogLSAxO1xuXG5cdFx0XHQvLyBmaXJzdCB3ZSBnZW5lcmF0ZSB0aGUgY2VudGVyIHZlcnRleCBkYXRhIG9mIHRoZSBjYXAuXG5cdFx0XHQvLyBiZWNhdXNlIHRoZSBnZW9tZXRyeSBuZWVkcyBvbmUgc2V0IG9mIHV2cyBwZXIgZmFjZSxcblx0XHRcdC8vIHdlIG11c3QgZ2VuZXJhdGUgYSBjZW50ZXIgdmVydGV4IHBlciBmYWNlL3NlZ21lbnRcblxuXHRcdFx0Zm9yICggbGV0IHggPSAxOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG5cdFx0XHRcdC8vIHZlcnRleFxuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIDAsIGhhbGZIZWlnaHQgKiBzaWduLCAwICk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKCAwLCBzaWduLCAwICk7XG5cblx0XHRcdFx0Ly8gdXZcblxuXHRcdFx0XHR1dnMucHVzaCggMC41LCAwLjUgKTtcblxuXHRcdFx0XHQvLyBpbmNyZWFzZSBpbmRleFxuXG5cdFx0XHRcdGluZGV4ICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHNhdmUgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGNlbnRlciB2ZXJ0ZXhcblx0XHRcdGNvbnN0IGNlbnRlckluZGV4RW5kID0gaW5kZXg7XG5cblx0XHRcdC8vIG5vdyB3ZSBnZW5lcmF0ZSB0aGUgc3Vycm91bmRpbmcgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0XHRmb3IgKCBsZXQgeCA9IDA7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdSA9IHggLyByYWRpYWxTZWdtZW50cztcblx0XHRcdFx0Y29uc3QgdGhldGEgPSB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0O1xuXG5cdFx0XHRcdGNvbnN0IGNvc1RoZXRhID0gTWF0aC5jb3MoIHRoZXRhICk7XG5cdFx0XHRcdGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBzaW5UaGV0YTtcblx0XHRcdFx0dmVydGV4LnkgPSBoYWxmSGVpZ2h0ICogc2lnbjtcblx0XHRcdFx0dmVydGV4LnogPSByYWRpdXMgKiBjb3NUaGV0YTtcblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggMCwgc2lnbiwgMCApO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXYueCA9ICggY29zVGhldGEgKiAwLjUgKSArIDAuNTtcblx0XHRcdFx0dXYueSA9ICggc2luVGhldGEgKiAwLjUgKiBzaWduICkgKyAwLjU7XG5cdFx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cblx0XHRcdFx0Ly8gaW5jcmVhc2UgaW5kZXhcblxuXHRcdFx0XHRpbmRleCArKztcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cblx0XHRcdGZvciAoIGxldCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGMgPSBjZW50ZXJJbmRleFN0YXJ0ICsgeDtcblx0XHRcdFx0Y29uc3QgaSA9IGNlbnRlckluZGV4RW5kICsgeDtcblxuXHRcdFx0XHRpZiAoIHRvcCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIGZhY2UgdG9wXG5cblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGksIGkgKyAxLCBjICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGZhY2UgYm90dG9tXG5cblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGkgKyAxLCBpLCBjICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdyb3VwQ291bnQgKz0gMztcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBhZGQgYSBncm91cCB0byB0aGUgZ2VvbWV0cnkuIHRoaXMgd2lsbCBlbnN1cmUgbXVsdGkgbWF0ZXJpYWwgc3VwcG9ydFxuXG5cdFx0XHRzY29wZS5hZGRHcm91cCggZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgdG9wID09PSB0cnVlID8gMSA6IDIgKTtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXG5cblx0XHRcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IEN5bGluZGVyR2VvbWV0cnkoIGRhdGEucmFkaXVzVG9wLCBkYXRhLnJhZGl1c0JvdHRvbSwgZGF0YS5oZWlnaHQsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMsIGRhdGEub3BlbkVuZGVkLCBkYXRhLnRoZXRhU3RhcnQsIGRhdGEudGhldGFMZW5ndGggKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgQ29uZUdlb21ldHJ5IGV4dGVuZHMgQ3lsaW5kZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIGhlaWdodCA9IDEsIHJhZGlhbFNlZ21lbnRzID0gMzIsIGhlaWdodFNlZ21lbnRzID0gMSwgb3BlbkVuZGVkID0gZmFsc2UsIHRoZXRhU3RhcnQgPSAwLCB0aGV0YUxlbmd0aCA9IE1hdGguUEkgKiAyICkge1xuXG5cdFx0c3VwZXIoIDAsIHJhZGl1cywgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDb25lR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRcdG9wZW5FbmRlZDogb3BlbkVuZGVkLFxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHRcdH07XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgQ29uZUdlb21ldHJ5KCBkYXRhLnJhZGl1cywgZGF0YS5oZWlnaHQsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMsIGRhdGEub3BlbkVuZGVkLCBkYXRhLnRoZXRhU3RhcnQsIGRhdGEudGhldGFMZW5ndGggKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgUG9seWhlZHJvbkdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCB2ZXJ0aWNlcyA9IFtdLCBpbmRpY2VzID0gW10sIHJhZGl1cyA9IDEsIGRldGFpbCA9IDAgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BvbHloZWRyb25HZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHR2ZXJ0aWNlczogdmVydGljZXMsXG5cdFx0XHRpbmRpY2VzOiBpbmRpY2VzLFxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdH07XG5cblx0XHQvLyBkZWZhdWx0IGJ1ZmZlciBkYXRhXG5cblx0XHRjb25zdCB2ZXJ0ZXhCdWZmZXIgPSBbXTtcblx0XHRjb25zdCB1dkJ1ZmZlciA9IFtdO1xuXG5cdFx0Ly8gdGhlIHN1YmRpdmlzaW9uIGNyZWF0ZXMgdGhlIHZlcnRleCBidWZmZXIgZGF0YVxuXG5cdFx0c3ViZGl2aWRlKCBkZXRhaWwgKTtcblxuXHRcdC8vIGFsbCB2ZXJ0aWNlcyBzaG91bGQgbGllIG9uIGEgY29uY2VwdHVhbCBzcGhlcmUgd2l0aCBhIGdpdmVuIHJhZGl1c1xuXG5cdFx0YXBwbHlSYWRpdXMoIHJhZGl1cyApO1xuXG5cdFx0Ly8gZmluYWxseSwgY3JlYXRlIHRoZSB1diBkYXRhXG5cblx0XHRnZW5lcmF0ZVVWcygpO1xuXG5cdFx0Ly8gYnVpbGQgbm9uLWluZGV4ZWQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGV4QnVmZmVyLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0ZXhCdWZmZXIuc2xpY2UoKSwgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dkJ1ZmZlciwgMiApICk7XG5cblx0XHRpZiAoIGRldGFpbCA9PT0gMCApIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpOyAvLyBmbGF0IG5vcm1hbHNcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpOyAvLyBzbW9vdGggbm9ybWFsc1xuXG5cdFx0fVxuXG5cdFx0Ly8gaGVscGVyIGZ1bmN0aW9uc1xuXG5cdFx0ZnVuY3Rpb24gc3ViZGl2aWRlKCBkZXRhaWwgKSB7XG5cblx0XHRcdGNvbnN0IGEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgYiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBjID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIGFsbCBmYWNlcyBhbmQgYXBwbHkgYSBzdWJkaXZpc2lvbiB3aXRoIHRoZSBnaXZlbiBkZXRhaWwgdmFsdWVcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMyApIHtcblxuXHRcdFx0XHQvLyBnZXQgdGhlIHZlcnRpY2VzIG9mIHRoZSBmYWNlXG5cblx0XHRcdFx0Z2V0VmVydGV4QnlJbmRleCggaW5kaWNlc1sgaSArIDAgXSwgYSApO1xuXHRcdFx0XHRnZXRWZXJ0ZXhCeUluZGV4KCBpbmRpY2VzWyBpICsgMSBdLCBiICk7XG5cdFx0XHRcdGdldFZlcnRleEJ5SW5kZXgoIGluZGljZXNbIGkgKyAyIF0sIGMgKTtcblxuXHRcdFx0XHQvLyBwZXJmb3JtIHN1YmRpdmlzaW9uXG5cblx0XHRcdFx0c3ViZGl2aWRlRmFjZSggYSwgYiwgYywgZGV0YWlsICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHN1YmRpdmlkZUZhY2UoIGEsIGIsIGMsIGRldGFpbCApIHtcblxuXHRcdFx0Y29uc3QgY29scyA9IGRldGFpbCArIDE7XG5cblx0XHRcdC8vIHdlIHVzZSB0aGlzIG11bHRpZGltZW5zaW9uYWwgYXJyYXkgYXMgYSBkYXRhIHN0cnVjdHVyZSBmb3IgY3JlYXRpbmcgdGhlIHN1YmRpdmlzaW9uXG5cblx0XHRcdGNvbnN0IHYgPSBbXTtcblxuXHRcdFx0Ly8gY29uc3RydWN0IGFsbCBvZiB0aGUgdmVydGljZXMgZm9yIHRoaXMgc3ViZGl2aXNpb25cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IGNvbHM7IGkgKysgKSB7XG5cblx0XHRcdFx0dlsgaSBdID0gW107XG5cblx0XHRcdFx0Y29uc3QgYWogPSBhLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKTtcblx0XHRcdFx0Y29uc3QgYmogPSBiLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKTtcblxuXHRcdFx0XHRjb25zdCByb3dzID0gY29scyAtIGk7XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9IHJvd3M7IGogKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgaSA9PT0gY29scyApIHtcblxuXHRcdFx0XHRcdFx0dlsgaSBdWyBqIF0gPSBhajtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHZbIGkgXVsgaiBdID0gYWouY2xvbmUoKS5sZXJwKCBiaiwgaiAvIHJvd3MgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY29uc3RydWN0IGFsbCBvZiB0aGUgZmFjZXNcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY29sczsgaSArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCAyICogKCBjb2xzIC0gaSApIC0gMTsgaiArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGsgPSBNYXRoLmZsb29yKCBqIC8gMiApO1xuXG5cdFx0XHRcdFx0aWYgKCBqICUgMiA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0cHVzaFZlcnRleCggdlsgaSBdWyBrICsgMSBdICk7XG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpICsgMSBdWyBrIF0gKTtcblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgoIHZbIGkgXVsgayBdICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpIF1bIGsgKyAxIF0gKTtcblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgoIHZbIGkgKyAxIF1bIGsgKyAxIF0gKTtcblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgoIHZbIGkgKyAxIF1bIGsgXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYXBwbHlSYWRpdXMoIHJhZGl1cyApIHtcblxuXHRcdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgYnVmZmVyIGFuZCBhcHBseSB0aGUgcmFkaXVzIHRvIGVhY2ggdmVydGV4XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IGkgKz0gMyApIHtcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHZlcnRleEJ1ZmZlclsgaSArIDAgXTtcblx0XHRcdFx0dmVydGV4LnkgPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF07XG5cdFx0XHRcdHZlcnRleC56ID0gdmVydGV4QnVmZmVyWyBpICsgMiBdO1xuXG5cdFx0XHRcdHZlcnRleC5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggcmFkaXVzICk7XG5cblx0XHRcdFx0dmVydGV4QnVmZmVyWyBpICsgMCBdID0gdmVydGV4Lng7XG5cdFx0XHRcdHZlcnRleEJ1ZmZlclsgaSArIDEgXSA9IHZlcnRleC55O1xuXHRcdFx0XHR2ZXJ0ZXhCdWZmZXJbIGkgKyAyIF0gPSB2ZXJ0ZXguejtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVVVnMoKSB7XG5cblx0XHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IGkgKz0gMyApIHtcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHZlcnRleEJ1ZmZlclsgaSArIDAgXTtcblx0XHRcdFx0dmVydGV4LnkgPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF07XG5cdFx0XHRcdHZlcnRleC56ID0gdmVydGV4QnVmZmVyWyBpICsgMiBdO1xuXG5cdFx0XHRcdGNvbnN0IHUgPSBhemltdXRoKCB2ZXJ0ZXggKSAvIDIgLyBNYXRoLlBJICsgMC41O1xuXHRcdFx0XHRjb25zdCB2ID0gaW5jbGluYXRpb24oIHZlcnRleCApIC8gTWF0aC5QSSArIDAuNTtcblx0XHRcdFx0dXZCdWZmZXIucHVzaCggdSwgMSAtIHYgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb3JyZWN0VVZzKCk7XG5cblx0XHRcdGNvcnJlY3RTZWFtKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb3JyZWN0U2VhbSgpIHtcblxuXHRcdFx0Ly8gaGFuZGxlIGNhc2Ugd2hlbiBmYWNlIHN0cmFkZGxlcyB0aGUgc2VhbSwgc2VlICMzMjY5XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHV2QnVmZmVyLmxlbmd0aDsgaSArPSA2ICkge1xuXG5cdFx0XHRcdC8vIHV2IGRhdGEgb2YgYSBzaW5nbGUgZmFjZVxuXG5cdFx0XHRcdGNvbnN0IHgwID0gdXZCdWZmZXJbIGkgKyAwIF07XG5cdFx0XHRcdGNvbnN0IHgxID0gdXZCdWZmZXJbIGkgKyAyIF07XG5cdFx0XHRcdGNvbnN0IHgyID0gdXZCdWZmZXJbIGkgKyA0IF07XG5cblx0XHRcdFx0Y29uc3QgbWF4ID0gTWF0aC5tYXgoIHgwLCB4MSwgeDIgKTtcblx0XHRcdFx0Y29uc3QgbWluID0gTWF0aC5taW4oIHgwLCB4MSwgeDIgKTtcblxuXHRcdFx0XHQvLyAwLjkgaXMgc29tZXdoYXQgYXJiaXRyYXJ5XG5cblx0XHRcdFx0aWYgKCBtYXggPiAwLjkgJiYgbWluIDwgMC4xICkge1xuXG5cdFx0XHRcdFx0aWYgKCB4MCA8IDAuMiApIHV2QnVmZmVyWyBpICsgMCBdICs9IDE7XG5cdFx0XHRcdFx0aWYgKCB4MSA8IDAuMiApIHV2QnVmZmVyWyBpICsgMiBdICs9IDE7XG5cdFx0XHRcdFx0aWYgKCB4MiA8IDAuMiApIHV2QnVmZmVyWyBpICsgNCBdICs9IDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwdXNoVmVydGV4KCB2ZXJ0ZXggKSB7XG5cblx0XHRcdHZlcnRleEJ1ZmZlci5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRWZXJ0ZXhCeUluZGV4KCBpbmRleCwgdmVydGV4ICkge1xuXG5cdFx0XHRjb25zdCBzdHJpZGUgPSBpbmRleCAqIDM7XG5cblx0XHRcdHZlcnRleC54ID0gdmVydGljZXNbIHN0cmlkZSArIDAgXTtcblx0XHRcdHZlcnRleC55ID0gdmVydGljZXNbIHN0cmlkZSArIDEgXTtcblx0XHRcdHZlcnRleC56ID0gdmVydGljZXNbIHN0cmlkZSArIDIgXTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvcnJlY3RVVnMoKSB7XG5cblx0XHRcdGNvbnN0IGEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgYiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBjID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Y29uc3QgY2VudHJvaWQgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRjb25zdCB1dkEgPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0Y29uc3QgdXZCID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdGNvbnN0IHV2QyA9IG5ldyBWZWN0b3IyKCk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaiA9IDA7IGkgPCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoOyBpICs9IDksIGogKz0gNiApIHtcblxuXHRcdFx0XHRhLnNldCggdmVydGV4QnVmZmVyWyBpICsgMCBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF0sIHZlcnRleEJ1ZmZlclsgaSArIDIgXSApO1xuXHRcdFx0XHRiLnNldCggdmVydGV4QnVmZmVyWyBpICsgMyBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyA0IF0sIHZlcnRleEJ1ZmZlclsgaSArIDUgXSApO1xuXHRcdFx0XHRjLnNldCggdmVydGV4QnVmZmVyWyBpICsgNiBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyA3IF0sIHZlcnRleEJ1ZmZlclsgaSArIDggXSApO1xuXG5cdFx0XHRcdHV2QS5zZXQoIHV2QnVmZmVyWyBqICsgMCBdLCB1dkJ1ZmZlclsgaiArIDEgXSApO1xuXHRcdFx0XHR1dkIuc2V0KCB1dkJ1ZmZlclsgaiArIDIgXSwgdXZCdWZmZXJbIGogKyAzIF0gKTtcblx0XHRcdFx0dXZDLnNldCggdXZCdWZmZXJbIGogKyA0IF0sIHV2QnVmZmVyWyBqICsgNSBdICk7XG5cblx0XHRcdFx0Y2VudHJvaWQuY29weSggYSApLmFkZCggYiApLmFkZCggYyApLmRpdmlkZVNjYWxhciggMyApO1xuXG5cdFx0XHRcdGNvbnN0IGF6aSA9IGF6aW11dGgoIGNlbnRyb2lkICk7XG5cblx0XHRcdFx0Y29ycmVjdFVWKCB1dkEsIGogKyAwLCBhLCBhemkgKTtcblx0XHRcdFx0Y29ycmVjdFVWKCB1dkIsIGogKyAyLCBiLCBhemkgKTtcblx0XHRcdFx0Y29ycmVjdFVWKCB1dkMsIGogKyA0LCBjLCBhemkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29ycmVjdFVWKCB1diwgc3RyaWRlLCB2ZWN0b3IsIGF6aW11dGggKSB7XG5cblx0XHRcdGlmICggKCBhemltdXRoIDwgMCApICYmICggdXYueCA9PT0gMSApICkge1xuXG5cdFx0XHRcdHV2QnVmZmVyWyBzdHJpZGUgXSA9IHV2LnggLSAxO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggKCB2ZWN0b3IueCA9PT0gMCApICYmICggdmVjdG9yLnogPT09IDAgKSApIHtcblxuXHRcdFx0XHR1dkJ1ZmZlclsgc3RyaWRlIF0gPSBhemltdXRoIC8gMiAvIE1hdGguUEkgKyAwLjU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIEFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzLCBjb3VudGVyLWNsb2Nrd2lzZSB3aGVuIGxvb2tpbmcgZnJvbSBhYm92ZS5cblxuXHRcdGZ1bmN0aW9uIGF6aW11dGgoIHZlY3RvciApIHtcblxuXHRcdFx0cmV0dXJuIE1hdGguYXRhbjIoIHZlY3Rvci56LCAtIHZlY3Rvci54ICk7XG5cblx0XHR9XG5cblxuXHRcdC8vIEFuZ2xlIGFib3ZlIHRoZSBYWiBwbGFuZS5cblxuXHRcdGZ1bmN0aW9uIGluY2xpbmF0aW9uKCB2ZWN0b3IgKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLmF0YW4yKCAtIHZlY3Rvci55LCBNYXRoLnNxcnQoICggdmVjdG9yLnggKiB2ZWN0b3IueCApICsgKCB2ZWN0b3IueiAqIHZlY3Rvci56ICkgKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgUG9seWhlZHJvbkdlb21ldHJ5KCBkYXRhLnZlcnRpY2VzLCBkYXRhLmluZGljZXMsIGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbHMgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgRG9kZWNhaGVkcm9uR2VvbWV0cnkgZXh0ZW5kcyBQb2x5aGVkcm9uR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCBkZXRhaWwgPSAwICkge1xuXG5cdFx0Y29uc3QgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuXHRcdGNvbnN0IHIgPSAxIC8gdDtcblxuXHRcdGNvbnN0IHZlcnRpY2VzID0gW1xuXG5cdFx0XHQvLyAowrExLCDCsTEsIMKxMSlcblx0XHRcdC0gMSwgLSAxLCAtIDEsXHQtIDEsIC0gMSwgMSxcblx0XHRcdC0gMSwgMSwgLSAxLCAtIDEsIDEsIDEsXG5cdFx0XHQxLCAtIDEsIC0gMSwgMSwgLSAxLCAxLFxuXHRcdFx0MSwgMSwgLSAxLCAxLCAxLCAxLFxuXG5cdFx0XHQvLyAoMCwgwrExL8+GLCDCsc+GKVxuXHRcdFx0MCwgLSByLCAtIHQsIDAsIC0gciwgdCxcblx0XHRcdDAsIHIsIC0gdCwgMCwgciwgdCxcblxuXHRcdFx0Ly8gKMKxMS/PhiwgwrHPhiwgMClcblx0XHRcdC0gciwgLSB0LCAwLCAtIHIsIHQsIDAsXG5cdFx0XHRyLCAtIHQsIDAsIHIsIHQsIDAsXG5cblx0XHRcdC8vICjCsc+GLCAwLCDCsTEvz4YpXG5cdFx0XHQtIHQsIDAsIC0gciwgdCwgMCwgLSByLFxuXHRcdFx0LSB0LCAwLCByLCB0LCAwLCByXG5cdFx0XTtcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXG5cdFx0XHQzLCAxMSwgNywgXHQzLCA3LCAxNSwgXHQzLCAxNSwgMTMsXG5cdFx0XHQ3LCAxOSwgMTcsIFx0NywgMTcsIDYsIFx0NywgNiwgMTUsXG5cdFx0XHQxNywgNCwgOCwgXHQxNywgOCwgMTAsIFx0MTcsIDEwLCA2LFxuXHRcdFx0OCwgMCwgMTYsIFx0OCwgMTYsIDIsIFx0OCwgMiwgMTAsXG5cdFx0XHQwLCAxMiwgMSwgXHQwLCAxLCAxOCwgXHQwLCAxOCwgMTYsXG5cdFx0XHQ2LCAxMCwgMiwgXHQ2LCAyLCAxMywgXHQ2LCAxMywgMTUsXG5cdFx0XHQyLCAxNiwgMTgsIFx0MiwgMTgsIDMsIFx0MiwgMywgMTMsXG5cdFx0XHQxOCwgMSwgOSwgXHQxOCwgOSwgMTEsIFx0MTgsIDExLCAzLFxuXHRcdFx0NCwgMTQsIDEyLCBcdDQsIDEyLCAwLCBcdDQsIDAsIDgsXG5cdFx0XHQxMSwgOSwgNSwgXHQxMSwgNSwgMTksIFx0MTEsIDE5LCA3LFxuXHRcdFx0MTksIDUsIDE0LCBcdDE5LCAxNCwgNCwgXHQxOSwgNCwgMTcsXG5cdFx0XHQxLCAxMiwgMTQsIFx0MSwgMTQsIDUsIFx0MSwgNSwgOVxuXHRcdF07XG5cblx0XHRzdXBlciggdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnRG9kZWNhaGVkcm9uR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdH07XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgRG9kZWNhaGVkcm9uR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbCApO1xuXG5cdH1cblxufVxuXG5jb25zdCBfdjAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdjEkMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9ub3JtYWwgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdHJpYW5nbGUgPSAvKkBfX1BVUkVfXyovIG5ldyBUcmlhbmdsZSgpO1xuXG5jbGFzcyBFZGdlc0dlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSA9IG51bGwsIHRocmVzaG9sZEFuZ2xlID0gMSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnRWRnZXNHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnksXG5cdFx0XHR0aHJlc2hvbGRBbmdsZTogdGhyZXNob2xkQW5nbGVcblx0XHR9O1xuXG5cdFx0aWYgKCBnZW9tZXRyeSAhPT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgcHJlY2lzaW9uUG9pbnRzID0gNDtcblx0XHRcdGNvbnN0IHByZWNpc2lvbiA9IE1hdGgucG93KCAxMCwgcHJlY2lzaW9uUG9pbnRzICk7XG5cdFx0XHRjb25zdCB0aHJlc2hvbGREb3QgPSBNYXRoLmNvcyggREVHMlJBRCAqIHRocmVzaG9sZEFuZ2xlICk7XG5cblx0XHRcdGNvbnN0IGluZGV4QXR0ciA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG5cdFx0XHRjb25zdCBwb3NpdGlvbkF0dHIgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblx0XHRcdGNvbnN0IGluZGV4Q291bnQgPSBpbmRleEF0dHIgPyBpbmRleEF0dHIuY291bnQgOiBwb3NpdGlvbkF0dHIuY291bnQ7XG5cblx0XHRcdGNvbnN0IGluZGV4QXJyID0gWyAwLCAwLCAwIF07XG5cdFx0XHRjb25zdCB2ZXJ0S2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xuXHRcdFx0Y29uc3QgaGFzaGVzID0gbmV3IEFycmF5KCAzICk7XG5cblx0XHRcdGNvbnN0IGVkZ2VEYXRhID0ge307XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgaW5kZXhDb3VudDsgaSArPSAzICkge1xuXG5cdFx0XHRcdGlmICggaW5kZXhBdHRyICkge1xuXG5cdFx0XHRcdFx0aW5kZXhBcnJbIDAgXSA9IGluZGV4QXR0ci5nZXRYKCBpICk7XG5cdFx0XHRcdFx0aW5kZXhBcnJbIDEgXSA9IGluZGV4QXR0ci5nZXRYKCBpICsgMSApO1xuXHRcdFx0XHRcdGluZGV4QXJyWyAyIF0gPSBpbmRleEF0dHIuZ2V0WCggaSArIDIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aW5kZXhBcnJbIDAgXSA9IGk7XG5cdFx0XHRcdFx0aW5kZXhBcnJbIDEgXSA9IGkgKyAxO1xuXHRcdFx0XHRcdGluZGV4QXJyWyAyIF0gPSBpICsgMjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgeyBhLCBiLCBjIH0gPSBfdHJpYW5nbGU7XG5cdFx0XHRcdGEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyLCBpbmRleEFyclsgMCBdICk7XG5cdFx0XHRcdGIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyLCBpbmRleEFyclsgMSBdICk7XG5cdFx0XHRcdGMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyLCBpbmRleEFyclsgMiBdICk7XG5cdFx0XHRcdF90cmlhbmdsZS5nZXROb3JtYWwoIF9ub3JtYWwgKTtcblxuXHRcdFx0XHQvLyBjcmVhdGUgaGFzaGVzIGZvciB0aGUgZWRnZSBmcm9tIHRoZSB2ZXJ0aWNlc1xuXHRcdFx0XHRoYXNoZXNbIDAgXSA9IGAkeyBNYXRoLnJvdW5kKCBhLnggKiBwcmVjaXNpb24gKSB9LCR7IE1hdGgucm91bmQoIGEueSAqIHByZWNpc2lvbiApIH0sJHsgTWF0aC5yb3VuZCggYS56ICogcHJlY2lzaW9uICkgfWA7XG5cdFx0XHRcdGhhc2hlc1sgMSBdID0gYCR7IE1hdGgucm91bmQoIGIueCAqIHByZWNpc2lvbiApIH0sJHsgTWF0aC5yb3VuZCggYi55ICogcHJlY2lzaW9uICkgfSwkeyBNYXRoLnJvdW5kKCBiLnogKiBwcmVjaXNpb24gKSB9YDtcblx0XHRcdFx0aGFzaGVzWyAyIF0gPSBgJHsgTWF0aC5yb3VuZCggYy54ICogcHJlY2lzaW9uICkgfSwkeyBNYXRoLnJvdW5kKCBjLnkgKiBwcmVjaXNpb24gKSB9LCR7IE1hdGgucm91bmQoIGMueiAqIHByZWNpc2lvbiApIH1gO1xuXG5cdFx0XHRcdC8vIHNraXAgZGVnZW5lcmF0ZSB0cmlhbmdsZXNcblx0XHRcdFx0aWYgKCBoYXNoZXNbIDAgXSA9PT0gaGFzaGVzWyAxIF0gfHwgaGFzaGVzWyAxIF0gPT09IGhhc2hlc1sgMiBdIHx8IGhhc2hlc1sgMiBdID09PSBoYXNoZXNbIDAgXSApIHtcblxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpdGVyYXRlIG92ZXIgZXZlcnkgZWRnZVxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG5cdFx0XHRcdFx0Ly8gZ2V0IHRoZSBmaXJzdCBhbmQgbmV4dCB2ZXJ0ZXggbWFraW5nIHVwIHRoZSBlZGdlXG5cdFx0XHRcdFx0Y29uc3Qgak5leHQgPSAoIGogKyAxICkgJSAzO1xuXHRcdFx0XHRcdGNvbnN0IHZlY0hhc2gwID0gaGFzaGVzWyBqIF07XG5cdFx0XHRcdFx0Y29uc3QgdmVjSGFzaDEgPSBoYXNoZXNbIGpOZXh0IF07XG5cdFx0XHRcdFx0Y29uc3QgdjAgPSBfdHJpYW5nbGVbIHZlcnRLZXlzWyBqIF0gXTtcblx0XHRcdFx0XHRjb25zdCB2MSA9IF90cmlhbmdsZVsgdmVydEtleXNbIGpOZXh0IF0gXTtcblxuXHRcdFx0XHRcdGNvbnN0IGhhc2ggPSBgJHsgdmVjSGFzaDAgfV8keyB2ZWNIYXNoMSB9YDtcblx0XHRcdFx0XHRjb25zdCByZXZlcnNlSGFzaCA9IGAkeyB2ZWNIYXNoMSB9XyR7IHZlY0hhc2gwIH1gO1xuXG5cdFx0XHRcdFx0aWYgKCByZXZlcnNlSGFzaCBpbiBlZGdlRGF0YSAmJiBlZGdlRGF0YVsgcmV2ZXJzZUhhc2ggXSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgd2UgZm91bmQgYSBzaWJsaW5nIGVkZ2UgYWRkIGl0IGludG8gdGhlIHZlcnRleCBhcnJheSBpZlxuXHRcdFx0XHRcdFx0Ly8gaXQgbWVldHMgdGhlIGFuZ2xlIHRocmVzaG9sZCBhbmQgZGVsZXRlIHRoZSBlZGdlIGZyb20gdGhlIG1hcC5cblx0XHRcdFx0XHRcdGlmICggX25vcm1hbC5kb3QoIGVkZ2VEYXRhWyByZXZlcnNlSGFzaCBdLm5vcm1hbCApIDw9IHRocmVzaG9sZERvdCApIHtcblxuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2MC54LCB2MC55LCB2MC56ICk7XG5cdFx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHYxLngsIHYxLnksIHYxLnogKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRlZGdlRGF0YVsgcmV2ZXJzZUhhc2ggXSA9IG51bGw7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhICggaGFzaCBpbiBlZGdlRGF0YSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBpZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBlZGdlIGhlcmUgdGhlbiBza2lwIGFkZGluZyBhIG5ldyBvbmVcblx0XHRcdFx0XHRcdGVkZ2VEYXRhWyBoYXNoIF0gPSB7XG5cblx0XHRcdFx0XHRcdFx0aW5kZXgwOiBpbmRleEFyclsgaiBdLFxuXHRcdFx0XHRcdFx0XHRpbmRleDE6IGluZGV4QXJyWyBqTmV4dCBdLFxuXHRcdFx0XHRcdFx0XHRub3JtYWw6IF9ub3JtYWwuY2xvbmUoKSxcblxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIGFsbCByZW1haW5pbmcsIHVubWF0Y2hlZCBlZGdlcyBhbmQgYWRkIHRoZW0gdG8gdGhlIHZlcnRleCBhcnJheVxuXHRcdFx0Zm9yICggY29uc3Qga2V5IGluIGVkZ2VEYXRhICkge1xuXG5cdFx0XHRcdGlmICggZWRnZURhdGFbIGtleSBdICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgeyBpbmRleDAsIGluZGV4MSB9ID0gZWRnZURhdGFbIGtleSBdO1xuXHRcdFx0XHRcdF92MC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHIsIGluZGV4MCApO1xuXHRcdFx0XHRcdF92MSQxLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0ciwgaW5kZXgxICk7XG5cblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCBfdjAueCwgX3YwLnksIF92MC56ICk7XG5cdFx0XHRcdFx0dmVydGljZXMucHVzaCggX3YxJDEueCwgX3YxJDEueSwgX3YxJDEueiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBTaGFwZSBleHRlbmRzIFBhdGgge1xuXG5cdGNvbnN0cnVjdG9yKCBwb2ludHMgKSB7XG5cblx0XHRzdXBlciggcG9pbnRzICk7XG5cblx0XHR0aGlzLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdTaGFwZSc7XG5cblx0XHR0aGlzLmhvbGVzID0gW107XG5cblx0fVxuXG5cdGdldFBvaW50c0hvbGVzKCBkaXZpc2lvbnMgKSB7XG5cblx0XHRjb25zdCBob2xlc1B0cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRob2xlc1B0c1sgaSBdID0gdGhpcy5ob2xlc1sgaSBdLmdldFBvaW50cyggZGl2aXNpb25zICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gaG9sZXNQdHM7XG5cblx0fVxuXG5cdC8vIGdldCBwb2ludHMgb2Ygc2hhcGUgYW5kIGhvbGVzIChrZXlwb2ludHMgYmFzZWQgb24gc2VnbWVudHMgcGFyYW1ldGVyKVxuXG5cdGV4dHJhY3RQb2ludHMoIGRpdmlzaW9ucyApIHtcblxuXHRcdHJldHVybiB7XG5cblx0XHRcdHNoYXBlOiB0aGlzLmdldFBvaW50cyggZGl2aXNpb25zICksXG5cdFx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcblxuXHRcdH07XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5ob2xlcyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc291cmNlLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGhvbGUgPSBzb3VyY2UuaG9sZXNbIGkgXTtcblxuXHRcdFx0dGhpcy5ob2xlcy5wdXNoKCBob2xlLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG5cdFx0ZGF0YS5ob2xlcyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBob2xlID0gdGhpcy5ob2xlc1sgaSBdO1xuXHRcdFx0ZGF0YS5ob2xlcy5wdXNoKCBob2xlLnRvSlNPTigpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xuXG5cdFx0dGhpcy51dWlkID0ganNvbi51dWlkO1xuXHRcdHRoaXMuaG9sZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGpzb24uaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgaG9sZSA9IGpzb24uaG9sZXNbIGkgXTtcblx0XHRcdHRoaXMuaG9sZXMucHVzaCggbmV3IFBhdGgoKS5mcm9tSlNPTiggaG9sZSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBQb3J0IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9lYXJjdXQgKHYyLjIuNClcbiAqL1xuXG5jb25zdCBFYXJjdXQgPSB7XG5cblx0dHJpYW5ndWxhdGU6IGZ1bmN0aW9uICggZGF0YSwgaG9sZUluZGljZXMsIGRpbSA9IDIgKSB7XG5cblx0XHRjb25zdCBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aDtcblx0XHRjb25zdCBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbIDAgXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuXHRcdGxldCBvdXRlck5vZGUgPSBsaW5rZWRMaXN0KCBkYXRhLCAwLCBvdXRlckxlbiwgZGltLCB0cnVlICk7XG5cdFx0Y29uc3QgdHJpYW5nbGVzID0gW107XG5cblx0XHRpZiAoICEgb3V0ZXJOb2RlIHx8IG91dGVyTm9kZS5uZXh0ID09PSBvdXRlck5vZGUucHJldiApIHJldHVybiB0cmlhbmdsZXM7XG5cblx0XHRsZXQgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgaW52U2l6ZTtcblxuXHRcdGlmICggaGFzSG9sZXMgKSBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlcyggZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltICk7XG5cblx0XHQvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcblx0XHRpZiAoIGRhdGEubGVuZ3RoID4gODAgKiBkaW0gKSB7XG5cblx0XHRcdG1pblggPSBtYXhYID0gZGF0YVsgMCBdO1xuXHRcdFx0bWluWSA9IG1heFkgPSBkYXRhWyAxIF07XG5cblx0XHRcdGZvciAoIGxldCBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltICkge1xuXG5cdFx0XHRcdHggPSBkYXRhWyBpIF07XG5cdFx0XHRcdHkgPSBkYXRhWyBpICsgMSBdO1xuXHRcdFx0XHRpZiAoIHggPCBtaW5YICkgbWluWCA9IHg7XG5cdFx0XHRcdGlmICggeSA8IG1pblkgKSBtaW5ZID0geTtcblx0XHRcdFx0aWYgKCB4ID4gbWF4WCApIG1heFggPSB4O1xuXHRcdFx0XHRpZiAoIHkgPiBtYXhZICkgbWF4WSA9IHk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gbWluWCwgbWluWSBhbmQgaW52U2l6ZSBhcmUgbGF0ZXIgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRzIGludG8gaW50ZWdlcnMgZm9yIHotb3JkZXIgY2FsY3VsYXRpb25cblx0XHRcdGludlNpemUgPSBNYXRoLm1heCggbWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZICk7XG5cdFx0XHRpbnZTaXplID0gaW52U2l6ZSAhPT0gMCA/IDMyNzY3IC8gaW52U2l6ZSA6IDA7XG5cblx0XHR9XG5cblx0XHRlYXJjdXRMaW5rZWQoIG91dGVyTm9kZSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDAgKTtcblxuXHRcdHJldHVybiB0cmlhbmdsZXM7XG5cblx0fVxuXG59O1xuXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcbmZ1bmN0aW9uIGxpbmtlZExpc3QoIGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlICkge1xuXG5cdGxldCBpLCBsYXN0O1xuXG5cdGlmICggY2xvY2t3aXNlID09PSAoIHNpZ25lZEFyZWEoIGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSApID4gMCApICkge1xuXG5cdFx0Zm9yICggaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGRpbSApIGxhc3QgPSBpbnNlcnROb2RlKCBpLCBkYXRhWyBpIF0sIGRhdGFbIGkgKyAxIF0sIGxhc3QgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Zm9yICggaSA9IGVuZCAtIGRpbTsgaSA+PSBzdGFydDsgaSAtPSBkaW0gKSBsYXN0ID0gaW5zZXJ0Tm9kZSggaSwgZGF0YVsgaSBdLCBkYXRhWyBpICsgMSBdLCBsYXN0ICk7XG5cblx0fVxuXG5cdGlmICggbGFzdCAmJiBlcXVhbHMoIGxhc3QsIGxhc3QubmV4dCApICkge1xuXG5cdFx0cmVtb3ZlTm9kZSggbGFzdCApO1xuXHRcdGxhc3QgPSBsYXN0Lm5leHQ7XG5cblx0fVxuXG5cdHJldHVybiBsYXN0O1xuXG59XG5cbi8vIGVsaW1pbmF0ZSBjb2xpbmVhciBvciBkdXBsaWNhdGUgcG9pbnRzXG5mdW5jdGlvbiBmaWx0ZXJQb2ludHMoIHN0YXJ0LCBlbmQgKSB7XG5cblx0aWYgKCAhIHN0YXJ0ICkgcmV0dXJuIHN0YXJ0O1xuXHRpZiAoICEgZW5kICkgZW5kID0gc3RhcnQ7XG5cblx0bGV0IHAgPSBzdGFydCxcblx0XHRhZ2Fpbjtcblx0ZG8ge1xuXG5cdFx0YWdhaW4gPSBmYWxzZTtcblxuXHRcdGlmICggISBwLnN0ZWluZXIgJiYgKCBlcXVhbHMoIHAsIHAubmV4dCApIHx8IGFyZWEoIHAucHJldiwgcCwgcC5uZXh0ICkgPT09IDAgKSApIHtcblxuXHRcdFx0cmVtb3ZlTm9kZSggcCApO1xuXHRcdFx0cCA9IGVuZCA9IHAucHJldjtcblx0XHRcdGlmICggcCA9PT0gcC5uZXh0ICkgYnJlYWs7XG5cdFx0XHRhZ2FpbiA9IHRydWU7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRwID0gcC5uZXh0O1xuXG5cdFx0fVxuXG5cdH0gd2hpbGUgKCBhZ2FpbiB8fCBwICE9PSBlbmQgKTtcblxuXHRyZXR1cm4gZW5kO1xuXG59XG5cbi8vIG1haW4gZWFyIHNsaWNpbmcgbG9vcCB3aGljaCB0cmlhbmd1bGF0ZXMgYSBwb2x5Z29uIChnaXZlbiBhcyBhIGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gZWFyY3V0TGlua2VkKCBlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCBwYXNzICkge1xuXG5cdGlmICggISBlYXIgKSByZXR1cm47XG5cblx0Ly8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuXHRpZiAoICEgcGFzcyAmJiBpbnZTaXplICkgaW5kZXhDdXJ2ZSggZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XG5cblx0bGV0IHN0b3AgPSBlYXIsXG5cdFx0cHJldiwgbmV4dDtcblxuXHQvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcblx0d2hpbGUgKCBlYXIucHJldiAhPT0gZWFyLm5leHQgKSB7XG5cblx0XHRwcmV2ID0gZWFyLnByZXY7XG5cdFx0bmV4dCA9IGVhci5uZXh0O1xuXG5cdFx0aWYgKCBpbnZTaXplID8gaXNFYXJIYXNoZWQoIGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSApIDogaXNFYXIoIGVhciApICkge1xuXG5cdFx0XHQvLyBjdXQgb2ZmIHRoZSB0cmlhbmdsZVxuXHRcdFx0dHJpYW5nbGVzLnB1c2goIHByZXYuaSAvIGRpbSB8IDAgKTtcblx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBlYXIuaSAvIGRpbSB8IDAgKTtcblx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBuZXh0LmkgLyBkaW0gfCAwICk7XG5cblx0XHRcdHJlbW92ZU5vZGUoIGVhciApO1xuXG5cdFx0XHQvLyBza2lwcGluZyB0aGUgbmV4dCB2ZXJ0ZXggbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXG5cdFx0XHRlYXIgPSBuZXh0Lm5leHQ7XG5cdFx0XHRzdG9wID0gbmV4dC5uZXh0O1xuXG5cdFx0XHRjb250aW51ZTtcblxuXHRcdH1cblxuXHRcdGVhciA9IG5leHQ7XG5cblx0XHQvLyBpZiB3ZSBsb29wZWQgdGhyb3VnaCB0aGUgd2hvbGUgcmVtYWluaW5nIHBvbHlnb24gYW5kIGNhbid0IGZpbmQgYW55IG1vcmUgZWFyc1xuXHRcdGlmICggZWFyID09PSBzdG9wICkge1xuXG5cdFx0XHQvLyB0cnkgZmlsdGVyaW5nIHBvaW50cyBhbmQgc2xpY2luZyBhZ2FpblxuXHRcdFx0aWYgKCAhIHBhc3MgKSB7XG5cblx0XHRcdFx0ZWFyY3V0TGlua2VkKCBmaWx0ZXJQb2ludHMoIGVhciApLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMSApO1xuXG5cdFx0XHRcdC8vIGlmIHRoaXMgZGlkbid0IHdvcmssIHRyeSBjdXJpbmcgYWxsIHNtYWxsIHNlbGYtaW50ZXJzZWN0aW9ucyBsb2NhbGx5XG5cblx0XHRcdH0gZWxzZSBpZiAoIHBhc3MgPT09IDEgKSB7XG5cblx0XHRcdFx0ZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyggZmlsdGVyUG9pbnRzKCBlYXIgKSwgdHJpYW5nbGVzLCBkaW0gKTtcblx0XHRcdFx0ZWFyY3V0TGlua2VkKCBlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAyICk7XG5cblx0XHRcdFx0Ly8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cblxuXHRcdFx0fSBlbHNlIGlmICggcGFzcyA9PT0gMiApIHtcblxuXHRcdFx0XHRzcGxpdEVhcmN1dCggZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG4vLyBjaGVjayB3aGV0aGVyIGEgcG9seWdvbiBub2RlIGZvcm1zIGEgdmFsaWQgZWFyIHdpdGggYWRqYWNlbnQgbm9kZXNcbmZ1bmN0aW9uIGlzRWFyKCBlYXIgKSB7XG5cblx0Y29uc3QgYSA9IGVhci5wcmV2LFxuXHRcdGIgPSBlYXIsXG5cdFx0YyA9IGVhci5uZXh0O1xuXG5cdGlmICggYXJlYSggYSwgYiwgYyApID49IDAgKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cblx0Ly8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcblx0Y29uc3QgYXggPSBhLngsIGJ4ID0gYi54LCBjeCA9IGMueCwgYXkgPSBhLnksIGJ5ID0gYi55LCBjeSA9IGMueTtcblxuXHQvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuXHRjb25zdCB4MCA9IGF4IDwgYnggPyAoIGF4IDwgY3ggPyBheCA6IGN4ICkgOiAoIGJ4IDwgY3ggPyBieCA6IGN4ICksXG5cdFx0eTAgPSBheSA8IGJ5ID8gKCBheSA8IGN5ID8gYXkgOiBjeSApIDogKCBieSA8IGN5ID8gYnkgOiBjeSApLFxuXHRcdHgxID0gYXggPiBieCA/ICggYXggPiBjeCA/IGF4IDogY3ggKSA6ICggYnggPiBjeCA/IGJ4IDogY3ggKSxcblx0XHR5MSA9IGF5ID4gYnkgPyAoIGF5ID4gY3kgPyBheSA6IGN5ICkgOiAoIGJ5ID4gY3kgPyBieSA6IGN5ICk7XG5cblx0bGV0IHAgPSBjLm5leHQ7XG5cdHdoaWxlICggcCAhPT0gYSApIHtcblxuXHRcdGlmICggcC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmXG5cdFx0XHRwb2ludEluVHJpYW5nbGUoIGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55ICkgJiZcblx0XHRcdGFyZWEoIHAucHJldiwgcCwgcC5uZXh0ICkgPj0gMCApIHJldHVybiBmYWxzZTtcblx0XHRwID0gcC5uZXh0O1xuXG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcblxufVxuXG5mdW5jdGlvbiBpc0Vhckhhc2hlZCggZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplICkge1xuXG5cdGNvbnN0IGEgPSBlYXIucHJldixcblx0XHRiID0gZWFyLFxuXHRcdGMgPSBlYXIubmV4dDtcblxuXHRpZiAoIGFyZWEoIGEsIGIsIGMgKSA+PSAwICkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG5cdGNvbnN0IGF4ID0gYS54LCBieCA9IGIueCwgY3ggPSBjLngsIGF5ID0gYS55LCBieSA9IGIueSwgY3kgPSBjLnk7XG5cblx0Ly8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcblx0Y29uc3QgeDAgPSBheCA8IGJ4ID8gKCBheCA8IGN4ID8gYXggOiBjeCApIDogKCBieCA8IGN4ID8gYnggOiBjeCApLFxuXHRcdHkwID0gYXkgPCBieSA/ICggYXkgPCBjeSA/IGF5IDogY3kgKSA6ICggYnkgPCBjeSA/IGJ5IDogY3kgKSxcblx0XHR4MSA9IGF4ID4gYnggPyAoIGF4ID4gY3ggPyBheCA6IGN4ICkgOiAoIGJ4ID4gY3ggPyBieCA6IGN4ICksXG5cdFx0eTEgPSBheSA+IGJ5ID8gKCBheSA+IGN5ID8gYXkgOiBjeSApIDogKCBieSA+IGN5ID8gYnkgOiBjeSApO1xuXG5cdC8vIHotb3JkZXIgcmFuZ2UgZm9yIHRoZSBjdXJyZW50IHRyaWFuZ2xlIGJib3g7XG5cdGNvbnN0IG1pblogPSB6T3JkZXIoIHgwLCB5MCwgbWluWCwgbWluWSwgaW52U2l6ZSApLFxuXHRcdG1heFogPSB6T3JkZXIoIHgxLCB5MSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xuXG5cdGxldCBwID0gZWFyLnByZXZaLFxuXHRcdG4gPSBlYXIubmV4dFo7XG5cblx0Ly8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgaW4gYm90aCBkaXJlY3Rpb25zXG5cdHdoaWxlICggcCAmJiBwLnogPj0gbWluWiAmJiBuICYmIG4ueiA8PSBtYXhaICkge1xuXG5cdFx0aWYgKCBwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiYgcCAhPT0gYSAmJiBwICE9PSBjICYmXG5cdFx0XHRwb2ludEluVHJpYW5nbGUoIGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55ICkgJiYgYXJlYSggcC5wcmV2LCBwLCBwLm5leHQgKSA+PSAwICkgcmV0dXJuIGZhbHNlO1xuXHRcdHAgPSBwLnByZXZaO1xuXG5cdFx0aWYgKCBuLnggPj0geDAgJiYgbi54IDw9IHgxICYmIG4ueSA+PSB5MCAmJiBuLnkgPD0geTEgJiYgbiAhPT0gYSAmJiBuICE9PSBjICYmXG5cdFx0XHRwb2ludEluVHJpYW5nbGUoIGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIG4ueCwgbi55ICkgJiYgYXJlYSggbi5wcmV2LCBuLCBuLm5leHQgKSA+PSAwICkgcmV0dXJuIGZhbHNlO1xuXHRcdG4gPSBuLm5leHRaO1xuXG5cdH1cblxuXHQvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxuXHR3aGlsZSAoIHAgJiYgcC56ID49IG1pblogKSB7XG5cblx0XHRpZiAoIHAueCA+PSB4MCAmJiBwLnggPD0geDEgJiYgcC55ID49IHkwICYmIHAueSA8PSB5MSAmJiBwICE9PSBhICYmIHAgIT09IGMgJiZcblx0XHRcdHBvaW50SW5UcmlhbmdsZSggYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkgKSAmJiBhcmVhKCBwLnByZXYsIHAsIHAubmV4dCApID49IDAgKSByZXR1cm4gZmFsc2U7XG5cdFx0cCA9IHAucHJldlo7XG5cblx0fVxuXG5cdC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gaW5jcmVhc2luZyB6LW9yZGVyXG5cdHdoaWxlICggbiAmJiBuLnogPD0gbWF4WiApIHtcblxuXHRcdGlmICggbi54ID49IHgwICYmIG4ueCA8PSB4MSAmJiBuLnkgPj0geTAgJiYgbi55IDw9IHkxICYmIG4gIT09IGEgJiYgbiAhPT0gYyAmJlxuXHRcdFx0cG9pbnRJblRyaWFuZ2xlKCBheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBuLngsIG4ueSApICYmIGFyZWEoIG4ucHJldiwgbiwgbi5uZXh0ICkgPj0gMCApIHJldHVybiBmYWxzZTtcblx0XHRuID0gbi5uZXh0WjtcblxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG5cbn1cblxuLy8gZ28gdGhyb3VnaCBhbGwgcG9seWdvbiBub2RlcyBhbmQgY3VyZSBzbWFsbCBsb2NhbCBzZWxmLWludGVyc2VjdGlvbnNcbmZ1bmN0aW9uIGN1cmVMb2NhbEludGVyc2VjdGlvbnMoIHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSApIHtcblxuXHRsZXQgcCA9IHN0YXJ0O1xuXHRkbyB7XG5cblx0XHRjb25zdCBhID0gcC5wcmV2LFxuXHRcdFx0YiA9IHAubmV4dC5uZXh0O1xuXG5cdFx0aWYgKCAhIGVxdWFscyggYSwgYiApICYmIGludGVyc2VjdHMoIGEsIHAsIHAubmV4dCwgYiApICYmIGxvY2FsbHlJbnNpZGUoIGEsIGIgKSAmJiBsb2NhbGx5SW5zaWRlKCBiLCBhICkgKSB7XG5cblx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBhLmkgLyBkaW0gfCAwICk7XG5cdFx0XHR0cmlhbmdsZXMucHVzaCggcC5pIC8gZGltIHwgMCApO1xuXHRcdFx0dHJpYW5nbGVzLnB1c2goIGIuaSAvIGRpbSB8IDAgKTtcblxuXHRcdFx0Ly8gcmVtb3ZlIHR3byBub2RlcyBpbnZvbHZlZFxuXHRcdFx0cmVtb3ZlTm9kZSggcCApO1xuXHRcdFx0cmVtb3ZlTm9kZSggcC5uZXh0ICk7XG5cblx0XHRcdHAgPSBzdGFydCA9IGI7XG5cblx0XHR9XG5cblx0XHRwID0gcC5uZXh0O1xuXG5cdH0gd2hpbGUgKCBwICE9PSBzdGFydCApO1xuXG5cdHJldHVybiBmaWx0ZXJQb2ludHMoIHAgKTtcblxufVxuXG4vLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxuZnVuY3Rpb24gc3BsaXRFYXJjdXQoIHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcblxuXHQvLyBsb29rIGZvciBhIHZhbGlkIGRpYWdvbmFsIHRoYXQgZGl2aWRlcyB0aGUgcG9seWdvbiBpbnRvIHR3b1xuXHRsZXQgYSA9IHN0YXJ0O1xuXHRkbyB7XG5cblx0XHRsZXQgYiA9IGEubmV4dC5uZXh0O1xuXHRcdHdoaWxlICggYiAhPT0gYS5wcmV2ICkge1xuXG5cdFx0XHRpZiAoIGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbCggYSwgYiApICkge1xuXG5cdFx0XHRcdC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcblx0XHRcdFx0bGV0IGMgPSBzcGxpdFBvbHlnb24oIGEsIGIgKTtcblxuXHRcdFx0XHQvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuXHRcdFx0XHRhID0gZmlsdGVyUG9pbnRzKCBhLCBhLm5leHQgKTtcblx0XHRcdFx0YyA9IGZpbHRlclBvaW50cyggYywgYy5uZXh0ICk7XG5cblx0XHRcdFx0Ly8gcnVuIGVhcmN1dCBvbiBlYWNoIGhhbGZcblx0XHRcdFx0ZWFyY3V0TGlua2VkKCBhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCApO1xuXHRcdFx0XHRlYXJjdXRMaW5rZWQoIGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHRiID0gYi5uZXh0O1xuXG5cdFx0fVxuXG5cdFx0YSA9IGEubmV4dDtcblxuXHR9IHdoaWxlICggYSAhPT0gc3RhcnQgKTtcblxufVxuXG4vLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyggZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltICkge1xuXG5cdGNvbnN0IHF1ZXVlID0gW107XG5cdGxldCBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XG5cblx0Zm9yICggaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSArKyApIHtcblxuXHRcdHN0YXJ0ID0gaG9sZUluZGljZXNbIGkgXSAqIGRpbTtcblx0XHRlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzWyBpICsgMSBdICogZGltIDogZGF0YS5sZW5ndGg7XG5cdFx0bGlzdCA9IGxpbmtlZExpc3QoIGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UgKTtcblx0XHRpZiAoIGxpc3QgPT09IGxpc3QubmV4dCApIGxpc3Quc3RlaW5lciA9IHRydWU7XG5cdFx0cXVldWUucHVzaCggZ2V0TGVmdG1vc3QoIGxpc3QgKSApO1xuXG5cdH1cblxuXHRxdWV1ZS5zb3J0KCBjb21wYXJlWCApO1xuXG5cdC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XG5cdGZvciAoIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0b3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZSggcXVldWVbIGkgXSwgb3V0ZXJOb2RlICk7XG5cblx0fVxuXG5cdHJldHVybiBvdXRlck5vZGU7XG5cbn1cblxuZnVuY3Rpb24gY29tcGFyZVgoIGEsIGIgKSB7XG5cblx0cmV0dXJuIGEueCAtIGIueDtcblxufVxuXG4vLyBmaW5kIGEgYnJpZGdlIGJldHdlZW4gdmVydGljZXMgdGhhdCBjb25uZWN0cyBob2xlIHdpdGggYW4gb3V0ZXIgcmluZyBhbmQgbGluayBpdFxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZSggaG9sZSwgb3V0ZXJOb2RlICkge1xuXG5cdGNvbnN0IGJyaWRnZSA9IGZpbmRIb2xlQnJpZGdlKCBob2xlLCBvdXRlck5vZGUgKTtcblx0aWYgKCAhIGJyaWRnZSApIHtcblxuXHRcdHJldHVybiBvdXRlck5vZGU7XG5cblx0fVxuXG5cdGNvbnN0IGJyaWRnZVJldmVyc2UgPSBzcGxpdFBvbHlnb24oIGJyaWRnZSwgaG9sZSApO1xuXG5cdC8vIGZpbHRlciBjb2xsaW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuXHRmaWx0ZXJQb2ludHMoIGJyaWRnZVJldmVyc2UsIGJyaWRnZVJldmVyc2UubmV4dCApO1xuXHRyZXR1cm4gZmlsdGVyUG9pbnRzKCBicmlkZ2UsIGJyaWRnZS5uZXh0ICk7XG5cbn1cblxuLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxuZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoIGhvbGUsIG91dGVyTm9kZSApIHtcblxuXHRsZXQgcCA9IG91dGVyTm9kZSxcblx0XHRxeCA9IC0gSW5maW5pdHksXG5cdFx0bTtcblxuXHRjb25zdCBoeCA9IGhvbGUueCwgaHkgPSBob2xlLnk7XG5cblx0Ly8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xuXHQvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XG5cdGRvIHtcblxuXHRcdGlmICggaHkgPD0gcC55ICYmIGh5ID49IHAubmV4dC55ICYmIHAubmV4dC55ICE9PSBwLnkgKSB7XG5cblx0XHRcdGNvbnN0IHggPSBwLnggKyAoIGh5IC0gcC55ICkgKiAoIHAubmV4dC54IC0gcC54ICkgLyAoIHAubmV4dC55IC0gcC55ICk7XG5cdFx0XHRpZiAoIHggPD0gaHggJiYgeCA+IHF4ICkge1xuXG5cdFx0XHRcdHF4ID0geDtcblx0XHRcdFx0bSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcblx0XHRcdFx0aWYgKCB4ID09PSBoeCApIHJldHVybiBtOyAvLyBob2xlIHRvdWNoZXMgb3V0ZXIgc2VnbWVudDsgcGljayBsZWZ0bW9zdCBlbmRwb2ludFxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRwID0gcC5uZXh0O1xuXG5cdH0gd2hpbGUgKCBwICE9PSBvdXRlck5vZGUgKTtcblxuXHRpZiAoICEgbSApIHJldHVybiBudWxsO1xuXG5cdC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcblx0Ly8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XG5cdC8vIG90aGVyd2lzZSBjaG9vc2UgdGhlIHBvaW50IG9mIHRoZSBtaW5pbXVtIGFuZ2xlIHdpdGggdGhlIHJheSBhcyBjb25uZWN0aW9uIHBvaW50XG5cblx0Y29uc3Qgc3RvcCA9IG0sXG5cdFx0bXggPSBtLngsXG5cdFx0bXkgPSBtLnk7XG5cdGxldCB0YW5NaW4gPSBJbmZpbml0eSwgdGFuO1xuXG5cdHAgPSBtO1xuXG5cdGRvIHtcblxuXHRcdGlmICggaHggPj0gcC54ICYmIHAueCA+PSBteCAmJiBoeCAhPT0gcC54ICYmXG5cdFx0XHRcdHBvaW50SW5UcmlhbmdsZSggaHkgPCBteSA/IGh4IDogcXgsIGh5LCBteCwgbXksIGh5IDwgbXkgPyBxeCA6IGh4LCBoeSwgcC54LCBwLnkgKSApIHtcblxuXHRcdFx0dGFuID0gTWF0aC5hYnMoIGh5IC0gcC55ICkgLyAoIGh4IC0gcC54ICk7IC8vIHRhbmdlbnRpYWxcblxuXHRcdFx0aWYgKCBsb2NhbGx5SW5zaWRlKCBwLCBob2xlICkgJiYgKCB0YW4gPCB0YW5NaW4gfHwgKCB0YW4gPT09IHRhbk1pbiAmJiAoIHAueCA+IG0ueCB8fCAoIHAueCA9PT0gbS54ICYmIHNlY3RvckNvbnRhaW5zU2VjdG9yKCBtLCBwICkgKSApICkgKSApIHtcblxuXHRcdFx0XHRtID0gcDtcblx0XHRcdFx0dGFuTWluID0gdGFuO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRwID0gcC5uZXh0O1xuXG5cdH0gd2hpbGUgKCBwICE9PSBzdG9wICk7XG5cblx0cmV0dXJuIG07XG5cbn1cblxuLy8gd2hldGhlciBzZWN0b3IgaW4gdmVydGV4IG0gY29udGFpbnMgc2VjdG9yIGluIHZlcnRleCBwIGluIHRoZSBzYW1lIGNvb3JkaW5hdGVzXG5mdW5jdGlvbiBzZWN0b3JDb250YWluc1NlY3RvciggbSwgcCApIHtcblxuXHRyZXR1cm4gYXJlYSggbS5wcmV2LCBtLCBwLnByZXYgKSA8IDAgJiYgYXJlYSggcC5uZXh0LCBtLCBtLm5leHQgKSA8IDA7XG5cbn1cblxuLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuZnVuY3Rpb24gaW5kZXhDdXJ2ZSggc3RhcnQsIG1pblgsIG1pblksIGludlNpemUgKSB7XG5cblx0bGV0IHAgPSBzdGFydDtcblx0ZG8ge1xuXG5cdFx0aWYgKCBwLnogPT09IDAgKSBwLnogPSB6T3JkZXIoIHAueCwgcC55LCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XG5cdFx0cC5wcmV2WiA9IHAucHJldjtcblx0XHRwLm5leHRaID0gcC5uZXh0O1xuXHRcdHAgPSBwLm5leHQ7XG5cblx0fSB3aGlsZSAoIHAgIT09IHN0YXJ0ICk7XG5cblx0cC5wcmV2Wi5uZXh0WiA9IG51bGw7XG5cdHAucHJldlogPSBudWxsO1xuXG5cdHNvcnRMaW5rZWQoIHAgKTtcblxufVxuXG4vLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxuLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcbmZ1bmN0aW9uIHNvcnRMaW5rZWQoIGxpc3QgKSB7XG5cblx0bGV0IGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLFxuXHRcdGluU2l6ZSA9IDE7XG5cblx0ZG8ge1xuXG5cdFx0cCA9IGxpc3Q7XG5cdFx0bGlzdCA9IG51bGw7XG5cdFx0dGFpbCA9IG51bGw7XG5cdFx0bnVtTWVyZ2VzID0gMDtcblxuXHRcdHdoaWxlICggcCApIHtcblxuXHRcdFx0bnVtTWVyZ2VzICsrO1xuXHRcdFx0cSA9IHA7XG5cdFx0XHRwU2l6ZSA9IDA7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGluU2l6ZTsgaSArKyApIHtcblxuXHRcdFx0XHRwU2l6ZSArKztcblx0XHRcdFx0cSA9IHEubmV4dFo7XG5cdFx0XHRcdGlmICggISBxICkgYnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0cVNpemUgPSBpblNpemU7XG5cblx0XHRcdHdoaWxlICggcFNpemUgPiAwIHx8ICggcVNpemUgPiAwICYmIHEgKSApIHtcblxuXHRcdFx0XHRpZiAoIHBTaXplICE9PSAwICYmICggcVNpemUgPT09IDAgfHwgISBxIHx8IHAueiA8PSBxLnogKSApIHtcblxuXHRcdFx0XHRcdGUgPSBwO1xuXHRcdFx0XHRcdHAgPSBwLm5leHRaO1xuXHRcdFx0XHRcdHBTaXplIC0tO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRlID0gcTtcblx0XHRcdFx0XHRxID0gcS5uZXh0Wjtcblx0XHRcdFx0XHRxU2l6ZSAtLTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0YWlsICkgdGFpbC5uZXh0WiA9IGU7XG5cdFx0XHRcdGVsc2UgbGlzdCA9IGU7XG5cblx0XHRcdFx0ZS5wcmV2WiA9IHRhaWw7XG5cdFx0XHRcdHRhaWwgPSBlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHAgPSBxO1xuXG5cdFx0fVxuXG5cdFx0dGFpbC5uZXh0WiA9IG51bGw7XG5cdFx0aW5TaXplICo9IDI7XG5cblx0fSB3aGlsZSAoIG51bU1lcmdlcyA+IDEgKTtcblxuXHRyZXR1cm4gbGlzdDtcblxufVxuXG4vLyB6LW9yZGVyIG9mIGEgcG9pbnQgZ2l2ZW4gY29vcmRzIGFuZCBpbnZlcnNlIG9mIHRoZSBsb25nZXIgc2lkZSBvZiBkYXRhIGJib3hcbmZ1bmN0aW9uIHpPcmRlciggeCwgeSwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcblxuXHQvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gbm9uLW5lZ2F0aXZlIDE1LWJpdCBpbnRlZ2VyIHJhbmdlXG5cdHggPSAoIHggLSBtaW5YICkgKiBpbnZTaXplIHwgMDtcblx0eSA9ICggeSAtIG1pblkgKSAqIGludlNpemUgfCAwO1xuXG5cdHggPSAoIHggfCAoIHggPDwgOCApICkgJiAweDAwRkYwMEZGO1xuXHR4ID0gKCB4IHwgKCB4IDw8IDQgKSApICYgMHgwRjBGMEYwRjtcblx0eCA9ICggeCB8ICggeCA8PCAyICkgKSAmIDB4MzMzMzMzMzM7XG5cdHggPSAoIHggfCAoIHggPDwgMSApICkgJiAweDU1NTU1NTU1O1xuXG5cdHkgPSAoIHkgfCAoIHkgPDwgOCApICkgJiAweDAwRkYwMEZGO1xuXHR5ID0gKCB5IHwgKCB5IDw8IDQgKSApICYgMHgwRjBGMEYwRjtcblx0eSA9ICggeSB8ICggeSA8PCAyICkgKSAmIDB4MzMzMzMzMzM7XG5cdHkgPSAoIHkgfCAoIHkgPDwgMSApICkgJiAweDU1NTU1NTU1O1xuXG5cdHJldHVybiB4IHwgKCB5IDw8IDEgKTtcblxufVxuXG4vLyBmaW5kIHRoZSBsZWZ0bW9zdCBub2RlIG9mIGEgcG9seWdvbiByaW5nXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdCggc3RhcnQgKSB7XG5cblx0bGV0IHAgPSBzdGFydCxcblx0XHRsZWZ0bW9zdCA9IHN0YXJ0O1xuXHRkbyB7XG5cblx0XHRpZiAoIHAueCA8IGxlZnRtb3N0LnggfHwgKCBwLnggPT09IGxlZnRtb3N0LnggJiYgcC55IDwgbGVmdG1vc3QueSApICkgbGVmdG1vc3QgPSBwO1xuXHRcdHAgPSBwLm5leHQ7XG5cblx0fSB3aGlsZSAoIHAgIT09IHN0YXJ0ICk7XG5cblx0cmV0dXJuIGxlZnRtb3N0O1xuXG59XG5cbi8vIGNoZWNrIGlmIGEgcG9pbnQgbGllcyB3aXRoaW4gYSBjb252ZXggdHJpYW5nbGVcbmZ1bmN0aW9uIHBvaW50SW5UcmlhbmdsZSggYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5ICkge1xuXG5cdHJldHVybiAoIGN4IC0gcHggKSAqICggYXkgLSBweSApID49ICggYXggLSBweCApICogKCBjeSAtIHB5ICkgJiZcbiAgICAgICAgICAgKCBheCAtIHB4ICkgKiAoIGJ5IC0gcHkgKSA+PSAoIGJ4IC0gcHggKSAqICggYXkgLSBweSApICYmXG4gICAgICAgICAgICggYnggLSBweCApICogKCBjeSAtIHB5ICkgPj0gKCBjeCAtIHB4ICkgKiAoIGJ5IC0gcHkgKTtcblxufVxuXG4vLyBjaGVjayBpZiBhIGRpYWdvbmFsIGJldHdlZW4gdHdvIHBvbHlnb24gbm9kZXMgaXMgdmFsaWQgKGxpZXMgaW4gcG9seWdvbiBpbnRlcmlvcilcbmZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbCggYSwgYiApIHtcblxuXHRyZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICEgaW50ZXJzZWN0c1BvbHlnb24oIGEsIGIgKSAmJiAvLyBkb2Vzbid0IGludGVyc2VjdCBvdGhlciBlZGdlc1xuICAgICAgICAgICAoIGxvY2FsbHlJbnNpZGUoIGEsIGIgKSAmJiBsb2NhbGx5SW5zaWRlKCBiLCBhICkgJiYgbWlkZGxlSW5zaWRlKCBhLCBiICkgJiYgLy8gbG9jYWxseSB2aXNpYmxlXG4gICAgICAgICAgICAoIGFyZWEoIGEucHJldiwgYSwgYi5wcmV2ICkgfHwgYXJlYSggYSwgYi5wcmV2LCBiICkgKSB8fCAvLyBkb2VzIG5vdCBjcmVhdGUgb3Bwb3NpdGUtZmFjaW5nIHNlY3RvcnNcbiAgICAgICAgICAgIGVxdWFscyggYSwgYiApICYmIGFyZWEoIGEucHJldiwgYSwgYS5uZXh0ICkgPiAwICYmIGFyZWEoIGIucHJldiwgYiwgYi5uZXh0ICkgPiAwICk7IC8vIHNwZWNpYWwgemVyby1sZW5ndGggY2FzZVxuXG59XG5cbi8vIHNpZ25lZCBhcmVhIG9mIGEgdHJpYW5nbGVcbmZ1bmN0aW9uIGFyZWEoIHAsIHEsIHIgKSB7XG5cblx0cmV0dXJuICggcS55IC0gcC55ICkgKiAoIHIueCAtIHEueCApIC0gKCBxLnggLSBwLnggKSAqICggci55IC0gcS55ICk7XG5cbn1cblxuLy8gY2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcbmZ1bmN0aW9uIGVxdWFscyggcDEsIHAyICkge1xuXG5cdHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG5cbn1cblxuLy8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxuZnVuY3Rpb24gaW50ZXJzZWN0cyggcDEsIHExLCBwMiwgcTIgKSB7XG5cblx0Y29uc3QgbzEgPSBzaWduKCBhcmVhKCBwMSwgcTEsIHAyICkgKTtcblx0Y29uc3QgbzIgPSBzaWduKCBhcmVhKCBwMSwgcTEsIHEyICkgKTtcblx0Y29uc3QgbzMgPSBzaWduKCBhcmVhKCBwMiwgcTIsIHAxICkgKTtcblx0Y29uc3QgbzQgPSBzaWduKCBhcmVhKCBwMiwgcTIsIHExICkgKTtcblxuXHRpZiAoIG8xICE9PSBvMiAmJiBvMyAhPT0gbzQgKSByZXR1cm4gdHJ1ZTsgLy8gZ2VuZXJhbCBjYXNlXG5cblx0aWYgKCBvMSA9PT0gMCAmJiBvblNlZ21lbnQoIHAxLCBwMiwgcTEgKSApIHJldHVybiB0cnVlOyAvLyBwMSwgcTEgYW5kIHAyIGFyZSBjb2xsaW5lYXIgYW5kIHAyIGxpZXMgb24gcDFxMVxuXHRpZiAoIG8yID09PSAwICYmIG9uU2VnbWVudCggcDEsIHEyLCBxMSApICkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcTIgYXJlIGNvbGxpbmVhciBhbmQgcTIgbGllcyBvbiBwMXExXG5cdGlmICggbzMgPT09IDAgJiYgb25TZWdtZW50KCBwMiwgcDEsIHEyICkgKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBwMSBhcmUgY29sbGluZWFyIGFuZCBwMSBsaWVzIG9uIHAycTJcblx0aWYgKCBvNCA9PT0gMCAmJiBvblNlZ21lbnQoIHAyLCBxMSwgcTIgKSApIHJldHVybiB0cnVlOyAvLyBwMiwgcTIgYW5kIHExIGFyZSBjb2xsaW5lYXIgYW5kIHExIGxpZXMgb24gcDJxMlxuXG5cdHJldHVybiBmYWxzZTtcblxufVxuXG4vLyBmb3IgY29sbGluZWFyIHBvaW50cyBwLCBxLCByLCBjaGVjayBpZiBwb2ludCBxIGxpZXMgb24gc2VnbWVudCBwclxuZnVuY3Rpb24gb25TZWdtZW50KCBwLCBxLCByICkge1xuXG5cdHJldHVybiBxLnggPD0gTWF0aC5tYXgoIHAueCwgci54ICkgJiYgcS54ID49IE1hdGgubWluKCBwLngsIHIueCApICYmIHEueSA8PSBNYXRoLm1heCggcC55LCByLnkgKSAmJiBxLnkgPj0gTWF0aC5taW4oIHAueSwgci55ICk7XG5cbn1cblxuZnVuY3Rpb24gc2lnbiggbnVtICkge1xuXG5cdHJldHVybiBudW0gPiAwID8gMSA6IG51bSA8IDAgPyAtIDEgOiAwO1xuXG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpbnRlcnNlY3RzIGFueSBwb2x5Z29uIHNlZ21lbnRzXG5mdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbiggYSwgYiApIHtcblxuXHRsZXQgcCA9IGE7XG5cdGRvIHtcblxuXHRcdGlmICggcC5pICE9PSBhLmkgJiYgcC5uZXh0LmkgIT09IGEuaSAmJiBwLmkgIT09IGIuaSAmJiBwLm5leHQuaSAhPT0gYi5pICYmXG5cdFx0XHRpbnRlcnNlY3RzKCBwLCBwLm5leHQsIGEsIGIgKSApIHJldHVybiB0cnVlO1xuXHRcdHAgPSBwLm5leHQ7XG5cblx0fSB3aGlsZSAoIHAgIT09IGEgKTtcblxuXHRyZXR1cm4gZmFsc2U7XG5cbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBsb2NhbGx5SW5zaWRlKCBhLCBiICkge1xuXG5cdHJldHVybiBhcmVhKCBhLnByZXYsIGEsIGEubmV4dCApIDwgMCA/XG5cdFx0YXJlYSggYSwgYiwgYS5uZXh0ICkgPj0gMCAmJiBhcmVhKCBhLCBhLnByZXYsIGIgKSA+PSAwIDpcblx0XHRhcmVhKCBhLCBiLCBhLnByZXYgKSA8IDAgfHwgYXJlYSggYSwgYS5uZXh0LCBiICkgPCAwO1xuXG59XG5cbi8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbWlkZGxlSW5zaWRlKCBhLCBiICkge1xuXG5cdGxldCBwID0gYSxcblx0XHRpbnNpZGUgPSBmYWxzZTtcblx0Y29uc3QgcHggPSAoIGEueCArIGIueCApIC8gMixcblx0XHRweSA9ICggYS55ICsgYi55ICkgLyAyO1xuXHRkbyB7XG5cblx0XHRpZiAoICggKCBwLnkgPiBweSApICE9PSAoIHAubmV4dC55ID4gcHkgKSApICYmIHAubmV4dC55ICE9PSBwLnkgJiZcblx0XHRcdCggcHggPCAoIHAubmV4dC54IC0gcC54ICkgKiAoIHB5IC0gcC55ICkgLyAoIHAubmV4dC55IC0gcC55ICkgKyBwLnggKSApXG5cdFx0XHRpbnNpZGUgPSAhIGluc2lkZTtcblx0XHRwID0gcC5uZXh0O1xuXG5cdH0gd2hpbGUgKCBwICE9PSBhICk7XG5cblx0cmV0dXJuIGluc2lkZTtcblxufVxuXG4vLyBsaW5rIHR3byBwb2x5Z29uIHZlcnRpY2VzIHdpdGggYSBicmlkZ2U7IGlmIHRoZSB2ZXJ0aWNlcyBiZWxvbmcgdG8gdGhlIHNhbWUgcmluZywgaXQgc3BsaXRzIHBvbHlnb24gaW50byB0d287XG4vLyBpZiBvbmUgYmVsb25ncyB0byB0aGUgb3V0ZXIgcmluZyBhbmQgYW5vdGhlciB0byBhIGhvbGUsIGl0IG1lcmdlcyBpdCBpbnRvIGEgc2luZ2xlIHJpbmdcbmZ1bmN0aW9uIHNwbGl0UG9seWdvbiggYSwgYiApIHtcblxuXHRjb25zdCBhMiA9IG5ldyBOb2RlKCBhLmksIGEueCwgYS55ICksXG5cdFx0YjIgPSBuZXcgTm9kZSggYi5pLCBiLngsIGIueSApLFxuXHRcdGFuID0gYS5uZXh0LFxuXHRcdGJwID0gYi5wcmV2O1xuXG5cdGEubmV4dCA9IGI7XG5cdGIucHJldiA9IGE7XG5cblx0YTIubmV4dCA9IGFuO1xuXHRhbi5wcmV2ID0gYTI7XG5cblx0YjIubmV4dCA9IGEyO1xuXHRhMi5wcmV2ID0gYjI7XG5cblx0YnAubmV4dCA9IGIyO1xuXHRiMi5wcmV2ID0gYnA7XG5cblx0cmV0dXJuIGIyO1xuXG59XG5cbi8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBpbnNlcnROb2RlKCBpLCB4LCB5LCBsYXN0ICkge1xuXG5cdGNvbnN0IHAgPSBuZXcgTm9kZSggaSwgeCwgeSApO1xuXG5cdGlmICggISBsYXN0ICkge1xuXG5cdFx0cC5wcmV2ID0gcDtcblx0XHRwLm5leHQgPSBwO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRwLm5leHQgPSBsYXN0Lm5leHQ7XG5cdFx0cC5wcmV2ID0gbGFzdDtcblx0XHRsYXN0Lm5leHQucHJldiA9IHA7XG5cdFx0bGFzdC5uZXh0ID0gcDtcblxuXHR9XG5cblx0cmV0dXJuIHA7XG5cbn1cblxuZnVuY3Rpb24gcmVtb3ZlTm9kZSggcCApIHtcblxuXHRwLm5leHQucHJldiA9IHAucHJldjtcblx0cC5wcmV2Lm5leHQgPSBwLm5leHQ7XG5cblx0aWYgKCBwLnByZXZaICkgcC5wcmV2Wi5uZXh0WiA9IHAubmV4dFo7XG5cdGlmICggcC5uZXh0WiApIHAubmV4dFoucHJldlogPSBwLnByZXZaO1xuXG59XG5cbmZ1bmN0aW9uIE5vZGUoIGksIHgsIHkgKSB7XG5cblx0Ly8gdmVydGV4IGluZGV4IGluIGNvb3JkaW5hdGVzIGFycmF5XG5cdHRoaXMuaSA9IGk7XG5cblx0Ly8gdmVydGV4IGNvb3JkaW5hdGVzXG5cdHRoaXMueCA9IHg7XG5cdHRoaXMueSA9IHk7XG5cblx0Ly8gcHJldmlvdXMgYW5kIG5leHQgdmVydGV4IG5vZGVzIGluIGEgcG9seWdvbiByaW5nXG5cdHRoaXMucHJldiA9IG51bGw7XG5cdHRoaXMubmV4dCA9IG51bGw7XG5cblx0Ly8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxuXHR0aGlzLnogPSAwO1xuXG5cdC8vIHByZXZpb3VzIGFuZCBuZXh0IG5vZGVzIGluIHotb3JkZXJcblx0dGhpcy5wcmV2WiA9IG51bGw7XG5cdHRoaXMubmV4dFogPSBudWxsO1xuXG5cdC8vIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYSBzdGVpbmVyIHBvaW50XG5cdHRoaXMuc3RlaW5lciA9IGZhbHNlO1xuXG59XG5cbmZ1bmN0aW9uIHNpZ25lZEFyZWEoIGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSApIHtcblxuXHRsZXQgc3VtID0gMDtcblx0Zm9yICggbGV0IGkgPSBzdGFydCwgaiA9IGVuZCAtIGRpbTsgaSA8IGVuZDsgaSArPSBkaW0gKSB7XG5cblx0XHRzdW0gKz0gKCBkYXRhWyBqIF0gLSBkYXRhWyBpIF0gKSAqICggZGF0YVsgaSArIDEgXSArIGRhdGFbIGogKyAxIF0gKTtcblx0XHRqID0gaTtcblxuXHR9XG5cblx0cmV0dXJuIHN1bTtcblxufVxuXG5jbGFzcyBTaGFwZVV0aWxzIHtcblxuXHQvLyBjYWxjdWxhdGUgYXJlYSBvZiB0aGUgY29udG91ciBwb2x5Z29uXG5cblx0c3RhdGljIGFyZWEoIGNvbnRvdXIgKSB7XG5cblx0XHRjb25zdCBuID0gY29udG91ci5sZW5ndGg7XG5cdFx0bGV0IGEgPSAwLjA7XG5cblx0XHRmb3IgKCBsZXQgcCA9IG4gLSAxLCBxID0gMDsgcSA8IG47IHAgPSBxICsrICkge1xuXG5cdFx0XHRhICs9IGNvbnRvdXJbIHAgXS54ICogY29udG91clsgcSBdLnkgLSBjb250b3VyWyBxIF0ueCAqIGNvbnRvdXJbIHAgXS55O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGEgKiAwLjU7XG5cblx0fVxuXG5cdHN0YXRpYyBpc0Nsb2NrV2lzZSggcHRzICkge1xuXG5cdFx0cmV0dXJuIFNoYXBlVXRpbHMuYXJlYSggcHRzICkgPCAwO1xuXG5cdH1cblxuXHRzdGF0aWMgdHJpYW5ndWxhdGVTaGFwZSggY29udG91ciwgaG9sZXMgKSB7XG5cblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdOyAvLyBmbGF0IGFycmF5IG9mIHZlcnRpY2VzIGxpa2UgWyB4MCx5MCwgeDEseTEsIHgyLHkyLCAuLi4gXVxuXHRcdGNvbnN0IGhvbGVJbmRpY2VzID0gW107IC8vIGFycmF5IG9mIGhvbGUgaW5kaWNlc1xuXHRcdGNvbnN0IGZhY2VzID0gW107IC8vIGZpbmFsIGFycmF5IG9mIHZlcnRleCBpbmRpY2VzIGxpa2UgWyBbIGEsYixkIF0sIFsgYixjLGQgXSBdXG5cblx0XHRyZW1vdmVEdXBFbmRQdHMoIGNvbnRvdXIgKTtcblx0XHRhZGRDb250b3VyKCB2ZXJ0aWNlcywgY29udG91ciApO1xuXG5cdFx0Ly9cblxuXHRcdGxldCBob2xlSW5kZXggPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdGhvbGVzLmZvckVhY2goIHJlbW92ZUR1cEVuZFB0cyApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRob2xlSW5kaWNlcy5wdXNoKCBob2xlSW5kZXggKTtcblx0XHRcdGhvbGVJbmRleCArPSBob2xlc1sgaSBdLmxlbmd0aDtcblx0XHRcdGFkZENvbnRvdXIoIHZlcnRpY2VzLCBob2xlc1sgaSBdICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgdHJpYW5nbGVzID0gRWFyY3V0LnRyaWFuZ3VsYXRlKCB2ZXJ0aWNlcywgaG9sZUluZGljZXMgKTtcblxuXHRcdC8vXG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMgKSB7XG5cblx0XHRcdGZhY2VzLnB1c2goIHRyaWFuZ2xlcy5zbGljZSggaSwgaSArIDMgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhY2VzO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiByZW1vdmVEdXBFbmRQdHMoIHBvaW50cyApIHtcblxuXHRjb25zdCBsID0gcG9pbnRzLmxlbmd0aDtcblxuXHRpZiAoIGwgPiAyICYmIHBvaW50c1sgbCAtIDEgXS5lcXVhbHMoIHBvaW50c1sgMCBdICkgKSB7XG5cblx0XHRwb2ludHMucG9wKCk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIGFkZENvbnRvdXIoIHZlcnRpY2VzLCBjb250b3VyICkge1xuXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IGNvbnRvdXIubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0dmVydGljZXMucHVzaCggY29udG91clsgaSBdLnggKTtcblx0XHR2ZXJ0aWNlcy5wdXNoKCBjb250b3VyWyBpIF0ueSApO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIENyZWF0ZXMgZXh0cnVkZWQgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqXG4gKiAgY3VydmVTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xuICogIHN0ZXBzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBmb3Igei1zaWRlIGV4dHJ1c2lvbnMgLyB1c2VkIGZvciBzdWJkaXZpZGluZyBzZWdtZW50cyBvZiBleHRydWRlIHNwbGluZSB0b29cbiAqICBkZXB0aDogPGZsb2F0PiwgLy8gRGVwdGggdG8gZXh0cnVkZSB0aGUgc2hhcGVcbiAqXG4gKiAgYmV2ZWxFbmFibGVkOiA8Ym9vbD4sIC8vIHR1cm4gb24gYmV2ZWxcbiAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0aGUgb3JpZ2luYWwgc2hhcGUgYmV2ZWwgZ29lc1xuICogIGJldmVsU2l6ZTogPGZsb2F0PiwgLy8gaG93IGZhciBmcm9tIHNoYXBlIG91dGxpbmUgKGluY2x1ZGluZyBiZXZlbE9mZnNldCkgaXMgYmV2ZWxcbiAqICBiZXZlbE9mZnNldDogPGZsb2F0PiwgLy8gaG93IGZhciBmcm9tIHNoYXBlIG91dGxpbmUgZG9lcyBiZXZlbCBzdGFydFxuICogIGJldmVsU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgYmV2ZWwgbGF5ZXJzXG4gKlxuICogIGV4dHJ1ZGVQYXRoOiA8VEhSRUUuQ3VydmU+IC8vIGN1cnZlIHRvIGV4dHJ1ZGUgc2hhcGUgYWxvbmdcbiAqXG4gKiAgVVZHZW5lcmF0b3I6IDxPYmplY3Q+IC8vIG9iamVjdCB0aGF0IHByb3ZpZGVzIFVWIGdlbmVyYXRvciBmdW5jdGlvbnNcbiAqXG4gKiB9XG4gKi9cblxuXG5jbGFzcyBFeHRydWRlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHNoYXBlcyA9IG5ldyBTaGFwZSggWyBuZXcgVmVjdG9yMiggMC41LCAwLjUgKSwgbmV3IFZlY3RvcjIoIC0gMC41LCAwLjUgKSwgbmV3IFZlY3RvcjIoIC0gMC41LCAtIDAuNSApLCBuZXcgVmVjdG9yMiggMC41LCAtIDAuNSApIF0gKSwgb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdFeHRydWRlR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0c2hhcGVzOiBzaGFwZXMsXG5cdFx0XHRvcHRpb25zOiBvcHRpb25zXG5cdFx0fTtcblxuXHRcdHNoYXBlcyA9IEFycmF5LmlzQXJyYXkoIHNoYXBlcyApID8gc2hhcGVzIDogWyBzaGFwZXMgXTtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGNvbnN0IHZlcnRpY2VzQXJyYXkgPSBbXTtcblx0XHRjb25zdCB1dkFycmF5ID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbIGkgXTtcblx0XHRcdGFkZFNoYXBlKCBzaGFwZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXNBcnJheSwgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dkFycmF5LCAyICkgKTtcblxuXHRcdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuXHRcdC8vIGZ1bmN0aW9uc1xuXG5cdFx0ZnVuY3Rpb24gYWRkU2hhcGUoIHNoYXBlICkge1xuXG5cdFx0XHRjb25zdCBwbGFjZWhvbGRlciA9IFtdO1xuXG5cdFx0XHQvLyBvcHRpb25zXG5cblx0XHRcdGNvbnN0IGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xuXHRcdFx0Y29uc3Qgc3RlcHMgPSBvcHRpb25zLnN0ZXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZXBzIDogMTtcblx0XHRcdGNvbnN0IGRlcHRoID0gb3B0aW9ucy5kZXB0aCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aCA6IDE7XG5cblx0XHRcdGxldCBiZXZlbEVuYWJsZWQgPSBvcHRpb25zLmJldmVsRW5hYmxlZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbEVuYWJsZWQgOiB0cnVlO1xuXHRcdFx0bGV0IGJldmVsVGhpY2tuZXNzID0gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyA6IDAuMjtcblx0XHRcdGxldCBiZXZlbFNpemUgPSBvcHRpb25zLmJldmVsU2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNpemUgOiBiZXZlbFRoaWNrbmVzcyAtIDAuMTtcblx0XHRcdGxldCBiZXZlbE9mZnNldCA9IG9wdGlvbnMuYmV2ZWxPZmZzZXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxPZmZzZXQgOiAwO1xuXHRcdFx0bGV0IGJldmVsU2VnbWVudHMgPSBvcHRpb25zLmJldmVsU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyA6IDM7XG5cblx0XHRcdGNvbnN0IGV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aDtcblxuXHRcdFx0Y29uc3QgdXZnZW4gPSBvcHRpb25zLlVWR2VuZXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLlVWR2VuZXJhdG9yIDogV29ybGRVVkdlbmVyYXRvcjtcblxuXHRcdFx0Ly9cblxuXHRcdFx0bGV0IGV4dHJ1ZGVQdHMsIGV4dHJ1ZGVCeVBhdGggPSBmYWxzZTtcblx0XHRcdGxldCBzcGxpbmVUdWJlLCBiaW5vcm1hbCwgbm9ybWFsLCBwb3NpdGlvbjI7XG5cblx0XHRcdGlmICggZXh0cnVkZVBhdGggKSB7XG5cblx0XHRcdFx0ZXh0cnVkZVB0cyA9IGV4dHJ1ZGVQYXRoLmdldFNwYWNlZFBvaW50cyggc3RlcHMgKTtcblxuXHRcdFx0XHRleHRydWRlQnlQYXRoID0gdHJ1ZTtcblx0XHRcdFx0YmV2ZWxFbmFibGVkID0gZmFsc2U7IC8vIGJldmVscyBub3Qgc3VwcG9ydGVkIGZvciBwYXRoIGV4dHJ1c2lvblxuXG5cdFx0XHRcdC8vIFNFVFVQIFROQiB2YXJpYWJsZXNcblxuXHRcdFx0XHQvLyBUT0RPMSAtIGhhdmUgYSAuaXNDbG9zZWQgaW4gc3BsaW5lP1xuXG5cdFx0XHRcdHNwbGluZVR1YmUgPSBleHRydWRlUGF0aC5jb21wdXRlRnJlbmV0RnJhbWVzKCBzdGVwcywgZmFsc2UgKTtcblxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhzcGxpbmVUdWJlLCAnc3BsaW5lVHViZScsIHNwbGluZVR1YmUubm9ybWFscy5sZW5ndGgsICdzdGVwcycsIHN0ZXBzLCAnZXh0cnVkZVB0cycsIGV4dHJ1ZGVQdHMubGVuZ3RoKTtcblxuXHRcdFx0XHRiaW5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdHBvc2l0aW9uMiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2FmZWd1YXJkcyBpZiBiZXZlbHMgYXJlIG5vdCBlbmFibGVkXG5cblx0XHRcdGlmICggISBiZXZlbEVuYWJsZWQgKSB7XG5cblx0XHRcdFx0YmV2ZWxTZWdtZW50cyA9IDA7XG5cdFx0XHRcdGJldmVsVGhpY2tuZXNzID0gMDtcblx0XHRcdFx0YmV2ZWxTaXplID0gMDtcblx0XHRcdFx0YmV2ZWxPZmZzZXQgPSAwO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFZhcmlhYmxlcyBpbml0aWFsaXphdGlvblxuXG5cdFx0XHRjb25zdCBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblxuXHRcdFx0bGV0IHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XG5cdFx0XHRjb25zdCBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xuXG5cdFx0XHRjb25zdCByZXZlcnNlID0gISBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApO1xuXG5cdFx0XHRpZiAoIHJldmVyc2UgKSB7XG5cblx0XHRcdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XG5cblx0XHRcdFx0Ly8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZSAuLi5cblxuXHRcdFx0XHRmb3IgKCBsZXQgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzWyBoIF07XG5cblx0XHRcdFx0XHRpZiAoIFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIGFob2xlICkgKSB7XG5cblx0XHRcdFx0XHRcdGhvbGVzWyBoIF0gPSBhaG9sZS5yZXZlcnNlKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdFx0Y29uc3QgZmFjZXMgPSBTaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHZlcnRpY2VzLCBob2xlcyApO1xuXG5cdFx0XHQvKiBWZXJ0aWNlcyAqL1xuXG5cdFx0XHRjb25zdCBjb250b3VyID0gdmVydGljZXM7IC8vIHZlcnRpY2VzIGhhcyBhbGwgcG9pbnRzIGJ1dCBjb250b3VyIGhhcyBvbmx5IHBvaW50cyBvZiBjaXJjdW1mZXJlbmNlXG5cblx0XHRcdGZvciAoIGxldCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzWyBoIF07XG5cblx0XHRcdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoIGFob2xlICk7XG5cblx0XHRcdH1cblxuXG5cdFx0XHRmdW5jdGlvbiBzY2FsZVB0MiggcHQsIHZlYywgc2l6ZSApIHtcblxuXHRcdFx0XHRpZiAoICEgdmVjICkgY29uc29sZS5lcnJvciggJ1RIUkVFLkV4dHJ1ZGVHZW9tZXRyeTogdmVjIGRvZXMgbm90IGV4aXN0JyApO1xuXG5cdFx0XHRcdHJldHVybiBwdC5jbG9uZSgpLmFkZFNjYWxlZFZlY3RvciggdmVjLCBzaXplICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aCwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcblxuXG5cdFx0XHQvLyBGaW5kIGRpcmVjdGlvbnMgZm9yIHBvaW50IG1vdmVtZW50XG5cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0QmV2ZWxWZWMoIGluUHQsIGluUHJldiwgaW5OZXh0ICkge1xuXG5cdFx0XHRcdC8vIGNvbXB1dGVzIGZvciBpblB0IHRoZSBjb3JyZXNwb25kaW5nIHBvaW50IGluUHQnIG9uIGEgbmV3IGNvbnRvdXJcblx0XHRcdFx0Ly8gICBzaGlmdGVkIGJ5IDEgdW5pdCAobGVuZ3RoIG9mIG5vcm1hbGl6ZWQgdmVjdG9yKSB0byB0aGUgbGVmdFxuXHRcdFx0XHQvLyBpZiB3ZSB3YWxrIGFsb25nIGNvbnRvdXIgY2xvY2t3aXNlLCB0aGlzIG5ldyBjb250b3VyIGlzIG91dHNpZGUgdGhlIG9sZCBvbmVcblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gaW5QdCcgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIGxpbmVzIHBhcmFsbGVsIHRvIHRoZSB0d29cblx0XHRcdFx0Ly8gIGFkamFjZW50IGVkZ2VzIG9mIGluUHQgYXQgYSBkaXN0YW5jZSBvZiAxIHVuaXQgb24gdGhlIGxlZnQgc2lkZS5cblxuXHRcdFx0XHRsZXQgdl90cmFuc194LCB2X3RyYW5zX3ksIHNocmlua19ieTsgLy8gcmVzdWx0aW5nIHRyYW5zbGF0aW9uIHZlY3RvciBmb3IgaW5QdFxuXG5cdFx0XHRcdC8vIGdvb2QgcmVhZGluZyBmb3IgZ2VvbWV0cnkgYWxnb3JpdGhtcyAoaGVyZTogbGluZS1saW5lIGludGVyc2VjdGlvbilcblx0XHRcdFx0Ly8gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMDUtX2ludGVyc2VjdC0xLmh0bWxcblxuXHRcdFx0XHRjb25zdCB2X3ByZXZfeCA9IGluUHQueCAtIGluUHJldi54LFxuXHRcdFx0XHRcdHZfcHJldl95ID0gaW5QdC55IC0gaW5QcmV2Lnk7XG5cdFx0XHRcdGNvbnN0IHZfbmV4dF94ID0gaW5OZXh0LnggLSBpblB0LngsXG5cdFx0XHRcdFx0dl9uZXh0X3kgPSBpbk5leHQueSAtIGluUHQueTtcblxuXHRcdFx0XHRjb25zdCB2X3ByZXZfbGVuc3EgPSAoIHZfcHJldl94ICogdl9wcmV2X3ggKyB2X3ByZXZfeSAqIHZfcHJldl95ICk7XG5cblx0XHRcdFx0Ly8gY2hlY2sgZm9yIGNvbGxpbmVhciBlZGdlc1xuXHRcdFx0XHRjb25zdCBjb2xsaW5lYXIwID0gKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIGNvbGxpbmVhcjAgKSA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0Ly8gbm90IGNvbGxpbmVhclxuXG5cdFx0XHRcdFx0Ly8gbGVuZ3RoIG9mIHZlY3RvcnMgZm9yIG5vcm1hbGl6aW5nXG5cblx0XHRcdFx0XHRjb25zdCB2X3ByZXZfbGVuID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcblx0XHRcdFx0XHRjb25zdCB2X25leHRfbGVuID0gTWF0aC5zcXJ0KCB2X25leHRfeCAqIHZfbmV4dF94ICsgdl9uZXh0X3kgKiB2X25leHRfeSApO1xuXG5cdFx0XHRcdFx0Ly8gc2hpZnQgYWRqYWNlbnQgcG9pbnRzIGJ5IHVuaXQgdmVjdG9ycyB0byB0aGUgbGVmdFxuXG5cdFx0XHRcdFx0Y29uc3QgcHRQcmV2U2hpZnRfeCA9ICggaW5QcmV2LnggLSB2X3ByZXZfeSAvIHZfcHJldl9sZW4gKTtcblx0XHRcdFx0XHRjb25zdCBwdFByZXZTaGlmdF95ID0gKCBpblByZXYueSArIHZfcHJldl94IC8gdl9wcmV2X2xlbiApO1xuXG5cdFx0XHRcdFx0Y29uc3QgcHROZXh0U2hpZnRfeCA9ICggaW5OZXh0LnggLSB2X25leHRfeSAvIHZfbmV4dF9sZW4gKTtcblx0XHRcdFx0XHRjb25zdCBwdE5leHRTaGlmdF95ID0gKCBpbk5leHQueSArIHZfbmV4dF94IC8gdl9uZXh0X2xlbiApO1xuXG5cdFx0XHRcdFx0Ly8gc2NhbGluZyBmYWN0b3IgZm9yIHZfcHJldiB0byBpbnRlcnNlY3Rpb24gcG9pbnRcblxuXHRcdFx0XHRcdGNvbnN0IHNmID0gKCAoIHB0TmV4dFNoaWZ0X3ggLSBwdFByZXZTaGlmdF94ICkgKiB2X25leHRfeSAtXG5cdFx0XHRcdFx0XHRcdCggcHROZXh0U2hpZnRfeSAtIHB0UHJldlNoaWZ0X3kgKSAqIHZfbmV4dF94ICkgL1xuXHRcdFx0XHRcdFx0KCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xuXG5cdFx0XHRcdFx0Ly8gdmVjdG9yIGZyb20gaW5QdCB0byBpbnRlcnNlY3Rpb24gcG9pbnRcblxuXHRcdFx0XHRcdHZfdHJhbnNfeCA9ICggcHRQcmV2U2hpZnRfeCArIHZfcHJldl94ICogc2YgLSBpblB0LnggKTtcblx0XHRcdFx0XHR2X3RyYW5zX3kgPSAoIHB0UHJldlNoaWZ0X3kgKyB2X3ByZXZfeSAqIHNmIC0gaW5QdC55ICk7XG5cblx0XHRcdFx0XHQvLyBEb24ndCBub3JtYWxpemUhLCBvdGhlcndpc2Ugc2hhcnAgY29ybmVycyBiZWNvbWUgdWdseVxuXHRcdFx0XHRcdC8vICBidXQgcHJldmVudCBjcmF6eSBzcGlrZXNcblx0XHRcdFx0XHRjb25zdCB2X3RyYW5zX2xlbnNxID0gKCB2X3RyYW5zX3ggKiB2X3RyYW5zX3ggKyB2X3RyYW5zX3kgKiB2X3RyYW5zX3kgKTtcblx0XHRcdFx0XHRpZiAoIHZfdHJhbnNfbGVuc3EgPD0gMiApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBWZWN0b3IyKCB2X3RyYW5zX3gsIHZfdHJhbnNfeSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3RyYW5zX2xlbnNxIC8gMiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIG9mIGNvbGxpbmVhciBlZGdlc1xuXG5cdFx0XHRcdFx0bGV0IGRpcmVjdGlvbl9lcSA9IGZhbHNlOyAvLyBhc3N1bWVzOiBvcHBvc2l0ZVxuXG5cdFx0XHRcdFx0aWYgKCB2X3ByZXZfeCA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHZfbmV4dF94ID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0aWYgKCB2X3ByZXZfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB2X25leHRfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRkaXJlY3Rpb25fZXEgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIE1hdGguc2lnbiggdl9wcmV2X3kgKSA9PT0gTWF0aC5zaWduKCB2X25leHRfeSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggZGlyZWN0aW9uX2VxICkge1xuXG5cdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNlcXVlbmNlXCIpO1xuXHRcdFx0XHRcdFx0dl90cmFuc194ID0gLSB2X3ByZXZfeTtcblx0XHRcdFx0XHRcdHZfdHJhbnNfeSA9IHZfcHJldl94O1xuXHRcdFx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc3Bpa2VcIik7XG5cdFx0XHRcdFx0XHR2X3RyYW5zX3ggPSB2X3ByZXZfeDtcblx0XHRcdFx0XHRcdHZfdHJhbnNfeSA9IHZfcHJldl95O1xuXHRcdFx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgLyAyICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZXcgVmVjdG9yMiggdl90cmFuc194IC8gc2hyaW5rX2J5LCB2X3RyYW5zX3kgLyBzaHJpbmtfYnkgKTtcblxuXHRcdFx0fVxuXG5cblx0XHRcdGNvbnN0IGNvbnRvdXJNb3ZlbWVudHMgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcblxuXHRcdFx0XHRpZiAoIGogPT09IGlsICkgaiA9IDA7XG5cdFx0XHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcblxuXHRcdFx0XHQvLyAgKGopLS0tKGkpLS0tKGspXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdpLGosaycsIGksIGogLCBrKVxuXG5cdFx0XHRcdGNvbnRvdXJNb3ZlbWVudHNbIGkgXSA9IGdldEJldmVsVmVjKCBjb250b3VyWyBpIF0sIGNvbnRvdXJbIGogXSwgY29udG91clsgayBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaG9sZXNNb3ZlbWVudHMgPSBbXTtcblx0XHRcdGxldCBvbmVIb2xlTW92ZW1lbnRzLCB2ZXJ0aWNlc01vdmVtZW50cyA9IGNvbnRvdXJNb3ZlbWVudHMuY29uY2F0KCk7XG5cblx0XHRcdGZvciAoIGxldCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzWyBoIF07XG5cblx0XHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xuXG5cdFx0XHRcdFx0aWYgKCBqID09PSBpbCApIGogPSAwO1xuXHRcdFx0XHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcblxuXHRcdFx0XHRcdC8vICAoaiktLS0oaSktLS0oaylcblx0XHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggYWhvbGVbIGkgXSwgYWhvbGVbIGogXSwgYWhvbGVbIGsgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRob2xlc01vdmVtZW50cy5wdXNoKCBvbmVIb2xlTW92ZW1lbnRzICk7XG5cdFx0XHRcdHZlcnRpY2VzTW92ZW1lbnRzID0gdmVydGljZXNNb3ZlbWVudHMuY29uY2F0KCBvbmVIb2xlTW92ZW1lbnRzICk7XG5cblx0XHRcdH1cblxuXG5cdFx0XHQvLyBMb29wIGJldmVsU2VnbWVudHMsIDEgZm9yIHRoZSBmcm9udCwgMSBmb3IgdGhlIGJhY2tcblxuXHRcdFx0Zm9yICggbGV0IGIgPSAwOyBiIDwgYmV2ZWxTZWdtZW50czsgYiArKyApIHtcblxuXHRcdFx0XHQvL2ZvciAoIGIgPSBiZXZlbFNlZ21lbnRzOyBiID4gMDsgYiAtLSApIHtcblxuXHRcdFx0XHRjb25zdCB0ID0gYiAvIGJldmVsU2VnbWVudHM7XG5cdFx0XHRcdGNvbnN0IHogPSBiZXZlbFRoaWNrbmVzcyAqIE1hdGguY29zKCB0ICogTWF0aC5QSSAvIDIgKTtcblx0XHRcdFx0Y29uc3QgYnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbiggdCAqIE1hdGguUEkgLyAyICkgKyBiZXZlbE9mZnNldDtcblxuXHRcdFx0XHQvLyBjb250cmFjdCBzaGFwZVxuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuXHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAtIHogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZXhwYW5kIGhvbGVzXG5cblx0XHRcdFx0Zm9yICggbGV0IGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYWhvbGUgPSBob2xlc1sgaCBdO1xuXHRcdFx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCB2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuXHRcdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIC0geiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBicyA9IGJldmVsU2l6ZSArIGJldmVsT2Zmc2V0O1xuXG5cdFx0XHQvLyBCYWNrIGZhY2luZyB2ZXJ0aWNlc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XG5cblx0XHRcdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XG5cblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgMCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIDAgXS55LCBleHRydWRlUHRzWyAwIF0ueCApO1xuXG5cdFx0XHRcdFx0bm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgMCBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xuXHRcdFx0XHRcdGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzWyAwIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC55ICk7XG5cblx0XHRcdFx0XHRwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1sgMCBdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XG5cblx0XHRcdFx0XHR2KCBwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBzdGVwcGVkIHZlcnRpY2VzLi4uXG5cdFx0XHQvLyBJbmNsdWRpbmcgZnJvbnQgZmFjaW5nIHZlcnRpY2VzXG5cblx0XHRcdGZvciAoIGxldCBzID0gMTsgcyA8PSBzdGVwczsgcyArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc01vdmVtZW50c1sgaSBdLCBicyApIDogdmVydGljZXNbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggISBleHRydWRlQnlQYXRoICkge1xuXG5cdFx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgZGVwdGggLyBzdGVwcyAqIHMgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgcyAtIDEgXS55LCBleHRydWRlUHRzWyBzIC0gMSBdLnggKTtcblxuXHRcdFx0XHRcdFx0bm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xuXHRcdFx0XHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcblxuXHRcdFx0XHRcdFx0cG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbIHMgXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xuXG5cdFx0XHRcdFx0XHR2KCBwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gQWRkIGJldmVsIHNlZ21lbnRzIHBsYW5lc1xuXG5cdFx0XHQvL2ZvciAoIGIgPSAxOyBiIDw9IGJldmVsU2VnbWVudHM7IGIgKysgKSB7XG5cdFx0XHRmb3IgKCBsZXQgYiA9IGJldmVsU2VnbWVudHMgLSAxOyBiID49IDA7IGIgLS0gKSB7XG5cblx0XHRcdFx0Y29uc3QgdCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xuXHRcdFx0XHRjb25zdCB6ID0gYmV2ZWxUaGlja25lc3MgKiBNYXRoLmNvcyggdCAqIE1hdGguUEkgLyAyICk7XG5cdFx0XHRcdGNvbnN0IGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4oIHQgKiBNYXRoLlBJIC8gMiApICsgYmV2ZWxPZmZzZXQ7XG5cblx0XHRcdFx0Ly8gY29udHJhY3Qgc2hhcGVcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIGRlcHRoICsgeiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBleHBhbmQgaG9sZXNcblxuXHRcdFx0XHRmb3IgKCBsZXQgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzWyBoIF07XG5cdFx0XHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzWyBoIF07XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xuXG5cdFx0XHRcdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuXHRcdFx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgZGVwdGggKyB6ICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS55LCBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS54ICsgeiApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8qIEZhY2VzICovXG5cblx0XHRcdC8vIFRvcCBhbmQgYm90dG9tIGZhY2VzXG5cblx0XHRcdGJ1aWxkTGlkRmFjZXMoKTtcblxuXHRcdFx0Ly8gU2lkZXMgZmFjZXNcblxuXHRcdFx0YnVpbGRTaWRlRmFjZXMoKTtcblxuXG5cdFx0XHQvLy8vLyAgSW50ZXJuYWwgZnVuY3Rpb25zXG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkTGlkRmFjZXMoKSB7XG5cblx0XHRcdFx0Y29uc3Qgc3RhcnQgPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XG5cblx0XHRcdFx0aWYgKCBiZXZlbEVuYWJsZWQgKSB7XG5cblx0XHRcdFx0XHRsZXQgbGF5ZXIgPSAwOyAvLyBzdGVwcyArIDFcblx0XHRcdFx0XHRsZXQgb2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xuXG5cdFx0XHRcdFx0Ly8gQm90dG9tIGZhY2VzXG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBmYWNlID0gZmFjZXNbIGkgXTtcblx0XHRcdFx0XHRcdGYzKCBmYWNlWyAyIF0gKyBvZmZzZXQsIGZhY2VbIDEgXSArIG9mZnNldCwgZmFjZVsgMCBdICsgb2Zmc2V0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsYXllciA9IHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDI7XG5cdFx0XHRcdFx0b2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xuXG5cdFx0XHRcdFx0Ly8gVG9wIGZhY2VzXG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBmYWNlID0gZmFjZXNbIGkgXTtcblx0XHRcdFx0XHRcdGYzKCBmYWNlWyAwIF0gKyBvZmZzZXQsIGZhY2VbIDEgXSArIG9mZnNldCwgZmFjZVsgMiBdICsgb2Zmc2V0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIEJvdHRvbSBmYWNlc1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdFx0XHRmMyggZmFjZVsgMiBdLCBmYWNlWyAxIF0sIGZhY2VbIDAgXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gVG9wIGZhY2VzXG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBmYWNlID0gZmFjZXNbIGkgXTtcblx0XHRcdFx0XHRcdGYzKCBmYWNlWyAwIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDEgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMiBdICsgdmxlbiAqIHN0ZXBzICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLmFkZEdyb3VwKCBzdGFydCwgdmVydGljZXNBcnJheS5sZW5ndGggLyAzIC0gc3RhcnQsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDcmVhdGUgZmFjZXMgZm9yIHRoZSB6LXNpZGVzIG9mIHRoZSBzaGFwZVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZFNpZGVGYWNlcygpIHtcblxuXHRcdFx0XHRjb25zdCBzdGFydCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcblx0XHRcdFx0bGV0IGxheWVyb2Zmc2V0ID0gMDtcblx0XHRcdFx0c2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApO1xuXHRcdFx0XHRsYXllcm9mZnNldCArPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzWyBoIF07XG5cdFx0XHRcdFx0c2lkZXdhbGxzKCBhaG9sZSwgbGF5ZXJvZmZzZXQgKTtcblxuXHRcdFx0XHRcdC8vLCB0cnVlXG5cdFx0XHRcdFx0bGF5ZXJvZmZzZXQgKz0gYWhvbGUubGVuZ3RoO1xuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdHNjb3BlLmFkZEdyb3VwKCBzdGFydCwgdmVydGljZXNBcnJheS5sZW5ndGggLyAzIC0gc3RhcnQsIDEgKTtcblxuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKSB7XG5cblx0XHRcdFx0bGV0IGkgPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIC0tIGkgPj0gMCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGogPSBpO1xuXHRcdFx0XHRcdGxldCBrID0gaSAtIDE7XG5cdFx0XHRcdFx0aWYgKCBrIDwgMCApIGsgPSBjb250b3VyLmxlbmd0aCAtIDE7XG5cblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdiJywgaSxqLCBpLTEsIGssdmVydGljZXMubGVuZ3RoKTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBzID0gMCwgc2wgPSAoIHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDIgKTsgcyA8IHNsOyBzICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBzbGVuMSA9IHZsZW4gKiBzO1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2xlbjIgPSB2bGVuICogKCBzICsgMSApO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBhID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjEsXG5cdFx0XHRcdFx0XHRcdGIgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMSxcblx0XHRcdFx0XHRcdFx0YyA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4yLFxuXHRcdFx0XHRcdFx0XHRkID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjI7XG5cblx0XHRcdFx0XHRcdGY0KCBhLCBiLCBjLCBkICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHYoIHgsIHksIHogKSB7XG5cblx0XHRcdFx0cGxhY2Vob2xkZXIucHVzaCggeCApO1xuXHRcdFx0XHRwbGFjZWhvbGRlci5wdXNoKCB5ICk7XG5cdFx0XHRcdHBsYWNlaG9sZGVyLnB1c2goIHogKTtcblxuXHRcdFx0fVxuXG5cblx0XHRcdGZ1bmN0aW9uIGYzKCBhLCBiLCBjICkge1xuXG5cdFx0XHRcdGFkZFZlcnRleCggYSApO1xuXHRcdFx0XHRhZGRWZXJ0ZXgoIGIgKTtcblx0XHRcdFx0YWRkVmVydGV4KCBjICk7XG5cblx0XHRcdFx0Y29uc3QgbmV4dEluZGV4ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xuXHRcdFx0XHRjb25zdCB1dnMgPSB1dmdlbi5nZW5lcmF0ZVRvcFVWKCBzY29wZSwgdmVydGljZXNBcnJheSwgbmV4dEluZGV4IC0gMywgbmV4dEluZGV4IC0gMiwgbmV4dEluZGV4IC0gMSApO1xuXG5cdFx0XHRcdGFkZFVWKCB1dnNbIDAgXSApO1xuXHRcdFx0XHRhZGRVViggdXZzWyAxIF0gKTtcblx0XHRcdFx0YWRkVVYoIHV2c1sgMiBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZjQoIGEsIGIsIGMsIGQgKSB7XG5cblx0XHRcdFx0YWRkVmVydGV4KCBhICk7XG5cdFx0XHRcdGFkZFZlcnRleCggYiApO1xuXHRcdFx0XHRhZGRWZXJ0ZXgoIGQgKTtcblxuXHRcdFx0XHRhZGRWZXJ0ZXgoIGIgKTtcblx0XHRcdFx0YWRkVmVydGV4KCBjICk7XG5cdFx0XHRcdGFkZFZlcnRleCggZCApO1xuXG5cblx0XHRcdFx0Y29uc3QgbmV4dEluZGV4ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xuXHRcdFx0XHRjb25zdCB1dnMgPSB1dmdlbi5nZW5lcmF0ZVNpZGVXYWxsVVYoIHNjb3BlLCB2ZXJ0aWNlc0FycmF5LCBuZXh0SW5kZXggLSA2LCBuZXh0SW5kZXggLSAzLCBuZXh0SW5kZXggLSAyLCBuZXh0SW5kZXggLSAxICk7XG5cblx0XHRcdFx0YWRkVVYoIHV2c1sgMCBdICk7XG5cdFx0XHRcdGFkZFVWKCB1dnNbIDEgXSApO1xuXHRcdFx0XHRhZGRVViggdXZzWyAzIF0gKTtcblxuXHRcdFx0XHRhZGRVViggdXZzWyAxIF0gKTtcblx0XHRcdFx0YWRkVVYoIHV2c1sgMiBdICk7XG5cdFx0XHRcdGFkZFVWKCB1dnNbIDMgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGFkZFZlcnRleCggaW5kZXggKSB7XG5cblx0XHRcdFx0dmVydGljZXNBcnJheS5wdXNoKCBwbGFjZWhvbGRlclsgaW5kZXggKiAzICsgMCBdICk7XG5cdFx0XHRcdHZlcnRpY2VzQXJyYXkucHVzaCggcGxhY2Vob2xkZXJbIGluZGV4ICogMyArIDEgXSApO1xuXHRcdFx0XHR2ZXJ0aWNlc0FycmF5LnB1c2goIHBsYWNlaG9sZGVyWyBpbmRleCAqIDMgKyAyIF0gKTtcblxuXHRcdFx0fVxuXG5cblx0XHRcdGZ1bmN0aW9uIGFkZFVWKCB2ZWN0b3IyICkge1xuXG5cdFx0XHRcdHV2QXJyYXkucHVzaCggdmVjdG9yMi54ICk7XG5cdFx0XHRcdHV2QXJyYXkucHVzaCggdmVjdG9yMi55ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRjb25zdCBzaGFwZXMgPSB0aGlzLnBhcmFtZXRlcnMuc2hhcGVzO1xuXHRcdGNvbnN0IG9wdGlvbnMgPSB0aGlzLnBhcmFtZXRlcnMub3B0aW9ucztcblxuXHRcdHJldHVybiB0b0pTT04kMSggc2hhcGVzLCBvcHRpb25zLCBkYXRhICk7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSwgc2hhcGVzICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnlTaGFwZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBkYXRhLnNoYXBlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbIGRhdGEuc2hhcGVzWyBqIF0gXTtcblxuXHRcdFx0Z2VvbWV0cnlTaGFwZXMucHVzaCggc2hhcGUgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGV4dHJ1ZGVQYXRoID0gZGF0YS5vcHRpb25zLmV4dHJ1ZGVQYXRoO1xuXG5cdFx0aWYgKCBleHRydWRlUGF0aCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRkYXRhLm9wdGlvbnMuZXh0cnVkZVBhdGggPSBuZXcgQ3VydmVzWyBleHRydWRlUGF0aC50eXBlIF0oKS5mcm9tSlNPTiggZXh0cnVkZVBhdGggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgRXh0cnVkZUdlb21ldHJ5KCBnZW9tZXRyeVNoYXBlcywgZGF0YS5vcHRpb25zICk7XG5cblx0fVxuXG59XG5cbmNvbnN0IFdvcmxkVVZHZW5lcmF0b3IgPSB7XG5cblx0Z2VuZXJhdGVUb3BVVjogZnVuY3Rpb24gKCBnZW9tZXRyeSwgdmVydGljZXMsIGluZGV4QSwgaW5kZXhCLCBpbmRleEMgKSB7XG5cblx0XHRjb25zdCBhX3ggPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyBdO1xuXHRcdGNvbnN0IGFfeSA9IHZlcnRpY2VzWyBpbmRleEEgKiAzICsgMSBdO1xuXHRcdGNvbnN0IGJfeCA9IHZlcnRpY2VzWyBpbmRleEIgKiAzIF07XG5cdFx0Y29uc3QgYl95ID0gdmVydGljZXNbIGluZGV4QiAqIDMgKyAxIF07XG5cdFx0Y29uc3QgY194ID0gdmVydGljZXNbIGluZGV4QyAqIDMgXTtcblx0XHRjb25zdCBjX3kgPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyArIDEgXTtcblxuXHRcdHJldHVybiBbXG5cdFx0XHRuZXcgVmVjdG9yMiggYV94LCBhX3kgKSxcblx0XHRcdG5ldyBWZWN0b3IyKCBiX3gsIGJfeSApLFxuXHRcdFx0bmV3IFZlY3RvcjIoIGNfeCwgY195IClcblx0XHRdO1xuXG5cdH0sXG5cblx0Z2VuZXJhdGVTaWRlV2FsbFVWOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCB2ZXJ0aWNlcywgaW5kZXhBLCBpbmRleEIsIGluZGV4QywgaW5kZXhEICkge1xuXG5cdFx0Y29uc3QgYV94ID0gdmVydGljZXNbIGluZGV4QSAqIDMgXTtcblx0XHRjb25zdCBhX3kgPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyArIDEgXTtcblx0XHRjb25zdCBhX3ogPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyArIDIgXTtcblx0XHRjb25zdCBiX3ggPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyBdO1xuXHRcdGNvbnN0IGJfeSA9IHZlcnRpY2VzWyBpbmRleEIgKiAzICsgMSBdO1xuXHRcdGNvbnN0IGJfeiA9IHZlcnRpY2VzWyBpbmRleEIgKiAzICsgMiBdO1xuXHRcdGNvbnN0IGNfeCA9IHZlcnRpY2VzWyBpbmRleEMgKiAzIF07XG5cdFx0Y29uc3QgY195ID0gdmVydGljZXNbIGluZGV4QyAqIDMgKyAxIF07XG5cdFx0Y29uc3QgY196ID0gdmVydGljZXNbIGluZGV4QyAqIDMgKyAyIF07XG5cdFx0Y29uc3QgZF94ID0gdmVydGljZXNbIGluZGV4RCAqIDMgXTtcblx0XHRjb25zdCBkX3kgPSB2ZXJ0aWNlc1sgaW5kZXhEICogMyArIDEgXTtcblx0XHRjb25zdCBkX3ogPSB2ZXJ0aWNlc1sgaW5kZXhEICogMyArIDIgXTtcblxuXHRcdGlmICggTWF0aC5hYnMoIGFfeSAtIGJfeSApIDwgTWF0aC5hYnMoIGFfeCAtIGJfeCApICkge1xuXG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRuZXcgVmVjdG9yMiggYV94LCAxIC0gYV96ICksXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBiX3gsIDEgLSBiX3ogKSxcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGNfeCwgMSAtIGNfeiApLFxuXHRcdFx0XHRuZXcgVmVjdG9yMiggZF94LCAxIC0gZF96IClcblx0XHRcdF07XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRuZXcgVmVjdG9yMiggYV95LCAxIC0gYV96ICksXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBiX3ksIDEgLSBiX3ogKSxcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGNfeSwgMSAtIGNfeiApLFxuXHRcdFx0XHRuZXcgVmVjdG9yMiggZF95LCAxIC0gZF96IClcblx0XHRcdF07XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5mdW5jdGlvbiB0b0pTT04kMSggc2hhcGVzLCBvcHRpb25zLCBkYXRhICkge1xuXG5cdGRhdGEuc2hhcGVzID0gW107XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBzaGFwZSA9IHNoYXBlc1sgaSBdO1xuXG5cdFx0XHRkYXRhLnNoYXBlcy5wdXNoKCBzaGFwZS51dWlkICk7XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdGRhdGEuc2hhcGVzLnB1c2goIHNoYXBlcy51dWlkICk7XG5cblx0fVxuXG5cdGRhdGEub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oIHt9LCBvcHRpb25zICk7XG5cblx0aWYgKCBvcHRpb25zLmV4dHJ1ZGVQYXRoICE9PSB1bmRlZmluZWQgKSBkYXRhLm9wdGlvbnMuZXh0cnVkZVBhdGggPSBvcHRpb25zLmV4dHJ1ZGVQYXRoLnRvSlNPTigpO1xuXG5cdHJldHVybiBkYXRhO1xuXG59XG5cbmNsYXNzIEljb3NhaGVkcm9uR2VvbWV0cnkgZXh0ZW5kcyBQb2x5aGVkcm9uR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCBkZXRhaWwgPSAwICkge1xuXG5cdFx0Y29uc3QgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXG5cdFx0XHQtIDEsIHQsIDAsIFx0MSwgdCwgMCwgXHQtIDEsIC0gdCwgMCwgXHQxLCAtIHQsIDAsXG5cdFx0XHQwLCAtIDEsIHQsIFx0MCwgMSwgdCxcdDAsIC0gMSwgLSB0LCBcdDAsIDEsIC0gdCxcblx0XHRcdHQsIDAsIC0gMSwgXHR0LCAwLCAxLCBcdC0gdCwgMCwgLSAxLCBcdC0gdCwgMCwgMVxuXHRcdF07XG5cblx0XHRjb25zdCBpbmRpY2VzID0gW1xuXHRcdFx0MCwgMTEsIDUsIFx0MCwgNSwgMSwgXHQwLCAxLCA3LCBcdDAsIDcsIDEwLCBcdDAsIDEwLCAxMSxcblx0XHRcdDEsIDUsIDksIFx0NSwgMTEsIDQsXHQxMSwgMTAsIDIsXHQxMCwgNywgNixcdDcsIDEsIDgsXG5cdFx0XHQzLCA5LCA0LCBcdDMsIDQsIDIsXHQzLCAyLCA2LFx0MywgNiwgOCxcdDMsIDgsIDksXG5cdFx0XHQ0LCA5LCA1LCBcdDIsIDQsIDExLFx0NiwgMiwgMTAsXHQ4LCA2LCA3LFx0OSwgOCwgMVxuXHRcdF07XG5cblx0XHRzdXBlciggdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnSWNvc2FoZWRyb25HZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdGRldGFpbDogZGV0YWlsXG5cdFx0fTtcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBJY29zYWhlZHJvbkdlb21ldHJ5KCBkYXRhLnJhZGl1cywgZGF0YS5kZXRhaWwgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgT2N0YWhlZHJvbkdlb21ldHJ5IGV4dGVuZHMgUG9seWhlZHJvbkdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgZGV0YWlsID0gMCApIHtcblxuXHRcdGNvbnN0IHZlcnRpY2VzID0gW1xuXHRcdFx0MSwgMCwgMCwgXHQtIDEsIDAsIDAsXHQwLCAxLCAwLFxuXHRcdFx0MCwgLSAxLCAwLCBcdDAsIDAsIDEsXHQwLCAwLCAtIDFcblx0XHRdO1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtcblx0XHRcdDAsIDIsIDQsXHQwLCA0LCAzLFx0MCwgMywgNSxcblx0XHRcdDAsIDUsIDIsXHQxLCAyLCA1LFx0MSwgNSwgMyxcblx0XHRcdDEsIDMsIDQsXHQxLCA0LCAyXG5cdFx0XTtcblxuXHRcdHN1cGVyKCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdPY3RhaGVkcm9uR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdH07XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgT2N0YWhlZHJvbkdlb21ldHJ5KCBkYXRhLnJhZGl1cywgZGF0YS5kZXRhaWwgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgUGxhbmVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3Rvciggd2lkdGggPSAxLCBoZWlnaHQgPSAxLCB3aWR0aFNlZ21lbnRzID0gMSwgaGVpZ2h0U2VnbWVudHMgPSAxICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdQbGFuZUdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcblx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50c1xuXHRcdH07XG5cblx0XHRjb25zdCB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xuXHRcdGNvbnN0IGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMjtcblxuXHRcdGNvbnN0IGdyaWRYID0gTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApO1xuXHRcdGNvbnN0IGdyaWRZID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKTtcblxuXHRcdGNvbnN0IGdyaWRYMSA9IGdyaWRYICsgMTtcblx0XHRjb25zdCBncmlkWTEgPSBncmlkWSArIDE7XG5cblx0XHRjb25zdCBzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWDtcblx0XHRjb25zdCBzZWdtZW50X2hlaWdodCA9IGhlaWdodCAvIGdyaWRZO1xuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcblxuXHRcdFx0Y29uc3QgeSA9IGl5ICogc2VnbWVudF9oZWlnaHQgLSBoZWlnaHRfaGFsZjtcblxuXHRcdFx0Zm9yICggbGV0IGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHggPSBpeCAqIHNlZ21lbnRfd2lkdGggLSB3aWR0aF9oYWxmO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHgsIC0geSwgMCApO1xuXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xuXG5cdFx0XHRcdHV2cy5wdXNoKCBpeCAvIGdyaWRYICk7XG5cdFx0XHRcdHV2cy5wdXNoKCAxIC0gKCBpeSAvIGdyaWRZICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGl5ID0gMDsgaXkgPCBncmlkWTsgaXkgKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGEgPSBpeCArIGdyaWRYMSAqIGl5O1xuXHRcdFx0XHRjb25zdCBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHRjb25zdCBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XG5cdFx0XHRcdGNvbnN0IGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgUGxhbmVHZW9tZXRyeSggZGF0YS53aWR0aCwgZGF0YS5oZWlnaHQsIGRhdGEud2lkdGhTZWdtZW50cywgZGF0YS5oZWlnaHRTZWdtZW50cyApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBSaW5nR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIGlubmVyUmFkaXVzID0gMC41LCBvdXRlclJhZGl1cyA9IDEsIHRoZXRhU2VnbWVudHMgPSAzMiwgcGhpU2VnbWVudHMgPSAxLCB0aGV0YVN0YXJ0ID0gMCwgdGhldGFMZW5ndGggPSBNYXRoLlBJICogMiApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnUmluZ0dlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcblx0XHRcdG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcblx0XHRcdHRoZXRhU2VnbWVudHM6IHRoZXRhU2VnbWVudHMsXG5cdFx0XHRwaGlTZWdtZW50czogcGhpU2VnbWVudHMsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblxuXHRcdHRoZXRhU2VnbWVudHMgPSBNYXRoLm1heCggMywgdGhldGFTZWdtZW50cyApO1xuXHRcdHBoaVNlZ21lbnRzID0gTWF0aC5tYXgoIDEsIHBoaVNlZ21lbnRzICk7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cblx0XHQvLyBzb21lIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGxldCByYWRpdXMgPSBpbm5lclJhZGl1cztcblx0XHRjb25zdCByYWRpdXNTdGVwID0gKCAoIG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMgKSAvIHBoaVNlZ21lbnRzICk7XG5cdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCB1diA9IG5ldyBWZWN0b3IyKCk7XG5cblx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPD0gcGhpU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8PSB0aGV0YVNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdC8vIHZhbHVlcyBhcmUgZ2VuZXJhdGUgZnJvbSB0aGUgaW5zaWRlIG9mIHRoZSByaW5nIHRvIHRoZSBvdXRzaWRlXG5cblx0XHRcdFx0Y29uc3Qgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBpIC8gdGhldGFTZWdtZW50cyAqIHRoZXRhTGVuZ3RoO1xuXG5cdFx0XHRcdC8vIHZlcnRleFxuXG5cdFx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcblx0XHRcdFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goIDAsIDAsIDEgKTtcblxuXHRcdFx0XHQvLyB1dlxuXG5cdFx0XHRcdHV2LnggPSAoIHZlcnRleC54IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyO1xuXHRcdFx0XHR1di55ID0gKCB2ZXJ0ZXgueSAvIG91dGVyUmFkaXVzICsgMSApIC8gMjtcblxuXHRcdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGluY3JlYXNlIHRoZSByYWRpdXMgZm9yIG5leHQgcm93IG9mIHZlcnRpY2VzXG5cblx0XHRcdHJhZGl1cyArPSByYWRpdXNTdGVwO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaW5kaWNlc1xuXG5cdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgcGhpU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRcdGNvbnN0IHRoZXRhU2VnbWVudExldmVsID0gaiAqICggdGhldGFTZWdtZW50cyArIDEgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGhldGFTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBzZWdtZW50ID0gaSArIHRoZXRhU2VnbWVudExldmVsO1xuXG5cdFx0XHRcdGNvbnN0IGEgPSBzZWdtZW50O1xuXHRcdFx0XHRjb25zdCBiID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAxO1xuXHRcdFx0XHRjb25zdCBjID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAyO1xuXHRcdFx0XHRjb25zdCBkID0gc2VnbWVudCArIDE7XG5cblx0XHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgUmluZ0dlb21ldHJ5KCBkYXRhLmlubmVyUmFkaXVzLCBkYXRhLm91dGVyUmFkaXVzLCBkYXRhLnRoZXRhU2VnbWVudHMsIGRhdGEucGhpU2VnbWVudHMsIGRhdGEudGhldGFTdGFydCwgZGF0YS50aGV0YUxlbmd0aCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBTaGFwZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCBzaGFwZXMgPSBuZXcgU2hhcGUoIFsgbmV3IFZlY3RvcjIoIDAsIDAuNSApLCBuZXcgVmVjdG9yMiggLSAwLjUsIC0gMC41ICksIG5ldyBWZWN0b3IyKCAwLjUsIC0gMC41ICkgXSApLCBjdXJ2ZVNlZ21lbnRzID0gMTIgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1NoYXBlR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0c2hhcGVzOiBzaGFwZXMsXG5cdFx0XHRjdXJ2ZVNlZ21lbnRzOiBjdXJ2ZVNlZ21lbnRzXG5cdFx0fTtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGxldCBncm91cFN0YXJ0ID0gMDtcblx0XHRsZXQgZ3JvdXBDb3VudCA9IDA7XG5cblx0XHQvLyBhbGxvdyBzaW5nbGUgYW5kIGFycmF5IHZhbHVlcyBmb3IgXCJzaGFwZXNcIiBwYXJhbWV0ZXJcblxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRhZGRTaGFwZSggc2hhcGVzICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzaGFwZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGFkZFNoYXBlKCBzaGFwZXNbIGkgXSApO1xuXG5cdFx0XHRcdHRoaXMuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIGkgKTsgLy8gZW5hYmxlcyBNdWx0aU1hdGVyaWFsIHN1cHBvcnRcblxuXHRcdFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG5cdFx0XHRcdGdyb3VwQ291bnQgPSAwO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXG5cdFx0Ly8gaGVscGVyIGZ1bmN0aW9uc1xuXG5cdFx0ZnVuY3Rpb24gYWRkU2hhcGUoIHNoYXBlICkge1xuXG5cdFx0XHRjb25zdCBpbmRleE9mZnNldCA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XG5cdFx0XHRjb25zdCBwb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XG5cblx0XHRcdGxldCBzaGFwZVZlcnRpY2VzID0gcG9pbnRzLnNoYXBlO1xuXHRcdFx0Y29uc3Qgc2hhcGVIb2xlcyA9IHBvaW50cy5ob2xlcztcblxuXHRcdFx0Ly8gY2hlY2sgZGlyZWN0aW9uIG9mIHZlcnRpY2VzXG5cblx0XHRcdGlmICggU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggc2hhcGVWZXJ0aWNlcyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRzaGFwZVZlcnRpY2VzID0gc2hhcGVWZXJ0aWNlcy5yZXZlcnNlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc2hhcGVIb2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNoYXBlSG9sZSA9IHNoYXBlSG9sZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIHNoYXBlSG9sZSApID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0c2hhcGVIb2xlc1sgaSBdID0gc2hhcGVIb2xlLnJldmVyc2UoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZmFjZXMgPSBTaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHNoYXBlVmVydGljZXMsIHNoYXBlSG9sZXMgKTtcblxuXHRcdFx0Ly8gam9pbiB2ZXJ0aWNlcyBvZiBpbm5lciBhbmQgb3V0ZXIgcGF0aHMgdG8gYSBzaW5nbGUgYXJyYXlcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc2hhcGVIb2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNoYXBlSG9sZSA9IHNoYXBlSG9sZXNbIGkgXTtcblx0XHRcdFx0c2hhcGVWZXJ0aWNlcyA9IHNoYXBlVmVydGljZXMuY29uY2F0KCBzaGFwZUhvbGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyB2ZXJ0aWNlcywgbm9ybWFscywgdXZzXG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNoYXBlVmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCB2ZXJ0ZXggPSBzaGFwZVZlcnRpY2VzWyBpIF07XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCAwICk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xuXHRcdFx0XHR1dnMucHVzaCggdmVydGV4LngsIHZlcnRleC55ICk7IC8vIHdvcmxkIHV2c1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGluZGljZXNcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdFx0XHRjb25zdCBhID0gZmFjZVsgMCBdICsgaW5kZXhPZmZzZXQ7XG5cdFx0XHRcdGNvbnN0IGIgPSBmYWNlWyAxIF0gKyBpbmRleE9mZnNldDtcblx0XHRcdFx0Y29uc3QgYyA9IGZhY2VbIDIgXSArIGluZGV4T2Zmc2V0O1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgYyApO1xuXHRcdFx0XHRncm91cENvdW50ICs9IDM7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRjb25zdCBzaGFwZXMgPSB0aGlzLnBhcmFtZXRlcnMuc2hhcGVzO1xuXG5cdFx0cmV0dXJuIHRvSlNPTiggc2hhcGVzLCBkYXRhICk7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSwgc2hhcGVzICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnlTaGFwZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBkYXRhLnNoYXBlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbIGRhdGEuc2hhcGVzWyBqIF0gXTtcblxuXHRcdFx0Z2VvbWV0cnlTaGFwZXMucHVzaCggc2hhcGUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgU2hhcGVHZW9tZXRyeSggZ2VvbWV0cnlTaGFwZXMsIGRhdGEuY3VydmVTZWdtZW50cyApO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiB0b0pTT04oIHNoYXBlcywgZGF0YSApIHtcblxuXHRkYXRhLnNoYXBlcyA9IFtdO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbIGkgXTtcblxuXHRcdFx0ZGF0YS5zaGFwZXMucHVzaCggc2hhcGUudXVpZCApO1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRkYXRhLnNoYXBlcy5wdXNoKCBzaGFwZXMudXVpZCApO1xuXG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcblxufVxuXG5jbGFzcyBTcGhlcmVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgd2lkdGhTZWdtZW50cyA9IDMyLCBoZWlnaHRTZWdtZW50cyA9IDE2LCBwaGlTdGFydCA9IDAsIHBoaUxlbmd0aCA9IE1hdGguUEkgKiAyLCB0aGV0YVN0YXJ0ID0gMCwgdGhldGFMZW5ndGggPSBNYXRoLlBJICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdTcGhlcmVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRwaGlTdGFydDogcGhpU3RhcnQsXG5cdFx0XHRwaGlMZW5ndGg6IHBoaUxlbmd0aCxcblx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0XHR9O1xuXG5cdFx0d2lkdGhTZWdtZW50cyA9IE1hdGgubWF4KCAzLCBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgKTtcblx0XHRoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KCAyLCBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApICk7XG5cblx0XHRjb25zdCB0aGV0YUVuZCA9IE1hdGgubWluKCB0aGV0YVN0YXJ0ICsgdGhldGFMZW5ndGgsIE1hdGguUEkgKTtcblxuXHRcdGxldCBpbmRleCA9IDA7XG5cdFx0Y29uc3QgZ3JpZCA9IFtdO1xuXG5cdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0Zm9yICggbGV0IGl5ID0gMDsgaXkgPD0gaGVpZ2h0U2VnbWVudHM7IGl5ICsrICkge1xuXG5cdFx0XHRjb25zdCB2ZXJ0aWNlc1JvdyA9IFtdO1xuXG5cdFx0XHRjb25zdCB2ID0gaXkgLyBoZWlnaHRTZWdtZW50cztcblxuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIGZvciB0aGUgcG9sZXNcblxuXHRcdFx0bGV0IHVPZmZzZXQgPSAwO1xuXG5cdFx0XHRpZiAoIGl5ID09PSAwICYmIHRoZXRhU3RhcnQgPT09IDAgKSB7XG5cblx0XHRcdFx0dU9mZnNldCA9IDAuNSAvIHdpZHRoU2VnbWVudHM7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGl5ID09PSBoZWlnaHRTZWdtZW50cyAmJiB0aGV0YUVuZCA9PT0gTWF0aC5QSSApIHtcblxuXHRcdFx0XHR1T2Zmc2V0ID0gLSAwLjUgLyB3aWR0aFNlZ21lbnRzO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGxldCBpeCA9IDA7IGl4IDw9IHdpZHRoU2VnbWVudHM7IGl4ICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHUgPSBpeCAvIHdpZHRoU2VnbWVudHM7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGV4LnggPSAtIHJhZGl1cyAqIE1hdGguY29zKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG5cdFx0XHRcdHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5jb3MoIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcblx0XHRcdFx0dmVydGV4LnogPSByYWRpdXMgKiBNYXRoLnNpbiggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRub3JtYWwuY29weSggdmVydGV4ICkubm9ybWFsaXplKCk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXZzLnB1c2goIHUgKyB1T2Zmc2V0LCAxIC0gdiApO1xuXG5cdFx0XHRcdHZlcnRpY2VzUm93LnB1c2goIGluZGV4ICsrICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z3JpZC5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaW5kaWNlc1xuXG5cdFx0Zm9yICggbGV0IGl5ID0gMDsgaXkgPCBoZWlnaHRTZWdtZW50czsgaXkgKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpeCA9IDA7IGl4IDwgd2lkdGhTZWdtZW50czsgaXggKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYSA9IGdyaWRbIGl5IF1bIGl4ICsgMSBdO1xuXHRcdFx0XHRjb25zdCBiID0gZ3JpZFsgaXkgXVsgaXggXTtcblx0XHRcdFx0Y29uc3QgYyA9IGdyaWRbIGl5ICsgMSBdWyBpeCBdO1xuXHRcdFx0XHRjb25zdCBkID0gZ3JpZFsgaXkgKyAxIF1bIGl4ICsgMSBdO1xuXG5cdFx0XHRcdGlmICggaXkgIT09IDAgfHwgdGhldGFTdGFydCA+IDAgKSBpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdFx0aWYgKCBpeSAhPT0gaGVpZ2h0U2VnbWVudHMgLSAxIHx8IHRoZXRhRW5kIDwgTWF0aC5QSSApIGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFNwaGVyZUdlb21ldHJ5KCBkYXRhLnJhZGl1cywgZGF0YS53aWR0aFNlZ21lbnRzLCBkYXRhLmhlaWdodFNlZ21lbnRzLCBkYXRhLnBoaVN0YXJ0LCBkYXRhLnBoaUxlbmd0aCwgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFRldHJhaGVkcm9uR2VvbWV0cnkgZXh0ZW5kcyBQb2x5aGVkcm9uR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCBkZXRhaWwgPSAwICkge1xuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXG5cdFx0XHQxLCAxLCAxLCBcdC0gMSwgLSAxLCAxLCBcdC0gMSwgMSwgLSAxLCBcdDEsIC0gMSwgLSAxXG5cdFx0XTtcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXG5cdFx0XHQyLCAxLCAwLCBcdDAsIDMsIDIsXHQxLCAzLCAwLFx0MiwgMywgMVxuXHRcdF07XG5cblx0XHRzdXBlciggdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnVGV0cmFoZWRyb25HZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdGRldGFpbDogZGV0YWlsXG5cdFx0fTtcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBUZXRyYWhlZHJvbkdlb21ldHJ5KCBkYXRhLnJhZGl1cywgZGF0YS5kZXRhaWwgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgVG9ydXNHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgdHViZSA9IDAuNCwgcmFkaWFsU2VnbWVudHMgPSAxMiwgdHVidWxhclNlZ21lbnRzID0gNDgsIGFyYyA9IE1hdGguUEkgKiAyICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdUb3J1c0dlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0dHViZTogdHViZSxcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuXHRcdFx0YXJjOiBhcmNcblx0XHR9O1xuXG5cdFx0cmFkaWFsU2VnbWVudHMgPSBNYXRoLmZsb29yKCByYWRpYWxTZWdtZW50cyApO1xuXHRcdHR1YnVsYXJTZWdtZW50cyA9IE1hdGguZmxvb3IoIHR1YnVsYXJTZWdtZW50cyApO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0Y29uc3QgY2VudGVyID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBhcmM7XG5cdFx0XHRcdGNvbnN0IHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguY29zKCB1ICk7XG5cdFx0XHRcdHZlcnRleC55ID0gKCByYWRpdXMgKyB0dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5zaW4oIHUgKTtcblx0XHRcdFx0dmVydGV4LnogPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0Y2VudGVyLnggPSByYWRpdXMgKiBNYXRoLmNvcyggdSApO1xuXHRcdFx0XHRjZW50ZXIueSA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICk7XG5cdFx0XHRcdG5vcm1hbC5zdWJWZWN0b3JzKCB2ZXJ0ZXgsIGNlbnRlciApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXZzLnB1c2goIGkgLyB0dWJ1bGFyU2VnbWVudHMgKTtcblx0XHRcdFx0dXZzLnB1c2goIGogLyByYWRpYWxTZWdtZW50cyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cblx0XHRmb3IgKCBsZXQgaiA9IDE7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0Ly8gaW5kaWNlc1xuXG5cdFx0XHRcdGNvbnN0IGEgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpIC0gMTtcblx0XHRcdFx0Y29uc3QgYiA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaSAtIDE7XG5cdFx0XHRcdGNvbnN0IGMgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGk7XG5cdFx0XHRcdGNvbnN0IGQgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpO1xuXG5cdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRvcnVzR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLnR1YmUsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEudHVidWxhclNlZ21lbnRzLCBkYXRhLmFyYyApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBUb3J1c0tub3RHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgdHViZSA9IDAuNCwgdHVidWxhclNlZ21lbnRzID0gNjQsIHJhZGlhbFNlZ21lbnRzID0gOCwgcCA9IDIsIHEgPSAzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdUb3J1c0tub3RHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdHR1YmU6IHR1YmUsXG5cdFx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdHA6IHAsXG5cdFx0XHRxOiBxXG5cdFx0fTtcblxuXHRcdHR1YnVsYXJTZWdtZW50cyA9IE1hdGguZmxvb3IoIHR1YnVsYXJTZWdtZW50cyApO1xuXHRcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vciggcmFkaWFsU2VnbWVudHMgKTtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdGNvbnN0IFAxID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBQMiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRjb25zdCBCID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBUID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBOID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7ICsrIGkgKSB7XG5cblx0XHRcdC8vIHRoZSByYWRpYW4gXCJ1XCIgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9uIHRoZSB0b3J1cyBjdXJ2ZSBvZiB0aGUgY3VycmVudCB0dWJ1bGFyIHNlZ21lbnRcblxuXHRcdFx0Y29uc3QgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBwICogTWF0aC5QSSAqIDI7XG5cblx0XHRcdC8vIG5vdyB3ZSBjYWxjdWxhdGUgdHdvIHBvaW50cy4gUDEgaXMgb3VyIGN1cnJlbnQgcG9zaXRpb24gb24gdGhlIGN1cnZlLCBQMiBpcyBhIGxpdHRsZSBmYXJ0aGVyIGFoZWFkLlxuXHRcdFx0Ly8gdGhlc2UgcG9pbnRzIGFyZSB1c2VkIHRvIGNyZWF0ZSBhIHNwZWNpYWwgXCJjb29yZGluYXRlIHNwYWNlXCIsIHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBjYWxjdWxhdGUgdGhlIGNvcnJlY3QgdmVydGV4IHBvc2l0aW9uc1xuXG5cdFx0XHRjYWxjdWxhdGVQb3NpdGlvbk9uQ3VydmUoIHUsIHAsIHEsIHJhZGl1cywgUDEgKTtcblx0XHRcdGNhbGN1bGF0ZVBvc2l0aW9uT25DdXJ2ZSggdSArIDAuMDEsIHAsIHEsIHJhZGl1cywgUDIgKTtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIG9ydGhvbm9ybWFsIGJhc2lzXG5cblx0XHRcdFQuc3ViVmVjdG9ycyggUDIsIFAxICk7XG5cdFx0XHROLmFkZFZlY3RvcnMoIFAyLCBQMSApO1xuXHRcdFx0Qi5jcm9zc1ZlY3RvcnMoIFQsIE4gKTtcblx0XHRcdE4uY3Jvc3NWZWN0b3JzKCBCLCBUICk7XG5cblx0XHRcdC8vIG5vcm1hbGl6ZSBCLCBOLiBUIGNhbiBiZSBpZ25vcmVkLCB3ZSBkb24ndCB1c2UgaXRcblxuXHRcdFx0Qi5ub3JtYWxpemUoKTtcblx0XHRcdE4ubm9ybWFsaXplKCk7XG5cblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgKysgaiApIHtcblxuXHRcdFx0XHQvLyBub3cgY2FsY3VsYXRlIHRoZSB2ZXJ0aWNlcy4gdGhleSBhcmUgbm90aGluZyBtb3JlIHRoYW4gYW4gZXh0cnVzaW9uIG9mIHRoZSB0b3J1cyBjdXJ2ZS5cblx0XHRcdFx0Ly8gYmVjYXVzZSB3ZSBleHRydWRlIGEgc2hhcGUgaW4gdGhlIHh5LXBsYW5lLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGN1bGF0ZSBhIHotdmFsdWUuXG5cblx0XHRcdFx0Y29uc3QgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xuXHRcdFx0XHRjb25zdCBjeCA9IC0gdHViZSAqIE1hdGguY29zKCB2ICk7XG5cdFx0XHRcdGNvbnN0IGN5ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XG5cblx0XHRcdFx0Ly8gbm93IGNhbGN1bGF0ZSB0aGUgZmluYWwgdmVydGV4IHBvc2l0aW9uLlxuXHRcdFx0XHQvLyBmaXJzdCB3ZSBvcmllbnQgdGhlIGV4dHJ1c2lvbiB3aXRoIG91ciBiYXNpcyB2ZWN0b3JzLCB0aGVuIHdlIGFkZCBpdCB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgY3VydmVcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IFAxLnggKyAoIGN4ICogTi54ICsgY3kgKiBCLnggKTtcblx0XHRcdFx0dmVydGV4LnkgPSBQMS55ICsgKCBjeCAqIE4ueSArIGN5ICogQi55ICk7XG5cdFx0XHRcdHZlcnRleC56ID0gUDEueiArICggY3ggKiBOLnogKyBjeSAqIEIueiApO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHQvLyBub3JtYWwgKFAxIGlzIGFsd2F5cyB0aGUgY2VudGVyL29yaWdpbiBvZiB0aGUgZXh0cnVzaW9uLCB0aHVzIHdlIGNhbiB1c2UgaXQgdG8gY2FsY3VsYXRlIHRoZSBub3JtYWwpXG5cblx0XHRcdFx0bm9ybWFsLnN1YlZlY3RvcnMoIHZlcnRleCwgUDEgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuXHRcdFx0XHQvLyB1dlxuXG5cdFx0XHRcdHV2cy5wdXNoKCBpIC8gdHVidWxhclNlZ21lbnRzICk7XG5cdFx0XHRcdHV2cy5wdXNoKCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xuXG5cdFx0Zm9yICggbGV0IGogPSAxOyBqIDw9IHR1YnVsYXJTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IHJhZGlhbFNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdC8vIGluZGljZXNcblxuXHRcdFx0XHRjb25zdCBhID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArICggaSAtIDEgKTtcblx0XHRcdFx0Y29uc3QgYiA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiBqICsgKCBpIC0gMSApO1xuXHRcdFx0XHRjb25zdCBjID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyBpO1xuXHRcdFx0XHRjb25zdCBkID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGk7XG5cblx0XHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdFx0Ly8gdGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSB0b3J1cyBjdXJ2ZVxuXG5cdFx0ZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKCB1LCBwLCBxLCByYWRpdXMsIHBvc2l0aW9uICkge1xuXG5cdFx0XHRjb25zdCBjdSA9IE1hdGguY29zKCB1ICk7XG5cdFx0XHRjb25zdCBzdSA9IE1hdGguc2luKCB1ICk7XG5cdFx0XHRjb25zdCBxdU92ZXJQID0gcSAvIHAgKiB1O1xuXHRcdFx0Y29uc3QgY3MgPSBNYXRoLmNvcyggcXVPdmVyUCApO1xuXG5cdFx0XHRwb3NpdGlvbi54ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIDAuNSAqIGN1O1xuXHRcdFx0cG9zaXRpb24ueSA9IHJhZGl1cyAqICggMiArIGNzICkgKiBzdSAqIDAuNTtcblx0XHRcdHBvc2l0aW9uLnogPSByYWRpdXMgKiBNYXRoLnNpbiggcXVPdmVyUCApICogMC41O1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgVG9ydXNLbm90R2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLnR1YmUsIGRhdGEudHVidWxhclNlZ21lbnRzLCBkYXRhLnJhZGlhbFNlZ21lbnRzLCBkYXRhLnAsIGRhdGEucSApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBUdWJlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHBhdGggPSBuZXcgUXVhZHJhdGljQmV6aWVyQ3VydmUzKCBuZXcgVmVjdG9yMyggLSAxLCAtIDEsIDAgKSwgbmV3IFZlY3RvcjMoIC0gMSwgMSwgMCApLCBuZXcgVmVjdG9yMyggMSwgMSwgMCApICksIHR1YnVsYXJTZWdtZW50cyA9IDY0LCByYWRpdXMgPSAxLCByYWRpYWxTZWdtZW50cyA9IDgsIGNsb3NlZCA9IGZhbHNlICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdUdWJlR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cGF0aDogcGF0aCxcblx0XHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG5cdFx0XHRjbG9zZWQ6IGNsb3NlZFxuXHRcdH07XG5cblx0XHRjb25zdCBmcmFtZXMgPSBwYXRoLmNvbXB1dGVGcmVuZXRGcmFtZXMoIHR1YnVsYXJTZWdtZW50cywgY2xvc2VkICk7XG5cblx0XHQvLyBleHBvc2UgaW50ZXJuYWxzXG5cblx0XHR0aGlzLnRhbmdlbnRzID0gZnJhbWVzLnRhbmdlbnRzO1xuXHRcdHRoaXMubm9ybWFscyA9IGZyYW1lcy5ub3JtYWxzO1xuXHRcdHRoaXMuYmlub3JtYWxzID0gZnJhbWVzLmJpbm9ybWFscztcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCB1diA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0bGV0IFAgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Ly8gYnVmZmVyXG5cblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cblx0XHQvLyBjcmVhdGUgYnVmZmVyIGRhdGFcblxuXHRcdGdlbmVyYXRlQnVmZmVyRGF0YSgpO1xuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0XHQvLyBmdW5jdGlvbnNcblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlQnVmZmVyRGF0YSgpIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdGdlbmVyYXRlU2VnbWVudCggaSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHRoZSBnZW9tZXRyeSBpcyBub3QgY2xvc2VkLCBnZW5lcmF0ZSB0aGUgbGFzdCByb3cgb2YgdmVydGljZXMgYW5kIG5vcm1hbHNcblx0XHRcdC8vIGF0IHRoZSByZWd1bGFyIHBvc2l0aW9uIG9uIHRoZSBnaXZlbiBwYXRoXG5cdFx0XHQvL1xuXHRcdFx0Ly8gaWYgdGhlIGdlb21ldHJ5IGlzIGNsb3NlZCwgZHVwbGljYXRlIHRoZSBmaXJzdCByb3cgb2YgdmVydGljZXMgYW5kIG5vcm1hbHMgKHV2cyB3aWxsIGRpZmZlcilcblxuXHRcdFx0Z2VuZXJhdGVTZWdtZW50KCAoIGNsb3NlZCA9PT0gZmFsc2UgKSA/IHR1YnVsYXJTZWdtZW50cyA6IDAgKTtcblxuXHRcdFx0Ly8gdXZzIGFyZSBnZW5lcmF0ZWQgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbi5cblx0XHRcdC8vIHRoaXMgbWFrZXMgaXQgZWFzeSBjb21wdXRlIGNvcnJlY3QgdmFsdWVzIGZvciBjbG9zZWQgZ2VvbWV0cmllc1xuXG5cdFx0XHRnZW5lcmF0ZVVWcygpO1xuXG5cdFx0XHQvLyBmaW5hbGx5IGNyZWF0ZSBmYWNlc1xuXG5cdFx0XHRnZW5lcmF0ZUluZGljZXMoKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlU2VnbWVudCggaSApIHtcblxuXHRcdFx0Ly8gd2UgdXNlIGdldFBvaW50QXQgdG8gc2FtcGxlIGV2ZW5seSBkaXN0cmlidXRlZCBwb2ludHMgZnJvbSB0aGUgZ2l2ZW4gcGF0aFxuXG5cdFx0XHRQID0gcGF0aC5nZXRQb2ludEF0KCBpIC8gdHVidWxhclNlZ21lbnRzLCBQICk7XG5cblx0XHRcdC8vIHJldHJpZXZlIGNvcnJlc3BvbmRpbmcgbm9ybWFsIGFuZCBiaW5vcm1hbFxuXG5cdFx0XHRjb25zdCBOID0gZnJhbWVzLm5vcm1hbHNbIGkgXTtcblx0XHRcdGNvbnN0IEIgPSBmcmFtZXMuYmlub3JtYWxzWyBpIF07XG5cblx0XHRcdC8vIGdlbmVyYXRlIG5vcm1hbHMgYW5kIHZlcnRpY2VzIGZvciB0aGUgY3VycmVudCBzZWdtZW50XG5cblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0XHRjb25zdCB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cblx0XHRcdFx0Y29uc3Qgc2luID0gTWF0aC5zaW4oIHYgKTtcblx0XHRcdFx0Y29uc3QgY29zID0gLSBNYXRoLmNvcyggdiApO1xuXG5cdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdG5vcm1hbC54ID0gKCBjb3MgKiBOLnggKyBzaW4gKiBCLnggKTtcblx0XHRcdFx0bm9ybWFsLnkgPSAoIGNvcyAqIE4ueSArIHNpbiAqIEIueSApO1xuXHRcdFx0XHRub3JtYWwueiA9ICggY29zICogTi56ICsgc2luICogQi56ICk7XG5cdFx0XHRcdG5vcm1hbC5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IFAueCArIHJhZGl1cyAqIG5vcm1hbC54O1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IFAueSArIHJhZGl1cyAqIG5vcm1hbC55O1xuXHRcdFx0XHR2ZXJ0ZXgueiA9IFAueiArIHJhZGl1cyAqIG5vcm1hbC56O1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVJbmRpY2VzKCkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDE7IGogPD0gdHVidWxhclNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMTsgaSA8PSByYWRpYWxTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGEgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgKCBpIC0gMSApO1xuXHRcdFx0XHRcdGNvbnN0IGIgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogaiArICggaSAtIDEgKTtcblx0XHRcdFx0XHRjb25zdCBjID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyBpO1xuXHRcdFx0XHRcdGNvbnN0IGQgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcblxuXHRcdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlVVZzKCkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0XHRcdHV2LnggPSBpIC8gdHVidWxhclNlZ21lbnRzO1xuXHRcdFx0XHRcdHV2LnkgPSBqIC8gcmFkaWFsU2VnbWVudHM7XG5cblx0XHRcdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGRhdGEucGF0aCA9IHRoaXMucGFyYW1ldGVycy5wYXRoLnRvSlNPTigpO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdC8vIFRoaXMgb25seSB3b3JrcyBmb3IgYnVpbHQtaW4gY3VydmVzIChlLmcuIENhdG11bGxSb21DdXJ2ZTMpLlxuXHRcdC8vIFVzZXIgZGVmaW5lZCBjdXJ2ZXMgb3IgaW5zdGFuY2VzIG9mIEN1cnZlUGF0aCB3aWxsIG5vdCBiZSBkZXNlcmlhbGl6ZWQuXG5cdFx0cmV0dXJuIG5ldyBUdWJlR2VvbWV0cnkoXG5cdFx0XHRuZXcgQ3VydmVzWyBkYXRhLnBhdGgudHlwZSBdKCkuZnJvbUpTT04oIGRhdGEucGF0aCApLFxuXHRcdFx0ZGF0YS50dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRkYXRhLnJhZGl1cyxcblx0XHRcdGRhdGEucmFkaWFsU2VnbWVudHMsXG5cdFx0XHRkYXRhLmNsb3NlZFxuXHRcdCk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFdpcmVmcmFtZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSA9IG51bGwgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1dpcmVmcmFtZUdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeVxuXHRcdH07XG5cblx0XHRpZiAoIGdlb21ldHJ5ICE9PSBudWxsICkge1xuXG5cdFx0XHQvLyBidWZmZXJcblxuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRcdGNvbnN0IGVkZ2VzID0gbmV3IFNldCgpO1xuXG5cdFx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRcdGNvbnN0IHN0YXJ0ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IGVuZCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Ly8gaW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxuXG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdFx0Y29uc3QgaW5kaWNlcyA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHRsZXQgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG5cdFx0XHRcdGlmICggZ3JvdXBzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdGdyb3VwcyA9IFsgeyBzdGFydDogMCwgY291bnQ6IGluZGljZXMuY291bnQsIG1hdGVyaWFsSW5kZXg6IDAgfSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjcmVhdGUgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IGNvbnRhaW5zIGFsbCBlZGdlcyB3aXRob3V0IGR1cGxpY2F0ZXNcblxuXHRcdFx0XHRmb3IgKCBsZXQgbyA9IDAsIG9sID0gZ3JvdXBzLmxlbmd0aDsgbyA8IG9sOyArKyBvICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIG8gXTtcblxuXHRcdFx0XHRcdGNvbnN0IGdyb3VwU3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdFx0XHRjb25zdCBncm91cENvdW50ID0gZ3JvdXAuY291bnQ7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IGdyb3VwU3RhcnQsIGwgPSAoIGdyb3VwU3RhcnQgKyBncm91cENvdW50ICk7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgaW5kZXgxID0gaW5kaWNlcy5nZXRYKCBpICsgaiApO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBpbmRleDIgPSBpbmRpY2VzLmdldFgoIGkgKyAoIGogKyAxICkgJSAzICk7XG5cblx0XHRcdFx0XHRcdFx0c3RhcnQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGluZGV4MSApO1xuXHRcdFx0XHRcdFx0XHRlbmQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGluZGV4MiApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaXNVbmlxdWVFZGdlKCBzdGFydCwgZW5kLCBlZGdlcyApID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCggc3RhcnQueCwgc3RhcnQueSwgc3RhcnQueiApO1xuXHRcdFx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIGVuZC54LCBlbmQueSwgZW5kLnogKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcblxuXHRcdFx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gKCBwb3NpdGlvbi5jb3VudCAvIDMgKTsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHQvLyB0aHJlZSBlZGdlcyBwZXIgdHJpYW5nbGUsIGFuIGVkZ2UgaXMgcmVwcmVzZW50ZWQgYXMgKGluZGV4MSwgaW5kZXgyKVxuXHRcdFx0XHRcdFx0Ly8gZS5nLiB0aGUgZmlyc3QgdHJpYW5nbGUgaGFzIHRoZSBmb2xsb3dpbmcgZWRnZXM6ICgwLDEpLCgxLDIpLCgyLDApXG5cblx0XHRcdFx0XHRcdGNvbnN0IGluZGV4MSA9IDMgKiBpICsgajtcblx0XHRcdFx0XHRcdGNvbnN0IGluZGV4MiA9IDMgKiBpICsgKCAoIGogKyAxICkgJSAzICk7XG5cblx0XHRcdFx0XHRcdHN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpbmRleDEgKTtcblx0XHRcdFx0XHRcdGVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaW5kZXgyICk7XG5cblx0XHRcdFx0XHRcdGlmICggaXNVbmlxdWVFZGdlKCBzdGFydCwgZW5kLCBlZGdlcyApID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHN0YXJ0LngsIHN0YXJ0LnksIHN0YXJ0LnogKTtcblx0XHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCggZW5kLngsIGVuZC55LCBlbmQueiApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIGlzVW5pcXVlRWRnZSggc3RhcnQsIGVuZCwgZWRnZXMgKSB7XG5cblx0Y29uc3QgaGFzaDEgPSBgJHtzdGFydC54fSwke3N0YXJ0Lnl9LCR7c3RhcnQuen0tJHtlbmQueH0sJHtlbmQueX0sJHtlbmQuen1gO1xuXHRjb25zdCBoYXNoMiA9IGAke2VuZC54fSwke2VuZC55fSwke2VuZC56fS0ke3N0YXJ0Lnh9LCR7c3RhcnQueX0sJHtzdGFydC56fWA7IC8vIGNvaW5jaWRlbnQgZWRnZVxuXG5cdGlmICggZWRnZXMuaGFzKCBoYXNoMSApID09PSB0cnVlIHx8IGVkZ2VzLmhhcyggaGFzaDIgKSA9PT0gdHJ1ZSApIHtcblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0ZWRnZXMuYWRkKCBoYXNoMSApO1xuXHRcdGVkZ2VzLmFkZCggaGFzaDIgKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cbn1cblxudmFyIEdlb21ldHJpZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0Qm94R2VvbWV0cnk6IEJveEdlb21ldHJ5LFxuXHRDYXBzdWxlR2VvbWV0cnk6IENhcHN1bGVHZW9tZXRyeSxcblx0Q2lyY2xlR2VvbWV0cnk6IENpcmNsZUdlb21ldHJ5LFxuXHRDb25lR2VvbWV0cnk6IENvbmVHZW9tZXRyeSxcblx0Q3lsaW5kZXJHZW9tZXRyeTogQ3lsaW5kZXJHZW9tZXRyeSxcblx0RG9kZWNhaGVkcm9uR2VvbWV0cnk6IERvZGVjYWhlZHJvbkdlb21ldHJ5LFxuXHRFZGdlc0dlb21ldHJ5OiBFZGdlc0dlb21ldHJ5LFxuXHRFeHRydWRlR2VvbWV0cnk6IEV4dHJ1ZGVHZW9tZXRyeSxcblx0SWNvc2FoZWRyb25HZW9tZXRyeTogSWNvc2FoZWRyb25HZW9tZXRyeSxcblx0TGF0aGVHZW9tZXRyeTogTGF0aGVHZW9tZXRyeSxcblx0T2N0YWhlZHJvbkdlb21ldHJ5OiBPY3RhaGVkcm9uR2VvbWV0cnksXG5cdFBsYW5lR2VvbWV0cnk6IFBsYW5lR2VvbWV0cnksXG5cdFBvbHloZWRyb25HZW9tZXRyeTogUG9seWhlZHJvbkdlb21ldHJ5LFxuXHRSaW5nR2VvbWV0cnk6IFJpbmdHZW9tZXRyeSxcblx0U2hhcGVHZW9tZXRyeTogU2hhcGVHZW9tZXRyeSxcblx0U3BoZXJlR2VvbWV0cnk6IFNwaGVyZUdlb21ldHJ5LFxuXHRUZXRyYWhlZHJvbkdlb21ldHJ5OiBUZXRyYWhlZHJvbkdlb21ldHJ5LFxuXHRUb3J1c0dlb21ldHJ5OiBUb3J1c0dlb21ldHJ5LFxuXHRUb3J1c0tub3RHZW9tZXRyeTogVG9ydXNLbm90R2VvbWV0cnksXG5cdFR1YmVHZW9tZXRyeTogVHViZUdlb21ldHJ5LFxuXHRXaXJlZnJhbWVHZW9tZXRyeTogV2lyZWZyYW1lR2VvbWV0cnlcbn0pO1xuXG5jbGFzcyBTaGFkb3dNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzU2hhZG93TWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1NoYWRvd01hdGVyaWFsJztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XG5cdFx0dGhpcy50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHR0aGlzLmZvZyA9IHRydWU7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY2xhc3MgUmF3U2hhZGVyTWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlciggcGFyYW1ldGVycyApO1xuXG5cdFx0dGhpcy5pc1Jhd1NoYWRlck1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdSYXdTaGFkZXJNYXRlcmlhbCc7XG5cblx0fVxuXG59XG5cbmNsYXNzIE1lc2hTdGFuZGFyZE1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnTWVzaFN0YW5kYXJkTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5kZWZpbmVzID0geyAnU1RBTkRBUkQnOiAnJyB9O1xuXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxuXHRcdHRoaXMucm91Z2huZXNzID0gMS4wO1xuXHRcdHRoaXMubWV0YWxuZXNzID0gMC4wO1xuXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5saWdodE1hcCA9IG51bGw7XG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdHRoaXMuYW9NYXAgPSBudWxsO1xuXHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0XHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXHRcdHRoaXMuYnVtcFNjYWxlID0gMTtcblxuXHRcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XG5cdFx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XG5cblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblxuXHRcdHRoaXMucm91Z2huZXNzTWFwID0gbnVsbDtcblxuXHRcdHRoaXMubWV0YWxuZXNzTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5lbnZNYXAgPSBudWxsO1xuXHRcdHRoaXMuZW52TWFwUm90YXRpb24gPSBuZXcgRXVsZXIoKTtcblx0XHR0aGlzLmVudk1hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cblx0XHR0aGlzLmZsYXRTaGFkaW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLmZvZyA9IHRydWU7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuZGVmaW5lcyA9IHsgJ1NUQU5EQVJEJzogJycgfTtcblxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cdFx0dGhpcy5yb3VnaG5lc3MgPSBzb3VyY2Uucm91Z2huZXNzO1xuXHRcdHRoaXMubWV0YWxuZXNzID0gc291cmNlLm1ldGFsbmVzcztcblxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuXHRcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblxuXHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblxuXHRcdHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcblx0XHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IHNvdXJjZS5ub3JtYWxNYXBUeXBlO1xuXHRcdHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XG5cblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdHRoaXMucm91Z2huZXNzTWFwID0gc291cmNlLnJvdWdobmVzc01hcDtcblxuXHRcdHRoaXMubWV0YWxuZXNzTWFwID0gc291cmNlLm1ldGFsbmVzc01hcDtcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cblx0XHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG5cdFx0dGhpcy5lbnZNYXBSb3RhdGlvbi5jb3B5KCBzb3VyY2UuZW52TWFwUm90YXRpb24gKTtcblx0XHR0aGlzLmVudk1hcEludGVuc2l0eSA9IHNvdXJjZS5lbnZNYXBJbnRlbnNpdHk7XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cblx0XHR0aGlzLmZsYXRTaGFkaW5nID0gc291cmNlLmZsYXRTaGFkaW5nO1xuXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNsYXNzIE1lc2hQaHlzaWNhbE1hdGVyaWFsIGV4dGVuZHMgTWVzaFN0YW5kYXJkTWF0ZXJpYWwge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNNZXNoUGh5c2ljYWxNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLmRlZmluZXMgPSB7XG5cblx0XHRcdCdTVEFOREFSRCc6ICcnLFxuXHRcdFx0J1BIWVNJQ0FMJzogJydcblxuXHRcdH07XG5cblx0XHR0aGlzLnR5cGUgPSAnTWVzaFBoeXNpY2FsTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5hbmlzb3Ryb3B5Um90YXRpb24gPSAwO1xuXHRcdHRoaXMuYW5pc290cm9weU1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmNsZWFyY29hdE1hcCA9IG51bGw7XG5cdFx0dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3MgPSAwLjA7XG5cdFx0dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPSBudWxsO1xuXHRcdHRoaXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xuXHRcdHRoaXMuY2xlYXJjb2F0Tm9ybWFsTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuaW9yID0gMS41O1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAncmVmbGVjdGl2aXR5Jywge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0cmV0dXJuICggY2xhbXAoIDIuNSAqICggdGhpcy5pb3IgLSAxICkgLyAoIHRoaXMuaW9yICsgMSApLCAwLCAxICkgKTtcblxuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKCByZWZsZWN0aXZpdHkgKSB7XG5cblx0XHRcdFx0dGhpcy5pb3IgPSAoIDEgKyAwLjQgKiByZWZsZWN0aXZpdHkgKSAvICggMSAtIDAuNCAqIHJlZmxlY3Rpdml0eSApO1xuXG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0dGhpcy5pcmlkZXNjZW5jZU1hcCA9IG51bGw7XG5cdFx0dGhpcy5pcmlkZXNjZW5jZUlPUiA9IDEuMztcblx0XHR0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgPSBbIDEwMCwgNDAwIF07XG5cdFx0dGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCA9IG51bGw7XG5cblx0XHR0aGlzLnNoZWVuQ29sb3IgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XG5cdFx0dGhpcy5zaGVlbkNvbG9yTWFwID0gbnVsbDtcblx0XHR0aGlzLnNoZWVuUm91Z2huZXNzID0gMS4wO1xuXHRcdHRoaXMuc2hlZW5Sb3VnaG5lc3NNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy50cmFuc21pc3Npb25NYXAgPSBudWxsO1xuXG5cdFx0dGhpcy50aGlja25lc3MgPSAwO1xuXHRcdHRoaXMudGhpY2tuZXNzTWFwID0gbnVsbDtcblx0XHR0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBJbmZpbml0eTtcblx0XHR0aGlzLmF0dGVudWF0aW9uQ29sb3IgPSBuZXcgQ29sb3IoIDEsIDEsIDEgKTtcblxuXHRcdHRoaXMuc3BlY3VsYXJJbnRlbnNpdHkgPSAxLjA7XG5cdFx0dGhpcy5zcGVjdWxhckludGVuc2l0eU1hcCA9IG51bGw7XG5cdFx0dGhpcy5zcGVjdWxhckNvbG9yID0gbmV3IENvbG9yKCAxLCAxLCAxICk7XG5cdFx0dGhpcy5zcGVjdWxhckNvbG9yTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuX2FuaXNvdHJvcHkgPSAwO1xuXHRcdHRoaXMuX2NsZWFyY29hdCA9IDA7XG5cdFx0dGhpcy5fZGlzcGVyc2lvbiA9IDA7XG5cdFx0dGhpcy5faXJpZGVzY2VuY2UgPSAwO1xuXHRcdHRoaXMuX3NoZWVuID0gMC4wO1xuXHRcdHRoaXMuX3RyYW5zbWlzc2lvbiA9IDA7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRnZXQgYW5pc290cm9weSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9hbmlzb3Ryb3B5O1xuXG5cdH1cblxuXHRzZXQgYW5pc290cm9weSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2FuaXNvdHJvcHkgPiAwICE9PSB2YWx1ZSA+IDAgKSB7XG5cblx0XHRcdHRoaXMudmVyc2lvbiArKztcblxuXHRcdH1cblxuXHRcdHRoaXMuX2FuaXNvdHJvcHkgPSB2YWx1ZTtcblxuXHR9XG5cblx0Z2V0IGNsZWFyY29hdCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9jbGVhcmNvYXQ7XG5cblx0fVxuXG5cdHNldCBjbGVhcmNvYXQoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzLl9jbGVhcmNvYXQgPiAwICE9PSB2YWx1ZSA+IDAgKSB7XG5cblx0XHRcdHRoaXMudmVyc2lvbiArKztcblxuXHRcdH1cblxuXHRcdHRoaXMuX2NsZWFyY29hdCA9IHZhbHVlO1xuXG5cdH1cblxuXHRnZXQgaXJpZGVzY2VuY2UoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5faXJpZGVzY2VuY2U7XG5cblx0fVxuXG5cdHNldCBpcmlkZXNjZW5jZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2lyaWRlc2NlbmNlID4gMCAhPT0gdmFsdWUgPiAwICkge1xuXG5cdFx0XHR0aGlzLnZlcnNpb24gKys7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9pcmlkZXNjZW5jZSA9IHZhbHVlO1xuXG5cdH1cblxuXHRnZXQgZGlzcGVyc2lvbigpIHtcblxuXHRcdHJldHVybiB0aGlzLl9kaXNwZXJzaW9uO1xuXG5cdH1cblxuXHRzZXQgZGlzcGVyc2lvbiggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2Rpc3BlcnNpb24gPiAwICE9PSB2YWx1ZSA+IDAgKSB7XG5cblx0XHRcdHRoaXMudmVyc2lvbiArKztcblxuXHRcdH1cblxuXHRcdHRoaXMuX2Rpc3BlcnNpb24gPSB2YWx1ZTtcblxuXHR9XG5cblx0Z2V0IHNoZWVuKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3NoZWVuO1xuXG5cdH1cblxuXHRzZXQgc2hlZW4oIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzLl9zaGVlbiA+IDAgIT09IHZhbHVlID4gMCApIHtcblxuXHRcdFx0dGhpcy52ZXJzaW9uICsrO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fc2hlZW4gPSB2YWx1ZTtcblxuXHR9XG5cblx0Z2V0IHRyYW5zbWlzc2lvbigpIHtcblxuXHRcdHJldHVybiB0aGlzLl90cmFuc21pc3Npb247XG5cblx0fVxuXG5cdHNldCB0cmFuc21pc3Npb24oIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzLl90cmFuc21pc3Npb24gPiAwICE9PSB2YWx1ZSA+IDAgKSB7XG5cblx0XHRcdHRoaXMudmVyc2lvbiArKztcblxuXHRcdH1cblxuXHRcdHRoaXMuX3RyYW5zbWlzc2lvbiA9IHZhbHVlO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuZGVmaW5lcyA9IHtcblxuXHRcdFx0J1NUQU5EQVJEJzogJycsXG5cdFx0XHQnUEhZU0lDQUwnOiAnJ1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuYW5pc290cm9weSA9IHNvdXJjZS5hbmlzb3Ryb3B5O1xuXHRcdHRoaXMuYW5pc290cm9weVJvdGF0aW9uID0gc291cmNlLmFuaXNvdHJvcHlSb3RhdGlvbjtcblx0XHR0aGlzLmFuaXNvdHJvcHlNYXAgPSBzb3VyY2UuYW5pc290cm9weU1hcDtcblxuXHRcdHRoaXMuY2xlYXJjb2F0ID0gc291cmNlLmNsZWFyY29hdDtcblx0XHR0aGlzLmNsZWFyY29hdE1hcCA9IHNvdXJjZS5jbGVhcmNvYXRNYXA7XG5cdFx0dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3MgPSBzb3VyY2UuY2xlYXJjb2F0Um91Z2huZXNzO1xuXHRcdHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwID0gc291cmNlLmNsZWFyY29hdFJvdWdobmVzc01hcDtcblx0XHR0aGlzLmNsZWFyY29hdE5vcm1hbE1hcCA9IHNvdXJjZS5jbGVhcmNvYXROb3JtYWxNYXA7XG5cdFx0dGhpcy5jbGVhcmNvYXROb3JtYWxTY2FsZS5jb3B5KCBzb3VyY2UuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgKTtcblxuXHRcdHRoaXMuZGlzcGVyc2lvbiA9IHNvdXJjZS5kaXNwZXJzaW9uO1xuXHRcdHRoaXMuaW9yID0gc291cmNlLmlvcjtcblxuXHRcdHRoaXMuaXJpZGVzY2VuY2UgPSBzb3VyY2UuaXJpZGVzY2VuY2U7XG5cdFx0dGhpcy5pcmlkZXNjZW5jZU1hcCA9IHNvdXJjZS5pcmlkZXNjZW5jZU1hcDtcblx0XHR0aGlzLmlyaWRlc2NlbmNlSU9SID0gc291cmNlLmlyaWRlc2NlbmNlSU9SO1xuXHRcdHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9IFsgLi4uc291cmNlLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgXTtcblx0XHR0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwID0gc291cmNlLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwO1xuXG5cdFx0dGhpcy5zaGVlbiA9IHNvdXJjZS5zaGVlbjtcblx0XHR0aGlzLnNoZWVuQ29sb3IuY29weSggc291cmNlLnNoZWVuQ29sb3IgKTtcblx0XHR0aGlzLnNoZWVuQ29sb3JNYXAgPSBzb3VyY2Uuc2hlZW5Db2xvck1hcDtcblx0XHR0aGlzLnNoZWVuUm91Z2huZXNzID0gc291cmNlLnNoZWVuUm91Z2huZXNzO1xuXHRcdHRoaXMuc2hlZW5Sb3VnaG5lc3NNYXAgPSBzb3VyY2Uuc2hlZW5Sb3VnaG5lc3NNYXA7XG5cblx0XHR0aGlzLnRyYW5zbWlzc2lvbiA9IHNvdXJjZS50cmFuc21pc3Npb247XG5cdFx0dGhpcy50cmFuc21pc3Npb25NYXAgPSBzb3VyY2UudHJhbnNtaXNzaW9uTWFwO1xuXG5cdFx0dGhpcy50aGlja25lc3MgPSBzb3VyY2UudGhpY2tuZXNzO1xuXHRcdHRoaXMudGhpY2tuZXNzTWFwID0gc291cmNlLnRoaWNrbmVzc01hcDtcblx0XHR0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBzb3VyY2UuYXR0ZW51YXRpb25EaXN0YW5jZTtcblx0XHR0aGlzLmF0dGVudWF0aW9uQ29sb3IuY29weSggc291cmNlLmF0dGVudWF0aW9uQ29sb3IgKTtcblxuXHRcdHRoaXMuc3BlY3VsYXJJbnRlbnNpdHkgPSBzb3VyY2Uuc3BlY3VsYXJJbnRlbnNpdHk7XG5cdFx0dGhpcy5zcGVjdWxhckludGVuc2l0eU1hcCA9IHNvdXJjZS5zcGVjdWxhckludGVuc2l0eU1hcDtcblx0XHR0aGlzLnNwZWN1bGFyQ29sb3IuY29weSggc291cmNlLnNwZWN1bGFyQ29sb3IgKTtcblx0XHR0aGlzLnNwZWN1bGFyQ29sb3JNYXAgPSBzb3VyY2Uuc3BlY3VsYXJDb2xvck1hcDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBNZXNoUGhvbmdNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzTWVzaFBob25nTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ01lc2hQaG9uZ01hdGVyaWFsJztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2Vcblx0XHR0aGlzLnNwZWN1bGFyID0gbmV3IENvbG9yKCAweDExMTExMSApO1xuXHRcdHRoaXMuc2hpbmluZXNzID0gMzA7XG5cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0dGhpcy5hb01hcCA9IG51bGw7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuYnVtcE1hcCA9IG51bGw7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSAxO1xuXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcblx0XHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuZW52TWFwID0gbnVsbDtcblx0XHR0aGlzLmVudk1hcFJvdGF0aW9uID0gbmV3IEV1bGVyKCk7XG5cblx0XHR0aGlzLmNvbWJpbmUgPSBNdWx0aXBseU9wZXJhdGlvbjtcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBmYWxzZTtcblxuXHRcdHRoaXMuZm9nID0gdHJ1ZTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblx0XHR0aGlzLnNwZWN1bGFyLmNvcHkoIHNvdXJjZS5zcGVjdWxhciApO1xuXHRcdHRoaXMuc2hpbmluZXNzID0gc291cmNlLnNoaW5pbmVzcztcblxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuXHRcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblxuXHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblxuXHRcdHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcblx0XHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IHNvdXJjZS5ub3JtYWxNYXBUeXBlO1xuXHRcdHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XG5cblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xuXHRcdHRoaXMuZW52TWFwUm90YXRpb24uY29weSggc291cmNlLmVudk1hcFJvdGF0aW9uICk7XG5cdFx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XG5cdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xuXHRcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcblxuXHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblxuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBzb3VyY2UuZmxhdFNoYWRpbmc7XG5cblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY2xhc3MgTWVzaFRvb25NYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzTWVzaFRvb25NYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLmRlZmluZXMgPSB7ICdUT09OJzogJycgfTtcblxuXHRcdHRoaXMudHlwZSA9ICdNZXNoVG9vbk1hdGVyaWFsJztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XG5cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cdFx0dGhpcy5ncmFkaWVudE1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0dGhpcy5hb01hcCA9IG51bGw7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuYnVtcE1hcCA9IG51bGw7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSAxO1xuXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcblx0XHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXHRcdHRoaXMuZ3JhZGllbnRNYXAgPSBzb3VyY2UuZ3JhZGllbnRNYXA7XG5cblx0XHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XG5cblx0XHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xuXHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG5cblx0XHR0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xuXHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcblxuXHRcdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xuXHRcdHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcblxuXHRcdHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcblx0XHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5ub3JtYWxTY2FsZSApO1xuXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNsYXNzIE1lc2hOb3JtYWxNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzTWVzaE5vcm1hbE1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdNZXNoTm9ybWFsTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5idW1wTWFwID0gbnVsbDtcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cblx0XHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XG5cdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gVGFuZ2VudFNwYWNlTm9ybWFsTWFwO1xuXHRcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xuXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBmYWxzZTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IHNvdXJjZS5ub3JtYWxNYXBUeXBlO1xuXHRcdHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XG5cblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cblx0XHR0aGlzLmZsYXRTaGFkaW5nID0gc291cmNlLmZsYXRTaGFkaW5nO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNsYXNzIE1lc2hMYW1iZXJ0TWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxuXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5saWdodE1hcCA9IG51bGw7XG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdHRoaXMuYW9NYXAgPSBudWxsO1xuXHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0XHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXHRcdHRoaXMuYnVtcFNjYWxlID0gMTtcblxuXHRcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XG5cdFx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XG5cblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblxuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdFx0dGhpcy5lbnZNYXBSb3RhdGlvbiA9IG5ldyBFdWxlcigpO1xuXHRcdHRoaXMuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xuXHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XG5cblx0XHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cblx0XHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG5cdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gc291cmNlLm5vcm1hbE1hcFR5cGU7XG5cdFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cblx0XHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG5cdFx0dGhpcy5lbnZNYXBSb3RhdGlvbi5jb3B5KCBzb3VyY2UuZW52TWFwUm90YXRpb24gKTtcblx0XHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IHNvdXJjZS5mbGF0U2hhZGluZztcblxuXHRcdHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBNZXNoRGVwdGhNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzTWVzaERlcHRoTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ01lc2hEZXB0aE1hdGVyaWFsJztcblxuXHRcdHRoaXMuZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc7XG5cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuZGVwdGhQYWNraW5nID0gc291cmNlLmRlcHRoUGFja2luZztcblxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY2xhc3MgTWVzaERpc3RhbmNlTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc01lc2hEaXN0YW5jZU1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdNZXNoRGlzdGFuY2VNYXRlcmlhbCc7XG5cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY2xhc3MgTWVzaE1hdGNhcE1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNNZXNoTWF0Y2FwTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy5kZWZpbmVzID0geyAnTUFUQ0FQJzogJycgfTtcblxuXHRcdHRoaXMudHlwZSA9ICdNZXNoTWF0Y2FwTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxuXG5cdFx0dGhpcy5tYXRjYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5idW1wTWFwID0gbnVsbDtcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cblx0XHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XG5cdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gVGFuZ2VudFNwYWNlTm9ybWFsTWFwO1xuXHRcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xuXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBmYWxzZTtcblxuXHRcdHRoaXMuZm9nID0gdHJ1ZTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmRlZmluZXMgPSB7ICdNQVRDQVAnOiAnJyB9O1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuXHRcdHRoaXMubWF0Y2FwID0gc291cmNlLm1hdGNhcDtcblxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuXHRcdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xuXHRcdHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcblxuXHRcdHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcblx0XHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5ub3JtYWxTY2FsZSApO1xuXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IHNvdXJjZS5mbGF0U2hhZGluZztcblxuXHRcdHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBMaW5lRGFzaGVkTWF0ZXJpYWwgZXh0ZW5kcyBMaW5lQmFzaWNNYXRlcmlhbCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0xpbmVEYXNoZWRNYXRlcmlhbCA9IHRydWU7XG5cdFx0dGhpcy50eXBlID0gJ0xpbmVEYXNoZWRNYXRlcmlhbCc7XG5cblx0XHR0aGlzLnNjYWxlID0gMTtcblx0XHR0aGlzLmRhc2hTaXplID0gMztcblx0XHR0aGlzLmdhcFNpemUgPSAxO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnNjYWxlID0gc291cmNlLnNjYWxlO1xuXHRcdHRoaXMuZGFzaFNpemUgPSBzb3VyY2UuZGFzaFNpemU7XG5cdFx0dGhpcy5nYXBTaXplID0gc291cmNlLmdhcFNpemU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuLy8gY29udmVydHMgYW4gYXJyYXkgdG8gYSBzcGVjaWZpYyB0eXBlXG5mdW5jdGlvbiBjb252ZXJ0QXJyYXkoIGFycmF5LCB0eXBlLCBmb3JjZUNsb25lICkge1xuXG5cdGlmICggISBhcnJheSB8fCAvLyBsZXQgJ3VuZGVmaW5lZCcgYW5kICdudWxsJyBwYXNzXG5cdFx0ISBmb3JjZUNsb25lICYmIGFycmF5LmNvbnN0cnVjdG9yID09PSB0eXBlICkgcmV0dXJuIGFycmF5O1xuXG5cdGlmICggdHlwZW9mIHR5cGUuQllURVNfUEVSX0VMRU1FTlQgPT09ICdudW1iZXInICkge1xuXG5cdFx0cmV0dXJuIG5ldyB0eXBlKCBhcnJheSApOyAvLyBjcmVhdGUgdHlwZWQgYXJyYXlcblxuXHR9XG5cblx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcnJheSApOyAvLyBjcmVhdGUgQXJyYXlcblxufVxuXG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkoIG9iamVjdCApIHtcblxuXHRyZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KCBvYmplY3QgKSAmJlxuXHRcdCEgKCBvYmplY3QgaW5zdGFuY2VvZiBEYXRhVmlldyApO1xuXG59XG5cbi8vIHJldHVybnMgYW4gYXJyYXkgYnkgd2hpY2ggdGltZXMgYW5kIHZhbHVlcyBjYW4gYmUgc29ydGVkXG5mdW5jdGlvbiBnZXRLZXlmcmFtZU9yZGVyKCB0aW1lcyApIHtcblxuXHRmdW5jdGlvbiBjb21wYXJlVGltZSggaSwgaiApIHtcblxuXHRcdHJldHVybiB0aW1lc1sgaSBdIC0gdGltZXNbIGogXTtcblxuXHR9XG5cblx0Y29uc3QgbiA9IHRpbWVzLmxlbmd0aDtcblx0Y29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KCBuICk7XG5cdGZvciAoIGxldCBpID0gMDsgaSAhPT0gbjsgKysgaSApIHJlc3VsdFsgaSBdID0gaTtcblxuXHRyZXN1bHQuc29ydCggY29tcGFyZVRpbWUgKTtcblxuXHRyZXR1cm4gcmVzdWx0O1xuXG59XG5cbi8vIHVzZXMgdGhlIGFycmF5IHByZXZpb3VzbHkgcmV0dXJuZWQgYnkgJ2dldEtleWZyYW1lT3JkZXInIHRvIHNvcnQgZGF0YVxuZnVuY3Rpb24gc29ydGVkQXJyYXkoIHZhbHVlcywgc3RyaWRlLCBvcmRlciApIHtcblxuXHRjb25zdCBuVmFsdWVzID0gdmFsdWVzLmxlbmd0aDtcblx0Y29uc3QgcmVzdWx0ID0gbmV3IHZhbHVlcy5jb25zdHJ1Y3RvciggblZhbHVlcyApO1xuXG5cdGZvciAoIGxldCBpID0gMCwgZHN0T2Zmc2V0ID0gMDsgZHN0T2Zmc2V0ICE9PSBuVmFsdWVzOyArKyBpICkge1xuXG5cdFx0Y29uc3Qgc3JjT2Zmc2V0ID0gb3JkZXJbIGkgXSAqIHN0cmlkZTtcblxuXHRcdGZvciAoIGxldCBqID0gMDsgaiAhPT0gc3RyaWRlOyArKyBqICkge1xuXG5cdFx0XHRyZXN1bHRbIGRzdE9mZnNldCArKyBdID0gdmFsdWVzWyBzcmNPZmZzZXQgKyBqIF07XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG5cbn1cblxuLy8gZnVuY3Rpb24gZm9yIHBhcnNpbmcgQU9TIGtleWZyYW1lIGZvcm1hdHNcbmZ1bmN0aW9uIGZsYXR0ZW5KU09OKCBqc29uS2V5cywgdGltZXMsIHZhbHVlcywgdmFsdWVQcm9wZXJ0eU5hbWUgKSB7XG5cblx0bGV0IGkgPSAxLCBrZXkgPSBqc29uS2V5c1sgMCBdO1xuXG5cdHdoaWxlICgga2V5ICE9PSB1bmRlZmluZWQgJiYga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xuXG5cdH1cblxuXHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuOyAvLyBubyBkYXRhXG5cblx0bGV0IHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xuXHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSByZXR1cm47IC8vIG5vIGRhdGFcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cblx0XHRkbyB7XG5cblx0XHRcdHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xuXG5cdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGltZXMucHVzaCgga2V5LnRpbWUgKTtcblx0XHRcdFx0dmFsdWVzLnB1c2guYXBwbHkoIHZhbHVlcywgdmFsdWUgKTsgLy8gcHVzaCBhbGwgZWxlbWVudHNcblxuXHRcdFx0fVxuXG5cdFx0XHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xuXG5cdFx0fSB3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICk7XG5cblx0fSBlbHNlIGlmICggdmFsdWUudG9BcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0Ly8gLi4uYXNzdW1lIFRIUkVFLk1hdGgtaXNoXG5cblx0XHRkbyB7XG5cblx0XHRcdHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xuXG5cdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGltZXMucHVzaCgga2V5LnRpbWUgKTtcblx0XHRcdFx0dmFsdWUudG9BcnJheSggdmFsdWVzLCB2YWx1ZXMubGVuZ3RoICk7XG5cblx0XHRcdH1cblxuXHRcdFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcblxuXHRcdH0gd2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBvdGhlcndpc2UgcHVzaCBhcy1pc1xuXG5cdFx0ZG8ge1xuXG5cdFx0XHR2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcblxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRpbWVzLnB1c2goIGtleS50aW1lICk7XG5cdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGtleSA9IGpzb25LZXlzWyBpICsrIF07XG5cblx0XHR9IHdoaWxlICgga2V5ICE9PSB1bmRlZmluZWQgKTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gc3ViY2xpcCggc291cmNlQ2xpcCwgbmFtZSwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIGZwcyA9IDMwICkge1xuXG5cdGNvbnN0IGNsaXAgPSBzb3VyY2VDbGlwLmNsb25lKCk7XG5cblx0Y2xpcC5uYW1lID0gbmFtZTtcblxuXHRjb25zdCB0cmFja3MgPSBbXTtcblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjbGlwLnRyYWNrcy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRjb25zdCB0cmFjayA9IGNsaXAudHJhY2tzWyBpIF07XG5cdFx0Y29uc3QgdmFsdWVTaXplID0gdHJhY2suZ2V0VmFsdWVTaXplKCk7XG5cblx0XHRjb25zdCB0aW1lcyA9IFtdO1xuXHRcdGNvbnN0IHZhbHVlcyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgdHJhY2sudGltZXMubGVuZ3RoOyArKyBqICkge1xuXG5cdFx0XHRjb25zdCBmcmFtZSA9IHRyYWNrLnRpbWVzWyBqIF0gKiBmcHM7XG5cblx0XHRcdGlmICggZnJhbWUgPCBzdGFydEZyYW1lIHx8IGZyYW1lID49IGVuZEZyYW1lICkgY29udGludWU7XG5cblx0XHRcdHRpbWVzLnB1c2goIHRyYWNrLnRpbWVzWyBqIF0gKTtcblxuXHRcdFx0Zm9yICggbGV0IGsgPSAwOyBrIDwgdmFsdWVTaXplOyArKyBrICkge1xuXG5cdFx0XHRcdHZhbHVlcy5wdXNoKCB0cmFjay52YWx1ZXNbIGogKiB2YWx1ZVNpemUgKyBrIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aW1lcy5sZW5ndGggPT09IDAgKSBjb250aW51ZTtcblxuXHRcdHRyYWNrLnRpbWVzID0gY29udmVydEFycmF5KCB0aW1lcywgdHJhY2sudGltZXMuY29uc3RydWN0b3IgKTtcblx0XHR0cmFjay52YWx1ZXMgPSBjb252ZXJ0QXJyYXkoIHZhbHVlcywgdHJhY2sudmFsdWVzLmNvbnN0cnVjdG9yICk7XG5cblx0XHR0cmFja3MucHVzaCggdHJhY2sgKTtcblxuXHR9XG5cblx0Y2xpcC50cmFja3MgPSB0cmFja3M7XG5cblx0Ly8gZmluZCBtaW5pbXVtIC50aW1lcyB2YWx1ZSBhY3Jvc3MgYWxsIHRyYWNrcyBpbiB0aGUgdHJpbW1lZCBjbGlwXG5cblx0bGV0IG1pblN0YXJ0VGltZSA9IEluZmluaXR5O1xuXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IGNsaXAudHJhY2tzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdGlmICggbWluU3RhcnRUaW1lID4gY2xpcC50cmFja3NbIGkgXS50aW1lc1sgMCBdICkge1xuXG5cdFx0XHRtaW5TdGFydFRpbWUgPSBjbGlwLnRyYWNrc1sgaSBdLnRpbWVzWyAwIF07XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIHNoaWZ0IGFsbCB0cmFja3Mgc3VjaCB0aGF0IGNsaXAgYmVnaW5zIGF0IHQ9MFxuXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IGNsaXAudHJhY2tzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdGNsaXAudHJhY2tzWyBpIF0uc2hpZnQoIC0gMSAqIG1pblN0YXJ0VGltZSApO1xuXG5cdH1cblxuXHRjbGlwLnJlc2V0RHVyYXRpb24oKTtcblxuXHRyZXR1cm4gY2xpcDtcblxufVxuXG5mdW5jdGlvbiBtYWtlQ2xpcEFkZGl0aXZlKCB0YXJnZXRDbGlwLCByZWZlcmVuY2VGcmFtZSA9IDAsIHJlZmVyZW5jZUNsaXAgPSB0YXJnZXRDbGlwLCBmcHMgPSAzMCApIHtcblxuXHRpZiAoIGZwcyA8PSAwICkgZnBzID0gMzA7XG5cblx0Y29uc3QgbnVtVHJhY2tzID0gcmVmZXJlbmNlQ2xpcC50cmFja3MubGVuZ3RoO1xuXHRjb25zdCByZWZlcmVuY2VUaW1lID0gcmVmZXJlbmNlRnJhbWUgLyBmcHM7XG5cblx0Ly8gTWFrZSBlYWNoIHRyYWNrJ3MgdmFsdWVzIHJlbGF0aXZlIHRvIHRoZSB2YWx1ZXMgYXQgdGhlIHJlZmVyZW5jZSBmcmFtZVxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBudW1UcmFja3M7ICsrIGkgKSB7XG5cblx0XHRjb25zdCByZWZlcmVuY2VUcmFjayA9IHJlZmVyZW5jZUNsaXAudHJhY2tzWyBpIF07XG5cdFx0Y29uc3QgcmVmZXJlbmNlVHJhY2tUeXBlID0gcmVmZXJlbmNlVHJhY2suVmFsdWVUeXBlTmFtZTtcblxuXHRcdC8vIFNraXAgdGhpcyB0cmFjayBpZiBpdCdzIG5vbi1udW1lcmljXG5cdFx0aWYgKCByZWZlcmVuY2VUcmFja1R5cGUgPT09ICdib29sJyB8fCByZWZlcmVuY2VUcmFja1R5cGUgPT09ICdzdHJpbmcnICkgY29udGludWU7XG5cblx0XHQvLyBGaW5kIHRoZSB0cmFjayBpbiB0aGUgdGFyZ2V0IGNsaXAgd2hvc2UgbmFtZSBhbmQgdHlwZSBtYXRjaGVzIHRoZSByZWZlcmVuY2UgdHJhY2tcblx0XHRjb25zdCB0YXJnZXRUcmFjayA9IHRhcmdldENsaXAudHJhY2tzLmZpbmQoIGZ1bmN0aW9uICggdHJhY2sgKSB7XG5cblx0XHRcdHJldHVybiB0cmFjay5uYW1lID09PSByZWZlcmVuY2VUcmFjay5uYW1lXG5cdFx0XHRcdCYmIHRyYWNrLlZhbHVlVHlwZU5hbWUgPT09IHJlZmVyZW5jZVRyYWNrVHlwZTtcblxuXHRcdH0gKTtcblxuXHRcdGlmICggdGFyZ2V0VHJhY2sgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG5cdFx0bGV0IHJlZmVyZW5jZU9mZnNldCA9IDA7XG5cdFx0Y29uc3QgcmVmZXJlbmNlVmFsdWVTaXplID0gcmVmZXJlbmNlVHJhY2suZ2V0VmFsdWVTaXplKCk7XG5cblx0XHRpZiAoIHJlZmVyZW5jZVRyYWNrLmNyZWF0ZUludGVycG9sYW50LmlzSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lICkge1xuXG5cdFx0XHRyZWZlcmVuY2VPZmZzZXQgPSByZWZlcmVuY2VWYWx1ZVNpemUgLyAzO1xuXG5cdFx0fVxuXG5cdFx0bGV0IHRhcmdldE9mZnNldCA9IDA7XG5cdFx0Y29uc3QgdGFyZ2V0VmFsdWVTaXplID0gdGFyZ2V0VHJhY2suZ2V0VmFsdWVTaXplKCk7XG5cblx0XHRpZiAoIHRhcmdldFRyYWNrLmNyZWF0ZUludGVycG9sYW50LmlzSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lICkge1xuXG5cdFx0XHR0YXJnZXRPZmZzZXQgPSB0YXJnZXRWYWx1ZVNpemUgLyAzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgbGFzdEluZGV4ID0gcmVmZXJlbmNlVHJhY2sudGltZXMubGVuZ3RoIC0gMTtcblx0XHRsZXQgcmVmZXJlbmNlVmFsdWU7XG5cblx0XHQvLyBGaW5kIHRoZSB2YWx1ZSB0byBzdWJ0cmFjdCBvdXQgb2YgdGhlIHRyYWNrXG5cdFx0aWYgKCByZWZlcmVuY2VUaW1lIDw9IHJlZmVyZW5jZVRyYWNrLnRpbWVzWyAwIF0gKSB7XG5cblx0XHRcdC8vIFJlZmVyZW5jZSBmcmFtZSBpcyBlYXJsaWVyIHRoYW4gdGhlIGZpcnN0IGtleWZyYW1lLCBzbyBqdXN0IHVzZSB0aGUgZmlyc3Qga2V5ZnJhbWVcblx0XHRcdGNvbnN0IHN0YXJ0SW5kZXggPSByZWZlcmVuY2VPZmZzZXQ7XG5cdFx0XHRjb25zdCBlbmRJbmRleCA9IHJlZmVyZW5jZVZhbHVlU2l6ZSAtIHJlZmVyZW5jZU9mZnNldDtcblx0XHRcdHJlZmVyZW5jZVZhbHVlID0gcmVmZXJlbmNlVHJhY2sudmFsdWVzLnNsaWNlKCBzdGFydEluZGV4LCBlbmRJbmRleCApO1xuXG5cdFx0fSBlbHNlIGlmICggcmVmZXJlbmNlVGltZSA+PSByZWZlcmVuY2VUcmFjay50aW1lc1sgbGFzdEluZGV4IF0gKSB7XG5cblx0XHRcdC8vIFJlZmVyZW5jZSBmcmFtZSBpcyBhZnRlciB0aGUgbGFzdCBrZXlmcmFtZSwgc28ganVzdCB1c2UgdGhlIGxhc3Qga2V5ZnJhbWVcblx0XHRcdGNvbnN0IHN0YXJ0SW5kZXggPSBsYXN0SW5kZXggKiByZWZlcmVuY2VWYWx1ZVNpemUgKyByZWZlcmVuY2VPZmZzZXQ7XG5cdFx0XHRjb25zdCBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyByZWZlcmVuY2VWYWx1ZVNpemUgLSByZWZlcmVuY2VPZmZzZXQ7XG5cdFx0XHRyZWZlcmVuY2VWYWx1ZSA9IHJlZmVyZW5jZVRyYWNrLnZhbHVlcy5zbGljZSggc3RhcnRJbmRleCwgZW5kSW5kZXggKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEludGVycG9sYXRlIHRvIHRoZSByZWZlcmVuY2UgdmFsdWVcblx0XHRcdGNvbnN0IGludGVycG9sYW50ID0gcmVmZXJlbmNlVHJhY2suY3JlYXRlSW50ZXJwb2xhbnQoKTtcblx0XHRcdGNvbnN0IHN0YXJ0SW5kZXggPSByZWZlcmVuY2VPZmZzZXQ7XG5cdFx0XHRjb25zdCBlbmRJbmRleCA9IHJlZmVyZW5jZVZhbHVlU2l6ZSAtIHJlZmVyZW5jZU9mZnNldDtcblx0XHRcdGludGVycG9sYW50LmV2YWx1YXRlKCByZWZlcmVuY2VUaW1lICk7XG5cdFx0XHRyZWZlcmVuY2VWYWx1ZSA9IGludGVycG9sYW50LnJlc3VsdEJ1ZmZlci5zbGljZSggc3RhcnRJbmRleCwgZW5kSW5kZXggKTtcblxuXHRcdH1cblxuXHRcdC8vIENvbmp1Z2F0ZSB0aGUgcXVhdGVybmlvblxuXHRcdGlmICggcmVmZXJlbmNlVHJhY2tUeXBlID09PSAncXVhdGVybmlvbicgKSB7XG5cblx0XHRcdGNvbnN0IHJlZmVyZW5jZVF1YXQgPSBuZXcgUXVhdGVybmlvbigpLmZyb21BcnJheSggcmVmZXJlbmNlVmFsdWUgKS5ub3JtYWxpemUoKS5jb25qdWdhdGUoKTtcblx0XHRcdHJlZmVyZW5jZVF1YXQudG9BcnJheSggcmVmZXJlbmNlVmFsdWUgKTtcblxuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHRoZSByZWZlcmVuY2UgdmFsdWUgZnJvbSBhbGwgb2YgdGhlIHRyYWNrIHZhbHVlc1xuXG5cdFx0Y29uc3QgbnVtVGltZXMgPSB0YXJnZXRUcmFjay50aW1lcy5sZW5ndGg7XG5cdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgbnVtVGltZXM7ICsrIGogKSB7XG5cblx0XHRcdGNvbnN0IHZhbHVlU3RhcnQgPSBqICogdGFyZ2V0VmFsdWVTaXplICsgdGFyZ2V0T2Zmc2V0O1xuXG5cdFx0XHRpZiAoIHJlZmVyZW5jZVRyYWNrVHlwZSA9PT0gJ3F1YXRlcm5pb24nICkge1xuXG5cdFx0XHRcdC8vIE11bHRpcGx5IHRoZSBjb25qdWdhdGUgZm9yIHF1YXRlcm5pb24gdHJhY2sgdHlwZXNcblx0XHRcdFx0UXVhdGVybmlvbi5tdWx0aXBseVF1YXRlcm5pb25zRmxhdChcblx0XHRcdFx0XHR0YXJnZXRUcmFjay52YWx1ZXMsXG5cdFx0XHRcdFx0dmFsdWVTdGFydCxcblx0XHRcdFx0XHRyZWZlcmVuY2VWYWx1ZSxcblx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdHRhcmdldFRyYWNrLnZhbHVlcyxcblx0XHRcdFx0XHR2YWx1ZVN0YXJ0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgdmFsdWVFbmQgPSB0YXJnZXRWYWx1ZVNpemUgLSB0YXJnZXRPZmZzZXQgKiAyO1xuXG5cdFx0XHRcdC8vIFN1YnRyYWN0IGVhY2ggdmFsdWUgZm9yIGFsbCBvdGhlciBudW1lcmljIHRyYWNrIHR5cGVzXG5cdFx0XHRcdGZvciAoIGxldCBrID0gMDsgayA8IHZhbHVlRW5kOyArKyBrICkge1xuXG5cdFx0XHRcdFx0dGFyZ2V0VHJhY2sudmFsdWVzWyB2YWx1ZVN0YXJ0ICsgayBdIC09IHJlZmVyZW5jZVZhbHVlWyBrIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHRhcmdldENsaXAuYmxlbmRNb2RlID0gQWRkaXRpdmVBbmltYXRpb25CbGVuZE1vZGU7XG5cblx0cmV0dXJuIHRhcmdldENsaXA7XG5cbn1cblxuY29uc3QgQW5pbWF0aW9uVXRpbHMgPSB7XG5cdGNvbnZlcnRBcnJheTogY29udmVydEFycmF5LFxuXHRpc1R5cGVkQXJyYXk6IGlzVHlwZWRBcnJheSxcblx0Z2V0S2V5ZnJhbWVPcmRlcjogZ2V0S2V5ZnJhbWVPcmRlcixcblx0c29ydGVkQXJyYXk6IHNvcnRlZEFycmF5LFxuXHRmbGF0dGVuSlNPTjogZmxhdHRlbkpTT04sXG5cdHN1YmNsaXA6IHN1YmNsaXAsXG5cdG1ha2VDbGlwQWRkaXRpdmU6IG1ha2VDbGlwQWRkaXRpdmVcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBvZiBpbnRlcnBvbGFudHMgb3ZlciBwYXJhbWV0cmljIHNhbXBsZXMuXG4gKlxuICogVGhlIHBhcmFtZXRlciBkb21haW4gaXMgb25lIGRpbWVuc2lvbmFsLCB0eXBpY2FsbHkgdGhlIHRpbWUgb3IgYSBwYXRoXG4gKiBhbG9uZyBhIGN1cnZlIGRlZmluZWQgYnkgdGhlIGRhdGEuXG4gKlxuICogVGhlIHNhbXBsZSB2YWx1ZXMgY2FuIGhhdmUgYW55IGRpbWVuc2lvbmFsaXR5IGFuZCBkZXJpdmVkIGNsYXNzZXMgbWF5XG4gKiBhcHBseSBzcGVjaWFsIGludGVycHJldGF0aW9ucyB0byB0aGUgZGF0YS5cbiAqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIHRoZSBpbnRlcnZhbCBzZWVrIGluIGEgVGVtcGxhdGUgTWV0aG9kLCBkZWZlcnJpbmdcbiAqIHRoZSBhY3R1YWwgaW50ZXJwb2xhdGlvbiB0byBkZXJpdmVkIGNsYXNzZXMuXG4gKlxuICogVGltZSBjb21wbGV4aXR5IGlzIE8oMSkgZm9yIGxpbmVhciBhY2Nlc3MgY3Jvc3NpbmcgYXQgbW9zdCB0d28gcG9pbnRzXG4gKiBhbmQgTyhsb2cgTikgZm9yIHJhbmRvbSBhY2Nlc3MsIHdoZXJlIE4gaXMgdGhlIG51bWJlciBvZiBwb3NpdGlvbnMuXG4gKlxuICogUmVmZXJlbmNlczpcbiAqXG4gKiBcdFx0aHR0cDovL3d3dy5vb2Rlc2lnbi5jb20vdGVtcGxhdGUtbWV0aG9kLXBhdHRlcm4uaHRtbFxuICpcbiAqL1xuXG5jbGFzcyBJbnRlcnBvbGFudCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XG5cblx0XHR0aGlzLnBhcmFtZXRlclBvc2l0aW9ucyA9IHBhcmFtZXRlclBvc2l0aW9ucztcblx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IDA7XG5cblx0XHR0aGlzLnJlc3VsdEJ1ZmZlciA9IHJlc3VsdEJ1ZmZlciAhPT0gdW5kZWZpbmVkID9cblx0XHRcdHJlc3VsdEJ1ZmZlciA6IG5ldyBzYW1wbGVWYWx1ZXMuY29uc3RydWN0b3IoIHNhbXBsZVNpemUgKTtcblx0XHR0aGlzLnNhbXBsZVZhbHVlcyA9IHNhbXBsZVZhbHVlcztcblx0XHR0aGlzLnZhbHVlU2l6ZSA9IHNhbXBsZVNpemU7XG5cblx0XHR0aGlzLnNldHRpbmdzID0gbnVsbDtcblx0XHR0aGlzLkRlZmF1bHRTZXR0aW5nc18gPSB7fTtcblxuXHR9XG5cblx0ZXZhbHVhdGUoIHQgKSB7XG5cblx0XHRjb25zdCBwcCA9IHRoaXMucGFyYW1ldGVyUG9zaXRpb25zO1xuXHRcdGxldCBpMSA9IHRoaXMuX2NhY2hlZEluZGV4LFxuXHRcdFx0dDEgPSBwcFsgaTEgXSxcblx0XHRcdHQwID0gcHBbIGkxIC0gMSBdO1xuXG5cdFx0dmFsaWRhdGVfaW50ZXJ2YWw6IHtcblxuXHRcdFx0c2Vlazoge1xuXG5cdFx0XHRcdGxldCByaWdodDtcblxuXHRcdFx0XHRsaW5lYXJfc2Nhbjoge1xuXG5cdFx0XHRcdFx0Ly8tIFNlZSBodHRwOi8vanNwZXJmLmNvbS9jb21wYXJpc29uLXRvLXVuZGVmaW5lZC8zXG5cdFx0XHRcdFx0Ly8tIHNsb3dlciBjb2RlOlxuXHRcdFx0XHRcdC8vLVxuXHRcdFx0XHRcdC8vLSBcdFx0XHRcdGlmICggdCA+PSB0MSB8fCB0MSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGZvcndhcmRfc2NhbjogaWYgKCAhICggdCA8IHQxICkgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBnaXZlVXBBdCA9IGkxICsgMjsgOyApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHQxID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHQgPCB0MCApIGJyZWFrIGZvcndhcmRfc2NhbjtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIGFmdGVyIGVuZFxuXG5cdFx0XHRcdFx0XHRcdFx0aTEgPSBwcC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSBpMTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jb3B5U2FtcGxlVmFsdWVfKCBpMSAtIDEgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBpMSA9PT0gZ2l2ZVVwQXQgKSBicmVhazsgLy8gdGhpcyBsb29wXG5cblx0XHRcdFx0XHRcdFx0dDAgPSB0MTtcblx0XHRcdFx0XHRcdFx0dDEgPSBwcFsgKysgaTEgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHQgPCB0MSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIHdlIGhhdmUgYXJyaXZlZCBhdCB0aGUgc291Z2h0IGludGVydmFsXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWsgc2VlaztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gcHJlcGFyZSBiaW5hcnkgc2VhcmNoIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBpbmRleFxuXHRcdFx0XHRcdFx0cmlnaHQgPSBwcC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRicmVhayBsaW5lYXJfc2NhbjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vLSBzbG93ZXIgY29kZTpcblx0XHRcdFx0XHQvLy1cdFx0XHRcdFx0aWYgKCB0IDwgdDAgfHwgdDAgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRpZiAoICEgKCB0ID49IHQwICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGxvb3Bpbmc/XG5cblx0XHRcdFx0XHRcdGNvbnN0IHQxZ2xvYmFsID0gcHBbIDEgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCB0IDwgdDFnbG9iYWwgKSB7XG5cblx0XHRcdFx0XHRcdFx0aTEgPSAyOyAvLyArIDEsIHVzaW5nIHRoZSBzY2FuIGZvciB0aGUgZGV0YWlsc1xuXHRcdFx0XHRcdFx0XHR0MCA9IHQxZ2xvYmFsO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGxpbmVhciByZXZlcnNlIHNjYW5cblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGdpdmVVcEF0ID0gaTEgLSAyOyA7ICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdDAgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIGJlZm9yZSBzdGFydFxuXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmNvcHlTYW1wbGVWYWx1ZV8oIDAgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBpMSA9PT0gZ2l2ZVVwQXQgKSBicmVhazsgLy8gdGhpcyBsb29wXG5cblx0XHRcdFx0XHRcdFx0dDEgPSB0MDtcblx0XHRcdFx0XHRcdFx0dDAgPSBwcFsgLS0gaTEgLSAxIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0ID49IHQwICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gd2UgaGF2ZSBhcnJpdmVkIGF0IHRoZSBzb3VnaHQgaW50ZXJ2YWxcblx0XHRcdFx0XHRcdFx0XHRicmVhayBzZWVrO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBwcmVwYXJlIGJpbmFyeSBzZWFyY2ggb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgaW5kZXhcblx0XHRcdFx0XHRcdHJpZ2h0ID0gaTE7XG5cdFx0XHRcdFx0XHRpMSA9IDA7XG5cdFx0XHRcdFx0XHRicmVhayBsaW5lYXJfc2NhbjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHRoZSBpbnRlcnZhbCBpcyB2YWxpZFxuXG5cdFx0XHRcdFx0YnJlYWsgdmFsaWRhdGVfaW50ZXJ2YWw7XG5cblx0XHRcdFx0fSAvLyBsaW5lYXIgc2NhblxuXG5cdFx0XHRcdC8vIGJpbmFyeSBzZWFyY2hcblxuXHRcdFx0XHR3aGlsZSAoIGkxIDwgcmlnaHQgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBtaWQgPSAoIGkxICsgcmlnaHQgKSA+Pj4gMTtcblxuXHRcdFx0XHRcdGlmICggdCA8IHBwWyBtaWQgXSApIHtcblxuXHRcdFx0XHRcdFx0cmlnaHQgPSBtaWQ7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRpMSA9IG1pZCArIDE7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHQxID0gcHBbIGkxIF07XG5cdFx0XHRcdHQwID0gcHBbIGkxIC0gMSBdO1xuXG5cdFx0XHRcdC8vIGNoZWNrIGJvdW5kYXJ5IGNhc2VzLCBhZ2FpblxuXG5cdFx0XHRcdGlmICggdDAgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jb3B5U2FtcGxlVmFsdWVfKCAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdDEgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGkxID0gcHAubGVuZ3RoO1xuXHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gaTE7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuY29weVNhbXBsZVZhbHVlXyggaTEgLSAxICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IC8vIHNlZWtcblxuXHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSBpMTtcblxuXHRcdFx0dGhpcy5pbnRlcnZhbENoYW5nZWRfKCBpMSwgdDAsIHQxICk7XG5cblx0XHR9IC8vIHZhbGlkYXRlX2ludGVydmFsXG5cblx0XHRyZXR1cm4gdGhpcy5pbnRlcnBvbGF0ZV8oIGkxLCB0MCwgdCwgdDEgKTtcblxuXHR9XG5cblx0Z2V0U2V0dGluZ3NfKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0dGluZ3MgfHwgdGhpcy5EZWZhdWx0U2V0dGluZ3NfO1xuXG5cdH1cblxuXHRjb3B5U2FtcGxlVmFsdWVfKCBpbmRleCApIHtcblxuXHRcdC8vIGNvcGllcyBhIHNhbXBsZSB2YWx1ZSB0byB0aGUgcmVzdWx0IGJ1ZmZlclxuXG5cdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXHRcdFx0b2Zmc2V0ID0gaW5kZXggKiBzdHJpZGU7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcblxuXHRcdFx0cmVzdWx0WyBpIF0gPSB2YWx1ZXNbIG9mZnNldCArIGkgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG5cdC8vIFRlbXBsYXRlIG1ldGhvZHMgZm9yIGRlcml2ZWQgY2xhc3NlczpcblxuXHRpbnRlcnBvbGF0ZV8oIC8qIGkxLCB0MCwgdCwgdDEgKi8gKSB7XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoICdjYWxsIHRvIGFic3RyYWN0IG1ldGhvZCcgKTtcblx0XHQvLyBpbXBsZW1lbnRhdGlvbnMgc2hhbGwgcmV0dXJuIHRoaXMucmVzdWx0QnVmZmVyXG5cblx0fVxuXG5cdGludGVydmFsQ2hhbmdlZF8oIC8qIGkxLCB0MCwgdDEgKi8gKSB7XG5cblx0XHQvLyBlbXB0eVxuXG5cdH1cblxufVxuXG4vKipcbiAqIEZhc3QgYW5kIHNpbXBsZSBjdWJpYyBzcGxpbmUgaW50ZXJwb2xhbnQuXG4gKlxuICogSXQgd2FzIGRlcml2ZWQgZnJvbSBhIEhlcm1pdGlhbiBjb25zdHJ1Y3Rpb24gc2V0dGluZyB0aGUgZmlyc3QgZGVyaXZhdGl2ZVxuICogYXQgZWFjaCBzYW1wbGUgcG9zaXRpb24gdG8gdGhlIGxpbmVhciBzbG9wZSBiZXR3ZWVuIG5laWdoYm9yaW5nIHBvc2l0aW9uc1xuICogb3ZlciB0aGVpciBwYXJhbWV0ZXIgaW50ZXJ2YWwuXG4gKi9cblxuY2xhc3MgQ3ViaWNJbnRlcnBvbGFudCBleHRlbmRzIEludGVycG9sYW50IHtcblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcblxuXHRcdHN1cGVyKCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XG5cblx0XHR0aGlzLl93ZWlnaHRQcmV2ID0gLSAwO1xuXHRcdHRoaXMuX29mZnNldFByZXYgPSAtIDA7XG5cdFx0dGhpcy5fd2VpZ2h0TmV4dCA9IC0gMDtcblx0XHR0aGlzLl9vZmZzZXROZXh0ID0gLSAwO1xuXG5cdFx0dGhpcy5EZWZhdWx0U2V0dGluZ3NfID0ge1xuXG5cdFx0XHRlbmRpbmdTdGFydDogWmVyb0N1cnZhdHVyZUVuZGluZyxcblx0XHRcdGVuZGluZ0VuZDogWmVyb0N1cnZhdHVyZUVuZGluZ1xuXG5cdFx0fTtcblxuXHR9XG5cblx0aW50ZXJ2YWxDaGFuZ2VkXyggaTEsIHQwLCB0MSApIHtcblxuXHRcdGNvbnN0IHBwID0gdGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnM7XG5cdFx0bGV0IGlQcmV2ID0gaTEgLSAyLFxuXHRcdFx0aU5leHQgPSBpMSArIDEsXG5cblx0XHRcdHRQcmV2ID0gcHBbIGlQcmV2IF0sXG5cdFx0XHR0TmV4dCA9IHBwWyBpTmV4dCBdO1xuXG5cdFx0aWYgKCB0UHJldiA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRzd2l0Y2ggKCB0aGlzLmdldFNldHRpbmdzXygpLmVuZGluZ1N0YXJ0ICkge1xuXG5cdFx0XHRcdGNhc2UgWmVyb1Nsb3BlRW5kaW5nOlxuXG5cdFx0XHRcdFx0Ly8gZicodDApID0gMFxuXHRcdFx0XHRcdGlQcmV2ID0gaTE7XG5cdFx0XHRcdFx0dFByZXYgPSAyICogdDAgLSB0MTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgV3JhcEFyb3VuZEVuZGluZzpcblxuXHRcdFx0XHRcdC8vIHVzZSB0aGUgb3RoZXIgZW5kIG9mIHRoZSBjdXJ2ZVxuXHRcdFx0XHRcdGlQcmV2ID0gcHAubGVuZ3RoIC0gMjtcblx0XHRcdFx0XHR0UHJldiA9IHQwICsgcHBbIGlQcmV2IF0gLSBwcFsgaVByZXYgKyAxIF07XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OiAvLyBaZXJvQ3VydmF0dXJlRW5kaW5nXG5cblx0XHRcdFx0XHQvLyBmJycodDApID0gMCBhLmsuYS4gTmF0dXJhbCBTcGxpbmVcblx0XHRcdFx0XHRpUHJldiA9IGkxO1xuXHRcdFx0XHRcdHRQcmV2ID0gdDE7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdE5leHQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0c3dpdGNoICggdGhpcy5nZXRTZXR0aW5nc18oKS5lbmRpbmdFbmQgKSB7XG5cblx0XHRcdFx0Y2FzZSBaZXJvU2xvcGVFbmRpbmc6XG5cblx0XHRcdFx0XHQvLyBmJyh0TikgPSAwXG5cdFx0XHRcdFx0aU5leHQgPSBpMTtcblx0XHRcdFx0XHR0TmV4dCA9IDIgKiB0MSAtIHQwO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBXcmFwQXJvdW5kRW5kaW5nOlxuXG5cdFx0XHRcdFx0Ly8gdXNlIHRoZSBvdGhlciBlbmQgb2YgdGhlIGN1cnZlXG5cdFx0XHRcdFx0aU5leHQgPSAxO1xuXHRcdFx0XHRcdHROZXh0ID0gdDEgKyBwcFsgMSBdIC0gcHBbIDAgXTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6IC8vIFplcm9DdXJ2YXR1cmVFbmRpbmdcblxuXHRcdFx0XHRcdC8vIGYnJyh0TikgPSAwLCBhLmsuYS4gTmF0dXJhbCBTcGxpbmVcblx0XHRcdFx0XHRpTmV4dCA9IGkxIC0gMTtcblx0XHRcdFx0XHR0TmV4dCA9IHQwO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zdCBoYWxmRHQgPSAoIHQxIC0gdDAgKSAqIDAuNSxcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplO1xuXG5cdFx0dGhpcy5fd2VpZ2h0UHJldiA9IGhhbGZEdCAvICggdDAgLSB0UHJldiApO1xuXHRcdHRoaXMuX3dlaWdodE5leHQgPSBoYWxmRHQgLyAoIHROZXh0IC0gdDEgKTtcblx0XHR0aGlzLl9vZmZzZXRQcmV2ID0gaVByZXYgKiBzdHJpZGU7XG5cdFx0dGhpcy5fb2Zmc2V0TmV4dCA9IGlOZXh0ICogc3RyaWRlO1xuXG5cdH1cblxuXHRpbnRlcnBvbGF0ZV8oIGkxLCB0MCwgdCwgdDEgKSB7XG5cblx0XHRjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcblx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cblx0XHRcdG8xID0gaTEgKiBzdHJpZGUsXHRcdG8wID0gbzEgLSBzdHJpZGUsXG5cdFx0XHRvUCA9IHRoaXMuX29mZnNldFByZXYsIFx0b04gPSB0aGlzLl9vZmZzZXROZXh0LFxuXHRcdFx0d1AgPSB0aGlzLl93ZWlnaHRQcmV2LFx0d04gPSB0aGlzLl93ZWlnaHROZXh0LFxuXG5cdFx0XHRwID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApLFxuXHRcdFx0cHAgPSBwICogcCxcblx0XHRcdHBwcCA9IHBwICogcDtcblxuXHRcdC8vIGV2YWx1YXRlIHBvbHlub21pYWxzXG5cblx0XHRjb25zdCBzUCA9IC0gd1AgKiBwcHAgKyAyICogd1AgKiBwcCAtIHdQICogcDtcblx0XHRjb25zdCBzMCA9ICggMSArIHdQICkgKiBwcHAgKyAoIC0gMS41IC0gMiAqIHdQICkgKiBwcCArICggLSAwLjUgKyB3UCApICogcCArIDE7XG5cdFx0Y29uc3QgczEgPSAoIC0gMSAtIHdOICkgKiBwcHAgKyAoIDEuNSArIHdOICkgKiBwcCArIDAuNSAqIHA7XG5cdFx0Y29uc3Qgc04gPSB3TiAqIHBwcCAtIHdOICogcHA7XG5cblx0XHQvLyBjb21iaW5lIGRhdGEgbGluZWFybHlcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xuXG5cdFx0XHRyZXN1bHRbIGkgXSA9XG5cdFx0XHRcdFx0c1AgKiB2YWx1ZXNbIG9QICsgaSBdICtcblx0XHRcdFx0XHRzMCAqIHZhbHVlc1sgbzAgKyBpIF0gK1xuXHRcdFx0XHRcdHMxICogdmFsdWVzWyBvMSArIGkgXSArXG5cdFx0XHRcdFx0c04gKiB2YWx1ZXNbIG9OICsgaSBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cbn1cblxuY2xhc3MgTGluZWFySW50ZXJwb2xhbnQgZXh0ZW5kcyBJbnRlcnBvbGFudCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XG5cblx0XHRzdXBlciggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xuXG5cdH1cblxuXHRpbnRlcnBvbGF0ZV8oIGkxLCB0MCwgdCwgdDEgKSB7XG5cblx0XHRjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcblx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cblx0XHRcdG9mZnNldDEgPSBpMSAqIHN0cmlkZSxcblx0XHRcdG9mZnNldDAgPSBvZmZzZXQxIC0gc3RyaWRlLFxuXG5cdFx0XHR3ZWlnaHQxID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApLFxuXHRcdFx0d2VpZ2h0MCA9IDEgLSB3ZWlnaHQxO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cblx0XHRcdHJlc3VsdFsgaSBdID1cblx0XHRcdFx0XHR2YWx1ZXNbIG9mZnNldDAgKyBpIF0gKiB3ZWlnaHQwICtcblx0XHRcdFx0XHR2YWx1ZXNbIG9mZnNldDEgKyBpIF0gKiB3ZWlnaHQxO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cbn1cblxuLyoqXG4gKlxuICogSW50ZXJwb2xhbnQgdGhhdCBldmFsdWF0ZXMgdG8gdGhlIHNhbXBsZSB2YWx1ZSBhdCB0aGUgcG9zaXRpb24gcHJlY2VkaW5nXG4gKiB0aGUgcGFyYW1ldGVyLlxuICovXG5cbmNsYXNzIERpc2NyZXRlSW50ZXJwb2xhbnQgZXh0ZW5kcyBJbnRlcnBvbGFudCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XG5cblx0XHRzdXBlciggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xuXG5cdH1cblxuXHRpbnRlcnBvbGF0ZV8oIGkxIC8qLCB0MCwgdCwgdDEgKi8gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jb3B5U2FtcGxlVmFsdWVfKCBpMSAtIDEgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgS2V5ZnJhbWVUcmFjayB7XG5cblx0Y29uc3RydWN0b3IoIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XG5cblx0XHRpZiAoIG5hbWUgPT09IHVuZGVmaW5lZCApIHRocm93IG5ldyBFcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IHRyYWNrIG5hbWUgaXMgdW5kZWZpbmVkJyApO1xuXHRcdGlmICggdGltZXMgPT09IHVuZGVmaW5lZCB8fCB0aW1lcy5sZW5ndGggPT09IDAgKSB0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBubyBrZXlmcmFtZXMgaW4gdHJhY2sgbmFtZWQgJyArIG5hbWUgKTtcblxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cblx0XHR0aGlzLnRpbWVzID0gY29udmVydEFycmF5KCB0aW1lcywgdGhpcy5UaW1lQnVmZmVyVHlwZSApO1xuXHRcdHRoaXMudmFsdWVzID0gY29udmVydEFycmF5KCB2YWx1ZXMsIHRoaXMuVmFsdWVCdWZmZXJUeXBlICk7XG5cblx0XHR0aGlzLnNldEludGVycG9sYXRpb24oIGludGVycG9sYXRpb24gfHwgdGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbiApO1xuXG5cdH1cblxuXHQvLyBTZXJpYWxpemF0aW9uIChpbiBzdGF0aWMgY29udGV4dCwgYmVjYXVzZSBvZiBjb25zdHJ1Y3RvciBpbnZvY2F0aW9uXG5cdC8vIGFuZCBhdXRvbWF0aWMgaW52b2NhdGlvbiBvZiAudG9KU09OKTpcblxuXHRzdGF0aWMgdG9KU09OKCB0cmFjayApIHtcblxuXHRcdGNvbnN0IHRyYWNrVHlwZSA9IHRyYWNrLmNvbnN0cnVjdG9yO1xuXG5cdFx0bGV0IGpzb247XG5cblx0XHQvLyBkZXJpdmVkIGNsYXNzZXMgY2FuIGRlZmluZSBhIHN0YXRpYyB0b0pTT04gbWV0aG9kXG5cdFx0aWYgKCB0cmFja1R5cGUudG9KU09OICE9PSB0aGlzLnRvSlNPTiApIHtcblxuXHRcdFx0anNvbiA9IHRyYWNrVHlwZS50b0pTT04oIHRyYWNrICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBieSBkZWZhdWx0LCB3ZSBhc3N1bWUgdGhlIGRhdGEgY2FuIGJlIHNlcmlhbGl6ZWQgYXMtaXNcblx0XHRcdGpzb24gPSB7XG5cblx0XHRcdFx0J25hbWUnOiB0cmFjay5uYW1lLFxuXHRcdFx0XHQndGltZXMnOiBjb252ZXJ0QXJyYXkoIHRyYWNrLnRpbWVzLCBBcnJheSApLFxuXHRcdFx0XHQndmFsdWVzJzogY29udmVydEFycmF5KCB0cmFjay52YWx1ZXMsIEFycmF5IClcblxuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgaW50ZXJwb2xhdGlvbiA9IHRyYWNrLmdldEludGVycG9sYXRpb24oKTtcblxuXHRcdFx0aWYgKCBpbnRlcnBvbGF0aW9uICE9PSB0cmFjay5EZWZhdWx0SW50ZXJwb2xhdGlvbiApIHtcblxuXHRcdFx0XHRqc29uLmludGVycG9sYXRpb24gPSBpbnRlcnBvbGF0aW9uO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRqc29uLnR5cGUgPSB0cmFjay5WYWx1ZVR5cGVOYW1lOyAvLyBtYW5kYXRvcnlcblxuXHRcdHJldHVybiBqc29uO1xuXG5cdH1cblxuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZSggcmVzdWx0ICkge1xuXG5cdFx0cmV0dXJuIG5ldyBEaXNjcmV0ZUludGVycG9sYW50KCB0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XG5cblx0fVxuXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhciggcmVzdWx0ICkge1xuXG5cdFx0cmV0dXJuIG5ldyBMaW5lYXJJbnRlcnBvbGFudCggdGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xuXG5cdH1cblxuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGgoIHJlc3VsdCApIHtcblxuXHRcdHJldHVybiBuZXcgQ3ViaWNJbnRlcnBvbGFudCggdGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xuXG5cdH1cblxuXHRzZXRJbnRlcnBvbGF0aW9uKCBpbnRlcnBvbGF0aW9uICkge1xuXG5cdFx0bGV0IGZhY3RvcnlNZXRob2Q7XG5cblx0XHRzd2l0Y2ggKCBpbnRlcnBvbGF0aW9uICkge1xuXG5cdFx0XHRjYXNlIEludGVycG9sYXRlRGlzY3JldGU6XG5cblx0XHRcdFx0ZmFjdG9yeU1ldGhvZCA9IHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGU7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgSW50ZXJwb2xhdGVMaW5lYXI6XG5cblx0XHRcdFx0ZmFjdG9yeU1ldGhvZCA9IHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIEludGVycG9sYXRlU21vb3RoOlxuXG5cdFx0XHRcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHRcdGlmICggZmFjdG9yeU1ldGhvZCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBtZXNzYWdlID0gJ3Vuc3VwcG9ydGVkIGludGVycG9sYXRpb24gZm9yICcgK1xuXHRcdFx0XHR0aGlzLlZhbHVlVHlwZU5hbWUgKyAnIGtleWZyYW1lIHRyYWNrIG5hbWVkICcgKyB0aGlzLm5hbWU7XG5cblx0XHRcdGlmICggdGhpcy5jcmVhdGVJbnRlcnBvbGFudCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIGZhbGwgYmFjayB0byBkZWZhdWx0LCB1bmxlc3MgdGhlIGRlZmF1bHQgaXRzZWxmIGlzIG1lc3NlZCB1cFxuXHRcdFx0XHRpZiAoIGludGVycG9sYXRpb24gIT09IHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKSB7XG5cblx0XHRcdFx0XHR0aGlzLnNldEludGVycG9sYXRpb24oIHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtZXNzYWdlICk7IC8vIGZhdGFsLCBpbiB0aGlzIGNhc2VcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazonLCBtZXNzYWdlICk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQgPSBmYWN0b3J5TWV0aG9kO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldEludGVycG9sYXRpb24oKSB7XG5cblx0XHRzd2l0Y2ggKCB0aGlzLmNyZWF0ZUludGVycG9sYW50ICkge1xuXG5cdFx0XHRjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGU6XG5cblx0XHRcdFx0cmV0dXJuIEludGVycG9sYXRlRGlzY3JldGU7XG5cblx0XHRcdGNhc2UgdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6XG5cblx0XHRcdFx0cmV0dXJuIEludGVycG9sYXRlTGluZWFyO1xuXG5cdFx0XHRjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOlxuXG5cdFx0XHRcdHJldHVybiBJbnRlcnBvbGF0ZVNtb290aDtcblxuXHRcdH1cblxuXHR9XG5cblx0Z2V0VmFsdWVTaXplKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLmxlbmd0aCAvIHRoaXMudGltZXMubGVuZ3RoO1xuXG5cdH1cblxuXHQvLyBtb3ZlIGFsbCBrZXlmcmFtZXMgZWl0aGVyIGZvcndhcmRzIG9yIGJhY2t3YXJkcyBpbiB0aW1lXG5cdHNoaWZ0KCB0aW1lT2Zmc2V0ICkge1xuXG5cdFx0aWYgKCB0aW1lT2Zmc2V0ICE9PSAwLjAgKSB7XG5cblx0XHRcdGNvbnN0IHRpbWVzID0gdGhpcy50aW1lcztcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gdGltZXMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRcdHRpbWVzWyBpIF0gKz0gdGltZU9mZnNldDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vIHNjYWxlIGFsbCBrZXlmcmFtZSB0aW1lcyBieSBhIGZhY3RvciAodXNlZnVsIGZvciBmcmFtZSA8LT4gc2Vjb25kcyBjb252ZXJzaW9ucylcblx0c2NhbGUoIHRpbWVTY2FsZSApIHtcblxuXHRcdGlmICggdGltZVNjYWxlICE9PSAxLjAgKSB7XG5cblx0XHRcdGNvbnN0IHRpbWVzID0gdGhpcy50aW1lcztcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gdGltZXMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRcdHRpbWVzWyBpIF0gKj0gdGltZVNjYWxlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Ly8gcmVtb3ZlcyBrZXlmcmFtZXMgYmVmb3JlIGFuZCBhZnRlciBhbmltYXRpb24gd2l0aG91dCBjaGFuZ2luZyBhbnkgdmFsdWVzIHdpdGhpbiB0aGUgcmFuZ2UgW3N0YXJ0VGltZSwgZW5kVGltZV0uXG5cdC8vIElNUE9SVEFOVDogV2UgZG8gbm90IHNoaWZ0IGFyb3VuZCBrZXlzIHRvIHRoZSBzdGFydCBvZiB0aGUgdHJhY2sgdGltZSwgYmVjYXVzZSBmb3IgaW50ZXJwb2xhdGVkIGtleXMgdGhpcyB3aWxsIGNoYW5nZSB0aGVpciB2YWx1ZXNcblx0dHJpbSggc3RhcnRUaW1lLCBlbmRUaW1lICkge1xuXG5cdFx0Y29uc3QgdGltZXMgPSB0aGlzLnRpbWVzLFxuXHRcdFx0bktleXMgPSB0aW1lcy5sZW5ndGg7XG5cblx0XHRsZXQgZnJvbSA9IDAsXG5cdFx0XHR0byA9IG5LZXlzIC0gMTtcblxuXHRcdHdoaWxlICggZnJvbSAhPT0gbktleXMgJiYgdGltZXNbIGZyb20gXSA8IHN0YXJ0VGltZSApIHtcblxuXHRcdFx0KysgZnJvbTtcblxuXHRcdH1cblxuXHRcdHdoaWxlICggdG8gIT09IC0gMSAmJiB0aW1lc1sgdG8gXSA+IGVuZFRpbWUgKSB7XG5cblx0XHRcdC0tIHRvO1xuXG5cdFx0fVxuXG5cdFx0KysgdG87IC8vIGluY2x1c2l2ZSAtPiBleGNsdXNpdmUgYm91bmRcblxuXHRcdGlmICggZnJvbSAhPT0gMCB8fCB0byAhPT0gbktleXMgKSB7XG5cblx0XHRcdC8vIGVtcHR5IHRyYWNrcyBhcmUgZm9yYmlkZGVuLCBzbyBrZWVwIGF0IGxlYXN0IG9uZSBrZXlmcmFtZVxuXHRcdFx0aWYgKCBmcm9tID49IHRvICkge1xuXG5cdFx0XHRcdHRvID0gTWF0aC5tYXgoIHRvLCAxICk7XG5cdFx0XHRcdGZyb20gPSB0byAtIDE7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc3RyaWRlID0gdGhpcy5nZXRWYWx1ZVNpemUoKTtcblx0XHRcdHRoaXMudGltZXMgPSB0aW1lcy5zbGljZSggZnJvbSwgdG8gKTtcblx0XHRcdHRoaXMudmFsdWVzID0gdGhpcy52YWx1ZXMuc2xpY2UoIGZyb20gKiBzdHJpZGUsIHRvICogc3RyaWRlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Ly8gZW5zdXJlIHdlIGRvIG5vdCBnZXQgYSBHYXJiYWdlSW5HYXJiYWdlT3V0IHNpdHVhdGlvbiwgbWFrZSBzdXJlIHRyYWNrcyBhcmUgYXQgbGVhc3QgbWluaW1hbGx5IHZpYWJsZVxuXHR2YWxpZGF0ZSgpIHtcblxuXHRcdGxldCB2YWxpZCA9IHRydWU7XG5cblx0XHRjb25zdCB2YWx1ZVNpemUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpO1xuXHRcdGlmICggdmFsdWVTaXplIC0gTWF0aC5mbG9vciggdmFsdWVTaXplICkgIT09IDAgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBJbnZhbGlkIHZhbHVlIHNpemUgaW4gdHJhY2suJywgdGhpcyApO1xuXHRcdFx0dmFsaWQgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHRpbWVzID0gdGhpcy50aW1lcyxcblx0XHRcdHZhbHVlcyA9IHRoaXMudmFsdWVzLFxuXG5cdFx0XHRuS2V5cyA9IHRpbWVzLmxlbmd0aDtcblxuXHRcdGlmICggbktleXMgPT09IDAgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBUcmFjayBpcyBlbXB0eS4nLCB0aGlzICk7XG5cdFx0XHR2YWxpZCA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0bGV0IHByZXZUaW1lID0gbnVsbDtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gbktleXM7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGN1cnJUaW1lID0gdGltZXNbIGkgXTtcblxuXHRcdFx0aWYgKCB0eXBlb2YgY3VyclRpbWUgPT09ICdudW1iZXInICYmIGlzTmFOKCBjdXJyVGltZSApICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBUaW1lIGlzIG5vdCBhIHZhbGlkIG51bWJlci4nLCB0aGlzLCBpLCBjdXJyVGltZSApO1xuXHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHByZXZUaW1lICE9PSBudWxsICYmIHByZXZUaW1lID4gY3VyclRpbWUgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IE91dCBvZiBvcmRlciBrZXlzLicsIHRoaXMsIGksIGN1cnJUaW1lLCBwcmV2VGltZSApO1xuXHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRwcmV2VGltZSA9IGN1cnJUaW1lO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCBpc1R5cGVkQXJyYXkoIHZhbHVlcyApICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IHZhbHVlc1sgaSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBpc05hTiggdmFsdWUgKSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IFZhbHVlIGlzIG5vdCBhIHZhbGlkIG51bWJlci4nLCB0aGlzLCBpLCB2YWx1ZSApO1xuXHRcdFx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbGlkO1xuXG5cdH1cblxuXHQvLyByZW1vdmVzIGVxdWl2YWxlbnQgc2VxdWVudGlhbCBrZXlzIGFzIGNvbW1vbiBpbiBtb3JwaCB0YXJnZXQgc2VxdWVuY2VzXG5cdC8vICgwLDAsMCwwLDEsMSwxLDAsMCwwLDAsMCwwLDApIC0tPiAoMCwwLDEsMSwwLDApXG5cdG9wdGltaXplKCkge1xuXG5cdFx0Ly8gdGltZXMgb3IgdmFsdWVzIG1heSBiZSBzaGFyZWQgd2l0aCBvdGhlciB0cmFja3MsIHNvIG92ZXJ3cml0aW5nIGlzIHVuc2FmZVxuXHRcdGNvbnN0IHRpbWVzID0gdGhpcy50aW1lcy5zbGljZSgpLFxuXHRcdFx0dmFsdWVzID0gdGhpcy52YWx1ZXMuc2xpY2UoKSxcblx0XHRcdHN0cmlkZSA9IHRoaXMuZ2V0VmFsdWVTaXplKCksXG5cblx0XHRcdHNtb290aEludGVycG9sYXRpb24gPSB0aGlzLmdldEludGVycG9sYXRpb24oKSA9PT0gSW50ZXJwb2xhdGVTbW9vdGgsXG5cblx0XHRcdGxhc3RJbmRleCA9IHRpbWVzLmxlbmd0aCAtIDE7XG5cblx0XHRsZXQgd3JpdGVJbmRleCA9IDE7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDE7IGkgPCBsYXN0SW5kZXg7ICsrIGkgKSB7XG5cblx0XHRcdGxldCBrZWVwID0gZmFsc2U7XG5cblx0XHRcdGNvbnN0IHRpbWUgPSB0aW1lc1sgaSBdO1xuXHRcdFx0Y29uc3QgdGltZU5leHQgPSB0aW1lc1sgaSArIDEgXTtcblxuXHRcdFx0Ly8gcmVtb3ZlIGFkamFjZW50IGtleWZyYW1lcyBzY2hlZHVsZWQgYXQgdGhlIHNhbWUgdGltZVxuXG5cdFx0XHRpZiAoIHRpbWUgIT09IHRpbWVOZXh0ICYmICggaSAhPT0gMSB8fCB0aW1lICE9PSB0aW1lc1sgMCBdICkgKSB7XG5cblx0XHRcdFx0aWYgKCAhIHNtb290aEludGVycG9sYXRpb24gKSB7XG5cblx0XHRcdFx0XHQvLyByZW1vdmUgdW5uZWNlc3Nhcnkga2V5ZnJhbWVzIHNhbWUgYXMgdGhlaXIgbmVpZ2hib3JzXG5cblx0XHRcdFx0XHRjb25zdCBvZmZzZXQgPSBpICogc3RyaWRlLFxuXHRcdFx0XHRcdFx0b2Zmc2V0UCA9IG9mZnNldCAtIHN0cmlkZSxcblx0XHRcdFx0XHRcdG9mZnNldE4gPSBvZmZzZXQgKyBzdHJpZGU7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSB2YWx1ZXNbIG9mZnNldCArIGogXTtcblxuXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdmFsdWVzWyBvZmZzZXRQICsgaiBdIHx8XG5cdFx0XHRcdFx0XHRcdHZhbHVlICE9PSB2YWx1ZXNbIG9mZnNldE4gKyBqIF0gKSB7XG5cblx0XHRcdFx0XHRcdFx0a2VlcCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGtlZXAgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbi1wbGFjZSBjb21wYWN0aW9uXG5cblx0XHRcdGlmICgga2VlcCApIHtcblxuXHRcdFx0XHRpZiAoIGkgIT09IHdyaXRlSW5kZXggKSB7XG5cblx0XHRcdFx0XHR0aW1lc1sgd3JpdGVJbmRleCBdID0gdGltZXNbIGkgXTtcblxuXHRcdFx0XHRcdGNvbnN0IHJlYWRPZmZzZXQgPSBpICogc3RyaWRlLFxuXHRcdFx0XHRcdFx0d3JpdGVPZmZzZXQgPSB3cml0ZUluZGV4ICogc3RyaWRlO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKSB7XG5cblx0XHRcdFx0XHRcdHZhbHVlc1sgd3JpdGVPZmZzZXQgKyBqIF0gPSB2YWx1ZXNbIHJlYWRPZmZzZXQgKyBqIF07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdCsrIHdyaXRlSW5kZXg7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGZsdXNoIGxhc3Qga2V5ZnJhbWUgKGNvbXBhY3Rpb24gbG9va3MgYWhlYWQpXG5cblx0XHRpZiAoIGxhc3RJbmRleCA+IDAgKSB7XG5cblx0XHRcdHRpbWVzWyB3cml0ZUluZGV4IF0gPSB0aW1lc1sgbGFzdEluZGV4IF07XG5cblx0XHRcdGZvciAoIGxldCByZWFkT2Zmc2V0ID0gbGFzdEluZGV4ICogc3RyaWRlLCB3cml0ZU9mZnNldCA9IHdyaXRlSW5kZXggKiBzdHJpZGUsIGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKSB7XG5cblx0XHRcdFx0dmFsdWVzWyB3cml0ZU9mZnNldCArIGogXSA9IHZhbHVlc1sgcmVhZE9mZnNldCArIGogXTtcblxuXHRcdFx0fVxuXG5cdFx0XHQrKyB3cml0ZUluZGV4O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB3cml0ZUluZGV4ICE9PSB0aW1lcy5sZW5ndGggKSB7XG5cblx0XHRcdHRoaXMudGltZXMgPSB0aW1lcy5zbGljZSggMCwgd3JpdGVJbmRleCApO1xuXHRcdFx0dGhpcy52YWx1ZXMgPSB2YWx1ZXMuc2xpY2UoIDAsIHdyaXRlSW5kZXggKiBzdHJpZGUgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMudGltZXMgPSB0aW1lcztcblx0XHRcdHRoaXMudmFsdWVzID0gdmFsdWVzO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0Y29uc3QgdGltZXMgPSB0aGlzLnRpbWVzLnNsaWNlKCk7XG5cdFx0Y29uc3QgdmFsdWVzID0gdGhpcy52YWx1ZXMuc2xpY2UoKTtcblxuXHRcdGNvbnN0IFR5cGVkS2V5ZnJhbWVUcmFjayA9IHRoaXMuY29uc3RydWN0b3I7XG5cdFx0Y29uc3QgdHJhY2sgPSBuZXcgVHlwZWRLZXlmcmFtZVRyYWNrKCB0aGlzLm5hbWUsIHRpbWVzLCB2YWx1ZXMgKTtcblxuXHRcdC8vIEludGVycG9sYW50IGFyZ3VtZW50IHRvIGNvbnN0cnVjdG9yIGlzIG5vdCBzYXZlZCwgc28gY29weSB0aGUgZmFjdG9yeSBtZXRob2QgZGlyZWN0bHkuXG5cdFx0dHJhY2suY3JlYXRlSW50ZXJwb2xhbnQgPSB0aGlzLmNyZWF0ZUludGVycG9sYW50O1xuXG5cdFx0cmV0dXJuIHRyYWNrO1xuXG5cdH1cblxufVxuXG5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5UaW1lQnVmZmVyVHlwZSA9IEZsb2F0MzJBcnJheTtcbktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlQnVmZmVyVHlwZSA9IEZsb2F0MzJBcnJheTtcbktleWZyYW1lVHJhY2sucHJvdG90eXBlLkRlZmF1bHRJbnRlcnBvbGF0aW9uID0gSW50ZXJwb2xhdGVMaW5lYXI7XG5cbi8qKlxuICogQSBUcmFjayBvZiBCb29sZWFuIGtleWZyYW1lIHZhbHVlcy5cbiAqL1xuY2xhc3MgQm9vbGVhbktleWZyYW1lVHJhY2sgZXh0ZW5kcyBLZXlmcmFtZVRyYWNrIHtcblxuXHQvLyBObyBpbnRlcnBvbGF0aW9uIHBhcmFtZXRlciBiZWNhdXNlIG9ubHkgSW50ZXJwb2xhdGVEaXNjcmV0ZSBpcyB2YWxpZC5cblx0Y29uc3RydWN0b3IoIG5hbWUsIHRpbWVzLCB2YWx1ZXMgKSB7XG5cblx0XHRzdXBlciggbmFtZSwgdGltZXMsIHZhbHVlcyApO1xuXG5cdH1cblxufVxuXG5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICdib29sJztcbkJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZUJ1ZmZlclR5cGUgPSBBcnJheTtcbkJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5EZWZhdWx0SW50ZXJwb2xhdGlvbiA9IEludGVycG9sYXRlRGlzY3JldGU7XG5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyID0gdW5kZWZpbmVkO1xuQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aCA9IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIFRyYWNrIG9mIGtleWZyYW1lIHZhbHVlcyB0aGF0IHJlcHJlc2VudCBjb2xvci5cbiAqL1xuY2xhc3MgQ29sb3JLZXlmcmFtZVRyYWNrIGV4dGVuZHMgS2V5ZnJhbWVUcmFjayB7fVxuXG5Db2xvcktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlVHlwZU5hbWUgPSAnY29sb3InO1xuXG4vKipcbiAqIEEgVHJhY2sgb2YgbnVtZXJpYyBrZXlmcmFtZSB2YWx1ZXMuXG4gKi9cbmNsYXNzIE51bWJlcktleWZyYW1lVHJhY2sgZXh0ZW5kcyBLZXlmcmFtZVRyYWNrIHt9XG5cbk51bWJlcktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlVHlwZU5hbWUgPSAnbnVtYmVyJztcblxuLyoqXG4gKiBTcGhlcmljYWwgbGluZWFyIHVuaXQgcXVhdGVybmlvbiBpbnRlcnBvbGFudC5cbiAqL1xuXG5jbGFzcyBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQgZXh0ZW5kcyBJbnRlcnBvbGFudCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XG5cblx0XHRzdXBlciggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xuXG5cdH1cblxuXHRpbnRlcnBvbGF0ZV8oIGkxLCB0MCwgdCwgdDEgKSB7XG5cblx0XHRjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcblx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cblx0XHRcdGFscGhhID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApO1xuXG5cdFx0bGV0IG9mZnNldCA9IGkxICogc3RyaWRlO1xuXG5cdFx0Zm9yICggbGV0IGVuZCA9IG9mZnNldCArIHN0cmlkZTsgb2Zmc2V0ICE9PSBlbmQ7IG9mZnNldCArPSA0ICkge1xuXG5cdFx0XHRRdWF0ZXJuaW9uLnNsZXJwRmxhdCggcmVzdWx0LCAwLCB2YWx1ZXMsIG9mZnNldCAtIHN0cmlkZSwgdmFsdWVzLCBvZmZzZXQsIGFscGhhICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxufVxuXG4vKipcbiAqIEEgVHJhY2sgb2YgcXVhdGVybmlvbiBrZXlmcmFtZSB2YWx1ZXMuXG4gKi9cbmNsYXNzIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrIGV4dGVuZHMgS2V5ZnJhbWVUcmFjayB7XG5cblx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyKCByZXN1bHQgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCggdGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xuXG5cdH1cblxufVxuXG5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICdxdWF0ZXJuaW9uJztcbi8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcbi8vIERlZmF1bHRJbnRlcnBvbGF0aW9uIGlzIGluaGVyaXRlZDtcblF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGggPSB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBUcmFjayB0aGF0IGludGVycG9sYXRlcyBTdHJpbmdzXG4gKi9cbmNsYXNzIFN0cmluZ0tleWZyYW1lVHJhY2sgZXh0ZW5kcyBLZXlmcmFtZVRyYWNrIHtcblxuXHQvLyBObyBpbnRlcnBvbGF0aW9uIHBhcmFtZXRlciBiZWNhdXNlIG9ubHkgSW50ZXJwb2xhdGVEaXNjcmV0ZSBpcyB2YWxpZC5cblx0Y29uc3RydWN0b3IoIG5hbWUsIHRpbWVzLCB2YWx1ZXMgKSB7XG5cblx0XHRzdXBlciggbmFtZSwgdGltZXMsIHZhbHVlcyApO1xuXG5cdH1cblxufVxuXG5TdHJpbmdLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZVR5cGVOYW1lID0gJ3N0cmluZyc7XG5TdHJpbmdLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZUJ1ZmZlclR5cGUgPSBBcnJheTtcblN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLkRlZmF1bHRJbnRlcnBvbGF0aW9uID0gSW50ZXJwb2xhdGVEaXNjcmV0ZTtcblN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhciA9IHVuZGVmaW5lZDtcblN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aCA9IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIFRyYWNrIG9mIHZlY3RvcmVkIGtleWZyYW1lIHZhbHVlcy5cbiAqL1xuY2xhc3MgVmVjdG9yS2V5ZnJhbWVUcmFjayBleHRlbmRzIEtleWZyYW1lVHJhY2sge31cblxuVmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICd2ZWN0b3InO1xuXG5jbGFzcyBBbmltYXRpb25DbGlwIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSA9ICcnLCBkdXJhdGlvbiA9IC0gMSwgdHJhY2tzID0gW10sIGJsZW5kTW9kZSA9IE5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZSApIHtcblxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0dGhpcy50cmFja3MgPSB0cmFja3M7XG5cdFx0dGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXHRcdHRoaXMuYmxlbmRNb2RlID0gYmxlbmRNb2RlO1xuXG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHQvLyB0aGlzIG1lYW5zIGl0IHNob3VsZCBmaWd1cmUgb3V0IGl0cyBkdXJhdGlvbiBieSBzY2FubmluZyB0aGUgdHJhY2tzXG5cdFx0aWYgKCB0aGlzLmR1cmF0aW9uIDwgMCApIHtcblxuXHRcdFx0dGhpcy5yZXNldER1cmF0aW9uKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cblx0c3RhdGljIHBhcnNlKCBqc29uICkge1xuXG5cdFx0Y29uc3QgdHJhY2tzID0gW10sXG5cdFx0XHRqc29uVHJhY2tzID0ganNvbi50cmFja3MsXG5cdFx0XHRmcmFtZVRpbWUgPSAxLjAgLyAoIGpzb24uZnBzIHx8IDEuMCApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0ganNvblRyYWNrcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdHRyYWNrcy5wdXNoKCBwYXJzZUtleWZyYW1lVHJhY2soIGpzb25UcmFja3NbIGkgXSApLnNjYWxlKCBmcmFtZVRpbWUgKSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgY2xpcCA9IG5ldyB0aGlzKCBqc29uLm5hbWUsIGpzb24uZHVyYXRpb24sIHRyYWNrcywganNvbi5ibGVuZE1vZGUgKTtcblx0XHRjbGlwLnV1aWQgPSBqc29uLnV1aWQ7XG5cblx0XHRyZXR1cm4gY2xpcDtcblxuXHR9XG5cblx0c3RhdGljIHRvSlNPTiggY2xpcCApIHtcblxuXHRcdGNvbnN0IHRyYWNrcyA9IFtdLFxuXHRcdFx0Y2xpcFRyYWNrcyA9IGNsaXAudHJhY2tzO1xuXG5cdFx0Y29uc3QganNvbiA9IHtcblxuXHRcdFx0J25hbWUnOiBjbGlwLm5hbWUsXG5cdFx0XHQnZHVyYXRpb24nOiBjbGlwLmR1cmF0aW9uLFxuXHRcdFx0J3RyYWNrcyc6IHRyYWNrcyxcblx0XHRcdCd1dWlkJzogY2xpcC51dWlkLFxuXHRcdFx0J2JsZW5kTW9kZSc6IGNsaXAuYmxlbmRNb2RlXG5cblx0XHR9O1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gY2xpcFRyYWNrcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdHRyYWNrcy5wdXNoKCBLZXlmcmFtZVRyYWNrLnRvSlNPTiggY2xpcFRyYWNrc1sgaSBdICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBqc29uO1xuXG5cdH1cblxuXHRzdGF0aWMgQ3JlYXRlRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2UoIG5hbWUsIG1vcnBoVGFyZ2V0U2VxdWVuY2UsIGZwcywgbm9Mb29wICkge1xuXG5cdFx0Y29uc3QgbnVtTW9ycGhUYXJnZXRzID0gbW9ycGhUYXJnZXRTZXF1ZW5jZS5sZW5ndGg7XG5cdFx0Y29uc3QgdHJhY2tzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBudW1Nb3JwaFRhcmdldHM7IGkgKysgKSB7XG5cblx0XHRcdGxldCB0aW1lcyA9IFtdO1xuXHRcdFx0bGV0IHZhbHVlcyA9IFtdO1xuXG5cdFx0XHR0aW1lcy5wdXNoKFxuXHRcdFx0XHQoIGkgKyBudW1Nb3JwaFRhcmdldHMgLSAxICkgJSBudW1Nb3JwaFRhcmdldHMsXG5cdFx0XHRcdGksXG5cdFx0XHRcdCggaSArIDEgKSAlIG51bU1vcnBoVGFyZ2V0cyApO1xuXG5cdFx0XHR2YWx1ZXMucHVzaCggMCwgMSwgMCApO1xuXG5cdFx0XHRjb25zdCBvcmRlciA9IGdldEtleWZyYW1lT3JkZXIoIHRpbWVzICk7XG5cdFx0XHR0aW1lcyA9IHNvcnRlZEFycmF5KCB0aW1lcywgMSwgb3JkZXIgKTtcblx0XHRcdHZhbHVlcyA9IHNvcnRlZEFycmF5KCB2YWx1ZXMsIDEsIG9yZGVyICk7XG5cblx0XHRcdC8vIGlmIHRoZXJlIGlzIGEga2V5IGF0IHRoZSBmaXJzdCBmcmFtZSwgZHVwbGljYXRlIGl0IGFzIHRoZVxuXHRcdFx0Ly8gbGFzdCBmcmFtZSBhcyB3ZWxsIGZvciBwZXJmZWN0IGxvb3AuXG5cdFx0XHRpZiAoICEgbm9Mb29wICYmIHRpbWVzWyAwIF0gPT09IDAgKSB7XG5cblx0XHRcdFx0dGltZXMucHVzaCggbnVtTW9ycGhUYXJnZXRzICk7XG5cdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZXNbIDAgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRyYWNrcy5wdXNoKFxuXHRcdFx0XHRuZXcgTnVtYmVyS2V5ZnJhbWVUcmFjayhcblx0XHRcdFx0XHQnLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1snICsgbW9ycGhUYXJnZXRTZXF1ZW5jZVsgaSBdLm5hbWUgKyAnXScsXG5cdFx0XHRcdFx0dGltZXMsIHZhbHVlc1xuXHRcdFx0XHQpLnNjYWxlKCAxLjAgLyBmcHMgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyB0aGlzKCBuYW1lLCAtIDEsIHRyYWNrcyApO1xuXG5cdH1cblxuXHRzdGF0aWMgZmluZEJ5TmFtZSggb2JqZWN0T3JDbGlwQXJyYXksIG5hbWUgKSB7XG5cblx0XHRsZXQgY2xpcEFycmF5ID0gb2JqZWN0T3JDbGlwQXJyYXk7XG5cblx0XHRpZiAoICEgQXJyYXkuaXNBcnJheSggb2JqZWN0T3JDbGlwQXJyYXkgKSApIHtcblxuXHRcdFx0Y29uc3QgbyA9IG9iamVjdE9yQ2xpcEFycmF5O1xuXHRcdFx0Y2xpcEFycmF5ID0gby5nZW9tZXRyeSAmJiBvLmdlb21ldHJ5LmFuaW1hdGlvbnMgfHwgby5hbmltYXRpb25zO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY2xpcEFycmF5Lmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0aWYgKCBjbGlwQXJyYXlbIGkgXS5uYW1lID09PSBuYW1lICkge1xuXG5cdFx0XHRcdHJldHVybiBjbGlwQXJyYXlbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fVxuXG5cdHN0YXRpYyBDcmVhdGVDbGlwc0Zyb21Nb3JwaFRhcmdldFNlcXVlbmNlcyggbW9ycGhUYXJnZXRzLCBmcHMsIG5vTG9vcCApIHtcblxuXHRcdGNvbnN0IGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzID0ge307XG5cblx0XHQvLyB0ZXN0ZWQgd2l0aCBodHRwczovL3JlZ2V4MTAxLmNvbS8gb24gdHJpY2sgc2VxdWVuY2VzXG5cdFx0Ly8gc3VjaCBmbGFtaW5nb19mbHlBXzAwMywgZmxhbWluZ29fcnVuMV8wMDMsIGNyZGVhdGgwMDU5XG5cdFx0Y29uc3QgcGF0dGVybiA9IC9eKFtcXHctXSo/KShbXFxkXSspJC87XG5cblx0XHQvLyBzb3J0IG1vcnBoIHRhcmdldCBuYW1lcyBpbnRvIGFuaW1hdGlvbiBncm91cHMgYmFzZWRcblx0XHQvLyBwYXR0ZXJucyBsaWtlIFdhbGtfMDAxLCBXYWxrXzAwMiwgUnVuXzAwMSwgUnVuXzAwMlxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBpIF07XG5cdFx0XHRjb25zdCBwYXJ0cyA9IG1vcnBoVGFyZ2V0Lm5hbWUubWF0Y2goIHBhdHRlcm4gKTtcblxuXHRcdFx0aWYgKCBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdGNvbnN0IG5hbWUgPSBwYXJ0c1sgMSBdO1xuXG5cdFx0XHRcdGxldCBhbmltYXRpb25Nb3JwaFRhcmdldHMgPSBhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdO1xuXG5cdFx0XHRcdGlmICggISBhbmltYXRpb25Nb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdFx0XHRhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdID0gYW5pbWF0aW9uTW9ycGhUYXJnZXRzID0gW107XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFuaW1hdGlvbk1vcnBoVGFyZ2V0cy5wdXNoKCBtb3JwaFRhcmdldCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zdCBjbGlwcyA9IFtdO1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBhbmltYXRpb25Ub01vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0Y2xpcHMucHVzaCggdGhpcy5DcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZSggbmFtZSwgYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXSwgZnBzLCBub0xvb3AgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsaXBzO1xuXG5cdH1cblxuXHQvLyBwYXJzZSB0aGUgYW5pbWF0aW9uLmhpZXJhcmNoeSBmb3JtYXRcblx0c3RhdGljIHBhcnNlQW5pbWF0aW9uKCBhbmltYXRpb24sIGJvbmVzICkge1xuXG5cdFx0aWYgKCAhIGFuaW1hdGlvbiApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkFuaW1hdGlvbkNsaXA6IE5vIGFuaW1hdGlvbiBpbiBKU09OTG9hZGVyIGRhdGEuJyApO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRjb25zdCBhZGROb25lbXB0eVRyYWNrID0gZnVuY3Rpb24gKCB0cmFja1R5cGUsIHRyYWNrTmFtZSwgYW5pbWF0aW9uS2V5cywgcHJvcGVydHlOYW1lLCBkZXN0VHJhY2tzICkge1xuXG5cdFx0XHQvLyBvbmx5IHJldHVybiB0cmFjayBpZiB0aGVyZSBhcmUgYWN0dWFsbHkga2V5cy5cblx0XHRcdGlmICggYW5pbWF0aW9uS2V5cy5sZW5ndGggIT09IDAgKSB7XG5cblx0XHRcdFx0Y29uc3QgdGltZXMgPSBbXTtcblx0XHRcdFx0Y29uc3QgdmFsdWVzID0gW107XG5cblx0XHRcdFx0ZmxhdHRlbkpTT04oIGFuaW1hdGlvbktleXMsIHRpbWVzLCB2YWx1ZXMsIHByb3BlcnR5TmFtZSApO1xuXG5cdFx0XHRcdC8vIGVtcHR5IGtleXMgYXJlIGZpbHRlcmVkIG91dCwgc28gY2hlY2sgYWdhaW5cblx0XHRcdFx0aWYgKCB0aW1lcy5sZW5ndGggIT09IDAgKSB7XG5cblx0XHRcdFx0XHRkZXN0VHJhY2tzLnB1c2goIG5ldyB0cmFja1R5cGUoIHRyYWNrTmFtZSwgdGltZXMsIHZhbHVlcyApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0Y29uc3QgdHJhY2tzID0gW107XG5cblx0XHRjb25zdCBjbGlwTmFtZSA9IGFuaW1hdGlvbi5uYW1lIHx8ICdkZWZhdWx0Jztcblx0XHRjb25zdCBmcHMgPSBhbmltYXRpb24uZnBzIHx8IDMwO1xuXHRcdGNvbnN0IGJsZW5kTW9kZSA9IGFuaW1hdGlvbi5ibGVuZE1vZGU7XG5cblx0XHQvLyBhdXRvbWF0aWMgbGVuZ3RoIGRldGVybWluYXRpb24gaW4gQW5pbWF0aW9uQ2xpcC5cblx0XHRsZXQgZHVyYXRpb24gPSBhbmltYXRpb24ubGVuZ3RoIHx8IC0gMTtcblxuXHRcdGNvbnN0IGhpZXJhcmNoeVRyYWNrcyA9IGFuaW1hdGlvbi5oaWVyYXJjaHkgfHwgW107XG5cblx0XHRmb3IgKCBsZXQgaCA9IDA7IGggPCBoaWVyYXJjaHlUcmFja3MubGVuZ3RoOyBoICsrICkge1xuXG5cdFx0XHRjb25zdCBhbmltYXRpb25LZXlzID0gaGllcmFyY2h5VHJhY2tzWyBoIF0ua2V5cztcblxuXHRcdFx0Ly8gc2tpcCBlbXB0eSB0cmFja3Ncblx0XHRcdGlmICggISBhbmltYXRpb25LZXlzIHx8IGFuaW1hdGlvbktleXMubGVuZ3RoID09PSAwICkgY29udGludWU7XG5cblx0XHRcdC8vIHByb2Nlc3MgbW9ycGggdGFyZ2V0c1xuXHRcdFx0aWYgKCBhbmltYXRpb25LZXlzWyAwIF0ubW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRcdC8vIGZpZ3VyZSBvdXQgYWxsIG1vcnBoIHRhcmdldHMgdXNlZCBpbiB0aGlzIHRyYWNrXG5cdFx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0TmFtZXMgPSB7fTtcblxuXHRcdFx0XHRsZXQgaztcblxuXHRcdFx0XHRmb3IgKCBrID0gMDsgayA8IGFuaW1hdGlvbktleXMubGVuZ3RoOyBrICsrICkge1xuXG5cdFx0XHRcdFx0aWYgKCBhbmltYXRpb25LZXlzWyBrIF0ubW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgbSA9IDA7IG0gPCBhbmltYXRpb25LZXlzWyBrIF0ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRtb3JwaFRhcmdldE5hbWVzWyBhbmltYXRpb25LZXlzWyBrIF0ubW9ycGhUYXJnZXRzWyBtIF0gXSA9IC0gMTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjcmVhdGUgYSB0cmFjayBmb3IgZWFjaCBtb3JwaCB0YXJnZXQgd2l0aCBhbGwgemVyb1xuXHRcdFx0XHQvLyBtb3JwaFRhcmdldEluZmx1ZW5jZXMgZXhjZXB0IGZvciB0aGUga2V5cyBpbiB3aGljaFxuXHRcdFx0XHQvLyB0aGUgbW9ycGhUYXJnZXQgaXMgbmFtZWQuXG5cdFx0XHRcdGZvciAoIGNvbnN0IG1vcnBoVGFyZ2V0TmFtZSBpbiBtb3JwaFRhcmdldE5hbWVzICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdGltZXMgPSBbXTtcblx0XHRcdFx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBtID0gMDsgbSAhPT0gYW5pbWF0aW9uS2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7ICsrIG0gKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGFuaW1hdGlvbktleSA9IGFuaW1hdGlvbktleXNbIGsgXTtcblxuXHRcdFx0XHRcdFx0dGltZXMucHVzaCggYW5pbWF0aW9uS2V5LnRpbWUgKTtcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCAoIGFuaW1hdGlvbktleS5tb3JwaFRhcmdldCA9PT0gbW9ycGhUYXJnZXROYW1lICkgPyAxIDogMCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dHJhY2tzLnB1c2goIG5ldyBOdW1iZXJLZXlmcmFtZVRyYWNrKCAnLm1vcnBoVGFyZ2V0SW5mbHVlbmNlWycgKyBtb3JwaFRhcmdldE5hbWUgKyAnXScsIHRpbWVzLCB2YWx1ZXMgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkdXJhdGlvbiA9IG1vcnBoVGFyZ2V0TmFtZXMubGVuZ3RoICogZnBzO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIC4uLmFzc3VtZSBza2VsZXRhbCBhbmltYXRpb25cblxuXHRcdFx0XHRjb25zdCBib25lTmFtZSA9ICcuYm9uZXNbJyArIGJvbmVzWyBoIF0ubmFtZSArICddJztcblxuXHRcdFx0XHRhZGROb25lbXB0eVRyYWNrKFxuXHRcdFx0XHRcdFZlY3RvcktleWZyYW1lVHJhY2ssIGJvbmVOYW1lICsgJy5wb3NpdGlvbicsXG5cdFx0XHRcdFx0YW5pbWF0aW9uS2V5cywgJ3BvcycsIHRyYWNrcyApO1xuXG5cdFx0XHRcdGFkZE5vbmVtcHR5VHJhY2soXG5cdFx0XHRcdFx0UXVhdGVybmlvbktleWZyYW1lVHJhY2ssIGJvbmVOYW1lICsgJy5xdWF0ZXJuaW9uJyxcblx0XHRcdFx0XHRhbmltYXRpb25LZXlzLCAncm90JywgdHJhY2tzICk7XG5cblx0XHRcdFx0YWRkTm9uZW1wdHlUcmFjayhcblx0XHRcdFx0XHRWZWN0b3JLZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcuc2NhbGUnLFxuXHRcdFx0XHRcdGFuaW1hdGlvbktleXMsICdzY2wnLCB0cmFja3MgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCB0cmFja3MubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGNsaXAgPSBuZXcgdGhpcyggY2xpcE5hbWUsIGR1cmF0aW9uLCB0cmFja3MsIGJsZW5kTW9kZSApO1xuXG5cdFx0cmV0dXJuIGNsaXA7XG5cblx0fVxuXG5cdHJlc2V0RHVyYXRpb24oKSB7XG5cblx0XHRjb25zdCB0cmFja3MgPSB0aGlzLnRyYWNrcztcblx0XHRsZXQgZHVyYXRpb24gPSAwO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gdHJhY2tzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0Y29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrc1sgaSBdO1xuXG5cdFx0XHRkdXJhdGlvbiA9IE1hdGgubWF4KCBkdXJhdGlvbiwgdHJhY2sudGltZXNbIHRyYWNrLnRpbWVzLmxlbmd0aCAtIDEgXSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRyaW0oKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMudHJhY2tzWyBpIF0udHJpbSggMCwgdGhpcy5kdXJhdGlvbiApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHZhbGlkYXRlKCkge1xuXG5cdFx0bGV0IHZhbGlkID0gdHJ1ZTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFsaWQgPSB2YWxpZCAmJiB0aGlzLnRyYWNrc1sgaSBdLnZhbGlkYXRlKCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsaWQ7XG5cblx0fVxuXG5cdG9wdGltaXplKCkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLnRyYWNrc1sgaSBdLm9wdGltaXplKCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRjb25zdCB0cmFja3MgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dHJhY2tzLnB1c2goIHRoaXMudHJhY2tzWyBpIF0uY2xvbmUoKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLm5hbWUsIHRoaXMuZHVyYXRpb24sIHRyYWNrcywgdGhpcy5ibGVuZE1vZGUgKTtcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9KU09OKCB0aGlzICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIGdldFRyYWNrVHlwZUZvclZhbHVlVHlwZU5hbWUoIHR5cGVOYW1lICkge1xuXG5cdHN3aXRjaCAoIHR5cGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cblx0XHRjYXNlICdzY2FsYXInOlxuXHRcdGNhc2UgJ2RvdWJsZSc6XG5cdFx0Y2FzZSAnZmxvYXQnOlxuXHRcdGNhc2UgJ251bWJlcic6XG5cdFx0Y2FzZSAnaW50ZWdlcic6XG5cblx0XHRcdHJldHVybiBOdW1iZXJLZXlmcmFtZVRyYWNrO1xuXG5cdFx0Y2FzZSAndmVjdG9yJzpcblx0XHRjYXNlICd2ZWN0b3IyJzpcblx0XHRjYXNlICd2ZWN0b3IzJzpcblx0XHRjYXNlICd2ZWN0b3I0JzpcblxuXHRcdFx0cmV0dXJuIFZlY3RvcktleWZyYW1lVHJhY2s7XG5cblx0XHRjYXNlICdjb2xvcic6XG5cblx0XHRcdHJldHVybiBDb2xvcktleWZyYW1lVHJhY2s7XG5cblx0XHRjYXNlICdxdWF0ZXJuaW9uJzpcblxuXHRcdFx0cmV0dXJuIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrO1xuXG5cdFx0Y2FzZSAnYm9vbCc6XG5cdFx0Y2FzZSAnYm9vbGVhbic6XG5cblx0XHRcdHJldHVybiBCb29sZWFuS2V5ZnJhbWVUcmFjaztcblxuXHRcdGNhc2UgJ3N0cmluZyc6XG5cblx0XHRcdHJldHVybiBTdHJpbmdLZXlmcmFtZVRyYWNrO1xuXG5cdH1cblxuXHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBVbnN1cHBvcnRlZCB0eXBlTmFtZTogJyArIHR5cGVOYW1lICk7XG5cbn1cblxuZnVuY3Rpb24gcGFyc2VLZXlmcmFtZVRyYWNrKCBqc29uICkge1xuXG5cdGlmICgganNvbi50eXBlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiB0cmFjayB0eXBlIHVuZGVmaW5lZCwgY2FuIG5vdCBwYXJzZScgKTtcblxuXHR9XG5cblx0Y29uc3QgdHJhY2tUeXBlID0gZ2V0VHJhY2tUeXBlRm9yVmFsdWVUeXBlTmFtZSgganNvbi50eXBlICk7XG5cblx0aWYgKCBqc29uLnRpbWVzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRjb25zdCB0aW1lcyA9IFtdLCB2YWx1ZXMgPSBbXTtcblxuXHRcdGZsYXR0ZW5KU09OKCBqc29uLmtleXMsIHRpbWVzLCB2YWx1ZXMsICd2YWx1ZScgKTtcblxuXHRcdGpzb24udGltZXMgPSB0aW1lcztcblx0XHRqc29uLnZhbHVlcyA9IHZhbHVlcztcblxuXHR9XG5cblx0Ly8gZGVyaXZlZCBjbGFzc2VzIGNhbiBkZWZpbmUgYSBzdGF0aWMgcGFyc2UgbWV0aG9kXG5cdGlmICggdHJhY2tUeXBlLnBhcnNlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRyZXR1cm4gdHJhY2tUeXBlLnBhcnNlKCBqc29uICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIGJ5IGRlZmF1bHQsIHdlIGFzc3VtZSBhIGNvbnN0cnVjdG9yIGNvbXBhdGlibGUgd2l0aCB0aGUgYmFzZVxuXHRcdHJldHVybiBuZXcgdHJhY2tUeXBlKCBqc29uLm5hbWUsIGpzb24udGltZXMsIGpzb24udmFsdWVzLCBqc29uLmludGVycG9sYXRpb24gKTtcblxuXHR9XG5cbn1cblxuY29uc3QgQ2FjaGUgPSB7XG5cblx0ZW5hYmxlZDogZmFsc2UsXG5cblx0ZmlsZXM6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24gKCBrZXksIGZpbGUgKSB7XG5cblx0XHRpZiAoIHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHQvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkNhY2hlJywgJ0FkZGluZyBrZXk6Jywga2V5ICk7XG5cblx0XHR0aGlzLmZpbGVzWyBrZXkgXSA9IGZpbGU7XG5cblx0fSxcblxuXHRnZXQ6IGZ1bmN0aW9uICgga2V5ICkge1xuXG5cdFx0aWYgKCB0aGlzLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdDaGVja2luZyBrZXk6Jywga2V5ICk7XG5cblx0XHRyZXR1cm4gdGhpcy5maWxlc1sga2V5IF07XG5cblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uICgga2V5ICkge1xuXG5cdFx0ZGVsZXRlIHRoaXMuZmlsZXNbIGtleSBdO1xuXG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuZmlsZXMgPSB7fTtcblxuXHR9XG5cbn07XG5cbmNsYXNzIExvYWRpbmdNYW5hZ2VyIHtcblxuXHRjb25zdHJ1Y3Rvciggb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0bGV0IGlzTG9hZGluZyA9IGZhbHNlO1xuXHRcdGxldCBpdGVtc0xvYWRlZCA9IDA7XG5cdFx0bGV0IGl0ZW1zVG90YWwgPSAwO1xuXHRcdGxldCB1cmxNb2RpZmllciA9IHVuZGVmaW5lZDtcblx0XHRjb25zdCBoYW5kbGVycyA9IFtdO1xuXG5cdFx0Ly8gUmVmZXIgdG8gIzU2ODkgZm9yIHRoZSByZWFzb24gd2h5IHdlIGRvbid0IHNldCAub25TdGFydFxuXHRcdC8vIGluIHRoZSBjb25zdHJ1Y3RvclxuXG5cdFx0dGhpcy5vblN0YXJ0ID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMub25Mb2FkID0gb25Mb2FkO1xuXHRcdHRoaXMub25Qcm9ncmVzcyA9IG9uUHJvZ3Jlc3M7XG5cdFx0dGhpcy5vbkVycm9yID0gb25FcnJvcjtcblxuXHRcdHRoaXMuaXRlbVN0YXJ0ID0gZnVuY3Rpb24gKCB1cmwgKSB7XG5cblx0XHRcdGl0ZW1zVG90YWwgKys7XG5cblx0XHRcdGlmICggaXNMb2FkaW5nID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRpZiAoIHNjb3BlLm9uU3RhcnQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHNjb3BlLm9uU3RhcnQoIHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aXNMb2FkaW5nID0gdHJ1ZTtcblxuXHRcdH07XG5cblx0XHR0aGlzLml0ZW1FbmQgPSBmdW5jdGlvbiAoIHVybCApIHtcblxuXHRcdFx0aXRlbXNMb2FkZWQgKys7XG5cblx0XHRcdGlmICggc2NvcGUub25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHNjb3BlLm9uUHJvZ3Jlc3MoIHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGl0ZW1zTG9hZGVkID09PSBpdGVtc1RvdGFsICkge1xuXG5cdFx0XHRcdGlzTG9hZGluZyA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmICggc2NvcGUub25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRzY29wZS5vbkxvYWQoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHR0aGlzLml0ZW1FcnJvciA9IGZ1bmN0aW9uICggdXJsICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLm9uRXJyb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzY29wZS5vbkVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMucmVzb2x2ZVVSTCA9IGZ1bmN0aW9uICggdXJsICkge1xuXG5cdFx0XHRpZiAoIHVybE1vZGlmaWVyICkge1xuXG5cdFx0XHRcdHJldHVybiB1cmxNb2RpZmllciggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVybDtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNldFVSTE1vZGlmaWVyID0gZnVuY3Rpb24gKCB0cmFuc2Zvcm0gKSB7XG5cblx0XHRcdHVybE1vZGlmaWVyID0gdHJhbnNmb3JtO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0XHR0aGlzLmFkZEhhbmRsZXIgPSBmdW5jdGlvbiAoIHJlZ2V4LCBsb2FkZXIgKSB7XG5cblx0XHRcdGhhbmRsZXJzLnB1c2goIHJlZ2V4LCBsb2FkZXIgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5yZW1vdmVIYW5kbGVyID0gZnVuY3Rpb24gKCByZWdleCApIHtcblxuXHRcdFx0Y29uc3QgaW5kZXggPSBoYW5kbGVycy5pbmRleE9mKCByZWdleCApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBpbmRleCwgMiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0SGFuZGxlciA9IGZ1bmN0aW9uICggZmlsZSApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSArPSAyICkge1xuXG5cdFx0XHRcdGNvbnN0IHJlZ2V4ID0gaGFuZGxlcnNbIGkgXTtcblx0XHRcdFx0Y29uc3QgbG9hZGVyID0gaGFuZGxlcnNbIGkgKyAxIF07XG5cblx0XHRcdFx0aWYgKCByZWdleC5nbG9iYWwgKSByZWdleC5sYXN0SW5kZXggPSAwOyAvLyBzZWUgIzE3OTIwXG5cblx0XHRcdFx0aWYgKCByZWdleC50ZXN0KCBmaWxlICkgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gbG9hZGVyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH07XG5cblx0fVxuXG59XG5cbmNvbnN0IERlZmF1bHRMb2FkaW5nTWFuYWdlciA9IC8qQF9fUFVSRV9fKi8gbmV3IExvYWRpbmdNYW5hZ2VyKCk7XG5cbmNsYXNzIExvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcblx0XHR0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuXHRcdHRoaXMucGF0aCA9ICcnO1xuXHRcdHRoaXMucmVzb3VyY2VQYXRoID0gJyc7XG5cdFx0dGhpcy5yZXF1ZXN0SGVhZGVyID0ge307XG5cblx0fVxuXG5cdGxvYWQoIC8qIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICovICkge31cblxuXHRsb2FkQXN5bmMoIHVybCwgb25Qcm9ncmVzcyApIHtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSggZnVuY3Rpb24gKCByZXNvbHZlLCByZWplY3QgKSB7XG5cblx0XHRcdHNjb3BlLmxvYWQoIHVybCwgcmVzb2x2ZSwgb25Qcm9ncmVzcywgcmVqZWN0ICk7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdHBhcnNlKCAvKiBkYXRhICovICkge31cblxuXHRzZXRDcm9zc09yaWdpbiggY3Jvc3NPcmlnaW4gKSB7XG5cblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFdpdGhDcmVkZW50aWFscyggdmFsdWUgKSB7XG5cblx0XHR0aGlzLndpdGhDcmVkZW50aWFscyA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRQYXRoKCBwYXRoICkge1xuXG5cdFx0dGhpcy5wYXRoID0gcGF0aDtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0UmVzb3VyY2VQYXRoKCByZXNvdXJjZVBhdGggKSB7XG5cblx0XHR0aGlzLnJlc291cmNlUGF0aCA9IHJlc291cmNlUGF0aDtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0UmVxdWVzdEhlYWRlciggcmVxdWVzdEhlYWRlciApIHtcblxuXHRcdHRoaXMucmVxdWVzdEhlYWRlciA9IHJlcXVlc3RIZWFkZXI7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbkxvYWRlci5ERUZBVUxUX01BVEVSSUFMX05BTUUgPSAnX19ERUZBVUxUJztcblxuY29uc3QgbG9hZGluZyA9IHt9O1xuXG5jbGFzcyBIdHRwRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cblx0Y29uc3RydWN0b3IoIG1lc3NhZ2UsIHJlc3BvbnNlICkge1xuXG5cdFx0c3VwZXIoIG1lc3NhZ2UgKTtcblx0XHR0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG5cblx0fVxuXG59XG5cbmNsYXNzIEZpbGVMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xuXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcblxuXHR9XG5cblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRpZiAoIHVybCA9PT0gdW5kZWZpbmVkICkgdXJsID0gJyc7XG5cblx0XHRpZiAoIHRoaXMucGF0aCAhPT0gdW5kZWZpbmVkICkgdXJsID0gdGhpcy5wYXRoICsgdXJsO1xuXG5cdFx0dXJsID0gdGhpcy5tYW5hZ2VyLnJlc29sdmVVUkwoIHVybCApO1xuXG5cdFx0Y29uc3QgY2FjaGVkID0gQ2FjaGUuZ2V0KCB1cmwgKTtcblxuXHRcdGlmICggY2FjaGVkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG5cdFx0XHRzZXRUaW1lb3V0KCAoKSA9PiB7XG5cblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGNhY2hlZCApO1xuXG5cdFx0XHRcdHRoaXMubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0fSwgMCApO1xuXG5cdFx0XHRyZXR1cm4gY2FjaGVkO1xuXG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgcmVxdWVzdCBpcyBkdXBsaWNhdGVcblxuXHRcdGlmICggbG9hZGluZ1sgdXJsIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bG9hZGluZ1sgdXJsIF0ucHVzaCgge1xuXG5cdFx0XHRcdG9uTG9hZDogb25Mb2FkLFxuXHRcdFx0XHRvblByb2dyZXNzOiBvblByb2dyZXNzLFxuXHRcdFx0XHRvbkVycm9yOiBvbkVycm9yXG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0Ly8gSW5pdGlhbGlzZSBhcnJheSBmb3IgZHVwbGljYXRlIHJlcXVlc3RzXG5cdFx0bG9hZGluZ1sgdXJsIF0gPSBbXTtcblxuXHRcdGxvYWRpbmdbIHVybCBdLnB1c2goIHtcblx0XHRcdG9uTG9hZDogb25Mb2FkLFxuXHRcdFx0b25Qcm9ncmVzczogb25Qcm9ncmVzcyxcblx0XHRcdG9uRXJyb3I6IG9uRXJyb3IsXG5cdFx0fSApO1xuXG5cdFx0Ly8gY3JlYXRlIHJlcXVlc3Rcblx0XHRjb25zdCByZXEgPSBuZXcgUmVxdWVzdCggdXJsLCB7XG5cdFx0XHRoZWFkZXJzOiBuZXcgSGVhZGVycyggdGhpcy5yZXF1ZXN0SGVhZGVyICksXG5cdFx0XHRjcmVkZW50aWFsczogdGhpcy53aXRoQ3JlZGVudGlhbHMgPyAnaW5jbHVkZScgOiAnc2FtZS1vcmlnaW4nLFxuXHRcdFx0Ly8gQW4gYWJvcnQgY29udHJvbGxlciBjb3VsZCBiZSBhZGRlZCB3aXRoaW4gYSBmdXR1cmUgUFJcblx0XHR9ICk7XG5cblx0XHQvLyByZWNvcmQgc3RhdGVzICggYXZvaWQgZGF0YSByYWNlIClcblx0XHRjb25zdCBtaW1lVHlwZSA9IHRoaXMubWltZVR5cGU7XG5cdFx0Y29uc3QgcmVzcG9uc2VUeXBlID0gdGhpcy5yZXNwb25zZVR5cGU7XG5cblx0XHQvLyBzdGFydCB0aGUgZmV0Y2hcblx0XHRmZXRjaCggcmVxIClcblx0XHRcdC50aGVuKCByZXNwb25zZSA9PiB7XG5cblx0XHRcdFx0aWYgKCByZXNwb25zZS5zdGF0dXMgPT09IDIwMCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDAgKSB7XG5cblx0XHRcdFx0XHQvLyBTb21lIGJyb3dzZXJzIHJldHVybiBIVFRQIFN0YXR1cyAwIHdoZW4gdXNpbmcgbm9uLWh0dHAgcHJvdG9jb2xcblx0XHRcdFx0XHQvLyBlLmcuICdmaWxlOi8vJyBvciAnZGF0YTovLycuIEhhbmRsZSBhcyBzdWNjZXNzLlxuXG5cdFx0XHRcdFx0aWYgKCByZXNwb25zZS5zdGF0dXMgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZpbGVMb2FkZXI6IEhUVFAgU3RhdHVzIDAgcmVjZWl2ZWQuJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gV29ya2Fyb3VuZDogQ2hlY2tpbmcgaWYgcmVzcG9uc2UuYm9keSA9PT0gdW5kZWZpbmVkIGZvciBBbGlwYXkgYnJvd3NlciAjMjM1NDhcblxuXHRcdFx0XHRcdGlmICggdHlwZW9mIFJlYWRhYmxlU3RyZWFtID09PSAndW5kZWZpbmVkJyB8fCByZXNwb25zZS5ib2R5ID09PSB1bmRlZmluZWQgfHwgcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3QgY2FsbGJhY2tzID0gbG9hZGluZ1sgdXJsIF07XG5cdFx0XHRcdFx0Y29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcblxuXHRcdFx0XHRcdC8vIE5naW54IG5lZWRzIFgtRmlsZS1TaXplIGNoZWNrXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9zZXJ2ZXJmYXVsdC5jb20vcXVlc3Rpb25zLzQ4Mjg3NS93aHktZG9lcy1uZ2lueC1yZW1vdmUtY29udGVudC1sZW5ndGgtaGVhZGVyLWZvci1jaHVua2VkLWNvbnRlbnRcblx0XHRcdFx0XHRjb25zdCBjb250ZW50TGVuZ3RoID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoICdYLUZpbGUtU2l6ZScgKSB8fCByZXNwb25zZS5oZWFkZXJzLmdldCggJ0NvbnRlbnQtTGVuZ3RoJyApO1xuXHRcdFx0XHRcdGNvbnN0IHRvdGFsID0gY29udGVudExlbmd0aCA/IHBhcnNlSW50KCBjb250ZW50TGVuZ3RoICkgOiAwO1xuXHRcdFx0XHRcdGNvbnN0IGxlbmd0aENvbXB1dGFibGUgPSB0b3RhbCAhPT0gMDtcblx0XHRcdFx0XHRsZXQgbG9hZGVkID0gMDtcblxuXHRcdFx0XHRcdC8vIHBlcmlvZGljYWxseSByZWFkIGRhdGEgaW50byB0aGUgbmV3IHN0cmVhbSB0cmFja2luZyB3aGlsZSBkb3dubG9hZCBwcm9ncmVzc1xuXHRcdFx0XHRcdGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSgge1xuXHRcdFx0XHRcdFx0c3RhcnQoIGNvbnRyb2xsZXIgKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVhZERhdGEoKTtcblxuXHRcdFx0XHRcdFx0XHRmdW5jdGlvbiByZWFkRGF0YSgpIHtcblxuXHRcdFx0XHRcdFx0XHRcdHJlYWRlci5yZWFkKCkudGhlbiggKCB7IGRvbmUsIHZhbHVlIH0gKSA9PiB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZG9uZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb250cm9sbGVyLmNsb3NlKCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0bG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgZXZlbnQgPSBuZXcgUHJvZ3Jlc3NFdmVudCggJ3Byb2dyZXNzJywgeyBsZW5ndGhDb21wdXRhYmxlLCBsb2FkZWQsIHRvdGFsIH0gKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tzWyBpIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjay5vblByb2dyZXNzICkgY2FsbGJhY2sub25Qcm9ncmVzcyggZXZlbnQgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29udHJvbGxlci5lbnF1ZXVlKCB2YWx1ZSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZWFkRGF0YSgpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9LCAoIGUgKSA9PiB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNvbnRyb2xsZXIuZXJyb3IoIGUgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgUmVzcG9uc2UoIHN0cmVhbSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgSHR0cEVycm9yKCBgZmV0Y2ggZm9yIFwiJHtyZXNwb25zZS51cmx9XCIgcmVzcG9uZGVkIHdpdGggJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCwgcmVzcG9uc2UgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKVxuXHRcdFx0LnRoZW4oIHJlc3BvbnNlID0+IHtcblxuXHRcdFx0XHRzd2l0Y2ggKCByZXNwb25zZVR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdhcnJheWJ1ZmZlcic6XG5cblx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuXG5cdFx0XHRcdFx0Y2FzZSAnYmxvYic6XG5cblx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZS5ibG9iKCk7XG5cblx0XHRcdFx0XHRjYXNlICdkb2N1bWVudCc6XG5cblx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZS50ZXh0KClcblx0XHRcdFx0XHRcdFx0LnRoZW4oIHRleHQgPT4ge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKCB0ZXh0LCBtaW1lVHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdGNhc2UgJ2pzb24nOlxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0aWYgKCBtaW1lVHlwZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZS50ZXh0KCk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gc25pZmYgZW5jb2Rpbmdcblx0XHRcdFx0XHRcdFx0Y29uc3QgcmUgPSAvY2hhcnNldD1cIj8oW147XCJcXHNdKilcIj8vaTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZXhlYyA9IHJlLmV4ZWMoIG1pbWVUeXBlICk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGxhYmVsID0gZXhlYyAmJiBleGVjWyAxIF0gPyBleGVjWyAxIF0udG9Mb3dlckNhc2UoKSA6IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlciggbGFiZWwgKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCkudGhlbiggYWIgPT4gZGVjb2Rlci5kZWNvZGUoIGFiICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApXG5cdFx0XHQudGhlbiggZGF0YSA9PiB7XG5cblx0XHRcdFx0Ly8gQWRkIHRvIGNhY2hlIG9ubHkgb24gSFRUUCBzdWNjZXNzLCBzbyB0aGF0IHdlIGRvIG5vdCBjYWNoZVxuXHRcdFx0XHQvLyBlcnJvciByZXNwb25zZSBib2RpZXMgYXMgcHJvcGVyIHJlc3BvbnNlcyB0byByZXF1ZXN0cy5cblx0XHRcdFx0Q2FjaGUuYWRkKCB1cmwsIGRhdGEgKTtcblxuXHRcdFx0XHRjb25zdCBjYWxsYmFja3MgPSBsb2FkaW5nWyB1cmwgXTtcblx0XHRcdFx0ZGVsZXRlIGxvYWRpbmdbIHVybCBdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBjYWxsYmFjayA9IGNhbGxiYWNrc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sub25Mb2FkICkgY2FsbGJhY2sub25Mb2FkKCBkYXRhICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IClcblx0XHRcdC5jYXRjaCggZXJyID0+IHtcblxuXHRcdFx0XHQvLyBBYm9ydCBlcnJvcnMgYW5kIG90aGVyIGVycm9ycyBhcmUgaGFuZGxlZCB0aGUgc2FtZVxuXG5cdFx0XHRcdGNvbnN0IGNhbGxiYWNrcyA9IGxvYWRpbmdbIHVybCBdO1xuXG5cdFx0XHRcdGlmICggY2FsbGJhY2tzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXaGVuIG9uTG9hZCB3YXMgY2FsbGVkIGFuZCB1cmwgd2FzIGRlbGV0ZWQgaW4gYGxvYWRpbmdgXG5cdFx0XHRcdFx0dGhpcy5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cdFx0XHRcdFx0dGhyb3cgZXJyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgbG9hZGluZ1sgdXJsIF07XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjay5vbkVycm9yICkgY2FsbGJhY2sub25FcnJvciggZXJyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0XHR9IClcblx0XHRcdC5maW5hbGx5KCAoKSA9PiB7XG5cblx0XHRcdFx0dGhpcy5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuXHR9XG5cblx0c2V0UmVzcG9uc2VUeXBlKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMucmVzcG9uc2VUeXBlID0gdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldE1pbWVUeXBlKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMubWltZVR5cGUgPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY2xhc3MgQW5pbWF0aW9uTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH1cblxuXHRwYXJzZSgganNvbiApIHtcblxuXHRcdGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBjbGlwID0gQW5pbWF0aW9uQ2xpcC5wYXJzZSgganNvblsgaSBdICk7XG5cblx0XHRcdGFuaW1hdGlvbnMucHVzaCggY2xpcCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFuaW1hdGlvbnM7XG5cblx0fVxuXG59XG5cbi8qKlxuICogQWJzdHJhY3QgQmFzZSBjbGFzcyB0byBibG9jayBiYXNlZCB0ZXh0dXJlcyBsb2FkZXIgKGRkcywgcHZyLCAuLi4pXG4gKlxuICogU3ViIGNsYXNzZXMgaGF2ZSB0byBpbXBsZW1lbnQgdGhlIHBhcnNlKCkgbWV0aG9kIHdoaWNoIHdpbGwgYmUgdXNlZCBpbiBsb2FkKCkuXG4gKi9cblxuY2xhc3MgQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xuXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcblxuXHR9XG5cblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBpbWFnZXMgPSBbXTtcblxuXHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgQ29tcHJlc3NlZFRleHR1cmUoKTtcblxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCBzY29wZS53aXRoQ3JlZGVudGlhbHMgKTtcblxuXHRcdGxldCBsb2FkZWQgPSAwO1xuXG5cdFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoIGkgKSB7XG5cblx0XHRcdGxvYWRlci5sb2FkKCB1cmxbIGkgXSwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cblx0XHRcdFx0Y29uc3QgdGV4RGF0YXMgPSBzY29wZS5wYXJzZSggYnVmZmVyLCB0cnVlICk7XG5cblx0XHRcdFx0aW1hZ2VzWyBpIF0gPSB7XG5cdFx0XHRcdFx0d2lkdGg6IHRleERhdGFzLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogdGV4RGF0YXMuaGVpZ2h0LFxuXHRcdFx0XHRcdGZvcm1hdDogdGV4RGF0YXMuZm9ybWF0LFxuXHRcdFx0XHRcdG1pcG1hcHM6IHRleERhdGFzLm1pcG1hcHNcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRsb2FkZWQgKz0gMTtcblxuXHRcdFx0XHRpZiAoIGxvYWRlZCA9PT0gNiApIHtcblxuXHRcdFx0XHRcdGlmICggdGV4RGF0YXMubWlwbWFwQ291bnQgPT09IDEgKSB0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcblxuXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZXM7XG5cdFx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG5cdFx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB1cmwgKSApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHVybC5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcblxuXHRcdFx0XHRsb2FkVGV4dHVyZSggaSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBjb21wcmVzc2VkIGN1YmVtYXAgdGV4dHVyZSBzdG9yZWQgaW4gYSBzaW5nbGUgRERTIGZpbGVcblxuXHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cblx0XHRcdFx0Y29uc3QgdGV4RGF0YXMgPSBzY29wZS5wYXJzZSggYnVmZmVyLCB0cnVlICk7XG5cblx0XHRcdFx0aWYgKCB0ZXhEYXRhcy5pc0N1YmVtYXAgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBmYWNlcyA9IHRleERhdGFzLm1pcG1hcHMubGVuZ3RoIC8gdGV4RGF0YXMubWlwbWFwQ291bnQ7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgZiA9IDA7IGYgPCBmYWNlczsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0gPSB7IG1pcG1hcHM6IFtdIH07XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRleERhdGFzLm1pcG1hcENvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLm1pcG1hcHMucHVzaCggdGV4RGF0YXMubWlwbWFwc1sgZiAqIHRleERhdGFzLm1pcG1hcENvdW50ICsgaSBdICk7XG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0ud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0uaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhcy5oZWlnaHQ7XG5cdFx0XHRcdFx0dGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YXMubWlwbWFwcztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcblx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fVxuXG59XG5cbmNsYXNzIEltYWdlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0aWYgKCB0aGlzLnBhdGggIT09IHVuZGVmaW5lZCApIHVybCA9IHRoaXMucGF0aCArIHVybDtcblxuXHRcdHVybCA9IHRoaXMubWFuYWdlci5yZXNvbHZlVVJMKCB1cmwgKTtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGNvbnN0IGNhY2hlZCA9IENhY2hlLmdldCggdXJsICk7XG5cblx0XHRpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cblx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggY2FjaGVkICk7XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0fSwgMCApO1xuXG5cdFx0XHRyZXR1cm4gY2FjaGVkO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaW1hZ2UgPSBjcmVhdGVFbGVtZW50TlMoICdpbWcnICk7XG5cblx0XHRmdW5jdGlvbiBvbkltYWdlTG9hZCgpIHtcblxuXHRcdFx0cmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcblxuXHRcdFx0Q2FjaGUuYWRkKCB1cmwsIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRoaXMgKTtcblxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uSW1hZ2VFcnJvciggZXZlbnQgKSB7XG5cblx0XHRcdHJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG5cblx0XHRcdGlmICggb25FcnJvciApIG9uRXJyb3IoIGV2ZW50ICk7XG5cblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycygpIHtcblxuXHRcdFx0aW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBvbkltYWdlTG9hZCwgZmFsc2UgKTtcblx0XHRcdGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdlcnJvcicsIG9uSW1hZ2VFcnJvciwgZmFsc2UgKTtcblxuXHRcdH1cblxuXHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgb25JbWFnZUxvYWQsIGZhbHNlICk7XG5cdFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgb25JbWFnZUVycm9yLCBmYWxzZSApO1xuXG5cdFx0aWYgKCB1cmwuc2xpY2UoIDAsIDUgKSAhPT0gJ2RhdGE6JyApIHtcblxuXHRcdFx0aWYgKCB0aGlzLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgKSBpbWFnZS5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XG5cblx0XHR9XG5cblx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cblx0XHRpbWFnZS5zcmMgPSB1cmw7XG5cblx0XHRyZXR1cm4gaW1hZ2U7XG5cblx0fVxuXG59XG5cbmNsYXNzIEN1YmVUZXh0dXJlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdGxvYWQoIHVybHMsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoKTtcblx0XHR0ZXh0dXJlLmNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZTtcblxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXG5cdFx0bGV0IGxvYWRlZCA9IDA7XG5cblx0XHRmdW5jdGlvbiBsb2FkVGV4dHVyZSggaSApIHtcblxuXHRcdFx0bG9hZGVyLmxvYWQoIHVybHNbIGkgXSwgZnVuY3Rpb24gKCBpbWFnZSApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLmltYWdlc1sgaSBdID0gaW1hZ2U7XG5cblx0XHRcdFx0bG9hZGVkICsrO1xuXG5cdFx0XHRcdGlmICggbG9hZGVkID09PSA2ICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSwgdW5kZWZpbmVkLCBvbkVycm9yICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0bG9hZFRleHR1cmUoIGkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gbG9hZCBnZW5lcmljIGJpbmFyeSB0ZXh0dXJlcyBmb3JtYXRzIChyZ2JlLCBoZHIsIC4uLilcbiAqXG4gKiBTdWIgY2xhc3NlcyBoYXZlIHRvIGltcGxlbWVudCB0aGUgcGFyc2UoKSBtZXRob2Qgd2hpY2ggd2lsbCBiZSB1c2VkIGluIGxvYWQoKS5cbiAqL1xuXG5jbGFzcyBEYXRhVGV4dHVyZUxvYWRlciBleHRlbmRzIExvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdH1cblxuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUoKTtcblxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMucmVxdWVzdEhlYWRlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCBzY29wZS53aXRoQ3JlZGVudGlhbHMgKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuXHRcdFx0bGV0IHRleERhdGE7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0dGV4RGF0YSA9IHNjb3BlLnBhcnNlKCBidWZmZXIgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZXJyb3IgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZXJyb3IgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGV4RGF0YS5pbWFnZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRleHR1cmUuaW1hZ2UgPSB0ZXhEYXRhLmltYWdlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0ZXhEYXRhLmRhdGEgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YS53aWR0aDtcblx0XHRcdFx0dGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhLmhlaWdodDtcblx0XHRcdFx0dGV4dHVyZS5pbWFnZS5kYXRhID0gdGV4RGF0YS5kYXRhO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRleHR1cmUud3JhcFMgPSB0ZXhEYXRhLndyYXBTICE9PSB1bmRlZmluZWQgPyB0ZXhEYXRhLndyYXBTIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcblx0XHRcdHRleHR1cmUud3JhcFQgPSB0ZXhEYXRhLndyYXBUICE9PSB1bmRlZmluZWQgPyB0ZXhEYXRhLndyYXBUIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuXHRcdFx0dGV4dHVyZS5tYWdGaWx0ZXIgPSB0ZXhEYXRhLm1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gdGV4RGF0YS5tYWdGaWx0ZXIgOiBMaW5lYXJGaWx0ZXI7XG5cdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IHRleERhdGEubWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyB0ZXhEYXRhLm1pbkZpbHRlciA6IExpbmVhckZpbHRlcjtcblxuXHRcdFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gdGV4RGF0YS5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgPyB0ZXhEYXRhLmFuaXNvdHJvcHkgOiAxO1xuXG5cdFx0XHRpZiAoIHRleERhdGEuY29sb3JTcGFjZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRleHR1cmUuY29sb3JTcGFjZSA9IHRleERhdGEuY29sb3JTcGFjZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRleERhdGEuZmxpcFkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLmZsaXBZID0gdGV4RGF0YS5mbGlwWTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRleERhdGEuZm9ybWF0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhLmZvcm1hdDtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRleERhdGEudHlwZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRleHR1cmUudHlwZSA9IHRleERhdGEudHlwZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRleERhdGEubWlwbWFwcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRleHR1cmUubWlwbWFwcyA9IHRleERhdGEubWlwbWFwcztcblx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXI7IC8vIHByZXN1bWFibHkuLi5cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRleERhdGEubWlwbWFwQ291bnQgPT09IDEgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0ZXhEYXRhLmdlbmVyYXRlTWlwbWFwcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gdGV4RGF0YS5nZW5lcmF0ZU1pcG1hcHM7XG5cblx0XHRcdH1cblxuXHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlLCB0ZXhEYXRhICk7XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH1cblxufVxuXG5jbGFzcyBUZXh0dXJlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XG5cblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggaW1hZ2UgKSB7XG5cblx0XHRcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZTtcblx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG9uTG9hZCggdGV4dHVyZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9XG5cbn1cblxuY2xhc3MgTGlnaHQgZXh0ZW5kcyBPYmplY3QzRCB7XG5cblx0Y29uc3RydWN0b3IoIGNvbG9yLCBpbnRlbnNpdHkgPSAxICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNMaWdodCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnTGlnaHQnO1xuXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggY29sb3IgKTtcblx0XHR0aGlzLmludGVuc2l0eSA9IGludGVuc2l0eTtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdC8vIEVtcHR5IGhlcmUgaW4gYmFzZSBjbGFzczsgc29tZSBzdWJjbGFzc2VzIG92ZXJyaWRlLlxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XG5cblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXHRcdHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oIG1ldGEgKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCBtZXRhICk7XG5cblx0XHRkYXRhLm9iamVjdC5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG5cdFx0ZGF0YS5vYmplY3QuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG5cblx0XHRpZiAoIHRoaXMuZ3JvdW5kQ29sb3IgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0Lmdyb3VuZENvbG9yID0gdGhpcy5ncm91bmRDb2xvci5nZXRIZXgoKTtcblxuXHRcdGlmICggdGhpcy5kaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlO1xuXHRcdGlmICggdGhpcy5hbmdsZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuYW5nbGUgPSB0aGlzLmFuZ2xlO1xuXHRcdGlmICggdGhpcy5kZWNheSAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuZGVjYXkgPSB0aGlzLmRlY2F5O1xuXHRcdGlmICggdGhpcy5wZW51bWJyYSAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QucGVudW1icmEgPSB0aGlzLnBlbnVtYnJhO1xuXG5cdFx0aWYgKCB0aGlzLnNoYWRvdyAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3Quc2hhZG93ID0gdGhpcy5zaGFkb3cudG9KU09OKCk7XG5cdFx0aWYgKCB0aGlzLnRhcmdldCAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QudGFyZ2V0ID0gdGhpcy50YXJnZXQudXVpZDtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxufVxuXG5jbGFzcyBIZW1pc3BoZXJlTGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cblx0Y29uc3RydWN0b3IoIHNreUNvbG9yLCBncm91bmRDb2xvciwgaW50ZW5zaXR5ICkge1xuXG5cdFx0c3VwZXIoIHNreUNvbG9yLCBpbnRlbnNpdHkgKTtcblxuXHRcdHRoaXMuaXNIZW1pc3BoZXJlTGlnaHQgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0hlbWlzcGhlcmVMaWdodCc7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIE9iamVjdDNELkRFRkFVTFRfVVAgKTtcblx0XHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0dGhpcy5ncm91bmRDb2xvciA9IG5ldyBDb2xvciggZ3JvdW5kQ29sb3IgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0dGhpcy5ncm91bmRDb2xvci5jb3B5KCBzb3VyY2UuZ3JvdW5kQ29sb3IgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jb25zdCBfcHJvalNjcmVlbk1hdHJpeCQxID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX2xpZ2h0UG9zaXRpb25Xb3JsZCQxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2xvb2tUYXJnZXQkMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY2xhc3MgTGlnaHRTaGFkb3cge1xuXG5cdGNvbnN0cnVjdG9yKCBjYW1lcmEgKSB7XG5cblx0XHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcblxuXHRcdHRoaXMuaW50ZW5zaXR5ID0gMTtcblxuXHRcdHRoaXMuYmlhcyA9IDA7XG5cdFx0dGhpcy5ub3JtYWxCaWFzID0gMDtcblx0XHR0aGlzLnJhZGl1cyA9IDE7XG5cdFx0dGhpcy5ibHVyU2FtcGxlcyA9IDg7XG5cblx0XHR0aGlzLm1hcFNpemUgPSBuZXcgVmVjdG9yMiggNTEyLCA1MTIgKTtcblxuXHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHR0aGlzLm1hcFBhc3MgPSBudWxsO1xuXHRcdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fZnJ1c3R1bSA9IG5ldyBGcnVzdHVtKCk7XG5cdFx0dGhpcy5fZnJhbWVFeHRlbnRzID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcblxuXHRcdHRoaXMuX3ZpZXdwb3J0Q291bnQgPSAxO1xuXG5cdFx0dGhpcy5fdmlld3BvcnRzID0gW1xuXG5cdFx0XHRuZXcgVmVjdG9yNCggMCwgMCwgMSwgMSApXG5cblx0XHRdO1xuXG5cdH1cblxuXHRnZXRWaWV3cG9ydENvdW50KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3ZpZXdwb3J0Q291bnQ7XG5cblx0fVxuXG5cdGdldEZydXN0dW0oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fZnJ1c3R1bTtcblxuXHR9XG5cblx0dXBkYXRlTWF0cmljZXMoIGxpZ2h0ICkge1xuXG5cdFx0Y29uc3Qgc2hhZG93Q2FtZXJhID0gdGhpcy5jYW1lcmE7XG5cdFx0Y29uc3Qgc2hhZG93TWF0cml4ID0gdGhpcy5tYXRyaXg7XG5cblx0XHRfbGlnaHRQb3NpdGlvbldvcmxkJDEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdHNoYWRvd0NhbWVyYS5wb3NpdGlvbi5jb3B5KCBfbGlnaHRQb3NpdGlvbldvcmxkJDEgKTtcblxuXHRcdF9sb29rVGFyZ2V0JDEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcblx0XHRzaGFkb3dDYW1lcmEubG9va0F0KCBfbG9va1RhcmdldCQxICk7XG5cdFx0c2hhZG93Q2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHRfcHJvalNjcmVlbk1hdHJpeCQxLm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cdFx0dGhpcy5fZnJ1c3R1bS5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXgkMSApO1xuXG5cdFx0c2hhZG93TWF0cml4LnNldChcblx0XHRcdDAuNSwgMC4wLCAwLjAsIDAuNSxcblx0XHRcdDAuMCwgMC41LCAwLjAsIDAuNSxcblx0XHRcdDAuMCwgMC4wLCAwLjUsIDAuNSxcblx0XHRcdDAuMCwgMC4wLCAwLjAsIDEuMFxuXHRcdCk7XG5cblx0XHRzaGFkb3dNYXRyaXgubXVsdGlwbHkoIF9wcm9qU2NyZWVuTWF0cml4JDEgKTtcblxuXHR9XG5cblx0Z2V0Vmlld3BvcnQoIHZpZXdwb3J0SW5kZXggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fdmlld3BvcnRzWyB2aWV3cG9ydEluZGV4IF07XG5cblx0fVxuXG5cdGdldEZyYW1lRXh0ZW50cygpIHtcblxuXHRcdHJldHVybiB0aGlzLl9mcmFtZUV4dGVudHM7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHRpZiAoIHRoaXMubWFwICkge1xuXG5cdFx0XHR0aGlzLm1hcC5kaXNwb3NlKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubWFwUGFzcyApIHtcblxuXHRcdFx0dGhpcy5tYXBQYXNzLmRpc3Bvc2UoKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0dGhpcy5jYW1lcmEgPSBzb3VyY2UuY2FtZXJhLmNsb25lKCk7XG5cblx0XHR0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XG5cblx0XHR0aGlzLmJpYXMgPSBzb3VyY2UuYmlhcztcblx0XHR0aGlzLnJhZGl1cyA9IHNvdXJjZS5yYWRpdXM7XG5cblx0XHR0aGlzLm1hcFNpemUuY29weSggc291cmNlLm1hcFNpemUgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3Qgb2JqZWN0ID0ge307XG5cblx0XHRpZiAoIHRoaXMuaW50ZW5zaXR5ICE9PSAxICkgb2JqZWN0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuXHRcdGlmICggdGhpcy5iaWFzICE9PSAwICkgb2JqZWN0LmJpYXMgPSB0aGlzLmJpYXM7XG5cdFx0aWYgKCB0aGlzLm5vcm1hbEJpYXMgIT09IDAgKSBvYmplY3Qubm9ybWFsQmlhcyA9IHRoaXMubm9ybWFsQmlhcztcblx0XHRpZiAoIHRoaXMucmFkaXVzICE9PSAxICkgb2JqZWN0LnJhZGl1cyA9IHRoaXMucmFkaXVzO1xuXHRcdGlmICggdGhpcy5tYXBTaXplLnggIT09IDUxMiB8fCB0aGlzLm1hcFNpemUueSAhPT0gNTEyICkgb2JqZWN0Lm1hcFNpemUgPSB0aGlzLm1hcFNpemUudG9BcnJheSgpO1xuXG5cdFx0b2JqZWN0LmNhbWVyYSA9IHRoaXMuY2FtZXJhLnRvSlNPTiggZmFsc2UgKS5vYmplY3Q7XG5cdFx0ZGVsZXRlIG9iamVjdC5jYW1lcmEubWF0cml4O1xuXG5cdFx0cmV0dXJuIG9iamVjdDtcblxuXHR9XG5cbn1cblxuY2xhc3MgU3BvdExpZ2h0U2hhZG93IGV4dGVuZHMgTGlnaHRTaGFkb3cge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggNTAsIDEsIDAuNSwgNTAwICkgKTtcblxuXHRcdHRoaXMuaXNTcG90TGlnaHRTaGFkb3cgPSB0cnVlO1xuXG5cdFx0dGhpcy5mb2N1cyA9IDE7XG5cblx0fVxuXG5cdHVwZGF0ZU1hdHJpY2VzKCBsaWdodCApIHtcblxuXHRcdGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuXG5cdFx0Y29uc3QgZm92ID0gUkFEMkRFRyAqIDIgKiBsaWdodC5hbmdsZSAqIHRoaXMuZm9jdXM7XG5cdFx0Y29uc3QgYXNwZWN0ID0gdGhpcy5tYXBTaXplLndpZHRoIC8gdGhpcy5tYXBTaXplLmhlaWdodDtcblx0XHRjb25zdCBmYXIgPSBsaWdodC5kaXN0YW5jZSB8fCBjYW1lcmEuZmFyO1xuXG5cdFx0aWYgKCBmb3YgIT09IGNhbWVyYS5mb3YgfHwgYXNwZWN0ICE9PSBjYW1lcmEuYXNwZWN0IHx8IGZhciAhPT0gY2FtZXJhLmZhciApIHtcblxuXHRcdFx0Y2FtZXJhLmZvdiA9IGZvdjtcblx0XHRcdGNhbWVyYS5hc3BlY3QgPSBhc3BlY3Q7XG5cdFx0XHRjYW1lcmEuZmFyID0gZmFyO1xuXHRcdFx0Y2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHRcdH1cblxuXHRcdHN1cGVyLnVwZGF0ZU1hdHJpY2VzKCBsaWdodCApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuZm9jdXMgPSBzb3VyY2UuZm9jdXM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY2xhc3MgU3BvdExpZ2h0IGV4dGVuZHMgTGlnaHQge1xuXG5cdGNvbnN0cnVjdG9yKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSA9IDAsIGFuZ2xlID0gTWF0aC5QSSAvIDMsIHBlbnVtYnJhID0gMCwgZGVjYXkgPSAyICkge1xuXG5cdFx0c3VwZXIoIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuXHRcdHRoaXMuaXNTcG90TGlnaHQgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1Nwb3RMaWdodCc7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIE9iamVjdDNELkRFRkFVTFRfVVAgKTtcblx0XHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0dGhpcy50YXJnZXQgPSBuZXcgT2JqZWN0M0QoKTtcblxuXHRcdHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0XHR0aGlzLmFuZ2xlID0gYW5nbGU7XG5cdFx0dGhpcy5wZW51bWJyYSA9IHBlbnVtYnJhO1xuXHRcdHRoaXMuZGVjYXkgPSBkZWNheTtcblxuXHRcdHRoaXMubWFwID0gbnVsbDtcblxuXHRcdHRoaXMuc2hhZG93ID0gbmV3IFNwb3RMaWdodFNoYWRvdygpO1xuXG5cdH1cblxuXHRnZXQgcG93ZXIoKSB7XG5cblx0XHQvLyBjb21wdXRlIHRoZSBsaWdodCdzIGx1bWlub3VzIHBvd2VyIChpbiBsdW1lbnMpIGZyb20gaXRzIGludGVuc2l0eSAoaW4gY2FuZGVsYSlcblx0XHQvLyBieSBjb252ZW50aW9uIGZvciBhIHNwb3RsaWdodCwgbHVtaW5vdXMgcG93ZXIgKGxtKSA9IM+AICogbHVtaW5vdXMgaW50ZW5zaXR5IChjZClcblx0XHRyZXR1cm4gdGhpcy5pbnRlbnNpdHkgKiBNYXRoLlBJO1xuXG5cdH1cblxuXHRzZXQgcG93ZXIoIHBvd2VyICkge1xuXG5cdFx0Ly8gc2V0IHRoZSBsaWdodCdzIGludGVuc2l0eSAoaW4gY2FuZGVsYSkgZnJvbSB0aGUgZGVzaXJlZCBsdW1pbm91cyBwb3dlciAoaW4gbHVtZW5zKVxuXHRcdHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyBNYXRoLlBJO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5zaGFkb3cuZGlzcG9zZSgpO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XG5cblx0XHR0aGlzLmRpc3RhbmNlID0gc291cmNlLmRpc3RhbmNlO1xuXHRcdHRoaXMuYW5nbGUgPSBzb3VyY2UuYW5nbGU7XG5cdFx0dGhpcy5wZW51bWJyYSA9IHNvdXJjZS5wZW51bWJyYTtcblx0XHR0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xuXG5cdFx0dGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XG5cblx0XHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jb25zdCBfcHJvalNjcmVlbk1hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9saWdodFBvc2l0aW9uV29ybGQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfbG9va1RhcmdldCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY2xhc3MgUG9pbnRMaWdodFNoYWRvdyBleHRlbmRzIExpZ2h0U2hhZG93IHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIDkwLCAxLCAwLjUsIDUwMCApICk7XG5cblx0XHR0aGlzLmlzUG9pbnRMaWdodFNoYWRvdyA9IHRydWU7XG5cblx0XHR0aGlzLl9mcmFtZUV4dGVudHMgPSBuZXcgVmVjdG9yMiggNCwgMiApO1xuXG5cdFx0dGhpcy5fdmlld3BvcnRDb3VudCA9IDY7XG5cblx0XHR0aGlzLl92aWV3cG9ydHMgPSBbXG5cdFx0XHQvLyBUaGVzZSB2aWV3cG9ydHMgbWFwIGEgY3ViZS1tYXAgb250byBhIDJEIHRleHR1cmUgd2l0aCB0aGVcblx0XHRcdC8vIGZvbGxvd2luZyBvcmllbnRhdGlvbjpcblx0XHRcdC8vXG5cdFx0XHQvLyAgeHpYWlxuXHRcdFx0Ly8gICB5IFlcblx0XHRcdC8vXG5cdFx0XHQvLyBYIC0gUG9zaXRpdmUgeCBkaXJlY3Rpb25cblx0XHRcdC8vIHggLSBOZWdhdGl2ZSB4IGRpcmVjdGlvblxuXHRcdFx0Ly8gWSAtIFBvc2l0aXZlIHkgZGlyZWN0aW9uXG5cdFx0XHQvLyB5IC0gTmVnYXRpdmUgeSBkaXJlY3Rpb25cblx0XHRcdC8vIFogLSBQb3NpdGl2ZSB6IGRpcmVjdGlvblxuXHRcdFx0Ly8geiAtIE5lZ2F0aXZlIHogZGlyZWN0aW9uXG5cblx0XHRcdC8vIHBvc2l0aXZlIFhcblx0XHRcdG5ldyBWZWN0b3I0KCAyLCAxLCAxLCAxICksXG5cdFx0XHQvLyBuZWdhdGl2ZSBYXG5cdFx0XHRuZXcgVmVjdG9yNCggMCwgMSwgMSwgMSApLFxuXHRcdFx0Ly8gcG9zaXRpdmUgWlxuXHRcdFx0bmV3IFZlY3RvcjQoIDMsIDEsIDEsIDEgKSxcblx0XHRcdC8vIG5lZ2F0aXZlIFpcblx0XHRcdG5ldyBWZWN0b3I0KCAxLCAxLCAxLCAxICksXG5cdFx0XHQvLyBwb3NpdGl2ZSBZXG5cdFx0XHRuZXcgVmVjdG9yNCggMywgMCwgMSwgMSApLFxuXHRcdFx0Ly8gbmVnYXRpdmUgWVxuXHRcdFx0bmV3IFZlY3RvcjQoIDEsIDAsIDEsIDEgKVxuXHRcdF07XG5cblx0XHR0aGlzLl9jdWJlRGlyZWN0aW9ucyA9IFtcblx0XHRcdG5ldyBWZWN0b3IzKCAxLCAwLCAwICksIG5ldyBWZWN0b3IzKCAtIDEsIDAsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIDAsIDEgKSxcblx0XHRcdG5ldyBWZWN0b3IzKCAwLCAwLCAtIDEgKSwgbmV3IFZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIC0gMSwgMCApXG5cdFx0XTtcblxuXHRcdHRoaXMuX2N1YmVVcHMgPSBbXG5cdFx0XHRuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMSwgMCApLFxuXHRcdFx0bmV3IFZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIDAsIDEgKSxcdG5ldyBWZWN0b3IzKCAwLCAwLCAtIDEgKVxuXHRcdF07XG5cblx0fVxuXG5cdHVwZGF0ZU1hdHJpY2VzKCBsaWdodCwgdmlld3BvcnRJbmRleCA9IDAgKSB7XG5cblx0XHRjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcblx0XHRjb25zdCBzaGFkb3dNYXRyaXggPSB0aGlzLm1hdHJpeDtcblxuXHRcdGNvbnN0IGZhciA9IGxpZ2h0LmRpc3RhbmNlIHx8IGNhbWVyYS5mYXI7XG5cblx0XHRpZiAoIGZhciAhPT0gY2FtZXJhLmZhciApIHtcblxuXHRcdFx0Y2FtZXJhLmZhciA9IGZhcjtcblx0XHRcdGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0XHR9XG5cblx0XHRfbGlnaHRQb3NpdGlvbldvcmxkLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRjYW1lcmEucG9zaXRpb24uY29weSggX2xpZ2h0UG9zaXRpb25Xb3JsZCApO1xuXG5cdFx0X2xvb2tUYXJnZXQuY29weSggY2FtZXJhLnBvc2l0aW9uICk7XG5cdFx0X2xvb2tUYXJnZXQuYWRkKCB0aGlzLl9jdWJlRGlyZWN0aW9uc1sgdmlld3BvcnRJbmRleCBdICk7XG5cdFx0Y2FtZXJhLnVwLmNvcHkoIHRoaXMuX2N1YmVVcHNbIHZpZXdwb3J0SW5kZXggXSApO1xuXHRcdGNhbWVyYS5sb29rQXQoIF9sb29rVGFyZ2V0ICk7XG5cdFx0Y2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHRzaGFkb3dNYXRyaXgubWFrZVRyYW5zbGF0aW9uKCAtIF9saWdodFBvc2l0aW9uV29ybGQueCwgLSBfbGlnaHRQb3NpdGlvbldvcmxkLnksIC0gX2xpZ2h0UG9zaXRpb25Xb3JsZC56ICk7XG5cblx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXHRcdHRoaXMuX2ZydXN0dW0uc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFBvaW50TGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cblx0Y29uc3RydWN0b3IoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlID0gMCwgZGVjYXkgPSAyICkge1xuXG5cdFx0c3VwZXIoIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuXHRcdHRoaXMuaXNQb2ludExpZ2h0ID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdQb2ludExpZ2h0JztcblxuXHRcdHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0XHR0aGlzLmRlY2F5ID0gZGVjYXk7XG5cblx0XHR0aGlzLnNoYWRvdyA9IG5ldyBQb2ludExpZ2h0U2hhZG93KCk7XG5cblx0fVxuXG5cdGdldCBwb3dlcigpIHtcblxuXHRcdC8vIGNvbXB1dGUgdGhlIGxpZ2h0J3MgbHVtaW5vdXMgcG93ZXIgKGluIGx1bWVucykgZnJvbSBpdHMgaW50ZW5zaXR5IChpbiBjYW5kZWxhKVxuXHRcdC8vIGZvciBhbiBpc290cm9waWMgbGlnaHQgc291cmNlLCBsdW1pbm91cyBwb3dlciAobG0pID0gNCDPgCBsdW1pbm91cyBpbnRlbnNpdHkgKGNkKVxuXHRcdHJldHVybiB0aGlzLmludGVuc2l0eSAqIDQgKiBNYXRoLlBJO1xuXG5cdH1cblxuXHRzZXQgcG93ZXIoIHBvd2VyICkge1xuXG5cdFx0Ly8gc2V0IHRoZSBsaWdodCdzIGludGVuc2l0eSAoaW4gY2FuZGVsYSkgZnJvbSB0aGUgZGVzaXJlZCBsdW1pbm91cyBwb3dlciAoaW4gbHVtZW5zKVxuXHRcdHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyAoIDQgKiBNYXRoLlBJICk7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLnNoYWRvdy5kaXNwb3NlKCk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlLCByZWN1cnNpdmUgKTtcblxuXHRcdHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XG5cdFx0dGhpcy5kZWNheSA9IHNvdXJjZS5kZWNheTtcblxuXHRcdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNsYXNzIE9ydGhvZ3JhcGhpY0NhbWVyYSBleHRlbmRzIENhbWVyYSB7XG5cblx0Y29uc3RydWN0b3IoIGxlZnQgPSAtIDEsIHJpZ2h0ID0gMSwgdG9wID0gMSwgYm90dG9tID0gLSAxLCBuZWFyID0gMC4xLCBmYXIgPSAyMDAwICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNPcnRob2dyYXBoaWNDYW1lcmEgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ09ydGhvZ3JhcGhpY0NhbWVyYSc7XG5cblx0XHR0aGlzLnpvb20gPSAxO1xuXHRcdHRoaXMudmlldyA9IG51bGw7XG5cblx0XHR0aGlzLmxlZnQgPSBsZWZ0O1xuXHRcdHRoaXMucmlnaHQgPSByaWdodDtcblx0XHR0aGlzLnRvcCA9IHRvcDtcblx0XHR0aGlzLmJvdHRvbSA9IGJvdHRvbTtcblxuXHRcdHRoaXMubmVhciA9IG5lYXI7XG5cdFx0dGhpcy5mYXIgPSBmYXI7XG5cblx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0dGhpcy5sZWZ0ID0gc291cmNlLmxlZnQ7XG5cdFx0dGhpcy5yaWdodCA9IHNvdXJjZS5yaWdodDtcblx0XHR0aGlzLnRvcCA9IHNvdXJjZS50b3A7XG5cdFx0dGhpcy5ib3R0b20gPSBzb3VyY2UuYm90dG9tO1xuXHRcdHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xuXHRcdHRoaXMuZmFyID0gc291cmNlLmZhcjtcblxuXHRcdHRoaXMuem9vbSA9IHNvdXJjZS56b29tO1xuXHRcdHRoaXMudmlldyA9IHNvdXJjZS52aWV3ID09PSBudWxsID8gbnVsbCA6IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UudmlldyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFZpZXdPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcblxuXHRcdGlmICggdGhpcy52aWV3ID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLnZpZXcgPSB7XG5cdFx0XHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0XHRcdGZ1bGxXaWR0aDogMSxcblx0XHRcdFx0ZnVsbEhlaWdodDogMSxcblx0XHRcdFx0b2Zmc2V0WDogMCxcblx0XHRcdFx0b2Zmc2V0WTogMCxcblx0XHRcdFx0d2lkdGg6IDEsXG5cdFx0XHRcdGhlaWdodDogMVxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdHRoaXMudmlldy5lbmFibGVkID0gdHJ1ZTtcblx0XHR0aGlzLnZpZXcuZnVsbFdpZHRoID0gZnVsbFdpZHRoO1xuXHRcdHRoaXMudmlldy5mdWxsSGVpZ2h0ID0gZnVsbEhlaWdodDtcblx0XHR0aGlzLnZpZXcub2Zmc2V0WCA9IHg7XG5cdFx0dGhpcy52aWV3Lm9mZnNldFkgPSB5O1xuXHRcdHRoaXMudmlldy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMudmlldy5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHR9XG5cblx0Y2xlYXJWaWV3T2Zmc2V0KCkge1xuXG5cdFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMudmlldy5lbmFibGVkID0gZmFsc2U7XG5cblx0XHR9XG5cblx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHR9XG5cblx0dXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpIHtcblxuXHRcdGNvbnN0IGR4ID0gKCB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0ICkgLyAoIDIgKiB0aGlzLnpvb20gKTtcblx0XHRjb25zdCBkeSA9ICggdGhpcy50b3AgLSB0aGlzLmJvdHRvbSApIC8gKCAyICogdGhpcy56b29tICk7XG5cdFx0Y29uc3QgY3ggPSAoIHRoaXMucmlnaHQgKyB0aGlzLmxlZnQgKSAvIDI7XG5cdFx0Y29uc3QgY3kgPSAoIHRoaXMudG9wICsgdGhpcy5ib3R0b20gKSAvIDI7XG5cblx0XHRsZXQgbGVmdCA9IGN4IC0gZHg7XG5cdFx0bGV0IHJpZ2h0ID0gY3ggKyBkeDtcblx0XHRsZXQgdG9wID0gY3kgKyBkeTtcblx0XHRsZXQgYm90dG9tID0gY3kgLSBkeTtcblxuXHRcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICYmIHRoaXMudmlldy5lbmFibGVkICkge1xuXG5cdFx0XHRjb25zdCBzY2FsZVcgPSAoIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQgKSAvIHRoaXMudmlldy5mdWxsV2lkdGggLyB0aGlzLnpvb207XG5cdFx0XHRjb25zdCBzY2FsZUggPSAoIHRoaXMudG9wIC0gdGhpcy5ib3R0b20gKSAvIHRoaXMudmlldy5mdWxsSGVpZ2h0IC8gdGhpcy56b29tO1xuXG5cdFx0XHRsZWZ0ICs9IHNjYWxlVyAqIHRoaXMudmlldy5vZmZzZXRYO1xuXHRcdFx0cmlnaHQgPSBsZWZ0ICsgc2NhbGVXICogdGhpcy52aWV3LndpZHRoO1xuXHRcdFx0dG9wIC09IHNjYWxlSCAqIHRoaXMudmlldy5vZmZzZXRZO1xuXHRcdFx0Ym90dG9tID0gdG9wIC0gc2NhbGVIICogdGhpcy52aWV3LmhlaWdodDtcblxuXHRcdH1cblxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlT3J0aG9ncmFwaGljKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIHRoaXMubmVhciwgdGhpcy5mYXIsIHRoaXMuY29vcmRpbmF0ZVN5c3RlbSApO1xuXG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KCB0aGlzLnByb2plY3Rpb25NYXRyaXggKS5pbnZlcnQoKTtcblxuXHR9XG5cblx0dG9KU09OKCBtZXRhICkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTiggbWV0YSApO1xuXG5cdFx0ZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcblx0XHRkYXRhLm9iamVjdC5sZWZ0ID0gdGhpcy5sZWZ0O1xuXHRcdGRhdGEub2JqZWN0LnJpZ2h0ID0gdGhpcy5yaWdodDtcblx0XHRkYXRhLm9iamVjdC50b3AgPSB0aGlzLnRvcDtcblx0XHRkYXRhLm9iamVjdC5ib3R0b20gPSB0aGlzLmJvdHRvbTtcblx0XHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xuXHRcdGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xuXG5cdFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSBkYXRhLm9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbigge30sIHRoaXMudmlldyApO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59XG5cbmNsYXNzIERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZXh0ZW5kcyBMaWdodFNoYWRvdyB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlciggbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSggLSA1LCA1LCA1LCAtIDUsIDAuNSwgNTAwICkgKTtcblxuXHRcdHRoaXMuaXNEaXJlY3Rpb25hbExpZ2h0U2hhZG93ID0gdHJ1ZTtcblxuXHR9XG5cbn1cblxuY2xhc3MgRGlyZWN0aW9uYWxMaWdodCBleHRlbmRzIExpZ2h0IHtcblxuXHRjb25zdHJ1Y3RvciggY29sb3IsIGludGVuc2l0eSApIHtcblxuXHRcdHN1cGVyKCBjb2xvciwgaW50ZW5zaXR5ICk7XG5cblx0XHR0aGlzLmlzRGlyZWN0aW9uYWxMaWdodCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnRGlyZWN0aW9uYWxMaWdodCc7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIE9iamVjdDNELkRFRkFVTFRfVVAgKTtcblx0XHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0dGhpcy50YXJnZXQgPSBuZXcgT2JqZWN0M0QoKTtcblxuXHRcdHRoaXMuc2hhZG93ID0gbmV3IERpcmVjdGlvbmFsTGlnaHRTaGFkb3coKTtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuc2hhZG93LmRpc3Bvc2UoKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnRhcmdldCA9IHNvdXJjZS50YXJnZXQuY2xvbmUoKTtcblx0XHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBBbWJpZW50TGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cblx0Y29uc3RydWN0b3IoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XG5cblx0XHRzdXBlciggY29sb3IsIGludGVuc2l0eSApO1xuXG5cdFx0dGhpcy5pc0FtYmllbnRMaWdodCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnQW1iaWVudExpZ2h0JztcblxuXHR9XG5cbn1cblxuY2xhc3MgUmVjdEFyZWFMaWdodCBleHRlbmRzIExpZ2h0IHtcblxuXHRjb25zdHJ1Y3RvciggY29sb3IsIGludGVuc2l0eSwgd2lkdGggPSAxMCwgaGVpZ2h0ID0gMTAgKSB7XG5cblx0XHRzdXBlciggY29sb3IsIGludGVuc2l0eSApO1xuXG5cdFx0dGhpcy5pc1JlY3RBcmVhTGlnaHQgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1JlY3RBcmVhTGlnaHQnO1xuXG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdH1cblxuXHRnZXQgcG93ZXIoKSB7XG5cblx0XHQvLyBjb21wdXRlIHRoZSBsaWdodCdzIGx1bWlub3VzIHBvd2VyIChpbiBsdW1lbnMpIGZyb20gaXRzIGludGVuc2l0eSAoaW4gbml0cylcblx0XHRyZXR1cm4gdGhpcy5pbnRlbnNpdHkgKiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQgKiBNYXRoLlBJO1xuXG5cdH1cblxuXHRzZXQgcG93ZXIoIHBvd2VyICkge1xuXG5cdFx0Ly8gc2V0IHRoZSBsaWdodCdzIGludGVuc2l0eSAoaW4gbml0cykgZnJvbSB0aGUgZGVzaXJlZCBsdW1pbm91cyBwb3dlciAoaW4gbHVtZW5zKVxuXHRcdHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyAoIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCAqIE1hdGguUEkgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLndpZHRoID0gc291cmNlLndpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gc291cmNlLmhlaWdodDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oIG1ldGEgKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCBtZXRhICk7XG5cblx0XHRkYXRhLm9iamVjdC53aWR0aCA9IHRoaXMud2lkdGg7XG5cdFx0ZGF0YS5vYmplY3QuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBQcmltYXJ5IHJlZmVyZW5jZTpcbiAqICAgaHR0cHM6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvcGFwZXJzL2Vudm1hcC9lbnZtYXAucGRmXG4gKlxuICogU2Vjb25kYXJ5IHJlZmVyZW5jZTpcbiAqICAgaHR0cHM6Ly93d3cucHBzbG9hbi5vcmcvcHVibGljYXRpb25zL1N0dXBpZFNIMzYucGRmXG4gKi9cblxuLy8gMy1iYW5kIFNIIGRlZmluZWQgYnkgOSBjb2VmZmljaWVudHNcblxuY2xhc3MgU3BoZXJpY2FsSGFybW9uaWNzMyB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHR0aGlzLmlzU3BoZXJpY2FsSGFybW9uaWNzMyA9IHRydWU7XG5cblx0XHR0aGlzLmNvZWZmaWNpZW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5jb2VmZmljaWVudHMucHVzaCggbmV3IFZlY3RvcjMoKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXQoIGNvZWZmaWNpZW50cyApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuY29lZmZpY2llbnRzWyBpIF0uY29weSggY29lZmZpY2llbnRzWyBpIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR6ZXJvKCkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5jb2VmZmljaWVudHNbIGkgXS5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvLyBnZXQgdGhlIHJhZGlhbmNlIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG5vcm1hbFxuXHQvLyB0YXJnZXQgaXMgYSBWZWN0b3IzXG5cdGdldEF0KCBub3JtYWwsIHRhcmdldCApIHtcblxuXHRcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGJlIHVuaXQgbGVuZ3RoXG5cblx0XHRjb25zdCB4ID0gbm9ybWFsLngsIHkgPSBub3JtYWwueSwgeiA9IG5vcm1hbC56O1xuXG5cdFx0Y29uc3QgY29lZmYgPSB0aGlzLmNvZWZmaWNpZW50cztcblxuXHRcdC8vIGJhbmQgMFxuXHRcdHRhcmdldC5jb3B5KCBjb2VmZlsgMCBdICkubXVsdGlwbHlTY2FsYXIoIDAuMjgyMDk1ICk7XG5cblx0XHQvLyBiYW5kIDFcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgMSBdLCAwLjQ4ODYwMyAqIHkgKTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgMiBdLCAwLjQ4ODYwMyAqIHogKTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgMyBdLCAwLjQ4ODYwMyAqIHggKTtcblxuXHRcdC8vIGJhbmQgMlxuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyA0IF0sIDEuMDkyNTQ4ICogKCB4ICogeSApICk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggY29lZmZbIDUgXSwgMS4wOTI1NDggKiAoIHkgKiB6ICkgKTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgNiBdLCAwLjMxNTM5MiAqICggMy4wICogeiAqIHogLSAxLjAgKSApO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyA3IF0sIDEuMDkyNTQ4ICogKCB4ICogeiApICk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggY29lZmZbIDggXSwgMC41NDYyNzQgKiAoIHggKiB4IC0geSAqIHkgKSApO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0Ly8gZ2V0IHRoZSBpcnJhZGlhbmNlIChyYWRpYW5jZSBjb252b2x2ZWQgd2l0aCBjb3NpbmUgbG9iZSkgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbm9ybWFsXG5cdC8vIHRhcmdldCBpcyBhIFZlY3RvcjNcblx0Ly8gaHR0cHM6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvcGFwZXJzL2Vudm1hcC9lbnZtYXAucGRmXG5cdGdldElycmFkaWFuY2VBdCggbm9ybWFsLCB0YXJnZXQgKSB7XG5cblx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aFxuXG5cdFx0Y29uc3QgeCA9IG5vcm1hbC54LCB5ID0gbm9ybWFsLnksIHogPSBub3JtYWwuejtcblxuXHRcdGNvbnN0IGNvZWZmID0gdGhpcy5jb2VmZmljaWVudHM7XG5cblx0XHQvLyBiYW5kIDBcblx0XHR0YXJnZXQuY29weSggY29lZmZbIDAgXSApLm11bHRpcGx5U2NhbGFyKCAwLjg4NjIyNyApOyAvLyDPgCAqIDAuMjgyMDk1XG5cblx0XHQvLyBiYW5kIDFcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgMSBdLCAyLjAgKiAwLjUxMTY2NCAqIHkgKTsgLy8gKCAyICogz4AgLyAzICkgKiAwLjQ4ODYwM1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyAyIF0sIDIuMCAqIDAuNTExNjY0ICogeiApO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyAzIF0sIDIuMCAqIDAuNTExNjY0ICogeCApO1xuXG5cdFx0Ly8gYmFuZCAyXG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggY29lZmZbIDQgXSwgMi4wICogMC40MjkwNDMgKiB4ICogeSApOyAvLyAoIM+AIC8gNCApICogMS4wOTI1NDhcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgNSBdLCAyLjAgKiAwLjQyOTA0MyAqIHkgKiB6ICk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggY29lZmZbIDYgXSwgMC43NDMxMjUgKiB6ICogeiAtIDAuMjQ3NzA4ICk7IC8vICggz4AgLyA0ICkgKiAwLjMxNTM5MiAqIDNcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgNyBdLCAyLjAgKiAwLjQyOTA0MyAqIHggKiB6ICk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggY29lZmZbIDggXSwgMC40MjkwNDMgKiAoIHggKiB4IC0geSAqIHkgKSApOyAvLyAoIM+AIC8gNCApICogMC41NDYyNzRcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdGFkZCggc2ggKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmNvZWZmaWNpZW50c1sgaSBdLmFkZCggc2guY29lZmZpY2llbnRzWyBpIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGRTY2FsZWRTSCggc2gsIHMgKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmNvZWZmaWNpZW50c1sgaSBdLmFkZFNjYWxlZFZlY3Rvciggc2guY29lZmZpY2llbnRzWyBpIF0sIHMgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzY2FsZSggcyApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuY29lZmZpY2llbnRzWyBpIF0ubXVsdGlwbHlTY2FsYXIoIHMgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRsZXJwKCBzaCwgYWxwaGEgKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmNvZWZmaWNpZW50c1sgaSBdLmxlcnAoIHNoLmNvZWZmaWNpZW50c1sgaSBdLCBhbHBoYSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVxdWFscyggc2ggKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xuXG5cdFx0XHRpZiAoICEgdGhpcy5jb2VmZmljaWVudHNbIGkgXS5lcXVhbHMoIHNoLmNvZWZmaWNpZW50c1sgaSBdICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0Y29weSggc2ggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoIHNoLmNvZWZmaWNpZW50cyApO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGNvbnN0IGNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcblxuXHRcdFx0Y29lZmZpY2llbnRzWyBpIF0uZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ICsgKCBpICogMyApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGNvbnN0IGNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcblxuXHRcdFx0Y29lZmZpY2llbnRzWyBpIF0udG9BcnJheSggYXJyYXksIG9mZnNldCArICggaSAqIDMgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHQvLyBldmFsdWF0ZSB0aGUgYmFzaXMgZnVuY3Rpb25zXG5cdC8vIHNoQmFzaXMgaXMgYW4gQXJyYXlbIDkgXVxuXHRzdGF0aWMgZ2V0QmFzaXNBdCggbm9ybWFsLCBzaEJhc2lzICkge1xuXG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gYmUgdW5pdCBsZW5ndGhcblxuXHRcdGNvbnN0IHggPSBub3JtYWwueCwgeSA9IG5vcm1hbC55LCB6ID0gbm9ybWFsLno7XG5cblx0XHQvLyBiYW5kIDBcblx0XHRzaEJhc2lzWyAwIF0gPSAwLjI4MjA5NTtcblxuXHRcdC8vIGJhbmQgMVxuXHRcdHNoQmFzaXNbIDEgXSA9IDAuNDg4NjAzICogeTtcblx0XHRzaEJhc2lzWyAyIF0gPSAwLjQ4ODYwMyAqIHo7XG5cdFx0c2hCYXNpc1sgMyBdID0gMC40ODg2MDMgKiB4O1xuXG5cdFx0Ly8gYmFuZCAyXG5cdFx0c2hCYXNpc1sgNCBdID0gMS4wOTI1NDggKiB4ICogeTtcblx0XHRzaEJhc2lzWyA1IF0gPSAxLjA5MjU0OCAqIHkgKiB6O1xuXHRcdHNoQmFzaXNbIDYgXSA9IDAuMzE1MzkyICogKCAzICogeiAqIHogLSAxICk7XG5cdFx0c2hCYXNpc1sgNyBdID0gMS4wOTI1NDggKiB4ICogejtcblx0XHRzaEJhc2lzWyA4IF0gPSAwLjU0NjI3NCAqICggeCAqIHggLSB5ICogeSApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBMaWdodFByb2JlIGV4dGVuZHMgTGlnaHQge1xuXG5cdGNvbnN0cnVjdG9yKCBzaCA9IG5ldyBTcGhlcmljYWxIYXJtb25pY3MzKCksIGludGVuc2l0eSA9IDEgKSB7XG5cblx0XHRzdXBlciggdW5kZWZpbmVkLCBpbnRlbnNpdHkgKTtcblxuXHRcdHRoaXMuaXNMaWdodFByb2JlID0gdHJ1ZTtcblxuXHRcdHRoaXMuc2ggPSBzaDtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnNoLmNvcHkoIHNvdXJjZS5zaCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0dGhpcy5pbnRlbnNpdHkgPSBqc29uLmludGVuc2l0eTsgLy8gVE9ETzogTW92ZSB0aGlzIGJpdCB0byBMaWdodC5mcm9tSlNPTigpO1xuXHRcdHRoaXMuc2guZnJvbUFycmF5KCBqc29uLnNoICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCBtZXRhICkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTiggbWV0YSApO1xuXG5cdFx0ZGF0YS5vYmplY3Quc2ggPSB0aGlzLnNoLnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxufVxuXG5jbGFzcyBNYXRlcmlhbExvYWRlciBleHRlbmRzIExvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXHRcdHRoaXMudGV4dHVyZXMgPSB7fTtcblxuXHR9XG5cblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggc2NvcGUubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCBzY29wZS5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHNjb3BlLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCBzY29wZS53aXRoQ3JlZGVudGlhbHMgKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH1cblxuXHRwYXJzZSgganNvbiApIHtcblxuXHRcdGNvbnN0IHRleHR1cmVzID0gdGhpcy50ZXh0dXJlcztcblxuXHRcdGZ1bmN0aW9uIGdldFRleHR1cmUoIG5hbWUgKSB7XG5cblx0XHRcdGlmICggdGV4dHVyZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGVyaWFsTG9hZGVyOiBVbmRlZmluZWQgdGV4dHVyZScsIG5hbWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZXNbIG5hbWUgXTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IG1hdGVyaWFsID0gdGhpcy5jcmVhdGVNYXRlcmlhbEZyb21UeXBlKCBqc29uLnR5cGUgKTtcblxuXHRcdGlmICgganNvbi51dWlkICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC51dWlkID0ganNvbi51dWlkO1xuXHRcdGlmICgganNvbi5uYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5uYW1lID0ganNvbi5uYW1lO1xuXHRcdGlmICgganNvbi5jb2xvciAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLmNvbG9yICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jb2xvci5zZXRIZXgoIGpzb24uY29sb3IgKTtcblx0XHRpZiAoIGpzb24ucm91Z2huZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5yb3VnaG5lc3MgPSBqc29uLnJvdWdobmVzcztcblx0XHRpZiAoIGpzb24ubWV0YWxuZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tZXRhbG5lc3MgPSBqc29uLm1ldGFsbmVzcztcblx0XHRpZiAoIGpzb24uc2hlZW4gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoZWVuID0ganNvbi5zaGVlbjtcblx0XHRpZiAoIGpzb24uc2hlZW5Db2xvciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hlZW5Db2xvciA9IG5ldyBDb2xvcigpLnNldEhleCgganNvbi5zaGVlbkNvbG9yICk7XG5cdFx0aWYgKCBqc29uLnNoZWVuUm91Z2huZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGVlblJvdWdobmVzcyA9IGpzb24uc2hlZW5Sb3VnaG5lc3M7XG5cdFx0aWYgKCBqc29uLmVtaXNzaXZlICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWwuZW1pc3NpdmUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlLnNldEhleCgganNvbi5lbWlzc2l2ZSApO1xuXHRcdGlmICgganNvbi5zcGVjdWxhciAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLnNwZWN1bGFyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhci5zZXRIZXgoIGpzb24uc3BlY3VsYXIgKTtcblx0XHRpZiAoIGpzb24uc3BlY3VsYXJJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5ID0ganNvbi5zcGVjdWxhckludGVuc2l0eTtcblx0XHRpZiAoIGpzb24uc3BlY3VsYXJDb2xvciAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3Iuc2V0SGV4KCBqc29uLnNwZWN1bGFyQ29sb3IgKTtcblx0XHRpZiAoIGpzb24uc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGluaW5lc3MgPSBqc29uLnNoaW5pbmVzcztcblx0XHRpZiAoIGpzb24uY2xlYXJjb2F0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jbGVhcmNvYXQgPSBqc29uLmNsZWFyY29hdDtcblx0XHRpZiAoIGpzb24uY2xlYXJjb2F0Um91Z2huZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgPSBqc29uLmNsZWFyY29hdFJvdWdobmVzcztcblx0XHRpZiAoIGpzb24uZGlzcGVyc2lvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGVyc2lvbiA9IGpzb24uZGlzcGVyc2lvbjtcblx0XHRpZiAoIGpzb24uaXJpZGVzY2VuY2UgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmlyaWRlc2NlbmNlID0ganNvbi5pcmlkZXNjZW5jZTtcblx0XHRpZiAoIGpzb24uaXJpZGVzY2VuY2VJT1IgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmlyaWRlc2NlbmNlSU9SID0ganNvbi5pcmlkZXNjZW5jZUlPUjtcblx0XHRpZiAoIGpzb24uaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9IGpzb24uaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZTtcblx0XHRpZiAoIGpzb24udHJhbnNtaXNzaW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50cmFuc21pc3Npb24gPSBqc29uLnRyYW5zbWlzc2lvbjtcblx0XHRpZiAoIGpzb24udGhpY2tuZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50aGlja25lc3MgPSBqc29uLnRoaWNrbmVzcztcblx0XHRpZiAoIGpzb24uYXR0ZW51YXRpb25EaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYXR0ZW51YXRpb25EaXN0YW5jZSA9IGpzb24uYXR0ZW51YXRpb25EaXN0YW5jZTtcblx0XHRpZiAoIGpzb24uYXR0ZW51YXRpb25Db2xvciAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLmF0dGVudWF0aW9uQ29sb3IgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmF0dGVudWF0aW9uQ29sb3Iuc2V0SGV4KCBqc29uLmF0dGVudWF0aW9uQ29sb3IgKTtcblx0XHRpZiAoIGpzb24uYW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW5pc290cm9weSA9IGpzb24uYW5pc290cm9weTtcblx0XHRpZiAoIGpzb24uYW5pc290cm9weVJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbmlzb3Ryb3B5Um90YXRpb24gPSBqc29uLmFuaXNvdHJvcHlSb3RhdGlvbjtcblx0XHRpZiAoIGpzb24uZm9nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mb2cgPSBqc29uLmZvZztcblx0XHRpZiAoIGpzb24uZmxhdFNoYWRpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZsYXRTaGFkaW5nID0ganNvbi5mbGF0U2hhZGluZztcblx0XHRpZiAoIGpzb24uYmxlbmRpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJsZW5kaW5nID0ganNvbi5ibGVuZGluZztcblx0XHRpZiAoIGpzb24uY29tYmluZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY29tYmluZSA9IGpzb24uY29tYmluZTtcblx0XHRpZiAoIGpzb24uc2lkZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2lkZSA9IGpzb24uc2lkZTtcblx0XHRpZiAoIGpzb24uc2hhZG93U2lkZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hhZG93U2lkZSA9IGpzb24uc2hhZG93U2lkZTtcblx0XHRpZiAoIGpzb24ub3BhY2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwub3BhY2l0eSA9IGpzb24ub3BhY2l0eTtcblx0XHRpZiAoIGpzb24udHJhbnNwYXJlbnQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnRyYW5zcGFyZW50ID0ganNvbi50cmFuc3BhcmVudDtcblx0XHRpZiAoIGpzb24uYWxwaGFUZXN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbHBoYVRlc3QgPSBqc29uLmFscGhhVGVzdDtcblx0XHRpZiAoIGpzb24uYWxwaGFIYXNoICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbHBoYUhhc2ggPSBqc29uLmFscGhhSGFzaDtcblx0XHRpZiAoIGpzb24uZGVwdGhGdW5jICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kZXB0aEZ1bmMgPSBqc29uLmRlcHRoRnVuYztcblx0XHRpZiAoIGpzb24uZGVwdGhUZXN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kZXB0aFRlc3QgPSBqc29uLmRlcHRoVGVzdDtcblx0XHRpZiAoIGpzb24uZGVwdGhXcml0ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGpzb24uZGVwdGhXcml0ZTtcblx0XHRpZiAoIGpzb24uY29sb3JXcml0ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY29sb3JXcml0ZSA9IGpzb24uY29sb3JXcml0ZTtcblx0XHRpZiAoIGpzb24uYmxlbmRTcmMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJsZW5kU3JjID0ganNvbi5ibGVuZFNyYztcblx0XHRpZiAoIGpzb24uYmxlbmREc3QgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJsZW5kRHN0ID0ganNvbi5ibGVuZERzdDtcblx0XHRpZiAoIGpzb24uYmxlbmRFcXVhdGlvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiA9IGpzb24uYmxlbmRFcXVhdGlvbjtcblx0XHRpZiAoIGpzb24uYmxlbmRTcmNBbHBoYSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYmxlbmRTcmNBbHBoYSA9IGpzb24uYmxlbmRTcmNBbHBoYTtcblx0XHRpZiAoIGpzb24uYmxlbmREc3RBbHBoYSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYmxlbmREc3RBbHBoYSA9IGpzb24uYmxlbmREc3RBbHBoYTtcblx0XHRpZiAoIGpzb24uYmxlbmRFcXVhdGlvbkFscGhhICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uQWxwaGEgPSBqc29uLmJsZW5kRXF1YXRpb25BbHBoYTtcblx0XHRpZiAoIGpzb24uYmxlbmRDb2xvciAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLmJsZW5kQ29sb3IgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJsZW5kQ29sb3Iuc2V0SGV4KCBqc29uLmJsZW5kQ29sb3IgKTtcblx0XHRpZiAoIGpzb24uYmxlbmRBbHBoYSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYmxlbmRBbHBoYSA9IGpzb24uYmxlbmRBbHBoYTtcblx0XHRpZiAoIGpzb24uc3RlbmNpbFdyaXRlTWFzayAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3RlbmNpbFdyaXRlTWFzayA9IGpzb24uc3RlbmNpbFdyaXRlTWFzaztcblx0XHRpZiAoIGpzb24uc3RlbmNpbEZ1bmMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnN0ZW5jaWxGdW5jID0ganNvbi5zdGVuY2lsRnVuYztcblx0XHRpZiAoIGpzb24uc3RlbmNpbFJlZiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3RlbmNpbFJlZiA9IGpzb24uc3RlbmNpbFJlZjtcblx0XHRpZiAoIGpzb24uc3RlbmNpbEZ1bmNNYXNrICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zdGVuY2lsRnVuY01hc2sgPSBqc29uLnN0ZW5jaWxGdW5jTWFzaztcblx0XHRpZiAoIGpzb24uc3RlbmNpbEZhaWwgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnN0ZW5jaWxGYWlsID0ganNvbi5zdGVuY2lsRmFpbDtcblx0XHRpZiAoIGpzb24uc3RlbmNpbFpGYWlsICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zdGVuY2lsWkZhaWwgPSBqc29uLnN0ZW5jaWxaRmFpbDtcblx0XHRpZiAoIGpzb24uc3RlbmNpbFpQYXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zdGVuY2lsWlBhc3MgPSBqc29uLnN0ZW5jaWxaUGFzcztcblx0XHRpZiAoIGpzb24uc3RlbmNpbFdyaXRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zdGVuY2lsV3JpdGUgPSBqc29uLnN0ZW5jaWxXcml0ZTtcblxuXHRcdGlmICgganNvbi53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZSA9IGpzb24ud2lyZWZyYW1lO1xuXHRcdGlmICgganNvbi53aXJlZnJhbWVMaW5ld2lkdGggIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IGpzb24ud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdGlmICgganNvbi53aXJlZnJhbWVMaW5lY2FwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwID0ganNvbi53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdGlmICgganNvbi53aXJlZnJhbWVMaW5lam9pbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gPSBqc29uLndpcmVmcmFtZUxpbmVqb2luO1xuXG5cdFx0aWYgKCBqc29uLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5yb3RhdGlvbiA9IGpzb24ucm90YXRpb247XG5cblx0XHRpZiAoIGpzb24ubGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saW5ld2lkdGggPSBqc29uLmxpbmV3aWR0aDtcblx0XHRpZiAoIGpzb24uZGFzaFNpemUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRhc2hTaXplID0ganNvbi5kYXNoU2l6ZTtcblx0XHRpZiAoIGpzb24uZ2FwU2l6ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZ2FwU2l6ZSA9IGpzb24uZ2FwU2l6ZTtcblx0XHRpZiAoIGpzb24uc2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNjYWxlID0ganNvbi5zY2FsZTtcblxuXHRcdGlmICgganNvbi5wb2x5Z29uT2Zmc2V0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0ID0ganNvbi5wb2x5Z29uT2Zmc2V0O1xuXHRcdGlmICgganNvbi5wb2x5Z29uT2Zmc2V0RmFjdG9yICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yID0ganNvbi5wb2x5Z29uT2Zmc2V0RmFjdG9yO1xuXHRcdGlmICgganNvbi5wb2x5Z29uT2Zmc2V0VW5pdHMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyA9IGpzb24ucG9seWdvbk9mZnNldFVuaXRzO1xuXG5cdFx0aWYgKCBqc29uLmRpdGhlcmluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGl0aGVyaW5nID0ganNvbi5kaXRoZXJpbmc7XG5cblx0XHRpZiAoIGpzb24uYWxwaGFUb0NvdmVyYWdlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbHBoYVRvQ292ZXJhZ2UgPSBqc29uLmFscGhhVG9Db3ZlcmFnZTtcblx0XHRpZiAoIGpzb24ucHJlbXVsdGlwbGllZEFscGhhICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5wcmVtdWx0aXBsaWVkQWxwaGEgPSBqc29uLnByZW11bHRpcGxpZWRBbHBoYTtcblx0XHRpZiAoIGpzb24uZm9yY2VTaW5nbGVQYXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mb3JjZVNpbmdsZVBhc3MgPSBqc29uLmZvcmNlU2luZ2xlUGFzcztcblxuXHRcdGlmICgganNvbi52aXNpYmxlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52aXNpYmxlID0ganNvbi52aXNpYmxlO1xuXG5cdFx0aWYgKCBqc29uLnRvbmVNYXBwZWQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnRvbmVNYXBwZWQgPSBqc29uLnRvbmVNYXBwZWQ7XG5cblx0XHRpZiAoIGpzb24udXNlckRhdGEgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnVzZXJEYXRhID0ganNvbi51c2VyRGF0YTtcblxuXHRcdGlmICgganNvbi52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCB0eXBlb2YganNvbi52ZXJ0ZXhDb2xvcnMgPT09ICdudW1iZXInICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsLnZlcnRleENvbG9ycyA9ICgganNvbi52ZXJ0ZXhDb2xvcnMgPiAwICkgPyB0cnVlIDogZmFsc2U7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0ganNvbi52ZXJ0ZXhDb2xvcnM7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIFNoYWRlciBNYXRlcmlhbFxuXG5cdFx0aWYgKCBqc29uLnVuaWZvcm1zICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIGNvbnN0IG5hbWUgaW4ganNvbi51bmlmb3JtcyApIHtcblxuXHRcdFx0XHRjb25zdCB1bmlmb3JtID0ganNvbi51bmlmb3Jtc1sgbmFtZSBdO1xuXG5cdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zWyBuYW1lIF0gPSB7fTtcblxuXHRcdFx0XHRzd2l0Y2ggKCB1bmlmb3JtLnR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICd0Jzpcblx0XHRcdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zWyBuYW1lIF0udmFsdWUgPSBnZXRUZXh0dXJlKCB1bmlmb3JtLnZhbHVlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2MnOlxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbIG5hbWUgXS52YWx1ZSA9IG5ldyBDb2xvcigpLnNldEhleCggdW5pZm9ybS52YWx1ZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd2Mic6XG5cdFx0XHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1sgbmFtZSBdLnZhbHVlID0gbmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkoIHVuaWZvcm0udmFsdWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndjMnOlxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbIG5hbWUgXS52YWx1ZSA9IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KCB1bmlmb3JtLnZhbHVlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3Y0Jzpcblx0XHRcdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zWyBuYW1lIF0udmFsdWUgPSBuZXcgVmVjdG9yNCgpLmZyb21BcnJheSggdW5pZm9ybS52YWx1ZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdtMyc6XG5cdFx0XHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1sgbmFtZSBdLnZhbHVlID0gbmV3IE1hdHJpeDMoKS5mcm9tQXJyYXkoIHVuaWZvcm0udmFsdWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbTQnOlxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbIG5hbWUgXS52YWx1ZSA9IG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCB1bmlmb3JtLnZhbHVlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1sgbmFtZSBdLnZhbHVlID0gdW5pZm9ybS52YWx1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICgganNvbi5kZWZpbmVzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kZWZpbmVzID0ganNvbi5kZWZpbmVzO1xuXHRcdGlmICgganNvbi52ZXJ0ZXhTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZlcnRleFNoYWRlciA9IGpzb24udmVydGV4U2hhZGVyO1xuXHRcdGlmICgganNvbi5mcmFnbWVudFNoYWRlciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgPSBqc29uLmZyYWdtZW50U2hhZGVyO1xuXHRcdGlmICgganNvbi5nbHNsVmVyc2lvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZ2xzbFZlcnNpb24gPSBqc29uLmdsc2xWZXJzaW9uO1xuXG5cdFx0aWYgKCBqc29uLmV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Zm9yICggY29uc3Qga2V5IGluIGpzb24uZXh0ZW5zaW9ucyApIHtcblxuXHRcdFx0XHRtYXRlcmlhbC5leHRlbnNpb25zWyBrZXkgXSA9IGpzb24uZXh0ZW5zaW9uc1sga2V5IF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICgganNvbi5saWdodHMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0cyA9IGpzb24ubGlnaHRzO1xuXHRcdGlmICgganNvbi5jbGlwcGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY2xpcHBpbmcgPSBqc29uLmNsaXBwaW5nO1xuXG5cdFx0Ly8gZm9yIFBvaW50c01hdGVyaWFsXG5cblx0XHRpZiAoIGpzb24uc2l6ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2l6ZSA9IGpzb24uc2l6ZTtcblx0XHRpZiAoIGpzb24uc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPSBqc29uLnNpemVBdHRlbnVhdGlvbjtcblxuXHRcdC8vIG1hcHNcblxuXHRcdGlmICgganNvbi5tYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1hcCA9IGdldFRleHR1cmUoIGpzb24ubWFwICk7XG5cdFx0aWYgKCBqc29uLm1hdGNhcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWF0Y2FwID0gZ2V0VGV4dHVyZSgganNvbi5tYXRjYXAgKTtcblxuXHRcdGlmICgganNvbi5hbHBoYU1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYWxwaGFNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmFscGhhTWFwICk7XG5cblx0XHRpZiAoIGpzb24uYnVtcE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYnVtcE1hcCA9IGdldFRleHR1cmUoIGpzb24uYnVtcE1hcCApO1xuXHRcdGlmICgganNvbi5idW1wU2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJ1bXBTY2FsZSA9IGpzb24uYnVtcFNjYWxlO1xuXG5cdFx0aWYgKCBqc29uLm5vcm1hbE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubm9ybWFsTWFwID0gZ2V0VGV4dHVyZSgganNvbi5ub3JtYWxNYXAgKTtcblx0XHRpZiAoIGpzb24ubm9ybWFsTWFwVHlwZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubm9ybWFsTWFwVHlwZSA9IGpzb24ubm9ybWFsTWFwVHlwZTtcblx0XHRpZiAoIGpzb24ubm9ybWFsU2NhbGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bGV0IG5vcm1hbFNjYWxlID0ganNvbi5ub3JtYWxTY2FsZTtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBub3JtYWxTY2FsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBCbGVuZGVyIGV4cG9ydGVyIHVzZWQgdG8gZXhwb3J0IGEgc2NhbGFyLiBTZWUgIzc0NTlcblxuXHRcdFx0XHRub3JtYWxTY2FsZSA9IFsgbm9ybWFsU2NhbGUsIG5vcm1hbFNjYWxlIF07XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWwubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigpLmZyb21BcnJheSggbm9ybWFsU2NhbGUgKTtcblxuXHRcdH1cblxuXHRcdGlmICgganNvbi5kaXNwbGFjZW1lbnRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCA9IGdldFRleHR1cmUoIGpzb24uZGlzcGxhY2VtZW50TWFwICk7XG5cdFx0aWYgKCBqc29uLmRpc3BsYWNlbWVudFNjYWxlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZSA9IGpzb24uZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0aWYgKCBqc29uLmRpc3BsYWNlbWVudEJpYXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXMgPSBqc29uLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHRpZiAoIGpzb24ucm91Z2huZXNzTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgPSBnZXRUZXh0dXJlKCBqc29uLnJvdWdobmVzc01hcCApO1xuXHRcdGlmICgganNvbi5tZXRhbG5lc3NNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1ldGFsbmVzc01hcCA9IGdldFRleHR1cmUoIGpzb24ubWV0YWxuZXNzTWFwICk7XG5cblx0XHRpZiAoIGpzb24uZW1pc3NpdmVNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlTWFwID0gZ2V0VGV4dHVyZSgganNvbi5lbWlzc2l2ZU1hcCApO1xuXHRcdGlmICgganNvbi5lbWlzc2l2ZUludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmVJbnRlbnNpdHkgPSBqc29uLmVtaXNzaXZlSW50ZW5zaXR5O1xuXG5cdFx0aWYgKCBqc29uLnNwZWN1bGFyTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhck1hcCA9IGdldFRleHR1cmUoIGpzb24uc3BlY3VsYXJNYXAgKTtcblx0XHRpZiAoIGpzb24uc3BlY3VsYXJJbnRlbnNpdHlNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5TWFwID0gZ2V0VGV4dHVyZSgganNvbi5zcGVjdWxhckludGVuc2l0eU1hcCApO1xuXHRcdGlmICgganNvbi5zcGVjdWxhckNvbG9yTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwID0gZ2V0VGV4dHVyZSgganNvbi5zcGVjdWxhckNvbG9yTWFwICk7XG5cblx0XHRpZiAoIGpzb24uZW52TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbnZNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmVudk1hcCApO1xuXHRcdGlmICgganNvbi5lbnZNYXBSb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW52TWFwUm90YXRpb24uZnJvbUFycmF5KCBqc29uLmVudk1hcFJvdGF0aW9uICk7XG5cdFx0aWYgKCBqc29uLmVudk1hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW52TWFwSW50ZW5zaXR5ID0ganNvbi5lbnZNYXBJbnRlbnNpdHk7XG5cblx0XHRpZiAoIGpzb24ucmVmbGVjdGl2aXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5yZWZsZWN0aXZpdHkgPSBqc29uLnJlZmxlY3Rpdml0eTtcblx0XHRpZiAoIGpzb24ucmVmcmFjdGlvblJhdGlvICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW8gPSBqc29uLnJlZnJhY3Rpb25SYXRpbztcblxuXHRcdGlmICgganNvbi5saWdodE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubGlnaHRNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmxpZ2h0TWFwICk7XG5cdFx0aWYgKCBqc29uLmxpZ2h0TWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eSA9IGpzb24ubGlnaHRNYXBJbnRlbnNpdHk7XG5cblx0XHRpZiAoIGpzb24uYW9NYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFvTWFwID0gZ2V0VGV4dHVyZSgganNvbi5hb01hcCApO1xuXHRcdGlmICgganNvbi5hb01hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHkgPSBqc29uLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0aWYgKCBqc29uLmdyYWRpZW50TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ncmFkaWVudE1hcCA9IGdldFRleHR1cmUoIGpzb24uZ3JhZGllbnRNYXAgKTtcblxuXHRcdGlmICgganNvbi5jbGVhcmNvYXRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNsZWFyY29hdE1hcCA9IGdldFRleHR1cmUoIGpzb24uY2xlYXJjb2F0TWFwICk7XG5cdFx0aWYgKCBqc29uLmNsZWFyY29hdFJvdWdobmVzc01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzTWFwID0gZ2V0VGV4dHVyZSgganNvbi5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgKTtcblx0XHRpZiAoIGpzb24uY2xlYXJjb2F0Tm9ybWFsTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmNsZWFyY29hdE5vcm1hbE1hcCApO1xuXHRcdGlmICgganNvbi5jbGVhcmNvYXROb3JtYWxTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigpLmZyb21BcnJheSgganNvbi5jbGVhcmNvYXROb3JtYWxTY2FsZSApO1xuXG5cdFx0aWYgKCBqc29uLmlyaWRlc2NlbmNlTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5pcmlkZXNjZW5jZU1hcCA9IGdldFRleHR1cmUoIGpzb24uaXJpZGVzY2VuY2VNYXAgKTtcblx0XHRpZiAoIGpzb24uaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwID0gZ2V0VGV4dHVyZSgganNvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCApO1xuXG5cdFx0aWYgKCBqc29uLnRyYW5zbWlzc2lvbk1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudHJhbnNtaXNzaW9uTWFwID0gZ2V0VGV4dHVyZSgganNvbi50cmFuc21pc3Npb25NYXAgKTtcblx0XHRpZiAoIGpzb24udGhpY2tuZXNzTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50aGlja25lc3NNYXAgPSBnZXRUZXh0dXJlKCBqc29uLnRoaWNrbmVzc01hcCApO1xuXG5cdFx0aWYgKCBqc29uLmFuaXNvdHJvcHlNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFuaXNvdHJvcHlNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmFuaXNvdHJvcHlNYXAgKTtcblxuXHRcdGlmICgganNvbi5zaGVlbkNvbG9yTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGVlbkNvbG9yTWFwID0gZ2V0VGV4dHVyZSgganNvbi5zaGVlbkNvbG9yTWFwICk7XG5cdFx0aWYgKCBqc29uLnNoZWVuUm91Z2huZXNzTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGVlblJvdWdobmVzc01hcCA9IGdldFRleHR1cmUoIGpzb24uc2hlZW5Sb3VnaG5lc3NNYXAgKTtcblxuXHRcdHJldHVybiBtYXRlcmlhbDtcblxuXHR9XG5cblx0c2V0VGV4dHVyZXMoIHZhbHVlICkge1xuXG5cdFx0dGhpcy50ZXh0dXJlcyA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjcmVhdGVNYXRlcmlhbEZyb21UeXBlKCB0eXBlICkge1xuXG5cdFx0cmV0dXJuIE1hdGVyaWFsTG9hZGVyLmNyZWF0ZU1hdGVyaWFsRnJvbVR5cGUoIHR5cGUgKTtcblxuXHR9XG5cblx0c3RhdGljIGNyZWF0ZU1hdGVyaWFsRnJvbVR5cGUoIHR5cGUgKSB7XG5cblx0XHRjb25zdCBtYXRlcmlhbExpYiA9IHtcblx0XHRcdFNoYWRvd01hdGVyaWFsLFxuXHRcdFx0U3ByaXRlTWF0ZXJpYWwsXG5cdFx0XHRSYXdTaGFkZXJNYXRlcmlhbCxcblx0XHRcdFNoYWRlck1hdGVyaWFsLFxuXHRcdFx0UG9pbnRzTWF0ZXJpYWwsXG5cdFx0XHRNZXNoUGh5c2ljYWxNYXRlcmlhbCxcblx0XHRcdE1lc2hTdGFuZGFyZE1hdGVyaWFsLFxuXHRcdFx0TWVzaFBob25nTWF0ZXJpYWwsXG5cdFx0XHRNZXNoVG9vbk1hdGVyaWFsLFxuXHRcdFx0TWVzaE5vcm1hbE1hdGVyaWFsLFxuXHRcdFx0TWVzaExhbWJlcnRNYXRlcmlhbCxcblx0XHRcdE1lc2hEZXB0aE1hdGVyaWFsLFxuXHRcdFx0TWVzaERpc3RhbmNlTWF0ZXJpYWwsXG5cdFx0XHRNZXNoQmFzaWNNYXRlcmlhbCxcblx0XHRcdE1lc2hNYXRjYXBNYXRlcmlhbCxcblx0XHRcdExpbmVEYXNoZWRNYXRlcmlhbCxcblx0XHRcdExpbmVCYXNpY01hdGVyaWFsLFxuXHRcdFx0TWF0ZXJpYWxcblx0XHR9O1xuXG5cdFx0cmV0dXJuIG5ldyBtYXRlcmlhbExpYlsgdHlwZSBdKCk7XG5cblx0fVxuXG59XG5cbmNsYXNzIExvYWRlclV0aWxzIHtcblxuXHRzdGF0aWMgZGVjb2RlVGV4dCggYXJyYXkgKSB7IC8vIEBkZXByZWNhdGVkLCByMTY1XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Mb2FkZXJVdGlsczogZGVjb2RlVGV4dCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgd2l0aCByMTY1IGFuZCB3aWxsIGJlIHJlbW92ZWQgd2l0aCByMTc1LiBVc2UgVGV4dERlY29kZXIgaW5zdGVhZC4nICk7XG5cblx0XHRpZiAoIHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoIGFycmF5ICk7XG5cblx0XHR9XG5cblx0XHQvLyBBdm9pZCB0aGUgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheSkgc2hvcnRjdXQsIHdoaWNoXG5cdFx0Ly8gdGhyb3dzIGEgXCJtYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiIGVycm9yIGZvciBsYXJnZSBhcnJheXMuXG5cblx0XHRsZXQgcyA9ICcnO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHQvLyBJbXBsaWNpdGx5IGFzc3VtZXMgbGl0dGxlLWVuZGlhbi5cblx0XHRcdHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSggYXJyYXlbIGkgXSApO1xuXG5cdFx0fVxuXG5cdFx0dHJ5IHtcblxuXHRcdFx0Ly8gbWVyZ2VzIG11bHRpLWJ5dGUgdXRmLTggY2hhcmFjdGVycy5cblxuXHRcdFx0cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCggZXNjYXBlKCBzICkgKTtcblxuXHRcdH0gY2F0Y2ggKCBlICkgeyAvLyBzZWUgIzE2MzU4XG5cblx0XHRcdHJldHVybiBzO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzdGF0aWMgZXh0cmFjdFVybEJhc2UoIHVybCApIHtcblxuXHRcdGNvbnN0IGluZGV4ID0gdXJsLmxhc3RJbmRleE9mKCAnLycgKTtcblxuXHRcdGlmICggaW5kZXggPT09IC0gMSApIHJldHVybiAnLi8nO1xuXG5cdFx0cmV0dXJuIHVybC5zbGljZSggMCwgaW5kZXggKyAxICk7XG5cblx0fVxuXG5cdHN0YXRpYyByZXNvbHZlVVJMKCB1cmwsIHBhdGggKSB7XG5cblx0XHQvLyBJbnZhbGlkIFVSTFxuXHRcdGlmICggdHlwZW9mIHVybCAhPT0gJ3N0cmluZycgfHwgdXJsID09PSAnJyApIHJldHVybiAnJztcblxuXHRcdC8vIEhvc3QgUmVsYXRpdmUgVVJMXG5cdFx0aWYgKCAvXmh0dHBzPzpcXC9cXC8vaS50ZXN0KCBwYXRoICkgJiYgL15cXC8vLnRlc3QoIHVybCApICkge1xuXG5cdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKCAvKF5odHRwcz86XFwvXFwvW15cXC9dKykuKi9pLCAnJDEnICk7XG5cblx0XHR9XG5cblx0XHQvLyBBYnNvbHV0ZSBVUkwgaHR0cDovLyxodHRwczovLywvL1xuXHRcdGlmICggL14oaHR0cHM/Oik/XFwvXFwvL2kudGVzdCggdXJsICkgKSByZXR1cm4gdXJsO1xuXG5cdFx0Ly8gRGF0YSBVUklcblx0XHRpZiAoIC9eZGF0YTouKiwuKiQvaS50ZXN0KCB1cmwgKSApIHJldHVybiB1cmw7XG5cblx0XHQvLyBCbG9iIFVSTFxuXHRcdGlmICggL15ibG9iOi4qJC9pLnRlc3QoIHVybCApICkgcmV0dXJuIHVybDtcblxuXHRcdC8vIFJlbGF0aXZlIFVSTFxuXHRcdHJldHVybiBwYXRoICsgdXJsO1xuXG5cdH1cblxufVxuXG5jbGFzcyBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5Jztcblx0XHR0aGlzLmluc3RhbmNlQ291bnQgPSBJbmZpbml0eTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmluc3RhbmNlQ291bnQgPSBzb3VyY2UuaW5zdGFuY2VDb3VudDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLmluc3RhbmNlQ291bnQgPSB0aGlzLmluc3RhbmNlQ291bnQ7XG5cblx0XHRkYXRhLmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59XG5cbmNsYXNzIEJ1ZmZlckdlb21ldHJ5TG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggc2NvcGUucGF0aCApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCBzY29wZS5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggc2NvcGUud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9XG5cblx0cGFyc2UoIGpzb24gKSB7XG5cblx0XHRjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlck1hcCA9IHt9O1xuXHRcdGNvbnN0IGFycmF5QnVmZmVyTWFwID0ge307XG5cblx0XHRmdW5jdGlvbiBnZXRJbnRlcmxlYXZlZEJ1ZmZlcigganNvbiwgdXVpZCApIHtcblxuXHRcdFx0aWYgKCBpbnRlcmxlYXZlZEJ1ZmZlck1hcFsgdXVpZCBdICE9PSB1bmRlZmluZWQgKSByZXR1cm4gaW50ZXJsZWF2ZWRCdWZmZXJNYXBbIHV1aWQgXTtcblxuXHRcdFx0Y29uc3QgaW50ZXJsZWF2ZWRCdWZmZXJzID0ganNvbi5pbnRlcmxlYXZlZEJ1ZmZlcnM7XG5cdFx0XHRjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlciA9IGludGVybGVhdmVkQnVmZmVyc1sgdXVpZCBdO1xuXG5cdFx0XHRjb25zdCBidWZmZXIgPSBnZXRBcnJheUJ1ZmZlcigganNvbiwgaW50ZXJsZWF2ZWRCdWZmZXIuYnVmZmVyICk7XG5cblx0XHRcdGNvbnN0IGFycmF5ID0gZ2V0VHlwZWRBcnJheSggaW50ZXJsZWF2ZWRCdWZmZXIudHlwZSwgYnVmZmVyICk7XG5cdFx0XHRjb25zdCBpYiA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlciggYXJyYXksIGludGVybGVhdmVkQnVmZmVyLnN0cmlkZSApO1xuXHRcdFx0aWIudXVpZCA9IGludGVybGVhdmVkQnVmZmVyLnV1aWQ7XG5cblx0XHRcdGludGVybGVhdmVkQnVmZmVyTWFwWyB1dWlkIF0gPSBpYjtcblxuXHRcdFx0cmV0dXJuIGliO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXIoIGpzb24sIHV1aWQgKSB7XG5cblx0XHRcdGlmICggYXJyYXlCdWZmZXJNYXBbIHV1aWQgXSAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIGFycmF5QnVmZmVyTWFwWyB1dWlkIF07XG5cblx0XHRcdGNvbnN0IGFycmF5QnVmZmVycyA9IGpzb24uYXJyYXlCdWZmZXJzO1xuXHRcdFx0Y29uc3QgYXJyYXlCdWZmZXIgPSBhcnJheUJ1ZmZlcnNbIHV1aWQgXTtcblxuXHRcdFx0Y29uc3QgYWIgPSBuZXcgVWludDMyQXJyYXkoIGFycmF5QnVmZmVyICkuYnVmZmVyO1xuXG5cdFx0XHRhcnJheUJ1ZmZlck1hcFsgdXVpZCBdID0gYWI7XG5cblx0XHRcdHJldHVybiBhYjtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0ganNvbi5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID8gbmV3IEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5KCkgOiBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdGNvbnN0IGluZGV4ID0ganNvbi5kYXRhLmluZGV4O1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCB0eXBlZEFycmF5ID0gZ2V0VHlwZWRBcnJheSggaW5kZXgudHlwZSwgaW5kZXguYXJyYXkgKTtcblx0XHRcdGdlb21ldHJ5LnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCB0eXBlZEFycmF5LCAxICkgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBqc29uLmRhdGEuYXR0cmlidXRlcztcblxuXHRcdGZvciAoIGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcblx0XHRcdGxldCBidWZmZXJBdHRyaWJ1dGU7XG5cblx0XHRcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW50ZXJsZWF2ZWRCdWZmZXIgPSBnZXRJbnRlcmxlYXZlZEJ1ZmZlcigganNvbi5kYXRhLCBhdHRyaWJ1dGUuZGF0YSApO1xuXHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoIGludGVybGVhdmVkQnVmZmVyLCBhdHRyaWJ1dGUuaXRlbVNpemUsIGF0dHJpYnV0ZS5vZmZzZXQsIGF0dHJpYnV0ZS5ub3JtYWxpemVkICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgdHlwZWRBcnJheSA9IGdldFR5cGVkQXJyYXkoIGF0dHJpYnV0ZS50eXBlLCBhdHRyaWJ1dGUuYXJyYXkgKTtcblx0XHRcdFx0Y29uc3QgYnVmZmVyQXR0cmlidXRlQ29uc3RyID0gYXR0cmlidXRlLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID8gSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIDogQnVmZmVyQXR0cmlidXRlO1xuXHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgYnVmZmVyQXR0cmlidXRlQ29uc3RyKCB0eXBlZEFycmF5LCBhdHRyaWJ1dGUuaXRlbVNpemUsIGF0dHJpYnV0ZS5ub3JtYWxpemVkICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUubmFtZSAhPT0gdW5kZWZpbmVkICkgYnVmZmVyQXR0cmlidXRlLm5hbWUgPSBhdHRyaWJ1dGUubmFtZTtcblx0XHRcdGlmICggYXR0cmlidXRlLnVzYWdlICE9PSB1bmRlZmluZWQgKSBidWZmZXJBdHRyaWJ1dGUuc2V0VXNhZ2UoIGF0dHJpYnV0ZS51c2FnZSApO1xuXG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoIGtleSwgYnVmZmVyQXR0cmlidXRlICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSBqc29uLmRhdGEubW9ycGhBdHRyaWJ1dGVzO1xuXG5cdFx0aWYgKCBtb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlQXJyYXkgPSBtb3JwaEF0dHJpYnV0ZXNbIGtleSBdO1xuXG5cdFx0XHRcdGNvbnN0IGFycmF5ID0gW107XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGF0dHJpYnV0ZUFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlQXJyYXlbIGkgXTtcblx0XHRcdFx0XHRsZXQgYnVmZmVyQXR0cmlidXRlO1xuXG5cdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgaW50ZXJsZWF2ZWRCdWZmZXIgPSBnZXRJbnRlcmxlYXZlZEJ1ZmZlcigganNvbi5kYXRhLCBhdHRyaWJ1dGUuZGF0YSApO1xuXHRcdFx0XHRcdFx0YnVmZmVyQXR0cmlidXRlID0gbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKCBpbnRlcmxlYXZlZEJ1ZmZlciwgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGUub2Zmc2V0LCBhdHRyaWJ1dGUubm9ybWFsaXplZCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgdHlwZWRBcnJheSA9IGdldFR5cGVkQXJyYXkoIGF0dHJpYnV0ZS50eXBlLCBhdHRyaWJ1dGUuYXJyYXkgKTtcblx0XHRcdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHR5cGVkQXJyYXksIGF0dHJpYnV0ZS5pdGVtU2l6ZSwgYXR0cmlidXRlLm5vcm1hbGl6ZWQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggYXR0cmlidXRlLm5hbWUgIT09IHVuZGVmaW5lZCApIGJ1ZmZlckF0dHJpYnV0ZS5uYW1lID0gYXR0cmlidXRlLm5hbWU7XG5cdFx0XHRcdFx0YXJyYXkucHVzaCggYnVmZmVyQXR0cmlidXRlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1sga2V5IF0gPSBhcnJheTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBqc29uLmRhdGEubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG5cblx0XHRpZiAoIG1vcnBoVGFyZ2V0c1JlbGF0aXZlICkge1xuXG5cdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRjb25zdCBncm91cHMgPSBqc29uLmRhdGEuZ3JvdXBzIHx8IGpzb24uZGF0YS5kcmF3Y2FsbHMgfHwganNvbi5kYXRhLm9mZnNldHM7XG5cblx0XHRpZiAoIGdyb3VwcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBncm91cHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cblx0XHRcdFx0Z2VvbWV0cnkuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zdCBib3VuZGluZ1NwaGVyZSA9IGpzb24uZGF0YS5ib3VuZGluZ1NwaGVyZTtcblxuXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgY2VudGVyID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0aWYgKCBib3VuZGluZ1NwaGVyZS5jZW50ZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjZW50ZXIuZnJvbUFycmF5KCBib3VuZGluZ1NwaGVyZS5jZW50ZXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoIGNlbnRlciwgYm91bmRpbmdTcGhlcmUucmFkaXVzICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGpzb24ubmFtZSApIGdlb21ldHJ5Lm5hbWUgPSBqc29uLm5hbWU7XG5cdFx0aWYgKCBqc29uLnVzZXJEYXRhICkgZ2VvbWV0cnkudXNlckRhdGEgPSBqc29uLnVzZXJEYXRhO1xuXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdH1cblxufVxuXG5jbGFzcyBPYmplY3RMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xuXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcblxuXHR9XG5cblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBwYXRoID0gKCB0aGlzLnBhdGggPT09ICcnICkgPyBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSggdXJsICkgOiB0aGlzLnBhdGg7XG5cdFx0dGhpcy5yZXNvdXJjZVBhdGggPSB0aGlzLnJlc291cmNlUGF0aCB8fCBwYXRoO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdGxldCBqc29uID0gbnVsbDtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRqc29uID0gSlNPTi5wYXJzZSggdGV4dCApO1xuXG5cdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICE9PSB1bmRlZmluZWQgKSBvbkVycm9yKCBlcnJvciApO1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRTpPYmplY3RMb2FkZXI6IENhblxcJ3QgcGFyc2UgJyArIHVybCArICcuJywgZXJyb3IubWVzc2FnZSApO1xuXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtZXRhZGF0YSA9IGpzb24ubWV0YWRhdGE7XG5cblx0XHRcdGlmICggbWV0YWRhdGEgPT09IHVuZGVmaW5lZCB8fCBtZXRhZGF0YS50eXBlID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZS50b0xvd2VyQ2FzZSgpID09PSAnZ2VvbWV0cnknICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciAhPT0gdW5kZWZpbmVkICkgb25FcnJvciggbmV3IEVycm9yKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBDYW5cXCd0IGxvYWQgJyArIHVybCApICk7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk9iamVjdExvYWRlcjogQ2FuXFwndCBsb2FkICcgKyB1cmwgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNjb3BlLnBhcnNlKCBqc29uLCBvbkxvYWQgKTtcblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9XG5cblx0YXN5bmMgbG9hZEFzeW5jKCB1cmwsIG9uUHJvZ3Jlc3MgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBwYXRoID0gKCB0aGlzLnBhdGggPT09ICcnICkgPyBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSggdXJsICkgOiB0aGlzLnBhdGg7XG5cdFx0dGhpcy5yZXNvdXJjZVBhdGggPSB0aGlzLnJlc291cmNlUGF0aCB8fCBwYXRoO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcblxuXHRcdGNvbnN0IHRleHQgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKCB1cmwsIG9uUHJvZ3Jlc3MgKTtcblxuXHRcdGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0ICk7XG5cblx0XHRjb25zdCBtZXRhZGF0YSA9IGpzb24ubWV0YWRhdGE7XG5cblx0XHRpZiAoIG1ldGFkYXRhID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZSA9PT0gdW5kZWZpbmVkIHx8IG1ldGFkYXRhLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2dlb21ldHJ5JyApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBDYW5cXCd0IGxvYWQgJyArIHVybCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGF3YWl0IHNjb3BlLnBhcnNlQXN5bmMoIGpzb24gKTtcblxuXHR9XG5cblx0cGFyc2UoIGpzb24sIG9uTG9hZCApIHtcblxuXHRcdGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLnBhcnNlQW5pbWF0aW9ucygganNvbi5hbmltYXRpb25zICk7XG5cdFx0Y29uc3Qgc2hhcGVzID0gdGhpcy5wYXJzZVNoYXBlcygganNvbi5zaGFwZXMgKTtcblx0XHRjb25zdCBnZW9tZXRyaWVzID0gdGhpcy5wYXJzZUdlb21ldHJpZXMoIGpzb24uZ2VvbWV0cmllcywgc2hhcGVzICk7XG5cblx0XHRjb25zdCBpbWFnZXMgPSB0aGlzLnBhcnNlSW1hZ2VzKCBqc29uLmltYWdlcywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcblxuXHRcdH0gKTtcblxuXHRcdGNvbnN0IHRleHR1cmVzID0gdGhpcy5wYXJzZVRleHR1cmVzKCBqc29uLnRleHR1cmVzLCBpbWFnZXMgKTtcblx0XHRjb25zdCBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZXMgKTtcblxuXHRcdGNvbnN0IG9iamVjdCA9IHRoaXMucGFyc2VPYmplY3QoIGpzb24ub2JqZWN0LCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMsIHRleHR1cmVzLCBhbmltYXRpb25zICk7XG5cdFx0Y29uc3Qgc2tlbGV0b25zID0gdGhpcy5wYXJzZVNrZWxldG9ucygganNvbi5za2VsZXRvbnMsIG9iamVjdCApO1xuXG5cdFx0dGhpcy5iaW5kU2tlbGV0b25zKCBvYmplY3QsIHNrZWxldG9ucyApO1xuXHRcdHRoaXMuYmluZExpZ2h0VGFyZ2V0cyggb2JqZWN0ICk7XG5cblx0XHQvL1xuXG5cdFx0aWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bGV0IGhhc0ltYWdlcyA9IGZhbHNlO1xuXG5cdFx0XHRmb3IgKCBjb25zdCB1dWlkIGluIGltYWdlcyApIHtcblxuXHRcdFx0XHRpZiAoIGltYWdlc1sgdXVpZCBdLmRhdGEgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ICkge1xuXG5cdFx0XHRcdFx0aGFzSW1hZ2VzID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNJbWFnZXMgPT09IGZhbHNlICkgb25Mb2FkKCBvYmplY3QgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBvYmplY3Q7XG5cblx0fVxuXG5cdGFzeW5jIHBhcnNlQXN5bmMoIGpzb24gKSB7XG5cblx0XHRjb25zdCBhbmltYXRpb25zID0gdGhpcy5wYXJzZUFuaW1hdGlvbnMoIGpzb24uYW5pbWF0aW9ucyApO1xuXHRcdGNvbnN0IHNoYXBlcyA9IHRoaXMucGFyc2VTaGFwZXMoIGpzb24uc2hhcGVzICk7XG5cdFx0Y29uc3QgZ2VvbWV0cmllcyA9IHRoaXMucGFyc2VHZW9tZXRyaWVzKCBqc29uLmdlb21ldHJpZXMsIHNoYXBlcyApO1xuXG5cdFx0Y29uc3QgaW1hZ2VzID0gYXdhaXQgdGhpcy5wYXJzZUltYWdlc0FzeW5jKCBqc29uLmltYWdlcyApO1xuXG5cdFx0Y29uc3QgdGV4dHVyZXMgPSB0aGlzLnBhcnNlVGV4dHVyZXMoIGpzb24udGV4dHVyZXMsIGltYWdlcyApO1xuXHRcdGNvbnN0IG1hdGVyaWFscyA9IHRoaXMucGFyc2VNYXRlcmlhbHMoIGpzb24ubWF0ZXJpYWxzLCB0ZXh0dXJlcyApO1xuXG5cdFx0Y29uc3Qgb2JqZWN0ID0gdGhpcy5wYXJzZU9iamVjdCgganNvbi5vYmplY3QsIGdlb21ldHJpZXMsIG1hdGVyaWFscywgdGV4dHVyZXMsIGFuaW1hdGlvbnMgKTtcblx0XHRjb25zdCBza2VsZXRvbnMgPSB0aGlzLnBhcnNlU2tlbGV0b25zKCBqc29uLnNrZWxldG9ucywgb2JqZWN0ICk7XG5cblx0XHR0aGlzLmJpbmRTa2VsZXRvbnMoIG9iamVjdCwgc2tlbGV0b25zICk7XG5cdFx0dGhpcy5iaW5kTGlnaHRUYXJnZXRzKCBvYmplY3QgKTtcblxuXHRcdHJldHVybiBvYmplY3Q7XG5cblx0fVxuXG5cdHBhcnNlU2hhcGVzKCBqc29uICkge1xuXG5cdFx0Y29uc3Qgc2hhcGVzID0ge307XG5cblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNoYXBlID0gbmV3IFNoYXBlKCkuZnJvbUpTT04oIGpzb25bIGkgXSApO1xuXG5cdFx0XHRcdHNoYXBlc1sgc2hhcGUudXVpZCBdID0gc2hhcGU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBzaGFwZXM7XG5cblx0fVxuXG5cdHBhcnNlU2tlbGV0b25zKCBqc29uLCBvYmplY3QgKSB7XG5cblx0XHRjb25zdCBza2VsZXRvbnMgPSB7fTtcblx0XHRjb25zdCBib25lcyA9IHt9O1xuXG5cdFx0Ly8gZ2VuZXJhdGUgYm9uZSBsb29rdXAgdGFibGVcblxuXHRcdG9iamVjdC50cmF2ZXJzZSggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0aWYgKCBjaGlsZC5pc0JvbmUgKSBib25lc1sgY2hpbGQudXVpZCBdID0gY2hpbGQ7XG5cblx0XHR9ICk7XG5cblx0XHQvLyBjcmVhdGUgc2tlbGV0b25zXG5cblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNrZWxldG9uID0gbmV3IFNrZWxldG9uKCkuZnJvbUpTT04oIGpzb25bIGkgXSwgYm9uZXMgKTtcblxuXHRcdFx0XHRza2VsZXRvbnNbIHNrZWxldG9uLnV1aWQgXSA9IHNrZWxldG9uO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gc2tlbGV0b25zO1xuXG5cdH1cblxuXHRwYXJzZUdlb21ldHJpZXMoIGpzb24sIHNoYXBlcyApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJpZXMgPSB7fTtcblxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBidWZmZXJHZW9tZXRyeUxvYWRlciA9IG5ldyBCdWZmZXJHZW9tZXRyeUxvYWRlcigpO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0bGV0IGdlb21ldHJ5O1xuXHRcdFx0XHRjb25zdCBkYXRhID0ganNvblsgaSBdO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGRhdGEudHlwZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ0J1ZmZlckdlb21ldHJ5Jzpcblx0XHRcdFx0XHRjYXNlICdJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gYnVmZmVyR2VvbWV0cnlMb2FkZXIucGFyc2UoIGRhdGEgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0aWYgKCBkYXRhLnR5cGUgaW4gR2VvbWV0cmllcyApIHtcblxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdLmZyb21KU09OKCBkYXRhLCBzaGFwZXMgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oIGBUSFJFRS5PYmplY3RMb2FkZXI6IFVuc3VwcG9ydGVkIGdlb21ldHJ5IHR5cGUgXCIkeyBkYXRhLnR5cGUgfVwiYCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5LnV1aWQgPSBkYXRhLnV1aWQ7XG5cblx0XHRcdFx0aWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIGdlb21ldHJ5Lm5hbWUgPSBkYXRhLm5hbWU7XG5cdFx0XHRcdGlmICggZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkICkgZ2VvbWV0cnkudXNlckRhdGEgPSBkYXRhLnVzZXJEYXRhO1xuXG5cdFx0XHRcdGdlb21ldHJpZXNbIGRhdGEudXVpZCBdID0gZ2VvbWV0cnk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBnZW9tZXRyaWVzO1xuXG5cdH1cblxuXHRwYXJzZU1hdGVyaWFscygganNvbiwgdGV4dHVyZXMgKSB7XG5cblx0XHRjb25zdCBjYWNoZSA9IHt9OyAvLyBNdWx0aU1hdGVyaWFsXG5cdFx0Y29uc3QgbWF0ZXJpYWxzID0ge307XG5cblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgbG9hZGVyID0gbmV3IE1hdGVyaWFsTG9hZGVyKCk7XG5cdFx0XHRsb2FkZXIuc2V0VGV4dHVyZXMoIHRleHR1cmVzICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBkYXRhID0ganNvblsgaSBdO1xuXG5cdFx0XHRcdGlmICggY2FjaGVbIGRhdGEudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjYWNoZVsgZGF0YS51dWlkIF0gPSBsb2FkZXIucGFyc2UoIGRhdGEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWF0ZXJpYWxzWyBkYXRhLnV1aWQgXSA9IGNhY2hlWyBkYXRhLnV1aWQgXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGVyaWFscztcblxuXHR9XG5cblx0cGFyc2VBbmltYXRpb25zKCBqc29uICkge1xuXG5cdFx0Y29uc3QgYW5pbWF0aW9ucyA9IHt9O1xuXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGRhdGEgPSBqc29uWyBpIF07XG5cblx0XHRcdFx0Y29uc3QgY2xpcCA9IEFuaW1hdGlvbkNsaXAucGFyc2UoIGRhdGEgKTtcblxuXHRcdFx0XHRhbmltYXRpb25zWyBjbGlwLnV1aWQgXSA9IGNsaXA7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBhbmltYXRpb25zO1xuXG5cdH1cblxuXHRwYXJzZUltYWdlcygganNvbiwgb25Mb2FkICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdGNvbnN0IGltYWdlcyA9IHt9O1xuXG5cdFx0bGV0IGxvYWRlcjtcblxuXHRcdGZ1bmN0aW9uIGxvYWRJbWFnZSggdXJsICkge1xuXG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cblx0XHRcdHJldHVybiBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0fSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZXNlcmlhbGl6ZUltYWdlKCBpbWFnZSApIHtcblxuXHRcdFx0aWYgKCB0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnICkge1xuXG5cdFx0XHRcdGNvbnN0IHVybCA9IGltYWdlO1xuXG5cdFx0XHRcdGNvbnN0IHBhdGggPSAvXihcXC9cXC8pfChbYS16XSs6KFxcL1xcLyk/KS9pLnRlc3QoIHVybCApID8gdXJsIDogc2NvcGUucmVzb3VyY2VQYXRoICsgdXJsO1xuXG5cdFx0XHRcdHJldHVybiBsb2FkSW1hZ2UoIHBhdGggKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIGltYWdlLmRhdGEgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZGF0YTogZ2V0VHlwZWRBcnJheSggaW1hZ2UudHlwZSwgaW1hZ2UuZGF0YSApLFxuXHRcdFx0XHRcdFx0d2lkdGg6IGltYWdlLndpZHRoLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBpbWFnZS5oZWlnaHRcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICYmIGpzb24ubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0Y29uc3QgbWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlciggb25Mb2FkICk7XG5cblx0XHRcdGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlciggbWFuYWdlciApO1xuXHRcdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBqc29uLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGltYWdlID0ganNvblsgaSBdO1xuXHRcdFx0XHRjb25zdCB1cmwgPSBpbWFnZS51cmw7XG5cblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB1cmwgKSApIHtcblxuXHRcdFx0XHRcdC8vIGxvYWQgYXJyYXkgb2YgaW1hZ2VzIGUuZyBDdWJlVGV4dHVyZVxuXG5cdFx0XHRcdFx0Y29uc3QgaW1hZ2VBcnJheSA9IFtdO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IHVybC5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgY3VycmVudFVybCA9IHVybFsgaiBdO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBkZXNlcmlhbGl6ZWRJbWFnZSA9IGRlc2VyaWFsaXplSW1hZ2UoIGN1cnJlbnRVcmwgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBkZXNlcmlhbGl6ZWRJbWFnZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGRlc2VyaWFsaXplZEltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGltYWdlQXJyYXkucHVzaCggZGVzZXJpYWxpemVkSW1hZ2UgKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlOiBoYW5kbGUgYXJyYXkgb2YgZGF0YSB0ZXh0dXJlcyBmb3IgY3ViZSB0ZXh0dXJlc1xuXG5cdFx0XHRcdFx0XHRcdFx0aW1hZ2VBcnJheS5wdXNoKCBuZXcgRGF0YVRleHR1cmUoIGRlc2VyaWFsaXplZEltYWdlLmRhdGEsIGRlc2VyaWFsaXplZEltYWdlLndpZHRoLCBkZXNlcmlhbGl6ZWRJbWFnZS5oZWlnaHQgKSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aW1hZ2VzWyBpbWFnZS51dWlkIF0gPSBuZXcgU291cmNlKCBpbWFnZUFycmF5ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGxvYWQgc2luZ2xlIGltYWdlXG5cblx0XHRcdFx0XHRjb25zdCBkZXNlcmlhbGl6ZWRJbWFnZSA9IGRlc2VyaWFsaXplSW1hZ2UoIGltYWdlLnVybCApO1xuXHRcdFx0XHRcdGltYWdlc1sgaW1hZ2UudXVpZCBdID0gbmV3IFNvdXJjZSggZGVzZXJpYWxpemVkSW1hZ2UgKTtcblxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGltYWdlcztcblxuXHR9XG5cblx0YXN5bmMgcGFyc2VJbWFnZXNBc3luYygganNvbiApIHtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRjb25zdCBpbWFnZXMgPSB7fTtcblxuXHRcdGxldCBsb2FkZXI7XG5cblx0XHRhc3luYyBmdW5jdGlvbiBkZXNlcmlhbGl6ZUltYWdlKCBpbWFnZSApIHtcblxuXHRcdFx0aWYgKCB0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnICkge1xuXG5cdFx0XHRcdGNvbnN0IHVybCA9IGltYWdlO1xuXG5cdFx0XHRcdGNvbnN0IHBhdGggPSAvXihcXC9cXC8pfChbYS16XSs6KFxcL1xcLyk/KS9pLnRlc3QoIHVybCApID8gdXJsIDogc2NvcGUucmVzb3VyY2VQYXRoICsgdXJsO1xuXG5cdFx0XHRcdHJldHVybiBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKCBwYXRoICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBpbWFnZS5kYXRhICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGRhdGE6IGdldFR5cGVkQXJyYXkoIGltYWdlLnR5cGUsIGltYWdlLmRhdGEgKSxcblx0XHRcdFx0XHRcdHdpZHRoOiBpbWFnZS53aWR0aCxcblx0XHRcdFx0XHRcdGhlaWdodDogaW1hZ2UuaGVpZ2h0XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCAmJiBqc29uLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGpzb24ubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW1hZ2UgPSBqc29uWyBpIF07XG5cdFx0XHRcdGNvbnN0IHVybCA9IGltYWdlLnVybDtcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHVybCApICkge1xuXG5cdFx0XHRcdFx0Ly8gbG9hZCBhcnJheSBvZiBpbWFnZXMgZS5nIEN1YmVUZXh0dXJlXG5cblx0XHRcdFx0XHRjb25zdCBpbWFnZUFycmF5ID0gW107XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gdXJsLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBjdXJyZW50VXJsID0gdXJsWyBqIF07XG5cblx0XHRcdFx0XHRcdGNvbnN0IGRlc2VyaWFsaXplZEltYWdlID0gYXdhaXQgZGVzZXJpYWxpemVJbWFnZSggY3VycmVudFVybCApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGRlc2VyaWFsaXplZEltYWdlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggZGVzZXJpYWxpemVkSW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aW1hZ2VBcnJheS5wdXNoKCBkZXNlcmlhbGl6ZWRJbWFnZSApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBzcGVjaWFsIGNhc2U6IGhhbmRsZSBhcnJheSBvZiBkYXRhIHRleHR1cmVzIGZvciBjdWJlIHRleHR1cmVzXG5cblx0XHRcdFx0XHRcdFx0XHRpbWFnZUFycmF5LnB1c2goIG5ldyBEYXRhVGV4dHVyZSggZGVzZXJpYWxpemVkSW1hZ2UuZGF0YSwgZGVzZXJpYWxpemVkSW1hZ2Uud2lkdGgsIGRlc2VyaWFsaXplZEltYWdlLmhlaWdodCApICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbWFnZXNbIGltYWdlLnV1aWQgXSA9IG5ldyBTb3VyY2UoIGltYWdlQXJyYXkgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gbG9hZCBzaW5nbGUgaW1hZ2VcblxuXHRcdFx0XHRcdGNvbnN0IGRlc2VyaWFsaXplZEltYWdlID0gYXdhaXQgZGVzZXJpYWxpemVJbWFnZSggaW1hZ2UudXJsICk7XG5cdFx0XHRcdFx0aW1hZ2VzWyBpbWFnZS51dWlkIF0gPSBuZXcgU291cmNlKCBkZXNlcmlhbGl6ZWRJbWFnZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGltYWdlcztcblxuXHR9XG5cblx0cGFyc2VUZXh0dXJlcygganNvbiwgaW1hZ2VzICkge1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VDb25zdGFudCggdmFsdWUsIHR5cGUgKSB7XG5cblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyApIHJldHVybiB2YWx1ZTtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyLnBhcnNlVGV4dHVyZTogQ29uc3RhbnQgc2hvdWxkIGJlIGluIG51bWVyaWMgZm9ybS4nLCB2YWx1ZSApO1xuXG5cdFx0XHRyZXR1cm4gdHlwZVsgdmFsdWUgXTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHRleHR1cmVzID0ge307XG5cblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGRhdGEgPSBqc29uWyBpIF07XG5cblx0XHRcdFx0aWYgKCBkYXRhLmltYWdlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IE5vIFwiaW1hZ2VcIiBzcGVjaWZpZWQgZm9yJywgZGF0YS51dWlkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaW1hZ2VzWyBkYXRhLmltYWdlIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGltYWdlJywgZGF0YS5pbWFnZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBzb3VyY2UgPSBpbWFnZXNbIGRhdGEuaW1hZ2UgXTtcblx0XHRcdFx0Y29uc3QgaW1hZ2UgPSBzb3VyY2UuZGF0YTtcblxuXHRcdFx0XHRsZXQgdGV4dHVyZTtcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGltYWdlICkgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlID0gbmV3IEN1YmVUZXh0dXJlKCk7XG5cblx0XHRcdFx0XHRpZiAoIGltYWdlLmxlbmd0aCA9PT0gNiApIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZiAoIGltYWdlICYmIGltYWdlLmRhdGEgKSB7XG5cblx0XHRcdFx0XHRcdHRleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUoKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBpbWFnZSApIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlOyAvLyB0ZXh0dXJlcyBjYW4gaGF2ZSB1bmRlZmluZWQgaW1hZ2UgZGF0YVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0ZXh0dXJlLnNvdXJjZSA9IHNvdXJjZTtcblxuXHRcdFx0XHR0ZXh0dXJlLnV1aWQgPSBkYXRhLnV1aWQ7XG5cblx0XHRcdFx0aWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubmFtZSA9IGRhdGEubmFtZTtcblxuXHRcdFx0XHRpZiAoIGRhdGEubWFwcGluZyAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYXBwaW5nID0gcGFyc2VDb25zdGFudCggZGF0YS5tYXBwaW5nLCBURVhUVVJFX01BUFBJTkcgKTtcblx0XHRcdFx0aWYgKCBkYXRhLmNoYW5uZWwgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuY2hhbm5lbCA9IGRhdGEuY2hhbm5lbDtcblxuXHRcdFx0XHRpZiAoIGRhdGEub2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm9mZnNldC5mcm9tQXJyYXkoIGRhdGEub2Zmc2V0ICk7XG5cdFx0XHRcdGlmICggZGF0YS5yZXBlYXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUucmVwZWF0LmZyb21BcnJheSggZGF0YS5yZXBlYXQgKTtcblx0XHRcdFx0aWYgKCBkYXRhLmNlbnRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5jZW50ZXIuZnJvbUFycmF5KCBkYXRhLmNlbnRlciApO1xuXHRcdFx0XHRpZiAoIGRhdGEucm90YXRpb24gIT09IHVuZGVmaW5lZCApIHRleHR1cmUucm90YXRpb24gPSBkYXRhLnJvdGF0aW9uO1xuXG5cdFx0XHRcdGlmICggZGF0YS53cmFwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLndyYXBTID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAwIF0sIFRFWFRVUkVfV1JBUFBJTkcgKTtcblx0XHRcdFx0XHR0ZXh0dXJlLndyYXBUID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAxIF0sIFRFWFRVUkVfV1JBUFBJTkcgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBkYXRhLmZvcm1hdCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5mb3JtYXQgPSBkYXRhLmZvcm1hdDtcblx0XHRcdFx0aWYgKCBkYXRhLmludGVybmFsRm9ybWF0ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmludGVybmFsRm9ybWF0ID0gZGF0YS5pbnRlcm5hbEZvcm1hdDtcblx0XHRcdFx0aWYgKCBkYXRhLnR5cGUgIT09IHVuZGVmaW5lZCApIHRleHR1cmUudHlwZSA9IGRhdGEudHlwZTtcblx0XHRcdFx0aWYgKCBkYXRhLmNvbG9yU3BhY2UgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuY29sb3JTcGFjZSA9IGRhdGEuY29sb3JTcGFjZTtcblxuXHRcdFx0XHRpZiAoIGRhdGEubWluRmlsdGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1pbkZpbHRlciA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWluRmlsdGVyLCBURVhUVVJFX0ZJTFRFUiApO1xuXHRcdFx0XHRpZiAoIGRhdGEubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hZ0ZpbHRlciA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWFnRmlsdGVyLCBURVhUVVJFX0ZJTFRFUiApO1xuXHRcdFx0XHRpZiAoIGRhdGEuYW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gZGF0YS5hbmlzb3Ryb3B5O1xuXG5cdFx0XHRcdGlmICggZGF0YS5mbGlwWSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5mbGlwWSA9IGRhdGEuZmxpcFk7XG5cblx0XHRcdFx0aWYgKCBkYXRhLmdlbmVyYXRlTWlwbWFwcyAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBkYXRhLmdlbmVyYXRlTWlwbWFwcztcblx0XHRcdFx0aWYgKCBkYXRhLnByZW11bHRpcGx5QWxwaGEgIT09IHVuZGVmaW5lZCApIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA9IGRhdGEucHJlbXVsdGlwbHlBbHBoYTtcblx0XHRcdFx0aWYgKCBkYXRhLnVucGFja0FsaWdubWVudCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS51bnBhY2tBbGlnbm1lbnQgPSBkYXRhLnVucGFja0FsaWdubWVudDtcblx0XHRcdFx0aWYgKCBkYXRhLmNvbXBhcmVGdW5jdGlvbiAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5jb21wYXJlRnVuY3Rpb24gPSBkYXRhLmNvbXBhcmVGdW5jdGlvbjtcblxuXHRcdFx0XHRpZiAoIGRhdGEudXNlckRhdGEgIT09IHVuZGVmaW5lZCApIHRleHR1cmUudXNlckRhdGEgPSBkYXRhLnVzZXJEYXRhO1xuXG5cdFx0XHRcdHRleHR1cmVzWyBkYXRhLnV1aWQgXSA9IHRleHR1cmU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0ZXh0dXJlcztcblxuXHR9XG5cblx0cGFyc2VPYmplY3QoIGRhdGEsIGdlb21ldHJpZXMsIG1hdGVyaWFscywgdGV4dHVyZXMsIGFuaW1hdGlvbnMgKSB7XG5cblx0XHRsZXQgb2JqZWN0O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0R2VvbWV0cnkoIG5hbWUgKSB7XG5cblx0XHRcdGlmICggZ2VvbWV0cmllc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgZ2VvbWV0cnknLCBuYW1lICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGdlb21ldHJpZXNbIG5hbWUgXTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldE1hdGVyaWFsKCBuYW1lICkge1xuXG5cdFx0XHRpZiAoIG5hbWUgPT09IHVuZGVmaW5lZCApIHJldHVybiB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXG5cdFx0XHRcdGNvbnN0IGFycmF5ID0gW107XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbmFtZS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdXVpZCA9IG5hbWVbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWxzWyB1dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwnLCB1dWlkICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRhcnJheS5wdXNoKCBtYXRlcmlhbHNbIHV1aWQgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbHNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIG1hdGVyaWFsJywgbmFtZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRlcmlhbHNbIG5hbWUgXTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFRleHR1cmUoIHV1aWQgKSB7XG5cblx0XHRcdGlmICggdGV4dHVyZXNbIHV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIHRleHR1cmUnLCB1dWlkICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRleHR1cmVzWyB1dWlkIF07XG5cblx0XHR9XG5cblx0XHRsZXQgZ2VvbWV0cnksIG1hdGVyaWFsO1xuXG5cdFx0c3dpdGNoICggZGF0YS50eXBlICkge1xuXG5cdFx0XHRjYXNlICdTY2VuZSc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IFNjZW5lKCk7XG5cblx0XHRcdFx0aWYgKCBkYXRhLmJhY2tncm91bmQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGlmICggTnVtYmVyLmlzSW50ZWdlciggZGF0YS5iYWNrZ3JvdW5kICkgKSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdC5iYWNrZ3JvdW5kID0gbmV3IENvbG9yKCBkYXRhLmJhY2tncm91bmQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdC5iYWNrZ3JvdW5kID0gZ2V0VGV4dHVyZSggZGF0YS5iYWNrZ3JvdW5kICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZGF0YS5lbnZpcm9ubWVudCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LmVudmlyb25tZW50ID0gZ2V0VGV4dHVyZSggZGF0YS5lbnZpcm9ubWVudCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGRhdGEuZm9nICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGRhdGEuZm9nLnR5cGUgPT09ICdGb2cnICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QuZm9nID0gbmV3IEZvZyggZGF0YS5mb2cuY29sb3IsIGRhdGEuZm9nLm5lYXIsIGRhdGEuZm9nLmZhciApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggZGF0YS5mb2cudHlwZSA9PT0gJ0ZvZ0V4cDInICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QuZm9nID0gbmV3IEZvZ0V4cDIoIGRhdGEuZm9nLmNvbG9yLCBkYXRhLmZvZy5kZW5zaXR5ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGRhdGEuZm9nLm5hbWUgIT09ICcnICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QuZm9nLm5hbWUgPSBkYXRhLmZvZy5uYW1lO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGRhdGEuYmFja2dyb3VuZEJsdXJyaW5lc3MgIT09IHVuZGVmaW5lZCApIG9iamVjdC5iYWNrZ3JvdW5kQmx1cnJpbmVzcyA9IGRhdGEuYmFja2dyb3VuZEJsdXJyaW5lc3M7XG5cdFx0XHRcdGlmICggZGF0YS5iYWNrZ3JvdW5kSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBvYmplY3QuYmFja2dyb3VuZEludGVuc2l0eSA9IGRhdGEuYmFja2dyb3VuZEludGVuc2l0eTtcblx0XHRcdFx0aWYgKCBkYXRhLmJhY2tncm91bmRSb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmJhY2tncm91bmRSb3RhdGlvbi5mcm9tQXJyYXkoIGRhdGEuYmFja2dyb3VuZFJvdGF0aW9uICk7XG5cblx0XHRcdFx0aWYgKCBkYXRhLmVudmlyb25tZW50SW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBvYmplY3QuZW52aXJvbm1lbnRJbnRlbnNpdHkgPSBkYXRhLmVudmlyb25tZW50SW50ZW5zaXR5O1xuXHRcdFx0XHRpZiAoIGRhdGEuZW52aXJvbm1lbnRSb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmVudmlyb25tZW50Um90YXRpb24uZnJvbUFycmF5KCBkYXRhLmVudmlyb25tZW50Um90YXRpb24gKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnUGVyc3BlY3RpdmVDYW1lcmEnOlxuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZGF0YS5mb3YsIGRhdGEuYXNwZWN0LCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XG5cblx0XHRcdFx0aWYgKCBkYXRhLmZvY3VzICE9PSB1bmRlZmluZWQgKSBvYmplY3QuZm9jdXMgPSBkYXRhLmZvY3VzO1xuXHRcdFx0XHRpZiAoIGRhdGEuem9vbSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0Lnpvb20gPSBkYXRhLnpvb207XG5cdFx0XHRcdGlmICggZGF0YS5maWxtR2F1Z2UgIT09IHVuZGVmaW5lZCApIG9iamVjdC5maWxtR2F1Z2UgPSBkYXRhLmZpbG1HYXVnZTtcblx0XHRcdFx0aWYgKCBkYXRhLmZpbG1PZmZzZXQgIT09IHVuZGVmaW5lZCApIG9iamVjdC5maWxtT2Zmc2V0ID0gZGF0YS5maWxtT2Zmc2V0O1xuXHRcdFx0XHRpZiAoIGRhdGEudmlldyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKCB7fSwgZGF0YS52aWV3ICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ09ydGhvZ3JhcGhpY0NhbWVyYSc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSggZGF0YS5sZWZ0LCBkYXRhLnJpZ2h0LCBkYXRhLnRvcCwgZGF0YS5ib3R0b20sIGRhdGEubmVhciwgZGF0YS5mYXIgKTtcblxuXHRcdFx0XHRpZiAoIGRhdGEuem9vbSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0Lnpvb20gPSBkYXRhLnpvb207XG5cdFx0XHRcdGlmICggZGF0YS52aWV3ICE9PSB1bmRlZmluZWQgKSBvYmplY3QudmlldyA9IE9iamVjdC5hc3NpZ24oIHt9LCBkYXRhLnZpZXcgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnQW1iaWVudExpZ2h0JzpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgQW1iaWVudExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdEaXJlY3Rpb25hbExpZ2h0JzpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgRGlyZWN0aW9uYWxMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcblx0XHRcdFx0b2JqZWN0LnRhcmdldCA9IGRhdGEudGFyZ2V0IHx8ICcnO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdQb2ludExpZ2h0JzpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgUG9pbnRMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuZGVjYXkgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnUmVjdEFyZWFMaWdodCc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IFJlY3RBcmVhTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLndpZHRoLCBkYXRhLmhlaWdodCApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdTcG90TGlnaHQnOlxuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBTcG90TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmFuZ2xlLCBkYXRhLnBlbnVtYnJhLCBkYXRhLmRlY2F5ICk7XG5cdFx0XHRcdG9iamVjdC50YXJnZXQgPSBkYXRhLnRhcmdldCB8fCAnJztcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnSGVtaXNwaGVyZUxpZ2h0JzpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgSGVtaXNwaGVyZUxpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmdyb3VuZENvbG9yLCBkYXRhLmludGVuc2l0eSApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdMaWdodFByb2JlJzpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgTGlnaHRQcm9iZSgpLmZyb21KU09OKCBkYXRhICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1NraW5uZWRNZXNoJzpcblxuXHRcdFx0XHRnZW9tZXRyeSA9IGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICk7XG5cdFx0XHQgXHRtYXRlcmlhbCA9IGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICk7XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IFNraW5uZWRNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRpZiAoIGRhdGEuYmluZE1vZGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5iaW5kTW9kZSA9IGRhdGEuYmluZE1vZGU7XG5cdFx0XHRcdGlmICggZGF0YS5iaW5kTWF0cml4ICE9PSB1bmRlZmluZWQgKSBvYmplY3QuYmluZE1hdHJpeC5mcm9tQXJyYXkoIGRhdGEuYmluZE1hdHJpeCApO1xuXHRcdFx0XHRpZiAoIGRhdGEuc2tlbGV0b24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5za2VsZXRvbiA9IGRhdGEuc2tlbGV0b247XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ01lc2gnOlxuXG5cdFx0XHRcdGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKTtcblx0XHRcdFx0bWF0ZXJpYWwgPSBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApO1xuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnSW5zdGFuY2VkTWVzaCc6XG5cblx0XHRcdFx0Z2VvbWV0cnkgPSBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApO1xuXHRcdFx0XHRtYXRlcmlhbCA9IGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICk7XG5cdFx0XHRcdGNvbnN0IGNvdW50ID0gZGF0YS5jb3VudDtcblx0XHRcdFx0Y29uc3QgaW5zdGFuY2VNYXRyaXggPSBkYXRhLmluc3RhbmNlTWF0cml4O1xuXHRcdFx0XHRjb25zdCBpbnN0YW5jZUNvbG9yID0gZGF0YS5pbnN0YW5jZUNvbG9yO1xuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBJbnN0YW5jZWRNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGNvdW50ICk7XG5cdFx0XHRcdG9iamVjdC5pbnN0YW5jZU1hdHJpeCA9IG5ldyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIGluc3RhbmNlTWF0cml4LmFycmF5ICksIDE2ICk7XG5cdFx0XHRcdGlmICggaW5zdGFuY2VDb2xvciAhPT0gdW5kZWZpbmVkICkgb2JqZWN0Lmluc3RhbmNlQ29sb3IgPSBuZXcgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBpbnN0YW5jZUNvbG9yLmFycmF5ICksIGluc3RhbmNlQ29sb3IuaXRlbVNpemUgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnQmF0Y2hlZE1lc2gnOlxuXG5cdFx0XHRcdGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKTtcblx0XHRcdFx0bWF0ZXJpYWwgPSBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApO1xuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBCYXRjaGVkTWVzaCggZGF0YS5tYXhJbnN0YW5jZUNvdW50LCBkYXRhLm1heFZlcnRleENvdW50LCBkYXRhLm1heEluZGV4Q291bnQsIG1hdGVyaWFsICk7XG5cdFx0XHRcdG9iamVjdC5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuXHRcdFx0XHRvYmplY3QucGVyT2JqZWN0RnJ1c3R1bUN1bGxlZCA9IGRhdGEucGVyT2JqZWN0RnJ1c3R1bUN1bGxlZDtcblx0XHRcdFx0b2JqZWN0LnNvcnRPYmplY3RzID0gZGF0YS5zb3J0T2JqZWN0cztcblxuXHRcdFx0XHRvYmplY3QuX2RyYXdSYW5nZXMgPSBkYXRhLmRyYXdSYW5nZXM7XG5cdFx0XHRcdG9iamVjdC5fcmVzZXJ2ZWRSYW5nZXMgPSBkYXRhLnJlc2VydmVkUmFuZ2VzO1xuXG5cdFx0XHRcdG9iamVjdC5fdmlzaWJpbGl0eSA9IGRhdGEudmlzaWJpbGl0eTtcblx0XHRcdFx0b2JqZWN0Ll9hY3RpdmUgPSBkYXRhLmFjdGl2ZTtcblx0XHRcdFx0b2JqZWN0Ll9ib3VuZHMgPSBkYXRhLmJvdW5kcy5tYXAoIGJvdW5kID0+IHtcblxuXHRcdFx0XHRcdGNvbnN0IGJveCA9IG5ldyBCb3gzKCk7XG5cdFx0XHRcdFx0Ym94Lm1pbi5mcm9tQXJyYXkoIGJvdW5kLmJveE1pbiApO1xuXHRcdFx0XHRcdGJveC5tYXguZnJvbUFycmF5KCBib3VuZC5ib3hNYXggKTtcblxuXHRcdFx0XHRcdGNvbnN0IHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblx0XHRcdFx0XHRzcGhlcmUucmFkaXVzID0gYm91bmQuc3BoZXJlUmFkaXVzO1xuXHRcdFx0XHRcdHNwaGVyZS5jZW50ZXIuZnJvbUFycmF5KCBib3VuZC5zcGhlcmVDZW50ZXIgKTtcblxuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRib3hJbml0aWFsaXplZDogYm91bmQuYm94SW5pdGlhbGl6ZWQsXG5cdFx0XHRcdFx0XHRib3g6IGJveCxcblxuXHRcdFx0XHRcdFx0c3BoZXJlSW5pdGlhbGl6ZWQ6IGJvdW5kLnNwaGVyZUluaXRpYWxpemVkLFxuXHRcdFx0XHRcdFx0c3BoZXJlOiBzcGhlcmVcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRvYmplY3QuX21heEluc3RhbmNlQ291bnQgPSBkYXRhLm1heEluc3RhbmNlQ291bnQ7XG5cdFx0XHRcdG9iamVjdC5fbWF4VmVydGV4Q291bnQgPSBkYXRhLm1heFZlcnRleENvdW50O1xuXHRcdFx0XHRvYmplY3QuX21heEluZGV4Q291bnQgPSBkYXRhLm1heEluZGV4Q291bnQ7XG5cblx0XHRcdFx0b2JqZWN0Ll9nZW9tZXRyeUluaXRpYWxpemVkID0gZGF0YS5nZW9tZXRyeUluaXRpYWxpemVkO1xuXHRcdFx0XHRvYmplY3QuX2dlb21ldHJ5Q291bnQgPSBkYXRhLmdlb21ldHJ5Q291bnQ7XG5cblx0XHRcdFx0b2JqZWN0Ll9tYXRyaWNlc1RleHR1cmUgPSBnZXRUZXh0dXJlKCBkYXRhLm1hdHJpY2VzVGV4dHVyZS51dWlkICk7XG5cdFx0XHRcdGlmICggZGF0YS5jb2xvcnNUZXh0dXJlICE9PSB1bmRlZmluZWQgKSBvYmplY3QuX2NvbG9yc1RleHR1cmUgPSBnZXRUZXh0dXJlKCBkYXRhLmNvbG9yc1RleHR1cmUudXVpZCApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdMT0QnOlxuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBMT0QoKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnTGluZSc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IExpbmUoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnTGluZUxvb3AnOlxuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lTG9vcCggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdMaW5lU2VnbWVudHMnOlxuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lU2VnbWVudHMoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnUG9pbnRDbG91ZCc6XG5cdFx0XHRjYXNlICdQb2ludHMnOlxuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBQb2ludHMoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnU3ByaXRlJzpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgU3ByaXRlKCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0dyb3VwJzpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgR3JvdXAoKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnQm9uZSc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IEJvbmUoKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgT2JqZWN0M0QoKTtcblxuXHRcdH1cblxuXHRcdG9iamVjdC51dWlkID0gZGF0YS51dWlkO1xuXG5cdFx0aWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5uYW1lID0gZGF0YS5uYW1lO1xuXG5cdFx0aWYgKCBkYXRhLm1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRvYmplY3QubWF0cml4LmZyb21BcnJheSggZGF0YS5tYXRyaXggKTtcblxuXHRcdFx0aWYgKCBkYXRhLm1hdHJpeEF1dG9VcGRhdGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlID0gZGF0YS5tYXRyaXhBdXRvVXBkYXRlO1xuXHRcdFx0aWYgKCBvYmplY3QubWF0cml4QXV0b1VwZGF0ZSApIG9iamVjdC5tYXRyaXguZGVjb21wb3NlKCBvYmplY3QucG9zaXRpb24sIG9iamVjdC5xdWF0ZXJuaW9uLCBvYmplY3Quc2NhbGUgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggZGF0YS5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnBvc2l0aW9uLmZyb21BcnJheSggZGF0YS5wb3NpdGlvbiApO1xuXHRcdFx0aWYgKCBkYXRhLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3Qucm90YXRpb24uZnJvbUFycmF5KCBkYXRhLnJvdGF0aW9uICk7XG5cdFx0XHRpZiAoIGRhdGEucXVhdGVybmlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnF1YXRlcm5pb24uZnJvbUFycmF5KCBkYXRhLnF1YXRlcm5pb24gKTtcblx0XHRcdGlmICggZGF0YS5zY2FsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNjYWxlLmZyb21BcnJheSggZGF0YS5zY2FsZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBkYXRhLnVwICE9PSB1bmRlZmluZWQgKSBvYmplY3QudXAuZnJvbUFycmF5KCBkYXRhLnVwICk7XG5cblx0XHRpZiAoIGRhdGEuY2FzdFNoYWRvdyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmNhc3RTaGFkb3cgPSBkYXRhLmNhc3RTaGFkb3c7XG5cdFx0aWYgKCBkYXRhLnJlY2VpdmVTaGFkb3cgIT09IHVuZGVmaW5lZCApIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gZGF0YS5yZWNlaXZlU2hhZG93O1xuXG5cdFx0aWYgKCBkYXRhLnNoYWRvdyApIHtcblxuXHRcdFx0aWYgKCBkYXRhLnNoYWRvdy5pbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zaGFkb3cuaW50ZW5zaXR5ID0gZGF0YS5zaGFkb3cuaW50ZW5zaXR5O1xuXHRcdFx0aWYgKCBkYXRhLnNoYWRvdy5iaWFzICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93LmJpYXMgPSBkYXRhLnNoYWRvdy5iaWFzO1xuXHRcdFx0aWYgKCBkYXRhLnNoYWRvdy5ub3JtYWxCaWFzICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93Lm5vcm1hbEJpYXMgPSBkYXRhLnNoYWRvdy5ub3JtYWxCaWFzO1xuXHRcdFx0aWYgKCBkYXRhLnNoYWRvdy5yYWRpdXMgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zaGFkb3cucmFkaXVzID0gZGF0YS5zaGFkb3cucmFkaXVzO1xuXHRcdFx0aWYgKCBkYXRhLnNoYWRvdy5tYXBTaXplICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93Lm1hcFNpemUuZnJvbUFycmF5KCBkYXRhLnNoYWRvdy5tYXBTaXplICk7XG5cdFx0XHRpZiAoIGRhdGEuc2hhZG93LmNhbWVyYSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNoYWRvdy5jYW1lcmEgPSB0aGlzLnBhcnNlT2JqZWN0KCBkYXRhLnNoYWRvdy5jYW1lcmEgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZGF0YS52aXNpYmxlICE9PSB1bmRlZmluZWQgKSBvYmplY3QudmlzaWJsZSA9IGRhdGEudmlzaWJsZTtcblx0XHRpZiAoIGRhdGEuZnJ1c3R1bUN1bGxlZCAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmZydXN0dW1DdWxsZWQgPSBkYXRhLmZydXN0dW1DdWxsZWQ7XG5cdFx0aWYgKCBkYXRhLnJlbmRlck9yZGVyICE9PSB1bmRlZmluZWQgKSBvYmplY3QucmVuZGVyT3JkZXIgPSBkYXRhLnJlbmRlck9yZGVyO1xuXHRcdGlmICggZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnVzZXJEYXRhID0gZGF0YS51c2VyRGF0YTtcblx0XHRpZiAoIGRhdGEubGF5ZXJzICE9PSB1bmRlZmluZWQgKSBvYmplY3QubGF5ZXJzLm1hc2sgPSBkYXRhLmxheWVycztcblxuXHRcdGlmICggZGF0YS5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IGRhdGEuY2hpbGRyZW47XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRvYmplY3QuYWRkKCB0aGlzLnBhcnNlT2JqZWN0KCBjaGlsZHJlblsgaSBdLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMsIHRleHR1cmVzLCBhbmltYXRpb25zICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBkYXRhLmFuaW1hdGlvbnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3Qgb2JqZWN0QW5pbWF0aW9ucyA9IGRhdGEuYW5pbWF0aW9ucztcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgb2JqZWN0QW5pbWF0aW9ucy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdXVpZCA9IG9iamVjdEFuaW1hdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRvYmplY3QuYW5pbWF0aW9ucy5wdXNoKCBhbmltYXRpb25zWyB1dWlkIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBkYXRhLnR5cGUgPT09ICdMT0QnICkge1xuXG5cdFx0XHRpZiAoIGRhdGEuYXV0b1VwZGF0ZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmF1dG9VcGRhdGUgPSBkYXRhLmF1dG9VcGRhdGU7XG5cblx0XHRcdGNvbnN0IGxldmVscyA9IGRhdGEubGV2ZWxzO1xuXG5cdFx0XHRmb3IgKCBsZXQgbCA9IDA7IGwgPCBsZXZlbHMubGVuZ3RoOyBsICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGxldmVsID0gbGV2ZWxzWyBsIF07XG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gb2JqZWN0LmdldE9iamVjdEJ5UHJvcGVydHkoICd1dWlkJywgbGV2ZWwub2JqZWN0ICk7XG5cblx0XHRcdFx0aWYgKCBjaGlsZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LmFkZExldmVsKCBjaGlsZCwgbGV2ZWwuZGlzdGFuY2UsIGxldmVsLmh5c3RlcmVzaXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBvYmplY3Q7XG5cblx0fVxuXG5cdGJpbmRTa2VsZXRvbnMoIG9iamVjdCwgc2tlbGV0b25zICkge1xuXG5cdFx0aWYgKCBPYmplY3Qua2V5cyggc2tlbGV0b25zICkubGVuZ3RoID09PSAwICkgcmV0dXJuO1xuXG5cdFx0b2JqZWN0LnRyYXZlcnNlKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRpZiAoIGNoaWxkLmlzU2tpbm5lZE1lc2ggPT09IHRydWUgJiYgY2hpbGQuc2tlbGV0b24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zdCBza2VsZXRvbiA9IHNrZWxldG9uc1sgY2hpbGQuc2tlbGV0b24gXTtcblxuXHRcdFx0XHRpZiAoIHNrZWxldG9uID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IE5vIHNrZWxldG9uIGZvdW5kIHdpdGggVVVJRDonLCBjaGlsZC5za2VsZXRvbiApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjaGlsZC5iaW5kKCBza2VsZXRvbiwgY2hpbGQuYmluZE1hdHJpeCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSApO1xuXG5cdH1cblxuXHRiaW5kTGlnaHRUYXJnZXRzKCBvYmplY3QgKSB7XG5cblx0XHRvYmplY3QudHJhdmVyc2UoIGZ1bmN0aW9uICggY2hpbGQgKSB7XG5cblx0XHRcdGlmICggY2hpbGQuaXNEaXJlY3Rpb25hbExpZ2h0IHx8IGNoaWxkLmlzU3BvdExpZ2h0ICkge1xuXG5cdFx0XHRcdGNvbnN0IHV1aWQgPSBjaGlsZC50YXJnZXQ7XG5cblx0XHRcdFx0Y29uc3QgdGFyZ2V0ID0gb2JqZWN0LmdldE9iamVjdEJ5UHJvcGVydHkoICd1dWlkJywgdXVpZCApO1xuXG5cdFx0XHRcdGlmICggdGFyZ2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjaGlsZC50YXJnZXQgPSB0YXJnZXQ7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNoaWxkLnRhcmdldCA9IG5ldyBPYmplY3QzRCgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSApO1xuXG5cdH1cblxufVxuXG5jb25zdCBURVhUVVJFX01BUFBJTkcgPSB7XG5cdFVWTWFwcGluZzogVVZNYXBwaW5nLFxuXHRDdWJlUmVmbGVjdGlvbk1hcHBpbmc6IEN1YmVSZWZsZWN0aW9uTWFwcGluZyxcblx0Q3ViZVJlZnJhY3Rpb25NYXBwaW5nOiBDdWJlUmVmcmFjdGlvbk1hcHBpbmcsXG5cdEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nOiBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyxcblx0RXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6IEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nLFxuXHRDdWJlVVZSZWZsZWN0aW9uTWFwcGluZzogQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmdcbn07XG5cbmNvbnN0IFRFWFRVUkVfV1JBUFBJTkcgPSB7XG5cdFJlcGVhdFdyYXBwaW5nOiBSZXBlYXRXcmFwcGluZyxcblx0Q2xhbXBUb0VkZ2VXcmFwcGluZzogQ2xhbXBUb0VkZ2VXcmFwcGluZyxcblx0TWlycm9yZWRSZXBlYXRXcmFwcGluZzogTWlycm9yZWRSZXBlYXRXcmFwcGluZ1xufTtcblxuY29uc3QgVEVYVFVSRV9GSUxURVIgPSB7XG5cdE5lYXJlc3RGaWx0ZXI6IE5lYXJlc3RGaWx0ZXIsXG5cdE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyOiBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlcixcblx0TmVhcmVzdE1pcG1hcExpbmVhckZpbHRlcjogTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlcixcblx0TGluZWFyRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXG5cdExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXI6IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsXG5cdExpbmVhck1pcG1hcExpbmVhckZpbHRlcjogTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyXG59O1xuXG5jbGFzcyBJbWFnZUJpdG1hcExvYWRlciBleHRlbmRzIExvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdFx0dGhpcy5pc0ltYWdlQml0bWFwTG9hZGVyID0gdHJ1ZTtcblxuXHRcdGlmICggdHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSAndW5kZWZpbmVkJyApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VCaXRtYXBMb2FkZXI6IGNyZWF0ZUltYWdlQml0bWFwKCkgbm90IHN1cHBvcnRlZC4nICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlQml0bWFwTG9hZGVyOiBmZXRjaCgpIG5vdCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5vcHRpb25zID0geyBwcmVtdWx0aXBseUFscGhhOiAnbm9uZScgfTtcblxuXHR9XG5cblx0c2V0T3B0aW9ucyggb3B0aW9ucyApIHtcblxuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRpZiAoIHVybCA9PT0gdW5kZWZpbmVkICkgdXJsID0gJyc7XG5cblx0XHRpZiAoIHRoaXMucGF0aCAhPT0gdW5kZWZpbmVkICkgdXJsID0gdGhpcy5wYXRoICsgdXJsO1xuXG5cdFx0dXJsID0gdGhpcy5tYW5hZ2VyLnJlc29sdmVVUkwoIHVybCApO1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0Y29uc3QgY2FjaGVkID0gQ2FjaGUuZ2V0KCB1cmwgKTtcblxuXHRcdGlmICggY2FjaGVkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuXHRcdFx0Ly8gSWYgY2FjaGVkIGlzIGEgcHJvbWlzZSwgd2FpdCBmb3IgaXQgdG8gcmVzb2x2ZVxuXHRcdFx0aWYgKCBjYWNoZWQudGhlbiApIHtcblxuXHRcdFx0XHRjYWNoZWQudGhlbiggaW1hZ2VCaXRtYXAgPT4ge1xuXG5cdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGltYWdlQml0bWFwICk7XG5cblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHRcdH0gKS5jYXRjaCggZSA9PiB7XG5cblx0XHRcdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBlICk7XG5cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgY2FjaGVkIGlzIG5vdCBhIHByb21pc2UgKGkuZS4sIGl0J3MgYWxyZWFkeSBhbiBpbWFnZUJpdG1hcClcblx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggY2FjaGVkICk7XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0fSwgMCApO1xuXG5cdFx0XHRyZXR1cm4gY2FjaGVkO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZmV0Y2hPcHRpb25zID0ge307XG5cdFx0ZmV0Y2hPcHRpb25zLmNyZWRlbnRpYWxzID0gKCB0aGlzLmNyb3NzT3JpZ2luID09PSAnYW5vbnltb3VzJyApID8gJ3NhbWUtb3JpZ2luJyA6ICdpbmNsdWRlJztcblx0XHRmZXRjaE9wdGlvbnMuaGVhZGVycyA9IHRoaXMucmVxdWVzdEhlYWRlcjtcblxuXHRcdGNvbnN0IHByb21pc2UgPSBmZXRjaCggdXJsLCBmZXRjaE9wdGlvbnMgKS50aGVuKCBmdW5jdGlvbiAoIHJlcyApIHtcblxuXHRcdFx0cmV0dXJuIHJlcy5ibG9iKCk7XG5cblx0XHR9ICkudGhlbiggZnVuY3Rpb24gKCBibG9iICkge1xuXG5cdFx0XHRyZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAoIGJsb2IsIE9iamVjdC5hc3NpZ24oIHNjb3BlLm9wdGlvbnMsIHsgY29sb3JTcGFjZUNvbnZlcnNpb246ICdub25lJyB9ICkgKTtcblxuXHRcdH0gKS50aGVuKCBmdW5jdGlvbiAoIGltYWdlQml0bWFwICkge1xuXG5cdFx0XHRDYWNoZS5hZGQoIHVybCwgaW1hZ2VCaXRtYXAgKTtcblxuXHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGltYWdlQml0bWFwICk7XG5cblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdHJldHVybiBpbWFnZUJpdG1hcDtcblxuXHRcdH0gKS5jYXRjaCggZnVuY3Rpb24gKCBlICkge1xuXG5cdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBlICk7XG5cblx0XHRcdENhY2hlLnJlbW92ZSggdXJsICk7XG5cblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHR9ICk7XG5cblx0XHRDYWNoZS5hZGQoIHVybCwgcHJvbWlzZSApO1xuXHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuXHR9XG5cbn1cblxubGV0IF9jb250ZXh0O1xuXG5jbGFzcyBBdWRpb0NvbnRleHQge1xuXG5cdHN0YXRpYyBnZXRDb250ZXh0KCkge1xuXG5cdFx0aWYgKCBfY29udGV4dCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRfY29udGV4dCA9IG5ldyAoIHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCApKCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gX2NvbnRleHQ7XG5cblx0fVxuXG5cdHN0YXRpYyBzZXRDb250ZXh0KCB2YWx1ZSApIHtcblxuXHRcdF9jb250ZXh0ID0gdmFsdWU7XG5cblx0fVxuXG59XG5cbmNsYXNzIEF1ZGlvTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMucmVxdWVzdEhlYWRlciApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIGEgY29weSBvZiB0aGUgYnVmZmVyLiBUaGUgYGRlY29kZUF1ZGlvRGF0YWAgbWV0aG9kXG5cdFx0XHRcdC8vIGRldGFjaGVzIHRoZSBidWZmZXIgd2hlbiBjb21wbGV0ZSwgcHJldmVudGluZyByZXVzZS5cblx0XHRcdFx0Y29uc3QgYnVmZmVyQ29weSA9IGJ1ZmZlci5zbGljZSggMCApO1xuXG5cdFx0XHRcdGNvbnN0IGNvbnRleHQgPSBBdWRpb0NvbnRleHQuZ2V0Q29udGV4dCgpO1xuXHRcdFx0XHRjb250ZXh0LmRlY29kZUF1ZGlvRGF0YSggYnVmZmVyQ29weSwgZnVuY3Rpb24gKCBhdWRpb0J1ZmZlciApIHtcblxuXHRcdFx0XHRcdG9uTG9hZCggYXVkaW9CdWZmZXIgKTtcblxuXHRcdFx0XHR9ICkuY2F0Y2goIGhhbmRsZUVycm9yICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdGhhbmRsZUVycm9yKCBlICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHRcdGZ1bmN0aW9uIGhhbmRsZUVycm9yKCBlICkge1xuXG5cdFx0XHRpZiAoIG9uRXJyb3IgKSB7XG5cblx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmNvbnN0IF9leWVSaWdodCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9leWVMZWZ0ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3Byb2plY3Rpb25NYXRyaXggPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5cbmNsYXNzIFN0ZXJlb0NhbWVyYSB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHR0aGlzLnR5cGUgPSAnU3RlcmVvQ2FtZXJhJztcblxuXHRcdHRoaXMuYXNwZWN0ID0gMTtcblxuXHRcdHRoaXMuZXllU2VwID0gMC4wNjQ7XG5cblx0XHR0aGlzLmNhbWVyYUwgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcblx0XHR0aGlzLmNhbWVyYUwubGF5ZXJzLmVuYWJsZSggMSApO1xuXHRcdHRoaXMuY2FtZXJhTC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLmNhbWVyYVIgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcblx0XHR0aGlzLmNhbWVyYVIubGF5ZXJzLmVuYWJsZSggMiApO1xuXHRcdHRoaXMuY2FtZXJhUi5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLl9jYWNoZSA9IHtcblx0XHRcdGZvY3VzOiBudWxsLFxuXHRcdFx0Zm92OiBudWxsLFxuXHRcdFx0YXNwZWN0OiBudWxsLFxuXHRcdFx0bmVhcjogbnVsbCxcblx0XHRcdGZhcjogbnVsbCxcblx0XHRcdHpvb206IG51bGwsXG5cdFx0XHRleWVTZXA6IG51bGxcblx0XHR9O1xuXG5cdH1cblxuXHR1cGRhdGUoIGNhbWVyYSApIHtcblxuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGU7XG5cblx0XHRjb25zdCBuZWVkc1VwZGF0ZSA9IGNhY2hlLmZvY3VzICE9PSBjYW1lcmEuZm9jdXMgfHwgY2FjaGUuZm92ICE9PSBjYW1lcmEuZm92IHx8XG5cdFx0XHRjYWNoZS5hc3BlY3QgIT09IGNhbWVyYS5hc3BlY3QgKiB0aGlzLmFzcGVjdCB8fCBjYWNoZS5uZWFyICE9PSBjYW1lcmEubmVhciB8fFxuXHRcdFx0Y2FjaGUuZmFyICE9PSBjYW1lcmEuZmFyIHx8IGNhY2hlLnpvb20gIT09IGNhbWVyYS56b29tIHx8IGNhY2hlLmV5ZVNlcCAhPT0gdGhpcy5leWVTZXA7XG5cblx0XHRpZiAoIG5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRjYWNoZS5mb2N1cyA9IGNhbWVyYS5mb2N1cztcblx0XHRcdGNhY2hlLmZvdiA9IGNhbWVyYS5mb3Y7XG5cdFx0XHRjYWNoZS5hc3BlY3QgPSBjYW1lcmEuYXNwZWN0ICogdGhpcy5hc3BlY3Q7XG5cdFx0XHRjYWNoZS5uZWFyID0gY2FtZXJhLm5lYXI7XG5cdFx0XHRjYWNoZS5mYXIgPSBjYW1lcmEuZmFyO1xuXHRcdFx0Y2FjaGUuem9vbSA9IGNhbWVyYS56b29tO1xuXHRcdFx0Y2FjaGUuZXllU2VwID0gdGhpcy5leWVTZXA7XG5cblx0XHRcdC8vIE9mZi1heGlzIHN0ZXJlb3Njb3BpYyBlZmZlY3QgYmFzZWQgb25cblx0XHRcdC8vIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9zdGVyZW9ncmFwaGljcy9zdGVyZW9yZW5kZXIvXG5cblx0XHRcdF9wcm9qZWN0aW9uTWF0cml4LmNvcHkoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cdFx0XHRjb25zdCBleWVTZXBIYWxmID0gY2FjaGUuZXllU2VwIC8gMjtcblx0XHRcdGNvbnN0IGV5ZVNlcE9uUHJvamVjdGlvbiA9IGV5ZVNlcEhhbGYgKiBjYWNoZS5uZWFyIC8gY2FjaGUuZm9jdXM7XG5cdFx0XHRjb25zdCB5bWF4ID0gKCBjYWNoZS5uZWFyICogTWF0aC50YW4oIERFRzJSQUQgKiBjYWNoZS5mb3YgKiAwLjUgKSApIC8gY2FjaGUuem9vbTtcblx0XHRcdGxldCB4bWluLCB4bWF4O1xuXG5cdFx0XHQvLyB0cmFuc2xhdGUgeE9mZnNldFxuXG5cdFx0XHRfZXllTGVmdC5lbGVtZW50c1sgMTIgXSA9IC0gZXllU2VwSGFsZjtcblx0XHRcdF9leWVSaWdodC5lbGVtZW50c1sgMTIgXSA9IGV5ZVNlcEhhbGY7XG5cblx0XHRcdC8vIGZvciBsZWZ0IGV5ZVxuXG5cdFx0XHR4bWluID0gLSB5bWF4ICogY2FjaGUuYXNwZWN0ICsgZXllU2VwT25Qcm9qZWN0aW9uO1xuXHRcdFx0eG1heCA9IHltYXggKiBjYWNoZS5hc3BlY3QgKyBleWVTZXBPblByb2plY3Rpb247XG5cblx0XHRcdF9wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyAwIF0gPSAyICogY2FjaGUubmVhciAvICggeG1heCAtIHhtaW4gKTtcblx0XHRcdF9wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyA4IF0gPSAoIHhtYXggKyB4bWluICkgLyAoIHhtYXggLSB4bWluICk7XG5cblx0XHRcdHRoaXMuY2FtZXJhTC5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIF9wcm9qZWN0aW9uTWF0cml4ICk7XG5cblx0XHRcdC8vIGZvciByaWdodCBleWVcblxuXHRcdFx0eG1pbiA9IC0geW1heCAqIGNhY2hlLmFzcGVjdCAtIGV5ZVNlcE9uUHJvamVjdGlvbjtcblx0XHRcdHhtYXggPSB5bWF4ICogY2FjaGUuYXNwZWN0IC0gZXllU2VwT25Qcm9qZWN0aW9uO1xuXG5cdFx0XHRfcHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgMCBdID0gMiAqIGNhY2hlLm5lYXIgLyAoIHhtYXggLSB4bWluICk7XG5cdFx0XHRfcHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgOCBdID0gKCB4bWF4ICsgeG1pbiApIC8gKCB4bWF4IC0geG1pbiApO1xuXG5cdFx0XHR0aGlzLmNhbWVyYVIucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBfcHJvamVjdGlvbk1hdHJpeCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5jYW1lcmFMLm1hdHJpeFdvcmxkLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZCApLm11bHRpcGx5KCBfZXllTGVmdCApO1xuXHRcdHRoaXMuY2FtZXJhUi5tYXRyaXhXb3JsZC5jb3B5KCBjYW1lcmEubWF0cml4V29ybGQgKS5tdWx0aXBseSggX2V5ZVJpZ2h0ICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIEFycmF5Q2FtZXJhIGV4dGVuZHMgUGVyc3BlY3RpdmVDYW1lcmEge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSA9IFtdICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNBcnJheUNhbWVyYSA9IHRydWU7XG5cblx0XHR0aGlzLmNhbWVyYXMgPSBhcnJheTtcblxuXHR9XG5cbn1cblxuY2xhc3MgQ2xvY2sge1xuXG5cdGNvbnN0cnVjdG9yKCBhdXRvU3RhcnQgPSB0cnVlICkge1xuXG5cdFx0dGhpcy5hdXRvU3RhcnQgPSBhdXRvU3RhcnQ7XG5cblx0XHR0aGlzLnN0YXJ0VGltZSA9IDA7XG5cdFx0dGhpcy5vbGRUaW1lID0gMDtcblx0XHR0aGlzLmVsYXBzZWRUaW1lID0gMDtcblxuXHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG5cdH1cblxuXHRzdGFydCgpIHtcblxuXHRcdHRoaXMuc3RhcnRUaW1lID0gbm93KCk7XG5cblx0XHR0aGlzLm9sZFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcblx0XHR0aGlzLmVsYXBzZWRUaW1lID0gMDtcblx0XHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXG5cdH1cblxuXHRzdG9wKCkge1xuXG5cdFx0dGhpcy5nZXRFbGFwc2VkVGltZSgpO1xuXHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXHRcdHRoaXMuYXV0b1N0YXJ0ID0gZmFsc2U7XG5cblx0fVxuXG5cdGdldEVsYXBzZWRUaW1lKCkge1xuXG5cdFx0dGhpcy5nZXREZWx0YSgpO1xuXHRcdHJldHVybiB0aGlzLmVsYXBzZWRUaW1lO1xuXG5cdH1cblxuXHRnZXREZWx0YSgpIHtcblxuXHRcdGxldCBkaWZmID0gMDtcblxuXHRcdGlmICggdGhpcy5hdXRvU3RhcnQgJiYgISB0aGlzLnJ1bm5pbmcgKSB7XG5cblx0XHRcdHRoaXMuc3RhcnQoKTtcblx0XHRcdHJldHVybiAwO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnJ1bm5pbmcgKSB7XG5cblx0XHRcdGNvbnN0IG5ld1RpbWUgPSBub3coKTtcblxuXHRcdFx0ZGlmZiA9ICggbmV3VGltZSAtIHRoaXMub2xkVGltZSApIC8gMTAwMDtcblx0XHRcdHRoaXMub2xkVGltZSA9IG5ld1RpbWU7XG5cblx0XHRcdHRoaXMuZWxhcHNlZFRpbWUgKz0gZGlmZjtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkaWZmO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBub3coKSB7XG5cblx0cmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuXG59XG5cbmNvbnN0IF9wb3NpdGlvbiQxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3F1YXRlcm5pb24kMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFF1YXRlcm5pb24oKTtcbmNvbnN0IF9zY2FsZSQxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX29yaWVudGF0aW9uJDEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNsYXNzIEF1ZGlvTGlzdGVuZXIgZXh0ZW5kcyBPYmplY3QzRCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ0F1ZGlvTGlzdGVuZXInO1xuXG5cdFx0dGhpcy5jb250ZXh0ID0gQXVkaW9Db250ZXh0LmdldENvbnRleHQoKTtcblxuXHRcdHRoaXMuZ2FpbiA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdFx0dGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXG5cdFx0dGhpcy5maWx0ZXIgPSBudWxsO1xuXG5cdFx0dGhpcy50aW1lRGVsdGEgPSAwO1xuXG5cdFx0Ly8gcHJpdmF0ZVxuXG5cdFx0dGhpcy5fY2xvY2sgPSBuZXcgQ2xvY2soKTtcblxuXHR9XG5cblx0Z2V0SW5wdXQoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nYWluO1xuXG5cdH1cblxuXHRyZW1vdmVGaWx0ZXIoKSB7XG5cblx0XHRpZiAoIHRoaXMuZmlsdGVyICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmdhaW4uZGlzY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcblx0XHRcdHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXHRcdFx0dGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXHRcdFx0dGhpcy5maWx0ZXIgPSBudWxsO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldEZpbHRlcigpIHtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlcjtcblxuXHR9XG5cblx0c2V0RmlsdGVyKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy5maWx0ZXIgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KCB0aGlzLmZpbHRlciApO1xuXHRcdFx0dGhpcy5maWx0ZXIuZGlzY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmdhaW4uZGlzY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmZpbHRlciA9IHZhbHVlO1xuXHRcdHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmZpbHRlciApO1xuXHRcdHRoaXMuZmlsdGVyLmNvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldE1hc3RlclZvbHVtZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcblxuXHR9XG5cblx0c2V0TWFzdGVyVm9sdW1lKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuZ2Fpbi5nYWluLnNldFRhcmdldEF0VGltZSggdmFsdWUsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSwgMC4wMSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcblxuXHRcdHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xuXG5cdFx0Y29uc3QgbGlzdGVuZXIgPSB0aGlzLmNvbnRleHQubGlzdGVuZXI7XG5cdFx0Y29uc3QgdXAgPSB0aGlzLnVwO1xuXG5cdFx0dGhpcy50aW1lRGVsdGEgPSB0aGlzLl9jbG9jay5nZXREZWx0YSgpO1xuXG5cdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIF9wb3NpdGlvbiQxLCBfcXVhdGVybmlvbiQxLCBfc2NhbGUkMSApO1xuXG5cdFx0X29yaWVudGF0aW9uJDEuc2V0KCAwLCAwLCAtIDEgKS5hcHBseVF1YXRlcm5pb24oIF9xdWF0ZXJuaW9uJDEgKTtcblxuXHRcdGlmICggbGlzdGVuZXIucG9zaXRpb25YICkge1xuXG5cdFx0XHQvLyBjb2RlIHBhdGggZm9yIENocm9tZSAoc2VlICMxNDM5MylcblxuXHRcdFx0Y29uc3QgZW5kVGltZSA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZSArIHRoaXMudGltZURlbHRhO1xuXG5cdFx0XHRsaXN0ZW5lci5wb3NpdGlvblgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoIF9wb3NpdGlvbiQxLngsIGVuZFRpbWUgKTtcblx0XHRcdGxpc3RlbmVyLnBvc2l0aW9uWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX3Bvc2l0aW9uJDEueSwgZW5kVGltZSApO1xuXHRcdFx0bGlzdGVuZXIucG9zaXRpb25aLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCBfcG9zaXRpb24kMS56LCBlbmRUaW1lICk7XG5cdFx0XHRsaXN0ZW5lci5mb3J3YXJkWC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX29yaWVudGF0aW9uJDEueCwgZW5kVGltZSApO1xuXHRcdFx0bGlzdGVuZXIuZm9yd2FyZFkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoIF9vcmllbnRhdGlvbiQxLnksIGVuZFRpbWUgKTtcblx0XHRcdGxpc3RlbmVyLmZvcndhcmRaLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCBfb3JpZW50YXRpb24kMS56LCBlbmRUaW1lICk7XG5cdFx0XHRsaXN0ZW5lci51cFgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoIHVwLngsIGVuZFRpbWUgKTtcblx0XHRcdGxpc3RlbmVyLnVwWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggdXAueSwgZW5kVGltZSApO1xuXHRcdFx0bGlzdGVuZXIudXBaLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCB1cC56LCBlbmRUaW1lICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRsaXN0ZW5lci5zZXRQb3NpdGlvbiggX3Bvc2l0aW9uJDEueCwgX3Bvc2l0aW9uJDEueSwgX3Bvc2l0aW9uJDEueiApO1xuXHRcdFx0bGlzdGVuZXIuc2V0T3JpZW50YXRpb24oIF9vcmllbnRhdGlvbiQxLngsIF9vcmllbnRhdGlvbiQxLnksIF9vcmllbnRhdGlvbiQxLnosIHVwLngsIHVwLnksIHVwLnogKTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuY2xhc3MgQXVkaW8gZXh0ZW5kcyBPYmplY3QzRCB7XG5cblx0Y29uc3RydWN0b3IoIGxpc3RlbmVyICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdBdWRpbyc7XG5cblx0XHR0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG5cdFx0dGhpcy5jb250ZXh0ID0gbGlzdGVuZXIuY29udGV4dDtcblxuXHRcdHRoaXMuZ2FpbiA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdFx0dGhpcy5nYWluLmNvbm5lY3QoIGxpc3RlbmVyLmdldElucHV0KCkgKTtcblxuXHRcdHRoaXMuYXV0b3BsYXkgPSBmYWxzZTtcblxuXHRcdHRoaXMuYnVmZmVyID0gbnVsbDtcblx0XHR0aGlzLmRldHVuZSA9IDA7XG5cdFx0dGhpcy5sb29wID0gZmFsc2U7XG5cdFx0dGhpcy5sb29wU3RhcnQgPSAwO1xuXHRcdHRoaXMubG9vcEVuZCA9IDA7XG5cdFx0dGhpcy5vZmZzZXQgPSAwO1xuXHRcdHRoaXMuZHVyYXRpb24gPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5wbGF5YmFja1JhdGUgPSAxO1xuXHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cdFx0dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPSB0cnVlO1xuXHRcdHRoaXMuc291cmNlID0gbnVsbDtcblx0XHR0aGlzLnNvdXJjZVR5cGUgPSAnZW1wdHknO1xuXG5cdFx0dGhpcy5fc3RhcnRlZEF0ID0gMDtcblx0XHR0aGlzLl9wcm9ncmVzcyA9IDA7XG5cdFx0dGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG5cblx0XHR0aGlzLmZpbHRlcnMgPSBbXTtcblxuXHR9XG5cblx0Z2V0T3V0cHV0KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2FpbjtcblxuXHR9XG5cblx0c2V0Tm9kZVNvdXJjZSggYXVkaW9Ob2RlICkge1xuXG5cdFx0dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPSBmYWxzZTtcblx0XHR0aGlzLnNvdXJjZVR5cGUgPSAnYXVkaW9Ob2RlJztcblx0XHR0aGlzLnNvdXJjZSA9IGF1ZGlvTm9kZTtcblx0XHR0aGlzLmNvbm5lY3QoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRNZWRpYUVsZW1lbnRTb3VyY2UoIG1lZGlhRWxlbWVudCApIHtcblxuXHRcdHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gZmFsc2U7XG5cdFx0dGhpcy5zb3VyY2VUeXBlID0gJ21lZGlhTm9kZSc7XG5cdFx0dGhpcy5zb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlTWVkaWFFbGVtZW50U291cmNlKCBtZWRpYUVsZW1lbnQgKTtcblx0XHR0aGlzLmNvbm5lY3QoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRNZWRpYVN0cmVhbVNvdXJjZSggbWVkaWFTdHJlYW0gKSB7XG5cblx0XHR0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9IGZhbHNlO1xuXHRcdHRoaXMuc291cmNlVHlwZSA9ICdtZWRpYVN0cmVhbU5vZGUnO1xuXHRcdHRoaXMuc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKCBtZWRpYVN0cmVhbSApO1xuXHRcdHRoaXMuY29ubmVjdCgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEJ1ZmZlciggYXVkaW9CdWZmZXIgKSB7XG5cblx0XHR0aGlzLmJ1ZmZlciA9IGF1ZGlvQnVmZmVyO1xuXHRcdHRoaXMuc291cmNlVHlwZSA9ICdidWZmZXInO1xuXG5cdFx0aWYgKCB0aGlzLmF1dG9wbGF5ICkgdGhpcy5wbGF5KCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cGxheSggZGVsYXkgPSAwICkge1xuXG5cdFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IEF1ZGlvIGlzIGFscmVhZHkgcGxheWluZy4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fc3RhcnRlZEF0ID0gdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICsgZGVsYXk7XG5cblx0XHRjb25zdCBzb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cdFx0c291cmNlLmJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuXHRcdHNvdXJjZS5sb29wID0gdGhpcy5sb29wO1xuXHRcdHNvdXJjZS5sb29wU3RhcnQgPSB0aGlzLmxvb3BTdGFydDtcblx0XHRzb3VyY2UubG9vcEVuZCA9IHRoaXMubG9vcEVuZDtcblx0XHRzb3VyY2Uub25lbmRlZCA9IHRoaXMub25FbmRlZC5iaW5kKCB0aGlzICk7XG5cdFx0c291cmNlLnN0YXJ0KCB0aGlzLl9zdGFydGVkQXQsIHRoaXMuX3Byb2dyZXNzICsgdGhpcy5vZmZzZXQsIHRoaXMuZHVyYXRpb24gKTtcblxuXHRcdHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcblxuXHRcdHRoaXMuc291cmNlID0gc291cmNlO1xuXG5cdFx0dGhpcy5zZXREZXR1bmUoIHRoaXMuZGV0dW5lICk7XG5cdFx0dGhpcy5zZXRQbGF5YmFja1JhdGUoIHRoaXMucGxheWJhY2tSYXRlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5jb25uZWN0KCk7XG5cblx0fVxuXG5cdHBhdXNlKCkge1xuXG5cdFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdC8vIHVwZGF0ZSBjdXJyZW50IHByb2dyZXNzXG5cblx0XHRcdHRoaXMuX3Byb2dyZXNzICs9IE1hdGgubWF4KCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgLSB0aGlzLl9zdGFydGVkQXQsIDAgKSAqIHRoaXMucGxheWJhY2tSYXRlO1xuXG5cdFx0XHRpZiAoIHRoaXMubG9vcCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHQvLyBlbnN1cmUgX3Byb2dyZXNzIGRvZXMgbm90IGV4Y2VlZCBkdXJhdGlvbiB3aXRoIGxvb3BlZCBhdWRpb3NcblxuXHRcdFx0XHR0aGlzLl9wcm9ncmVzcyA9IHRoaXMuX3Byb2dyZXNzICUgKCB0aGlzLmR1cmF0aW9uIHx8IHRoaXMuYnVmZmVyLmR1cmF0aW9uICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zb3VyY2Uuc3RvcCgpO1xuXHRcdFx0dGhpcy5zb3VyY2Uub25lbmRlZCA9IG51bGw7XG5cblx0XHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3RvcCggZGVsYXkgPSAwICkge1xuXG5cdFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHRoaXMuX3Byb2dyZXNzID0gMDtcblxuXHRcdGlmICggdGhpcy5zb3VyY2UgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuc291cmNlLnN0b3AoIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSArIGRlbGF5ICk7XG5cdFx0XHR0aGlzLnNvdXJjZS5vbmVuZGVkID0gbnVsbDtcblxuXHRcdH1cblxuXHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29ubmVjdCgpIHtcblxuXHRcdGlmICggdGhpcy5maWx0ZXJzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdHRoaXMuc291cmNlLmNvbm5lY3QoIHRoaXMuZmlsdGVyc1sgMCBdICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMSwgbCA9IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMuZmlsdGVyc1sgaSAtIDEgXS5jb25uZWN0KCB0aGlzLmZpbHRlcnNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZmlsdGVyc1sgdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDEgXS5jb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnNvdXJjZS5jb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRpc2Nvbm5lY3QoKSB7XG5cblx0XHRpZiAoIHRoaXMuX2Nvbm5lY3RlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5maWx0ZXJzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoIHRoaXMuZmlsdGVyc1sgMCBdICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMSwgbCA9IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMuZmlsdGVyc1sgaSAtIDEgXS5kaXNjb25uZWN0KCB0aGlzLmZpbHRlcnNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZmlsdGVyc1sgdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDEgXS5kaXNjb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRGaWx0ZXJzKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVycztcblxuXHR9XG5cblx0c2V0RmlsdGVycyggdmFsdWUgKSB7XG5cblx0XHRpZiAoICEgdmFsdWUgKSB2YWx1ZSA9IFtdO1xuXG5cdFx0aWYgKCB0aGlzLl9jb25uZWN0ZWQgPT09IHRydWUgKSB7XG5cblx0XHRcdHRoaXMuZGlzY29ubmVjdCgpO1xuXHRcdFx0dGhpcy5maWx0ZXJzID0gdmFsdWUuc2xpY2UoKTtcblx0XHRcdHRoaXMuY29ubmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5maWx0ZXJzID0gdmFsdWUuc2xpY2UoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXREZXR1bmUoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5kZXR1bmUgPSB2YWx1ZTtcblxuXHRcdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgJiYgdGhpcy5zb3VyY2UuZGV0dW5lICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuc291cmNlLmRldHVuZS5zZXRUYXJnZXRBdFRpbWUoIHRoaXMuZGV0dW5lLCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUsIDAuMDEgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXREZXR1bmUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kZXR1bmU7XG5cblx0fVxuXG5cdGdldEZpbHRlcigpIHtcblxuXHRcdHJldHVybiB0aGlzLmdldEZpbHRlcnMoKVsgMCBdO1xuXG5cdH1cblxuXHRzZXRGaWx0ZXIoIGZpbHRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZpbHRlcnMoIGZpbHRlciA/IFsgZmlsdGVyIF0gOiBbXSApO1xuXG5cdH1cblxuXHRzZXRQbGF5YmFja1JhdGUoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHRoaXMucGxheWJhY2tSYXRlID0gdmFsdWU7XG5cblx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG5cdFx0XHR0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VGFyZ2V0QXRUaW1lKCB0aGlzLnBsYXliYWNrUmF0ZSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lLCAwLjAxICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0UGxheWJhY2tSYXRlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMucGxheWJhY2tSYXRlO1xuXG5cdH1cblxuXHRvbkVuZGVkKCkge1xuXG5cdFx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblx0XHR0aGlzLl9wcm9ncmVzcyA9IDA7XG5cblx0fVxuXG5cdGdldExvb3AoKSB7XG5cblx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubG9vcDtcblxuXHR9XG5cblx0c2V0TG9vcCggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5sb29wID0gdmFsdWU7XG5cblx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG5cdFx0XHR0aGlzLnNvdXJjZS5sb29wID0gdGhpcy5sb29wO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldExvb3BTdGFydCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmxvb3BTdGFydCA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldExvb3BFbmQoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5sb29wRW5kID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Vm9sdW1lKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlO1xuXG5cdH1cblxuXHRzZXRWb2x1bWUoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5nYWluLmdhaW4uc2V0VGFyZ2V0QXRUaW1lKCB2YWx1ZSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lLCAwLjAxICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0aWYgKCBzb3VyY2Uuc291cmNlVHlwZSAhPT0gJ2J1ZmZlcicgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiBBdWRpbyBzb3VyY2UgdHlwZSBjYW5ub3QgYmUgY29waWVkLicgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHR0aGlzLmF1dG9wbGF5ID0gc291cmNlLmF1dG9wbGF5O1xuXG5cdFx0dGhpcy5idWZmZXIgPSBzb3VyY2UuYnVmZmVyO1xuXHRcdHRoaXMuZGV0dW5lID0gc291cmNlLmRldHVuZTtcblx0XHR0aGlzLmxvb3AgPSBzb3VyY2UubG9vcDtcblx0XHR0aGlzLmxvb3BTdGFydCA9IHNvdXJjZS5sb29wU3RhcnQ7XG5cdFx0dGhpcy5sb29wRW5kID0gc291cmNlLmxvb3BFbmQ7XG5cdFx0dGhpcy5vZmZzZXQgPSBzb3VyY2Uub2Zmc2V0O1xuXHRcdHRoaXMuZHVyYXRpb24gPSBzb3VyY2UuZHVyYXRpb247XG5cdFx0dGhpcy5wbGF5YmFja1JhdGUgPSBzb3VyY2UucGxheWJhY2tSYXRlO1xuXHRcdHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gc291cmNlLmhhc1BsYXliYWNrQ29udHJvbDtcblx0XHR0aGlzLnNvdXJjZVR5cGUgPSBzb3VyY2Uuc291cmNlVHlwZTtcblxuXHRcdHRoaXMuZmlsdGVycyA9IHNvdXJjZS5maWx0ZXJzLnNsaWNlKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5saXN0ZW5lciApLmNvcHkoIHRoaXMsIHJlY3Vyc2l2ZSApO1xuXG5cdH1cblxufVxuXG5jb25zdCBfcG9zaXRpb24gPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfcXVhdGVybmlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFF1YXRlcm5pb24oKTtcbmNvbnN0IF9zY2FsZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9vcmllbnRhdGlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY2xhc3MgUG9zaXRpb25hbEF1ZGlvIGV4dGVuZHMgQXVkaW8ge1xuXG5cdGNvbnN0cnVjdG9yKCBsaXN0ZW5lciApIHtcblxuXHRcdHN1cGVyKCBsaXN0ZW5lciApO1xuXG5cdFx0dGhpcy5wYW5uZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlUGFubmVyKCk7XG5cdFx0dGhpcy5wYW5uZXIucGFubmluZ01vZGVsID0gJ0hSVEYnO1xuXHRcdHRoaXMucGFubmVyLmNvbm5lY3QoIHRoaXMuZ2FpbiApO1xuXG5cdH1cblxuXHRjb25uZWN0KCkge1xuXG5cdFx0c3VwZXIuY29ubmVjdCgpO1xuXG5cdFx0dGhpcy5wYW5uZXIuY29ubmVjdCggdGhpcy5nYWluICk7XG5cblx0fVxuXG5cdGRpc2Nvbm5lY3QoKSB7XG5cblx0XHRzdXBlci5kaXNjb25uZWN0KCk7XG5cblx0XHR0aGlzLnBhbm5lci5kaXNjb25uZWN0KCB0aGlzLmdhaW4gKTtcblxuXHR9XG5cblx0Z2V0T3V0cHV0KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMucGFubmVyO1xuXG5cdH1cblxuXHRnZXRSZWZEaXN0YW5jZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnBhbm5lci5yZWZEaXN0YW5jZTtcblxuXHR9XG5cblx0c2V0UmVmRGlzdGFuY2UoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5wYW5uZXIucmVmRGlzdGFuY2UgPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRSb2xsb2ZmRmFjdG9yKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3I7XG5cblx0fVxuXG5cdHNldFJvbGxvZmZGYWN0b3IoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvciA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldERpc3RhbmNlTW9kZWwoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbDtcblxuXHR9XG5cblx0c2V0RGlzdGFuY2VNb2RlbCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnBhbm5lci5kaXN0YW5jZU1vZGVsID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0TWF4RGlzdGFuY2UoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5wYW5uZXIubWF4RGlzdGFuY2U7XG5cblx0fVxuXG5cdHNldE1heERpc3RhbmNlKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMucGFubmVyLm1heERpc3RhbmNlID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RGlyZWN0aW9uYWxDb25lKCBjb25lSW5uZXJBbmdsZSwgY29uZU91dGVyQW5nbGUsIGNvbmVPdXRlckdhaW4gKSB7XG5cblx0XHR0aGlzLnBhbm5lci5jb25lSW5uZXJBbmdsZSA9IGNvbmVJbm5lckFuZ2xlO1xuXHRcdHRoaXMucGFubmVyLmNvbmVPdXRlckFuZ2xlID0gY29uZU91dGVyQW5nbGU7XG5cdFx0dGhpcy5wYW5uZXIuY29uZU91dGVyR2FpbiA9IGNvbmVPdXRlckdhaW47XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG5cdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XG5cblx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSB0cnVlICYmIHRoaXMuaXNQbGF5aW5nID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBfcG9zaXRpb24sIF9xdWF0ZXJuaW9uLCBfc2NhbGUgKTtcblxuXHRcdF9vcmllbnRhdGlvbi5zZXQoIDAsIDAsIDEgKS5hcHBseVF1YXRlcm5pb24oIF9xdWF0ZXJuaW9uICk7XG5cblx0XHRjb25zdCBwYW5uZXIgPSB0aGlzLnBhbm5lcjtcblxuXHRcdGlmICggcGFubmVyLnBvc2l0aW9uWCApIHtcblxuXHRcdFx0Ly8gY29kZSBwYXRoIGZvciBDaHJvbWUgYW5kIEZpcmVmb3ggKHNlZSAjMTQzOTMpXG5cblx0XHRcdGNvbnN0IGVuZFRpbWUgPSB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLmxpc3RlbmVyLnRpbWVEZWx0YTtcblxuXHRcdFx0cGFubmVyLnBvc2l0aW9uWC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX3Bvc2l0aW9uLngsIGVuZFRpbWUgKTtcblx0XHRcdHBhbm5lci5wb3NpdGlvblkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoIF9wb3NpdGlvbi55LCBlbmRUaW1lICk7XG5cdFx0XHRwYW5uZXIucG9zaXRpb25aLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCBfcG9zaXRpb24ueiwgZW5kVGltZSApO1xuXHRcdFx0cGFubmVyLm9yaWVudGF0aW9uWC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX29yaWVudGF0aW9uLngsIGVuZFRpbWUgKTtcblx0XHRcdHBhbm5lci5vcmllbnRhdGlvblkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoIF9vcmllbnRhdGlvbi55LCBlbmRUaW1lICk7XG5cdFx0XHRwYW5uZXIub3JpZW50YXRpb25aLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCBfb3JpZW50YXRpb24ueiwgZW5kVGltZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cGFubmVyLnNldFBvc2l0aW9uKCBfcG9zaXRpb24ueCwgX3Bvc2l0aW9uLnksIF9wb3NpdGlvbi56ICk7XG5cdFx0XHRwYW5uZXIuc2V0T3JpZW50YXRpb24oIF9vcmllbnRhdGlvbi54LCBfb3JpZW50YXRpb24ueSwgX29yaWVudGF0aW9uLnogKTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuY2xhc3MgQXVkaW9BbmFseXNlciB7XG5cblx0Y29uc3RydWN0b3IoIGF1ZGlvLCBmZnRTaXplID0gMjA0OCApIHtcblxuXHRcdHRoaXMuYW5hbHlzZXIgPSBhdWRpby5jb250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG5cdFx0dGhpcy5hbmFseXNlci5mZnRTaXplID0gZmZ0U2l6ZTtcblxuXHRcdHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KCB0aGlzLmFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50ICk7XG5cblx0XHRhdWRpby5nZXRPdXRwdXQoKS5jb25uZWN0KCB0aGlzLmFuYWx5c2VyICk7XG5cblx0fVxuXG5cblx0Z2V0RnJlcXVlbmN5RGF0YSgpIHtcblxuXHRcdHRoaXMuYW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoIHRoaXMuZGF0YSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZGF0YTtcblxuXHR9XG5cblx0Z2V0QXZlcmFnZUZyZXF1ZW5jeSgpIHtcblxuXHRcdGxldCB2YWx1ZSA9IDA7XG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuZ2V0RnJlcXVlbmN5RGF0YSgpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhbHVlICs9IGRhdGFbIGkgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZSAvIGRhdGEubGVuZ3RoO1xuXG5cdH1cblxufVxuXG5jbGFzcyBQcm9wZXJ0eU1peGVyIHtcblxuXHRjb25zdHJ1Y3RvciggYmluZGluZywgdHlwZU5hbWUsIHZhbHVlU2l6ZSApIHtcblxuXHRcdHRoaXMuYmluZGluZyA9IGJpbmRpbmc7XG5cdFx0dGhpcy52YWx1ZVNpemUgPSB2YWx1ZVNpemU7XG5cblx0XHRsZXQgbWl4RnVuY3Rpb24sXG5cdFx0XHRtaXhGdW5jdGlvbkFkZGl0aXZlLFxuXHRcdFx0c2V0SWRlbnRpdHk7XG5cblx0XHQvLyBidWZmZXIgbGF5b3V0OiBbIGluY29taW5nIHwgYWNjdTAgfCBhY2N1MSB8IG9yaWcgfCBhZGRBY2N1IHwgKG9wdGlvbmFsIHdvcmspIF1cblx0XHQvL1xuXHRcdC8vIGludGVycG9sYXRvcnMgY2FuIHVzZSAuYnVmZmVyIGFzIHRoZWlyIC5yZXN1bHRcblx0XHQvLyB0aGUgZGF0YSB0aGVuIGdvZXMgdG8gJ2luY29taW5nJ1xuXHRcdC8vXG5cdFx0Ly8gJ2FjY3UwJyBhbmQgJ2FjY3UxJyBhcmUgdXNlZCBmcmFtZS1pbnRlcmxlYXZlZCBmb3Jcblx0XHQvLyB0aGUgY3VtdWxhdGl2ZSByZXN1bHQgYW5kIGFyZSBjb21wYXJlZCB0byBkZXRlY3Rcblx0XHQvLyBjaGFuZ2VzXG5cdFx0Ly9cblx0XHQvLyAnb3JpZycgc3RvcmVzIHRoZSBvcmlnaW5hbCBzdGF0ZSBvZiB0aGUgcHJvcGVydHlcblx0XHQvL1xuXHRcdC8vICdhZGQnIGlzIHVzZWQgZm9yIGFkZGl0aXZlIGN1bXVsYXRpdmUgcmVzdWx0c1xuXHRcdC8vXG5cdFx0Ly8gJ3dvcmsnIGlzIG9wdGlvbmFsIGFuZCBpcyBvbmx5IHByZXNlbnQgZm9yIHF1YXRlcm5pb24gdHlwZXMuIEl0IGlzIHVzZWRcblx0XHQvLyB0byBzdG9yZSBpbnRlcm1lZGlhdGUgcXVhdGVybmlvbiBtdWx0aXBsaWNhdGlvbiByZXN1bHRzXG5cblx0XHRzd2l0Y2ggKCB0eXBlTmFtZSApIHtcblxuXHRcdFx0Y2FzZSAncXVhdGVybmlvbic6XG5cdFx0XHRcdG1peEZ1bmN0aW9uID0gdGhpcy5fc2xlcnA7XG5cdFx0XHRcdG1peEZ1bmN0aW9uQWRkaXRpdmUgPSB0aGlzLl9zbGVycEFkZGl0aXZlO1xuXHRcdFx0XHRzZXRJZGVudGl0eSA9IHRoaXMuX3NldEFkZGl0aXZlSWRlbnRpdHlRdWF0ZXJuaW9uO1xuXG5cdFx0XHRcdHRoaXMuYnVmZmVyID0gbmV3IEZsb2F0NjRBcnJheSggdmFsdWVTaXplICogNiApO1xuXHRcdFx0XHR0aGlzLl93b3JrSW5kZXggPSA1O1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnc3RyaW5nJzpcblx0XHRcdGNhc2UgJ2Jvb2wnOlxuXHRcdFx0XHRtaXhGdW5jdGlvbiA9IHRoaXMuX3NlbGVjdDtcblxuXHRcdFx0XHQvLyBVc2UgdGhlIHJlZ3VsYXIgbWl4IGZ1bmN0aW9uIGFuZCBmb3IgYWRkaXRpdmUgb24gdGhlc2UgdHlwZXMsXG5cdFx0XHRcdC8vIGFkZGl0aXZlIGlzIG5vdCByZWxldmFudCBmb3Igbm9uLW51bWVyaWMgdHlwZXNcblx0XHRcdFx0bWl4RnVuY3Rpb25BZGRpdGl2ZSA9IHRoaXMuX3NlbGVjdDtcblxuXHRcdFx0XHRzZXRJZGVudGl0eSA9IHRoaXMuX3NldEFkZGl0aXZlSWRlbnRpdHlPdGhlcjtcblxuXHRcdFx0XHR0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheSggdmFsdWVTaXplICogNSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9sZXJwO1xuXHRcdFx0XHRtaXhGdW5jdGlvbkFkZGl0aXZlID0gdGhpcy5fbGVycEFkZGl0aXZlO1xuXHRcdFx0XHRzZXRJZGVudGl0eSA9IHRoaXMuX3NldEFkZGl0aXZlSWRlbnRpdHlOdW1lcmljO1xuXG5cdFx0XHRcdHRoaXMuYnVmZmVyID0gbmV3IEZsb2F0NjRBcnJheSggdmFsdWVTaXplICogNSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uID0gbWl4RnVuY3Rpb247XG5cdFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uQWRkaXRpdmUgPSBtaXhGdW5jdGlvbkFkZGl0aXZlO1xuXHRcdHRoaXMuX3NldElkZW50aXR5ID0gc2V0SWRlbnRpdHk7XG5cdFx0dGhpcy5fb3JpZ0luZGV4ID0gMztcblx0XHR0aGlzLl9hZGRJbmRleCA9IDQ7XG5cblx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xuXHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlID0gMDtcblxuXHRcdHRoaXMudXNlQ291bnQgPSAwO1xuXHRcdHRoaXMucmVmZXJlbmNlQ291bnQgPSAwO1xuXG5cdH1cblxuXHQvLyBhY2N1bXVsYXRlIGRhdGEgaW4gdGhlICdpbmNvbWluZycgcmVnaW9uIGludG8gJ2FjY3U8aT4nXG5cdGFjY3VtdWxhdGUoIGFjY3VJbmRleCwgd2VpZ2h0ICkge1xuXG5cdFx0Ly8gbm90ZTogaGFwcGlseSBhY2N1bXVsYXRpbmcgbm90aGluZyB3aGVuIHdlaWdodCA9IDAsIHRoZSBjYWxsZXIga25vd3Ncblx0XHQvLyB0aGUgd2VpZ2h0IGFuZCBzaG91bGRuJ3QgaGF2ZSBtYWRlIHRoZSBjYWxsIGluIHRoZSBmaXJzdCBwbGFjZVxuXG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXIsXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblx0XHRcdG9mZnNldCA9IGFjY3VJbmRleCAqIHN0cmlkZSArIHN0cmlkZTtcblxuXHRcdGxldCBjdXJyZW50V2VpZ2h0ID0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0O1xuXG5cdFx0aWYgKCBjdXJyZW50V2VpZ2h0ID09PSAwICkge1xuXG5cdFx0XHQvLyBhY2N1TiA6PSBpbmNvbWluZyAqIHdlaWdodFxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcblxuXHRcdFx0XHRidWZmZXJbIG9mZnNldCArIGkgXSA9IGJ1ZmZlclsgaSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGN1cnJlbnRXZWlnaHQgPSB3ZWlnaHQ7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBhY2N1TiA6PSBhY2N1TiArIGluY29taW5nICogd2VpZ2h0XG5cblx0XHRcdGN1cnJlbnRXZWlnaHQgKz0gd2VpZ2h0O1xuXHRcdFx0Y29uc3QgbWl4ID0gd2VpZ2h0IC8gY3VycmVudFdlaWdodDtcblx0XHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbiggYnVmZmVyLCBvZmZzZXQsIDAsIG1peCwgc3RyaWRlICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSBjdXJyZW50V2VpZ2h0O1xuXG5cdH1cblxuXHQvLyBhY2N1bXVsYXRlIGRhdGEgaW4gdGhlICdpbmNvbWluZycgcmVnaW9uIGludG8gJ2FkZCdcblx0YWNjdW11bGF0ZUFkZGl0aXZlKCB3ZWlnaHQgKSB7XG5cblx0XHRjb25zdCBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXHRcdFx0b2Zmc2V0ID0gc3RyaWRlICogdGhpcy5fYWRkSW5kZXg7XG5cblx0XHRpZiAoIHRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlID09PSAwICkge1xuXG5cdFx0XHQvLyBhZGQgPSBpZGVudGl0eVxuXG5cdFx0XHR0aGlzLl9zZXRJZGVudGl0eSgpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYWRkIDo9IGFkZCArIGluY29taW5nICogd2VpZ2h0XG5cblx0XHR0aGlzLl9taXhCdWZmZXJSZWdpb25BZGRpdGl2ZSggYnVmZmVyLCBvZmZzZXQsIDAsIHdlaWdodCwgc3RyaWRlICk7XG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUgKz0gd2VpZ2h0O1xuXG5cdH1cblxuXHQvLyBhcHBseSB0aGUgc3RhdGUgb2YgJ2FjY3U8aT4nIHRvIHRoZSBiaW5kaW5nIHdoZW4gYWNjdXMgZGlmZmVyXG5cdGFwcGx5KCBhY2N1SW5kZXggKSB7XG5cblx0XHRjb25zdCBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblx0XHRcdGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxuXHRcdFx0b2Zmc2V0ID0gYWNjdUluZGV4ICogc3RyaWRlICsgc3RyaWRlLFxuXG5cdFx0XHR3ZWlnaHQgPSB0aGlzLmN1bXVsYXRpdmVXZWlnaHQsXG5cdFx0XHR3ZWlnaHRBZGRpdGl2ZSA9IHRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlLFxuXG5cdFx0XHRiaW5kaW5nID0gdGhpcy5iaW5kaW5nO1xuXG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcblx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZSA9IDA7XG5cblx0XHRpZiAoIHdlaWdodCA8IDEgKSB7XG5cblx0XHRcdC8vIGFjY3VOIDo9IGFjY3VOICsgb3JpZ2luYWwgKiAoIDEgLSBjdW11bGF0aXZlV2VpZ2h0IClcblxuXHRcdFx0Y29uc3Qgb3JpZ2luYWxWYWx1ZU9mZnNldCA9IHN0cmlkZSAqIHRoaXMuX29yaWdJbmRleDtcblxuXHRcdFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uKFxuXHRcdFx0XHRidWZmZXIsIG9mZnNldCwgb3JpZ2luYWxWYWx1ZU9mZnNldCwgMSAtIHdlaWdodCwgc3RyaWRlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHdlaWdodEFkZGl0aXZlID4gMCApIHtcblxuXHRcdFx0Ly8gYWNjdU4gOj0gYWNjdU4gKyBhZGRpdGl2ZSBhY2N1TlxuXG5cdFx0XHR0aGlzLl9taXhCdWZmZXJSZWdpb25BZGRpdGl2ZSggYnVmZmVyLCBvZmZzZXQsIHRoaXMuX2FkZEluZGV4ICogc3RyaWRlLCAxLCBzdHJpZGUgKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gc3RyaWRlLCBlID0gc3RyaWRlICsgc3RyaWRlOyBpICE9PSBlOyArKyBpICkge1xuXG5cdFx0XHRpZiAoIGJ1ZmZlclsgaSBdICE9PSBidWZmZXJbIGkgKyBzdHJpZGUgXSApIHtcblxuXHRcdFx0XHQvLyB2YWx1ZSBoYXMgY2hhbmdlZCAtPiB1cGRhdGUgc2NlbmUgZ3JhcGhcblxuXHRcdFx0XHRiaW5kaW5nLnNldFZhbHVlKCBidWZmZXIsIG9mZnNldCApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyByZW1lbWJlciB0aGUgc3RhdGUgb2YgdGhlIGJvdW5kIHByb3BlcnR5IGFuZCBjb3B5IGl0IHRvIGJvdGggYWNjdXNcblx0c2F2ZU9yaWdpbmFsU3RhdGUoKSB7XG5cblx0XHRjb25zdCBiaW5kaW5nID0gdGhpcy5iaW5kaW5nO1xuXG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXIsXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblxuXHRcdFx0b3JpZ2luYWxWYWx1ZU9mZnNldCA9IHN0cmlkZSAqIHRoaXMuX29yaWdJbmRleDtcblxuXHRcdGJpbmRpbmcuZ2V0VmFsdWUoIGJ1ZmZlciwgb3JpZ2luYWxWYWx1ZU9mZnNldCApO1xuXG5cdFx0Ly8gYWNjdVswLi4xXSA6PSBvcmlnIC0tIGluaXRpYWxseSBkZXRlY3QgY2hhbmdlcyBhZ2FpbnN0IHRoZSBvcmlnaW5hbFxuXHRcdGZvciAoIGxldCBpID0gc3RyaWRlLCBlID0gb3JpZ2luYWxWYWx1ZU9mZnNldDsgaSAhPT0gZTsgKysgaSApIHtcblxuXHRcdFx0YnVmZmVyWyBpIF0gPSBidWZmZXJbIG9yaWdpbmFsVmFsdWVPZmZzZXQgKyAoIGkgJSBzdHJpZGUgKSBdO1xuXG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRvIGlkZW50aXR5IGZvciBhZGRpdGl2ZVxuXHRcdHRoaXMuX3NldElkZW50aXR5KCk7XG5cblx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xuXHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlID0gMDtcblxuXHR9XG5cblx0Ly8gYXBwbHkgdGhlIHN0YXRlIHByZXZpb3VzbHkgdGFrZW4gdmlhICdzYXZlT3JpZ2luYWxTdGF0ZScgdG8gdGhlIGJpbmRpbmdcblx0cmVzdG9yZU9yaWdpbmFsU3RhdGUoKSB7XG5cblx0XHRjb25zdCBvcmlnaW5hbFZhbHVlT2Zmc2V0ID0gdGhpcy52YWx1ZVNpemUgKiAzO1xuXHRcdHRoaXMuYmluZGluZy5zZXRWYWx1ZSggdGhpcy5idWZmZXIsIG9yaWdpbmFsVmFsdWVPZmZzZXQgKTtcblxuXHR9XG5cblx0X3NldEFkZGl0aXZlSWRlbnRpdHlOdW1lcmljKCkge1xuXG5cdFx0Y29uc3Qgc3RhcnRJbmRleCA9IHRoaXMuX2FkZEluZGV4ICogdGhpcy52YWx1ZVNpemU7XG5cdFx0Y29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgdGhpcy52YWx1ZVNpemU7XG5cblx0XHRmb3IgKCBsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5idWZmZXJbIGkgXSA9IDA7XG5cblx0XHR9XG5cblx0fVxuXG5cdF9zZXRBZGRpdGl2ZUlkZW50aXR5UXVhdGVybmlvbigpIHtcblxuXHRcdHRoaXMuX3NldEFkZGl0aXZlSWRlbnRpdHlOdW1lcmljKCk7XG5cdFx0dGhpcy5idWZmZXJbIHRoaXMuX2FkZEluZGV4ICogdGhpcy52YWx1ZVNpemUgKyAzIF0gPSAxO1xuXG5cdH1cblxuXHRfc2V0QWRkaXRpdmVJZGVudGl0eU90aGVyKCkge1xuXG5cdFx0Y29uc3Qgc3RhcnRJbmRleCA9IHRoaXMuX29yaWdJbmRleCAqIHRoaXMudmFsdWVTaXplO1xuXHRcdGNvbnN0IHRhcmdldEluZGV4ID0gdGhpcy5fYWRkSW5kZXggKiB0aGlzLnZhbHVlU2l6ZTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWVTaXplOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmJ1ZmZlclsgdGFyZ2V0SW5kZXggKyBpIF0gPSB0aGlzLmJ1ZmZlclsgc3RhcnRJbmRleCArIGkgXTtcblxuXHRcdH1cblxuXHR9XG5cblxuXHQvLyBtaXggZnVuY3Rpb25zXG5cblx0X3NlbGVjdCggYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCwgc3RyaWRlICkge1xuXG5cdFx0aWYgKCB0ID49IDAuNSApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cblx0XHRcdFx0YnVmZmVyWyBkc3RPZmZzZXQgKyBpIF0gPSBidWZmZXJbIHNyY09mZnNldCArIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRfc2xlcnAoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQgKSB7XG5cblx0XHRRdWF0ZXJuaW9uLnNsZXJwRmxhdCggYnVmZmVyLCBkc3RPZmZzZXQsIGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIHNyY09mZnNldCwgdCApO1xuXG5cdH1cblxuXHRfc2xlcnBBZGRpdGl2ZSggYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCwgc3RyaWRlICkge1xuXG5cdFx0Y29uc3Qgd29ya09mZnNldCA9IHRoaXMuX3dvcmtJbmRleCAqIHN0cmlkZTtcblxuXHRcdC8vIFN0b3JlIHJlc3VsdCBpbiBpbnRlcm1lZGlhdGUgYnVmZmVyIG9mZnNldFxuXHRcdFF1YXRlcm5pb24ubXVsdGlwbHlRdWF0ZXJuaW9uc0ZsYXQoIGJ1ZmZlciwgd29ya09mZnNldCwgYnVmZmVyLCBkc3RPZmZzZXQsIGJ1ZmZlciwgc3JjT2Zmc2V0ICk7XG5cblx0XHQvLyBTbGVycCB0byB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdFxuXHRcdFF1YXRlcm5pb24uc2xlcnBGbGF0KCBidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCBkc3RPZmZzZXQsIGJ1ZmZlciwgd29ya09mZnNldCwgdCApO1xuXG5cdH1cblxuXHRfbGVycCggYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCwgc3RyaWRlICkge1xuXG5cdFx0Y29uc3QgcyA9IDEgLSB0O1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IGogPSBkc3RPZmZzZXQgKyBpO1xuXG5cdFx0XHRidWZmZXJbIGogXSA9IGJ1ZmZlclsgaiBdICogcyArIGJ1ZmZlclsgc3JjT2Zmc2V0ICsgaSBdICogdDtcblxuXHRcdH1cblxuXHR9XG5cblx0X2xlcnBBZGRpdGl2ZSggYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCwgc3RyaWRlICkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IGogPSBkc3RPZmZzZXQgKyBpO1xuXG5cdFx0XHRidWZmZXJbIGogXSA9IGJ1ZmZlclsgaiBdICsgYnVmZmVyWyBzcmNPZmZzZXQgKyBpIF0gKiB0O1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG4vLyBDaGFyYWN0ZXJzIFtdLjovIGFyZSByZXNlcnZlZCBmb3IgdHJhY2sgYmluZGluZyBzeW50YXguXG5jb25zdCBfUkVTRVJWRURfQ0hBUlNfUkUgPSAnXFxcXFtcXFxcXVxcXFwuOlxcXFwvJztcbmNvbnN0IF9yZXNlcnZlZFJlID0gbmV3IFJlZ0V4cCggJ1snICsgX1JFU0VSVkVEX0NIQVJTX1JFICsgJ10nLCAnZycgKTtcblxuLy8gQXR0ZW1wdHMgdG8gYWxsb3cgbm9kZSBuYW1lcyBmcm9tIGFueSBsYW5ndWFnZS4gRVM1J3MgYFxcd2AgcmVnZXhwIG1hdGNoZXNcbi8vIG9ubHkgbGF0aW4gY2hhcmFjdGVycywgYW5kIHRoZSB1bmljb2RlIFxccHtMfSBpcyBub3QgeWV0IHN1cHBvcnRlZC4gU29cbi8vIGluc3RlYWQsIHdlIGV4Y2x1ZGUgcmVzZXJ2ZWQgY2hhcmFjdGVycyBhbmQgbWF0Y2ggZXZlcnl0aGluZyBlbHNlLlxuY29uc3QgX3dvcmRDaGFyID0gJ1teJyArIF9SRVNFUlZFRF9DSEFSU19SRSArICddJztcbmNvbnN0IF93b3JkQ2hhck9yRG90ID0gJ1teJyArIF9SRVNFUlZFRF9DSEFSU19SRS5yZXBsYWNlKCAnXFxcXC4nLCAnJyApICsgJ10nO1xuXG4vLyBQYXJlbnQgZGlyZWN0b3JpZXMsIGRlbGltaXRlZCBieSAnLycgb3IgJzonLiBDdXJyZW50bHkgdW51c2VkLCBidXQgbXVzdFxuLy8gYmUgbWF0Y2hlZCB0byBwYXJzZSB0aGUgcmVzdCBvZiB0aGUgdHJhY2sgbmFtZS5cbmNvbnN0IF9kaXJlY3RvcnlSZSA9IC8qQF9fUFVSRV9fKi8gLygoPzpXQytbXFwvOl0pKikvLnNvdXJjZS5yZXBsYWNlKCAnV0MnLCBfd29yZENoYXIgKTtcblxuLy8gVGFyZ2V0IG5vZGUuIE1heSBjb250YWluIHdvcmQgY2hhcmFjdGVycyAoYS16QS1aMC05XykgYW5kICcuJyBvciAnLScuXG5jb25zdCBfbm9kZVJlID0gLypAX19QVVJFX18qLyAvKFdDT0QrKT8vLnNvdXJjZS5yZXBsYWNlKCAnV0NPRCcsIF93b3JkQ2hhck9yRG90ICk7XG5cbi8vIE9iamVjdCBvbiB0YXJnZXQgbm9kZSwgYW5kIGFjY2Vzc29yLiBNYXkgbm90IGNvbnRhaW4gcmVzZXJ2ZWRcbi8vIGNoYXJhY3RlcnMuIEFjY2Vzc29yIG1heSBjb250YWluIGFueSBjaGFyYWN0ZXIgZXhjZXB0IGNsb3NpbmcgYnJhY2tldC5cbmNvbnN0IF9vYmplY3RSZSA9IC8qQF9fUFVSRV9fKi8gLyg/OlxcLihXQyspKD86XFxbKC4rKVxcXSk/KT8vLnNvdXJjZS5yZXBsYWNlKCAnV0MnLCBfd29yZENoYXIgKTtcblxuLy8gUHJvcGVydHkgYW5kIGFjY2Vzc29yLiBNYXkgbm90IGNvbnRhaW4gcmVzZXJ2ZWQgY2hhcmFjdGVycy4gQWNjZXNzb3IgbWF5XG4vLyBjb250YWluIGFueSBub24tYnJhY2tldCBjaGFyYWN0ZXJzLlxuY29uc3QgX3Byb3BlcnR5UmUgPSAvKkBfX1BVUkVfXyovIC9cXC4oV0MrKSg/OlxcWyguKylcXF0pPy8uc291cmNlLnJlcGxhY2UoICdXQycsIF93b3JkQ2hhciApO1xuXG5jb25zdCBfdHJhY2tSZSA9IG5ldyBSZWdFeHAoICcnXG5cdCsgJ14nXG5cdCsgX2RpcmVjdG9yeVJlXG5cdCsgX25vZGVSZVxuXHQrIF9vYmplY3RSZVxuXHQrIF9wcm9wZXJ0eVJlXG5cdCsgJyQnXG4pO1xuXG5jb25zdCBfc3VwcG9ydGVkT2JqZWN0TmFtZXMgPSBbICdtYXRlcmlhbCcsICdtYXRlcmlhbHMnLCAnYm9uZXMnLCAnbWFwJyBdO1xuXG5jbGFzcyBDb21wb3NpdGUge1xuXG5cdGNvbnN0cnVjdG9yKCB0YXJnZXRHcm91cCwgcGF0aCwgb3B0aW9uYWxQYXJzZWRQYXRoICkge1xuXG5cdFx0Y29uc3QgcGFyc2VkUGF0aCA9IG9wdGlvbmFsUGFyc2VkUGF0aCB8fCBQcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUoIHBhdGggKTtcblxuXHRcdHRoaXMuX3RhcmdldEdyb3VwID0gdGFyZ2V0R3JvdXA7XG5cdFx0dGhpcy5fYmluZGluZ3MgPSB0YXJnZXRHcm91cC5zdWJzY3JpYmVfKCBwYXRoLCBwYXJzZWRQYXRoICk7XG5cblx0fVxuXG5cdGdldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5iaW5kKCk7IC8vIGJpbmQgYWxsIGJpbmRpbmdcblxuXHRcdGNvbnN0IGZpcnN0VmFsaWRJbmRleCA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxcblx0XHRcdGJpbmRpbmcgPSB0aGlzLl9iaW5kaW5nc1sgZmlyc3RWYWxpZEluZGV4IF07XG5cblx0XHQvLyBhbmQgb25seSBjYWxsIC5nZXRWYWx1ZSBvbiB0aGUgZmlyc3Rcblx0XHRpZiAoIGJpbmRpbmcgIT09IHVuZGVmaW5lZCApIGJpbmRpbmcuZ2V0VmFsdWUoIGFycmF5LCBvZmZzZXQgKTtcblxuXHR9XG5cblx0c2V0VmFsdWUoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGJpbmRpbmdzWyBpIF0uc2V0VmFsdWUoIGFycmF5LCBvZmZzZXQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0YmluZCgpIHtcblxuXHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cblx0XHRmb3IgKCBsZXQgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXywgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0YmluZGluZ3NbIGkgXS5iaW5kKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHVuYmluZCgpIHtcblxuXHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cblx0XHRmb3IgKCBsZXQgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXywgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0YmluZGluZ3NbIGkgXS51bmJpbmQoKTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuLy8gTm90ZTogVGhpcyBjbGFzcyB1c2VzIGEgU3RhdGUgcGF0dGVybiBvbiBhIHBlci1tZXRob2QgYmFzaXM6XG4vLyAnYmluZCcgc2V0cyAndGhpcy5nZXRWYWx1ZScgLyAnc2V0VmFsdWUnIGFuZCBzaGFkb3dzIHRoZVxuLy8gcHJvdG90eXBlIHZlcnNpb24gb2YgdGhlc2UgbWV0aG9kcyB3aXRoIG9uZSB0aGF0IHJlcHJlc2VudHNcbi8vIHRoZSBib3VuZCBzdGF0ZS4gV2hlbiB0aGUgcHJvcGVydHkgaXMgbm90IGZvdW5kLCB0aGUgbWV0aG9kc1xuLy8gYmVjb21lIG5vLW9wcy5cbmNsYXNzIFByb3BlcnR5QmluZGluZyB7XG5cblx0Y29uc3RydWN0b3IoIHJvb3ROb2RlLCBwYXRoLCBwYXJzZWRQYXRoICkge1xuXG5cdFx0dGhpcy5wYXRoID0gcGF0aDtcblx0XHR0aGlzLnBhcnNlZFBhdGggPSBwYXJzZWRQYXRoIHx8IFByb3BlcnR5QmluZGluZy5wYXJzZVRyYWNrTmFtZSggcGF0aCApO1xuXG5cdFx0dGhpcy5ub2RlID0gUHJvcGVydHlCaW5kaW5nLmZpbmROb2RlKCByb290Tm9kZSwgdGhpcy5wYXJzZWRQYXRoLm5vZGVOYW1lICk7XG5cblx0XHR0aGlzLnJvb3ROb2RlID0gcm9vdE5vZGU7XG5cblx0XHQvLyBpbml0aWFsIHN0YXRlIG9mIHRoZXNlIG1ldGhvZHMgdGhhdCBjYWxscyAnYmluZCdcblx0XHR0aGlzLmdldFZhbHVlID0gdGhpcy5fZ2V0VmFsdWVfdW5ib3VuZDtcblx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5fc2V0VmFsdWVfdW5ib3VuZDtcblxuXHR9XG5cblxuXHRzdGF0aWMgY3JlYXRlKCByb290LCBwYXRoLCBwYXJzZWRQYXRoICkge1xuXG5cdFx0aWYgKCAhICggcm9vdCAmJiByb290LmlzQW5pbWF0aW9uT2JqZWN0R3JvdXAgKSApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBQcm9wZXJ0eUJpbmRpbmcoIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBuZXcgUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZSggcm9vdCwgcGF0aCwgcGFyc2VkUGF0aCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogUmVwbGFjZXMgc3BhY2VzIHdpdGggdW5kZXJzY29yZXMgYW5kIHJlbW92ZXMgdW5zdXBwb3J0ZWQgY2hhcmFjdGVycyBmcm9tXG5cdCAqIG5vZGUgbmFtZXMsIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5IHdpdGggcGFyc2VUcmFja05hbWUoKS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTm9kZSBuYW1lIHRvIGJlIHNhbml0aXplZC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0c3RhdGljIHNhbml0aXplTm9kZU5hbWUoIG5hbWUgKSB7XG5cblx0XHRyZXR1cm4gbmFtZS5yZXBsYWNlKCAvXFxzL2csICdfJyApLnJlcGxhY2UoIF9yZXNlcnZlZFJlLCAnJyApO1xuXG5cdH1cblxuXHRzdGF0aWMgcGFyc2VUcmFja05hbWUoIHRyYWNrTmFtZSApIHtcblxuXHRcdGNvbnN0IG1hdGNoZXMgPSBfdHJhY2tSZS5leGVjKCB0cmFja05hbWUgKTtcblxuXHRcdGlmICggbWF0Y2hlcyA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnUHJvcGVydHlCaW5kaW5nOiBDYW5ub3QgcGFyc2UgdHJhY2tOYW1lOiAnICsgdHJhY2tOYW1lICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCByZXN1bHRzID0ge1xuXHRcdFx0Ly8gZGlyZWN0b3J5TmFtZTogbWF0Y2hlc1sgMSBdLCAvLyAodHNjaHcpIGN1cnJlbnRseSB1bnVzZWRcblx0XHRcdG5vZGVOYW1lOiBtYXRjaGVzWyAyIF0sXG5cdFx0XHRvYmplY3ROYW1lOiBtYXRjaGVzWyAzIF0sXG5cdFx0XHRvYmplY3RJbmRleDogbWF0Y2hlc1sgNCBdLFxuXHRcdFx0cHJvcGVydHlOYW1lOiBtYXRjaGVzWyA1IF0sIC8vIHJlcXVpcmVkXG5cdFx0XHRwcm9wZXJ0eUluZGV4OiBtYXRjaGVzWyA2IF1cblx0XHR9O1xuXG5cdFx0Y29uc3QgbGFzdERvdCA9IHJlc3VsdHMubm9kZU5hbWUgJiYgcmVzdWx0cy5ub2RlTmFtZS5sYXN0SW5kZXhPZiggJy4nICk7XG5cblx0XHRpZiAoIGxhc3REb3QgIT09IHVuZGVmaW5lZCAmJiBsYXN0RG90ICE9PSAtIDEgKSB7XG5cblx0XHRcdGNvbnN0IG9iamVjdE5hbWUgPSByZXN1bHRzLm5vZGVOYW1lLnN1YnN0cmluZyggbGFzdERvdCArIDEgKTtcblxuXHRcdFx0Ly8gT2JqZWN0IG5hbWVzIG11c3QgYmUgY2hlY2tlZCBhZ2FpbnN0IGFuIGFsbG93bGlzdC4gT3RoZXJ3aXNlLCB0aGVyZVxuXHRcdFx0Ly8gaXMgbm8gd2F5IHRvIHBhcnNlICdmb28uYmFyLmJheic6ICdiYXonIG11c3QgYmUgYSBwcm9wZXJ0eSwgYnV0XG5cdFx0XHQvLyAnYmFyJyBjb3VsZCBiZSB0aGUgb2JqZWN0TmFtZSwgb3IgcGFydCBvZiBhIG5vZGVOYW1lICh3aGljaCBjYW5cblx0XHRcdC8vIGluY2x1ZGUgJy4nIGNoYXJhY3RlcnMpLlxuXHRcdFx0aWYgKCBfc3VwcG9ydGVkT2JqZWN0TmFtZXMuaW5kZXhPZiggb2JqZWN0TmFtZSApICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0cmVzdWx0cy5ub2RlTmFtZSA9IHJlc3VsdHMubm9kZU5hbWUuc3Vic3RyaW5nKCAwLCBsYXN0RG90ICk7XG5cdFx0XHRcdHJlc3VsdHMub2JqZWN0TmFtZSA9IG9iamVjdE5hbWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggcmVzdWx0cy5wcm9wZXJ0eU5hbWUgPT09IG51bGwgfHwgcmVzdWx0cy5wcm9wZXJ0eU5hbWUubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdQcm9wZXJ0eUJpbmRpbmc6IGNhbiBub3QgcGFyc2UgcHJvcGVydHlOYW1lIGZyb20gdHJhY2tOYW1lOiAnICsgdHJhY2tOYW1lICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHR9XG5cblx0c3RhdGljIGZpbmROb2RlKCByb290LCBub2RlTmFtZSApIHtcblxuXHRcdGlmICggbm9kZU5hbWUgPT09IHVuZGVmaW5lZCB8fCBub2RlTmFtZSA9PT0gJycgfHwgbm9kZU5hbWUgPT09ICcuJyB8fCBub2RlTmFtZSA9PT0gLSAxIHx8IG5vZGVOYW1lID09PSByb290Lm5hbWUgfHwgbm9kZU5hbWUgPT09IHJvb3QudXVpZCApIHtcblxuXHRcdFx0cmV0dXJuIHJvb3Q7XG5cblx0XHR9XG5cblx0XHQvLyBzZWFyY2ggaW50byBza2VsZXRvbiBib25lcy5cblx0XHRpZiAoIHJvb3Quc2tlbGV0b24gKSB7XG5cblx0XHRcdGNvbnN0IGJvbmUgPSByb290LnNrZWxldG9uLmdldEJvbmVCeU5hbWUoIG5vZGVOYW1lICk7XG5cblx0XHRcdGlmICggYm9uZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiBib25lO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBzZWFyY2ggaW50byBub2RlIHN1YnRyZWUuXG5cdFx0aWYgKCByb290LmNoaWxkcmVuICkge1xuXG5cdFx0XHRjb25zdCBzZWFyY2hOb2RlU3VidHJlZSA9IGZ1bmN0aW9uICggY2hpbGRyZW4gKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgY2hpbGROb2RlID0gY2hpbGRyZW5bIGkgXTtcblxuXHRcdFx0XHRcdGlmICggY2hpbGROb2RlLm5hbWUgPT09IG5vZGVOYW1lIHx8IGNoaWxkTm9kZS51dWlkID09PSBub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGNoaWxkTm9kZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IHJlc3VsdCA9IHNlYXJjaE5vZGVTdWJ0cmVlKCBjaGlsZE5vZGUuY2hpbGRyZW4gKTtcblxuXHRcdFx0XHRcdGlmICggcmVzdWx0ICkgcmV0dXJuIHJlc3VsdDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IHN1YlRyZWVOb2RlID0gc2VhcmNoTm9kZVN1YnRyZWUoIHJvb3QuY2hpbGRyZW4gKTtcblxuXHRcdFx0aWYgKCBzdWJUcmVlTm9kZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gc3ViVHJlZU5vZGU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH1cblxuXHQvLyB0aGVzZSBhcmUgdXNlZCB0byBcImJpbmRcIiBhIG5vbmV4aXN0ZW50IHByb3BlcnR5XG5cdF9nZXRWYWx1ZV91bmF2YWlsYWJsZSgpIHt9XG5cdF9zZXRWYWx1ZV91bmF2YWlsYWJsZSgpIHt9XG5cblx0Ly8gR2V0dGVyc1xuXG5cdF9nZXRWYWx1ZV9kaXJlY3QoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0YnVmZmVyWyBvZmZzZXQgXSA9IHRoaXMudGFyZ2V0T2JqZWN0WyB0aGlzLnByb3BlcnR5TmFtZSBdO1xuXG5cdH1cblxuXHRfZ2V0VmFsdWVfYXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0Y29uc3Qgc291cmNlID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gc291cmNlLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0YnVmZmVyWyBvZmZzZXQgKysgXSA9IHNvdXJjZVsgaSBdO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRfZ2V0VmFsdWVfYXJyYXlFbGVtZW50KCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdGJ1ZmZlclsgb2Zmc2V0IF0gPSB0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdO1xuXG5cdH1cblxuXHRfZ2V0VmFsdWVfdG9BcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkudG9BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcblxuXHR9XG5cblx0Ly8gRGlyZWN0XG5cblx0X3NldFZhbHVlX2RpcmVjdCggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLnRhcmdldE9iamVjdFsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XG5cblx0fVxuXG5cdF9zZXRWYWx1ZV9kaXJlY3Rfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy50YXJnZXRPYmplY3RbIHRoaXMucHJvcGVydHlOYW1lIF0gPSBidWZmZXJbIG9mZnNldCBdO1xuXHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0X3NldFZhbHVlX2RpcmVjdF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdHRoaXMudGFyZ2V0T2JqZWN0WyB0aGlzLnByb3BlcnR5TmFtZSBdID0gYnVmZmVyWyBvZmZzZXQgXTtcblx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0Ly8gRW50aXJlQXJyYXlcblxuXHRfc2V0VmFsdWVfYXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0Y29uc3QgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGRlc3QubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRfc2V0VmFsdWVfYXJyYXlfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0Y29uc3QgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGRlc3QubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxuXHRfc2V0VmFsdWVfYXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHRjb25zdCBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGRlc3RbIGkgXSA9IGJ1ZmZlclsgb2Zmc2V0ICsrIF07XG5cblx0XHR9XG5cblx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0Ly8gQXJyYXlFbGVtZW50XG5cblx0X3NldFZhbHVlX2FycmF5RWxlbWVudCggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdID0gYnVmZmVyWyBvZmZzZXQgXTtcblxuXHR9XG5cblx0X3NldFZhbHVlX2FycmF5RWxlbWVudF9zZXROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdID0gYnVmZmVyWyBvZmZzZXQgXTtcblx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG5cdF9zZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdID0gYnVmZmVyWyBvZmZzZXQgXTtcblx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0Ly8gSGFzVG9Gcm9tQXJyYXlcblxuXHRfc2V0VmFsdWVfZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XG5cblx0fVxuXG5cdF9zZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcblx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG5cdF9zZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApO1xuXHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxuXHRfZ2V0VmFsdWVfdW5ib3VuZCggdGFyZ2V0QXJyYXksIG9mZnNldCApIHtcblxuXHRcdHRoaXMuYmluZCgpO1xuXHRcdHRoaXMuZ2V0VmFsdWUoIHRhcmdldEFycmF5LCBvZmZzZXQgKTtcblxuXHR9XG5cblx0X3NldFZhbHVlX3VuYm91bmQoIHNvdXJjZUFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLmJpbmQoKTtcblx0XHR0aGlzLnNldFZhbHVlKCBzb3VyY2VBcnJheSwgb2Zmc2V0ICk7XG5cblx0fVxuXG5cdC8vIGNyZWF0ZSBnZXR0ZXIgLyBzZXR0ZXIgcGFpciBmb3IgYSBwcm9wZXJ0eSBpbiB0aGUgc2NlbmUgZ3JhcGhcblx0YmluZCgpIHtcblxuXHRcdGxldCB0YXJnZXRPYmplY3QgPSB0aGlzLm5vZGU7XG5cdFx0Y29uc3QgcGFyc2VkUGF0aCA9IHRoaXMucGFyc2VkUGF0aDtcblxuXHRcdGNvbnN0IG9iamVjdE5hbWUgPSBwYXJzZWRQYXRoLm9iamVjdE5hbWU7XG5cdFx0Y29uc3QgcHJvcGVydHlOYW1lID0gcGFyc2VkUGF0aC5wcm9wZXJ0eU5hbWU7XG5cdFx0bGV0IHByb3BlcnR5SW5kZXggPSBwYXJzZWRQYXRoLnByb3BlcnR5SW5kZXg7XG5cblx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0ICkge1xuXG5cdFx0XHR0YXJnZXRPYmplY3QgPSBQcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUoIHRoaXMucm9vdE5vZGUsIHBhcnNlZFBhdGgubm9kZU5hbWUgKTtcblxuXHRcdFx0dGhpcy5ub2RlID0gdGFyZ2V0T2JqZWN0O1xuXG5cdFx0fVxuXG5cdFx0Ly8gc2V0IGZhaWwgc3RhdGUgc28gd2UgY2FuIGp1c3QgJ3JldHVybicgb24gZXJyb3Jcblx0XHR0aGlzLmdldFZhbHVlID0gdGhpcy5fZ2V0VmFsdWVfdW5hdmFpbGFibGU7XG5cdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuX3NldFZhbHVlX3VuYXZhaWxhYmxlO1xuXG5cdFx0Ly8gZW5zdXJlIHRoZXJlIGlzIGEgdmFsdWUgbm9kZVxuXHRcdGlmICggISB0YXJnZXRPYmplY3QgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogTm8gdGFyZ2V0IG5vZGUgZm91bmQgZm9yIHRyYWNrOiAnICsgdGhpcy5wYXRoICsgJy4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIG9iamVjdE5hbWUgKSB7XG5cblx0XHRcdGxldCBvYmplY3RJbmRleCA9IHBhcnNlZFBhdGgub2JqZWN0SW5kZXg7XG5cblx0XHRcdC8vIHNwZWNpYWwgY2FzZXMgd2VyZSB3ZSBuZWVkIHRvIHJlYWNoIGRlZXBlciBpbnRvIHRoZSBoaWVyYXJjaHkgdG8gZ2V0IHRoZSBmYWNlIG1hdGVyaWFscy4uLi5cblx0XHRcdHN3aXRjaCAoIG9iamVjdE5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnbWF0ZXJpYWxzJzpcblxuXHRcdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QubWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtYXRlcmlhbCBhcyBub2RlIGRvZXMgbm90IGhhdmUgYSBtYXRlcmlhbC4nLCB0aGlzICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFscyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsLm1hdGVyaWFscyBhcyBub2RlLm1hdGVyaWFsIGRvZXMgbm90IGhhdmUgYSBtYXRlcmlhbHMgYXJyYXkuJywgdGhpcyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFscztcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2JvbmVzJzpcblxuXHRcdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3Quc2tlbGV0b24gKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBib25lcyBhcyBub2RlIGRvZXMgbm90IGhhdmUgYSBza2VsZXRvbi4nLCB0aGlzICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBwb3RlbnRpYWwgZnV0dXJlIG9wdGltaXphdGlvbjogc2tpcCB0aGlzIGlmIHByb3BlcnR5SW5kZXggaXMgYWxyZWFkeSBhbiBpbnRlZ2VyXG5cdFx0XHRcdFx0Ly8gYW5kIGNvbnZlcnQgdGhlIGludGVnZXIgc3RyaW5nIHRvIGEgdHJ1ZSBpbnRlZ2VyLlxuXG5cdFx0XHRcdFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0LnNrZWxldG9uLmJvbmVzO1xuXG5cdFx0XHRcdFx0Ly8gc3VwcG9ydCByZXNvbHZpbmcgbW9ycGhUYXJnZXQgbmFtZXMgaW50byBpbmRpY2VzLlxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRhcmdldE9iamVjdC5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0WyBpIF0ubmFtZSA9PT0gb2JqZWN0SW5kZXggKSB7XG5cblx0XHRcdFx0XHRcdFx0b2JqZWN0SW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbWFwJzpcblxuXHRcdFx0XHRcdGlmICggJ21hcCcgaW4gdGFyZ2V0T2JqZWN0ICkge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3QubWFwO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwgYXMgbm9kZSBkb2VzIG5vdCBoYXZlIGEgbWF0ZXJpYWwuJywgdGhpcyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXAgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtYXRlcmlhbC5tYXAgYXMgbm9kZS5tYXRlcmlhbCBkb2VzIG5vdCBoYXZlIGEgbWFwLicsIHRoaXMgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXA7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0WyBvYmplY3ROYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG9iamVjdE5hbWUgb2Ygbm9kZSB1bmRlZmluZWQuJywgdGhpcyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0WyBvYmplY3ROYW1lIF07XG5cblx0XHRcdH1cblxuXG5cdFx0XHRpZiAoIG9iamVjdEluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCB0YXJnZXRPYmplY3RbIG9iamVjdEluZGV4IF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IFRyeWluZyB0byBiaW5kIHRvIG9iamVjdEluZGV4IG9mIG9iamVjdE5hbWUsIGJ1dCBpcyB1bmRlZmluZWQuJywgdGhpcywgdGFyZ2V0T2JqZWN0ICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3RbIG9iamVjdEluZGV4IF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIHJlc29sdmUgcHJvcGVydHlcblx0XHRjb25zdCBub2RlUHJvcGVydHkgPSB0YXJnZXRPYmplY3RbIHByb3BlcnR5TmFtZSBdO1xuXG5cdFx0aWYgKCBub2RlUHJvcGVydHkgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3Qgbm9kZU5hbWUgPSBwYXJzZWRQYXRoLm5vZGVOYW1lO1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBUcnlpbmcgdG8gdXBkYXRlIHByb3BlcnR5IGZvciB0cmFjazogJyArIG5vZGVOYW1lICtcblx0XHRcdFx0Jy4nICsgcHJvcGVydHlOYW1lICsgJyBidXQgaXQgd2FzblxcJ3QgZm91bmQuJywgdGFyZ2V0T2JqZWN0ICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHQvLyBkZXRlcm1pbmUgdmVyc2lvbmluZyBzY2hlbWVcblx0XHRsZXQgdmVyc2lvbmluZyA9IHRoaXMuVmVyc2lvbmluZy5Ob25lO1xuXG5cdFx0dGhpcy50YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3Q7XG5cblx0XHRpZiAoIHRhcmdldE9iamVjdC5pc01hdGVyaWFsID09PSB0cnVlICkge1xuXG5cdFx0XHR2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk5lZWRzVXBkYXRlO1xuXG5cdFx0fSBlbHNlIGlmICggdGFyZ2V0T2JqZWN0LmlzT2JqZWN0M0QgPT09IHRydWUgKSB7XG5cblx0XHRcdHZlcnNpb25pbmcgPSB0aGlzLlZlcnNpb25pbmcuTWF0cml4V29ybGROZWVkc1VwZGF0ZTtcblxuXHRcdH1cblxuXHRcdC8vIGRldGVybWluZSBob3cgdGhlIHByb3BlcnR5IGdldHMgYm91bmRcblx0XHRsZXQgYmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkRpcmVjdDtcblxuXHRcdGlmICggcHJvcGVydHlJbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBhY2Nlc3MgYSBzdWIgZWxlbWVudCBvZiB0aGUgcHJvcGVydHkgYXJyYXkgKG9ubHkgcHJpbWl0aXZlcyBhcmUgc3VwcG9ydGVkIHJpZ2h0IG5vdylcblxuXHRcdFx0aWYgKCBwcm9wZXJ0eU5hbWUgPT09ICdtb3JwaFRhcmdldEluZmx1ZW5jZXMnICkge1xuXG5cdFx0XHRcdC8vIHBvdGVudGlhbCBvcHRpbWl6YXRpb24sIHNraXAgdGhpcyBpZiBwcm9wZXJ0eUluZGV4IGlzIGFscmVhZHkgYW4gaW50ZWdlciwgYW5kIGNvbnZlcnQgdGhlIGludGVnZXIgc3RyaW5nIHRvIGEgdHJ1ZSBpbnRlZ2VyLlxuXG5cdFx0XHRcdC8vIHN1cHBvcnQgcmVzb2x2aW5nIG1vcnBoVGFyZ2V0IG5hbWVzIGludG8gaW5kaWNlcy5cblx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5nZW9tZXRyeSApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXVzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeS4nLCB0aGlzICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXVzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuJywgdGhpcyApO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0YXJnZXRPYmplY3QubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBwcm9wZXJ0eUluZGV4IF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHByb3BlcnR5SW5kZXggPSB0YXJnZXRPYmplY3QubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBwcm9wZXJ0eUluZGV4IF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5BcnJheUVsZW1lbnQ7XG5cblx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcblx0XHRcdHRoaXMucHJvcGVydHlJbmRleCA9IHByb3BlcnR5SW5kZXg7XG5cblx0XHR9IGVsc2UgaWYgKCBub2RlUHJvcGVydHkuZnJvbUFycmF5ICE9PSB1bmRlZmluZWQgJiYgbm9kZVByb3BlcnR5LnRvQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gbXVzdCB1c2UgY29weSBmb3IgT2JqZWN0M0QuRXVsZXIvUXVhdGVybmlvblxuXG5cdFx0XHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuSGFzRnJvbVRvQXJyYXk7XG5cblx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcblxuXHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIG5vZGVQcm9wZXJ0eSApICkge1xuXG5cdFx0XHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuRW50aXJlQXJyYXk7XG5cblx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuXG5cdFx0fVxuXG5cdFx0Ly8gc2VsZWN0IGdldHRlciAvIHNldHRlclxuXHRcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLkdldHRlckJ5QmluZGluZ1R5cGVbIGJpbmRpbmdUeXBlIF07XG5cdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuU2V0dGVyQnlCaW5kaW5nVHlwZUFuZFZlcnNpb25pbmdbIGJpbmRpbmdUeXBlIF1bIHZlcnNpb25pbmcgXTtcblxuXHR9XG5cblx0dW5iaW5kKCkge1xuXG5cdFx0dGhpcy5ub2RlID0gbnVsbDtcblxuXHRcdC8vIGJhY2sgdG8gdGhlIHByb3RvdHlwZSB2ZXJzaW9uIG9mIGdldFZhbHVlIC8gc2V0VmFsdWVcblx0XHQvLyBub3RlOiBhdm9pZGluZyB0byBtdXRhdGUgdGhlIHNoYXBlIG9mICd0aGlzJyB2aWEgJ2RlbGV0ZSdcblx0XHR0aGlzLmdldFZhbHVlID0gdGhpcy5fZ2V0VmFsdWVfdW5ib3VuZDtcblx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5fc2V0VmFsdWVfdW5ib3VuZDtcblxuXHR9XG5cbn1cblxuUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZSA9IENvbXBvc2l0ZTtcblxuUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5CaW5kaW5nVHlwZSA9IHtcblx0RGlyZWN0OiAwLFxuXHRFbnRpcmVBcnJheTogMSxcblx0QXJyYXlFbGVtZW50OiAyLFxuXHRIYXNGcm9tVG9BcnJheTogM1xufTtcblxuUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5WZXJzaW9uaW5nID0ge1xuXHROb25lOiAwLFxuXHROZWVkc1VwZGF0ZTogMSxcblx0TWF0cml4V29ybGROZWVkc1VwZGF0ZTogMlxufTtcblxuUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5HZXR0ZXJCeUJpbmRpbmdUeXBlID0gW1xuXG5cdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX2dldFZhbHVlX2RpcmVjdCxcblx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fZ2V0VmFsdWVfYXJyYXksXG5cdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX2dldFZhbHVlX2FycmF5RWxlbWVudCxcblx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fZ2V0VmFsdWVfdG9BcnJheSxcblxuXTtcblxuUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5TZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZyA9IFtcblxuXHRbXG5cdFx0Ly8gRGlyZWN0XG5cdFx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfZGlyZWN0LFxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2RpcmVjdF9zZXROZWVkc1VwZGF0ZSxcblx0XHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9kaXJlY3Rfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSxcblxuXHRdLCBbXG5cblx0XHQvLyBFbnRpcmVBcnJheVxuXG5cdFx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXksXG5cdFx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXlfc2V0TmVlZHNVcGRhdGUsXG5cdFx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSxcblxuXHRdLCBbXG5cblx0XHQvLyBBcnJheUVsZW1lbnRcblx0XHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9hcnJheUVsZW1lbnQsXG5cdFx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXlFbGVtZW50X3NldE5lZWRzVXBkYXRlLFxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5RWxlbWVudF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlLFxuXG5cdF0sIFtcblxuXHRcdC8vIEhhc1RvRnJvbUFycmF5XG5cdFx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfZnJvbUFycmF5LFxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2Zyb21BcnJheV9zZXROZWVkc1VwZGF0ZSxcblx0XHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSxcblxuXHRdXG5cbl07XG5cbi8qKlxuICpcbiAqIEEgZ3JvdXAgb2Ygb2JqZWN0cyB0aGF0IHJlY2VpdmVzIGEgc2hhcmVkIGFuaW1hdGlvbiBzdGF0ZS5cbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgLSBBZGQgb2JqZWN0cyB5b3Ugd291bGQgb3RoZXJ3aXNlIHBhc3MgYXMgJ3Jvb3QnIHRvIHRoZVxuICogICAgY29uc3RydWN0b3Igb3IgdGhlIC5jbGlwQWN0aW9uIG1ldGhvZCBvZiBBbmltYXRpb25NaXhlci5cbiAqXG4gKiAgLSBJbnN0ZWFkIHBhc3MgdGhpcyBvYmplY3QgYXMgJ3Jvb3QnLlxuICpcbiAqICAtIFlvdSBjYW4gYWxzbyBhZGQgYW5kIHJlbW92ZSBvYmplY3RzIGxhdGVyIHdoZW4gdGhlIG1peGVyXG4gKiAgICBpcyBydW5uaW5nLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAgT2JqZWN0cyBvZiB0aGlzIGNsYXNzIGFwcGVhciBhcyBvbmUgb2JqZWN0IHRvIHRoZSBtaXhlcixcbiAqICAgIHNvIGNhY2hlIGNvbnRyb2wgb2YgdGhlIGluZGl2aWR1YWwgb2JqZWN0cyBtdXN0IGJlIGRvbmVcbiAqICAgIG9uIHRoZSBncm91cC5cbiAqXG4gKiBMaW1pdGF0aW9uOlxuICpcbiAqICAtIFRoZSBhbmltYXRlZCBwcm9wZXJ0aWVzIG11c3QgYmUgY29tcGF0aWJsZSBhbW9uZyB0aGVcbiAqICAgIGFsbCBvYmplY3RzIGluIHRoZSBncm91cC5cbiAqXG4gKiAgLSBBIHNpbmdsZSBwcm9wZXJ0eSBjYW4gZWl0aGVyIGJlIGNvbnRyb2xsZWQgdGhyb3VnaCBhXG4gKiAgICB0YXJnZXQgZ3JvdXAgb3IgZGlyZWN0bHksIGJ1dCBub3QgYm90aC5cbiAqL1xuXG5jbGFzcyBBbmltYXRpb25PYmplY3RHcm91cCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHR0aGlzLmlzQW5pbWF0aW9uT2JqZWN0R3JvdXAgPSB0cnVlO1xuXG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHQvLyBjYWNoZWQgb2JqZWN0cyBmb2xsb3dlZCBieSB0aGUgYWN0aXZlIG9uZXNcblx0XHR0aGlzLl9vYmplY3RzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG5cdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSAwOyAvLyB0aHJlc2hvbGRcblx0XHQvLyBub3RlOiByZWFkIGJ5IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGVcblxuXHRcdGNvbnN0IGluZGljZXMgPSB7fTtcblx0XHR0aGlzLl9pbmRpY2VzQnlVVUlEID0gaW5kaWNlczsgLy8gZm9yIGJvb2trZWVwaW5nXG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRpbmRpY2VzWyBhcmd1bWVudHNbIGkgXS51dWlkIF0gPSBpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fcGF0aHMgPSBbXTsgLy8gaW5zaWRlOiBzdHJpbmdcblx0XHR0aGlzLl9wYXJzZWRQYXRocyA9IFtdOyAvLyBpbnNpZGU6IHsgd2UgZG9uJ3QgY2FyZSwgaGVyZSB9XG5cdFx0dGhpcy5fYmluZGluZ3MgPSBbXTsgLy8gaW5zaWRlOiBBcnJheTwgUHJvcGVydHlCaW5kaW5nID5cblx0XHR0aGlzLl9iaW5kaW5nc0luZGljZXNCeVBhdGggPSB7fTsgLy8gaW5zaWRlOiBpbmRpY2VzIGluIHRoZXNlIGFycmF5c1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dGhpcy5zdGF0cyA9IHtcblxuXHRcdFx0b2JqZWN0czoge1xuXHRcdFx0XHRnZXQgdG90YWwoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX29iamVjdHMubGVuZ3RoO1xuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGdldCBpblVzZSgpIHtcblxuXHRcdFx0XHRcdHJldHVybiB0aGlzLnRvdGFsIC0gc2NvcGUubkNhY2hlZE9iamVjdHNfO1xuXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRnZXQgYmluZGluZ3NQZXJPYmplY3QoKSB7XG5cblx0XHRcdFx0cmV0dXJuIHNjb3BlLl9iaW5kaW5ncy5sZW5ndGg7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fVxuXG5cdGFkZCgpIHtcblxuXHRcdGNvbnN0IG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuXHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXG5cdFx0XHRwYXRocyA9IHRoaXMuX3BhdGhzLFxuXHRcdFx0cGFyc2VkUGF0aHMgPSB0aGlzLl9wYXJzZWRQYXRocyxcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XG5cblx0XHRsZXQga25vd25PYmplY3QgPSB1bmRlZmluZWQsXG5cdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxuXHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxuXHRcdFx0XHR1dWlkID0gb2JqZWN0LnV1aWQ7XG5cdFx0XHRsZXQgaW5kZXggPSBpbmRpY2VzQnlVVUlEWyB1dWlkIF07XG5cblx0XHRcdGlmICggaW5kZXggPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyB1bmtub3duIG9iamVjdCAtPiBhZGQgaXQgdG8gdGhlIEFDVElWRSByZWdpb25cblxuXHRcdFx0XHRpbmRleCA9IG5PYmplY3RzICsrO1xuXHRcdFx0XHRpbmRpY2VzQnlVVUlEWyB1dWlkIF0gPSBpbmRleDtcblx0XHRcdFx0b2JqZWN0cy5wdXNoKCBvYmplY3QgKTtcblxuXHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xuXG5cdFx0XHRcdFx0YmluZGluZ3NbIGogXS5wdXNoKCBuZXcgUHJvcGVydHlCaW5kaW5nKCBvYmplY3QsIHBhdGhzWyBqIF0sIHBhcnNlZFBhdGhzWyBqIF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggaW5kZXggPCBuQ2FjaGVkT2JqZWN0cyApIHtcblxuXHRcdFx0XHRrbm93bk9iamVjdCA9IG9iamVjdHNbIGluZGV4IF07XG5cblx0XHRcdFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgdG8gdGhlIEFDVElWRSByZWdpb25cblxuXHRcdFx0XHRjb25zdCBmaXJzdEFjdGl2ZUluZGV4ID0gLS0gbkNhY2hlZE9iamVjdHMsXG5cdFx0XHRcdFx0bGFzdENhY2hlZE9iamVjdCA9IG9iamVjdHNbIGZpcnN0QWN0aXZlSW5kZXggXTtcblxuXHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBsYXN0Q2FjaGVkT2JqZWN0LnV1aWQgXSA9IGluZGV4O1xuXHRcdFx0XHRvYmplY3RzWyBpbmRleCBdID0gbGFzdENhY2hlZE9iamVjdDtcblxuXHRcdFx0XHRpbmRpY2VzQnlVVUlEWyB1dWlkIF0gPSBmaXJzdEFjdGl2ZUluZGV4O1xuXHRcdFx0XHRvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBvYmplY3Q7XG5cblx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXG5cdFx0XHRcdFx0XHRsYXN0Q2FjaGVkID0gYmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF07XG5cblx0XHRcdFx0XHRsZXQgYmluZGluZyA9IGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXTtcblxuXHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGxhc3RDYWNoZWQ7XG5cblx0XHRcdFx0XHRpZiAoIGJpbmRpbmcgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gc2luY2Ugd2UgZG8gbm90IGJvdGhlciB0byBjcmVhdGUgbmV3IGJpbmRpbmdzXG5cdFx0XHRcdFx0XHQvLyBmb3Igb2JqZWN0cyB0aGF0IGFyZSBjYWNoZWQsIHRoZSBiaW5kaW5nIG1heVxuXHRcdFx0XHRcdFx0Ly8gb3IgbWF5IG5vdCBleGlzdFxuXG5cdFx0XHRcdFx0XHRiaW5kaW5nID0gbmV3IFByb3BlcnR5QmluZGluZyggb2JqZWN0LCBwYXRoc1sgaiBdLCBwYXJzZWRQYXRoc1sgaiBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSA9IGJpbmRpbmc7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3RzWyBpbmRleCBdICE9PSBrbm93bk9iamVjdCApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQW5pbWF0aW9uT2JqZWN0R3JvdXA6IERpZmZlcmVudCBvYmplY3RzIHdpdGggdGhlIHNhbWUgVVVJRCAnICtcblx0XHRcdFx0XHQnZGV0ZWN0ZWQuIENsZWFuIHRoZSBjYWNoZXMgb3IgcmVjcmVhdGUgeW91ciBpbmZyYXN0cnVjdHVyZSB3aGVuIHJlbG9hZGluZyBzY2VuZXMuJyApO1xuXG5cdFx0XHR9IC8vIGVsc2UgdGhlIG9iamVjdCBpcyBhbHJlYWR5IHdoZXJlIHdlIHdhbnQgaXQgdG8gYmVcblxuXHRcdH0gLy8gZm9yIGFyZ3VtZW50c1xuXG5cdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcblxuXHR9XG5cblx0cmVtb3ZlKCkge1xuXG5cdFx0Y29uc3Qgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG5cdFx0XHRpbmRpY2VzQnlVVUlEID0gdGhpcy5faW5kaWNlc0J5VVVJRCxcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XG5cblx0XHRsZXQgbkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxuXHRcdFx0XHR1dWlkID0gb2JqZWN0LnV1aWQsXG5cdFx0XHRcdGluZGV4ID0gaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaW5kZXggPj0gbkNhY2hlZE9iamVjdHMgKSB7XG5cblx0XHRcdFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgaW50byB0aGUgQ0FDSEVEIHJlZ2lvblxuXG5cdFx0XHRcdGNvbnN0IGxhc3RDYWNoZWRJbmRleCA9IG5DYWNoZWRPYmplY3RzICsrLFxuXHRcdFx0XHRcdGZpcnN0QWN0aXZlT2JqZWN0ID0gb2JqZWN0c1sgbGFzdENhY2hlZEluZGV4IF07XG5cblx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgZmlyc3RBY3RpdmVPYmplY3QudXVpZCBdID0gaW5kZXg7XG5cdFx0XHRcdG9iamVjdHNbIGluZGV4IF0gPSBmaXJzdEFjdGl2ZU9iamVjdDtcblxuXHRcdFx0XHRpbmRpY2VzQnlVVUlEWyB1dWlkIF0gPSBsYXN0Q2FjaGVkSW5kZXg7XG5cdFx0XHRcdG9iamVjdHNbIGxhc3RDYWNoZWRJbmRleCBdID0gb2JqZWN0O1xuXG5cdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XG5cblx0XHRcdFx0XHRjb25zdCBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1sgaiBdLFxuXHRcdFx0XHRcdFx0Zmlyc3RBY3RpdmUgPSBiaW5kaW5nc0ZvclBhdGhbIGxhc3RDYWNoZWRJbmRleCBdLFxuXHRcdFx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXTtcblxuXHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGZpcnN0QWN0aXZlO1xuXHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgbGFzdENhY2hlZEluZGV4IF0gPSBiaW5kaW5nO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSAvLyBmb3IgYXJndW1lbnRzXG5cblx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xuXG5cdH1cblxuXHQvLyByZW1vdmUgJiBmb3JnZXRcblx0dW5jYWNoZSgpIHtcblxuXHRcdGNvbnN0IG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuXHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXG5cdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0bkJpbmRpbmdzID0gYmluZGluZ3MubGVuZ3RoO1xuXG5cdFx0bGV0IG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sXG5cdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0Y29uc3Qgb2JqZWN0ID0gYXJndW1lbnRzWyBpIF0sXG5cdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcblx0XHRcdFx0aW5kZXggPSBpbmRpY2VzQnlVVUlEWyB1dWlkIF07XG5cblx0XHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRkZWxldGUgaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCBuQ2FjaGVkT2JqZWN0cyApIHtcblxuXHRcdFx0XHRcdC8vIG9iamVjdCBpcyBjYWNoZWQsIHNocmluayB0aGUgQ0FDSEVEIHJlZ2lvblxuXG5cdFx0XHRcdFx0Y29uc3QgZmlyc3RBY3RpdmVJbmRleCA9IC0tIG5DYWNoZWRPYmplY3RzLFxuXHRcdFx0XHRcdFx0bGFzdENhY2hlZE9iamVjdCA9IG9iamVjdHNbIGZpcnN0QWN0aXZlSW5kZXggXSxcblx0XHRcdFx0XHRcdGxhc3RJbmRleCA9IC0tIG5PYmplY3RzLFxuXHRcdFx0XHRcdFx0bGFzdE9iamVjdCA9IG9iamVjdHNbIGxhc3RJbmRleCBdO1xuXG5cdFx0XHRcdFx0Ly8gbGFzdCBjYWNoZWQgb2JqZWN0IHRha2VzIHRoaXMgb2JqZWN0J3MgcGxhY2Vcblx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBsYXN0Q2FjaGVkT2JqZWN0LnV1aWQgXSA9IGluZGV4O1xuXHRcdFx0XHRcdG9iamVjdHNbIGluZGV4IF0gPSBsYXN0Q2FjaGVkT2JqZWN0O1xuXG5cdFx0XHRcdFx0Ly8gbGFzdCBvYmplY3QgZ29lcyB0byB0aGUgYWN0aXZhdGVkIHNsb3QgYW5kIHBvcFxuXHRcdFx0XHRcdGluZGljZXNCeVVVSURbIGxhc3RPYmplY3QudXVpZCBdID0gZmlyc3RBY3RpdmVJbmRleDtcblx0XHRcdFx0XHRvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBsYXN0T2JqZWN0O1xuXHRcdFx0XHRcdG9iamVjdHMucG9wKCk7XG5cblx0XHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXG5cdFx0XHRcdFx0XHRcdGxhc3RDYWNoZWQgPSBiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSxcblx0XHRcdFx0XHRcdFx0bGFzdCA9IGJpbmRpbmdzRm9yUGF0aFsgbGFzdEluZGV4IF07XG5cblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGxhc3RDYWNoZWQ7XG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSA9IGxhc3Q7XG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGgucG9wKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIG9iamVjdCBpcyBhY3RpdmUsIGp1c3Qgc3dhcCB3aXRoIHRoZSBsYXN0IGFuZCBwb3BcblxuXHRcdFx0XHRcdGNvbnN0IGxhc3RJbmRleCA9IC0tIG5PYmplY3RzLFxuXHRcdFx0XHRcdFx0bGFzdE9iamVjdCA9IG9iamVjdHNbIGxhc3RJbmRleCBdO1xuXG5cdFx0XHRcdFx0aWYgKCBsYXN0SW5kZXggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBsYXN0T2JqZWN0LnV1aWQgXSA9IGluZGV4O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RPYmplY3Q7XG5cdFx0XHRcdFx0b2JqZWN0cy5wb3AoKTtcblxuXHRcdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXTtcblxuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gYmluZGluZ3NGb3JQYXRoWyBsYXN0SW5kZXggXTtcblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aC5wb3AoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IC8vIGNhY2hlZCBvciBhY3RpdmVcblxuXHRcdFx0fSAvLyBpZiBvYmplY3QgaXMga25vd25cblxuXHRcdH0gLy8gZm9yIGFyZ3VtZW50c1xuXG5cdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcblxuXHR9XG5cblx0Ly8gSW50ZXJuYWwgaW50ZXJmYWNlIHVzZWQgYnkgYmVmcmllbmRlZCBQcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlOlxuXG5cdHN1YnNjcmliZV8oIHBhdGgsIHBhcnNlZFBhdGggKSB7XG5cblx0XHQvLyByZXR1cm5zIGFuIGFycmF5IG9mIGJpbmRpbmdzIGZvciB0aGUgZ2l2ZW4gcGF0aCB0aGF0IGlzIGNoYW5nZWRcblx0XHQvLyBhY2NvcmRpbmcgdG8gdGhlIGNvbnRhaW5lZCBvYmplY3RzIGluIHRoZSBncm91cFxuXG5cdFx0Y29uc3QgaW5kaWNlc0J5UGF0aCA9IHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aDtcblx0XHRsZXQgaW5kZXggPSBpbmRpY2VzQnlQYXRoWyBwYXRoIF07XG5cdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcblxuXHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHJldHVybiBiaW5kaW5nc1sgaW5kZXggXTtcblxuXHRcdGNvbnN0IHBhdGhzID0gdGhpcy5fcGF0aHMsXG5cdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxuXHRcdFx0b2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG5cdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxuXHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcblx0XHRcdGJpbmRpbmdzRm9yUGF0aCA9IG5ldyBBcnJheSggbk9iamVjdHMgKTtcblxuXHRcdGluZGV4ID0gYmluZGluZ3MubGVuZ3RoO1xuXG5cdFx0aW5kaWNlc0J5UGF0aFsgcGF0aCBdID0gaW5kZXg7XG5cblx0XHRwYXRocy5wdXNoKCBwYXRoICk7XG5cdFx0cGFyc2VkUGF0aHMucHVzaCggcGFyc2VkUGF0aCApO1xuXHRcdGJpbmRpbmdzLnB1c2goIGJpbmRpbmdzRm9yUGF0aCApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSBuQ2FjaGVkT2JqZWN0cywgbiA9IG9iamVjdHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCBvYmplY3QgPSBvYmplY3RzWyBpIF07XG5cdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGkgXSA9IG5ldyBQcm9wZXJ0eUJpbmRpbmcoIG9iamVjdCwgcGF0aCwgcGFyc2VkUGF0aCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJpbmRpbmdzRm9yUGF0aDtcblxuXHR9XG5cblx0dW5zdWJzY3JpYmVfKCBwYXRoICkge1xuXG5cdFx0Ly8gdGVsbHMgdGhlIGdyb3VwIHRvIGZvcmdldCBhYm91dCBhIHByb3BlcnR5IHBhdGggYW5kIG5vIGxvbmdlclxuXHRcdC8vIHVwZGF0ZSB0aGUgYXJyYXkgcHJldmlvdXNseSBvYnRhaW5lZCB3aXRoICdzdWJzY3JpYmVfJ1xuXG5cdFx0Y29uc3QgaW5kaWNlc0J5UGF0aCA9IHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCxcblx0XHRcdGluZGV4ID0gaW5kaWNlc0J5UGF0aFsgcGF0aCBdO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBwYXRocyA9IHRoaXMuX3BhdGhzLFxuXHRcdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0XHRsYXN0QmluZGluZ3NJbmRleCA9IGJpbmRpbmdzLmxlbmd0aCAtIDEsXG5cdFx0XHRcdGxhc3RCaW5kaW5ncyA9IGJpbmRpbmdzWyBsYXN0QmluZGluZ3NJbmRleCBdLFxuXHRcdFx0XHRsYXN0QmluZGluZ3NQYXRoID0gcGF0aFsgbGFzdEJpbmRpbmdzSW5kZXggXTtcblxuXHRcdFx0aW5kaWNlc0J5UGF0aFsgbGFzdEJpbmRpbmdzUGF0aCBdID0gaW5kZXg7XG5cblx0XHRcdGJpbmRpbmdzWyBpbmRleCBdID0gbGFzdEJpbmRpbmdzO1xuXHRcdFx0YmluZGluZ3MucG9wKCk7XG5cblx0XHRcdHBhcnNlZFBhdGhzWyBpbmRleCBdID0gcGFyc2VkUGF0aHNbIGxhc3RCaW5kaW5nc0luZGV4IF07XG5cdFx0XHRwYXJzZWRQYXRocy5wb3AoKTtcblxuXHRcdFx0cGF0aHNbIGluZGV4IF0gPSBwYXRoc1sgbGFzdEJpbmRpbmdzSW5kZXggXTtcblx0XHRcdHBhdGhzLnBvcCgpO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5jbGFzcyBBbmltYXRpb25BY3Rpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCBtaXhlciwgY2xpcCwgbG9jYWxSb290ID0gbnVsbCwgYmxlbmRNb2RlID0gY2xpcC5ibGVuZE1vZGUgKSB7XG5cblx0XHR0aGlzLl9taXhlciA9IG1peGVyO1xuXHRcdHRoaXMuX2NsaXAgPSBjbGlwO1xuXHRcdHRoaXMuX2xvY2FsUm9vdCA9IGxvY2FsUm9vdDtcblx0XHR0aGlzLmJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcblxuXHRcdGNvbnN0IHRyYWNrcyA9IGNsaXAudHJhY2tzLFxuXHRcdFx0blRyYWNrcyA9IHRyYWNrcy5sZW5ndGgsXG5cdFx0XHRpbnRlcnBvbGFudHMgPSBuZXcgQXJyYXkoIG5UcmFja3MgKTtcblxuXHRcdGNvbnN0IGludGVycG9sYW50U2V0dGluZ3MgPSB7XG5cdFx0XHRlbmRpbmdTdGFydDogWmVyb0N1cnZhdHVyZUVuZGluZyxcblx0XHRcdGVuZGluZ0VuZDogWmVyb0N1cnZhdHVyZUVuZGluZ1xuXHRcdH07XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgIT09IG5UcmFja3M7ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IGludGVycG9sYW50ID0gdHJhY2tzWyBpIF0uY3JlYXRlSW50ZXJwb2xhbnQoIG51bGwgKTtcblx0XHRcdGludGVycG9sYW50c1sgaSBdID0gaW50ZXJwb2xhbnQ7XG5cdFx0XHRpbnRlcnBvbGFudC5zZXR0aW5ncyA9IGludGVycG9sYW50U2V0dGluZ3M7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9pbnRlcnBvbGFudFNldHRpbmdzID0gaW50ZXJwb2xhbnRTZXR0aW5ncztcblxuXHRcdHRoaXMuX2ludGVycG9sYW50cyA9IGludGVycG9sYW50czsgLy8gYm91bmQgYnkgdGhlIG1peGVyXG5cblx0XHQvLyBpbnNpZGU6IFByb3BlcnR5TWl4ZXIgKG1hbmFnZWQgYnkgdGhlIG1peGVyKVxuXHRcdHRoaXMuX3Byb3BlcnR5QmluZGluZ3MgPSBuZXcgQXJyYXkoIG5UcmFja3MgKTtcblxuXHRcdHRoaXMuX2NhY2hlSW5kZXggPSBudWxsOyAvLyBmb3IgdGhlIG1lbW9yeSBtYW5hZ2VyXG5cdFx0dGhpcy5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7IC8vIGZvciB0aGUgbWVtb3J5IG1hbmFnZXJcblxuXHRcdHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50ID0gbnVsbDtcblx0XHR0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9IG51bGw7XG5cblx0XHR0aGlzLmxvb3AgPSBMb29wUmVwZWF0O1xuXHRcdHRoaXMuX2xvb3BDb3VudCA9IC0gMTtcblxuXHRcdC8vIGdsb2JhbCBtaXhlciB0aW1lIHdoZW4gdGhlIGFjdGlvbiBpcyB0byBiZSBzdGFydGVkXG5cdFx0Ly8gaXQncyBzZXQgYmFjayB0byAnbnVsbCcgdXBvbiBzdGFydCBvZiB0aGUgYWN0aW9uXG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblxuXHRcdC8vIHNjYWxlZCBsb2NhbCB0aW1lIG9mIHRoZSBhY3Rpb25cblx0XHQvLyBnZXRzIGNsYW1wZWQgb3Igd3JhcHBlZCB0byAwLi5jbGlwLmR1cmF0aW9uIGFjY29yZGluZyB0byBsb29wXG5cdFx0dGhpcy50aW1lID0gMDtcblxuXHRcdHRoaXMudGltZVNjYWxlID0gMTtcblx0XHR0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSAxO1xuXG5cdFx0dGhpcy53ZWlnaHQgPSAxO1xuXHRcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IDE7XG5cblx0XHR0aGlzLnJlcGV0aXRpb25zID0gSW5maW5pdHk7IC8vIG5vLiBvZiByZXBldGl0aW9ucyB3aGVuIGxvb3BpbmdcblxuXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7IC8vIHRydWUgLT4gemVybyBlZmZlY3RpdmUgdGltZSBzY2FsZVxuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7IC8vIGZhbHNlIC0+IHplcm8gZWZmZWN0aXZlIHdlaWdodFxuXG5cdFx0dGhpcy5jbGFtcFdoZW5GaW5pc2hlZCA9IGZhbHNlOy8vIGtlZXAgZmVlZGluZyB0aGUgbGFzdCBmcmFtZT9cblxuXHRcdHRoaXMuemVyb1Nsb3BlQXRTdGFydCA9IHRydWU7Ly8gZm9yIHNtb290aCBpbnRlcnBvbGF0aW9uIHcvbyBzZXBhcmF0ZVxuXHRcdHRoaXMuemVyb1Nsb3BlQXRFbmQgPSB0cnVlOy8vIGNsaXBzIGZvciBzdGFydCwgbG9vcCBhbmQgZW5kXG5cblx0fVxuXG5cdC8vIFN0YXRlICYgU2NoZWR1bGluZ1xuXG5cdHBsYXkoKSB7XG5cblx0XHR0aGlzLl9taXhlci5fYWN0aXZhdGVBY3Rpb24oIHRoaXMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdG9wKCkge1xuXG5cdFx0dGhpcy5fbWl4ZXIuX2RlYWN0aXZhdGVBY3Rpb24oIHRoaXMgKTtcblxuXHRcdHJldHVybiB0aGlzLnJlc2V0KCk7XG5cblx0fVxuXG5cdHJlc2V0KCkge1xuXG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcblx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG5cdFx0dGhpcy50aW1lID0gMDsgLy8gcmVzdGFydCBjbGlwXG5cdFx0dGhpcy5fbG9vcENvdW50ID0gLSAxOy8vIGZvcmdldCBwcmV2aW91cyBsb29wc1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7Ly8gZm9yZ2V0IHNjaGVkdWxpbmdcblxuXHRcdHJldHVybiB0aGlzLnN0b3BGYWRpbmcoKS5zdG9wV2FycGluZygpO1xuXG5cdH1cblxuXHRpc1J1bm5pbmcoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5lbmFibGVkICYmICEgdGhpcy5wYXVzZWQgJiYgdGhpcy50aW1lU2NhbGUgIT09IDAgJiZcblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9PT0gbnVsbCAmJiB0aGlzLl9taXhlci5faXNBY3RpdmVBY3Rpb24oIHRoaXMgKTtcblxuXHR9XG5cblx0Ly8gcmV0dXJuIHRydWUgd2hlbiBwbGF5IGhhcyBiZWVuIGNhbGxlZFxuXHRpc1NjaGVkdWxlZCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9taXhlci5faXNBY3RpdmVBY3Rpb24oIHRoaXMgKTtcblxuXHR9XG5cblx0c3RhcnRBdCggdGltZSApIHtcblxuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IHRpbWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0TG9vcCggbW9kZSwgcmVwZXRpdGlvbnMgKSB7XG5cblx0XHR0aGlzLmxvb3AgPSBtb2RlO1xuXHRcdHRoaXMucmVwZXRpdGlvbnMgPSByZXBldGl0aW9ucztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvLyBXZWlnaHRcblxuXHQvLyBzZXQgdGhlIHdlaWdodCBzdG9wcGluZyBhbnkgc2NoZWR1bGVkIGZhZGluZ1xuXHQvLyBhbHRob3VnaCAuZW5hYmxlZCA9IGZhbHNlIHlpZWxkcyBhbiBlZmZlY3RpdmUgd2VpZ2h0IG9mIHplcm8sIHRoaXNcblx0Ly8gbWV0aG9kIGRvZXMgKm5vdCogY2hhbmdlIC5lbmFibGVkLCBiZWNhdXNlIGl0IHdvdWxkIGJlIGNvbmZ1c2luZ1xuXHRzZXRFZmZlY3RpdmVXZWlnaHQoIHdlaWdodCApIHtcblxuXHRcdHRoaXMud2VpZ2h0ID0gd2VpZ2h0O1xuXG5cdFx0Ly8gbm90ZTogc2FtZSBsb2dpYyBhcyB3aGVuIHVwZGF0ZWQgYXQgcnVudGltZVxuXHRcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IHRoaXMuZW5hYmxlZCA/IHdlaWdodCA6IDA7XG5cblx0XHRyZXR1cm4gdGhpcy5zdG9wRmFkaW5nKCk7XG5cblx0fVxuXG5cdC8vIHJldHVybiB0aGUgd2VpZ2h0IGNvbnNpZGVyaW5nIGZhZGluZyBhbmQgLmVuYWJsZWRcblx0Z2V0RWZmZWN0aXZlV2VpZ2h0KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVdlaWdodDtcblxuXHR9XG5cblx0ZmFkZUluKCBkdXJhdGlvbiApIHtcblxuXHRcdHJldHVybiB0aGlzLl9zY2hlZHVsZUZhZGluZyggZHVyYXRpb24sIDAsIDEgKTtcblxuXHR9XG5cblx0ZmFkZU91dCggZHVyYXRpb24gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcoIGR1cmF0aW9uLCAxLCAwICk7XG5cblx0fVxuXG5cdGNyb3NzRmFkZUZyb20oIGZhZGVPdXRBY3Rpb24sIGR1cmF0aW9uLCB3YXJwICkge1xuXG5cdFx0ZmFkZU91dEFjdGlvbi5mYWRlT3V0KCBkdXJhdGlvbiApO1xuXHRcdHRoaXMuZmFkZUluKCBkdXJhdGlvbiApO1xuXG5cdFx0aWYgKCB3YXJwICkge1xuXG5cdFx0XHRjb25zdCBmYWRlSW5EdXJhdGlvbiA9IHRoaXMuX2NsaXAuZHVyYXRpb24sXG5cdFx0XHRcdGZhZGVPdXREdXJhdGlvbiA9IGZhZGVPdXRBY3Rpb24uX2NsaXAuZHVyYXRpb24sXG5cblx0XHRcdFx0c3RhcnRFbmRSYXRpbyA9IGZhZGVPdXREdXJhdGlvbiAvIGZhZGVJbkR1cmF0aW9uLFxuXHRcdFx0XHRlbmRTdGFydFJhdGlvID0gZmFkZUluRHVyYXRpb24gLyBmYWRlT3V0RHVyYXRpb247XG5cblx0XHRcdGZhZGVPdXRBY3Rpb24ud2FycCggMS4wLCBzdGFydEVuZFJhdGlvLCBkdXJhdGlvbiApO1xuXHRcdFx0dGhpcy53YXJwKCBlbmRTdGFydFJhdGlvLCAxLjAsIGR1cmF0aW9uICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y3Jvc3NGYWRlVG8oIGZhZGVJbkFjdGlvbiwgZHVyYXRpb24sIHdhcnAgKSB7XG5cblx0XHRyZXR1cm4gZmFkZUluQWN0aW9uLmNyb3NzRmFkZUZyb20oIHRoaXMsIGR1cmF0aW9uLCB3YXJwICk7XG5cblx0fVxuXG5cdHN0b3BGYWRpbmcoKSB7XG5cblx0XHRjb25zdCB3ZWlnaHRJbnRlcnBvbGFudCA9IHRoaXMuX3dlaWdodEludGVycG9sYW50O1xuXG5cdFx0aWYgKCB3ZWlnaHRJbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBudWxsO1xuXHRcdFx0dGhpcy5fbWl4ZXIuX3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KCB3ZWlnaHRJbnRlcnBvbGFudCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vIFRpbWUgU2NhbGUgQ29udHJvbFxuXG5cdC8vIHNldCB0aGUgdGltZSBzY2FsZSBzdG9wcGluZyBhbnkgc2NoZWR1bGVkIHdhcnBpbmdcblx0Ly8gYWx0aG91Z2ggLnBhdXNlZCA9IHRydWUgeWllbGRzIGFuIGVmZmVjdGl2ZSB0aW1lIHNjYWxlIG9mIHplcm8sIHRoaXNcblx0Ly8gbWV0aG9kIGRvZXMgKm5vdCogY2hhbmdlIC5wYXVzZWQsIGJlY2F1c2UgaXQgd291bGQgYmUgY29uZnVzaW5nXG5cdHNldEVmZmVjdGl2ZVRpbWVTY2FsZSggdGltZVNjYWxlICkge1xuXG5cdFx0dGhpcy50aW1lU2NhbGUgPSB0aW1lU2NhbGU7XG5cdFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gdGhpcy5wYXVzZWQgPyAwIDogdGltZVNjYWxlO1xuXG5cdFx0cmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKTtcblxuXHR9XG5cblx0Ly8gcmV0dXJuIHRoZSB0aW1lIHNjYWxlIGNvbnNpZGVyaW5nIHdhcnBpbmcgYW5kIC5wYXVzZWRcblx0Z2V0RWZmZWN0aXZlVGltZVNjYWxlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZTtcblxuXHR9XG5cblx0c2V0RHVyYXRpb24oIGR1cmF0aW9uICkge1xuXG5cdFx0dGhpcy50aW1lU2NhbGUgPSB0aGlzLl9jbGlwLmR1cmF0aW9uIC8gZHVyYXRpb247XG5cblx0XHRyZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xuXG5cdH1cblxuXHRzeW5jV2l0aCggYWN0aW9uICkge1xuXG5cdFx0dGhpcy50aW1lID0gYWN0aW9uLnRpbWU7XG5cdFx0dGhpcy50aW1lU2NhbGUgPSBhY3Rpb24udGltZVNjYWxlO1xuXG5cdFx0cmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKTtcblxuXHR9XG5cblx0aGFsdCggZHVyYXRpb24gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy53YXJwKCB0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUsIDAsIGR1cmF0aW9uICk7XG5cblx0fVxuXG5cdHdhcnAoIHN0YXJ0VGltZVNjYWxlLCBlbmRUaW1lU2NhbGUsIGR1cmF0aW9uICkge1xuXG5cdFx0Y29uc3QgbWl4ZXIgPSB0aGlzLl9taXhlcixcblx0XHRcdG5vdyA9IG1peGVyLnRpbWUsXG5cdFx0XHR0aW1lU2NhbGUgPSB0aGlzLnRpbWVTY2FsZTtcblxuXHRcdGxldCBpbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50O1xuXG5cdFx0aWYgKCBpbnRlcnBvbGFudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0aW50ZXJwb2xhbnQgPSBtaXhlci5fbGVuZENvbnRyb2xJbnRlcnBvbGFudCgpO1xuXHRcdFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHRpbWVzID0gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zLFxuXHRcdFx0dmFsdWVzID0gaW50ZXJwb2xhbnQuc2FtcGxlVmFsdWVzO1xuXG5cdFx0dGltZXNbIDAgXSA9IG5vdztcblx0XHR0aW1lc1sgMSBdID0gbm93ICsgZHVyYXRpb247XG5cblx0XHR2YWx1ZXNbIDAgXSA9IHN0YXJ0VGltZVNjYWxlIC8gdGltZVNjYWxlO1xuXHRcdHZhbHVlc1sgMSBdID0gZW5kVGltZVNjYWxlIC8gdGltZVNjYWxlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0b3BXYXJwaW5nKCkge1xuXG5cdFx0Y29uc3QgdGltZVNjYWxlSW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtcblxuXHRcdGlmICggdGltZVNjYWxlSW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50ID0gbnVsbDtcblx0XHRcdHRoaXMuX21peGVyLl90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudCggdGltZVNjYWxlSW50ZXJwb2xhbnQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvLyBPYmplY3QgQWNjZXNzb3JzXG5cblx0Z2V0TWl4ZXIoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fbWl4ZXI7XG5cblx0fVxuXG5cdGdldENsaXAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fY2xpcDtcblxuXHR9XG5cblx0Z2V0Um9vdCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9sb2NhbFJvb3QgfHwgdGhpcy5fbWl4ZXIuX3Jvb3Q7XG5cblx0fVxuXG5cdC8vIEludGVybmFcblxuXHRfdXBkYXRlKCB0aW1lLCBkZWx0YVRpbWUsIHRpbWVEaXJlY3Rpb24sIGFjY3VJbmRleCApIHtcblxuXHRcdC8vIGNhbGxlZCBieSB0aGUgbWl4ZXJcblxuXHRcdGlmICggISB0aGlzLmVuYWJsZWQgKSB7XG5cblx0XHRcdC8vIGNhbGwgLl91cGRhdGVXZWlnaHQoKSB0byB1cGRhdGUgLl9lZmZlY3RpdmVXZWlnaHRcblxuXHRcdFx0dGhpcy5fdXBkYXRlV2VpZ2h0KCB0aW1lICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRjb25zdCBzdGFydFRpbWUgPSB0aGlzLl9zdGFydFRpbWU7XG5cblx0XHRpZiAoIHN0YXJ0VGltZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gY2hlY2sgZm9yIHNjaGVkdWxlZCBzdGFydCBvZiBhY3Rpb25cblxuXHRcdFx0Y29uc3QgdGltZVJ1bm5pbmcgPSAoIHRpbWUgLSBzdGFydFRpbWUgKSAqIHRpbWVEaXJlY3Rpb247XG5cdFx0XHRpZiAoIHRpbWVSdW5uaW5nIDwgMCB8fCB0aW1lRGlyZWN0aW9uID09PSAwICkge1xuXG5cdFx0XHRcdGRlbHRhVGltZSA9IDA7XG5cblx0XHRcdH0gZWxzZSB7XG5cblxuXHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsOyAvLyB1bnNjaGVkdWxlXG5cdFx0XHRcdGRlbHRhVGltZSA9IHRpbWVEaXJlY3Rpb24gKiB0aW1lUnVubmluZztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYXBwbHkgdGltZSBzY2FsZSBhbmQgYWR2YW5jZSB0aW1lXG5cblx0XHRkZWx0YVRpbWUgKj0gdGhpcy5fdXBkYXRlVGltZVNjYWxlKCB0aW1lICk7XG5cdFx0Y29uc3QgY2xpcFRpbWUgPSB0aGlzLl91cGRhdGVUaW1lKCBkZWx0YVRpbWUgKTtcblxuXHRcdC8vIG5vdGU6IF91cGRhdGVUaW1lIG1heSBkaXNhYmxlIHRoZSBhY3Rpb24gcmVzdWx0aW5nIGluXG5cdFx0Ly8gYW4gZWZmZWN0aXZlIHdlaWdodCBvZiAwXG5cblx0XHRjb25zdCB3ZWlnaHQgPSB0aGlzLl91cGRhdGVXZWlnaHQoIHRpbWUgKTtcblxuXHRcdGlmICggd2VpZ2h0ID4gMCApIHtcblxuXHRcdFx0Y29uc3QgaW50ZXJwb2xhbnRzID0gdGhpcy5faW50ZXJwb2xhbnRzO1xuXHRcdFx0Y29uc3QgcHJvcGVydHlNaXhlcnMgPSB0aGlzLl9wcm9wZXJ0eUJpbmRpbmdzO1xuXG5cdFx0XHRzd2l0Y2ggKCB0aGlzLmJsZW5kTW9kZSApIHtcblxuXHRcdFx0XHRjYXNlIEFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlOlxuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBtID0gaW50ZXJwb2xhbnRzLmxlbmd0aDsgaiAhPT0gbTsgKysgaiApIHtcblxuXHRcdFx0XHRcdFx0aW50ZXJwb2xhbnRzWyBqIF0uZXZhbHVhdGUoIGNsaXBUaW1lICk7XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eU1peGVyc1sgaiBdLmFjY3VtdWxhdGVBZGRpdGl2ZSggd2VpZ2h0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIE5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZTpcblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgbSA9IGludGVycG9sYW50cy5sZW5ndGg7IGogIT09IG07ICsrIGogKSB7XG5cblx0XHRcdFx0XHRcdGludGVycG9sYW50c1sgaiBdLmV2YWx1YXRlKCBjbGlwVGltZSApO1xuXHRcdFx0XHRcdFx0cHJvcGVydHlNaXhlcnNbIGogXS5hY2N1bXVsYXRlKCBhY2N1SW5kZXgsIHdlaWdodCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdF91cGRhdGVXZWlnaHQoIHRpbWUgKSB7XG5cblx0XHRsZXQgd2VpZ2h0ID0gMDtcblxuXHRcdGlmICggdGhpcy5lbmFibGVkICkge1xuXG5cdFx0XHR3ZWlnaHQgPSB0aGlzLndlaWdodDtcblx0XHRcdGNvbnN0IGludGVycG9sYW50ID0gdGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQ7XG5cblx0XHRcdGlmICggaW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW50ZXJwb2xhbnRWYWx1ZSA9IGludGVycG9sYW50LmV2YWx1YXRlKCB0aW1lIClbIDAgXTtcblxuXHRcdFx0XHR3ZWlnaHQgKj0gaW50ZXJwb2xhbnRWYWx1ZTtcblxuXHRcdFx0XHRpZiAoIHRpbWUgPiBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnNbIDEgXSApIHtcblxuXHRcdFx0XHRcdHRoaXMuc3RvcEZhZGluZygpO1xuXG5cdFx0XHRcdFx0aWYgKCBpbnRlcnBvbGFudFZhbHVlID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHQvLyBmYWRlZCBvdXQsIGRpc2FibGVcblx0XHRcdFx0XHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5fZWZmZWN0aXZlV2VpZ2h0ID0gd2VpZ2h0O1xuXHRcdHJldHVybiB3ZWlnaHQ7XG5cblx0fVxuXG5cdF91cGRhdGVUaW1lU2NhbGUoIHRpbWUgKSB7XG5cblx0XHRsZXQgdGltZVNjYWxlID0gMDtcblxuXHRcdGlmICggISB0aGlzLnBhdXNlZCApIHtcblxuXHRcdFx0dGltZVNjYWxlID0gdGhpcy50aW1lU2NhbGU7XG5cblx0XHRcdGNvbnN0IGludGVycG9sYW50ID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ7XG5cblx0XHRcdGlmICggaW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW50ZXJwb2xhbnRWYWx1ZSA9IGludGVycG9sYW50LmV2YWx1YXRlKCB0aW1lIClbIDAgXTtcblxuXHRcdFx0XHR0aW1lU2NhbGUgKj0gaW50ZXJwb2xhbnRWYWx1ZTtcblxuXHRcdFx0XHRpZiAoIHRpbWUgPiBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnNbIDEgXSApIHtcblxuXHRcdFx0XHRcdHRoaXMuc3RvcFdhcnBpbmcoKTtcblxuXHRcdFx0XHRcdGlmICggdGltZVNjYWxlID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHQvLyBtb3Rpb24gaGFzIGhhbHRlZCwgcGF1c2Vcblx0XHRcdFx0XHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIHdhcnAgZG9uZSAtIGFwcGx5IGZpbmFsIHRpbWUgc2NhbGVcblx0XHRcdFx0XHRcdHRoaXMudGltZVNjYWxlID0gdGltZVNjYWxlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gdGltZVNjYWxlO1xuXHRcdHJldHVybiB0aW1lU2NhbGU7XG5cblx0fVxuXG5cdF91cGRhdGVUaW1lKCBkZWx0YVRpbWUgKSB7XG5cblx0XHRjb25zdCBkdXJhdGlvbiA9IHRoaXMuX2NsaXAuZHVyYXRpb247XG5cdFx0Y29uc3QgbG9vcCA9IHRoaXMubG9vcDtcblxuXHRcdGxldCB0aW1lID0gdGhpcy50aW1lICsgZGVsdGFUaW1lO1xuXHRcdGxldCBsb29wQ291bnQgPSB0aGlzLl9sb29wQ291bnQ7XG5cblx0XHRjb25zdCBwaW5nUG9uZyA9ICggbG9vcCA9PT0gTG9vcFBpbmdQb25nICk7XG5cblx0XHRpZiAoIGRlbHRhVGltZSA9PT0gMCApIHtcblxuXHRcdFx0aWYgKCBsb29wQ291bnQgPT09IC0gMSApIHJldHVybiB0aW1lO1xuXG5cdFx0XHRyZXR1cm4gKCBwaW5nUG9uZyAmJiAoIGxvb3BDb3VudCAmIDEgKSA9PT0gMSApID8gZHVyYXRpb24gLSB0aW1lIDogdGltZTtcblxuXHRcdH1cblxuXHRcdGlmICggbG9vcCA9PT0gTG9vcE9uY2UgKSB7XG5cblx0XHRcdGlmICggbG9vcENvdW50ID09PSAtIDEgKSB7XG5cblx0XHRcdFx0Ly8ganVzdCBzdGFydGVkXG5cblx0XHRcdFx0dGhpcy5fbG9vcENvdW50ID0gMDtcblx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyggdHJ1ZSwgdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRoYW5kbGVfc3RvcDoge1xuXG5cdFx0XHRcdGlmICggdGltZSA+PSBkdXJhdGlvbiApIHtcblxuXHRcdFx0XHRcdHRpbWUgPSBkdXJhdGlvbjtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0aW1lIDwgMCApIHtcblxuXHRcdFx0XHRcdHRpbWUgPSAwO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLnRpbWUgPSB0aW1lO1xuXG5cdFx0XHRcdFx0YnJlYWsgaGFuZGxlX3N0b3A7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdGhpcy5jbGFtcFdoZW5GaW5pc2hlZCApIHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0XHRcdFx0ZWxzZSB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuXHRcdFx0XHR0aGlzLnRpbWUgPSB0aW1lO1xuXG5cdFx0XHRcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoIHtcblx0XHRcdFx0XHR0eXBlOiAnZmluaXNoZWQnLCBhY3Rpb246IHRoaXMsXG5cdFx0XHRcdFx0ZGlyZWN0aW9uOiBkZWx0YVRpbWUgPCAwID8gLSAxIDogMVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7IC8vIHJlcGV0aXRpdmUgUmVwZWF0IG9yIFBpbmdQb25nXG5cblx0XHRcdGlmICggbG9vcENvdW50ID09PSAtIDEgKSB7XG5cblx0XHRcdFx0Ly8ganVzdCBzdGFydGVkXG5cblx0XHRcdFx0aWYgKCBkZWx0YVRpbWUgPj0gMCApIHtcblxuXHRcdFx0XHRcdGxvb3BDb3VudCA9IDA7XG5cblx0XHRcdFx0XHR0aGlzLl9zZXRFbmRpbmdzKCB0cnVlLCB0aGlzLnJlcGV0aXRpb25zID09PSAwLCBwaW5nUG9uZyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyB3aGVuIGxvb3BpbmcgaW4gcmV2ZXJzZSBkaXJlY3Rpb24sIHRoZSBpbml0aWFsXG5cdFx0XHRcdFx0Ly8gdHJhbnNpdGlvbiB0aHJvdWdoIHplcm8gY291bnRzIGFzIGEgcmVwZXRpdGlvbixcblx0XHRcdFx0XHQvLyBzbyBsZWF2ZSBsb29wQ291bnQgYXQgLTFcblxuXHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIHRoaXMucmVwZXRpdGlvbnMgPT09IDAsIHRydWUsIHBpbmdQb25nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGltZSA+PSBkdXJhdGlvbiB8fCB0aW1lIDwgMCApIHtcblxuXHRcdFx0XHQvLyB3cmFwIGFyb3VuZFxuXG5cdFx0XHRcdGNvbnN0IGxvb3BEZWx0YSA9IE1hdGguZmxvb3IoIHRpbWUgLyBkdXJhdGlvbiApOyAvLyBzaWduZWRcblx0XHRcdFx0dGltZSAtPSBkdXJhdGlvbiAqIGxvb3BEZWx0YTtcblxuXHRcdFx0XHRsb29wQ291bnQgKz0gTWF0aC5hYnMoIGxvb3BEZWx0YSApO1xuXG5cdFx0XHRcdGNvbnN0IHBlbmRpbmcgPSB0aGlzLnJlcGV0aXRpb25zIC0gbG9vcENvdW50O1xuXG5cdFx0XHRcdGlmICggcGVuZGluZyA8PSAwICkge1xuXG5cdFx0XHRcdFx0Ly8gaGF2ZSB0byBzdG9wIChzd2l0Y2ggc3RhdGUsIGNsYW1wIHRpbWUsIGZpcmUgZXZlbnQpXG5cblx0XHRcdFx0XHRpZiAoIHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgKSB0aGlzLnBhdXNlZCA9IHRydWU7XG5cdFx0XHRcdFx0ZWxzZSB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdHRpbWUgPSBkZWx0YVRpbWUgPiAwID8gZHVyYXRpb24gOiAwO1xuXG5cdFx0XHRcdFx0dGhpcy50aW1lID0gdGltZTtcblxuXHRcdFx0XHRcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoIHtcblx0XHRcdFx0XHRcdHR5cGU6ICdmaW5pc2hlZCcsIGFjdGlvbjogdGhpcyxcblx0XHRcdFx0XHRcdGRpcmVjdGlvbjogZGVsdGFUaW1lID4gMCA/IDEgOiAtIDFcblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGtlZXAgcnVubmluZ1xuXG5cdFx0XHRcdFx0aWYgKCBwZW5kaW5nID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHQvLyBlbnRlcmluZyB0aGUgbGFzdCByb3VuZFxuXG5cdFx0XHRcdFx0XHRjb25zdCBhdFN0YXJ0ID0gZGVsdGFUaW1lIDwgMDtcblx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIGF0U3RhcnQsICEgYXRTdGFydCwgcGluZ1BvbmcgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIGZhbHNlLCBmYWxzZSwgcGluZ1BvbmcgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuX2xvb3BDb3VudCA9IGxvb3BDb3VudDtcblxuXHRcdFx0XHRcdHRoaXMudGltZSA9IHRpbWU7XG5cblx0XHRcdFx0XHR0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KCB7XG5cdFx0XHRcdFx0XHR0eXBlOiAnbG9vcCcsIGFjdGlvbjogdGhpcywgbG9vcERlbHRhOiBsb29wRGVsdGFcblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMudGltZSA9IHRpbWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwaW5nUG9uZyAmJiAoIGxvb3BDb3VudCAmIDEgKSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBpbnZlcnQgdGltZSBmb3IgdGhlIFwicG9uZyByb3VuZFwiXG5cblx0XHRcdFx0cmV0dXJuIGR1cmF0aW9uIC0gdGltZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRpbWU7XG5cblx0fVxuXG5cdF9zZXRFbmRpbmdzKCBhdFN0YXJ0LCBhdEVuZCwgcGluZ1BvbmcgKSB7XG5cblx0XHRjb25zdCBzZXR0aW5ncyA9IHRoaXMuX2ludGVycG9sYW50U2V0dGluZ3M7XG5cblx0XHRpZiAoIHBpbmdQb25nICkge1xuXG5cdFx0XHRzZXR0aW5ncy5lbmRpbmdTdGFydCA9IFplcm9TbG9wZUVuZGluZztcblx0XHRcdHNldHRpbmdzLmVuZGluZ0VuZCA9IFplcm9TbG9wZUVuZGluZztcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGFzc3VtaW5nIGZvciBMb29wT25jZSBhdFN0YXJ0ID09IGF0RW5kID09IHRydWVcblxuXHRcdFx0aWYgKCBhdFN0YXJ0ICkge1xuXG5cdFx0XHRcdHNldHRpbmdzLmVuZGluZ1N0YXJ0ID0gdGhpcy56ZXJvU2xvcGVBdFN0YXJ0ID8gWmVyb1Nsb3BlRW5kaW5nIDogWmVyb0N1cnZhdHVyZUVuZGluZztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdTdGFydCA9IFdyYXBBcm91bmRFbmRpbmc7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBhdEVuZCApIHtcblxuXHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdFbmQgPSB0aGlzLnplcm9TbG9wZUF0RW5kID8gWmVyb1Nsb3BlRW5kaW5nIDogWmVyb0N1cnZhdHVyZUVuZGluZztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdFbmQgXHQgPSBXcmFwQXJvdW5kRW5kaW5nO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdF9zY2hlZHVsZUZhZGluZyggZHVyYXRpb24sIHdlaWdodE5vdywgd2VpZ2h0VGhlbiApIHtcblxuXHRcdGNvbnN0IG1peGVyID0gdGhpcy5fbWl4ZXIsIG5vdyA9IG1peGVyLnRpbWU7XG5cdFx0bGV0IGludGVycG9sYW50ID0gdGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQ7XG5cblx0XHRpZiAoIGludGVycG9sYW50ID09PSBudWxsICkge1xuXG5cdFx0XHRpbnRlcnBvbGFudCA9IG1peGVyLl9sZW5kQ29udHJvbEludGVycG9sYW50KCk7XG5cdFx0XHR0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9IGludGVycG9sYW50O1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdGltZXMgPSBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnMsXG5cdFx0XHR2YWx1ZXMgPSBpbnRlcnBvbGFudC5zYW1wbGVWYWx1ZXM7XG5cblx0XHR0aW1lc1sgMCBdID0gbm93O1xuXHRcdHZhbHVlc1sgMCBdID0gd2VpZ2h0Tm93O1xuXHRcdHRpbWVzWyAxIF0gPSBub3cgKyBkdXJhdGlvbjtcblx0XHR2YWx1ZXNbIDEgXSA9IHdlaWdodFRoZW47XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY29uc3QgX2NvbnRyb2xJbnRlcnBvbGFudHNSZXN1bHRCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KCAxICk7XG5cblxuY2xhc3MgQW5pbWF0aW9uTWl4ZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXG5cdGNvbnN0cnVjdG9yKCByb290ICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuX3Jvb3QgPSByb290O1xuXHRcdHRoaXMuX2luaXRNZW1vcnlNYW5hZ2VyKCk7XG5cdFx0dGhpcy5fYWNjdUluZGV4ID0gMDtcblx0XHR0aGlzLnRpbWUgPSAwO1xuXHRcdHRoaXMudGltZVNjYWxlID0gMS4wO1xuXG5cdH1cblxuXHRfYmluZEFjdGlvbiggYWN0aW9uLCBwcm90b3R5cGVBY3Rpb24gKSB7XG5cblx0XHRjb25zdCByb290ID0gYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCxcblx0XHRcdHRyYWNrcyA9IGFjdGlvbi5fY2xpcC50cmFja3MsXG5cdFx0XHRuVHJhY2tzID0gdHJhY2tzLmxlbmd0aCxcblx0XHRcdGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzLFxuXHRcdFx0aW50ZXJwb2xhbnRzID0gYWN0aW9uLl9pbnRlcnBvbGFudHMsXG5cdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZCxcblx0XHRcdGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lO1xuXG5cdFx0bGV0IGJpbmRpbmdzQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF07XG5cblx0XHRpZiAoIGJpbmRpbmdzQnlOYW1lID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGJpbmRpbmdzQnlOYW1lID0ge307XG5cdFx0XHRiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXSA9IGJpbmRpbmdzQnlOYW1lO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBuVHJhY2tzOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCB0cmFjayA9IHRyYWNrc1sgaSBdLFxuXHRcdFx0XHR0cmFja05hbWUgPSB0cmFjay5uYW1lO1xuXG5cdFx0XHRsZXQgYmluZGluZyA9IGJpbmRpbmdzQnlOYW1lWyB0cmFja05hbWUgXTtcblxuXHRcdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0KysgYmluZGluZy5yZWZlcmVuY2VDb3VudDtcblx0XHRcdFx0YmluZGluZ3NbIGkgXSA9IGJpbmRpbmc7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBleGlzdGluZyBiaW5kaW5nLCBtYWtlIHN1cmUgdGhlIGNhY2hlIGtub3dzXG5cblx0XHRcdFx0XHRpZiAoIGJpbmRpbmcuX2NhY2hlSW5kZXggPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdCsrIGJpbmRpbmcucmVmZXJlbmNlQ291bnQ7XG5cdFx0XHRcdFx0XHR0aGlzLl9hZGRJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcsIHJvb3RVdWlkLCB0cmFja05hbWUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBwYXRoID0gcHJvdG90eXBlQWN0aW9uICYmIHByb3RvdHlwZUFjdGlvbi5cblx0XHRcdFx0XHRfcHJvcGVydHlCaW5kaW5nc1sgaSBdLmJpbmRpbmcucGFyc2VkUGF0aDtcblxuXHRcdFx0XHRiaW5kaW5nID0gbmV3IFByb3BlcnR5TWl4ZXIoXG5cdFx0XHRcdFx0UHJvcGVydHlCaW5kaW5nLmNyZWF0ZSggcm9vdCwgdHJhY2tOYW1lLCBwYXRoICksXG5cdFx0XHRcdFx0dHJhY2suVmFsdWVUeXBlTmFtZSwgdHJhY2suZ2V0VmFsdWVTaXplKCkgKTtcblxuXHRcdFx0XHQrKyBiaW5kaW5nLnJlZmVyZW5jZUNvdW50O1xuXHRcdFx0XHR0aGlzLl9hZGRJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcsIHJvb3RVdWlkLCB0cmFja05hbWUgKTtcblxuXHRcdFx0XHRiaW5kaW5nc1sgaSBdID0gYmluZGluZztcblxuXHRcdFx0fVxuXG5cdFx0XHRpbnRlcnBvbGFudHNbIGkgXS5yZXN1bHRCdWZmZXIgPSBiaW5kaW5nLmJ1ZmZlcjtcblxuXHRcdH1cblxuXHR9XG5cblx0X2FjdGl2YXRlQWN0aW9uKCBhY3Rpb24gKSB7XG5cblx0XHRpZiAoICEgdGhpcy5faXNBY3RpdmVBY3Rpb24oIGFjdGlvbiApICkge1xuXG5cdFx0XHRpZiAoIGFjdGlvbi5fY2FjaGVJbmRleCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHQvLyB0aGlzIGFjdGlvbiBoYXMgYmVlbiBmb3Jnb3R0ZW4gYnkgdGhlIGNhY2hlLCBidXQgdGhlIHVzZXJcblx0XHRcdFx0Ly8gYXBwZWFycyB0byBiZSBzdGlsbCB1c2luZyBpdCAtPiByZWJpbmRcblxuXHRcdFx0XHRjb25zdCByb290VXVpZCA9ICggYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCApLnV1aWQsXG5cdFx0XHRcdFx0Y2xpcFV1aWQgPSBhY3Rpb24uX2NsaXAudXVpZCxcblx0XHRcdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XG5cblx0XHRcdFx0dGhpcy5fYmluZEFjdGlvbiggYWN0aW9uLFxuXHRcdFx0XHRcdGFjdGlvbnNGb3JDbGlwICYmIGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9uc1sgMCBdICk7XG5cblx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiwgY2xpcFV1aWQsIHJvb3RVdWlkICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XG5cblx0XHRcdC8vIGluY3JlbWVudCByZWZlcmVuY2UgY291bnRzIC8gc29ydCBvdXQgc3RhdGVcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHRjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGJpbmRpbmcudXNlQ291bnQgKysgPT09IDAgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl9sZW5kQmluZGluZyggYmluZGluZyApO1xuXHRcdFx0XHRcdGJpbmRpbmcuc2F2ZU9yaWdpbmFsU3RhdGUoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbGVuZEFjdGlvbiggYWN0aW9uICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdF9kZWFjdGl2YXRlQWN0aW9uKCBhY3Rpb24gKSB7XG5cblx0XHRpZiAoIHRoaXMuX2lzQWN0aXZlQWN0aW9uKCBhY3Rpb24gKSApIHtcblxuXHRcdFx0Y29uc3QgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XG5cblx0XHRcdC8vIGRlY3JlbWVudCByZWZlcmVuY2UgY291bnRzIC8gc29ydCBvdXQgc3RhdGVcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHRjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcblxuXHRcdFx0XHRpZiAoIC0tIGJpbmRpbmcudXNlQ291bnQgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRiaW5kaW5nLnJlc3RvcmVPcmlnaW5hbFN0YXRlKCk7XG5cdFx0XHRcdFx0dGhpcy5fdGFrZUJhY2tCaW5kaW5nKCBiaW5kaW5nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3Rha2VCYWNrQWN0aW9uKCBhY3Rpb24gKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gTWVtb3J5IG1hbmFnZXJcblxuXHRfaW5pdE1lbW9yeU1hbmFnZXIoKSB7XG5cblx0XHR0aGlzLl9hY3Rpb25zID0gW107IC8vICduQWN0aXZlQWN0aW9ucycgZm9sbG93ZWQgYnkgaW5hY3RpdmUgb25lc1xuXHRcdHRoaXMuX25BY3RpdmVBY3Rpb25zID0gMDtcblxuXHRcdHRoaXMuX2FjdGlvbnNCeUNsaXAgPSB7fTtcblx0XHQvLyBpbnNpZGU6XG5cdFx0Ly8ge1xuXHRcdC8vIFx0a25vd25BY3Rpb25zOiBBcnJheTwgQW5pbWF0aW9uQWN0aW9uID4gLSB1c2VkIGFzIHByb3RvdHlwZXNcblx0XHQvLyBcdGFjdGlvbkJ5Um9vdDogQW5pbWF0aW9uQWN0aW9uIC0gbG9va3VwXG5cdFx0Ly8gfVxuXG5cblx0XHR0aGlzLl9iaW5kaW5ncyA9IFtdOyAvLyAnbkFjdGl2ZUJpbmRpbmdzJyBmb2xsb3dlZCBieSBpbmFjdGl2ZSBvbmVzXG5cdFx0dGhpcy5fbkFjdGl2ZUJpbmRpbmdzID0gMDtcblxuXHRcdHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSA9IHt9OyAvLyBpbnNpZGU6IE1hcDwgbmFtZSwgUHJvcGVydHlNaXhlciA+XG5cblxuXHRcdHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMgPSBbXTsgLy8gc2FtZSBnYW1lIGFzIGFib3ZlXG5cdFx0dGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHMgPSAwO1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dGhpcy5zdGF0cyA9IHtcblxuXHRcdFx0YWN0aW9uczoge1xuXHRcdFx0XHRnZXQgdG90YWwoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX2FjdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGdldCBpblVzZSgpIHtcblxuXHRcdFx0XHRcdHJldHVybiBzY29wZS5fbkFjdGl2ZUFjdGlvbnM7XG5cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGJpbmRpbmdzOiB7XG5cdFx0XHRcdGdldCB0b3RhbCgpIHtcblxuXHRcdFx0XHRcdHJldHVybiBzY29wZS5fYmluZGluZ3MubGVuZ3RoO1xuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGdldCBpblVzZSgpIHtcblxuXHRcdFx0XHRcdHJldHVybiBzY29wZS5fbkFjdGl2ZUJpbmRpbmdzO1xuXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRjb250cm9sSW50ZXJwb2xhbnRzOiB7XG5cdFx0XHRcdGdldCB0b3RhbCgpIHtcblxuXHRcdFx0XHRcdHJldHVybiBzY29wZS5fY29udHJvbEludGVycG9sYW50cy5sZW5ndGg7XG5cblx0XHRcdFx0fSxcblx0XHRcdFx0Z2V0IGluVXNlKCkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHNjb3BlLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cztcblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH1cblxuXHQvLyBNZW1vcnkgbWFuYWdlbWVudCBmb3IgQW5pbWF0aW9uQWN0aW9uIG9iamVjdHNcblxuXHRfaXNBY3RpdmVBY3Rpb24oIGFjdGlvbiApIHtcblxuXHRcdGNvbnN0IGluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4O1xuXHRcdHJldHVybiBpbmRleCAhPT0gbnVsbCAmJiBpbmRleCA8IHRoaXMuX25BY3RpdmVBY3Rpb25zO1xuXG5cdH1cblxuXHRfYWRkSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiwgY2xpcFV1aWQsIHJvb3RVdWlkICkge1xuXG5cdFx0Y29uc3QgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG5cdFx0XHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcDtcblxuXHRcdGxldCBhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XG5cblx0XHRpZiAoIGFjdGlvbnNGb3JDbGlwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGFjdGlvbnNGb3JDbGlwID0ge1xuXG5cdFx0XHRcdGtub3duQWN0aW9uczogWyBhY3Rpb24gXSxcblx0XHRcdFx0YWN0aW9uQnlSb290OiB7fVxuXG5cdFx0XHR9O1xuXG5cdFx0XHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSAwO1xuXG5cdFx0XHRhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdID0gYWN0aW9uc0ZvckNsaXA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBrbm93bkFjdGlvbnMgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnM7XG5cblx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IGtub3duQWN0aW9ucy5sZW5ndGg7XG5cdFx0XHRrbm93bkFjdGlvbnMucHVzaCggYWN0aW9uICk7XG5cblx0XHR9XG5cblx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBhY3Rpb25zLmxlbmd0aDtcblx0XHRhY3Rpb25zLnB1c2goIGFjdGlvbiApO1xuXG5cdFx0YWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdID0gYWN0aW9uO1xuXG5cdH1cblxuXHRfcmVtb3ZlSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiApIHtcblxuXHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgYWN0aW9ucy5sZW5ndGggLSAxIF0sXG5cdFx0XHRjYWNoZUluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4O1xuXG5cdFx0bGFzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcblx0XHRhY3Rpb25zWyBjYWNoZUluZGV4IF0gPSBsYXN0SW5hY3RpdmVBY3Rpb247XG5cdFx0YWN0aW9ucy5wb3AoKTtcblxuXHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XG5cblxuXHRcdGNvbnN0IGNsaXBVdWlkID0gYWN0aW9uLl9jbGlwLnV1aWQsXG5cdFx0XHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcCxcblx0XHRcdGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXSxcblx0XHRcdGtub3duQWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnMsXG5cblx0XHRcdGxhc3RLbm93bkFjdGlvbiA9XG5cdFx0XHRcdGtub3duQWN0aW9uc0ZvckNsaXBbIGtub3duQWN0aW9uc0ZvckNsaXAubGVuZ3RoIC0gMSBdLFxuXG5cdFx0XHRieUNsaXBDYWNoZUluZGV4ID0gYWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4O1xuXG5cdFx0bGFzdEtub3duQWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gYnlDbGlwQ2FjaGVJbmRleDtcblx0XHRrbm93bkFjdGlvbnNGb3JDbGlwWyBieUNsaXBDYWNoZUluZGV4IF0gPSBsYXN0S25vd25BY3Rpb247XG5cdFx0a25vd25BY3Rpb25zRm9yQ2xpcC5wb3AoKTtcblxuXHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XG5cblxuXHRcdGNvbnN0IGFjdGlvbkJ5Um9vdCA9IGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdCxcblx0XHRcdHJvb3RVdWlkID0gKCBhY3Rpb24uX2xvY2FsUm9vdCB8fCB0aGlzLl9yb290ICkudXVpZDtcblxuXHRcdGRlbGV0ZSBhY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF07XG5cblx0XHRpZiAoIGtub3duQWN0aW9uc0ZvckNsaXAubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRkZWxldGUgYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oIGFjdGlvbiApO1xuXG5cdH1cblxuXHRfcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbiggYWN0aW9uICkge1xuXG5cdFx0Y29uc3QgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xuXG5cdFx0XHRpZiAoIC0tIGJpbmRpbmcucmVmZXJlbmNlQ291bnQgPT09IDAgKSB7XG5cblx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0X2xlbmRBY3Rpb24oIGFjdGlvbiApIHtcblxuXHRcdC8vIFsgYWN0aXZlIGFjdGlvbnMgfCAgaW5hY3RpdmUgYWN0aW9ucyAgXVxuXHRcdC8vIFsgIGFjdGl2ZSBhY3Rpb25zID58IGluYWN0aXZlIGFjdGlvbnMgXVxuXHRcdC8vICAgICAgICAgICAgICAgICBzICAgICAgICBhXG5cdFx0Ly8gICAgICAgICAgICAgICAgICA8LXN3YXAtPlxuXHRcdC8vICAgICAgICAgICAgICAgICBhICAgICAgICBzXG5cblx0XHRjb25zdCBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdHByZXZJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcblxuXHRcdFx0bGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMgKyssXG5cblx0XHRcdGZpcnN0SW5hY3RpdmVBY3Rpb24gPSBhY3Rpb25zWyBsYXN0QWN0aXZlSW5kZXggXTtcblxuXHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcblx0XHRhY3Rpb25zWyBsYXN0QWN0aXZlSW5kZXggXSA9IGFjdGlvbjtcblxuXHRcdGZpcnN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG5cdFx0YWN0aW9uc1sgcHJldkluZGV4IF0gPSBmaXJzdEluYWN0aXZlQWN0aW9uO1xuXG5cdH1cblxuXHRfdGFrZUJhY2tBY3Rpb24oIGFjdGlvbiApIHtcblxuXHRcdC8vIFsgIGFjdGl2ZSBhY3Rpb25zICB8IGluYWN0aXZlIGFjdGlvbnMgXVxuXHRcdC8vIFsgYWN0aXZlIGFjdGlvbnMgfDwgaW5hY3RpdmUgYWN0aW9ucyAgXVxuXHRcdC8vICAgICAgICBhICAgICAgICBzXG5cdFx0Ly8gICAgICAgICA8LXN3YXAtPlxuXHRcdC8vICAgICAgICBzICAgICAgICBhXG5cblx0XHRjb25zdCBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdHByZXZJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcblxuXHRcdFx0Zmlyc3RJbmFjdGl2ZUluZGV4ID0gLS0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMsXG5cblx0XHRcdGxhc3RBY3RpdmVBY3Rpb24gPSBhY3Rpb25zWyBmaXJzdEluYWN0aXZlSW5kZXggXTtcblxuXHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IGZpcnN0SW5hY3RpdmVJbmRleDtcblx0XHRhY3Rpb25zWyBmaXJzdEluYWN0aXZlSW5kZXggXSA9IGFjdGlvbjtcblxuXHRcdGxhc3RBY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG5cdFx0YWN0aW9uc1sgcHJldkluZGV4IF0gPSBsYXN0QWN0aXZlQWN0aW9uO1xuXG5cdH1cblxuXHQvLyBNZW1vcnkgbWFuYWdlbWVudCBmb3IgUHJvcGVydHlNaXhlciBvYmplY3RzXG5cblx0X2FkZEluYWN0aXZlQmluZGluZyggYmluZGluZywgcm9vdFV1aWQsIHRyYWNrTmFtZSApIHtcblxuXHRcdGNvbnN0IGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxuXHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcblxuXHRcdGxldCBiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF07XG5cblx0XHRpZiAoIGJpbmRpbmdCeU5hbWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0YmluZGluZ0J5TmFtZSA9IHt9O1xuXHRcdFx0YmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0gPSBiaW5kaW5nQnlOYW1lO1xuXG5cdFx0fVxuXG5cdFx0YmluZGluZ0J5TmFtZVsgdHJhY2tOYW1lIF0gPSBiaW5kaW5nO1xuXG5cdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGJpbmRpbmdzLmxlbmd0aDtcblx0XHRiaW5kaW5ncy5wdXNoKCBiaW5kaW5nICk7XG5cblx0fVxuXG5cdF9yZW1vdmVJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcgKSB7XG5cblx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0cHJvcEJpbmRpbmcgPSBiaW5kaW5nLmJpbmRpbmcsXG5cdFx0XHRyb290VXVpZCA9IHByb3BCaW5kaW5nLnJvb3ROb2RlLnV1aWQsXG5cdFx0XHR0cmFja05hbWUgPSBwcm9wQmluZGluZy5wYXRoLFxuXHRcdFx0YmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXG5cdFx0XHRiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0sXG5cblx0XHRcdGxhc3RJbmFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1sgYmluZGluZ3MubGVuZ3RoIC0gMSBdLFxuXHRcdFx0Y2FjaGVJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXg7XG5cblx0XHRsYXN0SW5hY3RpdmVCaW5kaW5nLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcblx0XHRiaW5kaW5nc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQmluZGluZztcblx0XHRiaW5kaW5ncy5wb3AoKTtcblxuXHRcdGRlbGV0ZSBiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXTtcblxuXHRcdGlmICggT2JqZWN0LmtleXMoIGJpbmRpbmdCeU5hbWUgKS5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdGRlbGV0ZSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXTtcblxuXHRcdH1cblxuXHR9XG5cblx0X2xlbmRCaW5kaW5nKCBiaW5kaW5nICkge1xuXG5cdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcblx0XHRcdHByZXZJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXgsXG5cblx0XHRcdGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVCaW5kaW5ncyArKyxcblxuXHRcdFx0Zmlyc3RJbmFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1sgbGFzdEFjdGl2ZUluZGV4IF07XG5cblx0XHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xuXHRcdGJpbmRpbmdzWyBsYXN0QWN0aXZlSW5kZXggXSA9IGJpbmRpbmc7XG5cblx0XHRmaXJzdEluYWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcblx0XHRiaW5kaW5nc1sgcHJldkluZGV4IF0gPSBmaXJzdEluYWN0aXZlQmluZGluZztcblxuXHR9XG5cblx0X3Rha2VCYWNrQmluZGluZyggYmluZGluZyApIHtcblxuXHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRwcmV2SW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4LFxuXG5cdFx0XHRmaXJzdEluYWN0aXZlSW5kZXggPSAtLSB0aGlzLl9uQWN0aXZlQmluZGluZ3MsXG5cblx0XHRcdGxhc3RBY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbIGZpcnN0SW5hY3RpdmVJbmRleCBdO1xuXG5cdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGZpcnN0SW5hY3RpdmVJbmRleDtcblx0XHRiaW5kaW5nc1sgZmlyc3RJbmFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xuXG5cdFx0bGFzdEFjdGl2ZUJpbmRpbmcuX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG5cdFx0YmluZGluZ3NbIHByZXZJbmRleCBdID0gbGFzdEFjdGl2ZUJpbmRpbmc7XG5cblx0fVxuXG5cblx0Ly8gTWVtb3J5IG1hbmFnZW1lbnQgb2YgSW50ZXJwb2xhbnRzIGZvciB3ZWlnaHQgYW5kIHRpbWUgc2NhbGVcblxuXHRfbGVuZENvbnRyb2xJbnRlcnBvbGFudCgpIHtcblxuXHRcdGNvbnN0IGludGVycG9sYW50cyA9IHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsXG5cdFx0XHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cyArKztcblxuXHRcdGxldCBpbnRlcnBvbGFudCA9IGludGVycG9sYW50c1sgbGFzdEFjdGl2ZUluZGV4IF07XG5cblx0XHRpZiAoIGludGVycG9sYW50ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGludGVycG9sYW50ID0gbmV3IExpbmVhckludGVycG9sYW50KFxuXHRcdFx0XHRuZXcgRmxvYXQzMkFycmF5KCAyICksIG5ldyBGbG9hdDMyQXJyYXkoIDIgKSxcblx0XHRcdFx0MSwgX2NvbnRyb2xJbnRlcnBvbGFudHNSZXN1bHRCdWZmZXIgKTtcblxuXHRcdFx0aW50ZXJwb2xhbnQuX19jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xuXHRcdFx0aW50ZXJwb2xhbnRzWyBsYXN0QWN0aXZlSW5kZXggXSA9IGludGVycG9sYW50O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGludGVycG9sYW50O1xuXG5cdH1cblxuXHRfdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQoIGludGVycG9sYW50ICkge1xuXG5cdFx0Y29uc3QgaW50ZXJwb2xhbnRzID0gdGhpcy5fY29udHJvbEludGVycG9sYW50cyxcblx0XHRcdHByZXZJbmRleCA9IGludGVycG9sYW50Ll9fY2FjaGVJbmRleCxcblxuXHRcdFx0Zmlyc3RJbmFjdGl2ZUluZGV4ID0gLS0gdGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHMsXG5cblx0XHRcdGxhc3RBY3RpdmVJbnRlcnBvbGFudCA9IGludGVycG9sYW50c1sgZmlyc3RJbmFjdGl2ZUluZGV4IF07XG5cblx0XHRpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XG5cdFx0aW50ZXJwb2xhbnRzWyBmaXJzdEluYWN0aXZlSW5kZXggXSA9IGludGVycG9sYW50O1xuXG5cdFx0bGFzdEFjdGl2ZUludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcblx0XHRpbnRlcnBvbGFudHNbIHByZXZJbmRleCBdID0gbGFzdEFjdGl2ZUludGVycG9sYW50O1xuXG5cdH1cblxuXHQvLyByZXR1cm4gYW4gYWN0aW9uIGZvciBhIGNsaXAgb3B0aW9uYWxseSB1c2luZyBhIGN1c3RvbSByb290IHRhcmdldFxuXHQvLyBvYmplY3QgKHRoaXMgbWV0aG9kIGFsbG9jYXRlcyBhIGxvdCBvZiBkeW5hbWljIG1lbW9yeSBpbiBjYXNlIGFcblx0Ly8gcHJldmlvdXNseSB1bmtub3duIGNsaXAvcm9vdCBjb21iaW5hdGlvbiBpcyBzcGVjaWZpZWQpXG5cdGNsaXBBY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCwgYmxlbmRNb2RlICkge1xuXG5cdFx0Y29uc3Qgcm9vdCA9IG9wdGlvbmFsUm9vdCB8fCB0aGlzLl9yb290LFxuXHRcdFx0cm9vdFV1aWQgPSByb290LnV1aWQ7XG5cblx0XHRsZXQgY2xpcE9iamVjdCA9IHR5cGVvZiBjbGlwID09PSAnc3RyaW5nJyA/IEFuaW1hdGlvbkNsaXAuZmluZEJ5TmFtZSggcm9vdCwgY2xpcCApIDogY2xpcDtcblxuXHRcdGNvbnN0IGNsaXBVdWlkID0gY2xpcE9iamVjdCAhPT0gbnVsbCA/IGNsaXBPYmplY3QudXVpZCA6IGNsaXA7XG5cblx0XHRjb25zdCBhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XG5cdFx0bGV0IHByb3RvdHlwZUFjdGlvbiA9IG51bGw7XG5cblx0XHRpZiAoIGJsZW5kTW9kZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIGNsaXBPYmplY3QgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0YmxlbmRNb2RlID0gY2xpcE9iamVjdC5ibGVuZE1vZGU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YmxlbmRNb2RlID0gTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IGV4aXN0aW5nQWN0aW9uID0gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xuXG5cdFx0XHRpZiAoIGV4aXN0aW5nQWN0aW9uICE9PSB1bmRlZmluZWQgJiYgZXhpc3RpbmdBY3Rpb24uYmxlbmRNb2RlID09PSBibGVuZE1vZGUgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGV4aXN0aW5nQWN0aW9uO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHdlIGtub3cgdGhlIGNsaXAsIHNvIHdlIGRvbid0IGhhdmUgdG8gcGFyc2UgYWxsXG5cdFx0XHQvLyB0aGUgYmluZGluZ3MgYWdhaW4gYnV0IGNhbiBqdXN0IGNvcHlcblx0XHRcdHByb3RvdHlwZUFjdGlvbiA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9uc1sgMCBdO1xuXG5cdFx0XHQvLyBhbHNvLCB0YWtlIHRoZSBjbGlwIGZyb20gdGhlIHByb3RvdHlwZSBhY3Rpb25cblx0XHRcdGlmICggY2xpcE9iamVjdCA9PT0gbnVsbCApXG5cdFx0XHRcdGNsaXBPYmplY3QgPSBwcm90b3R5cGVBY3Rpb24uX2NsaXA7XG5cblx0XHR9XG5cblx0XHQvLyBjbGlwIG11c3QgYmUga25vd24gd2hlbiBzcGVjaWZpZWQgdmlhIHN0cmluZ1xuXHRcdGlmICggY2xpcE9iamVjdCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xuXG5cdFx0Ly8gYWxsb2NhdGUgYWxsIHJlc291cmNlcyByZXF1aXJlZCB0byBydW4gaXRcblx0XHRjb25zdCBuZXdBY3Rpb24gPSBuZXcgQW5pbWF0aW9uQWN0aW9uKCB0aGlzLCBjbGlwT2JqZWN0LCBvcHRpb25hbFJvb3QsIGJsZW5kTW9kZSApO1xuXG5cdFx0dGhpcy5fYmluZEFjdGlvbiggbmV3QWN0aW9uLCBwcm90b3R5cGVBY3Rpb24gKTtcblxuXHRcdC8vIGFuZCBtYWtlIHRoZSBhY3Rpb24ga25vd24gdG8gdGhlIG1lbW9yeSBtYW5hZ2VyXG5cdFx0dGhpcy5fYWRkSW5hY3RpdmVBY3Rpb24oIG5ld0FjdGlvbiwgY2xpcFV1aWQsIHJvb3RVdWlkICk7XG5cblx0XHRyZXR1cm4gbmV3QWN0aW9uO1xuXG5cdH1cblxuXHQvLyBnZXQgYW4gZXhpc3RpbmcgYWN0aW9uXG5cdGV4aXN0aW5nQWN0aW9uKCBjbGlwLCBvcHRpb25hbFJvb3QgKSB7XG5cblx0XHRjb25zdCByb290ID0gb3B0aW9uYWxSb290IHx8IHRoaXMuX3Jvb3QsXG5cdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZCxcblxuXHRcdFx0Y2xpcE9iamVjdCA9IHR5cGVvZiBjbGlwID09PSAnc3RyaW5nJyA/XG5cdFx0XHRcdEFuaW1hdGlvbkNsaXAuZmluZEJ5TmFtZSggcm9vdCwgY2xpcCApIDogY2xpcCxcblxuXHRcdFx0Y2xpcFV1aWQgPSBjbGlwT2JqZWN0ID8gY2xpcE9iamVjdC51dWlkIDogY2xpcCxcblxuXHRcdFx0YWN0aW9uc0ZvckNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xuXG5cdFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXR1cm4gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdIHx8IG51bGw7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cblx0Ly8gZGVhY3RpdmF0ZXMgYWxsIHByZXZpb3VzbHkgc2NoZWR1bGVkIGFjdGlvbnNcblx0c3RvcEFsbEFjdGlvbigpIHtcblxuXHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0bkFjdGlvbnMgPSB0aGlzLl9uQWN0aXZlQWN0aW9ucztcblxuXHRcdGZvciAoIGxldCBpID0gbkFjdGlvbnMgLSAxOyBpID49IDA7IC0tIGkgKSB7XG5cblx0XHRcdGFjdGlvbnNbIGkgXS5zdG9wKCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Ly8gYWR2YW5jZSB0aGUgdGltZSBhbmQgdXBkYXRlIGFwcGx5IHRoZSBhbmltYXRpb25cblx0dXBkYXRlKCBkZWx0YVRpbWUgKSB7XG5cblx0XHRkZWx0YVRpbWUgKj0gdGhpcy50aW1lU2NhbGU7XG5cblx0XHRjb25zdCBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdG5BY3Rpb25zID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMsXG5cblx0XHRcdHRpbWUgPSB0aGlzLnRpbWUgKz0gZGVsdGFUaW1lLFxuXHRcdFx0dGltZURpcmVjdGlvbiA9IE1hdGguc2lnbiggZGVsdGFUaW1lICksXG5cblx0XHRcdGFjY3VJbmRleCA9IHRoaXMuX2FjY3VJbmRleCBePSAxO1xuXG5cdFx0Ly8gcnVuIGFjdGl2ZSBhY3Rpb25zXG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgIT09IG5BY3Rpb25zOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCBhY3Rpb24gPSBhY3Rpb25zWyBpIF07XG5cblx0XHRcdGFjdGlvbi5fdXBkYXRlKCB0aW1lLCBkZWx0YVRpbWUsIHRpbWVEaXJlY3Rpb24sIGFjY3VJbmRleCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIHNjZW5lIGdyYXBoXG5cblx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0bkJpbmRpbmdzID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBuQmluZGluZ3M7ICsrIGkgKSB7XG5cblx0XHRcdGJpbmRpbmdzWyBpIF0uYXBwbHkoIGFjY3VJbmRleCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vIEFsbG93cyB5b3UgdG8gc2VlayB0byBhIHNwZWNpZmljIHRpbWUgaW4gYW4gYW5pbWF0aW9uLlxuXHRzZXRUaW1lKCB0aW1lSW5TZWNvbmRzICkge1xuXG5cdFx0dGhpcy50aW1lID0gMDsgLy8gWmVybyBvdXQgdGltZSBhdHRyaWJ1dGUgZm9yIEFuaW1hdGlvbk1peGVyIG9iamVjdDtcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLl9hY3Rpb25zLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5fYWN0aW9uc1sgaSBdLnRpbWUgPSAwOyAvLyBaZXJvIG91dCB0aW1lIGF0dHJpYnV0ZSBmb3IgYWxsIGFzc29jaWF0ZWQgQW5pbWF0aW9uQWN0aW9uIG9iamVjdHMuXG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy51cGRhdGUoIHRpbWVJblNlY29uZHMgKTsgLy8gVXBkYXRlIHVzZWQgdG8gc2V0IGV4YWN0IHRpbWUuIFJldHVybnMgXCJ0aGlzXCIgQW5pbWF0aW9uTWl4ZXIgb2JqZWN0LlxuXG5cdH1cblxuXHQvLyByZXR1cm4gdGhpcyBtaXhlcidzIHJvb3QgdGFyZ2V0IG9iamVjdFxuXHRnZXRSb290KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3Jvb3Q7XG5cblx0fVxuXG5cdC8vIGZyZWUgYWxsIHJlc291cmNlcyBzcGVjaWZpYyB0byBhIHBhcnRpY3VsYXIgY2xpcFxuXHR1bmNhY2hlQ2xpcCggY2xpcCApIHtcblxuXHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0Y2xpcFV1aWQgPSBjbGlwLnV1aWQsXG5cdFx0XHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcCxcblx0XHRcdGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcblxuXHRcdGlmICggYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gbm90ZToganVzdCBjYWxsaW5nIF9yZW1vdmVJbmFjdGl2ZUFjdGlvbiB3b3VsZCBtZXNzIHVwIHRoZVxuXHRcdFx0Ly8gaXRlcmF0aW9uIHN0YXRlIGFuZCBhbHNvIHJlcXVpcmUgdXBkYXRpbmcgdGhlIHN0YXRlIHdlIGNhblxuXHRcdFx0Ly8ganVzdCB0aHJvdyBhd2F5XG5cblx0XHRcdGNvbnN0IGFjdGlvbnNUb1JlbW92ZSA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucztcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gYWN0aW9uc1RvUmVtb3ZlLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHRjb25zdCBhY3Rpb24gPSBhY3Rpb25zVG9SZW1vdmVbIGkgXTtcblxuXHRcdFx0XHR0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKCBhY3Rpb24gKTtcblxuXHRcdFx0XHRjb25zdCBjYWNoZUluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxuXHRcdFx0XHRcdGxhc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGFjdGlvbnMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XG5cdFx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XG5cblx0XHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcblx0XHRcdFx0YWN0aW9uc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQWN0aW9uO1xuXHRcdFx0XHRhY3Rpb25zLnBvcCgpO1xuXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oIGFjdGlvbiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRlbGV0ZSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBmcmVlIGFsbCByZXNvdXJjZXMgc3BlY2lmaWMgdG8gYSBwYXJ0aWN1bGFyIHJvb3QgdGFyZ2V0IG9iamVjdFxuXHR1bmNhY2hlUm9vdCggcm9vdCApIHtcblxuXHRcdGNvbnN0IHJvb3RVdWlkID0gcm9vdC51dWlkLFxuXHRcdFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXA7XG5cblx0XHRmb3IgKCBjb25zdCBjbGlwVXVpZCBpbiBhY3Rpb25zQnlDbGlwICkge1xuXG5cdFx0XHRjb25zdCBhY3Rpb25CeVJvb3QgPSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdLmFjdGlvbkJ5Um9vdCxcblx0XHRcdFx0YWN0aW9uID0gYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xuXG5cdFx0XHRpZiAoIGFjdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oIGFjdGlvbiApO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUFjdGlvbiggYWN0aW9uICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxuXHRcdFx0YmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdO1xuXG5cdFx0aWYgKCBiaW5kaW5nQnlOYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIGNvbnN0IHRyYWNrTmFtZSBpbiBiaW5kaW5nQnlOYW1lICkge1xuXG5cdFx0XHRcdGNvbnN0IGJpbmRpbmcgPSBiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXTtcblx0XHRcdFx0YmluZGluZy5yZXN0b3JlT3JpZ2luYWxTdGF0ZSgpO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyByZW1vdmUgYSB0YXJnZXRlZCBjbGlwIGZyb20gdGhlIGNhY2hlXG5cdHVuY2FjaGVBY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCApIHtcblxuXHRcdGNvbnN0IGFjdGlvbiA9IHRoaXMuZXhpc3RpbmdBY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCApO1xuXG5cdFx0aWYgKCBhY3Rpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oIGFjdGlvbiApO1xuXHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5jbGFzcyBSZW5kZXJUYXJnZXQzRCBleHRlbmRzIFJlbmRlclRhcmdldCB7XG5cblx0Y29uc3RydWN0b3IoIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgZGVwdGggPSAxLCBvcHRpb25zID0ge30gKSB7XG5cblx0XHRzdXBlciggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApO1xuXG5cdFx0dGhpcy5pc1JlbmRlclRhcmdldDNEID0gdHJ1ZTtcblxuXHRcdHRoaXMuZGVwdGggPSBkZXB0aDtcblxuXHRcdHRoaXMudGV4dHVyZSA9IG5ldyBEYXRhM0RUZXh0dXJlKCBudWxsLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCApO1xuXG5cdFx0dGhpcy50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XG5cblx0fVxuXG59XG5cbmNsYXNzIFJlbmRlclRhcmdldEFycmF5IGV4dGVuZHMgUmVuZGVyVGFyZ2V0IHtcblxuXHRjb25zdHJ1Y3Rvciggd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBkZXB0aCA9IDEsIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdHN1cGVyKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICk7XG5cblx0XHR0aGlzLmlzUmVuZGVyVGFyZ2V0QXJyYXkgPSB0cnVlO1xuXG5cdFx0dGhpcy5kZXB0aCA9IGRlcHRoO1xuXG5cdFx0dGhpcy50ZXh0dXJlID0gbmV3IERhdGFBcnJheVRleHR1cmUoIG51bGwsIHdpZHRoLCBoZWlnaHQsIGRlcHRoICk7XG5cblx0XHR0aGlzLnRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gdHJ1ZTtcblxuXHR9XG5cbn1cblxuY2xhc3MgVW5pZm9ybSB7XG5cblx0Y29uc3RydWN0b3IoIHZhbHVlICkge1xuXG5cdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgVW5pZm9ybSggdGhpcy52YWx1ZS5jbG9uZSA9PT0gdW5kZWZpbmVkID8gdGhpcy52YWx1ZSA6IHRoaXMudmFsdWUuY2xvbmUoKSApO1xuXG5cdH1cblxufVxuXG5sZXQgX2lkID0gMDtcblxuY2xhc3MgVW5pZm9ybXNHcm91cCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc1VuaWZvcm1zR3JvdXAgPSB0cnVlO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBfaWQgKysgfSApO1xuXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cblx0XHR0aGlzLnVzYWdlID0gU3RhdGljRHJhd1VzYWdlO1xuXHRcdHRoaXMudW5pZm9ybXMgPSBbXTtcblxuXHR9XG5cblx0YWRkKCB1bmlmb3JtICkge1xuXG5cdFx0dGhpcy51bmlmb3Jtcy5wdXNoKCB1bmlmb3JtICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmVtb3ZlKCB1bmlmb3JtICkge1xuXG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLnVuaWZvcm1zLmluZGV4T2YoIHVuaWZvcm0gKTtcblxuXHRcdGlmICggaW5kZXggIT09IC0gMSApIHRoaXMudW5pZm9ybXMuc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldE5hbWUoIG5hbWUgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFVzYWdlKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMudXNhZ2UgPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG5cdFx0dGhpcy51c2FnZSA9IHNvdXJjZS51c2FnZTtcblxuXHRcdGNvbnN0IHVuaWZvcm1zU291cmNlID0gc291cmNlLnVuaWZvcm1zO1xuXG5cdFx0dGhpcy51bmlmb3Jtcy5sZW5ndGggPSAwO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdW5pZm9ybXNTb3VyY2UubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBBcnJheS5pc0FycmF5KCB1bmlmb3Jtc1NvdXJjZVsgaSBdICkgPyB1bmlmb3Jtc1NvdXJjZVsgaSBdIDogWyB1bmlmb3Jtc1NvdXJjZVsgaSBdIF07XG5cblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IHVuaWZvcm1zLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHR0aGlzLnVuaWZvcm1zLnB1c2goIHVuaWZvcm1zWyBqIF0uY2xvbmUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyIGV4dGVuZHMgSW50ZXJsZWF2ZWRCdWZmZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgc3RyaWRlLCBtZXNoUGVyQXR0cmlidXRlID0gMSApIHtcblxuXHRcdHN1cGVyKCBhcnJheSwgc3RyaWRlICk7XG5cblx0XHR0aGlzLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgPSB0cnVlO1xuXG5cdFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSggZGF0YSApIHtcblxuXHRcdGNvbnN0IGliID0gc3VwZXIuY2xvbmUoIGRhdGEgKTtcblxuXHRcdGliLm1lc2hQZXJBdHRyaWJ1dGUgPSB0aGlzLm1lc2hQZXJBdHRyaWJ1dGU7XG5cblx0XHRyZXR1cm4gaWI7XG5cblx0fVxuXG5cdHRvSlNPTiggZGF0YSApIHtcblxuXHRcdGNvbnN0IGpzb24gPSBzdXBlci50b0pTT04oIGRhdGEgKTtcblxuXHRcdGpzb24uaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IHRydWU7XG5cdFx0anNvbi5tZXNoUGVyQXR0cmlidXRlID0gdGhpcy5tZXNoUGVyQXR0cmlidXRlO1xuXG5cdFx0cmV0dXJuIGpzb247XG5cblx0fVxuXG59XG5cbmNsYXNzIEdMQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYnVmZmVyLCB0eXBlLCBpdGVtU2l6ZSwgZWxlbWVudFNpemUsIGNvdW50ICkge1xuXG5cdFx0dGhpcy5pc0dMQnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcblxuXHRcdHRoaXMubmFtZSA9ICcnO1xuXG5cdFx0dGhpcy5idWZmZXIgPSBidWZmZXI7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XG5cdFx0dGhpcy5lbGVtZW50U2l6ZSA9IGVsZW1lbnRTaXplO1xuXHRcdHRoaXMuY291bnQgPSBjb3VudDtcblxuXHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cblx0fVxuXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xuXG5cdH1cblxuXHRzZXRCdWZmZXIoIGJ1ZmZlciApIHtcblxuXHRcdHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFR5cGUoIHR5cGUsIGVsZW1lbnRTaXplICkge1xuXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLmVsZW1lbnRTaXplID0gZWxlbWVudFNpemU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0SXRlbVNpemUoIGl0ZW1TaXplICkge1xuXG5cdFx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldENvdW50KCBjb3VudCApIHtcblxuXHRcdHRoaXMuY291bnQgPSBjb3VudDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jb25zdCBfbWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuXG5jbGFzcyBSYXljYXN0ZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBvcmlnaW4sIGRpcmVjdGlvbiwgbmVhciA9IDAsIGZhciA9IEluZmluaXR5ICkge1xuXG5cdFx0dGhpcy5yYXkgPSBuZXcgUmF5KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xuXHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cblx0XHR0aGlzLm5lYXIgPSBuZWFyO1xuXHRcdHRoaXMuZmFyID0gZmFyO1xuXHRcdHRoaXMuY2FtZXJhID0gbnVsbDtcblx0XHR0aGlzLmxheWVycyA9IG5ldyBMYXllcnMoKTtcblxuXHRcdHRoaXMucGFyYW1zID0ge1xuXHRcdFx0TWVzaDoge30sXG5cdFx0XHRMaW5lOiB7IHRocmVzaG9sZDogMSB9LFxuXHRcdFx0TE9EOiB7fSxcblx0XHRcdFBvaW50czogeyB0aHJlc2hvbGQ6IDEgfSxcblx0XHRcdFNwcml0ZToge31cblx0XHR9O1xuXG5cdH1cblxuXHRzZXQoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xuXG5cdFx0Ly8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcblxuXHRcdHRoaXMucmF5LnNldCggb3JpZ2luLCBkaXJlY3Rpb24gKTtcblxuXHR9XG5cblx0c2V0RnJvbUNhbWVyYSggY29vcmRzLCBjYW1lcmEgKSB7XG5cblx0XHRpZiAoIGNhbWVyYS5pc1BlcnNwZWN0aXZlQ2FtZXJhICkge1xuXG5cdFx0XHR0aGlzLnJheS5vcmlnaW4uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblx0XHRcdHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgMC41ICkudW5wcm9qZWN0KCBjYW1lcmEgKS5zdWIoIHRoaXMucmF5Lm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cblx0XHR9IGVsc2UgaWYgKCBjYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEgKSB7XG5cblx0XHRcdHRoaXMucmF5Lm9yaWdpbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgKCBjYW1lcmEubmVhciArIGNhbWVyYS5mYXIgKSAvICggY2FtZXJhLm5lYXIgLSBjYW1lcmEuZmFyICkgKS51bnByb2plY3QoIGNhbWVyYSApOyAvLyBzZXQgb3JpZ2luIGluIHBsYW5lIG9mIGNhbWVyYVxuXHRcdFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldCggMCwgMCwgLSAxICkudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblx0XHRcdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlJheWNhc3RlcjogVW5zdXBwb3J0ZWQgY2FtZXJhIHR5cGU6ICcgKyBjYW1lcmEudHlwZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXRGcm9tWFJDb250cm9sbGVyKCBjb250cm9sbGVyICkge1xuXG5cdFx0X21hdHJpeC5pZGVudGl0eSgpLmV4dHJhY3RSb3RhdGlvbiggY29udHJvbGxlci5tYXRyaXhXb3JsZCApO1xuXG5cdFx0dGhpcy5yYXkub3JpZ2luLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY29udHJvbGxlci5tYXRyaXhXb3JsZCApO1xuXHRcdHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIDAsIDAsIC0gMSApLmFwcGx5TWF0cml4NCggX21hdHJpeCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGludGVyc2VjdE9iamVjdCggb2JqZWN0LCByZWN1cnNpdmUgPSB0cnVlLCBpbnRlcnNlY3RzID0gW10gKSB7XG5cblx0XHRpbnRlcnNlY3QoIG9iamVjdCwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XG5cblx0XHRpbnRlcnNlY3RzLnNvcnQoIGFzY1NvcnQgKTtcblxuXHRcdHJldHVybiBpbnRlcnNlY3RzO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RPYmplY3RzKCBvYmplY3RzLCByZWN1cnNpdmUgPSB0cnVlLCBpbnRlcnNlY3RzID0gW10gKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGludGVyc2VjdCggb2JqZWN0c1sgaSBdLCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcblxuXHRcdH1cblxuXHRcdGludGVyc2VjdHMuc29ydCggYXNjU29ydCApO1xuXG5cdFx0cmV0dXJuIGludGVyc2VjdHM7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIGFzY1NvcnQoIGEsIGIgKSB7XG5cblx0cmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuXG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdCggb2JqZWN0LCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApIHtcblxuXHRsZXQgcHJvcGFnYXRlID0gdHJ1ZTtcblxuXHRpZiAoIG9iamVjdC5sYXllcnMudGVzdCggcmF5Y2FzdGVyLmxheWVycyApICkge1xuXG5cdFx0Y29uc3QgcmVzdWx0ID0gb2JqZWN0LnJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xuXG5cdFx0aWYgKCByZXN1bHQgPT09IGZhbHNlICkgcHJvcGFnYXRlID0gZmFsc2U7XG5cblx0fVxuXG5cdGlmICggcHJvcGFnYXRlID09PSB0cnVlICYmIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdGNvbnN0IGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0aW50ZXJzZWN0KCBjaGlsZHJlblsgaSBdLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHRydWUgKTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuLyoqXG4gKiBSZWY6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwaGVyaWNhbF9jb29yZGluYXRlX3N5c3RlbVxuICpcbiAqIHBoaSAodGhlIHBvbGFyIGFuZ2xlKSBpcyBtZWFzdXJlZCBmcm9tIHRoZSBwb3NpdGl2ZSB5LWF4aXMuIFRoZSBwb3NpdGl2ZSB5LWF4aXMgaXMgdXAuXG4gKiB0aGV0YSAodGhlIGF6aW11dGhhbCBhbmdsZSkgaXMgbWVhc3VyZWQgZnJvbSB0aGUgcG9zaXRpdmUgei1heGlzLlxuICovXG5jbGFzcyBTcGhlcmljYWwge1xuXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCBwaGkgPSAwLCB0aGV0YSA9IDAgKSB7XG5cblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0XHR0aGlzLnBoaSA9IHBoaTsgLy8gcG9sYXIgYW5nbGVcblx0XHR0aGlzLnRoZXRhID0gdGhldGE7IC8vIGF6aW11dGhhbCBhbmdsZVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldCggcmFkaXVzLCBwaGksIHRoZXRhICkge1xuXG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdFx0dGhpcy5waGkgPSBwaGk7XG5cdFx0dGhpcy50aGV0YSA9IHRoZXRhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHkoIG90aGVyICkge1xuXG5cdFx0dGhpcy5yYWRpdXMgPSBvdGhlci5yYWRpdXM7XG5cdFx0dGhpcy5waGkgPSBvdGhlci5waGk7XG5cdFx0dGhpcy50aGV0YSA9IG90aGVyLnRoZXRhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWVuIEVQUyBhbmQgUEktRVBTXG5cdG1ha2VTYWZlKCkge1xuXG5cdFx0Y29uc3QgRVBTID0gMC4wMDAwMDE7XG5cdFx0dGhpcy5waGkgPSBjbGFtcCggdGhpcy5waGksIEVQUywgTWF0aC5QSSAtIEVQUyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21WZWN0b3IzKCB2ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbUNhcnRlc2lhbkNvb3Jkcyggdi54LCB2LnksIHYueiApO1xuXG5cdH1cblxuXHRzZXRGcm9tQ2FydGVzaWFuQ29vcmRzKCB4LCB5LCB6ICkge1xuXG5cdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIHggKiB4ICsgeSAqIHkgKyB6ICogeiApO1xuXG5cdFx0aWYgKCB0aGlzLnJhZGl1cyA9PT0gMCApIHtcblxuXHRcdFx0dGhpcy50aGV0YSA9IDA7XG5cdFx0XHR0aGlzLnBoaSA9IDA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnRoZXRhID0gTWF0aC5hdGFuMiggeCwgeiApO1xuXHRcdFx0dGhpcy5waGkgPSBNYXRoLmFjb3MoIGNsYW1wKCB5IC8gdGhpcy5yYWRpdXMsIC0gMSwgMSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59XG5cbi8qKlxuICogUmVmOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DeWxpbmRyaWNhbF9jb29yZGluYXRlX3N5c3RlbVxuICovXG5cbmNsYXNzIEN5bGluZHJpY2FsIHtcblxuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgdGhldGEgPSAwLCB5ID0gMCApIHtcblxuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzOyAvLyBkaXN0YW5jZSBmcm9tIHRoZSBvcmlnaW4gdG8gYSBwb2ludCBpbiB0aGUgeC16IHBsYW5lXG5cdFx0dGhpcy50aGV0YSA9IHRoZXRhOyAvLyBjb3VudGVyY2xvY2t3aXNlIGFuZ2xlIGluIHRoZSB4LXogcGxhbmUgbWVhc3VyZWQgaW4gcmFkaWFucyBmcm9tIHRoZSBwb3NpdGl2ZSB6LWF4aXNcblx0XHR0aGlzLnkgPSB5OyAvLyBoZWlnaHQgYWJvdmUgdGhlIHgteiBwbGFuZVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldCggcmFkaXVzLCB0aGV0YSwgeSApIHtcblxuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXHRcdHRoaXMudGhldGEgPSB0aGV0YTtcblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHkoIG90aGVyICkge1xuXG5cdFx0dGhpcy5yYWRpdXMgPSBvdGhlci5yYWRpdXM7XG5cdFx0dGhpcy50aGV0YSA9IG90aGVyLnRoZXRhO1xuXHRcdHRoaXMueSA9IG90aGVyLnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVZlY3RvcjMoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tQ2FydGVzaWFuQ29vcmRzKCB2LngsIHYueSwgdi56ICk7XG5cblx0fVxuXG5cdHNldEZyb21DYXJ0ZXNpYW5Db29yZHMoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnJhZGl1cyA9IE1hdGguc3FydCggeCAqIHggKyB6ICogeiApO1xuXHRcdHRoaXMudGhldGEgPSBNYXRoLmF0YW4yKCB4LCB6ICk7XG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgTWF0cml4MiB7XG5cblx0Y29uc3RydWN0b3IoIG4xMSwgbjEyLCBuMjEsIG4yMiApIHtcblxuXHRcdE1hdHJpeDIucHJvdG90eXBlLmlzTWF0cml4MiA9IHRydWU7XG5cblx0XHR0aGlzLmVsZW1lbnRzID0gW1xuXHRcdFx0MSwgMCxcblx0XHRcdDAsIDEsXG5cdFx0XTtcblxuXHRcdGlmICggbjExICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuc2V0KCBuMTEsIG4xMiwgbjIxLCBuMjIgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0aWRlbnRpdHkoKSB7XG5cblx0XHR0aGlzLnNldChcblx0XHRcdDEsIDAsXG5cdFx0XHQwLCAxLFxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZWxlbWVudHNbIGkgXSA9IGFycmF5WyBpICsgb2Zmc2V0IF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0KCBuMTEsIG4xMiwgbjIxLCBuMjIgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgMiBdID0gbjEyO1xuXHRcdHRlWyAxIF0gPSBuMjE7IHRlWyAzIF0gPSBuMjI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY29uc3QgX3ZlY3RvciQ0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMigpO1xuXG5jbGFzcyBCb3gyIHtcblxuXHRjb25zdHJ1Y3RvciggbWluID0gbmV3IFZlY3RvcjIoICsgSW5maW5pdHksICsgSW5maW5pdHkgKSwgbWF4ID0gbmV3IFZlY3RvcjIoIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKSApIHtcblxuXHRcdHRoaXMuaXNCb3gyID0gdHJ1ZTtcblxuXHRcdHRoaXMubWluID0gbWluO1xuXHRcdHRoaXMubWF4ID0gbWF4O1xuXG5cdH1cblxuXHRzZXQoIG1pbiwgbWF4ICkge1xuXG5cdFx0dGhpcy5taW4uY29weSggbWluICk7XG5cdFx0dGhpcy5tYXguY29weSggbWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVBvaW50cyggcG9pbnRzICkge1xuXG5cdFx0dGhpcy5tYWtlRW1wdHkoKTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tQ2VudGVyQW5kU2l6ZSggY2VudGVyLCBzaXplICkge1xuXG5cdFx0Y29uc3QgaGFsZlNpemUgPSBfdmVjdG9yJDQuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblx0XHR0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XG5cdFx0dGhpcy5tYXguY29weSggY2VudGVyICkuYWRkKCBoYWxmU2l6ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxuXHRjb3B5KCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XG5cdFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VFbXB0eSgpIHtcblxuXHRcdHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gKyBJbmZpbml0eTtcblx0XHR0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IC0gSW5maW5pdHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aXNFbXB0eSgpIHtcblxuXHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXG5cblx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKTtcblxuXHR9XG5cblx0Z2V0Q2VudGVyKCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0YXJnZXQuc2V0KCAwLCAwICkgOiB0YXJnZXQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG5cdH1cblxuXHRnZXRTaXplKCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0YXJnZXQuc2V0KCAwLCAwICkgOiB0YXJnZXQuc3ViVmVjdG9ycyggdGhpcy5tYXgsIHRoaXMubWluICk7XG5cblx0fVxuXG5cdGV4cGFuZEJ5UG9pbnQoIHBvaW50ICkge1xuXG5cdFx0dGhpcy5taW4ubWluKCBwb2ludCApO1xuXHRcdHRoaXMubWF4Lm1heCggcG9pbnQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHBhbmRCeVZlY3RvciggdmVjdG9yICkge1xuXG5cdFx0dGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcblx0XHR0aGlzLm1heC5hZGQoIHZlY3RvciApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGV4cGFuZEJ5U2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLm1pbi5hZGRTY2FsYXIoIC0gc2NhbGFyICk7XG5cdFx0dGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb250YWluc1BvaW50KCBwb2ludCApIHtcblxuXHRcdHJldHVybiBwb2ludC54ID49IHRoaXMubWluLnggJiYgcG9pbnQueCA8PSB0aGlzLm1heC54ICYmXG5cdFx0XHRwb2ludC55ID49IHRoaXMubWluLnkgJiYgcG9pbnQueSA8PSB0aGlzLm1heC55O1xuXG5cdH1cblxuXHRjb250YWluc0JveCggYm94ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICYmIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICYmXG5cdFx0XHR0aGlzLm1pbi55IDw9IGJveC5taW4ueSAmJiBib3gubWF4LnkgPD0gdGhpcy5tYXgueTtcblxuXHR9XG5cblx0Z2V0UGFyYW1ldGVyKCBwb2ludCwgdGFyZ2V0ICkge1xuXG5cdFx0Ly8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcblx0XHQvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxuXG5cdFx0cmV0dXJuIHRhcmdldC5zZXQoXG5cdFx0XHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXG5cdFx0XHQoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55IClcblx0XHQpO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHQvLyB1c2luZyA0IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9uc1xuXG5cdFx0cmV0dXJuIGJveC5tYXgueCA+PSB0aGlzLm1pbi54ICYmIGJveC5taW4ueCA8PSB0aGlzLm1heC54ICYmXG5cdFx0XHRib3gubWF4LnkgPj0gdGhpcy5taW4ueSAmJiBib3gubWluLnkgPD0gdGhpcy5tYXgueTtcblxuXHR9XG5cblx0Y2xhbXBQb2ludCggcG9pbnQsIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0YXJnZXQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jbGFtcFBvaW50KCBwb2ludCwgX3ZlY3RvciQ0ICkuZGlzdGFuY2VUbyggcG9pbnQgKTtcblxuXHR9XG5cblx0aW50ZXJzZWN0KCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcblxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHVuaW9uKCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2xhdGUoIG9mZnNldCApIHtcblxuXHRcdHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XG5cdFx0dGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlcXVhbHMoIGJveCApIHtcblxuXHRcdHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcblxuXHR9XG5cbn1cblxuY29uc3QgX3N0YXJ0UCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9zdGFydEVuZCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY2xhc3MgTGluZTMge1xuXG5cdGNvbnN0cnVjdG9yKCBzdGFydCA9IG5ldyBWZWN0b3IzKCksIGVuZCA9IG5ldyBWZWN0b3IzKCkgKSB7XG5cblx0XHR0aGlzLnN0YXJ0ID0gc3RhcnQ7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cblx0fVxuXG5cdHNldCggc3RhcnQsIGVuZCApIHtcblxuXHRcdHRoaXMuc3RhcnQuY29weSggc3RhcnQgKTtcblx0XHR0aGlzLmVuZC5jb3B5KCBlbmQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb3B5KCBsaW5lICkge1xuXG5cdFx0dGhpcy5zdGFydC5jb3B5KCBsaW5lLnN0YXJ0ICk7XG5cdFx0dGhpcy5lbmQuY29weSggbGluZS5lbmQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRDZW50ZXIoIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0YXJnZXQuYWRkVmVjdG9ycyggdGhpcy5zdGFydCwgdGhpcy5lbmQgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cblx0fVxuXG5cdGRlbHRhKCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnN1YlZlY3RvcnMoIHRoaXMuZW5kLCB0aGlzLnN0YXJ0ICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlU3EoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5lbmQgKTtcblxuXHR9XG5cblx0ZGlzdGFuY2UoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvKCB0aGlzLmVuZCApO1xuXG5cdH1cblxuXHRhdCggdCwgdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGVsdGEoIHRhcmdldCApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnN0YXJ0ICk7XG5cblx0fVxuXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXIoIHBvaW50LCBjbGFtcFRvTGluZSApIHtcblxuXHRcdF9zdGFydFAuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMuc3RhcnQgKTtcblx0XHRfc3RhcnRFbmQuc3ViVmVjdG9ycyggdGhpcy5lbmQsIHRoaXMuc3RhcnQgKTtcblxuXHRcdGNvbnN0IHN0YXJ0RW5kMiA9IF9zdGFydEVuZC5kb3QoIF9zdGFydEVuZCApO1xuXHRcdGNvbnN0IHN0YXJ0RW5kX3N0YXJ0UCA9IF9zdGFydEVuZC5kb3QoIF9zdGFydFAgKTtcblxuXHRcdGxldCB0ID0gc3RhcnRFbmRfc3RhcnRQIC8gc3RhcnRFbmQyO1xuXG5cdFx0aWYgKCBjbGFtcFRvTGluZSApIHtcblxuXHRcdFx0dCA9IGNsYW1wKCB0LCAwLCAxICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdDtcblxuXHR9XG5cblx0Y2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIGNsYW1wVG9MaW5lLCB0YXJnZXQgKSB7XG5cblx0XHRjb25zdCB0ID0gdGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKCBwb2ludCwgY2xhbXBUb0xpbmUgKTtcblxuXHRcdHJldHVybiB0aGlzLmRlbHRhKCB0YXJnZXQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDQoIG1hdHJpeCApIHtcblxuXHRcdHRoaXMuc3RhcnQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblx0XHR0aGlzLmVuZC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVxdWFscyggbGluZSApIHtcblxuXHRcdHJldHVybiBsaW5lLnN0YXJ0LmVxdWFscyggdGhpcy5zdGFydCApICYmIGxpbmUuZW5kLmVxdWFscyggdGhpcy5lbmQgKTtcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59XG5cbmNvbnN0IF92ZWN0b3IkMyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY2xhc3MgU3BvdExpZ2h0SGVscGVyIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdGNvbnN0cnVjdG9yKCBsaWdodCwgY29sb3IgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLmNvbG9yID0gY29sb3I7XG5cblx0XHR0aGlzLnR5cGUgPSAnU3BvdExpZ2h0SGVscGVyJztcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRjb25zdCBwb3NpdGlvbnMgPSBbXG5cdFx0XHQwLCAwLCAwLCBcdDAsIDAsIDEsXG5cdFx0XHQwLCAwLCAwLCBcdDEsIDAsIDEsXG5cdFx0XHQwLCAwLCAwLFx0LSAxLCAwLCAxLFxuXHRcdFx0MCwgMCwgMCwgXHQwLCAxLCAxLFxuXHRcdFx0MCwgMCwgMCwgXHQwLCAtIDEsIDFcblx0XHRdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBqID0gMSwgbCA9IDMyOyBpIDwgbDsgaSArKywgaiArKyApIHtcblxuXHRcdFx0Y29uc3QgcDEgPSAoIGkgLyBsICkgKiBNYXRoLlBJICogMjtcblx0XHRcdGNvbnN0IHAyID0gKCBqIC8gbCApICogTWF0aC5QSSAqIDI7XG5cblx0XHRcdHBvc2l0aW9ucy5wdXNoKFxuXHRcdFx0XHRNYXRoLmNvcyggcDEgKSwgTWF0aC5zaW4oIHAxICksIDEsXG5cdFx0XHRcdE1hdGguY29zKCBwMiApLCBNYXRoLnNpbiggcDIgKSwgMVxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG5cblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlLCB0b25lTWFwcGVkOiBmYWxzZSB9ICk7XG5cblx0XHR0aGlzLmNvbmUgPSBuZXcgTGluZVNlZ21lbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0XHR0aGlzLmFkZCggdGhpcy5jb25lICk7XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5jb25lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH1cblxuXHR1cGRhdGUoKSB7XG5cblx0XHR0aGlzLmxpZ2h0LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXHRcdHRoaXMubGlnaHQudGFyZ2V0LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0Ly8gdXBkYXRlIHRoZSBsb2NhbCBtYXRyaXggYmFzZWQgb24gdGhlIHBhcmVudCBhbmQgbGlnaHQgdGFyZ2V0IHRyYW5zZm9ybXNcblx0XHRpZiAoIHRoaXMucGFyZW50ICkge1xuXG5cdFx0XHR0aGlzLnBhcmVudC51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSApO1xuXG5cdFx0XHR0aGlzLm1hdHJpeFxuXHRcdFx0XHQuY29weSggdGhpcy5wYXJlbnQubWF0cml4V29ybGQgKVxuXHRcdFx0XHQuaW52ZXJ0KClcblx0XHRcdFx0Lm11bHRpcGx5KCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLm1hdHJpeC5jb3B5KCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcblxuXHRcdGNvbnN0IGNvbmVMZW5ndGggPSB0aGlzLmxpZ2h0LmRpc3RhbmNlID8gdGhpcy5saWdodC5kaXN0YW5jZSA6IDEwMDA7XG5cdFx0Y29uc3QgY29uZVdpZHRoID0gY29uZUxlbmd0aCAqIE1hdGgudGFuKCB0aGlzLmxpZ2h0LmFuZ2xlICk7XG5cblx0XHR0aGlzLmNvbmUuc2NhbGUuc2V0KCBjb25lV2lkdGgsIGNvbmVXaWR0aCwgY29uZUxlbmd0aCApO1xuXG5cdFx0X3ZlY3RvciQzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcblxuXHRcdHRoaXMuY29uZS5sb29rQXQoIF92ZWN0b3IkMyApO1xuXG5cdFx0aWYgKCB0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmNvbnN0IF92ZWN0b3IkMiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9ib25lTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX21hdHJpeFdvcmxkSW52ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuXG5cbmNsYXNzIFNrZWxldG9uSGVscGVyIGV4dGVuZHMgTGluZVNlZ21lbnRzIHtcblxuXHRjb25zdHJ1Y3Rvciggb2JqZWN0ICkge1xuXG5cdFx0Y29uc3QgYm9uZXMgPSBnZXRCb25lTGlzdCggb2JqZWN0ICk7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBjb2xvcnMgPSBbXTtcblxuXHRcdGNvbnN0IGNvbG9yMSA9IG5ldyBDb2xvciggMCwgMCwgMSApO1xuXHRcdGNvbnN0IGNvbG9yMiA9IG5ldyBDb2xvciggMCwgMSwgMCApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBib25lID0gYm9uZXNbIGkgXTtcblxuXHRcdFx0aWYgKCBib25lLnBhcmVudCAmJiBib25lLnBhcmVudC5pc0JvbmUgKSB7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCAwLCAwLCAwICk7XG5cdFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvcjEuciwgY29sb3IxLmcsIGNvbG9yMS5iICk7XG5cdFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvcjIuciwgY29sb3IyLmcsIGNvbG9yMi5iICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiB0cnVlLCBkZXB0aFRlc3Q6IGZhbHNlLCBkZXB0aFdyaXRlOiBmYWxzZSwgdG9uZU1hcHBlZDogZmFsc2UsIHRyYW5zcGFyZW50OiB0cnVlIH0gKTtcblxuXHRcdHN1cGVyKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdHRoaXMuaXNTa2VsZXRvbkhlbHBlciA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnU2tlbGV0b25IZWxwZXInO1xuXG5cdFx0dGhpcy5yb290ID0gb2JqZWN0O1xuXHRcdHRoaXMuYm9uZXMgPSBib25lcztcblxuXHRcdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdH1cblxuXHR1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XG5cblx0XHRjb25zdCBib25lcyA9IHRoaXMuYm9uZXM7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblxuXHRcdF9tYXRyaXhXb3JsZEludi5jb3B5KCB0aGlzLnJvb3QubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaiA9IDA7IGkgPCBib25lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGJvbmUgPSBib25lc1sgaSBdO1xuXG5cdFx0XHRpZiAoIGJvbmUucGFyZW50ICYmIGJvbmUucGFyZW50LmlzQm9uZSApIHtcblxuXHRcdFx0XHRfYm9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBfbWF0cml4V29ybGRJbnYsIGJvbmUubWF0cml4V29ybGQgKTtcblx0XHRcdFx0X3ZlY3RvciQyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggX2JvbmVNYXRyaXggKTtcblx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBqLCBfdmVjdG9yJDIueCwgX3ZlY3RvciQyLnksIF92ZWN0b3IkMi56ICk7XG5cblx0XHRcdFx0X2JvbmVNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggX21hdHJpeFdvcmxkSW52LCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRfdmVjdG9yJDIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBfYm9uZU1hdHJpeCApO1xuXHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGogKyAxLCBfdmVjdG9yJDIueCwgX3ZlY3RvciQyLnksIF92ZWN0b3IkMi56ICk7XG5cblx0XHRcdFx0aiArPSAyO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH1cblxufVxuXG5cbmZ1bmN0aW9uIGdldEJvbmVMaXN0KCBvYmplY3QgKSB7XG5cblx0Y29uc3QgYm9uZUxpc3QgPSBbXTtcblxuXHRpZiAoIG9iamVjdC5pc0JvbmUgPT09IHRydWUgKSB7XG5cblx0XHRib25lTGlzdC5wdXNoKCBvYmplY3QgKTtcblxuXHR9XG5cblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdGJvbmVMaXN0LnB1c2guYXBwbHkoIGJvbmVMaXN0LCBnZXRCb25lTGlzdCggb2JqZWN0LmNoaWxkcmVuWyBpIF0gKSApO1xuXG5cdH1cblxuXHRyZXR1cm4gYm9uZUxpc3Q7XG5cbn1cblxuY2xhc3MgUG9pbnRMaWdodEhlbHBlciBleHRlbmRzIE1lc2gge1xuXG5cdGNvbnN0cnVjdG9yKCBsaWdodCwgc3BoZXJlU2l6ZSwgY29sb3IgKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBTcGhlcmVHZW9tZXRyeSggc3BoZXJlU2l6ZSwgNCwgMiApO1xuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IHdpcmVmcmFtZTogdHJ1ZSwgZm9nOiBmYWxzZSwgdG9uZU1hcHBlZDogZmFsc2UgfSApO1xuXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXG5cdFx0dGhpcy5jb2xvciA9IGNvbG9yO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BvaW50TGlnaHRIZWxwZXInO1xuXG5cdFx0dGhpcy5tYXRyaXggPSB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkO1xuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy51cGRhdGUoKTtcblxuXG5cdFx0Lypcblx0Ly8gVE9ETzogZGVsZXRlIHRoaXMgY29tbWVudD9cblx0Y29uc3QgZGlzdGFuY2VHZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KCAxLCAyICk7XG5cdGNvbnN0IGRpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCBmb2c6IGZhbHNlLCB3aXJlZnJhbWU6IHRydWUsIG9wYWNpdHk6IDAuMSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xuXG5cdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBidWxiTWF0ZXJpYWwgKTtcblx0dGhpcy5saWdodERpc3RhbmNlID0gbmV3IFRIUkVFLk1lc2goIGRpc3RhbmNlR2VvbWV0cnksIGRpc3RhbmNlTWF0ZXJpYWwgKTtcblxuXHRjb25zdCBkID0gbGlnaHQuZGlzdGFuY2U7XG5cblx0aWYgKCBkID09PSAwLjAgKSB7XG5cblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuXG5cdH0gZWxzZSB7XG5cblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XG5cblx0fVxuXG5cdHRoaXMuYWRkKCB0aGlzLmxpZ2h0RGlzdGFuY2UgKTtcblx0Ki9cblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH1cblxuXHR1cGRhdGUoKSB7XG5cblx0XHR0aGlzLmxpZ2h0LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0aWYgKCB0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMubWF0ZXJpYWwuY29sb3Iuc2V0KCB0aGlzLmNvbG9yICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKTtcblxuXHRcdH1cblxuXHRcdC8qXG5cdFx0Y29uc3QgZCA9IHRoaXMubGlnaHQuZGlzdGFuY2U7XG5cblx0XHRpZiAoIGQgPT09IDAuMCApIHtcblxuXHRcdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gdHJ1ZTtcblx0XHRcdHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcblxuXHRcdH1cblx0XHQqL1xuXG5cdH1cblxufVxuXG5jb25zdCBfdmVjdG9yJDEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfY29sb3IxID0gLypAX19QVVJFX18qLyBuZXcgQ29sb3IoKTtcbmNvbnN0IF9jb2xvcjIgPSAvKkBfX1BVUkVfXyovIG5ldyBDb2xvcigpO1xuXG5jbGFzcyBIZW1pc3BoZXJlTGlnaHRIZWxwZXIgZXh0ZW5kcyBPYmplY3QzRCB7XG5cblx0Y29uc3RydWN0b3IoIGxpZ2h0LCBzaXplLCBjb2xvciApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XG5cblx0XHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5jb2xvciA9IGNvbG9yO1xuXG5cdFx0dGhpcy50eXBlID0gJ0hlbWlzcGhlcmVMaWdodEhlbHBlcic7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBPY3RhaGVkcm9uR2VvbWV0cnkoIHNpemUgKTtcblx0XHRnZW9tZXRyeS5yb3RhdGVZKCBNYXRoLlBJICogMC41ICk7XG5cblx0XHR0aGlzLm1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IHdpcmVmcmFtZTogdHJ1ZSwgZm9nOiBmYWxzZSwgdG9uZU1hcHBlZDogZmFsc2UgfSApO1xuXHRcdGlmICggdGhpcy5jb2xvciA9PT0gdW5kZWZpbmVkICkgdGhpcy5tYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblx0XHRjb25zdCBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBwb3NpdGlvbi5jb3VudCAqIDMgKTtcblxuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuXHRcdHRoaXMuYWRkKCBuZXcgTWVzaCggZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKSApO1xuXG5cdFx0dGhpcy51cGRhdGUoKTtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuY2hpbGRyZW5bIDAgXS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5jaGlsZHJlblsgMCBdLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9XG5cblx0dXBkYXRlKCkge1xuXG5cdFx0Y29uc3QgbWVzaCA9IHRoaXMuY2hpbGRyZW5bIDAgXTtcblxuXHRcdGlmICggdGhpcy5jb2xvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLm1hdGVyaWFsLmNvbG9yLnNldCggdGhpcy5jb2xvciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3QgY29sb3JzID0gbWVzaC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdjb2xvcicgKTtcblxuXHRcdFx0X2NvbG9yMS5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XG5cdFx0XHRfY29sb3IyLmNvcHkoIHRoaXMubGlnaHQuZ3JvdW5kQ29sb3IgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY29sb3JzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjb2xvciA9ICggaSA8ICggbCAvIDIgKSApID8gX2NvbG9yMSA6IF9jb2xvcjI7XG5cblx0XHRcdFx0Y29sb3JzLnNldFhZWiggaSwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbG9ycy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHR0aGlzLmxpZ2h0LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0bWVzaC5sb29rQXQoIF92ZWN0b3IkMS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKS5uZWdhdGUoKSApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBHcmlkSGVscGVyIGV4dGVuZHMgTGluZVNlZ21lbnRzIHtcblxuXHRjb25zdHJ1Y3Rvciggc2l6ZSA9IDEwLCBkaXZpc2lvbnMgPSAxMCwgY29sb3IxID0gMHg0NDQ0NDQsIGNvbG9yMiA9IDB4ODg4ODg4ICkge1xuXG5cdFx0Y29sb3IxID0gbmV3IENvbG9yKCBjb2xvcjEgKTtcblx0XHRjb2xvcjIgPSBuZXcgQ29sb3IoIGNvbG9yMiApO1xuXG5cdFx0Y29uc3QgY2VudGVyID0gZGl2aXNpb25zIC8gMjtcblx0XHRjb25zdCBzdGVwID0gc2l6ZSAvIGRpdmlzaW9ucztcblx0XHRjb25zdCBoYWxmU2l6ZSA9IHNpemUgLyAyO1xuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXSwgY29sb3JzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGogPSAwLCBrID0gLSBoYWxmU2l6ZTsgaSA8PSBkaXZpc2lvbnM7IGkgKyssIGsgKz0gc3RlcCApIHtcblxuXHRcdFx0dmVydGljZXMucHVzaCggLSBoYWxmU2l6ZSwgMCwgaywgaGFsZlNpemUsIDAsIGsgKTtcblx0XHRcdHZlcnRpY2VzLnB1c2goIGssIDAsIC0gaGFsZlNpemUsIGssIDAsIGhhbGZTaXplICk7XG5cblx0XHRcdGNvbnN0IGNvbG9yID0gaSA9PT0gY2VudGVyID8gY29sb3IxIDogY29sb3IyO1xuXG5cdFx0XHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xuXHRcdFx0Y29sb3IudG9BcnJheSggY29sb3JzLCBqICk7IGogKz0gMztcblx0XHRcdGNvbG9yLnRvQXJyYXkoIGNvbG9ycywgaiApOyBqICs9IDM7XG5cdFx0XHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogdHJ1ZSwgdG9uZU1hcHBlZDogZmFsc2UgfSApO1xuXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0dyaWRIZWxwZXInO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFBvbGFyR3JpZEhlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XG5cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEwLCBzZWN0b3JzID0gMTYsIHJpbmdzID0gOCwgZGl2aXNpb25zID0gNjQsIGNvbG9yMSA9IDB4NDQ0NDQ0LCBjb2xvcjIgPSAweDg4ODg4OCApIHtcblxuXHRcdGNvbG9yMSA9IG5ldyBDb2xvciggY29sb3IxICk7XG5cdFx0Y29sb3IyID0gbmV3IENvbG9yKCBjb2xvcjIgKTtcblxuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3QgY29sb3JzID0gW107XG5cblx0XHQvLyBjcmVhdGUgdGhlIHNlY3RvcnNcblxuXHRcdGlmICggc2VjdG9ycyA+IDEgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHNlY3RvcnM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdiA9ICggaSAvIHNlY3RvcnMgKSAqICggTWF0aC5QSSAqIDIgKTtcblxuXHRcdFx0XHRjb25zdCB4ID0gTWF0aC5zaW4oIHYgKSAqIHJhZGl1cztcblx0XHRcdFx0Y29uc3QgeiA9IE1hdGguY29zKCB2ICkgKiByYWRpdXM7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB4LCAwLCB6ICk7XG5cblx0XHRcdFx0Y29uc3QgY29sb3IgPSAoIGkgJiAxICkgPyBjb2xvcjEgOiBjb2xvcjI7XG5cblx0XHRcdFx0Y29sb3JzLnB1c2goIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcblx0XHRcdFx0Y29sb3JzLnB1c2goIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gY3JlYXRlIHRoZSByaW5nc1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcmluZ3M7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGNvbG9yID0gKCBpICYgMSApID8gY29sb3IxIDogY29sb3IyO1xuXG5cdFx0XHRjb25zdCByID0gcmFkaXVzIC0gKCByYWRpdXMgLyByaW5ncyAqIGkgKTtcblxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgZGl2aXNpb25zOyBqICsrICkge1xuXG5cdFx0XHRcdC8vIGZpcnN0IHZlcnRleFxuXG5cdFx0XHRcdGxldCB2ID0gKCBqIC8gZGl2aXNpb25zICkgKiAoIE1hdGguUEkgKiAyICk7XG5cblx0XHRcdFx0bGV0IHggPSBNYXRoLnNpbiggdiApICogcjtcblx0XHRcdFx0bGV0IHogPSBNYXRoLmNvcyggdiApICogcjtcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB4LCAwLCB6ICk7XG5cdFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XG5cblx0XHRcdFx0Ly8gc2Vjb25kIHZlcnRleFxuXG5cdFx0XHRcdHYgPSAoICggaiArIDEgKSAvIGRpdmlzaW9ucyApICogKCBNYXRoLlBJICogMiApO1xuXG5cdFx0XHRcdHggPSBNYXRoLnNpbiggdiApICogcjtcblx0XHRcdFx0eiA9IE1hdGguY29zKCB2ICkgKiByO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHgsIDAsIHogKTtcblx0XHRcdFx0Y29sb3JzLnB1c2goIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogdHJ1ZSwgdG9uZU1hcHBlZDogZmFsc2UgfSApO1xuXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BvbGFyR3JpZEhlbHBlcic7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9XG5cbn1cblxuY29uc3QgX3YxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YzID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBEaXJlY3Rpb25hbExpZ2h0SGVscGVyIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdGNvbnN0cnVjdG9yKCBsaWdodCwgc2l6ZSwgY29sb3IgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXG5cdFx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdHRoaXMuY29sb3IgPSBjb2xvcjtcblxuXHRcdHRoaXMudHlwZSA9ICdEaXJlY3Rpb25hbExpZ2h0SGVscGVyJztcblxuXHRcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IDE7XG5cblx0XHRsZXQgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBbXG5cdFx0XHQtIHNpemUsIHNpemUsIDAsXG5cdFx0XHRzaXplLCBzaXplLCAwLFxuXHRcdFx0c2l6ZSwgLSBzaXplLCAwLFxuXHRcdFx0LSBzaXplLCAtIHNpemUsIDAsXG5cdFx0XHQtIHNpemUsIHNpemUsIDBcblx0XHRdLCAzICkgKTtcblxuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UsIHRvbmVNYXBwZWQ6IGZhbHNlIH0gKTtcblxuXHRcdHRoaXMubGlnaHRQbGFuZSA9IG5ldyBMaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0XHR0aGlzLmFkZCggdGhpcy5saWdodFBsYW5lICk7XG5cblx0XHRnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIFsgMCwgMCwgMCwgMCwgMCwgMSBdLCAzICkgKTtcblxuXHRcdHRoaXMudGFyZ2V0TGluZSA9IG5ldyBMaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0XHR0aGlzLmFkZCggdGhpcy50YXJnZXRMaW5lICk7XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5saWdodFBsYW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9XG5cblx0dXBkYXRlKCkge1xuXG5cdFx0dGhpcy5saWdodC51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblx0XHR0aGlzLmxpZ2h0LnRhcmdldC51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdF92MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRfdjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuXHRcdF92My5zdWJWZWN0b3JzKCBfdjIsIF92MSApO1xuXG5cdFx0dGhpcy5saWdodFBsYW5lLmxvb2tBdCggX3YyICk7XG5cblx0XHRpZiAoIHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yLnNldCggdGhpcy5jb2xvciApO1xuXHRcdFx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmNvbG9yLnNldCggdGhpcy5jb2xvciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKTtcblx0XHRcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnRhcmdldExpbmUubG9va0F0KCBfdjIgKTtcblx0XHR0aGlzLnRhcmdldExpbmUuc2NhbGUueiA9IF92My5sZW5ndGgoKTtcblxuXHR9XG5cbn1cblxuY29uc3QgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9jYW1lcmEgPSAvKkBfX1BVUkVfXyovIG5ldyBDYW1lcmEoKTtcblxuLyoqXG4gKlx0LSBzaG93cyBmcnVzdHVtLCBsaW5lIG9mIHNpZ2h0IGFuZCB1cCBvZiB0aGUgY2FtZXJhXG4gKlx0LSBzdWl0YWJsZSBmb3IgZmFzdCB1cGRhdGVzXG4gKiBcdC0gYmFzZWQgb24gZnJ1c3R1bSB2aXN1YWxpemF0aW9uIGluIGxpZ2h0Z2wuanMgc2hhZG93bWFwIGV4YW1wbGVcbiAqXHRcdGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9saWdodGdsLmpzL2Jsb2IvbWFzdGVyL3Rlc3RzL3NoYWRvd21hcC5odG1sXG4gKi9cblxuY2xhc3MgQ2FtZXJhSGVscGVyIGV4dGVuZHMgTGluZVNlZ21lbnRzIHtcblxuXHRjb25zdHJ1Y3RvciggY2FtZXJhICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmZmYsIHZlcnRleENvbG9yczogdHJ1ZSwgdG9uZU1hcHBlZDogZmFsc2UgfSApO1xuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBjb2xvcnMgPSBbXTtcblxuXHRcdGNvbnN0IHBvaW50TWFwID0ge307XG5cblx0XHQvLyBuZWFyXG5cblx0XHRhZGRMaW5lKCAnbjEnLCAnbjInICk7XG5cdFx0YWRkTGluZSggJ24yJywgJ240JyApO1xuXHRcdGFkZExpbmUoICduNCcsICduMycgKTtcblx0XHRhZGRMaW5lKCAnbjMnLCAnbjEnICk7XG5cblx0XHQvLyBmYXJcblxuXHRcdGFkZExpbmUoICdmMScsICdmMicgKTtcblx0XHRhZGRMaW5lKCAnZjInLCAnZjQnICk7XG5cdFx0YWRkTGluZSggJ2Y0JywgJ2YzJyApO1xuXHRcdGFkZExpbmUoICdmMycsICdmMScgKTtcblxuXHRcdC8vIHNpZGVzXG5cblx0XHRhZGRMaW5lKCAnbjEnLCAnZjEnICk7XG5cdFx0YWRkTGluZSggJ24yJywgJ2YyJyApO1xuXHRcdGFkZExpbmUoICduMycsICdmMycgKTtcblx0XHRhZGRMaW5lKCAnbjQnLCAnZjQnICk7XG5cblx0XHQvLyBjb25lXG5cblx0XHRhZGRMaW5lKCAncCcsICduMScgKTtcblx0XHRhZGRMaW5lKCAncCcsICduMicgKTtcblx0XHRhZGRMaW5lKCAncCcsICduMycgKTtcblx0XHRhZGRMaW5lKCAncCcsICduNCcgKTtcblxuXHRcdC8vIHVwXG5cblx0XHRhZGRMaW5lKCAndTEnLCAndTInICk7XG5cdFx0YWRkTGluZSggJ3UyJywgJ3UzJyApO1xuXHRcdGFkZExpbmUoICd1MycsICd1MScgKTtcblxuXHRcdC8vIHRhcmdldFxuXG5cdFx0YWRkTGluZSggJ2MnLCAndCcgKTtcblx0XHRhZGRMaW5lKCAncCcsICdjJyApO1xuXG5cdFx0Ly8gY3Jvc3NcblxuXHRcdGFkZExpbmUoICdjbjEnLCAnY24yJyApO1xuXHRcdGFkZExpbmUoICdjbjMnLCAnY240JyApO1xuXG5cdFx0YWRkTGluZSggJ2NmMScsICdjZjInICk7XG5cdFx0YWRkTGluZSggJ2NmMycsICdjZjQnICk7XG5cblx0XHRmdW5jdGlvbiBhZGRMaW5lKCBhLCBiICkge1xuXG5cdFx0XHRhZGRQb2ludCggYSApO1xuXHRcdFx0YWRkUG9pbnQoIGIgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZFBvaW50KCBpZCApIHtcblxuXHRcdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xuXHRcdFx0Y29sb3JzLnB1c2goIDAsIDAsIDAgKTtcblxuXHRcdFx0aWYgKCBwb2ludE1hcFsgaWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHBvaW50TWFwWyBpZCBdID0gW107XG5cblx0XHRcdH1cblxuXHRcdFx0cG9pbnRNYXBbIGlkIF0ucHVzaCggKCB2ZXJ0aWNlcy5sZW5ndGggLyAzICkgLSAxICk7XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuXHRcdHN1cGVyKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDYW1lcmFIZWxwZXInO1xuXG5cdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cdFx0aWYgKCB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ICkgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdFx0dGhpcy5tYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGQ7XG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLnBvaW50TWFwID0gcG9pbnRNYXA7XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0Ly8gY29sb3JzXG5cblx0XHRjb25zdCBjb2xvckZydXN0dW0gPSBuZXcgQ29sb3IoIDB4ZmZhYTAwICk7XG5cdFx0Y29uc3QgY29sb3JDb25lID0gbmV3IENvbG9yKCAweGZmMDAwMCApO1xuXHRcdGNvbnN0IGNvbG9yVXAgPSBuZXcgQ29sb3IoIDB4MDBhYWZmICk7XG5cdFx0Y29uc3QgY29sb3JUYXJnZXQgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XG5cdFx0Y29uc3QgY29sb3JDcm9zcyA9IG5ldyBDb2xvciggMHgzMzMzMzMgKTtcblxuXHRcdHRoaXMuc2V0Q29sb3JzKCBjb2xvckZydXN0dW0sIGNvbG9yQ29uZSwgY29sb3JVcCwgY29sb3JUYXJnZXQsIGNvbG9yQ3Jvc3MgKTtcblxuXHR9XG5cblx0c2V0Q29sb3JzKCBmcnVzdHVtLCBjb25lLCB1cCwgdGFyZ2V0LCBjcm9zcyApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdGNvbnN0IGNvbG9yQXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAnY29sb3InICk7XG5cblx0XHQvLyBuZWFyXG5cblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDAsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAxLCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IC8vIG4xLCBuMlxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMiwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDMsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgLy8gbjIsIG40XG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA0LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggNSwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyAvLyBuNCwgbjNcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDYsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA3LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IC8vIG4zLCBuMVxuXG5cdFx0Ly8gZmFyXG5cblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDgsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA5LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IC8vIGYxLCBmMlxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMTAsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAxMSwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyAvLyBmMiwgZjRcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDEyLCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMTMsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgLy8gZjQsIGYzXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAxNCwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDE1LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IC8vIGYzLCBmMVxuXG5cdFx0Ly8gc2lkZXNcblxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMTYsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAxNywgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyAvLyBuMSwgZjFcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDE4LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMTksIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgLy8gbjIsIGYyXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAyMCwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDIxLCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IC8vIG4zLCBmM1xuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMjIsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAyMywgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyAvLyBuNCwgZjRcblxuXHRcdC8vIGNvbmVcblxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMjQsIGNvbmUuciwgY29uZS5nLCBjb25lLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAyNSwgY29uZS5yLCBjb25lLmcsIGNvbmUuYiApOyAvLyBwLCBuMVxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMjYsIGNvbmUuciwgY29uZS5nLCBjb25lLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAyNywgY29uZS5yLCBjb25lLmcsIGNvbmUuYiApOyAvLyBwLCBuMlxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMjgsIGNvbmUuciwgY29uZS5nLCBjb25lLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAyOSwgY29uZS5yLCBjb25lLmcsIGNvbmUuYiApOyAvLyBwLCBuM1xuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMzAsIGNvbmUuciwgY29uZS5nLCBjb25lLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAzMSwgY29uZS5yLCBjb25lLmcsIGNvbmUuYiApOyAvLyBwLCBuNFxuXG5cdFx0Ly8gdXBcblxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMzIsIHVwLnIsIHVwLmcsIHVwLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAzMywgdXAuciwgdXAuZywgdXAuYiApOyAvLyB1MSwgdTJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDM0LCB1cC5yLCB1cC5nLCB1cC5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMzUsIHVwLnIsIHVwLmcsIHVwLmIgKTsgLy8gdTIsIHUzXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAzNiwgdXAuciwgdXAuZywgdXAuYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDM3LCB1cC5yLCB1cC5nLCB1cC5iICk7IC8vIHUzLCB1MVxuXG5cdFx0Ly8gdGFyZ2V0XG5cblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDM4LCB0YXJnZXQuciwgdGFyZ2V0LmcsIHRhcmdldC5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMzksIHRhcmdldC5yLCB0YXJnZXQuZywgdGFyZ2V0LmIgKTsgLy8gYywgdFxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggNDAsIGNyb3NzLnIsIGNyb3NzLmcsIGNyb3NzLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA0MSwgY3Jvc3MuciwgY3Jvc3MuZywgY3Jvc3MuYiApOyAvLyBwLCBjXG5cblx0XHQvLyBjcm9zc1xuXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA0MiwgY3Jvc3MuciwgY3Jvc3MuZywgY3Jvc3MuYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDQzLCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iICk7IC8vIGNuMSwgY24yXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA0NCwgY3Jvc3MuciwgY3Jvc3MuZywgY3Jvc3MuYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDQ1LCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iICk7IC8vIGNuMywgY240XG5cblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDQ2LCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggNDcsIGNyb3NzLnIsIGNyb3NzLmcsIGNyb3NzLmIgKTsgLy8gY2YxLCBjZjJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDQ4LCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggNDksIGNyb3NzLnIsIGNyb3NzLmcsIGNyb3NzLmIgKTsgLy8gY2YzLCBjZjRcblxuXHRcdGNvbG9yQXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0dXBkYXRlKCkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGNvbnN0IHBvaW50TWFwID0gdGhpcy5wb2ludE1hcDtcblxuXHRcdGNvbnN0IHcgPSAxLCBoID0gMTtcblxuXHRcdC8vIHdlIG5lZWQganVzdCBjYW1lcmEgcHJvamVjdGlvbiBtYXRyaXggaW52ZXJzZVxuXHRcdC8vIHdvcmxkIG1hdHJpeCBtdXN0IGJlIGlkZW50aXR5XG5cblx0XHRfY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkoIHRoaXMuY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlICk7XG5cblx0XHQvLyBBZGp1c3QgeiB2YWx1ZXMgYmFzZWQgb24gY29vcmRpbmF0ZSBzeXN0ZW1cblx0XHRjb25zdCBuZWFyWiA9IHRoaXMuY2FtZXJhLmNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSA/IC0gMSA6IDA7XG5cblx0XHQvLyBjZW50ZXIgLyB0YXJnZXRcblx0XHRzZXRQb2ludCggJ2MnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIDAsIDAsIG5lYXJaICk7XG5cdFx0c2V0UG9pbnQoICd0JywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAwLCAwLCAxICk7XG5cblx0XHQvLyBuZWFyXG5cblx0XHRzZXRQb2ludCggJ24xJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtIHcsIC0gaCwgbmVhclogKTtcblx0XHRzZXRQb2ludCggJ24yJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCB3LCAtIGgsIG5lYXJaICk7XG5cdFx0c2V0UG9pbnQoICduMycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgLSB3LCBoLCBuZWFyWiApO1xuXHRcdHNldFBvaW50KCAnbjQnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIGgsIG5lYXJaICk7XG5cblx0XHQvLyBmYXJcblxuXHRcdHNldFBvaW50KCAnZjEnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIC0gdywgLSBoLCAxICk7XG5cdFx0c2V0UG9pbnQoICdmMicsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgdywgLSBoLCAxICk7XG5cdFx0c2V0UG9pbnQoICdmMycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgLSB3LCBoLCAxICk7XG5cdFx0c2V0UG9pbnQoICdmNCcsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgdywgaCwgMSApO1xuXG5cdFx0Ly8gdXBcblxuXHRcdHNldFBvaW50KCAndTEnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcgKiAwLjcsIGggKiAxLjEsIG5lYXJaICk7XG5cdFx0c2V0UG9pbnQoICd1MicsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgLSB3ICogMC43LCBoICogMS4xLCBuZWFyWiApO1xuXHRcdHNldFBvaW50KCAndTMnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIDAsIGggKiAyLCBuZWFyWiApO1xuXG5cdFx0Ly8gY3Jvc3NcblxuXHRcdHNldFBvaW50KCAnY2YxJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtIHcsIDAsIDEgKTtcblx0XHRzZXRQb2ludCggJ2NmMicsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgdywgMCwgMSApO1xuXHRcdHNldFBvaW50KCAnY2YzJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAwLCAtIGgsIDEgKTtcblx0XHRzZXRQb2ludCggJ2NmNCcsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgaCwgMSApO1xuXG5cdFx0c2V0UG9pbnQoICdjbjEnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIC0gdywgMCwgbmVhclogKTtcblx0XHRzZXRQb2ludCggJ2NuMicsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgdywgMCwgbmVhclogKTtcblx0XHRzZXRQb2ludCggJ2NuMycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgLSBoLCBuZWFyWiApO1xuXHRcdHNldFBvaW50KCAnY240JywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAwLCBoLCBuZWFyWiApO1xuXG5cdFx0Z2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICkubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cblx0fVxuXG59XG5cblxuZnVuY3Rpb24gc2V0UG9pbnQoIHBvaW50LCBwb2ludE1hcCwgZ2VvbWV0cnksIGNhbWVyYSwgeCwgeSwgeiApIHtcblxuXHRfdmVjdG9yLnNldCggeCwgeSwgeiApLnVucHJvamVjdCggY2FtZXJhICk7XG5cblx0Y29uc3QgcG9pbnRzID0gcG9pbnRNYXBbIHBvaW50IF07XG5cblx0aWYgKCBwb2ludHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0cG9zaXRpb24uc2V0WFlaKCBwb2ludHNbIGkgXSwgX3ZlY3Rvci54LCBfdmVjdG9yLnksIF92ZWN0b3IueiApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5jb25zdCBfYm94ID0gLypAX19QVVJFX18qLyBuZXcgQm94MygpO1xuXG5jbGFzcyBCb3hIZWxwZXIgZXh0ZW5kcyBMaW5lU2VnbWVudHMge1xuXG5cdGNvbnN0cnVjdG9yKCBvYmplY3QsIGNvbG9yID0gMHhmZmZmMDAgKSB7XG5cblx0XHRjb25zdCBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDAsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDQsIDAsIDQsIDEsIDUsIDIsIDYsIDMsIDcgXSApO1xuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIDggKiAzICk7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGdlb21ldHJ5LnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG5cblx0XHRzdXBlciggZ2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIHRvbmVNYXBwZWQ6IGZhbHNlIH0gKSApO1xuXG5cdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cdFx0dGhpcy50eXBlID0gJ0JveEhlbHBlcic7XG5cblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0fVxuXG5cdHVwZGF0ZSggb2JqZWN0ICkge1xuXG5cdFx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94SGVscGVyOiAudXBkYXRlKCkgaGFzIG5vIGxvbmdlciBhcmd1bWVudHMuJyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRfYm94LnNldEZyb21PYmplY3QoIHRoaXMub2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIF9ib3guaXNFbXB0eSgpICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgbWluID0gX2JveC5taW47XG5cdFx0Y29uc3QgbWF4ID0gX2JveC5tYXg7XG5cblx0XHQvKlxuXHRcdFx0NV9fX180XG5cdFx0MS9fX18wL3xcblx0XHR8IDZfX3xfN1xuXHRcdDIvX19fMy9cblxuXHRcdDA6IG1heC54LCBtYXgueSwgbWF4Lnpcblx0XHQxOiBtaW4ueCwgbWF4LnksIG1heC56XG5cdFx0MjogbWluLngsIG1pbi55LCBtYXguelxuXHRcdDM6IG1heC54LCBtaW4ueSwgbWF4Lnpcblx0XHQ0OiBtYXgueCwgbWF4LnksIG1pbi56XG5cdFx0NTogbWluLngsIG1heC55LCBtaW4uelxuXHRcdDY6IG1pbi54LCBtaW4ueSwgbWluLnpcblx0XHQ3OiBtYXgueCwgbWluLnksIG1pbi56XG5cdFx0Ki9cblxuXHRcdGNvbnN0IHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGNvbnN0IGFycmF5ID0gcG9zaXRpb24uYXJyYXk7XG5cblx0XHRhcnJheVsgMCBdID0gbWF4Lng7IGFycmF5WyAxIF0gPSBtYXgueTsgYXJyYXlbIDIgXSA9IG1heC56O1xuXHRcdGFycmF5WyAzIF0gPSBtaW4ueDsgYXJyYXlbIDQgXSA9IG1heC55OyBhcnJheVsgNSBdID0gbWF4Lno7XG5cdFx0YXJyYXlbIDYgXSA9IG1pbi54OyBhcnJheVsgNyBdID0gbWluLnk7IGFycmF5WyA4IF0gPSBtYXguejtcblx0XHRhcnJheVsgOSBdID0gbWF4Lng7IGFycmF5WyAxMCBdID0gbWluLnk7IGFycmF5WyAxMSBdID0gbWF4Lno7XG5cdFx0YXJyYXlbIDEyIF0gPSBtYXgueDsgYXJyYXlbIDEzIF0gPSBtYXgueTsgYXJyYXlbIDE0IF0gPSBtaW4uejtcblx0XHRhcnJheVsgMTUgXSA9IG1pbi54OyBhcnJheVsgMTYgXSA9IG1heC55OyBhcnJheVsgMTcgXSA9IG1pbi56O1xuXHRcdGFycmF5WyAxOCBdID0gbWluLng7IGFycmF5WyAxOSBdID0gbWluLnk7IGFycmF5WyAyMCBdID0gbWluLno7XG5cdFx0YXJyYXlbIDIxIF0gPSBtYXgueDsgYXJyYXlbIDIyIF0gPSBtaW4ueTsgYXJyYXlbIDIzIF0gPSBtaW4uejtcblxuXHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0fVxuXG5cdHNldEZyb21PYmplY3QoIG9iamVjdCApIHtcblxuXHRcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0dGhpcy5vYmplY3QgPSBzb3VyY2Uub2JqZWN0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgQm94M0hlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XG5cblx0Y29uc3RydWN0b3IoIGJveCwgY29sb3IgPSAweGZmZmYwMCApIHtcblxuXHRcdGNvbnN0IGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIFsgMCwgMSwgMSwgMiwgMiwgMywgMywgMCwgNCwgNSwgNSwgNiwgNiwgNywgNywgNCwgMCwgNCwgMSwgNSwgMiwgNiwgMywgNyBdICk7XG5cblx0XHRjb25zdCBwb3NpdGlvbnMgPSBbIDEsIDEsIDEsIC0gMSwgMSwgMSwgLSAxLCAtIDEsIDEsIDEsIC0gMSwgMSwgMSwgMSwgLSAxLCAtIDEsIDEsIC0gMSwgLSAxLCAtIDEsIC0gMSwgMSwgLSAxLCAtIDEgXTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XG5cblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xuXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCB0b25lTWFwcGVkOiBmYWxzZSB9ICkgKTtcblxuXHRcdHRoaXMuYm94ID0gYm94O1xuXG5cdFx0dGhpcy50eXBlID0gJ0JveDNIZWxwZXInO1xuXG5cdFx0dGhpcy5nZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHR9XG5cblx0dXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG5cdFx0Y29uc3QgYm94ID0gdGhpcy5ib3g7XG5cblx0XHRpZiAoIGJveC5pc0VtcHR5KCkgKSByZXR1cm47XG5cblx0XHRib3guZ2V0Q2VudGVyKCB0aGlzLnBvc2l0aW9uICk7XG5cblx0XHRib3guZ2V0U2l6ZSggdGhpcy5zY2FsZSApO1xuXG5cdFx0dGhpcy5zY2FsZS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cblx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH1cblxufVxuXG5jbGFzcyBQbGFuZUhlbHBlciBleHRlbmRzIExpbmUge1xuXG5cdGNvbnN0cnVjdG9yKCBwbGFuZSwgc2l6ZSA9IDEsIGhleCA9IDB4ZmZmZjAwICkge1xuXG5cdFx0Y29uc3QgY29sb3IgPSBoZXg7XG5cblx0XHRjb25zdCBwb3NpdGlvbnMgPSBbIDEsIC0gMSwgMCwgLSAxLCAxLCAwLCAtIDEsIC0gMSwgMCwgMSwgMSwgMCwgLSAxLCAxLCAwLCAtIDEsIC0gMSwgMCwgMSwgLSAxLCAwLCAxLCAxLCAwIF07XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG5cdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRzdXBlciggZ2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIHRvbmVNYXBwZWQ6IGZhbHNlIH0gKSApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BsYW5lSGVscGVyJztcblxuXHRcdHRoaXMucGxhbmUgPSBwbGFuZTtcblxuXHRcdHRoaXMuc2l6ZSA9IHNpemU7XG5cblx0XHRjb25zdCBwb3NpdGlvbnMyID0gWyAxLCAxLCAwLCAtIDEsIDEsIDAsIC0gMSwgLSAxLCAwLCAxLCAxLCAwLCAtIDEsIC0gMSwgMCwgMSwgLSAxLCAwIF07XG5cblx0XHRjb25zdCBnZW9tZXRyeTIgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeTIuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zMiwgMyApICk7XG5cdFx0Z2VvbWV0cnkyLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0dGhpcy5hZGQoIG5ldyBNZXNoKCBnZW9tZXRyeTIsIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIG9wYWNpdHk6IDAuMiwgdHJhbnNwYXJlbnQ6IHRydWUsIGRlcHRoV3JpdGU6IGZhbHNlLCB0b25lTWFwcGVkOiBmYWxzZSB9ICkgKSApO1xuXG5cdH1cblxuXHR1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XG5cblx0XHR0aGlzLnBvc2l0aW9uLnNldCggMCwgMCwgMCApO1xuXG5cdFx0dGhpcy5zY2FsZS5zZXQoIDAuNSAqIHRoaXMuc2l6ZSwgMC41ICogdGhpcy5zaXplLCAxICk7XG5cblx0XHR0aGlzLmxvb2tBdCggdGhpcy5wbGFuZS5ub3JtYWwgKTtcblxuXHRcdHRoaXMudHJhbnNsYXRlWiggLSB0aGlzLnBsYW5lLmNvbnN0YW50ICk7XG5cblx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdHRoaXMuY2hpbGRyZW5bIDAgXS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5jaGlsZHJlblsgMCBdLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9XG5cbn1cblxuY29uc3QgX2F4aXMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5sZXQgX2xpbmVHZW9tZXRyeSwgX2NvbmVHZW9tZXRyeTtcblxuY2xhc3MgQXJyb3dIZWxwZXIgZXh0ZW5kcyBPYmplY3QzRCB7XG5cblx0Ly8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdGNvbnN0cnVjdG9yKCBkaXIgPSBuZXcgVmVjdG9yMyggMCwgMCwgMSApLCBvcmlnaW4gPSBuZXcgVmVjdG9yMyggMCwgMCwgMCApLCBsZW5ndGggPSAxLCBjb2xvciA9IDB4ZmZmZjAwLCBoZWFkTGVuZ3RoID0gbGVuZ3RoICogMC4yLCBoZWFkV2lkdGggPSBoZWFkTGVuZ3RoICogMC4yICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdBcnJvd0hlbHBlcic7XG5cblx0XHRpZiAoIF9saW5lR2VvbWV0cnkgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0X2xpbmVHZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0X2xpbmVHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBbIDAsIDAsIDAsIDAsIDEsIDAgXSwgMyApICk7XG5cblx0XHRcdF9jb25lR2VvbWV0cnkgPSBuZXcgQ3lsaW5kZXJHZW9tZXRyeSggMCwgMC41LCAxLCA1LCAxICk7XG5cdFx0XHRfY29uZUdlb21ldHJ5LnRyYW5zbGF0ZSggMCwgLSAwLjUsIDAgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMucG9zaXRpb24uY29weSggb3JpZ2luICk7XG5cblx0XHR0aGlzLmxpbmUgPSBuZXcgTGluZSggX2xpbmVHZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgdG9uZU1hcHBlZDogZmFsc2UgfSApICk7XG5cdFx0dGhpcy5saW5lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmFkZCggdGhpcy5saW5lICk7XG5cblx0XHR0aGlzLmNvbmUgPSBuZXcgTWVzaCggX2NvbmVHZW9tZXRyeSwgbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgdG9uZU1hcHBlZDogZmFsc2UgfSApICk7XG5cdFx0dGhpcy5jb25lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmFkZCggdGhpcy5jb25lICk7XG5cblx0XHR0aGlzLnNldERpcmVjdGlvbiggZGlyICk7XG5cdFx0dGhpcy5zZXRMZW5ndGgoIGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XG5cblx0fVxuXG5cdHNldERpcmVjdGlvbiggZGlyICkge1xuXG5cdFx0Ly8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0aWYgKCBkaXIueSA+IDAuOTk5OTkgKSB7XG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoIDAsIDAsIDAsIDEgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGRpci55IDwgLSAwLjk5OTk5ICkge1xuXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0KCAxLCAwLCAwLCAwICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfYXhpcy5zZXQoIGRpci56LCAwLCAtIGRpci54ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdGNvbnN0IHJhZGlhbnMgPSBNYXRoLmFjb3MoIGRpci55ICk7XG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBfYXhpcywgcmFkaWFucyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXRMZW5ndGgoIGxlbmd0aCwgaGVhZExlbmd0aCA9IGxlbmd0aCAqIDAuMiwgaGVhZFdpZHRoID0gaGVhZExlbmd0aCAqIDAuMiApIHtcblxuXHRcdHRoaXMubGluZS5zY2FsZS5zZXQoIDEsIE1hdGgubWF4KCAwLjAwMDEsIGxlbmd0aCAtIGhlYWRMZW5ndGggKSwgMSApOyAvLyBzZWUgIzE3NDU4XG5cdFx0dGhpcy5saW5lLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0dGhpcy5jb25lLnNjYWxlLnNldCggaGVhZFdpZHRoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcblx0XHR0aGlzLmNvbmUucG9zaXRpb24ueSA9IGxlbmd0aDtcblx0XHR0aGlzLmNvbmUudXBkYXRlTWF0cml4KCk7XG5cblx0fVxuXG5cdHNldENvbG9yKCBjb2xvciApIHtcblxuXHRcdHRoaXMubGluZS5tYXRlcmlhbC5jb2xvci5zZXQoIGNvbG9yICk7XG5cdFx0dGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLnNldCggY29sb3IgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlLCBmYWxzZSApO1xuXG5cdFx0dGhpcy5saW5lLmNvcHkoIHNvdXJjZS5saW5lICk7XG5cdFx0dGhpcy5jb25lLmNvcHkoIHNvdXJjZS5jb25lICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMubGluZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5saW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0XHR0aGlzLmNvbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMuY29uZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cblx0fVxuXG59XG5cbmNsYXNzIEF4ZXNIZWxwZXIgZXh0ZW5kcyBMaW5lU2VnbWVudHMge1xuXG5cdGNvbnN0cnVjdG9yKCBzaXplID0gMSApIHtcblxuXHRcdGNvbnN0IHZlcnRpY2VzID0gW1xuXHRcdFx0MCwgMCwgMCxcdHNpemUsIDAsIDAsXG5cdFx0XHQwLCAwLCAwLFx0MCwgc2l6ZSwgMCxcblx0XHRcdDAsIDAsIDAsXHQwLCAwLCBzaXplXG5cdFx0XTtcblxuXHRcdGNvbnN0IGNvbG9ycyA9IFtcblx0XHRcdDEsIDAsIDAsXHQxLCAwLjYsIDAsXG5cdFx0XHQwLCAxLCAwLFx0MC42LCAxLCAwLFxuXHRcdFx0MCwgMCwgMSxcdDAsIDAuNiwgMVxuXHRcdF07XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiB0cnVlLCB0b25lTWFwcGVkOiBmYWxzZSB9ICk7XG5cblx0XHRzdXBlciggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQXhlc0hlbHBlcic7XG5cblx0fVxuXG5cdHNldENvbG9ycyggeEF4aXNDb2xvciwgeUF4aXNDb2xvciwgekF4aXNDb2xvciApIHtcblxuXHRcdGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKCk7XG5cdFx0Y29uc3QgYXJyYXkgPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IuYXJyYXk7XG5cblx0XHRjb2xvci5zZXQoIHhBeGlzQ29sb3IgKTtcblx0XHRjb2xvci50b0FycmF5KCBhcnJheSwgMCApO1xuXHRcdGNvbG9yLnRvQXJyYXkoIGFycmF5LCAzICk7XG5cblx0XHRjb2xvci5zZXQoIHlBeGlzQ29sb3IgKTtcblx0XHRjb2xvci50b0FycmF5KCBhcnJheSwgNiApO1xuXHRcdGNvbG9yLnRvQXJyYXkoIGFycmF5LCA5ICk7XG5cblx0XHRjb2xvci5zZXQoIHpBeGlzQ29sb3IgKTtcblx0XHRjb2xvci50b0FycmF5KCBhcnJheSwgMTIgKTtcblx0XHRjb2xvci50b0FycmF5KCBhcnJheSwgMTUgKTtcblxuXHRcdHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH1cblxufVxuXG5jbGFzcyBTaGFwZVBhdGgge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy50eXBlID0gJ1NoYXBlUGF0aCc7XG5cblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCk7XG5cblx0XHR0aGlzLnN1YlBhdGhzID0gW107XG5cdFx0dGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG5cblx0fVxuXG5cdG1vdmVUbyggeCwgeSApIHtcblxuXHRcdHRoaXMuY3VycmVudFBhdGggPSBuZXcgUGF0aCgpO1xuXHRcdHRoaXMuc3ViUGF0aHMucHVzaCggdGhpcy5jdXJyZW50UGF0aCApO1xuXHRcdHRoaXMuY3VycmVudFBhdGgubW92ZVRvKCB4LCB5ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bGluZVRvKCB4LCB5ICkge1xuXG5cdFx0dGhpcy5jdXJyZW50UGF0aC5saW5lVG8oIHgsIHkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRxdWFkcmF0aWNDdXJ2ZVRvKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKSB7XG5cblx0XHR0aGlzLmN1cnJlbnRQYXRoLnF1YWRyYXRpY0N1cnZlVG8oIGFDUHgsIGFDUHksIGFYLCBhWSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGJlemllckN1cnZlVG8oIGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkgKSB7XG5cblx0XHR0aGlzLmN1cnJlbnRQYXRoLmJlemllckN1cnZlVG8oIGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzcGxpbmVUaHJ1KCBwdHMgKSB7XG5cblx0XHR0aGlzLmN1cnJlbnRQYXRoLnNwbGluZVRocnUoIHB0cyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvU2hhcGVzKCBpc0NDVyApIHtcblxuXHRcdGZ1bmN0aW9uIHRvU2hhcGVzTm9Ib2xlcyggaW5TdWJwYXRocyApIHtcblxuXHRcdFx0Y29uc3Qgc2hhcGVzID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluU3VicGF0aHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCB0bXBQYXRoID0gaW5TdWJwYXRoc1sgaSBdO1xuXG5cdFx0XHRcdGNvbnN0IHRtcFNoYXBlID0gbmV3IFNoYXBlKCk7XG5cdFx0XHRcdHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuXG5cdFx0XHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzaGFwZXM7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1BvaW50SW5zaWRlUG9seWdvbiggaW5QdCwgaW5Qb2x5Z29uICkge1xuXG5cdFx0XHRjb25zdCBwb2x5TGVuID0gaW5Qb2x5Z29uLmxlbmd0aDtcblxuXHRcdFx0Ly8gaW5QdCBvbiBwb2x5Z29uIGNvbnRvdXIgPT4gaW1tZWRpYXRlIHN1Y2Nlc3MgICAgb3Jcblx0XHRcdC8vIHRvZ2dsaW5nIG9mIGluc2lkZS9vdXRzaWRlIGF0IGV2ZXJ5IHNpbmdsZSEgaW50ZXJzZWN0aW9uIHBvaW50IG9mIGFuIGVkZ2Vcblx0XHRcdC8vICB3aXRoIHRoZSBob3Jpem9udGFsIGxpbmUgdGhyb3VnaCBpblB0LCBsZWZ0IG9mIGluUHRcblx0XHRcdC8vICBub3QgY291bnRpbmcgbG93ZXJZIGVuZHBvaW50cyBvZiBlZGdlcyBhbmQgd2hvbGUgZWRnZXMgb24gdGhhdCBsaW5lXG5cdFx0XHRsZXQgaW5zaWRlID0gZmFsc2U7XG5cdFx0XHRmb3IgKCBsZXQgcCA9IHBvbHlMZW4gLSAxLCBxID0gMDsgcSA8IHBvbHlMZW47IHAgPSBxICsrICkge1xuXG5cdFx0XHRcdGxldCBlZGdlTG93UHQgPSBpblBvbHlnb25bIHAgXTtcblx0XHRcdFx0bGV0IGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bIHEgXTtcblxuXHRcdFx0XHRsZXQgZWRnZUR4ID0gZWRnZUhpZ2hQdC54IC0gZWRnZUxvd1B0Lng7XG5cdFx0XHRcdGxldCBlZGdlRHkgPSBlZGdlSGlnaFB0LnkgLSBlZGdlTG93UHQueTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBlZGdlRHkgKSA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0Ly8gbm90IHBhcmFsbGVsXG5cdFx0XHRcdFx0aWYgKCBlZGdlRHkgPCAwICkge1xuXG5cdFx0XHRcdFx0XHRlZGdlTG93UHQgPSBpblBvbHlnb25bIHEgXTsgZWRnZUR4ID0gLSBlZGdlRHg7XG5cdFx0XHRcdFx0XHRlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBwIF07IGVkZ2VEeSA9IC0gZWRnZUR5O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAoIGluUHQueSA8IGVkZ2VMb3dQdC55ICkgfHwgKCBpblB0LnkgPiBlZGdlSGlnaFB0LnkgKSApIFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdGlmICggaW5QdC55ID09PSBlZGdlTG93UHQueSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBpblB0LnggPT09IGVkZ2VMb3dQdC54IClcdFx0cmV0dXJuXHR0cnVlO1x0XHQvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xuXHRcdFx0XHRcdFx0Ly8gY29udGludWU7XHRcdFx0XHQvLyBubyBpbnRlcnNlY3Rpb24gb3IgZWRnZUxvd1B0ID0+IGRvZXNuJ3QgY291bnQgISEhXG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBwZXJwRWRnZSA9IGVkZ2VEeSAqICggaW5QdC54IC0gZWRnZUxvd1B0LnggKSAtIGVkZ2VEeCAqICggaW5QdC55IC0gZWRnZUxvd1B0LnkgKTtcblx0XHRcdFx0XHRcdGlmICggcGVycEVkZ2UgPT09IDAgKVx0XHRcdFx0cmV0dXJuXHR0cnVlO1x0XHQvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xuXHRcdFx0XHRcdFx0aWYgKCBwZXJwRWRnZSA8IDAgKSBcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0aW5zaWRlID0gISBpbnNpZGU7XHRcdC8vIHRydWUgaW50ZXJzZWN0aW9uIGxlZnQgb2YgaW5QdFxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBwYXJhbGxlbCBvciBjb2xsaW5lYXJcblx0XHRcdFx0XHRpZiAoIGluUHQueSAhPT0gZWRnZUxvd1B0LnkgKSBcdFx0Y29udGludWU7XHRcdFx0Ly8gcGFyYWxsZWxcblx0XHRcdFx0XHQvLyBlZGdlIGxpZXMgb24gdGhlIHNhbWUgaG9yaXpvbnRhbCBsaW5lIGFzIGluUHRcblx0XHRcdFx0XHRpZiAoICggKCBlZGdlSGlnaFB0LnggPD0gaW5QdC54ICkgJiYgKCBpblB0LnggPD0gZWRnZUxvd1B0LnggKSApIHx8XG5cdFx0XHRcdFx0XHQgKCAoIGVkZ2VMb3dQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VIaWdoUHQueCApICkgKVx0XHRyZXR1cm5cdHRydWU7XHQvLyBpblB0OiBQb2ludCBvbiBjb250b3VyICFcblx0XHRcdFx0XHQvLyBjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuXHRpbnNpZGU7XG5cblx0XHR9XG5cblx0XHRjb25zdCBpc0Nsb2NrV2lzZSA9IFNoYXBlVXRpbHMuaXNDbG9ja1dpc2U7XG5cblx0XHRjb25zdCBzdWJQYXRocyA9IHRoaXMuc3ViUGF0aHM7XG5cdFx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDAgKSByZXR1cm4gW107XG5cblx0XHRsZXQgc29saWQsIHRtcFBhdGgsIHRtcFNoYXBlO1xuXHRcdGNvbnN0IHNoYXBlcyA9IFtdO1xuXG5cdFx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdHRtcFBhdGggPSBzdWJQYXRoc1sgMCBdO1xuXHRcdFx0dG1wU2hhcGUgPSBuZXcgU2hhcGUoKTtcblx0XHRcdHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuXHRcdFx0c2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XG5cdFx0XHRyZXR1cm4gc2hhcGVzO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGhvbGVzRmlyc3QgPSAhIGlzQ2xvY2tXaXNlKCBzdWJQYXRoc1sgMCBdLmdldFBvaW50cygpICk7XG5cdFx0aG9sZXNGaXJzdCA9IGlzQ0NXID8gISBob2xlc0ZpcnN0IDogaG9sZXNGaXJzdDtcblxuXHRcdC8vIGNvbnNvbGUubG9nKFwiSG9sZXMgZmlyc3RcIiwgaG9sZXNGaXJzdCk7XG5cblx0XHRjb25zdCBiZXR0ZXJTaGFwZUhvbGVzID0gW107XG5cdFx0Y29uc3QgbmV3U2hhcGVzID0gW107XG5cdFx0bGV0IG5ld1NoYXBlSG9sZXMgPSBbXTtcblx0XHRsZXQgbWFpbklkeCA9IDA7XG5cdFx0bGV0IHRtcFBvaW50cztcblxuXHRcdG5ld1NoYXBlc1sgbWFpbklkeCBdID0gdW5kZWZpbmVkO1xuXHRcdG5ld1NoYXBlSG9sZXNbIG1haW5JZHggXSA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc3ViUGF0aHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dG1wUGF0aCA9IHN1YlBhdGhzWyBpIF07XG5cdFx0XHR0bXBQb2ludHMgPSB0bXBQYXRoLmdldFBvaW50cygpO1xuXHRcdFx0c29saWQgPSBpc0Nsb2NrV2lzZSggdG1wUG9pbnRzICk7XG5cdFx0XHRzb2xpZCA9IGlzQ0NXID8gISBzb2xpZCA6IHNvbGlkO1xuXG5cdFx0XHRpZiAoIHNvbGlkICkge1xuXG5cdFx0XHRcdGlmICggKCAhIGhvbGVzRmlyc3QgKSAmJiAoIG5ld1NoYXBlc1sgbWFpbklkeCBdICkgKVx0bWFpbklkeCArKztcblxuXHRcdFx0XHRuZXdTaGFwZXNbIG1haW5JZHggXSA9IHsgczogbmV3IFNoYXBlKCksIHA6IHRtcFBvaW50cyB9O1xuXHRcdFx0XHRuZXdTaGFwZXNbIG1haW5JZHggXS5zLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuXG5cdFx0XHRcdGlmICggaG9sZXNGaXJzdCApXHRtYWluSWR4ICsrO1xuXHRcdFx0XHRuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0gPSBbXTtcblxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdjdycsIGkpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG5ld1NoYXBlSG9sZXNbIG1haW5JZHggXS5wdXNoKCB7IGg6IHRtcFBhdGgsIHA6IHRtcFBvaW50c1sgMCBdIH0gKTtcblxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdjY3cnLCBpKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gb25seSBIb2xlcz8gLT4gcHJvYmFibHkgYWxsIFNoYXBlcyB3aXRoIHdyb25nIG9yaWVudGF0aW9uXG5cdFx0aWYgKCAhIG5ld1NoYXBlc1sgMCBdIClcdHJldHVyblx0dG9TaGFwZXNOb0hvbGVzKCBzdWJQYXRocyApO1xuXG5cblx0XHRpZiAoIG5ld1NoYXBlcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRsZXQgYW1iaWd1b3VzID0gZmFsc2U7XG5cdFx0XHRsZXQgdG9DaGFuZ2UgPSAwO1xuXG5cdFx0XHRmb3IgKCBsZXQgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcblxuXHRcdFx0XHRiZXR0ZXJTaGFwZUhvbGVzWyBzSWR4IF0gPSBbXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBsZXQgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcblxuXHRcdFx0XHRjb25zdCBzaG8gPSBuZXdTaGFwZUhvbGVzWyBzSWR4IF07XG5cblx0XHRcdFx0Zm9yICggbGV0IGhJZHggPSAwOyBoSWR4IDwgc2hvLmxlbmd0aDsgaElkeCArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGhvID0gc2hvWyBoSWR4IF07XG5cdFx0XHRcdFx0bGV0IGhvbGVfdW5hc3NpZ25lZCA9IHRydWU7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgczJJZHggPSAwOyBzMklkeCA8IG5ld1NoYXBlcy5sZW5ndGg7IHMySWR4ICsrICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBoby5wLCBuZXdTaGFwZXNbIHMySWR4IF0ucCApICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggc0lkeCAhPT0gczJJZHggKVx0dG9DaGFuZ2UgKys7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRob2xlX3VuYXNzaWduZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRiZXR0ZXJTaGFwZUhvbGVzWyBzMklkeCBdLnB1c2goIGhvICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdGFtYmlndW91cyA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcblxuXHRcdFx0XHRcdFx0YmV0dGVyU2hhcGVIb2xlc1sgc0lkeCBdLnB1c2goIGhvICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdG9DaGFuZ2UgPiAwICYmIGFtYmlndW91cyA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0bmV3U2hhcGVIb2xlcyA9IGJldHRlclNoYXBlSG9sZXM7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGxldCB0bXBIb2xlcztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBuZXdTaGFwZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRtcFNoYXBlID0gbmV3U2hhcGVzWyBpIF0ucztcblx0XHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xuXHRcdFx0dG1wSG9sZXMgPSBuZXdTaGFwZUhvbGVzWyBpIF07XG5cblx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSB0bXBIb2xlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHR0bXBTaGFwZS5ob2xlcy5wdXNoKCB0bXBIb2xlc1sgaiBdLmggKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9jb25zb2xlLmxvZyhcInNoYXBlXCIsIHNoYXBlcyk7XG5cblx0XHRyZXR1cm4gc2hhcGVzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBDb250cm9scyBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IoIG9iamVjdCwgZG9tRWxlbWVudCA9IG51bGwgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cdFx0dGhpcy5kb21FbGVtZW50ID0gZG9tRWxlbWVudDtcblxuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cblx0XHR0aGlzLnN0YXRlID0gLSAxO1xuXG5cdFx0dGhpcy5rZXlzID0ge307XG5cdFx0dGhpcy5tb3VzZUJ1dHRvbnMgPSB7IExFRlQ6IG51bGwsIE1JRERMRTogbnVsbCwgUklHSFQ6IG51bGwgfTtcblx0XHR0aGlzLnRvdWNoZXMgPSB7IE9ORTogbnVsbCwgVFdPOiBudWxsIH07XG5cblx0fVxuXG5cdGNvbm5lY3QoKSB7fVxuXG5cdGRpc2Nvbm5lY3QoKSB7fVxuXG5cdGRpc3Bvc2UoKSB7fVxuXG5cdHVwZGF0ZSggLyogZGVsdGEgKi8gKSB7fVxuXG59XG5cbmZ1bmN0aW9uIGNvbnRhaW4oIHRleHR1cmUsIGFzcGVjdCApIHtcblxuXHRjb25zdCBpbWFnZUFzcGVjdCA9ICggdGV4dHVyZS5pbWFnZSAmJiB0ZXh0dXJlLmltYWdlLndpZHRoICkgPyB0ZXh0dXJlLmltYWdlLndpZHRoIC8gdGV4dHVyZS5pbWFnZS5oZWlnaHQgOiAxO1xuXG5cdGlmICggaW1hZ2VBc3BlY3QgPiBhc3BlY3QgKSB7XG5cblx0XHR0ZXh0dXJlLnJlcGVhdC54ID0gMTtcblx0XHR0ZXh0dXJlLnJlcGVhdC55ID0gaW1hZ2VBc3BlY3QgLyBhc3BlY3Q7XG5cblx0XHR0ZXh0dXJlLm9mZnNldC54ID0gMDtcblx0XHR0ZXh0dXJlLm9mZnNldC55ID0gKCAxIC0gdGV4dHVyZS5yZXBlYXQueSApIC8gMjtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dGV4dHVyZS5yZXBlYXQueCA9IGFzcGVjdCAvIGltYWdlQXNwZWN0O1xuXHRcdHRleHR1cmUucmVwZWF0LnkgPSAxO1xuXG5cdFx0dGV4dHVyZS5vZmZzZXQueCA9ICggMSAtIHRleHR1cmUucmVwZWF0LnggKSAvIDI7XG5cdFx0dGV4dHVyZS5vZmZzZXQueSA9IDA7XG5cblx0fVxuXG5cdHJldHVybiB0ZXh0dXJlO1xuXG59XG5cbmZ1bmN0aW9uIGNvdmVyKCB0ZXh0dXJlLCBhc3BlY3QgKSB7XG5cblx0Y29uc3QgaW1hZ2VBc3BlY3QgPSAoIHRleHR1cmUuaW1hZ2UgJiYgdGV4dHVyZS5pbWFnZS53aWR0aCApID8gdGV4dHVyZS5pbWFnZS53aWR0aCAvIHRleHR1cmUuaW1hZ2UuaGVpZ2h0IDogMTtcblxuXHRpZiAoIGltYWdlQXNwZWN0ID4gYXNwZWN0ICkge1xuXG5cdFx0dGV4dHVyZS5yZXBlYXQueCA9IGFzcGVjdCAvIGltYWdlQXNwZWN0O1xuXHRcdHRleHR1cmUucmVwZWF0LnkgPSAxO1xuXG5cdFx0dGV4dHVyZS5vZmZzZXQueCA9ICggMSAtIHRleHR1cmUucmVwZWF0LnggKSAvIDI7XG5cdFx0dGV4dHVyZS5vZmZzZXQueSA9IDA7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRleHR1cmUucmVwZWF0LnggPSAxO1xuXHRcdHRleHR1cmUucmVwZWF0LnkgPSBpbWFnZUFzcGVjdCAvIGFzcGVjdDtcblxuXHRcdHRleHR1cmUub2Zmc2V0LnggPSAwO1xuXHRcdHRleHR1cmUub2Zmc2V0LnkgPSAoIDEgLSB0ZXh0dXJlLnJlcGVhdC55ICkgLyAyO1xuXG5cdH1cblxuXHRyZXR1cm4gdGV4dHVyZTtcblxufVxuXG5mdW5jdGlvbiBmaWxsKCB0ZXh0dXJlICkge1xuXG5cdHRleHR1cmUucmVwZWF0LnggPSAxO1xuXHR0ZXh0dXJlLnJlcGVhdC55ID0gMTtcblxuXHR0ZXh0dXJlLm9mZnNldC54ID0gMDtcblx0dGV4dHVyZS5vZmZzZXQueSA9IDA7XG5cblx0cmV0dXJuIHRleHR1cmU7XG5cbn1cblxuXG5cbi8qKlxuICogR2l2ZW4gdGhlIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgYW5kIHR5cGUgb2YgYSB0ZXh0dXJlLiBEZXRlcm1pbmVzIGhvdyBtYW55XG4gKiBieXRlcyBtdXN0IGJlIHVzZWQgdG8gcmVwcmVzZW50IHRoZSB0ZXh0dXJlLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICogQHBhcmFtIHtOdW1iZXJ9IGZvcm1hdFxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGVcbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byByZXByZXNlbnQgdGhlIHRleHR1cmUuXG4gKi9cbmZ1bmN0aW9uIGdldEJ5dGVMZW5ndGgoIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSApIHtcblxuXHRjb25zdCB0eXBlQnl0ZUxlbmd0aCA9IGdldFRleHR1cmVUeXBlQnl0ZUxlbmd0aCggdHlwZSApO1xuXG5cdHN3aXRjaCAoIGZvcm1hdCApIHtcblxuXHRcdC8vIGh0dHBzOi8vcmVnaXN0cnkua2hyb25vcy5vcmcvT3BlbkdMLVJlZnBhZ2VzL2VzMy4wL2h0bWwvZ2xUZXhJbWFnZTJELnhodG1sXG5cdFx0Y2FzZSBBbHBoYUZvcm1hdDpcblx0XHRcdHJldHVybiB3aWR0aCAqIGhlaWdodDtcblx0XHRjYXNlIEx1bWluYW5jZUZvcm1hdDpcblx0XHRcdHJldHVybiB3aWR0aCAqIGhlaWdodDtcblx0XHRjYXNlIEx1bWluYW5jZUFscGhhRm9ybWF0OlxuXHRcdFx0cmV0dXJuIHdpZHRoICogaGVpZ2h0ICogMjtcblx0XHRjYXNlIFJlZEZvcm1hdDpcblx0XHRcdHJldHVybiAoICggd2lkdGggKiBoZWlnaHQgKSAvIHR5cGVCeXRlTGVuZ3RoLmNvbXBvbmVudHMgKSAqIHR5cGVCeXRlTGVuZ3RoLmJ5dGVMZW5ndGg7XG5cdFx0Y2FzZSBSZWRJbnRlZ2VyRm9ybWF0OlxuXHRcdFx0cmV0dXJuICggKCB3aWR0aCAqIGhlaWdodCApIC8gdHlwZUJ5dGVMZW5ndGguY29tcG9uZW50cyApICogdHlwZUJ5dGVMZW5ndGguYnl0ZUxlbmd0aDtcblx0XHRjYXNlIFJHRm9ybWF0OlxuXHRcdFx0cmV0dXJuICggKCB3aWR0aCAqIGhlaWdodCAqIDIgKSAvIHR5cGVCeXRlTGVuZ3RoLmNvbXBvbmVudHMgKSAqIHR5cGVCeXRlTGVuZ3RoLmJ5dGVMZW5ndGg7XG5cdFx0Y2FzZSBSR0ludGVnZXJGb3JtYXQ6XG5cdFx0XHRyZXR1cm4gKCAoIHdpZHRoICogaGVpZ2h0ICogMiApIC8gdHlwZUJ5dGVMZW5ndGguY29tcG9uZW50cyApICogdHlwZUJ5dGVMZW5ndGguYnl0ZUxlbmd0aDtcblx0XHRjYXNlIFJHQkZvcm1hdDpcblx0XHRcdHJldHVybiAoICggd2lkdGggKiBoZWlnaHQgKiAzICkgLyB0eXBlQnl0ZUxlbmd0aC5jb21wb25lbnRzICkgKiB0eXBlQnl0ZUxlbmd0aC5ieXRlTGVuZ3RoO1xuXHRcdGNhc2UgUkdCQUZvcm1hdDpcblx0XHRcdHJldHVybiAoICggd2lkdGggKiBoZWlnaHQgKiA0ICkgLyB0eXBlQnl0ZUxlbmd0aC5jb21wb25lbnRzICkgKiB0eXBlQnl0ZUxlbmd0aC5ieXRlTGVuZ3RoO1xuXHRcdGNhc2UgUkdCQUludGVnZXJGb3JtYXQ6XG5cdFx0XHRyZXR1cm4gKCAoIHdpZHRoICogaGVpZ2h0ICogNCApIC8gdHlwZUJ5dGVMZW5ndGguY29tcG9uZW50cyApICogdHlwZUJ5dGVMZW5ndGguYnl0ZUxlbmd0aDtcblxuXHRcdC8vIGh0dHBzOi8vcmVnaXN0cnkua2hyb25vcy5vcmcvd2ViZ2wvZXh0ZW5zaW9ucy9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y19zcmdiL1xuXHRcdGNhc2UgUkdCX1MzVENfRFhUMV9Gb3JtYXQ6XG5cdFx0Y2FzZSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQ6XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vciggKCB3aWR0aCArIDMgKSAvIDQgKSAqIE1hdGguZmxvb3IoICggaGVpZ2h0ICsgMyApIC8gNCApICogODtcblx0XHRjYXNlIFJHQkFfUzNUQ19EWFQzX0Zvcm1hdDpcblx0XHRjYXNlIFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdDpcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKCAoIHdpZHRoICsgMyApIC8gNCApICogTWF0aC5mbG9vciggKCBoZWlnaHQgKyAzICkgLyA0ICkgKiAxNjtcblxuXHRcdC8vIGh0dHBzOi8vcmVnaXN0cnkua2hyb25vcy5vcmcvd2ViZ2wvZXh0ZW5zaW9ucy9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMvXG5cdFx0Y2FzZSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdDpcblx0XHRjYXNlIFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdDpcblx0XHRcdHJldHVybiAoIE1hdGgubWF4KCB3aWR0aCwgMTYgKSAqIE1hdGgubWF4KCBoZWlnaHQsIDggKSApIC8gNDtcblx0XHRjYXNlIFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0OlxuXHRcdGNhc2UgUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0OlxuXHRcdFx0cmV0dXJuICggTWF0aC5tYXgoIHdpZHRoLCA4ICkgKiBNYXRoLm1heCggaGVpZ2h0LCA4ICkgKSAvIDI7XG5cblx0XHQvLyBodHRwczovL3JlZ2lzdHJ5Lmtocm9ub3Mub3JnL3dlYmdsL2V4dGVuc2lvbnMvV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0Yy9cblx0XHRjYXNlIFJHQl9FVEMxX0Zvcm1hdDpcblx0XHRjYXNlIFJHQl9FVEMyX0Zvcm1hdDpcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKCAoIHdpZHRoICsgMyApIC8gNCApICogTWF0aC5mbG9vciggKCBoZWlnaHQgKyAzICkgLyA0ICkgKiA4O1xuXHRcdGNhc2UgUkdCQV9FVEMyX0VBQ19Gb3JtYXQ6XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vciggKCB3aWR0aCArIDMgKSAvIDQgKSAqIE1hdGguZmxvb3IoICggaGVpZ2h0ICsgMyApIC8gNCApICogMTY7XG5cblx0XHQvLyBodHRwczovL3JlZ2lzdHJ5Lmtocm9ub3Mub3JnL3dlYmdsL2V4dGVuc2lvbnMvV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2FzdGMvXG5cdFx0Y2FzZSBSR0JBX0FTVENfNHg0X0Zvcm1hdDpcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKCAoIHdpZHRoICsgMyApIC8gNCApICogTWF0aC5mbG9vciggKCBoZWlnaHQgKyAzICkgLyA0ICkgKiAxNjtcblx0XHRjYXNlIFJHQkFfQVNUQ181eDRfRm9ybWF0OlxuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoICggd2lkdGggKyA0ICkgLyA1ICkgKiBNYXRoLmZsb29yKCAoIGhlaWdodCArIDMgKSAvIDQgKSAqIDE2O1xuXHRcdGNhc2UgUkdCQV9BU1RDXzV4NV9Gb3JtYXQ6XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vciggKCB3aWR0aCArIDQgKSAvIDUgKSAqIE1hdGguZmxvb3IoICggaGVpZ2h0ICsgNCApIC8gNSApICogMTY7XG5cdFx0Y2FzZSBSR0JBX0FTVENfNng1X0Zvcm1hdDpcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKCAoIHdpZHRoICsgNSApIC8gNiApICogTWF0aC5mbG9vciggKCBoZWlnaHQgKyA0ICkgLyA1ICkgKiAxNjtcblx0XHRjYXNlIFJHQkFfQVNUQ182eDZfRm9ybWF0OlxuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoICggd2lkdGggKyA1ICkgLyA2ICkgKiBNYXRoLmZsb29yKCAoIGhlaWdodCArIDUgKSAvIDYgKSAqIDE2O1xuXHRcdGNhc2UgUkdCQV9BU1RDXzh4NV9Gb3JtYXQ6XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vciggKCB3aWR0aCArIDcgKSAvIDggKSAqIE1hdGguZmxvb3IoICggaGVpZ2h0ICsgNCApIC8gNSApICogMTY7XG5cdFx0Y2FzZSBSR0JBX0FTVENfOHg2X0Zvcm1hdDpcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKCAoIHdpZHRoICsgNyApIC8gOCApICogTWF0aC5mbG9vciggKCBoZWlnaHQgKyA1ICkgLyA2ICkgKiAxNjtcblx0XHRjYXNlIFJHQkFfQVNUQ184eDhfRm9ybWF0OlxuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoICggd2lkdGggKyA3ICkgLyA4ICkgKiBNYXRoLmZsb29yKCAoIGhlaWdodCArIDcgKSAvIDggKSAqIDE2O1xuXHRcdGNhc2UgUkdCQV9BU1RDXzEweDVfRm9ybWF0OlxuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoICggd2lkdGggKyA5ICkgLyAxMCApICogTWF0aC5mbG9vciggKCBoZWlnaHQgKyA0ICkgLyA1ICkgKiAxNjtcblx0XHRjYXNlIFJHQkFfQVNUQ18xMHg2X0Zvcm1hdDpcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKCAoIHdpZHRoICsgOSApIC8gMTAgKSAqIE1hdGguZmxvb3IoICggaGVpZ2h0ICsgNSApIC8gNiApICogMTY7XG5cdFx0Y2FzZSBSR0JBX0FTVENfMTB4OF9Gb3JtYXQ6XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vciggKCB3aWR0aCArIDkgKSAvIDEwICkgKiBNYXRoLmZsb29yKCAoIGhlaWdodCArIDcgKSAvIDggKSAqIDE2O1xuXHRcdGNhc2UgUkdCQV9BU1RDXzEweDEwX0Zvcm1hdDpcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKCAoIHdpZHRoICsgOSApIC8gMTAgKSAqIE1hdGguZmxvb3IoICggaGVpZ2h0ICsgOSApIC8gMTAgKSAqIDE2O1xuXHRcdGNhc2UgUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdDpcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKCAoIHdpZHRoICsgMTEgKSAvIDEyICkgKiBNYXRoLmZsb29yKCAoIGhlaWdodCArIDkgKSAvIDEwICkgKiAxNjtcblx0XHRjYXNlIFJHQkFfQVNUQ18xMngxMl9Gb3JtYXQ6XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vciggKCB3aWR0aCArIDExICkgLyAxMiApICogTWF0aC5mbG9vciggKCBoZWlnaHQgKyAxMSApIC8gMTIgKSAqIDE2O1xuXG5cdFx0Ly8gaHR0cHM6Ly9yZWdpc3RyeS5raHJvbm9zLm9yZy93ZWJnbC9leHRlbnNpb25zL0VYVF90ZXh0dXJlX2NvbXByZXNzaW9uX2JwdGMvXG5cdFx0Y2FzZSBSR0JBX0JQVENfRm9ybWF0OlxuXHRcdGNhc2UgUkdCX0JQVENfU0lHTkVEX0Zvcm1hdDpcblx0XHRjYXNlIFJHQl9CUFRDX1VOU0lHTkVEX0Zvcm1hdDpcblx0XHRcdHJldHVybiBNYXRoLmNlaWwoIHdpZHRoIC8gNCApICogTWF0aC5jZWlsKCBoZWlnaHQgLyA0ICkgKiAxNjtcblxuXHRcdC8vIGh0dHBzOi8vcmVnaXN0cnkua2hyb25vcy5vcmcvd2ViZ2wvZXh0ZW5zaW9ucy9FWFRfdGV4dHVyZV9jb21wcmVzc2lvbl9yZ3RjL1xuXHRcdGNhc2UgUkVEX1JHVEMxX0Zvcm1hdDpcblx0XHRjYXNlIFNJR05FRF9SRURfUkdUQzFfRm9ybWF0OlxuXHRcdFx0cmV0dXJuIE1hdGguY2VpbCggd2lkdGggLyA0ICkgKiBNYXRoLmNlaWwoIGhlaWdodCAvIDQgKSAqIDg7XG5cdFx0Y2FzZSBSRURfR1JFRU5fUkdUQzJfRm9ybWF0OlxuXHRcdGNhc2UgU0lHTkVEX1JFRF9HUkVFTl9SR1RDMl9Gb3JtYXQ6XG5cdFx0XHRyZXR1cm4gTWF0aC5jZWlsKCB3aWR0aCAvIDQgKSAqIE1hdGguY2VpbCggaGVpZ2h0IC8gNCApICogMTY7XG5cblx0fVxuXG5cdHRocm93IG5ldyBFcnJvcihcblx0XHRgVW5hYmxlIHRvIGRldGVybWluZSB0ZXh0dXJlIGJ5dGUgbGVuZ3RoIGZvciAke2Zvcm1hdH0gZm9ybWF0LmAsXG5cdCk7XG5cbn1cblxuZnVuY3Rpb24gZ2V0VGV4dHVyZVR5cGVCeXRlTGVuZ3RoKCB0eXBlICkge1xuXG5cdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRjYXNlIFVuc2lnbmVkQnl0ZVR5cGU6XG5cdFx0Y2FzZSBCeXRlVHlwZTpcblx0XHRcdHJldHVybiB7IGJ5dGVMZW5ndGg6IDEsIGNvbXBvbmVudHM6IDEgfTtcblx0XHRjYXNlIFVuc2lnbmVkU2hvcnRUeXBlOlxuXHRcdGNhc2UgU2hvcnRUeXBlOlxuXHRcdGNhc2UgSGFsZkZsb2F0VHlwZTpcblx0XHRcdHJldHVybiB7IGJ5dGVMZW5ndGg6IDIsIGNvbXBvbmVudHM6IDEgfTtcblx0XHRjYXNlIFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZTpcblx0XHRjYXNlIFVuc2lnbmVkU2hvcnQ1NTUxVHlwZTpcblx0XHRcdHJldHVybiB7IGJ5dGVMZW5ndGg6IDIsIGNvbXBvbmVudHM6IDQgfTtcblx0XHRjYXNlIFVuc2lnbmVkSW50VHlwZTpcblx0XHRjYXNlIEludFR5cGU6XG5cdFx0Y2FzZSBGbG9hdFR5cGU6XG5cdFx0XHRyZXR1cm4geyBieXRlTGVuZ3RoOiA0LCBjb21wb25lbnRzOiAxIH07XG5cdFx0Y2FzZSBVbnNpZ25lZEludDU5OTlUeXBlOlxuXHRcdFx0cmV0dXJuIHsgYnl0ZUxlbmd0aDogNCwgY29tcG9uZW50czogMyB9O1xuXG5cdH1cblxuXHR0aHJvdyBuZXcgRXJyb3IoIGBVbmtub3duIHRleHR1cmUgdHlwZSAke3R5cGV9LmAgKTtcblxufVxuXG5jb25zdCBUZXh0dXJlVXRpbHMgPSB7XG5cdGNvbnRhaW4sXG5cdGNvdmVyLFxuXHRmaWxsLFxuXHRnZXRCeXRlTGVuZ3RoXG59O1xuXG5pZiAoIHR5cGVvZiBfX1RIUkVFX0RFVlRPT0xTX18gIT09ICd1bmRlZmluZWQnICkge1xuXG5cdF9fVEhSRUVfREVWVE9PTFNfXy5kaXNwYXRjaEV2ZW50KCBuZXcgQ3VzdG9tRXZlbnQoICdyZWdpc3RlcicsIHsgZGV0YWlsOiB7XG5cdFx0cmV2aXNpb246IFJFVklTSU9OLFxuXHR9IH0gKSApO1xuXG59XG5cbmlmICggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cblx0aWYgKCB3aW5kb3cuX19USFJFRV9fICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnV0FSTklORzogTXVsdGlwbGUgaW5zdGFuY2VzIG9mIFRocmVlLmpzIGJlaW5nIGltcG9ydGVkLicgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0d2luZG93Ll9fVEhSRUVfXyA9IFJFVklTSU9OO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBBQ0VTRmlsbWljVG9uZU1hcHBpbmcsIEFkZEVxdWF0aW9uLCBBZGRPcGVyYXRpb24sIEFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlLCBBZGRpdGl2ZUJsZW5kaW5nLCBBZ1hUb25lTWFwcGluZywgQWxwaGFGb3JtYXQsIEFsd2F5c0NvbXBhcmUsIEFsd2F5c0RlcHRoLCBBbHdheXNTdGVuY2lsRnVuYywgQW1iaWVudExpZ2h0LCBBbmltYXRpb25BY3Rpb24sIEFuaW1hdGlvbkNsaXAsIEFuaW1hdGlvbkxvYWRlciwgQW5pbWF0aW9uTWl4ZXIsIEFuaW1hdGlvbk9iamVjdEdyb3VwLCBBbmltYXRpb25VdGlscywgQXJjQ3VydmUsIEFycmF5Q2FtZXJhLCBBcnJvd0hlbHBlciwgQXR0YWNoZWRCaW5kTW9kZSwgQXVkaW8sIEF1ZGlvQW5hbHlzZXIsIEF1ZGlvQ29udGV4dCwgQXVkaW9MaXN0ZW5lciwgQXVkaW9Mb2FkZXIsIEF4ZXNIZWxwZXIsIEJhY2tTaWRlLCBCYXNpY0RlcHRoUGFja2luZywgQmFzaWNTaGFkb3dNYXAsIEJhdGNoZWRNZXNoLCBCb25lLCBCb29sZWFuS2V5ZnJhbWVUcmFjaywgQm94MiwgQm94MywgQm94M0hlbHBlciwgQm94R2VvbWV0cnksIEJveEhlbHBlciwgQnVmZmVyQXR0cmlidXRlLCBCdWZmZXJHZW9tZXRyeSwgQnVmZmVyR2VvbWV0cnlMb2FkZXIsIEJ5dGVUeXBlLCBDYWNoZSwgQ2FtZXJhLCBDYW1lcmFIZWxwZXIsIENhbnZhc1RleHR1cmUsIENhcHN1bGVHZW9tZXRyeSwgQ2F0bXVsbFJvbUN1cnZlMywgQ2luZW9uVG9uZU1hcHBpbmcsIENpcmNsZUdlb21ldHJ5LCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBDbG9jaywgQ29sb3IsIENvbG9yS2V5ZnJhbWVUcmFjaywgQ29sb3JNYW5hZ2VtZW50LCBDb21wcmVzc2VkQXJyYXlUZXh0dXJlLCBDb21wcmVzc2VkQ3ViZVRleHR1cmUsIENvbXByZXNzZWRUZXh0dXJlLCBDb21wcmVzc2VkVGV4dHVyZUxvYWRlciwgQ29uZUdlb21ldHJ5LCBDb25zdGFudEFscGhhRmFjdG9yLCBDb25zdGFudENvbG9yRmFjdG9yLCBDb250cm9scywgQ3ViZUNhbWVyYSwgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nLCBDdWJlUmVmcmFjdGlvbk1hcHBpbmcsIEN1YmVUZXh0dXJlLCBDdWJlVGV4dHVyZUxvYWRlciwgQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcsIEN1YmljQmV6aWVyQ3VydmUsIEN1YmljQmV6aWVyQ3VydmUzLCBDdWJpY0ludGVycG9sYW50LCBDdWxsRmFjZUJhY2ssIEN1bGxGYWNlRnJvbnQsIEN1bGxGYWNlRnJvbnRCYWNrLCBDdWxsRmFjZU5vbmUsIEN1cnZlLCBDdXJ2ZVBhdGgsIEN1c3RvbUJsZW5kaW5nLCBDdXN0b21Ub25lTWFwcGluZywgQ3lsaW5kZXJHZW9tZXRyeSwgQ3lsaW5kcmljYWwsIERhdGEzRFRleHR1cmUsIERhdGFBcnJheVRleHR1cmUsIERhdGFUZXh0dXJlLCBEYXRhVGV4dHVyZUxvYWRlciwgRGF0YVV0aWxzLCBEZWNyZW1lbnRTdGVuY2lsT3AsIERlY3JlbWVudFdyYXBTdGVuY2lsT3AsIERlZmF1bHRMb2FkaW5nTWFuYWdlciwgRGVwdGhGb3JtYXQsIERlcHRoU3RlbmNpbEZvcm1hdCwgRGVwdGhUZXh0dXJlLCBEZXRhY2hlZEJpbmRNb2RlLCBEaXJlY3Rpb25hbExpZ2h0LCBEaXJlY3Rpb25hbExpZ2h0SGVscGVyLCBEaXNjcmV0ZUludGVycG9sYW50LCBEb2RlY2FoZWRyb25HZW9tZXRyeSwgRG91YmxlU2lkZSwgRHN0QWxwaGFGYWN0b3IsIERzdENvbG9yRmFjdG9yLCBEeW5hbWljQ29weVVzYWdlLCBEeW5hbWljRHJhd1VzYWdlLCBEeW5hbWljUmVhZFVzYWdlLCBFZGdlc0dlb21ldHJ5LCBFbGxpcHNlQ3VydmUsIEVxdWFsQ29tcGFyZSwgRXF1YWxEZXB0aCwgRXF1YWxTdGVuY2lsRnVuYywgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcsIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nLCBFdWxlciwgRXZlbnREaXNwYXRjaGVyLCBFeHRydWRlR2VvbWV0cnksIEZpbGVMb2FkZXIsIEZsb2F0MTZCdWZmZXJBdHRyaWJ1dGUsIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsIEZsb2F0VHlwZSwgRm9nLCBGb2dFeHAyLCBGcmFtZWJ1ZmZlclRleHR1cmUsIEZyb250U2lkZSwgRnJ1c3R1bSwgR0xCdWZmZXJBdHRyaWJ1dGUsIEdMU0wxLCBHTFNMMywgR3JlYXRlckNvbXBhcmUsIEdyZWF0ZXJEZXB0aCwgR3JlYXRlckVxdWFsQ29tcGFyZSwgR3JlYXRlckVxdWFsRGVwdGgsIEdyZWF0ZXJFcXVhbFN0ZW5jaWxGdW5jLCBHcmVhdGVyU3RlbmNpbEZ1bmMsIEdyaWRIZWxwZXIsIEdyb3VwLCBIYWxmRmxvYXRUeXBlLCBIZW1pc3BoZXJlTGlnaHQsIEhlbWlzcGhlcmVMaWdodEhlbHBlciwgSWNvc2FoZWRyb25HZW9tZXRyeSwgSW1hZ2VCaXRtYXBMb2FkZXIsIEltYWdlTG9hZGVyLCBJbWFnZVV0aWxzLCBJbmNyZW1lbnRTdGVuY2lsT3AsIEluY3JlbWVudFdyYXBTdGVuY2lsT3AsIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSwgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnksIEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLCBJbnN0YW5jZWRNZXNoLCBJbnQxNkJ1ZmZlckF0dHJpYnV0ZSwgSW50MzJCdWZmZXJBdHRyaWJ1dGUsIEludDhCdWZmZXJBdHRyaWJ1dGUsIEludFR5cGUsIEludGVybGVhdmVkQnVmZmVyLCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSwgSW50ZXJwb2xhbnQsIEludGVycG9sYXRlRGlzY3JldGUsIEludGVycG9sYXRlTGluZWFyLCBJbnRlcnBvbGF0ZVNtb290aCwgSW52ZXJ0U3RlbmNpbE9wLCBLZWVwU3RlbmNpbE9wLCBLZXlmcmFtZVRyYWNrLCBMT0QsIExhdGhlR2VvbWV0cnksIExheWVycywgTGVzc0NvbXBhcmUsIExlc3NEZXB0aCwgTGVzc0VxdWFsQ29tcGFyZSwgTGVzc0VxdWFsRGVwdGgsIExlc3NFcXVhbFN0ZW5jaWxGdW5jLCBMZXNzU3RlbmNpbEZ1bmMsIExpZ2h0LCBMaWdodFByb2JlLCBMaW5lLCBMaW5lMywgTGluZUJhc2ljTWF0ZXJpYWwsIExpbmVDdXJ2ZSwgTGluZUN1cnZlMywgTGluZURhc2hlZE1hdGVyaWFsLCBMaW5lTG9vcCwgTGluZVNlZ21lbnRzLCBMaW5lYXJGaWx0ZXIsIExpbmVhckludGVycG9sYW50LCBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIsIExpbmVhck1pcG1hcExpbmVhckZpbHRlciwgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciwgTGluZWFyU1JHQkNvbG9yU3BhY2UsIExpbmVhclRvbmVNYXBwaW5nLCBMaW5lYXJUcmFuc2ZlciwgTG9hZGVyLCBMb2FkZXJVdGlscywgTG9hZGluZ01hbmFnZXIsIExvb3BPbmNlLCBMb29wUGluZ1BvbmcsIExvb3BSZXBlYXQsIEx1bWluYW5jZUFscGhhRm9ybWF0LCBMdW1pbmFuY2VGb3JtYXQsIE1PVVNFLCBNYXRlcmlhbCwgTWF0ZXJpYWxMb2FkZXIsIE1hdGhVdGlscywgTWF0cml4MiwgTWF0cml4MywgTWF0cml4NCwgTWF4RXF1YXRpb24sIE1lc2gsIE1lc2hCYXNpY01hdGVyaWFsLCBNZXNoRGVwdGhNYXRlcmlhbCwgTWVzaERpc3RhbmNlTWF0ZXJpYWwsIE1lc2hMYW1iZXJ0TWF0ZXJpYWwsIE1lc2hNYXRjYXBNYXRlcmlhbCwgTWVzaE5vcm1hbE1hdGVyaWFsLCBNZXNoUGhvbmdNYXRlcmlhbCwgTWVzaFBoeXNpY2FsTWF0ZXJpYWwsIE1lc2hTdGFuZGFyZE1hdGVyaWFsLCBNZXNoVG9vbk1hdGVyaWFsLCBNaW5FcXVhdGlvbiwgTWlycm9yZWRSZXBlYXRXcmFwcGluZywgTWl4T3BlcmF0aW9uLCBNdWx0aXBseUJsZW5kaW5nLCBNdWx0aXBseU9wZXJhdGlvbiwgTmVhcmVzdEZpbHRlciwgTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciwgTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsIE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLCBOZXV0cmFsVG9uZU1hcHBpbmcsIE5ldmVyQ29tcGFyZSwgTmV2ZXJEZXB0aCwgTmV2ZXJTdGVuY2lsRnVuYywgTm9CbGVuZGluZywgTm9Db2xvclNwYWNlLCBOb1RvbmVNYXBwaW5nLCBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGUsIE5vcm1hbEJsZW5kaW5nLCBOb3RFcXVhbENvbXBhcmUsIE5vdEVxdWFsRGVwdGgsIE5vdEVxdWFsU3RlbmNpbEZ1bmMsIE51bWJlcktleWZyYW1lVHJhY2ssIE9iamVjdDNELCBPYmplY3RMb2FkZXIsIE9iamVjdFNwYWNlTm9ybWFsTWFwLCBPY3RhaGVkcm9uR2VvbWV0cnksIE9uZUZhY3RvciwgT25lTWludXNDb25zdGFudEFscGhhRmFjdG9yLCBPbmVNaW51c0NvbnN0YW50Q29sb3JGYWN0b3IsIE9uZU1pbnVzRHN0QWxwaGFGYWN0b3IsIE9uZU1pbnVzRHN0Q29sb3JGYWN0b3IsIE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IsIE9uZU1pbnVzU3JjQ29sb3JGYWN0b3IsIE9ydGhvZ3JhcGhpY0NhbWVyYSwgUENGU2hhZG93TWFwLCBQQ0ZTb2Z0U2hhZG93TWFwLCBQYXRoLCBQZXJzcGVjdGl2ZUNhbWVyYSwgUGxhbmUsIFBsYW5lR2VvbWV0cnksIFBsYW5lSGVscGVyLCBQb2ludExpZ2h0LCBQb2ludExpZ2h0SGVscGVyLCBQb2ludHMsIFBvaW50c01hdGVyaWFsLCBQb2xhckdyaWRIZWxwZXIsIFBvbHloZWRyb25HZW9tZXRyeSwgUG9zaXRpb25hbEF1ZGlvLCBQcm9wZXJ0eUJpbmRpbmcsIFByb3BlcnR5TWl4ZXIsIFF1YWRyYXRpY0JlemllckN1cnZlLCBRdWFkcmF0aWNCZXppZXJDdXJ2ZTMsIFF1YXRlcm5pb24sIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQsIFJBRDJERUcsIFJFRF9HUkVFTl9SR1RDMl9Gb3JtYXQsIFJFRF9SR1RDMV9Gb3JtYXQsIFJFVklTSU9OLCBSR0JBRGVwdGhQYWNraW5nLCBSR0JBRm9ybWF0LCBSR0JBSW50ZWdlckZvcm1hdCwgUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCwgUkdCQV9BU1RDXzEweDVfRm9ybWF0LCBSR0JBX0FTVENfMTB4Nl9Gb3JtYXQsIFJHQkFfQVNUQ18xMHg4X0Zvcm1hdCwgUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdCwgUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdCwgUkdCQV9BU1RDXzR4NF9Gb3JtYXQsIFJHQkFfQVNUQ181eDRfRm9ybWF0LCBSR0JBX0FTVENfNXg1X0Zvcm1hdCwgUkdCQV9BU1RDXzZ4NV9Gb3JtYXQsIFJHQkFfQVNUQ182eDZfRm9ybWF0LCBSR0JBX0FTVENfOHg1X0Zvcm1hdCwgUkdCQV9BU1RDXzh4Nl9Gb3JtYXQsIFJHQkFfQVNUQ184eDhfRm9ybWF0LCBSR0JBX0JQVENfRm9ybWF0LCBSR0JBX0VUQzJfRUFDX0Zvcm1hdCwgUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0LCBSR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQsIFJHQkFfUzNUQ19EWFQxX0Zvcm1hdCwgUkdCQV9TM1RDX0RYVDNfRm9ybWF0LCBSR0JBX1MzVENfRFhUNV9Gb3JtYXQsIFJHQkRlcHRoUGFja2luZywgUkdCRm9ybWF0LCBSR0JJbnRlZ2VyRm9ybWF0LCBSR0JfQlBUQ19TSUdORURfRm9ybWF0LCBSR0JfQlBUQ19VTlNJR05FRF9Gb3JtYXQsIFJHQl9FVEMxX0Zvcm1hdCwgUkdCX0VUQzJfRm9ybWF0LCBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCwgUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQsIFJHQl9TM1RDX0RYVDFfRm9ybWF0LCBSR0RlcHRoUGFja2luZywgUkdGb3JtYXQsIFJHSW50ZWdlckZvcm1hdCwgUmF3U2hhZGVyTWF0ZXJpYWwsIFJheSwgUmF5Y2FzdGVyLCBSZWN0QXJlYUxpZ2h0LCBSZWRGb3JtYXQsIFJlZEludGVnZXJGb3JtYXQsIFJlaW5oYXJkVG9uZU1hcHBpbmcsIFJlbmRlclRhcmdldCwgUmVuZGVyVGFyZ2V0M0QsIFJlbmRlclRhcmdldEFycmF5LCBSZXBlYXRXcmFwcGluZywgUmVwbGFjZVN0ZW5jaWxPcCwgUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24sIFJpbmdHZW9tZXRyeSwgU0lHTkVEX1JFRF9HUkVFTl9SR1RDMl9Gb3JtYXQsIFNJR05FRF9SRURfUkdUQzFfRm9ybWF0LCBTUkdCQ29sb3JTcGFjZSwgU1JHQlRyYW5zZmVyLCBTY2VuZSwgU2hhZGVyTWF0ZXJpYWwsIFNoYWRvd01hdGVyaWFsLCBTaGFwZSwgU2hhcGVHZW9tZXRyeSwgU2hhcGVQYXRoLCBTaGFwZVV0aWxzLCBTaG9ydFR5cGUsIFNrZWxldG9uLCBTa2VsZXRvbkhlbHBlciwgU2tpbm5lZE1lc2gsIFNvdXJjZSwgU3BoZXJlLCBTcGhlcmVHZW9tZXRyeSwgU3BoZXJpY2FsLCBTcGhlcmljYWxIYXJtb25pY3MzLCBTcGxpbmVDdXJ2ZSwgU3BvdExpZ2h0LCBTcG90TGlnaHRIZWxwZXIsIFNwcml0ZSwgU3ByaXRlTWF0ZXJpYWwsIFNyY0FscGhhRmFjdG9yLCBTcmNBbHBoYVNhdHVyYXRlRmFjdG9yLCBTcmNDb2xvckZhY3RvciwgU3RhdGljQ29weVVzYWdlLCBTdGF0aWNEcmF3VXNhZ2UsIFN0YXRpY1JlYWRVc2FnZSwgU3RlcmVvQ2FtZXJhLCBTdHJlYW1Db3B5VXNhZ2UsIFN0cmVhbURyYXdVc2FnZSwgU3RyZWFtUmVhZFVzYWdlLCBTdHJpbmdLZXlmcmFtZVRyYWNrLCBTdWJ0cmFjdEVxdWF0aW9uLCBTdWJ0cmFjdGl2ZUJsZW5kaW5nLCBUT1VDSCwgVGFuZ2VudFNwYWNlTm9ybWFsTWFwLCBUZXRyYWhlZHJvbkdlb21ldHJ5LCBUZXh0dXJlLCBUZXh0dXJlTG9hZGVyLCBUZXh0dXJlVXRpbHMsIFRvcnVzR2VvbWV0cnksIFRvcnVzS25vdEdlb21ldHJ5LCBUcmlhbmdsZSwgVHJpYW5nbGVGYW5EcmF3TW9kZSwgVHJpYW5nbGVTdHJpcERyYXdNb2RlLCBUcmlhbmdsZXNEcmF3TW9kZSwgVHViZUdlb21ldHJ5LCBVVk1hcHBpbmcsIFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSwgVWludDMyQnVmZmVyQXR0cmlidXRlLCBVaW50OEJ1ZmZlckF0dHJpYnV0ZSwgVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlLCBVbmlmb3JtLCBVbmlmb3Jtc0dyb3VwLCBVbmlmb3Jtc1V0aWxzLCBVbnNpZ25lZEJ5dGVUeXBlLCBVbnNpZ25lZEludDI0OFR5cGUsIFVuc2lnbmVkSW50NTk5OVR5cGUsIFVuc2lnbmVkSW50VHlwZSwgVW5zaWduZWRTaG9ydDQ0NDRUeXBlLCBVbnNpZ25lZFNob3J0NTU1MVR5cGUsIFVuc2lnbmVkU2hvcnRUeXBlLCBWU01TaGFkb3dNYXAsIFZlY3RvcjIsIFZlY3RvcjMsIFZlY3RvcjQsIFZlY3RvcktleWZyYW1lVHJhY2ssIFZpZGVvVGV4dHVyZSwgV2ViR0wzRFJlbmRlclRhcmdldCwgV2ViR0xBcnJheVJlbmRlclRhcmdldCwgV2ViR0xDb29yZGluYXRlU3lzdGVtLCBXZWJHTEN1YmVSZW5kZXJUYXJnZXQsIFdlYkdMUmVuZGVyVGFyZ2V0LCBXZWJHUFVDb29yZGluYXRlU3lzdGVtLCBXaXJlZnJhbWVHZW9tZXRyeSwgV3JhcEFyb3VuZEVuZGluZywgWmVyb0N1cnZhdHVyZUVuZGluZywgWmVyb0ZhY3RvciwgWmVyb1Nsb3BlRW5kaW5nLCBaZXJvU3RlbmNpbE9wLCBhcnJheU5lZWRzVWludDMyLCBjbG9uZVVuaWZvcm1zLCBjcmVhdGVDYW52YXNFbGVtZW50LCBjcmVhdGVFbGVtZW50TlMsIGdldEJ5dGVMZW5ndGgsIGdldFVubGl0VW5pZm9ybUNvbG9yU3BhY2UsIG1lcmdlVW5pZm9ybXMsIHByb2JlQXN5bmMsIHRvTm9ybWFsaXplZFByb2plY3Rpb25NYXRyaXgsIHRvUmV2ZXJzZWRQcm9qZWN0aW9uTWF0cml4LCB3YXJuT25jZSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/three@0.172.0/node_modules/three/build/three.core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/three@0.172.0/node_modules/three/build/three.module.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/three@0.172.0/node_modules/three/build/three.module.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACESFilmicToneMapping: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ACESFilmicToneMapping),\n/* harmony export */   AddEquation: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AddEquation),\n/* harmony export */   AddOperation: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AddOperation),\n/* harmony export */   AdditiveAnimationBlendMode: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AdditiveAnimationBlendMode),\n/* harmony export */   AdditiveBlending: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AdditiveBlending),\n/* harmony export */   AgXToneMapping: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AgXToneMapping),\n/* harmony export */   AlphaFormat: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AlphaFormat),\n/* harmony export */   AlwaysCompare: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AlwaysCompare),\n/* harmony export */   AlwaysDepth: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AlwaysDepth),\n/* harmony export */   AlwaysStencilFunc: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AlwaysStencilFunc),\n/* harmony export */   AmbientLight: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AmbientLight),\n/* harmony export */   AnimationAction: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AnimationAction),\n/* harmony export */   AnimationClip: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AnimationClip),\n/* harmony export */   AnimationLoader: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AnimationLoader),\n/* harmony export */   AnimationMixer: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AnimationMixer),\n/* harmony export */   AnimationObjectGroup: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AnimationObjectGroup),\n/* harmony export */   AnimationUtils: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AnimationUtils),\n/* harmony export */   ArcCurve: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ArcCurve),\n/* harmony export */   ArrayCamera: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ArrayCamera),\n/* harmony export */   ArrowHelper: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ArrowHelper),\n/* harmony export */   AttachedBindMode: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AttachedBindMode),\n/* harmony export */   Audio: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Audio),\n/* harmony export */   AudioAnalyser: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AudioAnalyser),\n/* harmony export */   AudioContext: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AudioContext),\n/* harmony export */   AudioListener: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AudioListener),\n/* harmony export */   AudioLoader: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AudioLoader),\n/* harmony export */   AxesHelper: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AxesHelper),\n/* harmony export */   BackSide: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BackSide),\n/* harmony export */   BasicDepthPacking: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking),\n/* harmony export */   BasicShadowMap: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BasicShadowMap),\n/* harmony export */   BatchedMesh: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BatchedMesh),\n/* harmony export */   Bone: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Bone),\n/* harmony export */   BooleanKeyframeTrack: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BooleanKeyframeTrack),\n/* harmony export */   Box2: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Box2),\n/* harmony export */   Box3: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Box3),\n/* harmony export */   Box3Helper: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Box3Helper),\n/* harmony export */   BoxGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry),\n/* harmony export */   BoxHelper: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BoxHelper),\n/* harmony export */   BufferAttribute: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute),\n/* harmony export */   BufferGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry),\n/* harmony export */   BufferGeometryLoader: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BufferGeometryLoader),\n/* harmony export */   ByteType: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ByteType),\n/* harmony export */   Cache: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Cache),\n/* harmony export */   Camera: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Camera),\n/* harmony export */   CameraHelper: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CameraHelper),\n/* harmony export */   CanvasTexture: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CanvasTexture),\n/* harmony export */   CapsuleGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CapsuleGeometry),\n/* harmony export */   CatmullRomCurve3: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CatmullRomCurve3),\n/* harmony export */   CineonToneMapping: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CineonToneMapping),\n/* harmony export */   CircleGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CircleGeometry),\n/* harmony export */   ClampToEdgeWrapping: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping),\n/* harmony export */   Clock: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Clock),\n/* harmony export */   Color: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color),\n/* harmony export */   ColorKeyframeTrack: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorKeyframeTrack),\n/* harmony export */   ColorManagement: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement),\n/* harmony export */   CompressedArrayTexture: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CompressedArrayTexture),\n/* harmony export */   CompressedCubeTexture: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CompressedCubeTexture),\n/* harmony export */   CompressedTexture: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CompressedTexture),\n/* harmony export */   CompressedTextureLoader: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CompressedTextureLoader),\n/* harmony export */   ConeGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ConeGeometry),\n/* harmony export */   ConstantAlphaFactor: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ConstantAlphaFactor),\n/* harmony export */   ConstantColorFactor: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ConstantColorFactor),\n/* harmony export */   Controls: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Controls),\n/* harmony export */   CubeCamera: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeCamera),\n/* harmony export */   CubeReflectionMapping: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeReflectionMapping),\n/* harmony export */   CubeRefractionMapping: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeRefractionMapping),\n/* harmony export */   CubeTexture: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeTexture),\n/* harmony export */   CubeTextureLoader: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeTextureLoader),\n/* harmony export */   CubeUVReflectionMapping: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeUVReflectionMapping),\n/* harmony export */   CubicBezierCurve: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubicBezierCurve),\n/* harmony export */   CubicBezierCurve3: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubicBezierCurve3),\n/* harmony export */   CubicInterpolant: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubicInterpolant),\n/* harmony export */   CullFaceBack: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CullFaceBack),\n/* harmony export */   CullFaceFront: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CullFaceFront),\n/* harmony export */   CullFaceFrontBack: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CullFaceFrontBack),\n/* harmony export */   CullFaceNone: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CullFaceNone),\n/* harmony export */   Curve: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Curve),\n/* harmony export */   CurvePath: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CurvePath),\n/* harmony export */   CustomBlending: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CustomBlending),\n/* harmony export */   CustomToneMapping: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CustomToneMapping),\n/* harmony export */   CylinderGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry),\n/* harmony export */   Cylindrical: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Cylindrical),\n/* harmony export */   Data3DTexture: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture),\n/* harmony export */   DataArrayTexture: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DataArrayTexture),\n/* harmony export */   DataTexture: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DataTexture),\n/* harmony export */   DataTextureLoader: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DataTextureLoader),\n/* harmony export */   DataUtils: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DataUtils),\n/* harmony export */   DecrementStencilOp: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DecrementStencilOp),\n/* harmony export */   DecrementWrapStencilOp: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DecrementWrapStencilOp),\n/* harmony export */   DefaultLoadingManager: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DefaultLoadingManager),\n/* harmony export */   DepthFormat: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DepthFormat),\n/* harmony export */   DepthStencilFormat: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DepthStencilFormat),\n/* harmony export */   DepthTexture: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DepthTexture),\n/* harmony export */   DetachedBindMode: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DetachedBindMode),\n/* harmony export */   DirectionalLight: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight),\n/* harmony export */   DirectionalLightHelper: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DirectionalLightHelper),\n/* harmony export */   DiscreteInterpolant: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DiscreteInterpolant),\n/* harmony export */   DodecahedronGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DodecahedronGeometry),\n/* harmony export */   DoubleSide: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DoubleSide),\n/* harmony export */   DstAlphaFactor: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DstAlphaFactor),\n/* harmony export */   DstColorFactor: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DstColorFactor),\n/* harmony export */   DynamicCopyUsage: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DynamicCopyUsage),\n/* harmony export */   DynamicDrawUsage: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DynamicDrawUsage),\n/* harmony export */   DynamicReadUsage: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DynamicReadUsage),\n/* harmony export */   EdgesGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EdgesGeometry),\n/* harmony export */   EllipseCurve: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EllipseCurve),\n/* harmony export */   EqualCompare: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EqualCompare),\n/* harmony export */   EqualDepth: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EqualDepth),\n/* harmony export */   EqualStencilFunc: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EqualStencilFunc),\n/* harmony export */   EquirectangularReflectionMapping: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EquirectangularReflectionMapping),\n/* harmony export */   EquirectangularRefractionMapping: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EquirectangularRefractionMapping),\n/* harmony export */   Euler: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Euler),\n/* harmony export */   EventDispatcher: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher),\n/* harmony export */   ExtrudeGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ExtrudeGeometry),\n/* harmony export */   FileLoader: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.FileLoader),\n/* harmony export */   Float16BufferAttribute: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Float16BufferAttribute),\n/* harmony export */   Float32BufferAttribute: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute),\n/* harmony export */   FloatType: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.FloatType),\n/* harmony export */   Fog: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Fog),\n/* harmony export */   FogExp2: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.FogExp2),\n/* harmony export */   FramebufferTexture: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.FramebufferTexture),\n/* harmony export */   FrontSide: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.FrontSide),\n/* harmony export */   Frustum: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Frustum),\n/* harmony export */   GLBufferAttribute: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GLBufferAttribute),\n/* harmony export */   GLSL1: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GLSL1),\n/* harmony export */   GLSL3: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GLSL3),\n/* harmony export */   GreaterCompare: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GreaterCompare),\n/* harmony export */   GreaterDepth: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GreaterDepth),\n/* harmony export */   GreaterEqualCompare: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GreaterEqualCompare),\n/* harmony export */   GreaterEqualDepth: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GreaterEqualDepth),\n/* harmony export */   GreaterEqualStencilFunc: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GreaterEqualStencilFunc),\n/* harmony export */   GreaterStencilFunc: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GreaterStencilFunc),\n/* harmony export */   GridHelper: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GridHelper),\n/* harmony export */   Group: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Group),\n/* harmony export */   HalfFloatType: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType),\n/* harmony export */   HemisphereLight: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.HemisphereLight),\n/* harmony export */   HemisphereLightHelper: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.HemisphereLightHelper),\n/* harmony export */   IcosahedronGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.IcosahedronGeometry),\n/* harmony export */   ImageBitmapLoader: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader),\n/* harmony export */   ImageLoader: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ImageLoader),\n/* harmony export */   ImageUtils: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ImageUtils),\n/* harmony export */   IncrementStencilOp: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.IncrementStencilOp),\n/* harmony export */   IncrementWrapStencilOp: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.IncrementWrapStencilOp),\n/* harmony export */   InstancedBufferAttribute: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute),\n/* harmony export */   InstancedBufferGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferGeometry),\n/* harmony export */   InstancedInterleavedBuffer: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.InstancedInterleavedBuffer),\n/* harmony export */   InstancedMesh: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh),\n/* harmony export */   Int16BufferAttribute: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Int16BufferAttribute),\n/* harmony export */   Int32BufferAttribute: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Int32BufferAttribute),\n/* harmony export */   Int8BufferAttribute: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Int8BufferAttribute),\n/* harmony export */   IntType: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.IntType),\n/* harmony export */   InterleavedBuffer: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer),\n/* harmony export */   InterleavedBufferAttribute: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute),\n/* harmony export */   Interpolant: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Interpolant),\n/* harmony export */   InterpolateDiscrete: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete),\n/* harmony export */   InterpolateLinear: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear),\n/* harmony export */   InterpolateSmooth: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.InterpolateSmooth),\n/* harmony export */   InvertStencilOp: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.InvertStencilOp),\n/* harmony export */   KeepStencilOp: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.KeepStencilOp),\n/* harmony export */   KeyframeTrack: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.KeyframeTrack),\n/* harmony export */   LOD: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LOD),\n/* harmony export */   LatheGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LatheGeometry),\n/* harmony export */   Layers: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Layers),\n/* harmony export */   LessCompare: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LessCompare),\n/* harmony export */   LessDepth: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LessDepth),\n/* harmony export */   LessEqualCompare: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LessEqualCompare),\n/* harmony export */   LessEqualDepth: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LessEqualDepth),\n/* harmony export */   LessEqualStencilFunc: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LessEqualStencilFunc),\n/* harmony export */   LessStencilFunc: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LessStencilFunc),\n/* harmony export */   Light: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Light),\n/* harmony export */   LightProbe: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LightProbe),\n/* harmony export */   Line: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Line),\n/* harmony export */   Line3: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Line3),\n/* harmony export */   LineBasicMaterial: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial),\n/* harmony export */   LineCurve: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LineCurve),\n/* harmony export */   LineCurve3: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LineCurve3),\n/* harmony export */   LineDashedMaterial: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LineDashedMaterial),\n/* harmony export */   LineLoop: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LineLoop),\n/* harmony export */   LineSegments: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LineSegments),\n/* harmony export */   LinearFilter: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearFilter),\n/* harmony export */   LinearInterpolant: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearInterpolant),\n/* harmony export */   LinearMipMapLinearFilter: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearMipMapLinearFilter),\n/* harmony export */   LinearMipMapNearestFilter: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearMipMapNearestFilter),\n/* harmony export */   LinearMipmapLinearFilter: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter),\n/* harmony export */   LinearMipmapNearestFilter: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter),\n/* harmony export */   LinearSRGBColorSpace: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace),\n/* harmony export */   LinearToneMapping: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearToneMapping),\n/* harmony export */   LinearTransfer: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearTransfer),\n/* harmony export */   Loader: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Loader),\n/* harmony export */   LoaderUtils: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils),\n/* harmony export */   LoadingManager: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LoadingManager),\n/* harmony export */   LoopOnce: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LoopOnce),\n/* harmony export */   LoopPingPong: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LoopPingPong),\n/* harmony export */   LoopRepeat: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LoopRepeat),\n/* harmony export */   LuminanceAlphaFormat: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LuminanceAlphaFormat),\n/* harmony export */   LuminanceFormat: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LuminanceFormat),\n/* harmony export */   MOUSE: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MOUSE),\n/* harmony export */   Material: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Material),\n/* harmony export */   MaterialLoader: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MaterialLoader),\n/* harmony export */   MathUtils: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MathUtils),\n/* harmony export */   Matrix2: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2),\n/* harmony export */   Matrix3: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3),\n/* harmony export */   Matrix4: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix4),\n/* harmony export */   MaxEquation: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MaxEquation),\n/* harmony export */   Mesh: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Mesh),\n/* harmony export */   MeshBasicMaterial: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial),\n/* harmony export */   MeshDepthMaterial: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MeshDepthMaterial),\n/* harmony export */   MeshDistanceMaterial: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MeshDistanceMaterial),\n/* harmony export */   MeshLambertMaterial: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MeshLambertMaterial),\n/* harmony export */   MeshMatcapMaterial: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MeshMatcapMaterial),\n/* harmony export */   MeshNormalMaterial: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MeshNormalMaterial),\n/* harmony export */   MeshPhongMaterial: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial),\n/* harmony export */   MeshPhysicalMaterial: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial),\n/* harmony export */   MeshStandardMaterial: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial),\n/* harmony export */   MeshToonMaterial: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MeshToonMaterial),\n/* harmony export */   MinEquation: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MinEquation),\n/* harmony export */   MirroredRepeatWrapping: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping),\n/* harmony export */   MixOperation: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MixOperation),\n/* harmony export */   MultiplyBlending: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MultiplyBlending),\n/* harmony export */   MultiplyOperation: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MultiplyOperation),\n/* harmony export */   NearestFilter: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NearestFilter),\n/* harmony export */   NearestMipMapLinearFilter: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NearestMipMapLinearFilter),\n/* harmony export */   NearestMipMapNearestFilter: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NearestMipMapNearestFilter),\n/* harmony export */   NearestMipmapLinearFilter: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter),\n/* harmony export */   NearestMipmapNearestFilter: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter),\n/* harmony export */   NeutralToneMapping: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NeutralToneMapping),\n/* harmony export */   NeverCompare: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NeverCompare),\n/* harmony export */   NeverDepth: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NeverDepth),\n/* harmony export */   NeverStencilFunc: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NeverStencilFunc),\n/* harmony export */   NoBlending: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoBlending),\n/* harmony export */   NoColorSpace: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoColorSpace),\n/* harmony export */   NoToneMapping: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoToneMapping),\n/* harmony export */   NormalAnimationBlendMode: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NormalAnimationBlendMode),\n/* harmony export */   NormalBlending: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NormalBlending),\n/* harmony export */   NotEqualCompare: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NotEqualCompare),\n/* harmony export */   NotEqualDepth: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NotEqualDepth),\n/* harmony export */   NotEqualStencilFunc: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NotEqualStencilFunc),\n/* harmony export */   NumberKeyframeTrack: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack),\n/* harmony export */   Object3D: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Object3D),\n/* harmony export */   ObjectLoader: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ObjectLoader),\n/* harmony export */   ObjectSpaceNormalMap: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ObjectSpaceNormalMap),\n/* harmony export */   OctahedronGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.OctahedronGeometry),\n/* harmony export */   OneFactor: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.OneFactor),\n/* harmony export */   OneMinusConstantAlphaFactor: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.OneMinusConstantAlphaFactor),\n/* harmony export */   OneMinusConstantColorFactor: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.OneMinusConstantColorFactor),\n/* harmony export */   OneMinusDstAlphaFactor: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.OneMinusDstAlphaFactor),\n/* harmony export */   OneMinusDstColorFactor: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.OneMinusDstColorFactor),\n/* harmony export */   OneMinusSrcAlphaFactor: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.OneMinusSrcAlphaFactor),\n/* harmony export */   OneMinusSrcColorFactor: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.OneMinusSrcColorFactor),\n/* harmony export */   OrthographicCamera: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera),\n/* harmony export */   PCFShadowMap: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PCFShadowMap),\n/* harmony export */   PCFSoftShadowMap: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PCFSoftShadowMap),\n/* harmony export */   PMREMGenerator: () => (/* binding */ PMREMGenerator),\n/* harmony export */   Path: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Path),\n/* harmony export */   PerspectiveCamera: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera),\n/* harmony export */   Plane: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Plane),\n/* harmony export */   PlaneGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry),\n/* harmony export */   PlaneHelper: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PlaneHelper),\n/* harmony export */   PointLight: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PointLight),\n/* harmony export */   PointLightHelper: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PointLightHelper),\n/* harmony export */   Points: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Points),\n/* harmony export */   PointsMaterial: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial),\n/* harmony export */   PolarGridHelper: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PolarGridHelper),\n/* harmony export */   PolyhedronGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PolyhedronGeometry),\n/* harmony export */   PositionalAudio: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PositionalAudio),\n/* harmony export */   PropertyBinding: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding),\n/* harmony export */   PropertyMixer: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PropertyMixer),\n/* harmony export */   QuadraticBezierCurve: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.QuadraticBezierCurve),\n/* harmony export */   QuadraticBezierCurve3: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.QuadraticBezierCurve3),\n/* harmony export */   Quaternion: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion),\n/* harmony export */   QuaternionKeyframeTrack: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack),\n/* harmony export */   QuaternionLinearInterpolant: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.QuaternionLinearInterpolant),\n/* harmony export */   RED_GREEN_RGTC2_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RED_GREEN_RGTC2_Format),\n/* harmony export */   RED_RGTC1_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RED_RGTC1_Format),\n/* harmony export */   REVISION: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.REVISION),\n/* harmony export */   RGBADepthPacking: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking),\n/* harmony export */   RGBAFormat: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat),\n/* harmony export */   RGBAIntegerFormat: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBAIntegerFormat),\n/* harmony export */   RGBA_ASTC_10x10_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_10x10_Format),\n/* harmony export */   RGBA_ASTC_10x5_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_10x5_Format),\n/* harmony export */   RGBA_ASTC_10x6_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_10x6_Format),\n/* harmony export */   RGBA_ASTC_10x8_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_10x8_Format),\n/* harmony export */   RGBA_ASTC_12x10_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_12x10_Format),\n/* harmony export */   RGBA_ASTC_12x12_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_12x12_Format),\n/* harmony export */   RGBA_ASTC_4x4_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_4x4_Format),\n/* harmony export */   RGBA_ASTC_5x4_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_5x4_Format),\n/* harmony export */   RGBA_ASTC_5x5_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_5x5_Format),\n/* harmony export */   RGBA_ASTC_6x5_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_6x5_Format),\n/* harmony export */   RGBA_ASTC_6x6_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_6x6_Format),\n/* harmony export */   RGBA_ASTC_8x5_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_8x5_Format),\n/* harmony export */   RGBA_ASTC_8x6_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_8x6_Format),\n/* harmony export */   RGBA_ASTC_8x8_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_8x8_Format),\n/* harmony export */   RGBA_BPTC_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_BPTC_Format),\n/* harmony export */   RGBA_ETC2_EAC_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ETC2_EAC_Format),\n/* harmony export */   RGBA_PVRTC_2BPPV1_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_PVRTC_2BPPV1_Format),\n/* harmony export */   RGBA_PVRTC_4BPPV1_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_PVRTC_4BPPV1_Format),\n/* harmony export */   RGBA_S3TC_DXT1_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_S3TC_DXT1_Format),\n/* harmony export */   RGBA_S3TC_DXT3_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_S3TC_DXT3_Format),\n/* harmony export */   RGBA_S3TC_DXT5_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_S3TC_DXT5_Format),\n/* harmony export */   RGBDepthPacking: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBDepthPacking),\n/* harmony export */   RGBFormat: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBFormat),\n/* harmony export */   RGBIntegerFormat: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBIntegerFormat),\n/* harmony export */   RGB_BPTC_SIGNED_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_BPTC_SIGNED_Format),\n/* harmony export */   RGB_BPTC_UNSIGNED_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_BPTC_UNSIGNED_Format),\n/* harmony export */   RGB_ETC1_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_ETC1_Format),\n/* harmony export */   RGB_ETC2_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_ETC2_Format),\n/* harmony export */   RGB_PVRTC_2BPPV1_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_PVRTC_2BPPV1_Format),\n/* harmony export */   RGB_PVRTC_4BPPV1_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_PVRTC_4BPPV1_Format),\n/* harmony export */   RGB_S3TC_DXT1_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_S3TC_DXT1_Format),\n/* harmony export */   RGDepthPacking: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGDepthPacking),\n/* harmony export */   RGFormat: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGFormat),\n/* harmony export */   RGIntegerFormat: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGIntegerFormat),\n/* harmony export */   RawShaderMaterial: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RawShaderMaterial),\n/* harmony export */   Ray: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Ray),\n/* harmony export */   Raycaster: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Raycaster),\n/* harmony export */   RectAreaLight: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RectAreaLight),\n/* harmony export */   RedFormat: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RedFormat),\n/* harmony export */   RedIntegerFormat: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RedIntegerFormat),\n/* harmony export */   ReinhardToneMapping: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ReinhardToneMapping),\n/* harmony export */   RenderTarget: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RenderTarget),\n/* harmony export */   RenderTarget3D: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RenderTarget3D),\n/* harmony export */   RenderTargetArray: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RenderTargetArray),\n/* harmony export */   RepeatWrapping: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping),\n/* harmony export */   ReplaceStencilOp: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ReplaceStencilOp),\n/* harmony export */   ReverseSubtractEquation: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ReverseSubtractEquation),\n/* harmony export */   RingGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RingGeometry),\n/* harmony export */   SIGNED_RED_GREEN_RGTC2_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SIGNED_RED_GREEN_RGTC2_Format),\n/* harmony export */   SIGNED_RED_RGTC1_Format: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SIGNED_RED_RGTC1_Format),\n/* harmony export */   SRGBColorSpace: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace),\n/* harmony export */   SRGBTransfer: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer),\n/* harmony export */   Scene: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Scene),\n/* harmony export */   ShaderChunk: () => (/* binding */ ShaderChunk),\n/* harmony export */   ShaderLib: () => (/* binding */ ShaderLib),\n/* harmony export */   ShaderMaterial: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial),\n/* harmony export */   ShadowMaterial: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ShadowMaterial),\n/* harmony export */   Shape: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Shape),\n/* harmony export */   ShapeGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ShapeGeometry),\n/* harmony export */   ShapePath: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ShapePath),\n/* harmony export */   ShapeUtils: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ShapeUtils),\n/* harmony export */   ShortType: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ShortType),\n/* harmony export */   Skeleton: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Skeleton),\n/* harmony export */   SkeletonHelper: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SkeletonHelper),\n/* harmony export */   SkinnedMesh: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh),\n/* harmony export */   Source: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Source),\n/* harmony export */   Sphere: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Sphere),\n/* harmony export */   SphereGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry),\n/* harmony export */   Spherical: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Spherical),\n/* harmony export */   SphericalHarmonics3: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SphericalHarmonics3),\n/* harmony export */   SplineCurve: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SplineCurve),\n/* harmony export */   SpotLight: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SpotLight),\n/* harmony export */   SpotLightHelper: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SpotLightHelper),\n/* harmony export */   Sprite: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Sprite),\n/* harmony export */   SpriteMaterial: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SpriteMaterial),\n/* harmony export */   SrcAlphaFactor: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SrcAlphaFactor),\n/* harmony export */   SrcAlphaSaturateFactor: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SrcAlphaSaturateFactor),\n/* harmony export */   SrcColorFactor: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SrcColorFactor),\n/* harmony export */   StaticCopyUsage: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.StaticCopyUsage),\n/* harmony export */   StaticDrawUsage: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.StaticDrawUsage),\n/* harmony export */   StaticReadUsage: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.StaticReadUsage),\n/* harmony export */   StereoCamera: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.StereoCamera),\n/* harmony export */   StreamCopyUsage: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.StreamCopyUsage),\n/* harmony export */   StreamDrawUsage: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.StreamDrawUsage),\n/* harmony export */   StreamReadUsage: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.StreamReadUsage),\n/* harmony export */   StringKeyframeTrack: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.StringKeyframeTrack),\n/* harmony export */   SubtractEquation: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SubtractEquation),\n/* harmony export */   SubtractiveBlending: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SubtractiveBlending),\n/* harmony export */   TOUCH: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.TOUCH),\n/* harmony export */   TangentSpaceNormalMap: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.TangentSpaceNormalMap),\n/* harmony export */   TetrahedronGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.TetrahedronGeometry),\n/* harmony export */   Texture: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Texture),\n/* harmony export */   TextureLoader: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.TextureLoader),\n/* harmony export */   TextureUtils: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.TextureUtils),\n/* harmony export */   TorusGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.TorusGeometry),\n/* harmony export */   TorusKnotGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.TorusKnotGeometry),\n/* harmony export */   Triangle: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Triangle),\n/* harmony export */   TriangleFanDrawMode: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode),\n/* harmony export */   TriangleStripDrawMode: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode),\n/* harmony export */   TrianglesDrawMode: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode),\n/* harmony export */   TubeGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.TubeGeometry),\n/* harmony export */   UVMapping: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UVMapping),\n/* harmony export */   Uint16BufferAttribute: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Uint16BufferAttribute),\n/* harmony export */   Uint32BufferAttribute: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Uint32BufferAttribute),\n/* harmony export */   Uint8BufferAttribute: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Uint8BufferAttribute),\n/* harmony export */   Uint8ClampedBufferAttribute: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Uint8ClampedBufferAttribute),\n/* harmony export */   Uniform: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Uniform),\n/* harmony export */   UniformsGroup: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UniformsGroup),\n/* harmony export */   UniformsLib: () => (/* binding */ UniformsLib),\n/* harmony export */   UniformsUtils: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils),\n/* harmony export */   UnsignedByteType: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType),\n/* harmony export */   UnsignedInt248Type: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedInt248Type),\n/* harmony export */   UnsignedInt5999Type: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedInt5999Type),\n/* harmony export */   UnsignedIntType: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType),\n/* harmony export */   UnsignedShort4444Type: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedShort4444Type),\n/* harmony export */   UnsignedShort5551Type: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedShort5551Type),\n/* harmony export */   UnsignedShortType: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedShortType),\n/* harmony export */   VSMShadowMap: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.VSMShadowMap),\n/* harmony export */   Vector2: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector2),\n/* harmony export */   Vector3: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3),\n/* harmony export */   Vector4: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector4),\n/* harmony export */   VectorKeyframeTrack: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack),\n/* harmony export */   VideoTexture: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.VideoTexture),\n/* harmony export */   WebGL3DRenderTarget: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.WebGL3DRenderTarget),\n/* harmony export */   WebGLArrayRenderTarget: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.WebGLArrayRenderTarget),\n/* harmony export */   WebGLCoordinateSystem: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.WebGLCoordinateSystem),\n/* harmony export */   WebGLCubeRenderTarget: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.WebGLCubeRenderTarget),\n/* harmony export */   WebGLRenderTarget: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget),\n/* harmony export */   WebGLRenderer: () => (/* binding */ WebGLRenderer),\n/* harmony export */   WebGLUtils: () => (/* binding */ WebGLUtils),\n/* harmony export */   WebGPUCoordinateSystem: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.WebGPUCoordinateSystem),\n/* harmony export */   WireframeGeometry: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.WireframeGeometry),\n/* harmony export */   WrapAroundEnding: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.WrapAroundEnding),\n/* harmony export */   ZeroCurvatureEnding: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ZeroCurvatureEnding),\n/* harmony export */   ZeroFactor: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ZeroFactor),\n/* harmony export */   ZeroSlopeEnding: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ZeroSlopeEnding),\n/* harmony export */   ZeroStencilOp: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ZeroStencilOp),\n/* harmony export */   createCanvasElement: () => (/* reexport safe */ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.createCanvasElement)\n/* harmony export */ });\n/* harmony import */ var _three_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./three.core.js */ \"(ssr)/./node_modules/.pnpm/three@0.172.0/node_modules/three/build/three.core.js\");\n/**\n * @license\n * Copyright 2010-2024 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\n\n\n\nfunction WebGLAnimation() {\n\n\tlet context = null;\n\tlet isAnimating = false;\n\tlet animationLoop = null;\n\tlet requestId = null;\n\n\tfunction onAnimationFrame( time, frame ) {\n\n\t\tanimationLoop( time, frame );\n\n\t\trequestId = context.requestAnimationFrame( onAnimationFrame );\n\n\t}\n\n\treturn {\n\n\t\tstart: function () {\n\n\t\t\tif ( isAnimating === true ) return;\n\t\t\tif ( animationLoop === null ) return;\n\n\t\t\trequestId = context.requestAnimationFrame( onAnimationFrame );\n\n\t\t\tisAnimating = true;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tcontext.cancelAnimationFrame( requestId );\n\n\t\t\tisAnimating = false;\n\n\t\t},\n\n\t\tsetAnimationLoop: function ( callback ) {\n\n\t\t\tanimationLoop = callback;\n\n\t\t},\n\n\t\tsetContext: function ( value ) {\n\n\t\t\tcontext = value;\n\n\t\t}\n\n\t};\n\n}\n\nfunction WebGLAttributes( gl ) {\n\n\tconst buffers = new WeakMap();\n\n\tfunction createBuffer( attribute, bufferType ) {\n\n\t\tconst array = attribute.array;\n\t\tconst usage = attribute.usage;\n\t\tconst size = array.byteLength;\n\n\t\tconst buffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\t\tgl.bufferData( bufferType, array, usage );\n\n\t\tattribute.onUploadCallback();\n\n\t\tlet type;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\ttype = gl.FLOAT;\n\n\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\tif ( attribute.isFloat16BufferAttribute ) {\n\n\t\t\t\ttype = gl.HALF_FLOAT;\n\n\t\t\t} else {\n\n\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\n\t\t\t}\n\n\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\ttype = gl.SHORT;\n\n\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\ttype = gl.UNSIGNED_INT;\n\n\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\ttype = gl.INT;\n\n\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\ttype = gl.BYTE;\n\n\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else if ( array instanceof Uint8ClampedArray ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );\n\n\t\t}\n\n\t\treturn {\n\t\t\tbuffer: buffer,\n\t\t\ttype: type,\n\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\tversion: attribute.version,\n\t\t\tsize: size\n\t\t};\n\n\t}\n\n\tfunction updateBuffer( buffer, attribute, bufferType ) {\n\n\t\tconst array = attribute.array;\n\t\tconst updateRanges = attribute.updateRanges;\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\n\t\tif ( updateRanges.length === 0 ) {\n\n\t\t\t// Not using update ranges\n\t\t\tgl.bufferSubData( bufferType, 0, array );\n\n\t\t} else {\n\n\t\t\t// Before applying update ranges, we merge any adjacent / overlapping\n\t\t\t// ranges to reduce load on `gl.bufferSubData`. Empirically, this has led\n\t\t\t// to performance improvements for applications which make heavy use of\n\t\t\t// update ranges. Likely due to GPU command overhead.\n\t\t\t//\n\t\t\t// Note that to reduce garbage collection between frames, we merge the\n\t\t\t// update ranges in-place. This is safe because this method will clear the\n\t\t\t// update ranges once updated.\n\n\t\t\tupdateRanges.sort( ( a, b ) => a.start - b.start );\n\n\t\t\t// To merge the update ranges in-place, we work from left to right in the\n\t\t\t// existing updateRanges array, merging ranges. This may result in a final\n\t\t\t// array which is smaller than the original. This index tracks the last\n\t\t\t// index representing a merged range, any data after this index can be\n\t\t\t// trimmed once the merge algorithm is completed.\n\t\t\tlet mergeIndex = 0;\n\n\t\t\tfor ( let i = 1; i < updateRanges.length; i ++ ) {\n\n\t\t\t\tconst previousRange = updateRanges[ mergeIndex ];\n\t\t\t\tconst range = updateRanges[ i ];\n\n\t\t\t\t// We add one here to merge adjacent ranges. This is safe because ranges\n\t\t\t\t// operate over positive integers.\n\t\t\t\tif ( range.start <= previousRange.start + previousRange.count + 1 ) {\n\n\t\t\t\t\tpreviousRange.count = Math.max(\n\t\t\t\t\t\tpreviousRange.count,\n\t\t\t\t\t\trange.start + range.count - previousRange.start\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\t++ mergeIndex;\n\t\t\t\t\tupdateRanges[ mergeIndex ] = range;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Trim the array to only contain the merged ranges.\n\t\t\tupdateRanges.length = mergeIndex + 1;\n\n\t\t\tfor ( let i = 0, l = updateRanges.length; i < l; i ++ ) {\n\n\t\t\t\tconst range = updateRanges[ i ];\n\n\t\t\t\tgl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray, range.start, range.count );\n\n\t\t\t}\n\n\t\t\tattribute.clearUpdateRanges();\n\n\t\t}\n\n\t\tattribute.onUploadCallback();\n\n\t}\n\n\t//\n\n\tfunction get( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn buffers.get( attribute );\n\n\t}\n\n\tfunction remove( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tconst data = buffers.get( attribute );\n\n\t\tif ( data ) {\n\n\t\t\tgl.deleteBuffer( data.buffer );\n\n\t\t\tbuffers.delete( attribute );\n\n\t\t}\n\n\t}\n\n\tfunction update( attribute, bufferType ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tif ( attribute.isGLBufferAttribute ) {\n\n\t\t\tconst cached = buffers.get( attribute );\n\n\t\t\tif ( ! cached || cached.version < attribute.version ) {\n\n\t\t\t\tbuffers.set( attribute, {\n\t\t\t\t\tbuffer: attribute.buffer,\n\t\t\t\t\ttype: attribute.type,\n\t\t\t\t\tbytesPerElement: attribute.elementSize,\n\t\t\t\t\tversion: attribute.version\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst data = buffers.get( attribute );\n\n\t\tif ( data === undefined ) {\n\n\t\t\tbuffers.set( attribute, createBuffer( attribute, bufferType ) );\n\n\t\t} else if ( data.version < attribute.version ) {\n\n\t\t\tif ( data.size !== attribute.array.byteLength ) {\n\n\t\t\t\tthrow new Error( 'THREE.WebGLAttributes: The size of the buffer attribute\\'s array buffer does not match the original size. Resizing buffer attributes is not supported.' );\n\n\t\t\t}\n\n\t\t\tupdateBuffer( data.buffer, attribute, bufferType );\n\n\t\t\tdata.version = attribute.version;\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tremove: remove,\n\t\tupdate: update\n\n\t};\n\n}\n\nvar alphahash_fragment = \"#ifdef USE_ALPHAHASH\\n\\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\\n#endif\";\n\nvar alphahash_pars_fragment = \"#ifdef USE_ALPHAHASH\\n\\tconst float ALPHA_HASH_SCALE = 0.05;\\n\\tfloat hash2D( vec2 value ) {\\n\\t\\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\\n\\t}\\n\\tfloat hash3D( vec3 value ) {\\n\\t\\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\\n\\t}\\n\\tfloat getAlphaHashThreshold( vec3 position ) {\\n\\t\\tfloat maxDeriv = max(\\n\\t\\t\\tlength( dFdx( position.xyz ) ),\\n\\t\\t\\tlength( dFdy( position.xyz ) )\\n\\t\\t);\\n\\t\\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\\n\\t\\tvec2 pixScales = vec2(\\n\\t\\t\\texp2( floor( log2( pixScale ) ) ),\\n\\t\\t\\texp2( ceil( log2( pixScale ) ) )\\n\\t\\t);\\n\\t\\tvec2 alpha = vec2(\\n\\t\\t\\thash3D( floor( pixScales.x * position.xyz ) ),\\n\\t\\t\\thash3D( floor( pixScales.y * position.xyz ) )\\n\\t\\t);\\n\\t\\tfloat lerpFactor = fract( log2( pixScale ) );\\n\\t\\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\\n\\t\\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\\n\\t\\tvec3 cases = vec3(\\n\\t\\t\\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\\n\\t\\t\\t( x - 0.5 * a ) / ( 1.0 - a ),\\n\\t\\t\\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\\n\\t\\t);\\n\\t\\tfloat threshold = ( x < ( 1.0 - a ) )\\n\\t\\t\\t? ( ( x < a ) ? cases.x : cases.y )\\n\\t\\t\\t: cases.z;\\n\\t\\treturn clamp( threshold , 1.0e-6, 1.0 );\\n\\t}\\n#endif\";\n\nvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\\n#endif\";\n\nvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\nvar alphatest_fragment = \"#ifdef USE_ALPHATEST\\n\\t#ifdef ALPHA_TO_COVERAGE\\n\\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\\n\\tif ( diffuseColor.a == 0.0 ) discard;\\n\\t#else\\n\\tif ( diffuseColor.a < alphaTest ) discard;\\n\\t#endif\\n#endif\";\n\nvar alphatest_pars_fragment = \"#ifdef USE_ALPHATEST\\n\\tuniform float alphaTest;\\n#endif\";\n\nvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_CLEARCOAT ) \\n\\t\\tclearcoatSpecularIndirect *= ambientOcclusion;\\n\\t#endif\\n\\t#if defined( USE_SHEEN ) \\n\\t\\tsheenSpecularIndirect *= ambientOcclusion;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\\t\\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\\n\\t#endif\\n#endif\";\n\nvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\nvar batching_pars_vertex = \"#ifdef USE_BATCHING\\n\\t#if ! defined( GL_ANGLE_multi_draw )\\n\\t#define gl_DrawID _gl_DrawID\\n\\tuniform int _gl_DrawID;\\n\\t#endif\\n\\tuniform highp sampler2D batchingTexture;\\n\\tuniform highp usampler2D batchingIdTexture;\\n\\tmat4 getBatchingMatrix( const in float i ) {\\n\\t\\tint size = textureSize( batchingTexture, 0 ).x;\\n\\t\\tint j = int( i ) * 4;\\n\\t\\tint x = j % size;\\n\\t\\tint y = j / size;\\n\\t\\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\\n\\t\\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\\n\\t\\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\\n\\t\\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\\n\\t\\treturn mat4( v1, v2, v3, v4 );\\n\\t}\\n\\tfloat getIndirectIndex( const in int i ) {\\n\\t\\tint size = textureSize( batchingIdTexture, 0 ).x;\\n\\t\\tint x = i % size;\\n\\t\\tint y = i / size;\\n\\t\\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\\n\\t}\\n#endif\\n#ifdef USE_BATCHING_COLOR\\n\\tuniform sampler2D batchingColorTexture;\\n\\tvec3 getBatchingColor( const in float i ) {\\n\\t\\tint size = textureSize( batchingColorTexture, 0 ).x;\\n\\t\\tint j = int( i );\\n\\t\\tint x = j % size;\\n\\t\\tint y = j / size;\\n\\t\\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\\n\\t}\\n#endif\";\n\nvar batching_vertex = \"#ifdef USE_BATCHING\\n\\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\\n#endif\";\n\nvar begin_vertex = \"vec3 transformed = vec3( position );\\n#ifdef USE_ALPHAHASH\\n\\tvPosition = vec3( position );\\n#endif\";\n\nvar beginnormal_vertex = \"vec3 objectNormal = vec3( normal );\\n#ifdef USE_TANGENT\\n\\tvec3 objectTangent = vec3( tangent.xyz );\\n#endif\";\n\nvar bsdfs = \"float G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n} // validated\";\n\nvar iridescence_fragment = \"#ifdef USE_IRIDESCENCE\\n\\tconst mat3 XYZ_TO_REC709 = mat3(\\n\\t\\t 3.2404542, -0.9692660,  0.0556434,\\n\\t\\t-1.5371385,  1.8760108, -0.2040259,\\n\\t\\t-0.4985314,  0.0415560,  1.0572252\\n\\t);\\n\\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\\n\\t\\tvec3 sqrtF0 = sqrt( fresnel0 );\\n\\t\\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\\n\\t}\\n\\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\\n\\t\\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\\n\\t}\\n\\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\\n\\t\\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\\n\\t}\\n\\tvec3 evalSensitivity( float OPD, vec3 shift ) {\\n\\t\\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\\n\\t\\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\\n\\t\\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\\n\\t\\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\\n\\t\\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\\n\\t\\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\\n\\t\\txyz /= 1.0685e-7;\\n\\t\\tvec3 rgb = XYZ_TO_REC709 * xyz;\\n\\t\\treturn rgb;\\n\\t}\\n\\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\\n\\t\\tvec3 I;\\n\\t\\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\\n\\t\\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\\n\\t\\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\\n\\t\\tif ( cosTheta2Sq < 0.0 ) {\\n\\t\\t\\treturn vec3( 1.0 );\\n\\t\\t}\\n\\t\\tfloat cosTheta2 = sqrt( cosTheta2Sq );\\n\\t\\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\\n\\t\\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\\n\\t\\tfloat T121 = 1.0 - R12;\\n\\t\\tfloat phi12 = 0.0;\\n\\t\\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\\n\\t\\tfloat phi21 = PI - phi12;\\n\\t\\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\\t\\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\\n\\t\\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\\n\\t\\tvec3 phi23 = vec3( 0.0 );\\n\\t\\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\\n\\t\\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\\n\\t\\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\\n\\t\\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\\n\\t\\tvec3 phi = vec3( phi21 ) + phi23;\\n\\t\\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\\n\\t\\tvec3 r123 = sqrt( R123 );\\n\\t\\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\\n\\t\\tvec3 C0 = R12 + Rs;\\n\\t\\tI = C0;\\n\\t\\tvec3 Cm = Rs - T121;\\n\\t\\tfor ( int m = 1; m <= 2; ++ m ) {\\n\\t\\t\\tCm *= r123;\\n\\t\\t\\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\\n\\t\\t\\tI += Cm * Sm;\\n\\t\\t}\\n\\t\\treturn max( I, vec3( 0.0 ) );\\n\\t}\\n#endif\";\n\nvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vBumpMapUv );\\n\\t\\tvec2 dSTdy = dFdy( vBumpMapUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\\n\\t\\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\\n\\t\\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\";\n\nvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#ifdef ALPHA_TO_COVERAGE\\n\\t\\tfloat distanceToPlane, distanceGradient;\\n\\t\\tfloat clipOpacity = 1.0;\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\\n\\t\\t\\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\\n\\t\\t\\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\\n\\t\\t\\tif ( clipOpacity == 0.0 ) discard;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\t\\tfloat unionClipOpacity = 1.0;\\n\\t\\t\\t#pragma unroll_loop_start\\n\\t\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\t\\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\\n\\t\\t\\t\\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\\n\\t\\t\\t\\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\\n\\t\\t\\t}\\n\\t\\t\\t#pragma unroll_loop_end\\n\\t\\t\\tclipOpacity *= 1.0 - unionClipOpacity;\\n\\t\\t#endif\\n\\t\\tdiffuseColor.a *= clipOpacity;\\n\\t\\tif ( diffuseColor.a == 0.0 ) discard;\\n\\t#else\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\t\\tbool clipped = true;\\n\\t\\t\\t#pragma unroll_loop_start\\n\\t\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\t\\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t\\t}\\n\\t\\t\\t#pragma unroll_loop_end\\n\\t\\t\\tif ( clipped ) discard;\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\nvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\";\n\nvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n#endif\";\n\nvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvClipPosition = - mvPosition.xyz;\\n#endif\";\n\nvar color_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tdiffuseColor *= vColor;\\n#elif defined( USE_COLOR )\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\nvar color_pars_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\n\nvar color_pars_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\n\nvar color_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvColor = vec4( 1.0 );\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\\n\\tvColor = vec3( 1.0 );\\n#endif\\n#ifdef USE_COLOR\\n\\tvColor *= color;\\n#endif\\n#ifdef USE_INSTANCING_COLOR\\n\\tvColor.xyz *= instanceColor.xyz;\\n#endif\\n#ifdef USE_BATCHING_COLOR\\n\\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\\n\\tvColor.xyz *= batchingColor.xyz;\\n#endif\";\n\nvar common = \"#define PI 3.141592653589793\\n#define PI2 6.283185307179586\\n#define PI_HALF 1.5707963267948966\\n#define RECIPROCAL_PI 0.3183098861837907\\n#define RECIPROCAL_PI2 0.15915494309189535\\n#define EPSILON 1e-6\\n#ifndef saturate\\n#define saturate( a ) clamp( a, 0.0, 1.0 )\\n#endif\\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nvec3 pow2( const in vec3 x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract( sin( sn ) * c );\\n}\\n#ifdef HIGH_PRECISION\\n\\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\\n#else\\n\\tfloat precisionSafeLength( vec3 v ) {\\n\\t\\tfloat maxComponent = max3( abs( v ) );\\n\\t\\treturn length( v / maxComponent ) * maxComponent;\\n\\t}\\n#endif\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\n#ifdef USE_ALPHAHASH\\n\\tvarying vec3 vPosition;\\n#endif\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nbool isPerspectiveMatrix( mat4 m ) {\\n\\treturn m[ 2 ][ 3 ] == - 1.0;\\n}\\nvec2 equirectUv( in vec3 dir ) {\\n\\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\treturn vec2( u, v );\\n}\\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\\n\\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\\n\\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\\n}\\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\\n\\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\\n\\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\\n} // validated\";\n\nvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t#define cubeUV_minMipLevel 4.0\\n\\t#define cubeUV_minTileSize 16.0\\n\\tfloat getFace( vec3 direction ) {\\n\\t\\tvec3 absDirection = abs( direction );\\n\\t\\tfloat face = - 1.0;\\n\\t\\tif ( absDirection.x > absDirection.z ) {\\n\\t\\t\\tif ( absDirection.x > absDirection.y )\\n\\t\\t\\t\\tface = direction.x > 0.0 ? 0.0 : 3.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t} else {\\n\\t\\t\\tif ( absDirection.z > absDirection.y )\\n\\t\\t\\t\\tface = direction.z > 0.0 ? 2.0 : 5.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t}\\n\\t\\treturn face;\\n\\t}\\n\\tvec2 getUV( vec3 direction, float face ) {\\n\\t\\tvec2 uv;\\n\\t\\tif ( face == 0.0 ) {\\n\\t\\t\\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 1.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\\n\\t\\t} else if ( face == 2.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\\n\\t\\t} else if ( face == 3.0 ) {\\n\\t\\t\\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 4.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\\n\\t\\t} else {\\n\\t\\t\\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\\n\\t\\t}\\n\\t\\treturn 0.5 * ( uv + 1.0 );\\n\\t}\\n\\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\\n\\t\\tfloat face = getFace( direction );\\n\\t\\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\\n\\t\\tmipInt = max( mipInt, cubeUV_minMipLevel );\\n\\t\\tfloat faceSize = exp2( mipInt );\\n\\t\\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\\n\\t\\tif ( face > 2.0 ) {\\n\\t\\t\\tuv.y += faceSize;\\n\\t\\t\\tface -= 3.0;\\n\\t\\t}\\n\\t\\tuv.x += face * faceSize;\\n\\t\\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\\n\\t\\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\\n\\t\\tuv.x *= CUBEUV_TEXEL_WIDTH;\\n\\t\\tuv.y *= CUBEUV_TEXEL_HEIGHT;\\n\\t\\t#ifdef texture2DGradEXT\\n\\t\\t\\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn texture2D( envMap, uv ).rgb;\\n\\t\\t#endif\\n\\t}\\n\\t#define cubeUV_r0 1.0\\n\\t#define cubeUV_m0 - 2.0\\n\\t#define cubeUV_r1 0.8\\n\\t#define cubeUV_m1 - 1.0\\n\\t#define cubeUV_r4 0.4\\n\\t#define cubeUV_m4 2.0\\n\\t#define cubeUV_r5 0.305\\n\\t#define cubeUV_m5 3.0\\n\\t#define cubeUV_r6 0.21\\n\\t#define cubeUV_m6 4.0\\n\\tfloat roughnessToMip( float roughness ) {\\n\\t\\tfloat mip = 0.0;\\n\\t\\tif ( roughness >= cubeUV_r1 ) {\\n\\t\\t\\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\\n\\t\\t} else if ( roughness >= cubeUV_r4 ) {\\n\\t\\t\\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\\n\\t\\t} else if ( roughness >= cubeUV_r5 ) {\\n\\t\\t\\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\\n\\t\\t} else if ( roughness >= cubeUV_r6 ) {\\n\\t\\t\\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\\n\\t\\t} else {\\n\\t\\t\\tmip = - 2.0 * log2( 1.16 * roughness );\\t\\t}\\n\\t\\treturn mip;\\n\\t}\\n\\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\\n\\t\\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\\n\\t\\tfloat mipF = fract( mip );\\n\\t\\tfloat mipInt = floor( mip );\\n\\t\\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\\n\\t\\tif ( mipF == 0.0 ) {\\n\\t\\t\\treturn vec4( color0, 1.0 );\\n\\t\\t} else {\\n\\t\\t\\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\\n\\t\\t\\treturn vec4( mix( color0, color1, mipF ), 1.0 );\\n\\t\\t}\\n\\t}\\n#endif\";\n\nvar defaultnormal_vertex = \"vec3 transformedNormal = objectNormal;\\n#ifdef USE_TANGENT\\n\\tvec3 transformedTangent = objectTangent;\\n#endif\\n#ifdef USE_BATCHING\\n\\tmat3 bm = mat3( batchingMatrix );\\n\\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\\n\\ttransformedNormal = bm * transformedNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\ttransformedTangent = bm * transformedTangent;\\n\\t#endif\\n#endif\\n#ifdef USE_INSTANCING\\n\\tmat3 im = mat3( instanceMatrix );\\n\\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\\n\\ttransformedNormal = im * transformedNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\ttransformedTangent = im * transformedTangent;\\n\\t#endif\\n#endif\\ntransformedNormal = normalMatrix * transformedNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n#ifdef USE_TANGENT\\n\\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\\n\\t#ifdef FLIP_SIDED\\n\\t\\ttransformedTangent = - transformedTangent;\\n\\t#endif\\n#endif\";\n\nvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\";\n\nvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\\n#endif\";\n\nvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\\n\\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\\n\\t\\temissiveColor = sRGBTransferEOTF( emissiveColor );\\n\\t#endif\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\";\n\nvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\";\n\nvar colorspace_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor );\";\n\nvar colorspace_pars_fragment = \"vec4 LinearTransferOETF( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 sRGBTransferEOTF( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 sRGBTransferOETF( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\";\n\nvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvec3 cameraToFrag;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\";\n\nvar envmap_common_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float envMapIntensity;\\n\\tuniform float flipEnvMap;\\n\\tuniform mat3 envMapRotation;\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\t\\n#endif\";\n\nvar envmap_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float reflectivity;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\";\n\nvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\t\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\";\n\nvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\nvar fog_vertex = \"#ifdef USE_FOG\\n\\tvFogDepth = - mvPosition.z;\\n#endif\";\n\nvar fog_pars_vertex = \"#ifdef USE_FOG\\n\\tvarying float vFogDepth;\\n#endif\";\n\nvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\";\n\nvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float vFogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\nvar gradientmap_pars_fragment = \"#ifdef USE_GRADIENTMAP\\n\\tuniform sampler2D gradientMap;\\n#endif\\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\tfloat dotNL = dot( normal, lightDirection );\\n\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t#ifdef USE_GRADIENTMAP\\n\\t\\treturn vec3( texture2D( gradientMap, coord ).r );\\n\\t#else\\n\\t\\tvec2 fw = fwidth( coord ) * 0.5;\\n\\t\\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\\n\\t#endif\\n}\";\n\nvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\nvar lights_lambert_fragment = \"LambertMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularStrength = specularStrength;\";\n\nvar lights_lambert_pars_fragment = \"varying vec3 vViewPosition;\\nstruct LambertMaterial {\\n\\tvec3 diffuseColor;\\n\\tfloat specularStrength;\\n};\\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Lambert\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Lambert\";\n\nvar lights_pars_begin = \"uniform bool receiveShadow;\\nuniform vec3 ambientLightColor;\\n#if defined( USE_LIGHT_PROBES )\\n\\tuniform vec3 lightProbe[ 9 ];\\n#endif\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\\tfloat x = normal.x, y = normal.y, z = normal.z;\\n\\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\n\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\n\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\n\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\n\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\n\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\\treturn result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\\n\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\n\\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\treturn irradiance;\\n}\\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\tif ( cutoffDistance > 0.0 ) {\\n\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t}\\n\\treturn distanceFalloff;\\n}\\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\\n\\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\\n\\t\\tlight.color = directionalLight.color;\\n\\t\\tlight.direction = directionalLight.direction;\\n\\t\\tlight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\\n\\t\\tvec3 lVector = pointLight.position - geometryPosition;\\n\\t\\tlight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tlight.color = pointLight.color;\\n\\t\\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tlight.visible = ( light.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\\n\\t\\tvec3 lVector = spotLight.position - geometryPosition;\\n\\t\\tlight.direction = normalize( lVector );\\n\\t\\tfloat angleCos = dot( light.direction, spotLight.direction );\\n\\t\\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\tif ( spotAttenuation > 0.0 ) {\\n\\t\\t\\tfloat lightDistance = length( lVector );\\n\\t\\t\\tlight.color = spotLight.color * spotAttenuation;\\n\\t\\t\\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tlight.visible = ( light.color != vec3( 0.0 ) );\\n\\t\\t} else {\\n\\t\\t\\tlight.color = vec3( 0.0 );\\n\\t\\t\\tlight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\\n\\t\\tfloat dotNL = dot( normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\";\n\nvar envmap_physical_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tvec3 getIBLIrradiance( const in vec3 normal ) {\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\\n\\t\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t\\t#else\\n\\t\\t\\treturn vec3( 0.0 );\\n\\t\\t#endif\\n\\t}\\n\\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t\\t\\tvec3 reflectVec = reflect( - viewDir, normal );\\n\\t\\t\\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\\n\\t\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\\n\\t\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t\\t#else\\n\\t\\t\\treturn vec3( 0.0 );\\n\\t\\t#endif\\n\\t}\\n\\t#ifdef USE_ANISOTROPY\\n\\t\\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\\n\\t\\t\\t#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t\\t\\t\\tvec3 bentNormal = cross( bitangent, viewDir );\\n\\t\\t\\t\\tbentNormal = normalize( cross( bentNormal, bitangent ) );\\n\\t\\t\\t\\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\\n\\t\\t\\t\\treturn getIBLRadiance( viewDir, bentNormal, roughness );\\n\\t\\t\\t#else\\n\\t\\t\\t\\treturn vec3( 0.0 );\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\nvar lights_toon_fragment = \"ToonMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\";\n\nvar lights_toon_pars_fragment = \"varying vec3 vViewPosition;\\nstruct ToonMaterial {\\n\\tvec3 diffuseColor;\\n};\\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Toon\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Toon\";\n\nvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\";\n\nvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\nstruct BlinnPhongMaterial {\\n\\tvec3 diffuseColor;\\n\\tvec3 specularColor;\\n\\tfloat specularShininess;\\n\\tfloat specularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\";\n\nvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\\nmaterial.roughness = min( material.roughness, 1.0 );\\n#ifdef IOR\\n\\tmaterial.ior = ior;\\n\\t#ifdef USE_SPECULAR\\n\\t\\tfloat specularIntensityFactor = specularIntensity;\\n\\t\\tvec3 specularColorFactor = specularColor;\\n\\t\\t#ifdef USE_SPECULAR_COLORMAP\\n\\t\\t\\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\\n\\t\\t#endif\\n\\t\\t#ifdef USE_SPECULAR_INTENSITYMAP\\n\\t\\t\\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\\n\\t\\t#endif\\n\\t\\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\\n\\t#else\\n\\t\\tfloat specularIntensityFactor = 1.0;\\n\\t\\tvec3 specularColorFactor = vec3( 1.0 );\\n\\t\\tmaterial.specularF90 = 1.0;\\n\\t#endif\\n\\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.specularF90 = 1.0;\\n#endif\\n#ifdef USE_CLEARCOAT\\n\\tmaterial.clearcoat = clearcoat;\\n\\tmaterial.clearcoatRoughness = clearcoatRoughness;\\n\\tmaterial.clearcoatF0 = vec3( 0.04 );\\n\\tmaterial.clearcoatF90 = 1.0;\\n\\t#ifdef USE_CLEARCOATMAP\\n\\t\\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\t\\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\\n\\t#endif\\n\\tmaterial.clearcoat = saturate( material.clearcoat );\\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\\n\\tmaterial.clearcoatRoughness += geometryRoughness;\\n\\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\\n#endif\\n#ifdef USE_DISPERSION\\n\\tmaterial.dispersion = dispersion;\\n#endif\\n#ifdef USE_IRIDESCENCE\\n\\tmaterial.iridescence = iridescence;\\n\\tmaterial.iridescenceIOR = iridescenceIOR;\\n\\t#ifdef USE_IRIDESCENCEMAP\\n\\t\\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\\n\\t#endif\\n\\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\t\\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\\n\\t#else\\n\\t\\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\\n\\t#endif\\n#endif\\n#ifdef USE_SHEEN\\n\\tmaterial.sheenColor = sheenColor;\\n\\t#ifdef USE_SHEEN_COLORMAP\\n\\t\\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\\n\\t#endif\\n\\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\\n\\t#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\t\\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\\n\\t#endif\\n#endif\\n#ifdef USE_ANISOTROPY\\n\\t#ifdef USE_ANISOTROPYMAP\\n\\t\\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\\n\\t\\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\\n\\t\\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\\n\\t#else\\n\\t\\tvec2 anisotropyV = anisotropyVector;\\n\\t#endif\\n\\tmaterial.anisotropy = length( anisotropyV );\\n\\tif( material.anisotropy == 0.0 ) {\\n\\t\\tanisotropyV = vec2( 1.0, 0.0 );\\n\\t} else {\\n\\t\\tanisotropyV /= material.anisotropy;\\n\\t\\tmaterial.anisotropy = saturate( material.anisotropy );\\n\\t}\\n\\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\\n\\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\\n\\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\\n#endif\";\n\nvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3 diffuseColor;\\n\\tfloat roughness;\\n\\tvec3 specularColor;\\n\\tfloat specularF90;\\n\\tfloat dispersion;\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat clearcoat;\\n\\t\\tfloat clearcoatRoughness;\\n\\t\\tvec3 clearcoatF0;\\n\\t\\tfloat clearcoatF90;\\n\\t#endif\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tfloat iridescence;\\n\\t\\tfloat iridescenceIOR;\\n\\t\\tfloat iridescenceThickness;\\n\\t\\tvec3 iridescenceFresnel;\\n\\t\\tvec3 iridescenceF0;\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\tvec3 sheenColor;\\n\\t\\tfloat sheenRoughness;\\n\\t#endif\\n\\t#ifdef IOR\\n\\t\\tfloat ior;\\n\\t#endif\\n\\t#ifdef USE_TRANSMISSION\\n\\t\\tfloat transmission;\\n\\t\\tfloat transmissionAlpha;\\n\\t\\tfloat thickness;\\n\\t\\tfloat attenuationDistance;\\n\\t\\tvec3 attenuationColor;\\n\\t#endif\\n\\t#ifdef USE_ANISOTROPY\\n\\t\\tfloat anisotropy;\\n\\t\\tfloat alphaT;\\n\\t\\tvec3 anisotropyT;\\n\\t\\tvec3 anisotropyB;\\n\\t#endif\\n};\\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\\nvec3 sheenSpecularDirect = vec3( 0.0 );\\nvec3 sheenSpecularIndirect = vec3(0.0 );\\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\\n    float x2 = x * x;\\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\\n}\\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\n#ifdef USE_ANISOTROPY\\n\\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\\n\\t\\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\\n\\t\\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\\n\\t\\tfloat v = 0.5 / ( gv + gl );\\n\\t\\treturn saturate(v);\\n\\t}\\n\\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\\n\\t\\tfloat a2 = alphaT * alphaB;\\n\\t\\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\\n\\t\\thighp float v2 = dot( v, v );\\n\\t\\tfloat w2 = a2 / v2;\\n\\t\\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\\n\\t}\\n#endif\\n#ifdef USE_CLEARCOAT\\n\\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\\n\\t\\tvec3 f0 = material.clearcoatF0;\\n\\t\\tfloat f90 = material.clearcoatF90;\\n\\t\\tfloat roughness = material.clearcoatRoughness;\\n\\t\\tfloat alpha = pow2( roughness );\\n\\t\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\t\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\t\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\t\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\t\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\t\\tvec3 F = F_Schlick( f0, f90, dotVH );\\n\\t\\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\t\\tfloat D = D_GGX( alpha, dotNH );\\n\\t\\treturn F * ( V * D );\\n\\t}\\n#endif\\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\\n\\tvec3 f0 = material.specularColor;\\n\\tfloat f90 = material.specularF90;\\n\\tfloat roughness = material.roughness;\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\tvec3 F = F_Schlick( f0, f90, dotVH );\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tF = mix( F, material.iridescenceFresnel, material.iridescence );\\n\\t#endif\\n\\t#ifdef USE_ANISOTROPY\\n\\t\\tfloat dotTL = dot( material.anisotropyT, lightDir );\\n\\t\\tfloat dotTV = dot( material.anisotropyT, viewDir );\\n\\t\\tfloat dotTH = dot( material.anisotropyT, halfDir );\\n\\t\\tfloat dotBL = dot( material.anisotropyB, lightDir );\\n\\t\\tfloat dotBV = dot( material.anisotropyB, viewDir );\\n\\t\\tfloat dotBH = dot( material.anisotropyB, halfDir );\\n\\t\\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\\n\\t\\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\\n\\t#else\\n\\t\\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\t\\tfloat D = D_GGX( alpha, dotNH );\\n\\t#endif\\n\\treturn F * ( V * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\n#if defined( USE_SHEEN )\\nfloat D_Charlie( float roughness, float dotNH ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tfloat invAlpha = 1.0 / alpha;\\n\\tfloat cos2h = dotNH * dotNH;\\n\\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\\n\\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\\n}\\nfloat V_Neubelt( float dotNV, float dotNL ) {\\n\\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\\n}\\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat D = D_Charlie( sheenRoughness, dotNH );\\n\\tfloat V = V_Neubelt( dotNV, dotNL );\\n\\treturn sheenColor * ( D * V );\\n}\\n#endif\\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat r2 = roughness * roughness;\\n\\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\\n\\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\\n\\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\\n\\treturn saturate( DG * RECIPROCAL_PI );\\n}\\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\\n\\treturn fab;\\n}\\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\\n\\tvec2 fab = DFGApprox( normal, viewDir, roughness );\\n\\treturn specularColor * fab.x + specularF90 * fab.y;\\n}\\n#ifdef USE_IRIDESCENCE\\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n#else\\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n#endif\\n\\tvec2 fab = DFGApprox( normal, viewDir, roughness );\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\\n\\t#else\\n\\t\\tvec3 Fr = specularColor;\\n\\t#endif\\n\\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\\n\\tfloat Ess = fab.x + fab.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometryNormal;\\n\\t\\tvec3 viewDir = geometryViewDir;\\n\\t\\tvec3 position = geometryPosition;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.roughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(    0, 1,    0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\\n\\t\\tvec3 ccIrradiance = dotNLcc * directLight.color;\\n\\t\\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\\n\\t#endif\\n\\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\\n\\t#endif\\n\\tvec3 singleScattering = vec3( 0.0 );\\n\\tvec3 multiScattering = vec3( 0.0 );\\n\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\\n\\t#else\\n\\t\\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\\n\\t#endif\\n\\tvec3 totalScattering = singleScattering + multiScattering;\\n\\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\\n\\treflectedLight.indirectSpecular += radiance * singleScattering;\\n\\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\\n\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\";\n\nvar lights_fragment_begin = \"\\nvec3 geometryPosition = - vViewPosition;\\nvec3 geometryNormal = normal;\\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\nvec3 geometryClearcoatNormal = vec3( 0.0 );\\n#ifdef USE_CLEARCOAT\\n\\tgeometryClearcoatNormal = clearcoatNormal;\\n#endif\\n#ifdef USE_IRIDESCENCE\\n\\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\\n\\tif ( material.iridescenceThickness == 0.0 ) {\\n\\t\\tmaterial.iridescence = 0.0;\\n\\t} else {\\n\\t\\tmaterial.iridescence = saturate( material.iridescence );\\n\\t}\\n\\tif ( material.iridescence > 0.0 ) {\\n\\t\\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\\n\\t\\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\\n\\t}\\n#endif\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointLightInfo( pointLight, geometryPosition, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n\\t\\tpointLightShadow = pointLightShadows[ i ];\\n\\t\\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\tvec4 spotColor;\\n\\tvec3 spotLightCoord;\\n\\tbool inSpotLightMap;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\\n\\t\\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\\n\\t\\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\\n\\t\\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\\n\\t\\t#else\\n\\t\\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\\n\\t\\t#endif\\n\\t\\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\\n\\t\\t\\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\\n\\t\\t\\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\\n\\t\\t\\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\\n\\t\\t\\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\\n\\t\\t#endif\\n\\t\\t#undef SPOT_LIGHT_MAP_INDEX\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\tspotLightShadow = spotLightShadows[ i ];\\n\\t\\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalLightInfo( directionalLight, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 iblIrradiance = vec3( 0.0 );\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#if defined( USE_LIGHT_PROBES )\\n\\t\\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\\n\\t#endif\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearcoatRadiance = vec3( 0.0 );\\n#endif\";\n\nvar lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\\n\\t\\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tiblIrradiance += getIBLIrradiance( geometryNormal );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\t#ifdef USE_ANISOTROPY\\n\\t\\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\\n\\t#else\\n\\t\\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\\n\\t#endif\\n#endif\";\n\nvar lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n#endif\";\n\nvar logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF )\\n\\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\n\nvar logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n\\tvarying float vIsPerspective;\\n#endif\";\n\nvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\tvarying float vFragDepth;\\n\\tvarying float vIsPerspective;\\n#endif\";\n\nvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\tvFragDepth = 1.0 + gl_Position.w;\\n\\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\\n#endif\";\n\nvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\\n\\t#ifdef DECODE_VIDEO_TEXTURE\\n\\t\\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\\n\\t#endif\\n\\tdiffuseColor *= sampledDiffuseColor;\\n#endif\";\n\nvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\";\n\nvar map_particle_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\t#if defined( USE_POINTS_UV )\\n\\t\\tvec2 uv = vUv;\\n\\t#else\\n\\t\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n\\t#endif\\n#endif\\n#ifdef USE_MAP\\n\\tdiffuseColor *= texture2D( map, uv );\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\\n#endif\";\n\nvar map_particle_pars_fragment = \"#if defined( USE_POINTS_UV )\\n\\tvarying vec2 vUv;\\n#else\\n\\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\t\\tuniform mat3 uvTransform;\\n\\t#endif\\n#endif\\n#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\nvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\";\n\nvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\nvar morphinstance_vertex = \"#ifdef USE_INSTANCING_MORPH\\n\\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\\n\\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\\n\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\\n\\t}\\n#endif\";\n\nvar morphcolor_vertex = \"#if defined( USE_MORPHCOLORS )\\n\\tvColor *= morphTargetBaseInfluence;\\n\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\t#if defined( USE_COLOR_ALPHA )\\n\\t\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\\n\\t\\t#elif defined( USE_COLOR )\\n\\t\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\\n\\t\\t#endif\\n\\t}\\n#endif\";\n\nvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal *= morphTargetBaseInfluence;\\n\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\\n\\t}\\n#endif\";\n\nvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_INSTANCING_MORPH\\n\\t\\tuniform float morphTargetBaseInfluence;\\n\\t\\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\\n\\t#endif\\n\\tuniform sampler2DArray morphTargetsTexture;\\n\\tuniform ivec2 morphTargetsTextureSize;\\n\\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\\n\\t\\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\\n\\t\\tint y = texelIndex / morphTargetsTextureSize.x;\\n\\t\\tint x = texelIndex - y * morphTargetsTextureSize.x;\\n\\t\\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\\n\\t\\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\\n\\t}\\n#endif\";\n\nvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed *= morphTargetBaseInfluence;\\n\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\\n\\t}\\n#endif\";\n\nvar normal_fragment_begin = \"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\\n#ifdef FLAT_SHADED\\n\\tvec3 fdx = dFdx( vViewPosition );\\n\\tvec3 fdy = dFdy( vViewPosition );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal *= faceDirection;\\n\\t#endif\\n#endif\\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\\n\\t#ifdef USE_TANGENT\\n\\t\\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\\n\\t#else\\n\\t\\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\\n\\t\\t#if defined( USE_NORMALMAP )\\n\\t\\t\\tvNormalMapUv\\n\\t\\t#elif defined( USE_CLEARCOAT_NORMALMAP )\\n\\t\\t\\tvClearcoatNormalMapUv\\n\\t\\t#else\\n\\t\\t\\tvUv\\n\\t\\t#endif\\n\\t\\t);\\n\\t#endif\\n\\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\\n\\t\\ttbn[0] *= faceDirection;\\n\\t\\ttbn[1] *= faceDirection;\\n\\t#endif\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\t#ifdef USE_TANGENT\\n\\t\\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\\n\\t#else\\n\\t\\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\\n\\t#endif\\n\\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\\n\\t\\ttbn2[0] *= faceDirection;\\n\\t\\ttbn2[1] *= faceDirection;\\n\\t#endif\\n#endif\\nvec3 nonPerturbedNormal = normal;\";\n\nvar normal_fragment_maps = \"#ifdef USE_NORMALMAP_OBJECTSPACE\\n\\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\\n\\t#ifdef FLIP_SIDED\\n\\t\\tnormal = - normal;\\n\\t#endif\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\tnormal = normalize( normalMatrix * normal );\\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\\n\\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\\n\\tmapN.xy *= normalScale;\\n\\tnormal = normalize( tbn * mapN );\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\\n#endif\";\n\nvar normal_pars_fragment = \"#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\";\n\nvar normal_pars_vertex = \"#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\";\n\nvar normal_vertex = \"#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\";\n\nvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n#endif\\n#ifdef USE_NORMALMAP_OBJECTSPACE\\n\\tuniform mat3 normalMatrix;\\n#endif\\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\\n\\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\\n\\t\\tvec3 q0 = dFdx( eye_pos.xyz );\\n\\t\\tvec3 q1 = dFdy( eye_pos.xyz );\\n\\t\\tvec2 st0 = dFdx( uv.st );\\n\\t\\tvec2 st1 = dFdy( uv.st );\\n\\t\\tvec3 N = surf_norm;\\n\\t\\tvec3 q1perp = cross( q1, N );\\n\\t\\tvec3 q0perp = cross( N, q0 );\\n\\t\\tvec3 T = q1perp * st0.x + q0perp * st1.x;\\n\\t\\tvec3 B = q1perp * st0.y + q0perp * st1.y;\\n\\t\\tfloat det = max( dot( T, T ), dot( B, B ) );\\n\\t\\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\\n\\t\\treturn mat3( T * scale, B * scale, N );\\n\\t}\\n#endif\";\n\nvar clearcoat_normal_fragment_begin = \"#ifdef USE_CLEARCOAT\\n\\tvec3 clearcoatNormal = nonPerturbedNormal;\\n#endif\";\n\nvar clearcoat_normal_fragment_maps = \"#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\\n\\tclearcoatMapN.xy *= clearcoatNormalScale;\\n\\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\\n#endif\";\n\nvar clearcoat_pars_fragment = \"#ifdef USE_CLEARCOATMAP\\n\\tuniform sampler2D clearcoatMap;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tuniform sampler2D clearcoatNormalMap;\\n\\tuniform vec2 clearcoatNormalScale;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tuniform sampler2D clearcoatRoughnessMap;\\n#endif\";\n\nvar iridescence_pars_fragment = \"#ifdef USE_IRIDESCENCEMAP\\n\\tuniform sampler2D iridescenceMap;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\tuniform sampler2D iridescenceThicknessMap;\\n#endif\";\n\nvar opaque_fragment = \"#ifdef OPAQUE\\ndiffuseColor.a = 1.0;\\n#endif\\n#ifdef USE_TRANSMISSION\\ndiffuseColor.a *= material.transmissionAlpha;\\n#endif\\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\";\n\nvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\\nconst float Inv255 = 1. / 255.;\\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tif( v <= 0.0 )\\n\\t\\treturn vec4( 0., 0., 0., 0. );\\n\\tif( v >= 1.0 )\\n\\t\\treturn vec4( 1., 1., 1., 1. );\\n\\tfloat vuf;\\n\\tfloat af = modf( v * PackFactors.a, vuf );\\n\\tfloat bf = modf( vuf * ShiftRight8, vuf );\\n\\tfloat gf = modf( vuf * ShiftRight8, vuf );\\n\\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\\n}\\nvec3 packDepthToRGB( const in float v ) {\\n\\tif( v <= 0.0 )\\n\\t\\treturn vec3( 0., 0., 0. );\\n\\tif( v >= 1.0 )\\n\\t\\treturn vec3( 1., 1., 1. );\\n\\tfloat vuf;\\n\\tfloat bf = modf( v * PackFactors.b, vuf );\\n\\tfloat gf = modf( vuf * ShiftRight8, vuf );\\n\\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\\n}\\nvec2 packDepthToRG( const in float v ) {\\n\\tif( v <= 0.0 )\\n\\t\\treturn vec2( 0., 0. );\\n\\tif( v >= 1.0 )\\n\\t\\treturn vec2( 1., 1. );\\n\\tfloat vuf;\\n\\tfloat gf = modf( v * 256., vuf );\\n\\treturn vec2( vuf * Inv255, gf );\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors4 );\\n}\\nfloat unpackRGBToDepth( const in vec3 v ) {\\n\\treturn dot( v, UnpackFactors3 );\\n}\\nfloat unpackRGToDepth( const in vec2 v ) {\\n\\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\\n}\\nvec4 pack2HalfToRGBA( const in vec2 v ) {\\n\\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\\n\\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\\n}\\nvec2 unpackRGBATo2Half( const in vec4 v ) {\\n\\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\\n\\treturn depth * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * depth - far );\\n}\";\n\nvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\";\n\nvar project_vertex = \"vec4 mvPosition = vec4( transformed, 1.0 );\\n#ifdef USE_BATCHING\\n\\tmvPosition = batchingMatrix * mvPosition;\\n#endif\\n#ifdef USE_INSTANCING\\n\\tmvPosition = instanceMatrix * mvPosition;\\n#endif\\nmvPosition = modelViewMatrix * mvPosition;\\ngl_Position = projectionMatrix * mvPosition;\";\n\nvar dithering_fragment = \"#ifdef DITHERING\\n\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\";\n\nvar dithering_pars_fragment = \"#ifdef DITHERING\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\";\n\nvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\";\n\nvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\nvar shadowmap_pars_fragment = \"#if NUM_SPOT_LIGHT_COORDS > 0\\n\\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\\n#endif\\n#if NUM_SPOT_LIGHT_MAPS > 0\\n\\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\\n#endif\\n#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowIntensity;\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowIntensity;\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowIntensity;\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\\n\\t\\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\\n\\t}\\n\\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\\n\\t\\tfloat occlusion = 1.0;\\n\\t\\tvec2 distribution = texture2DDistribution( shadow, uv );\\n\\t\\tfloat hard_shadow = step( compare , distribution.x );\\n\\t\\tif (hard_shadow != 1.0 ) {\\n\\t\\t\\tfloat distance = compare - distribution.x ;\\n\\t\\t\\tfloat variance = max( 0.00000, distribution.y * distribution.y );\\n\\t\\t\\tfloat softness_probability = variance / (variance + distance * distance );\\t\\t\\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\\t\\t\\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\\n\\t\\t}\\n\\t\\treturn occlusion;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\\n\\t\\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx2 = dx0 / 2.0;\\n\\t\\t\\tfloat dy2 = dy0 / 2.0;\\n\\t\\t\\tfloat dx3 = dx1 / 2.0;\\n\\t\\t\\tfloat dy3 = dy1 / 2.0;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 17.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx = texelSize.x;\\n\\t\\t\\tfloat dy = texelSize.y;\\n\\t\\t\\tvec2 uv = shadowCoord.xy;\\n\\t\\t\\tvec2 f = fract( uv * shadowMapSize + 0.5 );\\n\\t\\t\\tuv -= f * texelSize;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  f.x ),\\n\\t\\t\\t\\t\\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  f.x ),\\n\\t\\t\\t\\t\\t f.y )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn mix( 1.0, shadow, shadowIntensity );\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\t\\n\\t\\tfloat lightToPositionLength = length( lightToPosition );\\n\\t\\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\\n\\t\\t\\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\t\\tdp += shadowBias;\\n\\t\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\t\\tshadow = (\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn mix( 1.0, shadow, shadowIntensity );\\n\\t}\\n#endif\";\n\nvar shadowmap_pars_vertex = \"#if NUM_SPOT_LIGHT_COORDS > 0\\n\\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\\n\\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\\n#endif\\n#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowIntensity;\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowIntensity;\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowIntensity;\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n#endif\";\n\nvar shadowmap_vertex = \"#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\\n\\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\tvec4 shadowWorldPosition;\\n#endif\\n#if defined( USE_SHADOWMAP )\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\\n#if NUM_SPOT_LIGHT_COORDS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition;\\n\\t\\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\t\\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\\n\\t\\t#endif\\n\\t\\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\";\n\nvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tspotLight = spotLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tpointLight = pointLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\";\n\nvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\nvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\tuniform highp sampler2D boneTexture;\\n\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\tint size = textureSize( boneTexture, 0 ).x;\\n\\t\\tint j = int( i ) * 4;\\n\\t\\tint x = j % size;\\n\\t\\tint y = j / size;\\n\\t\\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\\n\\t\\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\\n\\t\\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\\n\\t\\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\\n\\t\\treturn mat4( v1, v2, v3, v4 );\\n\\t}\\n#endif\";\n\nvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\";\n\nvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\t#ifdef USE_TANGENT\\n\\t\\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#endif\\n#endif\";\n\nvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\nvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\nvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\";\n\nvar tonemapping_pars_fragment = \"#ifndef saturate\\n#define saturate( a ) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn saturate( toneMappingExposure * color );\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\nvec3 CineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 RRTAndODTFit( vec3 v ) {\\n\\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\\n\\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\\n\\treturn a / b;\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tconst mat3 ACESInputMat = mat3(\\n\\t\\tvec3( 0.59719, 0.07600, 0.02840 ),\\t\\tvec3( 0.35458, 0.90834, 0.13383 ),\\n\\t\\tvec3( 0.04823, 0.01566, 0.83777 )\\n\\t);\\n\\tconst mat3 ACESOutputMat = mat3(\\n\\t\\tvec3(  1.60475, -0.10208, -0.00327 ),\\t\\tvec3( -0.53108,  1.10813, -0.07276 ),\\n\\t\\tvec3( -0.07367, -0.00605,  1.07602 )\\n\\t);\\n\\tcolor *= toneMappingExposure / 0.6;\\n\\tcolor = ACESInputMat * color;\\n\\tcolor = RRTAndODTFit( color );\\n\\tcolor = ACESOutputMat * color;\\n\\treturn saturate( color );\\n}\\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\\n\\tvec3( 1.6605, - 0.1246, - 0.0182 ),\\n\\tvec3( - 0.5876, 1.1329, - 0.1006 ),\\n\\tvec3( - 0.0728, - 0.0083, 1.1187 )\\n);\\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\\n\\tvec3( 0.6274, 0.0691, 0.0164 ),\\n\\tvec3( 0.3293, 0.9195, 0.0880 ),\\n\\tvec3( 0.0433, 0.0113, 0.8956 )\\n);\\nvec3 agxDefaultContrastApprox( vec3 x ) {\\n\\tvec3 x2 = x * x;\\n\\tvec3 x4 = x2 * x2;\\n\\treturn + 15.5 * x4 * x2\\n\\t\\t- 40.14 * x4 * x\\n\\t\\t+ 31.96 * x4\\n\\t\\t- 6.868 * x2 * x\\n\\t\\t+ 0.4298 * x2\\n\\t\\t+ 0.1191 * x\\n\\t\\t- 0.00232;\\n}\\nvec3 AgXToneMapping( vec3 color ) {\\n\\tconst mat3 AgXInsetMatrix = mat3(\\n\\t\\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\\n\\t\\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\\n\\t\\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\\n\\t);\\n\\tconst mat3 AgXOutsetMatrix = mat3(\\n\\t\\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\\n\\t\\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\\n\\t\\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\\n\\t);\\n\\tconst float AgxMinEv = - 12.47393;\\tconst float AgxMaxEv = 4.026069;\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\\n\\tcolor = AgXInsetMatrix * color;\\n\\tcolor = max( color, 1e-10 );\\tcolor = log2( color );\\n\\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\\n\\tcolor = clamp( color, 0.0, 1.0 );\\n\\tcolor = agxDefaultContrastApprox( color );\\n\\tcolor = AgXOutsetMatrix * color;\\n\\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\\n\\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\\n\\tcolor = clamp( color, 0.0, 1.0 );\\n\\treturn color;\\n}\\nvec3 NeutralToneMapping( vec3 color ) {\\n\\tconst float StartCompression = 0.8 - 0.04;\\n\\tconst float Desaturation = 0.15;\\n\\tcolor *= toneMappingExposure;\\n\\tfloat x = min( color.r, min( color.g, color.b ) );\\n\\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\\n\\tcolor -= offset;\\n\\tfloat peak = max( color.r, max( color.g, color.b ) );\\n\\tif ( peak < StartCompression ) return color;\\n\\tfloat d = 1. - StartCompression;\\n\\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\\n\\tcolor *= newPeak / peak;\\n\\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\\n\\treturn mix( color, vec3( newPeak ), g );\\n}\\nvec3 CustomToneMapping( vec3 color ) { return color; }\";\n\nvar transmission_fragment = \"#ifdef USE_TRANSMISSION\\n\\tmaterial.transmission = transmission;\\n\\tmaterial.transmissionAlpha = 1.0;\\n\\tmaterial.thickness = thickness;\\n\\tmaterial.attenuationDistance = attenuationDistance;\\n\\tmaterial.attenuationColor = attenuationColor;\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\\n\\t#endif\\n\\tvec3 pos = vWorldPosition;\\n\\tvec3 v = normalize( cameraPosition - pos );\\n\\tvec3 n = inverseTransformDirection( normal, viewMatrix );\\n\\tvec4 transmitted = getIBLVolumeRefraction(\\n\\t\\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\\n\\t\\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\\n\\t\\tmaterial.attenuationColor, material.attenuationDistance );\\n\\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\\n\\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\\n#endif\";\n\nvar transmission_pars_fragment = \"#ifdef USE_TRANSMISSION\\n\\tuniform float transmission;\\n\\tuniform float thickness;\\n\\tuniform float attenuationDistance;\\n\\tuniform vec3 attenuationColor;\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\tuniform sampler2D transmissionMap;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tuniform sampler2D thicknessMap;\\n\\t#endif\\n\\tuniform vec2 transmissionSamplerSize;\\n\\tuniform sampler2D transmissionSamplerMap;\\n\\tuniform mat4 modelMatrix;\\n\\tuniform mat4 projectionMatrix;\\n\\tvarying vec3 vWorldPosition;\\n\\tfloat w0( float a ) {\\n\\t\\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\\n\\t}\\n\\tfloat w1( float a ) {\\n\\t\\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\\n\\t}\\n\\tfloat w2( float a ){\\n\\t\\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\\n\\t}\\n\\tfloat w3( float a ) {\\n\\t\\treturn ( 1.0 / 6.0 ) * ( a * a * a );\\n\\t}\\n\\tfloat g0( float a ) {\\n\\t\\treturn w0( a ) + w1( a );\\n\\t}\\n\\tfloat g1( float a ) {\\n\\t\\treturn w2( a ) + w3( a );\\n\\t}\\n\\tfloat h0( float a ) {\\n\\t\\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\\n\\t}\\n\\tfloat h1( float a ) {\\n\\t\\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\\n\\t}\\n\\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\\n\\t\\tuv = uv * texelSize.zw + 0.5;\\n\\t\\tvec2 iuv = floor( uv );\\n\\t\\tvec2 fuv = fract( uv );\\n\\t\\tfloat g0x = g0( fuv.x );\\n\\t\\tfloat g1x = g1( fuv.x );\\n\\t\\tfloat h0x = h0( fuv.x );\\n\\t\\tfloat h1x = h1( fuv.x );\\n\\t\\tfloat h0y = h0( fuv.y );\\n\\t\\tfloat h1y = h1( fuv.y );\\n\\t\\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\\n\\t\\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\\n\\t\\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\\n\\t\\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\\n\\t\\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\\n\\t\\t\\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\\n\\t}\\n\\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\\n\\t\\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\\n\\t\\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\\n\\t\\tvec2 fLodSizeInv = 1.0 / fLodSize;\\n\\t\\tvec2 cLodSizeInv = 1.0 / cLodSize;\\n\\t\\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\\n\\t\\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\\n\\t\\treturn mix( fSample, cSample, fract( lod ) );\\n\\t}\\n\\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\\n\\t\\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\\n\\t\\tvec3 modelScale;\\n\\t\\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\\n\\t\\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\\n\\t\\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\\n\\t\\treturn normalize( refractionVector ) * thickness * modelScale;\\n\\t}\\n\\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\\n\\t\\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\\n\\t}\\n\\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\\n\\t\\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\\n\\t\\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\\n\\t}\\n\\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\\n\\t\\tif ( isinf( attenuationDistance ) ) {\\n\\t\\t\\treturn vec3( 1.0 );\\n\\t\\t} else {\\n\\t\\t\\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\\n\\t\\t\\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\\t\\t\\treturn transmittance;\\n\\t\\t}\\n\\t}\\n\\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\\n\\t\\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\\n\\t\\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\\n\\t\\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\\n\\t\\tvec4 transmittedLight;\\n\\t\\tvec3 transmittance;\\n\\t\\t#ifdef USE_DISPERSION\\n\\t\\t\\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\\n\\t\\t\\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\\n\\t\\t\\tfor ( int i = 0; i < 3; i ++ ) {\\n\\t\\t\\t\\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\\n\\t\\t\\t\\tvec3 refractedRayExit = position + transmissionRay;\\n\\t\\t\\t\\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\\n\\t\\t\\t\\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n\\t\\t\\t\\trefractionCoords += 1.0;\\n\\t\\t\\t\\trefractionCoords /= 2.0;\\n\\t\\t\\t\\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\\n\\t\\t\\t\\ttransmittedLight[ i ] = transmissionSample[ i ];\\n\\t\\t\\t\\ttransmittedLight.a += transmissionSample.a;\\n\\t\\t\\t\\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\\n\\t\\t\\t}\\n\\t\\t\\ttransmittedLight.a /= 3.0;\\n\\t\\t#else\\n\\t\\t\\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\\n\\t\\t\\tvec3 refractedRayExit = position + transmissionRay;\\n\\t\\t\\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\\n\\t\\t\\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n\\t\\t\\trefractionCoords += 1.0;\\n\\t\\t\\trefractionCoords /= 2.0;\\n\\t\\t\\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\\n\\t\\t\\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\\n\\t\\t#endif\\n\\t\\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\\n\\t\\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\\n\\t\\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\\n\\t\\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\\n\\t}\\n#endif\";\n\nvar uv_pars_fragment = \"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\\n\\tvarying vec2 vUv;\\n#endif\\n#ifdef USE_MAP\\n\\tvarying vec2 vMapUv;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tvarying vec2 vAlphaMapUv;\\n#endif\\n#ifdef USE_LIGHTMAP\\n\\tvarying vec2 vLightMapUv;\\n#endif\\n#ifdef USE_AOMAP\\n\\tvarying vec2 vAoMapUv;\\n#endif\\n#ifdef USE_BUMPMAP\\n\\tvarying vec2 vBumpMapUv;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tvarying vec2 vNormalMapUv;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\\tvarying vec2 vEmissiveMapUv;\\n#endif\\n#ifdef USE_METALNESSMAP\\n\\tvarying vec2 vMetalnessMapUv;\\n#endif\\n#ifdef USE_ROUGHNESSMAP\\n\\tvarying vec2 vRoughnessMapUv;\\n#endif\\n#ifdef USE_ANISOTROPYMAP\\n\\tvarying vec2 vAnisotropyMapUv;\\n#endif\\n#ifdef USE_CLEARCOATMAP\\n\\tvarying vec2 vClearcoatMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvarying vec2 vClearcoatNormalMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tvarying vec2 vClearcoatRoughnessMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCEMAP\\n\\tvarying vec2 vIridescenceMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\tvarying vec2 vIridescenceThicknessMapUv;\\n#endif\\n#ifdef USE_SHEEN_COLORMAP\\n\\tvarying vec2 vSheenColorMapUv;\\n#endif\\n#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\tvarying vec2 vSheenRoughnessMapUv;\\n#endif\\n#ifdef USE_SPECULARMAP\\n\\tvarying vec2 vSpecularMapUv;\\n#endif\\n#ifdef USE_SPECULAR_COLORMAP\\n\\tvarying vec2 vSpecularColorMapUv;\\n#endif\\n#ifdef USE_SPECULAR_INTENSITYMAP\\n\\tvarying vec2 vSpecularIntensityMapUv;\\n#endif\\n#ifdef USE_TRANSMISSIONMAP\\n\\tuniform mat3 transmissionMapTransform;\\n\\tvarying vec2 vTransmissionMapUv;\\n#endif\\n#ifdef USE_THICKNESSMAP\\n\\tuniform mat3 thicknessMapTransform;\\n\\tvarying vec2 vThicknessMapUv;\\n#endif\";\n\nvar uv_pars_vertex = \"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\\n\\tvarying vec2 vUv;\\n#endif\\n#ifdef USE_MAP\\n\\tuniform mat3 mapTransform;\\n\\tvarying vec2 vMapUv;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tuniform mat3 alphaMapTransform;\\n\\tvarying vec2 vAlphaMapUv;\\n#endif\\n#ifdef USE_LIGHTMAP\\n\\tuniform mat3 lightMapTransform;\\n\\tvarying vec2 vLightMapUv;\\n#endif\\n#ifdef USE_AOMAP\\n\\tuniform mat3 aoMapTransform;\\n\\tvarying vec2 vAoMapUv;\\n#endif\\n#ifdef USE_BUMPMAP\\n\\tuniform mat3 bumpMapTransform;\\n\\tvarying vec2 vBumpMapUv;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tuniform mat3 normalMapTransform;\\n\\tvarying vec2 vNormalMapUv;\\n#endif\\n#ifdef USE_DISPLACEMENTMAP\\n\\tuniform mat3 displacementMapTransform;\\n\\tvarying vec2 vDisplacementMapUv;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\\tuniform mat3 emissiveMapTransform;\\n\\tvarying vec2 vEmissiveMapUv;\\n#endif\\n#ifdef USE_METALNESSMAP\\n\\tuniform mat3 metalnessMapTransform;\\n\\tvarying vec2 vMetalnessMapUv;\\n#endif\\n#ifdef USE_ROUGHNESSMAP\\n\\tuniform mat3 roughnessMapTransform;\\n\\tvarying vec2 vRoughnessMapUv;\\n#endif\\n#ifdef USE_ANISOTROPYMAP\\n\\tuniform mat3 anisotropyMapTransform;\\n\\tvarying vec2 vAnisotropyMapUv;\\n#endif\\n#ifdef USE_CLEARCOATMAP\\n\\tuniform mat3 clearcoatMapTransform;\\n\\tvarying vec2 vClearcoatMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tuniform mat3 clearcoatNormalMapTransform;\\n\\tvarying vec2 vClearcoatNormalMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tuniform mat3 clearcoatRoughnessMapTransform;\\n\\tvarying vec2 vClearcoatRoughnessMapUv;\\n#endif\\n#ifdef USE_SHEEN_COLORMAP\\n\\tuniform mat3 sheenColorMapTransform;\\n\\tvarying vec2 vSheenColorMapUv;\\n#endif\\n#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\tuniform mat3 sheenRoughnessMapTransform;\\n\\tvarying vec2 vSheenRoughnessMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCEMAP\\n\\tuniform mat3 iridescenceMapTransform;\\n\\tvarying vec2 vIridescenceMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\tuniform mat3 iridescenceThicknessMapTransform;\\n\\tvarying vec2 vIridescenceThicknessMapUv;\\n#endif\\n#ifdef USE_SPECULARMAP\\n\\tuniform mat3 specularMapTransform;\\n\\tvarying vec2 vSpecularMapUv;\\n#endif\\n#ifdef USE_SPECULAR_COLORMAP\\n\\tuniform mat3 specularColorMapTransform;\\n\\tvarying vec2 vSpecularColorMapUv;\\n#endif\\n#ifdef USE_SPECULAR_INTENSITYMAP\\n\\tuniform mat3 specularIntensityMapTransform;\\n\\tvarying vec2 vSpecularIntensityMapUv;\\n#endif\\n#ifdef USE_TRANSMISSIONMAP\\n\\tuniform mat3 transmissionMapTransform;\\n\\tvarying vec2 vTransmissionMapUv;\\n#endif\\n#ifdef USE_THICKNESSMAP\\n\\tuniform mat3 thicknessMapTransform;\\n\\tvarying vec2 vThicknessMapUv;\\n#endif\";\n\nvar uv_vertex = \"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\\n\\tvUv = vec3( uv, 1 ).xy;\\n#endif\\n#ifdef USE_MAP\\n\\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_LIGHTMAP\\n\\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_AOMAP\\n\\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_BUMPMAP\\n\\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_DISPLACEMENTMAP\\n\\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_METALNESSMAP\\n\\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_ROUGHNESSMAP\\n\\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_ANISOTROPYMAP\\n\\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_CLEARCOATMAP\\n\\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_IRIDESCENCEMAP\\n\\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SHEEN_COLORMAP\\n\\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SPECULARMAP\\n\\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SPECULAR_COLORMAP\\n\\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SPECULAR_INTENSITYMAP\\n\\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_TRANSMISSIONMAP\\n\\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_THICKNESSMAP\\n\\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\\n#endif\";\n\nvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\\n\\tvec4 worldPosition = vec4( transformed, 1.0 );\\n\\t#ifdef USE_BATCHING\\n\\t\\tworldPosition = batchingMatrix * worldPosition;\\n\\t#endif\\n\\t#ifdef USE_INSTANCING\\n\\t\\tworldPosition = instanceMatrix * worldPosition;\\n\\t#endif\\n\\tworldPosition = modelMatrix * worldPosition;\\n#endif\";\n\nconst vertex$h = \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\";\n\nconst fragment$h = \"uniform sampler2D t2D;\\nuniform float backgroundIntensity;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 texColor = texture2D( t2D, vUv );\\n\\t#ifdef DECODE_VIDEO_TEXTURE\\n\\t\\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\\n\\t#endif\\n\\ttexColor.rgb *= backgroundIntensity;\\n\\tgl_FragColor = texColor;\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n}\";\n\nconst vertex$g = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\";\n\nconst fragment$g = \"#ifdef ENVMAP_TYPE_CUBE\\n\\tuniform samplerCube envMap;\\n#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\tuniform sampler2D envMap;\\n#endif\\nuniform float flipEnvMap;\\nuniform float backgroundBlurriness;\\nuniform float backgroundIntensity;\\nuniform mat3 backgroundRotation;\\nvarying vec3 vWorldDirection;\\n#include <cube_uv_reflection_fragment>\\nvoid main() {\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\\n\\t#else\\n\\t\\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\t#endif\\n\\ttexColor.rgb *= backgroundIntensity;\\n\\tgl_FragColor = texColor;\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n}\";\n\nconst vertex$f = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\";\n\nconst fragment$f = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\nvoid main() {\\n\\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\\n\\tgl_FragColor = texColor;\\n\\tgl_FragColor.a *= opacity;\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n}\";\n\nconst vertex$e = \"#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvHighPrecisionZW = gl_Position.zw;\\n}\";\n\nconst fragment$e = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <clipping_planes_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( fragCoordZ );\\n\\t#elif DEPTH_PACKING == 3202\\n\\t\\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\\n\\t#elif DEPTH_PACKING == 3203\\n\\t\\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\\n\\t#endif\\n}\";\n\nconst vertex$d = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\";\n\nconst fragment$d = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <clipping_planes_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\";\n\nconst vertex$c = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\";\n\nconst fragment$c = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV = equirectUv( direction );\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n}\";\n\nconst vertex$b = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvLineDistance = scale * lineDistance;\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$b = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\n\nconst vertex$a = \"#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <batching_vertex>\\n\\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinbase_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$a = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\\n\\t\\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$9 = \"#define LAMBERT\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$9 = \"#define LAMBERT\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_lambert_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_lambert_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$8 = \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n}\";\n\nconst fragment$8 = \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <normal_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$7 = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\";\n\nconst fragment$7 = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <normal_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\\n\\t#ifdef OPAQUE\\n\\t\\tgl_FragColor.a = 1.0;\\n\\t#endif\\n}\";\n\nconst vertex$6 = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$6 = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$5 = \"#define STANDARD\\nvarying vec3 vViewPosition;\\n#ifdef USE_TRANSMISSION\\n\\tvarying vec3 vWorldPosition;\\n#endif\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n#ifdef USE_TRANSMISSION\\n\\tvWorldPosition = worldPosition.xyz;\\n#endif\\n}\";\n\nconst fragment$5 = \"#define STANDARD\\n#ifdef PHYSICAL\\n\\t#define IOR\\n\\t#define USE_SPECULAR\\n#endif\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifdef IOR\\n\\tuniform float ior;\\n#endif\\n#ifdef USE_SPECULAR\\n\\tuniform float specularIntensity;\\n\\tuniform vec3 specularColor;\\n\\t#ifdef USE_SPECULAR_COLORMAP\\n\\t\\tuniform sampler2D specularColorMap;\\n\\t#endif\\n\\t#ifdef USE_SPECULAR_INTENSITYMAP\\n\\t\\tuniform sampler2D specularIntensityMap;\\n\\t#endif\\n#endif\\n#ifdef USE_CLEARCOAT\\n\\tuniform float clearcoat;\\n\\tuniform float clearcoatRoughness;\\n#endif\\n#ifdef USE_DISPERSION\\n\\tuniform float dispersion;\\n#endif\\n#ifdef USE_IRIDESCENCE\\n\\tuniform float iridescence;\\n\\tuniform float iridescenceIOR;\\n\\tuniform float iridescenceThicknessMinimum;\\n\\tuniform float iridescenceThicknessMaximum;\\n#endif\\n#ifdef USE_SHEEN\\n\\tuniform vec3 sheenColor;\\n\\tuniform float sheenRoughness;\\n\\t#ifdef USE_SHEEN_COLORMAP\\n\\t\\tuniform sampler2D sheenColorMap;\\n\\t#endif\\n\\t#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\t\\tuniform sampler2D sheenRoughnessMap;\\n\\t#endif\\n#endif\\n#ifdef USE_ANISOTROPY\\n\\tuniform vec2 anisotropyVector;\\n\\t#ifdef USE_ANISOTROPYMAP\\n\\t\\tuniform sampler2D anisotropyMap;\\n\\t#endif\\n#endif\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <iridescence_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_physical_pars_fragment>\\n#include <transmission_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <clearcoat_pars_fragment>\\n#include <iridescence_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <clearcoat_normal_fragment_begin>\\n\\t#include <clearcoat_normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\\n\\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\\n\\t#include <transmission_fragment>\\n\\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\\n\\t#ifdef USE_SHEEN\\n\\t\\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\\n\\t\\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\\n\\t\\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\\n\\t\\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\\n\\t#endif\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$4 = \"#define TOON\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$4 = \"#define TOON\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_toon_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_toon_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$3 = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n#ifdef USE_POINTS_UV\\n\\tvarying vec2 vUv;\\n\\tuniform mat3 uvTransform;\\n#endif\\nvoid main() {\\n\\t#ifdef USE_POINTS_UV\\n\\t\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\t#endif\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$3 = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\n\nconst vertex$2 = \"#include <common>\\n#include <batching_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$2 = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <logdepthbuf_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\t#include <logdepthbuf_fragment>\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nconst vertex$1 = \"uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\tvec4 mvPosition = modelViewMatrix[ 3 ];\\n\\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$1 = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nconst ShaderChunk = {\n\talphahash_fragment: alphahash_fragment,\n\talphahash_pars_fragment: alphahash_pars_fragment,\n\talphamap_fragment: alphamap_fragment,\n\talphamap_pars_fragment: alphamap_pars_fragment,\n\talphatest_fragment: alphatest_fragment,\n\talphatest_pars_fragment: alphatest_pars_fragment,\n\taomap_fragment: aomap_fragment,\n\taomap_pars_fragment: aomap_pars_fragment,\n\tbatching_pars_vertex: batching_pars_vertex,\n\tbatching_vertex: batching_vertex,\n\tbegin_vertex: begin_vertex,\n\tbeginnormal_vertex: beginnormal_vertex,\n\tbsdfs: bsdfs,\n\tiridescence_fragment: iridescence_fragment,\n\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\tclipping_planes_fragment: clipping_planes_fragment,\n\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\tclipping_planes_vertex: clipping_planes_vertex,\n\tcolor_fragment: color_fragment,\n\tcolor_pars_fragment: color_pars_fragment,\n\tcolor_pars_vertex: color_pars_vertex,\n\tcolor_vertex: color_vertex,\n\tcommon: common,\n\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\tdefaultnormal_vertex: defaultnormal_vertex,\n\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\tdisplacementmap_vertex: displacementmap_vertex,\n\temissivemap_fragment: emissivemap_fragment,\n\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\tcolorspace_fragment: colorspace_fragment,\n\tcolorspace_pars_fragment: colorspace_pars_fragment,\n\tenvmap_fragment: envmap_fragment,\n\tenvmap_common_pars_fragment: envmap_common_pars_fragment,\n\tenvmap_pars_fragment: envmap_pars_fragment,\n\tenvmap_pars_vertex: envmap_pars_vertex,\n\tenvmap_physical_pars_fragment: envmap_physical_pars_fragment,\n\tenvmap_vertex: envmap_vertex,\n\tfog_vertex: fog_vertex,\n\tfog_pars_vertex: fog_pars_vertex,\n\tfog_fragment: fog_fragment,\n\tfog_pars_fragment: fog_pars_fragment,\n\tgradientmap_pars_fragment: gradientmap_pars_fragment,\n\tlightmap_pars_fragment: lightmap_pars_fragment,\n\tlights_lambert_fragment: lights_lambert_fragment,\n\tlights_lambert_pars_fragment: lights_lambert_pars_fragment,\n\tlights_pars_begin: lights_pars_begin,\n\tlights_toon_fragment: lights_toon_fragment,\n\tlights_toon_pars_fragment: lights_toon_pars_fragment,\n\tlights_phong_fragment: lights_phong_fragment,\n\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\tlights_physical_fragment: lights_physical_fragment,\n\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\tlights_fragment_begin: lights_fragment_begin,\n\tlights_fragment_maps: lights_fragment_maps,\n\tlights_fragment_end: lights_fragment_end,\n\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\tmap_fragment: map_fragment,\n\tmap_pars_fragment: map_pars_fragment,\n\tmap_particle_fragment: map_particle_fragment,\n\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\tmetalnessmap_fragment: metalnessmap_fragment,\n\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\tmorphinstance_vertex: morphinstance_vertex,\n\tmorphcolor_vertex: morphcolor_vertex,\n\tmorphnormal_vertex: morphnormal_vertex,\n\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\tmorphtarget_vertex: morphtarget_vertex,\n\tnormal_fragment_begin: normal_fragment_begin,\n\tnormal_fragment_maps: normal_fragment_maps,\n\tnormal_pars_fragment: normal_pars_fragment,\n\tnormal_pars_vertex: normal_pars_vertex,\n\tnormal_vertex: normal_vertex,\n\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\tclearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,\n\tclearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,\n\tclearcoat_pars_fragment: clearcoat_pars_fragment,\n\tiridescence_pars_fragment: iridescence_pars_fragment,\n\topaque_fragment: opaque_fragment,\n\tpacking: packing,\n\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\tproject_vertex: project_vertex,\n\tdithering_fragment: dithering_fragment,\n\tdithering_pars_fragment: dithering_pars_fragment,\n\troughnessmap_fragment: roughnessmap_fragment,\n\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\tshadowmap_vertex: shadowmap_vertex,\n\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\tskinbase_vertex: skinbase_vertex,\n\tskinning_pars_vertex: skinning_pars_vertex,\n\tskinning_vertex: skinning_vertex,\n\tskinnormal_vertex: skinnormal_vertex,\n\tspecularmap_fragment: specularmap_fragment,\n\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\ttonemapping_fragment: tonemapping_fragment,\n\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\ttransmission_fragment: transmission_fragment,\n\ttransmission_pars_fragment: transmission_pars_fragment,\n\tuv_pars_fragment: uv_pars_fragment,\n\tuv_pars_vertex: uv_pars_vertex,\n\tuv_vertex: uv_vertex,\n\tworldpos_vertex: worldpos_vertex,\n\n\tbackground_vert: vertex$h,\n\tbackground_frag: fragment$h,\n\tbackgroundCube_vert: vertex$g,\n\tbackgroundCube_frag: fragment$g,\n\tcube_vert: vertex$f,\n\tcube_frag: fragment$f,\n\tdepth_vert: vertex$e,\n\tdepth_frag: fragment$e,\n\tdistanceRGBA_vert: vertex$d,\n\tdistanceRGBA_frag: fragment$d,\n\tequirect_vert: vertex$c,\n\tequirect_frag: fragment$c,\n\tlinedashed_vert: vertex$b,\n\tlinedashed_frag: fragment$b,\n\tmeshbasic_vert: vertex$a,\n\tmeshbasic_frag: fragment$a,\n\tmeshlambert_vert: vertex$9,\n\tmeshlambert_frag: fragment$9,\n\tmeshmatcap_vert: vertex$8,\n\tmeshmatcap_frag: fragment$8,\n\tmeshnormal_vert: vertex$7,\n\tmeshnormal_frag: fragment$7,\n\tmeshphong_vert: vertex$6,\n\tmeshphong_frag: fragment$6,\n\tmeshphysical_vert: vertex$5,\n\tmeshphysical_frag: fragment$5,\n\tmeshtoon_vert: vertex$4,\n\tmeshtoon_frag: fragment$4,\n\tpoints_vert: vertex$3,\n\tpoints_frag: fragment$3,\n\tshadow_vert: vertex$2,\n\tshadow_frag: fragment$2,\n\tsprite_vert: vertex$1,\n\tsprite_frag: fragment$1\n};\n\n/**\n * Uniforms library for shared webgl shaders\n */\n\nconst UniformsLib = {\n\n\tcommon: {\n\n\t\tdiffuse: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color( 0xffffff ) },\n\t\topacity: { value: 1.0 },\n\n\t\tmap: { value: null },\n\t\tmapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\n\t\talphaMap: { value: null },\n\t\talphaMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\n\t\talphaTest: { value: 0 }\n\n\t},\n\n\tspecularmap: {\n\n\t\tspecularMap: { value: null },\n\t\tspecularMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() }\n\n\t},\n\n\tenvmap: {\n\n\t\tenvMap: { value: null },\n\t\tenvMapRotation: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\tflipEnvMap: { value: - 1 },\n\t\treflectivity: { value: 1.0 }, // basic, lambert, phong\n\t\tior: { value: 1.5 }, // physical\n\t\trefractionRatio: { value: 0.98 }, // basic, lambert, phong\n\n\t},\n\n\taomap: {\n\n\t\taoMap: { value: null },\n\t\taoMapIntensity: { value: 1 },\n\t\taoMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() }\n\n\t},\n\n\tlightmap: {\n\n\t\tlightMap: { value: null },\n\t\tlightMapIntensity: { value: 1 },\n\t\tlightMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() }\n\n\t},\n\n\tbumpmap: {\n\n\t\tbumpMap: { value: null },\n\t\tbumpMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\tbumpScale: { value: 1 }\n\n\t},\n\n\tnormalmap: {\n\n\t\tnormalMap: { value: null },\n\t\tnormalMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\tnormalScale: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector2( 1, 1 ) }\n\n\t},\n\n\tdisplacementmap: {\n\n\t\tdisplacementMap: { value: null },\n\t\tdisplacementMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\tdisplacementScale: { value: 1 },\n\t\tdisplacementBias: { value: 0 }\n\n\t},\n\n\temissivemap: {\n\n\t\temissiveMap: { value: null },\n\t\temissiveMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() }\n\n\t},\n\n\tmetalnessmap: {\n\n\t\tmetalnessMap: { value: null },\n\t\tmetalnessMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() }\n\n\t},\n\n\troughnessmap: {\n\n\t\troughnessMap: { value: null },\n\t\troughnessMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() }\n\n\t},\n\n\tgradientmap: {\n\n\t\tgradientMap: { value: null }\n\n\t},\n\n\tfog: {\n\n\t\tfogDensity: { value: 0.00025 },\n\t\tfogNear: { value: 1 },\n\t\tfogFar: { value: 2000 },\n\t\tfogColor: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color( 0xffffff ) }\n\n\t},\n\n\tlights: {\n\n\t\tambientLightColor: { value: [] },\n\n\t\tlightProbe: { value: [] },\n\n\t\tdirectionalLights: { value: [], properties: {\n\t\t\tdirection: {},\n\t\t\tcolor: {}\n\t\t} },\n\n\t\tdirectionalLightShadows: { value: [], properties: {\n\t\t\tshadowIntensity: 1,\n\t\t\tshadowBias: {},\n\t\t\tshadowNormalBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {}\n\t\t} },\n\n\t\tdirectionalShadowMap: { value: [] },\n\t\tdirectionalShadowMatrix: { value: [] },\n\n\t\tspotLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\tdirection: {},\n\t\t\tdistance: {},\n\t\t\tconeCos: {},\n\t\t\tpenumbraCos: {},\n\t\t\tdecay: {}\n\t\t} },\n\n\t\tspotLightShadows: { value: [], properties: {\n\t\t\tshadowIntensity: 1,\n\t\t\tshadowBias: {},\n\t\t\tshadowNormalBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {}\n\t\t} },\n\n\t\tspotLightMap: { value: [] },\n\t\tspotShadowMap: { value: [] },\n\t\tspotLightMatrix: { value: [] },\n\n\t\tpointLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\tdecay: {},\n\t\t\tdistance: {}\n\t\t} },\n\n\t\tpointLightShadows: { value: [], properties: {\n\t\t\tshadowIntensity: 1,\n\t\t\tshadowBias: {},\n\t\t\tshadowNormalBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {},\n\t\t\tshadowCameraNear: {},\n\t\t\tshadowCameraFar: {}\n\t\t} },\n\n\t\tpointShadowMap: { value: [] },\n\t\tpointShadowMatrix: { value: [] },\n\n\t\themisphereLights: { value: [], properties: {\n\t\t\tdirection: {},\n\t\t\tskyColor: {},\n\t\t\tgroundColor: {}\n\t\t} },\n\n\t\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\n\t\trectAreaLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\twidth: {},\n\t\t\theight: {}\n\t\t} },\n\n\t\tltc_1: { value: null },\n\t\tltc_2: { value: null }\n\n\t},\n\n\tpoints: {\n\n\t\tdiffuse: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color( 0xffffff ) },\n\t\topacity: { value: 1.0 },\n\t\tsize: { value: 1.0 },\n\t\tscale: { value: 1.0 },\n\t\tmap: { value: null },\n\t\talphaMap: { value: null },\n\t\talphaMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\talphaTest: { value: 0 },\n\t\tuvTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() }\n\n\t},\n\n\tsprite: {\n\n\t\tdiffuse: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color( 0xffffff ) },\n\t\topacity: { value: 1.0 },\n\t\tcenter: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector2( 0.5, 0.5 ) },\n\t\trotation: { value: 0.0 },\n\t\tmap: { value: null },\n\t\tmapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\talphaMap: { value: null },\n\t\talphaMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\talphaTest: { value: 0 }\n\n\t}\n\n};\n\nconst ShaderLib = {\n\n\tbasic: {\n\n\t\tuniforms: /*@__PURE__*/ (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeUniforms)( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\n\t},\n\n\tlambert: {\n\n\t\tuniforms: /*@__PURE__*/ (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeUniforms)( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color( 0x000000 ) }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\n\t},\n\n\tphong: {\n\n\t\tuniforms: /*@__PURE__*/ (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeUniforms)( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color( 0x000000 ) },\n\t\t\t\tspecular: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color( 0x111111 ) },\n\t\t\t\tshininess: { value: 30 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\tfragmentShader: ShaderChunk.meshphong_frag\n\n\t},\n\n\tstandard: {\n\n\t\tuniforms: /*@__PURE__*/ (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeUniforms)( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.roughnessmap,\n\t\t\tUniformsLib.metalnessmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color( 0x000000 ) },\n\t\t\t\troughness: { value: 1.0 },\n\t\t\t\tmetalness: { value: 0.0 },\n\t\t\t\tenvMapIntensity: { value: 1 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t},\n\n\ttoon: {\n\n\t\tuniforms: /*@__PURE__*/ (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeUniforms)( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.gradientmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color( 0x000000 ) }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshtoon_vert,\n\t\tfragmentShader: ShaderChunk.meshtoon_frag\n\n\t},\n\n\tmatcap: {\n\n\t\tuniforms: /*@__PURE__*/ (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeUniforms)( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tmatcap: { value: null }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshmatcap_vert,\n\t\tfragmentShader: ShaderChunk.meshmatcap_frag\n\n\t},\n\n\tpoints: {\n\n\t\tuniforms: /*@__PURE__*/ (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeUniforms)( [\n\t\t\tUniformsLib.points,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.points_vert,\n\t\tfragmentShader: ShaderChunk.points_frag\n\n\t},\n\n\tdashed: {\n\n\t\tuniforms: /*@__PURE__*/ (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeUniforms)( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tscale: { value: 1 },\n\t\t\t\tdashSize: { value: 1 },\n\t\t\t\ttotalSize: { value: 2 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\tfragmentShader: ShaderChunk.linedashed_frag\n\n\t},\n\n\tdepth: {\n\n\t\tuniforms: /*@__PURE__*/ (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeUniforms)( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.displacementmap\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.depth_vert,\n\t\tfragmentShader: ShaderChunk.depth_frag\n\n\t},\n\n\tnormal: {\n\n\t\tuniforms: /*@__PURE__*/ (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeUniforms)( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\t{\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshnormal_vert,\n\t\tfragmentShader: ShaderChunk.meshnormal_frag\n\n\t},\n\n\tsprite: {\n\n\t\tuniforms: /*@__PURE__*/ (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeUniforms)( [\n\t\t\tUniformsLib.sprite,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.sprite_vert,\n\t\tfragmentShader: ShaderChunk.sprite_frag\n\n\t},\n\n\tbackground: {\n\n\t\tuniforms: {\n\t\t\tuvTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\t\tt2D: { value: null },\n\t\t\tbackgroundIntensity: { value: 1 }\n\t\t},\n\n\t\tvertexShader: ShaderChunk.background_vert,\n\t\tfragmentShader: ShaderChunk.background_frag\n\n\t},\n\n\tbackgroundCube: {\n\n\t\tuniforms: {\n\t\t\tenvMap: { value: null },\n\t\t\tflipEnvMap: { value: - 1 },\n\t\t\tbackgroundBlurriness: { value: 0 },\n\t\t\tbackgroundIntensity: { value: 1 },\n\t\t\tbackgroundRotation: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() }\n\t\t},\n\n\t\tvertexShader: ShaderChunk.backgroundCube_vert,\n\t\tfragmentShader: ShaderChunk.backgroundCube_frag\n\n\t},\n\n\tcube: {\n\n\t\tuniforms: {\n\t\t\ttCube: { value: null },\n\t\t\ttFlip: { value: - 1 },\n\t\t\topacity: { value: 1.0 }\n\t\t},\n\n\t\tvertexShader: ShaderChunk.cube_vert,\n\t\tfragmentShader: ShaderChunk.cube_frag\n\n\t},\n\n\tequirect: {\n\n\t\tuniforms: {\n\t\t\ttEquirect: { value: null },\n\t\t},\n\n\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\tfragmentShader: ShaderChunk.equirect_frag\n\n\t},\n\n\tdistanceRGBA: {\n\n\t\tuniforms: /*@__PURE__*/ (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeUniforms)( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.displacementmap,\n\t\t\t{\n\t\t\t\treferencePosition: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3() },\n\t\t\t\tnearDistance: { value: 1 },\n\t\t\t\tfarDistance: { value: 1000 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\n\t},\n\n\tshadow: {\n\n\t\tuniforms: /*@__PURE__*/ (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeUniforms)( [\n\t\t\tUniformsLib.lights,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tcolor: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color( 0x00000 ) },\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t},\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.shadow_vert,\n\t\tfragmentShader: ShaderChunk.shadow_frag\n\n\t}\n\n};\n\nShaderLib.physical = {\n\n\tuniforms: /*@__PURE__*/ (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeUniforms)( [\n\t\tShaderLib.standard.uniforms,\n\t\t{\n\t\t\tclearcoat: { value: 0 },\n\t\t\tclearcoatMap: { value: null },\n\t\t\tclearcoatMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\t\tclearcoatNormalMap: { value: null },\n\t\t\tclearcoatNormalMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\t\tclearcoatNormalScale: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector2( 1, 1 ) },\n\t\t\tclearcoatRoughness: { value: 0 },\n\t\t\tclearcoatRoughnessMap: { value: null },\n\t\t\tclearcoatRoughnessMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\t\tdispersion: { value: 0 },\n\t\t\tiridescence: { value: 0 },\n\t\t\tiridescenceMap: { value: null },\n\t\t\tiridescenceMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\t\tiridescenceIOR: { value: 1.3 },\n\t\t\tiridescenceThicknessMinimum: { value: 100 },\n\t\t\tiridescenceThicknessMaximum: { value: 400 },\n\t\t\tiridescenceThicknessMap: { value: null },\n\t\t\tiridescenceThicknessMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\t\tsheen: { value: 0 },\n\t\t\tsheenColor: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color( 0x000000 ) },\n\t\t\tsheenColorMap: { value: null },\n\t\t\tsheenColorMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\t\tsheenRoughness: { value: 1 },\n\t\t\tsheenRoughnessMap: { value: null },\n\t\t\tsheenRoughnessMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\t\ttransmission: { value: 0 },\n\t\t\ttransmissionMap: { value: null },\n\t\t\ttransmissionMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\t\ttransmissionSamplerSize: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector2() },\n\t\t\ttransmissionSamplerMap: { value: null },\n\t\t\tthickness: { value: 0 },\n\t\t\tthicknessMap: { value: null },\n\t\t\tthicknessMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\t\tattenuationDistance: { value: 0 },\n\t\t\tattenuationColor: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color( 0x000000 ) },\n\t\t\tspecularColor: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color( 1, 1, 1 ) },\n\t\t\tspecularColorMap: { value: null },\n\t\t\tspecularColorMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\t\tspecularIntensity: { value: 1 },\n\t\t\tspecularIntensityMap: { value: null },\n\t\t\tspecularIntensityMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\t\tanisotropyVector: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector2() },\n\t\t\tanisotropyMap: { value: null },\n\t\t\tanisotropyMapTransform: { value: /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3() },\n\t\t}\n\t] ),\n\n\tvertexShader: ShaderChunk.meshphysical_vert,\n\tfragmentShader: ShaderChunk.meshphysical_frag\n\n};\n\nconst _rgb = { r: 0, b: 0, g: 0 };\nconst _e1$1 = /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Euler();\nconst _m1$1 = /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\nfunction WebGLBackground( renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha ) {\n\n\tconst clearColor = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color( 0x000000 );\n\tlet clearAlpha = alpha === true ? 0 : 1;\n\n\tlet planeMesh;\n\tlet boxMesh;\n\n\tlet currentBackground = null;\n\tlet currentBackgroundVersion = 0;\n\tlet currentTonemapping = null;\n\n\tfunction getBackground( scene ) {\n\n\t\tlet background = scene.isScene === true ? scene.background : null;\n\n\t\tif ( background && background.isTexture ) {\n\n\t\t\tconst usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background\n\t\t\tbackground = ( usePMREM ? cubeuvmaps : cubemaps ).get( background );\n\n\t\t}\n\n\t\treturn background;\n\n\t}\n\n\tfunction render( scene ) {\n\n\t\tlet forceClear = false;\n\t\tconst background = getBackground( scene );\n\n\t\tif ( background === null ) {\n\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t} else if ( background && background.isColor ) {\n\n\t\t\tsetClear( background, 1 );\n\t\t\tforceClear = true;\n\n\t\t}\n\n\t\tconst environmentBlendMode = renderer.xr.getEnvironmentBlendMode();\n\n\t\tif ( environmentBlendMode === 'additive' ) {\n\n\t\t\tstate.buffers.color.setClear( 0, 0, 0, 1, premultipliedAlpha );\n\n\t\t} else if ( environmentBlendMode === 'alpha-blend' ) {\n\n\t\t\tstate.buffers.color.setClear( 0, 0, 0, 0, premultipliedAlpha );\n\n\t\t}\n\n\t\tif ( renderer.autoClear || forceClear ) {\n\n\t\t\t// buffers might not be writable which is required to ensure a correct clear\n\n\t\t\tstate.buffers.depth.setTest( true );\n\t\t\tstate.buffers.depth.setMask( true );\n\t\t\tstate.buffers.color.setMask( true );\n\n\t\t\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\n\t\t}\n\n\t}\n\n\tfunction addToRenderList( renderList, scene ) {\n\n\t\tconst background = getBackground( scene );\n\n\t\tif ( background && ( background.isCubeTexture || background.mapping === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeUVReflectionMapping ) ) {\n\n\t\t\tif ( boxMesh === undefined ) {\n\n\t\t\t\tboxMesh = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Mesh(\n\t\t\t\t\tnew _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry( 1, 1, 1 ),\n\t\t\t\t\tnew _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial( {\n\t\t\t\t\t\tname: 'BackgroundCubeMaterial',\n\t\t\t\t\t\tuniforms: (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.cloneUniforms)( ShaderLib.backgroundCube.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.backgroundCube.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.backgroundCube.fragmentShader,\n\t\t\t\t\t\tside: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BackSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tboxMesh.geometry.deleteAttribute( 'normal' );\n\t\t\t\tboxMesh.geometry.deleteAttribute( 'uv' );\n\n\t\t\t\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\n\n\t\t\t\t};\n\n\t\t\t\t// add \"envMap\" material property so the renderer can evaluate it like for built-in materials\n\t\t\t\tObject.defineProperty( boxMesh.material, 'envMap', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.envMap.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( boxMesh );\n\n\t\t\t}\n\n\t\t\t_e1$1.copy( scene.backgroundRotation );\n\n\t\t\t// accommodate left-handed frame\n\t\t\t_e1$1.x *= - 1; _e1$1.y *= - 1; _e1$1.z *= - 1;\n\n\t\t\tif ( background.isCubeTexture && background.isRenderTargetTexture === false ) {\n\n\t\t\t\t// environment maps which are not cube render targets or PMREMs follow a different convention\n\t\t\t\t_e1$1.y *= - 1;\n\t\t\t\t_e1$1.z *= - 1;\n\n\t\t\t}\n\n\t\t\tboxMesh.material.uniforms.envMap.value = background;\n\t\t\tboxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;\n\t\t\tboxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;\n\t\t\tboxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;\n\t\t\tboxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4( _m1$1.makeRotationFromEuler( _e1$1 ) );\n\t\t\tboxMesh.material.toneMapped = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.getTransfer( background.colorSpace ) !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer;\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t\tcurrentBackgroundVersion !== background.version ||\n\t\t\t\tcurrentTonemapping !== renderer.toneMapping ) {\n\n\t\t\t\tboxMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\n\t\t\t}\n\n\t\t\tboxMesh.layers.enableAll();\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );\n\n\t\t} else if ( background && background.isTexture ) {\n\n\t\t\tif ( planeMesh === undefined ) {\n\n\t\t\t\tplaneMesh = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Mesh(\n\t\t\t\t\tnew _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry( 2, 2 ),\n\t\t\t\t\tnew _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial( {\n\t\t\t\t\t\tname: 'BackgroundMaterial',\n\t\t\t\t\t\tuniforms: (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.cloneUniforms)( ShaderLib.background.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.background.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.background.fragmentShader,\n\t\t\t\t\t\tside: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.FrontSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tplaneMesh.geometry.deleteAttribute( 'normal' );\n\n\t\t\t\t// add \"map\" material property so the renderer can evaluate it like for built-in materials\n\t\t\t\tObject.defineProperty( planeMesh.material, 'map', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.t2D.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( planeMesh );\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.t2D.value = background;\n\t\t\tplaneMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;\n\t\t\tplaneMesh.material.toneMapped = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.getTransfer( background.colorSpace ) !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer;\n\n\t\t\tif ( background.matrixAutoUpdate === true ) {\n\n\t\t\t\tbackground.updateMatrix();\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.uvTransform.value.copy( background.matrix );\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t\tcurrentBackgroundVersion !== background.version ||\n\t\t\t\tcurrentTonemapping !== renderer.toneMapping ) {\n\n\t\t\t\tplaneMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\n\t\t\t}\n\n\t\t\tplaneMesh.layers.enableAll();\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );\n\n\t\t}\n\n\t}\n\n\tfunction setClear( color, alpha ) {\n\n\t\tcolor.getRGB( _rgb, (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnlitUniformColorSpace)( renderer ) );\n\n\t\tstate.buffers.color.setClear( _rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha );\n\n\t}\n\n\tfunction dispose() {\n\n\t\tif ( boxMesh !== undefined ) {\n\n\t\t\tboxMesh.geometry.dispose();\n\t\t\tboxMesh.material.dispose();\n\n\t\t}\n\n\t\tif ( planeMesh !== undefined ) {\n\n\t\t\tplaneMesh.geometry.dispose();\n\t\t\tplaneMesh.material.dispose();\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\tgetClearColor: function () {\n\n\t\t\treturn clearColor;\n\n\t\t},\n\t\tsetClearColor: function ( color, alpha = 1 ) {\n\n\t\t\tclearColor.set( color );\n\t\t\tclearAlpha = alpha;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\tgetClearAlpha: function () {\n\n\t\t\treturn clearAlpha;\n\n\t\t},\n\t\tsetClearAlpha: function ( alpha ) {\n\n\t\t\tclearAlpha = alpha;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\trender: render,\n\t\taddToRenderList: addToRenderList,\n\t\tdispose: dispose\n\n\t};\n\n}\n\nfunction WebGLBindingStates( gl, attributes ) {\n\n\tconst maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\n\tconst bindingStates = {};\n\n\tconst defaultState = createBindingState( null );\n\tlet currentState = defaultState;\n\tlet forceUpdate = false;\n\n\tfunction setup( object, material, program, geometry, index ) {\n\n\t\tlet updateBuffers = false;\n\n\t\tconst state = getBindingState( geometry, program, material );\n\n\t\tif ( currentState !== state ) {\n\n\t\t\tcurrentState = state;\n\t\t\tbindVertexArrayObject( currentState.object );\n\n\t\t}\n\n\t\tupdateBuffers = needsUpdate( object, geometry, program, index );\n\n\t\tif ( updateBuffers ) saveCache( object, geometry, program, index );\n\n\t\tif ( index !== null ) {\n\n\t\t\tattributes.update( index, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t}\n\n\t\tif ( updateBuffers || forceUpdate ) {\n\n\t\t\tforceUpdate = false;\n\n\t\t\tsetupVertexAttributes( object, material, program, geometry );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction createVertexArrayObject() {\n\n\t\treturn gl.createVertexArray();\n\n\t}\n\n\tfunction bindVertexArrayObject( vao ) {\n\n\t\treturn gl.bindVertexArray( vao );\n\n\t}\n\n\tfunction deleteVertexArrayObject( vao ) {\n\n\t\treturn gl.deleteVertexArray( vao );\n\n\t}\n\n\tfunction getBindingState( geometry, program, material ) {\n\n\t\tconst wireframe = ( material.wireframe === true );\n\n\t\tlet programMap = bindingStates[ geometry.id ];\n\n\t\tif ( programMap === undefined ) {\n\n\t\t\tprogramMap = {};\n\t\t\tbindingStates[ geometry.id ] = programMap;\n\n\t\t}\n\n\t\tlet stateMap = programMap[ program.id ];\n\n\t\tif ( stateMap === undefined ) {\n\n\t\t\tstateMap = {};\n\t\t\tprogramMap[ program.id ] = stateMap;\n\n\t\t}\n\n\t\tlet state = stateMap[ wireframe ];\n\n\t\tif ( state === undefined ) {\n\n\t\t\tstate = createBindingState( createVertexArrayObject() );\n\t\t\tstateMap[ wireframe ] = state;\n\n\t\t}\n\n\t\treturn state;\n\n\t}\n\n\tfunction createBindingState( vao ) {\n\n\t\tconst newAttributes = [];\n\t\tconst enabledAttributes = [];\n\t\tconst attributeDivisors = [];\n\n\t\tfor ( let i = 0; i < maxVertexAttributes; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\t\t\tenabledAttributes[ i ] = 0;\n\t\t\tattributeDivisors[ i ] = 0;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\t// for backward compatibility on non-VAO support browser\n\t\t\tgeometry: null,\n\t\t\tprogram: null,\n\t\t\twireframe: false,\n\n\t\t\tnewAttributes: newAttributes,\n\t\t\tenabledAttributes: enabledAttributes,\n\t\t\tattributeDivisors: attributeDivisors,\n\t\t\tobject: vao,\n\t\t\tattributes: {},\n\t\t\tindex: null\n\n\t\t};\n\n\t}\n\n\tfunction needsUpdate( object, geometry, program, index ) {\n\n\t\tconst cachedAttributes = currentState.attributes;\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\tlet attributesNum = 0;\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tfor ( const name in programAttributes ) {\n\n\t\t\tconst programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute.location >= 0 ) {\n\n\t\t\t\tconst cachedAttribute = cachedAttributes[ name ];\n\t\t\t\tlet geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute === undefined ) {\n\n\t\t\t\t\tif ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;\n\t\t\t\t\tif ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;\n\n\t\t\t\t}\n\n\t\t\t\tif ( cachedAttribute === undefined ) return true;\n\n\t\t\t\tif ( cachedAttribute.attribute !== geometryAttribute ) return true;\n\n\t\t\t\tif ( geometryAttribute && cachedAttribute.data !== geometryAttribute.data ) return true;\n\n\t\t\t\tattributesNum ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( currentState.attributesNum !== attributesNum ) return true;\n\n\t\tif ( currentState.index !== index ) return true;\n\n\t\treturn false;\n\n\t}\n\n\tfunction saveCache( object, geometry, program, index ) {\n\n\t\tconst cache = {};\n\t\tconst attributes = geometry.attributes;\n\t\tlet attributesNum = 0;\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tfor ( const name in programAttributes ) {\n\n\t\t\tconst programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute.location >= 0 ) {\n\n\t\t\t\tlet attribute = attributes[ name ];\n\n\t\t\t\tif ( attribute === undefined ) {\n\n\t\t\t\t\tif ( name === 'instanceMatrix' && object.instanceMatrix ) attribute = object.instanceMatrix;\n\t\t\t\t\tif ( name === 'instanceColor' && object.instanceColor ) attribute = object.instanceColor;\n\n\t\t\t\t}\n\n\t\t\t\tconst data = {};\n\t\t\t\tdata.attribute = attribute;\n\n\t\t\t\tif ( attribute && attribute.data ) {\n\n\t\t\t\t\tdata.data = attribute.data;\n\n\t\t\t\t}\n\n\t\t\t\tcache[ name ] = data;\n\n\t\t\t\tattributesNum ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcurrentState.attributes = cache;\n\t\tcurrentState.attributesNum = attributesNum;\n\n\t\tcurrentState.index = index;\n\n\t}\n\n\tfunction initAttributes() {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\n\t\tfor ( let i = 0, il = newAttributes.length; i < il; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\tfunction enableAttribute( attribute ) {\n\n\t\tenableAttributeAndDivisor( attribute, 0 );\n\n\t}\n\n\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\t\tconst enabledAttributes = currentState.enabledAttributes;\n\t\tconst attributeDivisors = currentState.attributeDivisors;\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\tgl.vertexAttribDivisor( attribute, meshPerAttribute );\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t}\n\n\t}\n\n\tfunction disableUnusedAttributes() {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\t\tconst enabledAttributes = currentState.enabledAttributes;\n\n\t\tfor ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {\n\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction vertexAttribPointer( index, size, type, normalized, stride, offset, integer ) {\n\n\t\tif ( integer === true ) {\n\n\t\t\tgl.vertexAttribIPointer( index, size, type, stride, offset );\n\n\t\t} else {\n\n\t\t\tgl.vertexAttribPointer( index, size, type, normalized, stride, offset );\n\n\t\t}\n\n\t}\n\n\tfunction setupVertexAttributes( object, material, program, geometry ) {\n\n\t\tinitAttributes();\n\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tconst materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\tfor ( const name in programAttributes ) {\n\n\t\t\tconst programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute.location >= 0 ) {\n\n\t\t\t\tlet geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute === undefined ) {\n\n\t\t\t\t\tif ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;\n\t\t\t\t\tif ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\tconst normalized = geometryAttribute.normalized;\n\t\t\t\t\tconst size = geometryAttribute.itemSize;\n\n\t\t\t\t\tconst attribute = attributes.get( geometryAttribute );\n\n\t\t\t\t\t// TODO Attribute may not be available on context restore\n\n\t\t\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\tconst type = attribute.type;\n\t\t\t\t\tconst bytesPerElement = attribute.bytesPerElement;\n\n\t\t\t\t\t// check for integer attributes\n\n\t\t\t\t\tconst integer = ( type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.IntType );\n\n\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tconst data = geometryAttribute.data;\n\t\t\t\t\t\tconst stride = data.stride;\n\t\t\t\t\t\tconst offset = geometryAttribute.offset;\n\n\t\t\t\t\t\tif ( data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttribute( programAttribute.location + i );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n\n\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\tvertexAttribPointer(\n\t\t\t\t\t\t\t\tprogramAttribute.location + i,\n\t\t\t\t\t\t\t\tsize / programAttribute.locationSize,\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\tnormalized,\n\t\t\t\t\t\t\t\tstride * bytesPerElement,\n\t\t\t\t\t\t\t\t( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement,\n\t\t\t\t\t\t\t\tinteger\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttribute( programAttribute.location + i );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n\n\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\tvertexAttribPointer(\n\t\t\t\t\t\t\t\tprogramAttribute.location + i,\n\t\t\t\t\t\t\t\tsize / programAttribute.locationSize,\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\tnormalized,\n\t\t\t\t\t\t\t\tsize * bytesPerElement,\n\t\t\t\t\t\t\t\t( size / programAttribute.locationSize ) * i * bytesPerElement,\n\t\t\t\t\t\t\t\tinteger\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\tconst value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tgl.vertexAttrib2fv( programAttribute.location, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tgl.vertexAttrib3fv( programAttribute.location, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\tgl.vertexAttrib4fv( programAttribute.location, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tgl.vertexAttrib1fv( programAttribute.location, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tdisableUnusedAttributes();\n\n\t}\n\n\tfunction dispose() {\n\n\t\treset();\n\n\t\tfor ( const geometryId in bindingStates ) {\n\n\t\t\tconst programMap = bindingStates[ geometryId ];\n\n\t\t\tfor ( const programId in programMap ) {\n\n\t\t\t\tconst stateMap = programMap[ programId ];\n\n\t\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t\t}\n\n\t\t\t\tdelete programMap[ programId ];\n\n\t\t\t}\n\n\t\t\tdelete bindingStates[ geometryId ];\n\n\t\t}\n\n\t}\n\n\tfunction releaseStatesOfGeometry( geometry ) {\n\n\t\tif ( bindingStates[ geometry.id ] === undefined ) return;\n\n\t\tconst programMap = bindingStates[ geometry.id ];\n\n\t\tfor ( const programId in programMap ) {\n\n\t\t\tconst stateMap = programMap[ programId ];\n\n\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t}\n\n\t\t\tdelete programMap[ programId ];\n\n\t\t}\n\n\t\tdelete bindingStates[ geometry.id ];\n\n\t}\n\n\tfunction releaseStatesOfProgram( program ) {\n\n\t\tfor ( const geometryId in bindingStates ) {\n\n\t\t\tconst programMap = bindingStates[ geometryId ];\n\n\t\t\tif ( programMap[ program.id ] === undefined ) continue;\n\n\t\t\tconst stateMap = programMap[ program.id ];\n\n\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t}\n\n\t\t\tdelete programMap[ program.id ];\n\n\t\t}\n\n\t}\n\n\tfunction reset() {\n\n\t\tresetDefaultState();\n\t\tforceUpdate = true;\n\n\t\tif ( currentState === defaultState ) return;\n\n\t\tcurrentState = defaultState;\n\t\tbindVertexArrayObject( currentState.object );\n\n\t}\n\n\t// for backward-compatibility\n\n\tfunction resetDefaultState() {\n\n\t\tdefaultState.geometry = null;\n\t\tdefaultState.program = null;\n\t\tdefaultState.wireframe = false;\n\n\t}\n\n\treturn {\n\n\t\tsetup: setup,\n\t\treset: reset,\n\t\tresetDefaultState: resetDefaultState,\n\t\tdispose: dispose,\n\t\treleaseStatesOfGeometry: releaseStatesOfGeometry,\n\t\treleaseStatesOfProgram: releaseStatesOfProgram,\n\n\t\tinitAttributes: initAttributes,\n\t\tenableAttribute: enableAttribute,\n\t\tdisableUnusedAttributes: disableUnusedAttributes\n\n\t};\n\n}\n\nfunction WebGLBufferRenderer( gl, extensions, info ) {\n\n\tlet mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\tgl.drawArrays( mode, start, count );\n\n\t\tinfo.update( count, mode, 1 );\n\n\t}\n\n\tfunction renderInstances( start, count, primcount ) {\n\n\t\tif ( primcount === 0 ) return;\n\n\t\tgl.drawArraysInstanced( mode, start, count, primcount );\n\n\t\tinfo.update( count, mode, primcount );\n\n\t}\n\n\tfunction renderMultiDraw( starts, counts, drawCount ) {\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\t\textension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );\n\n\t\tlet elementCount = 0;\n\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\telementCount += counts[ i ];\n\n\t\t}\n\n\t\tinfo.update( elementCount, mode, 1 );\n\n\t}\n\n\tfunction renderMultiDrawInstances( starts, counts, drawCount, primcount ) {\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < starts.length; i ++ ) {\n\n\t\t\t\trenderInstances( starts[ i ], counts[ i ], primcount[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\textension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ] * primcount[ i ];\n\n\t\t\t}\n\n\t\t\tinfo.update( elementCount, mode, 1 );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tthis.setMode = setMode;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\tthis.renderMultiDraw = renderMultiDraw;\n\tthis.renderMultiDrawInstances = renderMultiDrawInstances;\n\n}\n\nfunction WebGLCapabilities( gl, extensions, parameters, utils ) {\n\n\tlet maxAnisotropy;\n\n\tfunction getMaxAnisotropy() {\n\n\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tmaxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn maxAnisotropy;\n\n\t}\n\n\tfunction textureFormatReadable( textureFormat ) {\n\n\t\tif ( textureFormat !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat && utils.convert( textureFormat ) !== gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction textureTypeReadable( textureType ) {\n\n\t\tconst halfFloatSupportedByExt = ( textureType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) );\n\n\t\tif ( textureType !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType && utils.convert( textureType ) !== gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // Edge and Chrome Mac < 52 (#9513)\n\t\t\ttextureType !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.FloatType && ! halfFloatSupportedByExt ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction getMaxPrecision( precision ) {\n\n\t\tif ( precision === 'highp' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t\tgl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'highp';\n\n\t\t\t}\n\n\t\t\tprecision = 'mediump';\n\n\t\t}\n\n\t\tif ( precision === 'mediump' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t\tgl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'mediump';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn 'lowp';\n\n\t}\n\n\tlet precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\tconst maxPrecision = getMaxPrecision( precision );\n\n\tif ( maxPrecision !== precision ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n\t\tprecision = maxPrecision;\n\n\t}\n\n\tconst logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n\tconst reverseDepthBuffer = parameters.reverseDepthBuffer === true && extensions.has( 'EXT_clip_control' );\n\n\tconst maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\tconst maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\tconst maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\tconst maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\tconst maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\tconst maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\tconst maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\tconst maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\n\tconst vertexTextures = maxVertexTextures > 0;\n\n\tconst maxSamples = gl.getParameter( gl.MAX_SAMPLES );\n\n\treturn {\n\n\t\tisWebGL2: true, // keeping this for backwards compatibility\n\n\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\tgetMaxPrecision: getMaxPrecision,\n\n\t\ttextureFormatReadable: textureFormatReadable,\n\t\ttextureTypeReadable: textureTypeReadable,\n\n\t\tprecision: precision,\n\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\t\treverseDepthBuffer: reverseDepthBuffer,\n\n\t\tmaxTextures: maxTextures,\n\t\tmaxVertexTextures: maxVertexTextures,\n\t\tmaxTextureSize: maxTextureSize,\n\t\tmaxCubemapSize: maxCubemapSize,\n\n\t\tmaxAttributes: maxAttributes,\n\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\tmaxVaryings: maxVaryings,\n\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\n\t\tvertexTextures: vertexTextures,\n\n\t\tmaxSamples: maxSamples\n\n\t};\n\n}\n\nfunction WebGLClipping( properties ) {\n\n\tconst scope = this;\n\n\tlet globalState = null,\n\t\tnumGlobalPlanes = 0,\n\t\tlocalClippingEnabled = false,\n\t\trenderingShadows = false;\n\n\tconst plane = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Plane(),\n\t\tviewNormalMatrix = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3(),\n\n\t\tuniform = { value: null, needsUpdate: false };\n\n\tthis.uniform = uniform;\n\tthis.numPlanes = 0;\n\tthis.numIntersection = 0;\n\n\tthis.init = function ( planes, enableLocalClipping ) {\n\n\t\tconst enabled =\n\t\t\tplanes.length !== 0 ||\n\t\t\tenableLocalClipping ||\n\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\tlocalClippingEnabled;\n\n\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\tnumGlobalPlanes = planes.length;\n\n\t\treturn enabled;\n\n\t};\n\n\tthis.beginShadows = function () {\n\n\t\trenderingShadows = true;\n\t\tprojectPlanes( null );\n\n\t};\n\n\tthis.endShadows = function () {\n\n\t\trenderingShadows = false;\n\n\t};\n\n\tthis.setGlobalState = function ( planes, camera ) {\n\n\t\tglobalState = projectPlanes( planes, camera, 0 );\n\n\t};\n\n\tthis.setState = function ( material, camera, useCache ) {\n\n\t\tconst planes = material.clippingPlanes,\n\t\t\tclipIntersection = material.clipIntersection,\n\t\t\tclipShadows = material.clipShadows;\n\n\t\tconst materialProperties = properties.get( material );\n\n\t\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\n\n\t\t\t// there's no local clipping\n\n\t\t\tif ( renderingShadows ) {\n\n\t\t\t\t// there's no global clipping\n\n\t\t\t\tprojectPlanes( null );\n\n\t\t\t} else {\n\n\t\t\t\tresetGlobalState();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\tlGlobal = nGlobal * 4;\n\n\t\t\tlet dstArray = materialProperties.clippingState || null;\n\n\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, useCache );\n\n\t\t\tfor ( let i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t}\n\n\t\t\tmaterialProperties.clippingState = dstArray;\n\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\tthis.numPlanes += nGlobal;\n\n\t\t}\n\n\n\t};\n\n\tfunction resetGlobalState() {\n\n\t\tif ( uniform.value !== globalState ) {\n\n\t\t\tuniform.value = globalState;\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t}\n\n\t\tscope.numPlanes = numGlobalPlanes;\n\t\tscope.numIntersection = 0;\n\n\t}\n\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\tconst nPlanes = planes !== null ? planes.length : 0;\n\t\tlet dstArray = null;\n\n\t\tif ( nPlanes !== 0 ) {\n\n\t\t\tdstArray = uniform.value;\n\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\tconst flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tuniform.value = dstArray;\n\t\t\tuniform.needsUpdate = true;\n\n\t\t}\n\n\t\tscope.numPlanes = nPlanes;\n\t\tscope.numIntersection = 0;\n\n\t\treturn dstArray;\n\n\t}\n\n}\n\nfunction WebGLCubeMaps( renderer ) {\n\n\tlet cubemaps = new WeakMap();\n\n\tfunction mapTextureMapping( texture, mapping ) {\n\n\t\tif ( mapping === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EquirectangularReflectionMapping ) {\n\n\t\t\ttexture.mapping = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeReflectionMapping;\n\n\t\t} else if ( mapping === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EquirectangularRefractionMapping ) {\n\n\t\t\ttexture.mapping = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeRefractionMapping;\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tfunction get( texture ) {\n\n\t\tif ( texture && texture.isTexture ) {\n\n\t\t\tconst mapping = texture.mapping;\n\n\t\t\tif ( mapping === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EquirectangularReflectionMapping || mapping === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EquirectangularRefractionMapping ) {\n\n\t\t\t\tif ( cubemaps.has( texture ) ) {\n\n\t\t\t\t\tconst cubemap = cubemaps.get( texture ).texture;\n\t\t\t\t\treturn mapTextureMapping( cubemap, texture.mapping );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\tif ( image && image.height > 0 ) {\n\n\t\t\t\t\t\tconst renderTarget = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.WebGLCubeRenderTarget( image.height );\n\t\t\t\t\t\trenderTarget.fromEquirectangularTexture( renderer, texture );\n\t\t\t\t\t\tcubemaps.set( texture, renderTarget );\n\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\treturn mapTextureMapping( renderTarget.texture, texture.mapping );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// image not yet ready. try the conversion next frame\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tfunction onTextureDispose( event ) {\n\n\t\tconst texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tconst cubemap = cubemaps.get( texture );\n\n\t\tif ( cubemap !== undefined ) {\n\n\t\t\tcubemaps.delete( texture );\n\t\t\tcubemap.dispose();\n\n\t\t}\n\n\t}\n\n\tfunction dispose() {\n\n\t\tcubemaps = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nconst LOD_MIN = 4;\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst _flatCamera = /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera();\nconst _clearColor = /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color();\nlet _oldTarget = null;\nlet _oldActiveCubeFace = 0;\nlet _oldActiveMipmapLevel = 0;\nlet _oldXrEnabled = false;\n\n// Golden Ratio\nconst PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [\n\t/*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3( - PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3( PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3( - INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3( INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3( 0, PHI, - INV_PHI ),\n\t/*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3( 0, PHI, INV_PHI ),\n\t/*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3( - 1, 1, - 1 ),\n\t/*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3( 1, 1, - 1 ),\n\t/*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3( - 1, 1, 1 ),\n\t/*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3( 1, 1, 1 ) ];\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nclass PMREMGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._pingPongRenderTarget = null;\n\n\t\tthis._lodMax = 0;\n\t\tthis._cubeSize = 0;\n\t\tthis._lodPlanes = [];\n\t\tthis._sizeLods = [];\n\t\tthis._sigmas = [];\n\n\t\tthis._blurMaterial = null;\n\t\tthis._cubemapMaterial = null;\n\t\tthis._equirectMaterial = null;\n\n\t\tthis._compileMaterial( this._blurMaterial );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t *\n\t * @param {Scene} scene\n\t * @param {number} sigma\n\t * @param {number} near\n\t * @param {number} far\n\t * @return {WebGLRenderTarget}\n\t */\n\tfromScene( scene, sigma = 0, near = 0.1, far = 100 ) {\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\t\t_oldXrEnabled = this._renderer.xr.enabled;\n\n\t\tthis._renderer.xr.enabled = false;\n\n\t\tthis._setSize( 256 );\n\n\t\tconst cubeUVRenderTarget = this._allocateTargets();\n\t\tcubeUVRenderTarget.depthBuffer = true;\n\n\t\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );\n\n\t\tif ( sigma > 0 ) {\n\n\t\t\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * or HDR. The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t * The smallest supported equirectangular image size is 64 x 32.\n\t *\n\t * @param {Texture} equirectangular\n\t * @param {WebGLRenderTarget} [renderTarget=null] - Optional render target.\n\t * @return {WebGLRenderTarget}\n\t */\n\tfromEquirectangular( equirectangular, renderTarget = null ) {\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * or HDR. The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t * The smallest supported cube size is 16 x 16.\n\t *\n\t * @param {Texture} cubemap\n\t * @param {null} [renderTarget=null] - Optional render target.\n\t * @return {WebGLRenderTarget}\n\t */\n\tfromCubemap( cubemap, renderTarget = null ) {\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileCubemapShader() {\n\n\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\t\t\tthis._compileMaterial( this._cubemapMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileEquirectangularShader() {\n\n\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\t\t\tthis._compileMaterial( this._equirectMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose() {\n\n\t\tthis._dispose();\n\n\t\tif ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();\n\t\tif ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();\n\n\t}\n\n\t// private interface\n\n\t_setSize( cubeSize ) {\n\n\t\tthis._lodMax = Math.floor( Math.log2( cubeSize ) );\n\t\tthis._cubeSize = Math.pow( 2, this._lodMax );\n\n\t}\n\n\t_dispose() {\n\n\t\tif ( this._blurMaterial !== null ) this._blurMaterial.dispose();\n\n\t\tif ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();\n\n\t\tfor ( let i = 0; i < this._lodPlanes.length; i ++ ) {\n\n\t\t\tthis._lodPlanes[ i ].dispose();\n\n\t\t}\n\n\t}\n\n\t_cleanup( outputTarget ) {\n\n\t\tthis._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );\n\t\tthis._renderer.xr.enabled = _oldXrEnabled;\n\n\t\toutputTarget.scissorTest = false;\n\t\t_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );\n\n\t}\n\n\t_fromTexture( texture, renderTarget ) {\n\n\t\tif ( texture.mapping === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeReflectionMapping || texture.mapping === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeRefractionMapping ) {\n\n\t\t\tthis._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );\n\n\t\t} else { // Equirectangular\n\n\t\t\tthis._setSize( texture.image.width / 4 );\n\n\t\t}\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\t\t_oldXrEnabled = this._renderer.xr.enabled;\n\n\t\tthis._renderer.xr.enabled = false;\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\t\tthis._textureToCubeUV( texture, cubeUVRenderTarget );\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_allocateTargets() {\n\n\t\tconst width = 3 * Math.max( this._cubeSize, 16 * 7 );\n\t\tconst height = 4 * this._cubeSize;\n\n\t\tconst params = {\n\t\t\tmagFilter: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n\t\t\tminFilter: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n\t\t\tgenerateMipmaps: false,\n\t\t\ttype: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n\t\t\tformat: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,\n\t\t\tcolorSpace: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace,\n\t\t\tdepthBuffer: false\n\t\t};\n\n\t\tconst cubeUVRenderTarget = _createRenderTarget( width, height, params );\n\n\t\tif ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {\n\n\t\t\tif ( this._pingPongRenderTarget !== null ) {\n\n\t\t\t\tthis._dispose();\n\n\t\t\t}\n\n\t\t\tthis._pingPongRenderTarget = _createRenderTarget( width, height, params );\n\n\t\t\tconst { _lodMax } = this;\n\t\t\t( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );\n\n\t\t\tthis._blurMaterial = _getBlurShader( _lodMax, width, height );\n\n\t\t}\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_compileMaterial( material ) {\n\n\t\tconst tmpMesh = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Mesh( this._lodPlanes[ 0 ], material );\n\t\tthis._renderer.compile( tmpMesh, _flatCamera );\n\n\t}\n\n\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {\n\n\t\tconst fov = 90;\n\t\tconst aspect = 1;\n\t\tconst cubeCamera = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera( fov, aspect, near, far );\n\t\tconst upSign = [ 1, - 1, 1, 1, 1, 1 ];\n\t\tconst forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];\n\t\tconst renderer = this._renderer;\n\n\t\tconst originalAutoClear = renderer.autoClear;\n\t\tconst toneMapping = renderer.toneMapping;\n\t\trenderer.getClearColor( _clearColor );\n\n\t\trenderer.toneMapping = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoToneMapping;\n\t\trenderer.autoClear = false;\n\n\t\tconst backgroundMaterial = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial( {\n\t\t\tname: 'PMREM.Background',\n\t\t\tside: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BackSide,\n\t\t\tdepthWrite: false,\n\t\t\tdepthTest: false,\n\t\t} );\n\n\t\tconst backgroundBox = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Mesh( new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(), backgroundMaterial );\n\n\t\tlet useSolidColor = false;\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tif ( background.isColor ) {\n\n\t\t\t\tbackgroundMaterial.color.copy( background );\n\t\t\t\tscene.background = null;\n\t\t\t\tuseSolidColor = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbackgroundMaterial.color.copy( _clearColor );\n\t\t\tuseSolidColor = true;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst col = i % 3;\n\n\t\t\tif ( col === 0 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( forwardSign[ i ], 0, 0 );\n\n\t\t\t} else if ( col === 1 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\t\tcubeCamera.lookAt( 0, forwardSign[ i ], 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( 0, 0, forwardSign[ i ] );\n\n\t\t\t}\n\n\t\t\tconst size = this._cubeSize;\n\n\t\t\t_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );\n\n\t\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\n\t\t\tif ( useSolidColor ) {\n\n\t\t\t\trenderer.render( backgroundBox, cubeCamera );\n\n\t\t\t}\n\n\t\t\trenderer.render( scene, cubeCamera );\n\n\t\t}\n\n\t\tbackgroundBox.geometry.dispose();\n\t\tbackgroundBox.material.dispose();\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.autoClear = originalAutoClear;\n\t\tscene.background = background;\n\n\t}\n\n\t_textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst isCubeTexture = ( texture.mapping === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeReflectionMapping || texture.mapping === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeRefractionMapping );\n\n\t\tif ( isCubeTexture ) {\n\n\t\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\n\t\t\t}\n\n\t\t\tthis._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? - 1 : 1;\n\n\t\t} else {\n\n\t\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n\t\tconst mesh = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Mesh( this._lodPlanes[ 0 ], material );\n\n\t\tconst uniforms = material.uniforms;\n\n\t\tuniforms[ 'envMap' ].value = texture;\n\n\t\tconst size = this._cubeSize;\n\n\t\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\trenderer.render( mesh, _flatCamera );\n\n\t}\n\n\t_applyPMREM( cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\t\tconst n = this._lodPlanes.length;\n\n\t\tfor ( let i = 1; i < n; i ++ ) {\n\n\t\t\tconst sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );\n\n\t\t\tconst poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];\n\n\t\t\tthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n\t/**\n\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t * accurate at the poles, but still does a decent job.\n\t *\n\t * @param {WebGLRenderTarget} cubeUVRenderTarget\n\t * @param {number} lodIn\n\t * @param {number} lodOut\n\t * @param {number} sigma\n\t * @param {Vector3} [poleAxis]\n\t */\n\t_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\tthis._halfBlur(\n\t\t\tcubeUVRenderTarget,\n\t\t\tpingPongRenderTarget,\n\t\t\tlodIn,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'latitudinal',\n\t\t\tpoleAxis );\n\n\t\tthis._halfBlur(\n\t\t\tpingPongRenderTarget,\n\t\t\tcubeUVRenderTarget,\n\t\t\tlodOut,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'longitudinal',\n\t\t\tpoleAxis );\n\n\t}\n\n\t_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst blurMaterial = this._blurMaterial;\n\n\t\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\t\tconsole.error(\n\t\t\t\t'blur direction must be either latitudinal or longitudinal!' );\n\n\t\t}\n\n\t\t// Number of standard deviations at which to cut off the discrete approximation.\n\t\tconst STANDARD_DEVIATIONS = 3;\n\n\t\tconst blurMesh = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Mesh( this._lodPlanes[ lodOut ], blurMaterial );\n\t\tconst blurUniforms = blurMaterial.uniforms;\n\n\t\tconst pixels = this._sizeLods[ lodIn ] - 1;\n\t\tconst radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\tconst samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\t\tif ( samples > MAX_SAMPLES ) {\n\n\t\t\tconsole.warn( `sigmaRadians, ${\n\t\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t\t}\n\n\t\tconst weights = [];\n\t\tlet sum = 0;\n\n\t\tfor ( let i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\t\tconst x = i / sigmaPixels;\n\t\t\tconst weight = Math.exp( - x * x / 2 );\n\t\t\tweights.push( weight );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tsum += weight;\n\n\t\t\t} else if ( i < samples ) {\n\n\t\t\t\tsum += 2 * weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < weights.length; i ++ ) {\n\n\t\t\tweights[ i ] = weights[ i ] / sum;\n\n\t\t}\n\n\t\tblurUniforms[ 'envMap' ].value = targetIn.texture;\n\t\tblurUniforms[ 'samples' ].value = samples;\n\t\tblurUniforms[ 'weights' ].value = weights;\n\t\tblurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';\n\n\t\tif ( poleAxis ) {\n\n\t\t\tblurUniforms[ 'poleAxis' ].value = poleAxis;\n\n\t\t}\n\n\t\tconst { _lodMax } = this;\n\t\tblurUniforms[ 'dTheta' ].value = radiansPerPixel;\n\t\tblurUniforms[ 'mipInt' ].value = _lodMax - lodIn;\n\n\t\tconst outputSize = this._sizeLods[ lodOut ];\n\t\tconst x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );\n\t\tconst y = 4 * ( this._cubeSize - outputSize );\n\n\t\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( targetOut );\n\t\trenderer.render( blurMesh, _flatCamera );\n\n\t}\n\n}\n\n\n\nfunction _createPlanes( lodMax ) {\n\n\tconst lodPlanes = [];\n\tconst sizeLods = [];\n\tconst sigmas = [];\n\n\tlet lod = lodMax;\n\n\tconst totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n\tfor ( let i = 0; i < totalLods; i ++ ) {\n\n\t\tconst sizeLod = Math.pow( 2, lod );\n\t\tsizeLods.push( sizeLod );\n\t\tlet sigma = 1.0 / sizeLod;\n\n\t\tif ( i > lodMax - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];\n\n\t\t} else if ( i === 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\n\t\tsigmas.push( sigma );\n\n\t\tconst texelSize = 1.0 / ( sizeLod - 2 );\n\t\tconst min = - texelSize;\n\t\tconst max = 1 + texelSize;\n\t\tconst uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tconst cubeFaces = 6;\n\t\tconst vertices = 6;\n\t\tconst positionSize = 3;\n\t\tconst uvSize = 2;\n\t\tconst faceIndexSize = 1;\n\n\t\tconst position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tconst uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tconst faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( let face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tconst x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tconst y = face > 2 ? 0 : - 1;\n\t\t\tconst coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\t\t\tposition.set( coordinates, positionSize * vertices * face );\n\t\t\tuv.set( uv1, uvSize * vertices * face );\n\t\t\tconst fill = [ face, face, face, face, face, face ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * face );\n\n\t\t}\n\n\t\tconst planes = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\t\tplanes.setAttribute( 'position', new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( faceIndex, faceIndexSize ) );\n\t\tlodPlanes.push( planes );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\n\treturn { lodPlanes, sizeLods, sigmas };\n\n}\n\nfunction _createRenderTarget( width, height, params ) {\n\n\tconst cubeUVRenderTarget = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget( width, height, params );\n\tcubeUVRenderTarget.texture.mapping = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( target, x, y, width, height ) {\n\n\ttarget.viewport.set( x, y, width, height );\n\ttarget.scissor.set( x, y, width, height );\n\n}\n\nfunction _getBlurShader( lodMax, width, height ) {\n\n\tconst weights = new Float32Array( MAX_SAMPLES );\n\tconst poleAxis = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3( 0, 1, 0 );\n\tconst shaderMaterial = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial( {\n\n\t\tname: 'SphericalGaussianBlur',\n\n\t\tdefines: {\n\t\t\t'n': MAX_SAMPLES,\n\t\t\t'CUBEUV_TEXEL_WIDTH': 1.0 / width,\n\t\t\t'CUBEUV_TEXEL_HEIGHT': 1.0 / height,\n\t\t\t'CUBEUV_MAX_MIP': `${lodMax}.0`,\n\t\t},\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'samples': { value: 1 },\n\t\t\t'weights': { value: weights },\n\t\t\t'latitudinal': { value: false },\n\t\t\t'dTheta': { value: 0 },\n\t\t\t'mipInt': { value: 0 },\n\t\t\t'poleAxis': { value: poleAxis }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getEquirectMaterial() {\n\n\treturn new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial( {\n\n\t\tname: 'EquirectangularToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n}\n\nfunction _getCubemapMaterial() {\n\n\treturn new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial( {\n\n\t\tname: 'CubemapToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'flipEnvMap': { value: - 1 }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n}\n\nfunction _getCommonVertexShader() {\n\n\treturn /* glsl */`\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`;\n\n}\n\nfunction WebGLCubeUVMaps( renderer ) {\n\n\tlet cubeUVmaps = new WeakMap();\n\n\tlet pmremGenerator = null;\n\n\tfunction get( texture ) {\n\n\t\tif ( texture && texture.isTexture ) {\n\n\t\t\tconst mapping = texture.mapping;\n\n\t\t\tconst isEquirectMap = ( mapping === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EquirectangularReflectionMapping || mapping === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EquirectangularRefractionMapping );\n\t\t\tconst isCubeMap = ( mapping === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeReflectionMapping || mapping === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeRefractionMapping );\n\n\t\t\t// equirect/cube map to cubeUV conversion\n\n\t\t\tif ( isEquirectMap || isCubeMap ) {\n\n\t\t\t\tlet renderTarget = cubeUVmaps.get( texture );\n\n\t\t\t\tconst currentPMREMVersion = renderTarget !== undefined ? renderTarget.texture.pmremVersion : 0;\n\n\t\t\t\tif ( texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion ) {\n\n\t\t\t\t\tif ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );\n\n\t\t\t\t\trenderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );\n\t\t\t\t\trenderTarget.texture.pmremVersion = texture.pmremVersion;\n\n\t\t\t\t\tcubeUVmaps.set( texture, renderTarget );\n\n\t\t\t\t\treturn renderTarget.texture;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( renderTarget !== undefined ) {\n\n\t\t\t\t\t\treturn renderTarget.texture;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\t\tif ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {\n\n\t\t\t\t\t\t\tif ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );\n\n\t\t\t\t\t\t\trenderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );\n\t\t\t\t\t\t\trenderTarget.texture.pmremVersion = texture.pmremVersion;\n\n\t\t\t\t\t\t\tcubeUVmaps.set( texture, renderTarget );\n\n\t\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\t\treturn renderTarget.texture;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// image not yet ready. try the conversion next frame\n\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tfunction isCubeTextureComplete( image ) {\n\n\t\tlet count = 0;\n\t\tconst length = 6;\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tif ( image[ i ] !== undefined ) count ++;\n\n\t\t}\n\n\t\treturn count === length;\n\n\n\t}\n\n\tfunction onTextureDispose( event ) {\n\n\t\tconst texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tconst cubemapUV = cubeUVmaps.get( texture );\n\n\t\tif ( cubemapUV !== undefined ) {\n\n\t\t\tcubeUVmaps.delete( texture );\n\t\t\tcubemapUV.dispose();\n\n\t\t}\n\n\t}\n\n\tfunction dispose() {\n\n\t\tcubeUVmaps = new WeakMap();\n\n\t\tif ( pmremGenerator !== null ) {\n\n\t\t\tpmremGenerator.dispose();\n\t\t\tpmremGenerator = null;\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction WebGLExtensions( gl ) {\n\n\tconst extensions = {};\n\n\tfunction getExtension( name ) {\n\n\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\treturn extensions[ name ];\n\n\t\t}\n\n\t\tlet extension;\n\n\t\tswitch ( name ) {\n\n\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\textension = gl.getExtension( name );\n\n\t\t}\n\n\t\textensions[ name ] = extension;\n\n\t\treturn extension;\n\n\t}\n\n\treturn {\n\n\t\thas: function ( name ) {\n\n\t\t\treturn getExtension( name ) !== null;\n\n\t\t},\n\n\t\tinit: function () {\n\n\t\t\tgetExtension( 'EXT_color_buffer_float' );\n\t\t\tgetExtension( 'WEBGL_clip_cull_distance' );\n\t\t\tgetExtension( 'OES_texture_float_linear' );\n\t\t\tgetExtension( 'EXT_color_buffer_half_float' );\n\t\t\tgetExtension( 'WEBGL_multisampled_render_to_texture' );\n\t\t\tgetExtension( 'WEBGL_render_shared_exponent' );\n\n\t\t},\n\n\t\tget: function ( name ) {\n\n\t\t\tconst extension = getExtension( name );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\t(0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.warnOnce)( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t\t}\n\n\t\t\treturn extension;\n\n\t\t}\n\n\t};\n\n}\n\nfunction WebGLGeometries( gl, attributes, info, bindingStates ) {\n\n\tconst geometries = {};\n\tconst wireframeAttributes = new WeakMap();\n\n\tfunction onGeometryDispose( event ) {\n\n\t\tconst geometry = event.target;\n\n\t\tif ( geometry.index !== null ) {\n\n\t\t\tattributes.remove( geometry.index );\n\n\t\t}\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tattributes.remove( geometry.attributes[ name ] );\n\n\t\t}\n\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\tdelete geometries[ geometry.id ];\n\n\t\tconst attribute = wireframeAttributes.get( geometry );\n\n\t\tif ( attribute ) {\n\n\t\t\tattributes.remove( attribute );\n\t\t\twireframeAttributes.delete( geometry );\n\n\t\t}\n\n\t\tbindingStates.releaseStatesOfGeometry( geometry );\n\n\t\tif ( geometry.isInstancedBufferGeometry === true ) {\n\n\t\t\tdelete geometry._maxInstanceCount;\n\n\t\t}\n\n\t\t//\n\n\t\tinfo.memory.geometries --;\n\n\t}\n\n\tfunction get( object, geometry ) {\n\n\t\tif ( geometries[ geometry.id ] === true ) return geometry;\n\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\tgeometries[ geometry.id ] = true;\n\n\t\tinfo.memory.geometries ++;\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction update( geometry ) {\n\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\t// Updating index buffer in VAO now. See WebGLBindingStates.\n\n\t\tfor ( const name in geometryAttributes ) {\n\n\t\t\tattributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );\n\n\t\t}\n\n\t}\n\n\tfunction updateWireframeAttribute( geometry ) {\n\n\t\tconst indices = [];\n\n\t\tconst geometryIndex = geometry.index;\n\t\tconst geometryPosition = geometry.attributes.position;\n\t\tlet version = 0;\n\n\t\tif ( geometryIndex !== null ) {\n\n\t\t\tconst array = geometryIndex.array;\n\t\t\tversion = geometryIndex.version;\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tconst a = array[ i + 0 ];\n\t\t\t\tconst b = array[ i + 1 ];\n\t\t\t\tconst c = array[ i + 2 ];\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t} else if ( geometryPosition !== undefined ) {\n\n\t\t\tconst array = geometryPosition.array;\n\t\t\tversion = geometryPosition.version;\n\n\t\t\tfor ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\tconst a = i + 0;\n\t\t\t\tconst b = i + 1;\n\t\t\t\tconst c = i + 2;\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst attribute = new ( (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.arrayNeedsUint32)( indices ) ? _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Uint32BufferAttribute : _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Uint16BufferAttribute )( indices, 1 );\n\t\tattribute.version = version;\n\n\t\t// Updating index buffer in VAO now. See WebGLBindingStates\n\n\t\t//\n\n\t\tconst previousAttribute = wireframeAttributes.get( geometry );\n\n\t\tif ( previousAttribute ) attributes.remove( previousAttribute );\n\n\t\t//\n\n\t\twireframeAttributes.set( geometry, attribute );\n\n\t}\n\n\tfunction getWireframeAttribute( geometry ) {\n\n\t\tconst currentAttribute = wireframeAttributes.get( geometry );\n\n\t\tif ( currentAttribute ) {\n\n\t\t\tconst geometryIndex = geometry.index;\n\n\t\t\tif ( geometryIndex !== null ) {\n\n\t\t\t\t// if the attribute is obsolete, create a new one\n\n\t\t\t\tif ( currentAttribute.version < geometryIndex.version ) {\n\n\t\t\t\t\tupdateWireframeAttribute( geometry );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tupdateWireframeAttribute( geometry );\n\n\t\t}\n\n\t\treturn wireframeAttributes.get( geometry );\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tupdate: update,\n\n\t\tgetWireframeAttribute: getWireframeAttribute\n\n\t};\n\n}\n\nfunction WebGLIndexedBufferRenderer( gl, extensions, info ) {\n\n\tlet mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tlet type, bytesPerElement;\n\n\tfunction setIndex( value ) {\n\n\t\ttype = value.type;\n\t\tbytesPerElement = value.bytesPerElement;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\tgl.drawElements( mode, count, type, start * bytesPerElement );\n\n\t\tinfo.update( count, mode, 1 );\n\n\t}\n\n\tfunction renderInstances( start, count, primcount ) {\n\n\t\tif ( primcount === 0 ) return;\n\n\t\tgl.drawElementsInstanced( mode, count, type, start * bytesPerElement, primcount );\n\n\t\tinfo.update( count, mode, primcount );\n\n\t}\n\n\tfunction renderMultiDraw( starts, counts, drawCount ) {\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\t\textension.multiDrawElementsWEBGL( mode, counts, 0, type, starts, 0, drawCount );\n\n\t\tlet elementCount = 0;\n\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\telementCount += counts[ i ];\n\n\t\t}\n\n\t\tinfo.update( elementCount, mode, 1 );\n\n\n\t}\n\n\tfunction renderMultiDrawInstances( starts, counts, drawCount, primcount ) {\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < starts.length; i ++ ) {\n\n\t\t\t\trenderInstances( starts[ i ] / bytesPerElement, counts[ i ], primcount[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\textension.multiDrawElementsInstancedWEBGL( mode, counts, 0, type, starts, 0, primcount, 0, drawCount );\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ] * primcount[ i ];\n\n\t\t\t}\n\n\t\t\tinfo.update( elementCount, mode, 1 );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tthis.setMode = setMode;\n\tthis.setIndex = setIndex;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\tthis.renderMultiDraw = renderMultiDraw;\n\tthis.renderMultiDrawInstances = renderMultiDrawInstances;\n\n}\n\nfunction WebGLInfo( gl ) {\n\n\tconst memory = {\n\t\tgeometries: 0,\n\t\ttextures: 0\n\t};\n\n\tconst render = {\n\t\tframe: 0,\n\t\tcalls: 0,\n\t\ttriangles: 0,\n\t\tpoints: 0,\n\t\tlines: 0\n\t};\n\n\tfunction update( count, mode, instanceCount ) {\n\n\t\trender.calls ++;\n\n\t\tswitch ( mode ) {\n\n\t\t\tcase gl.TRIANGLES:\n\t\t\t\trender.triangles += instanceCount * ( count / 3 );\n\t\t\t\tbreak;\n\n\t\t\tcase gl.LINES:\n\t\t\t\trender.lines += instanceCount * ( count / 2 );\n\t\t\t\tbreak;\n\n\t\t\tcase gl.LINE_STRIP:\n\t\t\t\trender.lines += instanceCount * ( count - 1 );\n\t\t\t\tbreak;\n\n\t\t\tcase gl.LINE_LOOP:\n\t\t\t\trender.lines += instanceCount * count;\n\t\t\t\tbreak;\n\n\t\t\tcase gl.POINTS:\n\t\t\t\trender.points += instanceCount * count;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction reset() {\n\n\t\trender.calls = 0;\n\t\trender.triangles = 0;\n\t\trender.points = 0;\n\t\trender.lines = 0;\n\n\t}\n\n\treturn {\n\t\tmemory: memory,\n\t\trender: render,\n\t\tprograms: null,\n\t\tautoReset: true,\n\t\treset: reset,\n\t\tupdate: update\n\t};\n\n}\n\nfunction WebGLMorphtargets( gl, capabilities, textures ) {\n\n\tconst morphTextures = new WeakMap();\n\tconst morph = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector4();\n\n\tfunction update( object, geometry, program ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\t// the following encodes morph targets into an array of data textures. Each layer represents a single morph target.\n\n\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\tlet entry = morphTextures.get( geometry );\n\n\t\tif ( entry === undefined || entry.count !== morphTargetsCount ) {\n\n\t\t\tif ( entry !== undefined ) entry.texture.dispose();\n\n\t\t\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\t\t\tconst hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n\t\t\tconst hasMorphColors = geometry.morphAttributes.color !== undefined;\n\n\t\t\tconst morphTargets = geometry.morphAttributes.position || [];\n\t\t\tconst morphNormals = geometry.morphAttributes.normal || [];\n\t\t\tconst morphColors = geometry.morphAttributes.color || [];\n\n\t\t\tlet vertexDataCount = 0;\n\n\t\t\tif ( hasMorphPosition === true ) vertexDataCount = 1;\n\t\t\tif ( hasMorphNormals === true ) vertexDataCount = 2;\n\t\t\tif ( hasMorphColors === true ) vertexDataCount = 3;\n\n\t\t\tlet width = geometry.attributes.position.count * vertexDataCount;\n\t\t\tlet height = 1;\n\n\t\t\tif ( width > capabilities.maxTextureSize ) {\n\n\t\t\t\theight = Math.ceil( width / capabilities.maxTextureSize );\n\t\t\t\twidth = capabilities.maxTextureSize;\n\n\t\t\t}\n\n\t\t\tconst buffer = new Float32Array( width * height * 4 * morphTargetsCount );\n\n\t\t\tconst texture = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DataArrayTexture( buffer, width, height, morphTargetsCount );\n\t\t\ttexture.type = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\t// fill buffer\n\n\t\t\tconst vertexDataStride = vertexDataCount * 4;\n\n\t\t\tfor ( let i = 0; i < morphTargetsCount; i ++ ) {\n\n\t\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\t\tconst morphNormal = morphNormals[ i ];\n\t\t\t\tconst morphColor = morphColors[ i ];\n\n\t\t\t\tconst offset = width * height * 4 * i;\n\n\t\t\t\tfor ( let j = 0; j < morphTarget.count; j ++ ) {\n\n\t\t\t\t\tconst stride = j * vertexDataStride;\n\n\t\t\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\t\t\tmorph.fromBufferAttribute( morphTarget, j );\n\n\t\t\t\t\t\tbuffer[ offset + stride + 0 ] = morph.x;\n\t\t\t\t\t\tbuffer[ offset + stride + 1 ] = morph.y;\n\t\t\t\t\t\tbuffer[ offset + stride + 2 ] = morph.z;\n\t\t\t\t\t\tbuffer[ offset + stride + 3 ] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\t\t\tmorph.fromBufferAttribute( morphNormal, j );\n\n\t\t\t\t\t\tbuffer[ offset + stride + 4 ] = morph.x;\n\t\t\t\t\t\tbuffer[ offset + stride + 5 ] = morph.y;\n\t\t\t\t\t\tbuffer[ offset + stride + 6 ] = morph.z;\n\t\t\t\t\t\tbuffer[ offset + stride + 7 ] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasMorphColors === true ) {\n\n\t\t\t\t\t\tmorph.fromBufferAttribute( morphColor, j );\n\n\t\t\t\t\t\tbuffer[ offset + stride + 8 ] = morph.x;\n\t\t\t\t\t\tbuffer[ offset + stride + 9 ] = morph.y;\n\t\t\t\t\t\tbuffer[ offset + stride + 10 ] = morph.z;\n\t\t\t\t\t\tbuffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tentry = {\n\t\t\t\tcount: morphTargetsCount,\n\t\t\t\ttexture: texture,\n\t\t\t\tsize: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector2( width, height )\n\t\t\t};\n\n\t\t\tmorphTextures.set( geometry, entry );\n\n\t\t\tfunction disposeTexture() {\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t\tmorphTextures.delete( geometry );\n\n\t\t\t\tgeometry.removeEventListener( 'dispose', disposeTexture );\n\n\t\t\t}\n\n\t\t\tgeometry.addEventListener( 'dispose', disposeTexture );\n\n\t\t}\n\n\t\t//\n\t\tif ( object.isInstancedMesh === true && object.morphTexture !== null ) {\n\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTexture', object.morphTexture, textures );\n\n\t\t} else {\n\n\t\t\tlet morphInfluencesSum = 0;\n\n\t\t\tfor ( let i = 0; i < objectInfluences.length; i ++ ) {\n\n\t\t\t\tmorphInfluencesSum += objectInfluences[ i ];\n\n\t\t\t}\n\n\t\t\tconst morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\n\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );\n\n\t\t}\n\n\t\tprogram.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );\n\t\tprogram.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );\n\n\t}\n\n\treturn {\n\n\t\tupdate: update\n\n\t};\n\n}\n\nfunction WebGLObjects( gl, geometries, attributes, info ) {\n\n\tlet updateMap = new WeakMap();\n\n\tfunction update( object ) {\n\n\t\tconst frame = info.render.frame;\n\n\t\tconst geometry = object.geometry;\n\t\tconst buffergeometry = geometries.get( object, geometry );\n\n\t\t// Update once per frame\n\n\t\tif ( updateMap.get( buffergeometry ) !== frame ) {\n\n\t\t\tgeometries.update( buffergeometry );\n\n\t\t\tupdateMap.set( buffergeometry, frame );\n\n\t\t}\n\n\t\tif ( object.isInstancedMesh ) {\n\n\t\t\tif ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {\n\n\t\t\t\tobject.addEventListener( 'dispose', onInstancedMeshDispose );\n\n\t\t\t}\n\n\t\t\tif ( updateMap.get( object ) !== frame ) {\n\n\t\t\t\tattributes.update( object.instanceMatrix, gl.ARRAY_BUFFER );\n\n\t\t\t\tif ( object.instanceColor !== null ) {\n\n\t\t\t\t\tattributes.update( object.instanceColor, gl.ARRAY_BUFFER );\n\n\t\t\t\t}\n\n\t\t\t\tupdateMap.set( object, frame );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tconst skeleton = object.skeleton;\n\n\t\t\tif ( updateMap.get( skeleton ) !== frame ) {\n\n\t\t\t\tskeleton.update();\n\n\t\t\t\tupdateMap.set( skeleton, frame );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn buffergeometry;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tupdateMap = new WeakMap();\n\n\t}\n\n\tfunction onInstancedMeshDispose( event ) {\n\n\t\tconst instancedMesh = event.target;\n\n\t\tinstancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );\n\n\t\tattributes.remove( instancedMesh.instanceMatrix );\n\n\t\tif ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );\n\n\t}\n\n\treturn {\n\n\t\tupdate: update,\n\t\tdispose: dispose\n\n\t};\n\n}\n\n/**\n * Uniforms of a program.\n * Those form a tree structure with a special top-level container for the root,\n * which you get by calling 'new WebGLUniforms( gl, program )'.\n *\n *\n * Properties of inner nodes including the top-level container:\n *\n * .seq - array of nested uniforms\n * .map - nested uniforms by name\n *\n *\n * Methods of all nodes except the top-level container:\n *\n * .setValue( gl, value, [textures] )\n *\n * \t\tuploads a uniform value(s)\n *  \tthe 'textures' parameter is needed for sampler uniforms\n *\n *\n * Static methods of the top-level container (textures factorizations):\n *\n * .upload( gl, seq, values, textures )\n *\n * \t\tsets uniforms in 'seq' to 'values[id].value'\n *\n * .seqWithValue( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with corresponding entry in values\n *\n *\n * Methods of the top-level container (textures factorizations):\n *\n * .setValue( gl, name, value, textures )\n *\n * \t\tsets uniform with  name 'name' to 'value'\n *\n * .setOptional( gl, obj, prop )\n *\n * \t\tlike .set for an optional property of the object\n *\n */\n\n\nconst emptyTexture = /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Texture();\n\nconst emptyShadowTexture = /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DepthTexture( 1, 1 );\n\nconst emptyArrayTexture = /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DataArrayTexture();\nconst empty3dTexture = /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture();\nconst emptyCubeTexture = /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeTexture();\n\n// --- Utilities ---\n\n// Array Caches (provide typed arrays for temporary by size)\n\nconst arrayCacheF32 = [];\nconst arrayCacheI32 = [];\n\n// Float32Array caches used for uploading Matrix uniforms\n\nconst mat4array = new Float32Array( 16 );\nconst mat3array = new Float32Array( 9 );\nconst mat2array = new Float32Array( 4 );\n\n// Flattening for arrays of vectors and matrices\n\nfunction flatten( array, nBlocks, blockSize ) {\n\n\tconst firstElem = array[ 0 ];\n\n\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t// unoptimized: ! isNaN( firstElem )\n\t// see http://jacksondunstan.com/articles/983\n\n\tconst n = nBlocks * blockSize;\n\tlet r = arrayCacheF32[ n ];\n\n\tif ( r === undefined ) {\n\n\t\tr = new Float32Array( n );\n\t\tarrayCacheF32[ n ] = r;\n\n\t}\n\n\tif ( nBlocks !== 0 ) {\n\n\t\tfirstElem.toArray( r, 0 );\n\n\t\tfor ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\toffset += blockSize;\n\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t}\n\n\t}\n\n\treturn r;\n\n}\n\nfunction arraysEqual( a, b ) {\n\n\tif ( a.length !== b.length ) return false;\n\n\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction copyArray( a, b ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\ta[ i ] = b[ i ];\n\n\t}\n\n}\n\n// Texture unit allocation\n\nfunction allocTexUnits( textures, n ) {\n\n\tlet r = arrayCacheI32[ n ];\n\n\tif ( r === undefined ) {\n\n\t\tr = new Int32Array( n );\n\t\tarrayCacheI32[ n ] = r;\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\tr[ i ] = textures.allocateTextureUnit();\n\n\t}\n\n\treturn r;\n\n}\n\n// --- Setters ---\n\n// Note: Defining these methods externally, because they come in a bunch\n// and this way their names minify.\n\n// Single scalar\n\nfunction setValueV1f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1f( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single float vector (from flat array or THREE.VectorN)\n\nfunction setValueV2f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {\n\n\t\t\tgl.uniform2f( this.addr, v.x, v.y );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform2fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV3f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {\n\n\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\n\t\t}\n\n\t} else if ( v.r !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {\n\n\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\n\t\t\tcache[ 0 ] = v.r;\n\t\t\tcache[ 1 ] = v.g;\n\t\t\tcache[ 2 ] = v.b;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform3fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV4f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {\n\n\t\t\tgl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\t\t\tcache[ 3 ] = v.w;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform4fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\n// Single matrix (from flat array or THREE.MatrixN)\n\nfunction setValueM2( gl, v ) {\n\n\tconst cache = this.cache;\n\tconst elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix2fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat2array.set( elements );\n\n\t\tgl.uniformMatrix2fv( this.addr, false, mat2array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\nfunction setValueM3( gl, v ) {\n\n\tconst cache = this.cache;\n\tconst elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix3fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat3array.set( elements );\n\n\t\tgl.uniformMatrix3fv( this.addr, false, mat3array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\nfunction setValueM4( gl, v ) {\n\n\tconst cache = this.cache;\n\tconst elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix4fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat4array.set( elements );\n\n\t\tgl.uniformMatrix4fv( this.addr, false, mat4array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\n// Single integer / boolean\n\nfunction setValueV1i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1i( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single integer / boolean vector (from flat array or THREE.VectorN)\n\nfunction setValueV2i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {\n\n\t\t\tgl.uniform2i( this.addr, v.x, v.y );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform2iv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV3i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {\n\n\t\t\tgl.uniform3i( this.addr, v.x, v.y, v.z );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform3iv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV4i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {\n\n\t\t\tgl.uniform4i( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\t\t\tcache[ 3 ] = v.w;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform4iv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\n// Single unsigned integer\n\nfunction setValueV1ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1ui( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single unsigned integer vector (from flat array or THREE.VectorN)\n\nfunction setValueV2ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {\n\n\t\t\tgl.uniform2ui( this.addr, v.x, v.y );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform2uiv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV3ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {\n\n\t\t\tgl.uniform3ui( this.addr, v.x, v.y, v.z );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform3uiv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV4ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {\n\n\t\t\tgl.uniform4ui( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\t\t\tcache[ 3 ] = v.w;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform4uiv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\n\n// Single texture (2D / Cube)\n\nfunction setValueT1( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\tlet emptyTexture2D;\n\n\tif ( this.type === gl.SAMPLER_2D_SHADOW ) {\n\n\t\temptyShadowTexture.compareFunction = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LessEqualCompare; // #28670\n\t\temptyTexture2D = emptyShadowTexture;\n\n\t} else {\n\n\t\temptyTexture2D = emptyTexture;\n\n\t}\n\n\ttextures.setTexture2D( v || emptyTexture2D, unit );\n\n}\n\nfunction setValueT3D1( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTexture3D( v || empty3dTexture, unit );\n\n}\n\nfunction setValueT6( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTextureCube( v || emptyCubeTexture, unit );\n\n}\n\nfunction setValueT2DArray1( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTexture2DArray( v || emptyArrayTexture, unit );\n\n}\n\n// Helper to pick the right setter for the singular case\n\nfunction getSingularSetter( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase 0x1406: return setValueV1f; // FLOAT\n\t\tcase 0x8b50: return setValueV2f; // _VEC2\n\t\tcase 0x8b51: return setValueV3f; // _VEC3\n\t\tcase 0x8b52: return setValueV4f; // _VEC4\n\n\t\tcase 0x8b5a: return setValueM2; // _MAT2\n\t\tcase 0x8b5b: return setValueM3; // _MAT3\n\t\tcase 0x8b5c: return setValueM4; // _MAT4\n\n\t\tcase 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL\n\t\tcase 0x8b53: case 0x8b57: return setValueV2i; // _VEC2\n\t\tcase 0x8b54: case 0x8b58: return setValueV3i; // _VEC3\n\t\tcase 0x8b55: case 0x8b59: return setValueV4i; // _VEC4\n\n\t\tcase 0x1405: return setValueV1ui; // UINT\n\t\tcase 0x8dc6: return setValueV2ui; // _VEC2\n\t\tcase 0x8dc7: return setValueV3ui; // _VEC3\n\t\tcase 0x8dc8: return setValueV4ui; // _VEC4\n\n\t\tcase 0x8b5e: // SAMPLER_2D\n\t\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\n\t\tcase 0x8dca: // INT_SAMPLER_2D\n\t\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\t\tcase 0x8b62: // SAMPLER_2D_SHADOW\n\t\t\treturn setValueT1;\n\n\t\tcase 0x8b5f: // SAMPLER_3D\n\t\tcase 0x8dcb: // INT_SAMPLER_3D\n\t\tcase 0x8dd3: // UNSIGNED_INT_SAMPLER_3D\n\t\t\treturn setValueT3D1;\n\n\t\tcase 0x8b60: // SAMPLER_CUBE\n\t\tcase 0x8dcc: // INT_SAMPLER_CUBE\n\t\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\t\tcase 0x8dc5: // SAMPLER_CUBE_SHADOW\n\t\t\treturn setValueT6;\n\n\t\tcase 0x8dc1: // SAMPLER_2D_ARRAY\n\t\tcase 0x8dcf: // INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW\n\t\t\treturn setValueT2DArray1;\n\n\t}\n\n}\n\n\n// Array of scalars\n\nfunction setValueV1fArray( gl, v ) {\n\n\tgl.uniform1fv( this.addr, v );\n\n}\n\n// Array of vectors (from flat array or array of THREE.VectorN)\n\nfunction setValueV2fArray( gl, v ) {\n\n\tconst data = flatten( v, this.size, 2 );\n\n\tgl.uniform2fv( this.addr, data );\n\n}\n\nfunction setValueV3fArray( gl, v ) {\n\n\tconst data = flatten( v, this.size, 3 );\n\n\tgl.uniform3fv( this.addr, data );\n\n}\n\nfunction setValueV4fArray( gl, v ) {\n\n\tconst data = flatten( v, this.size, 4 );\n\n\tgl.uniform4fv( this.addr, data );\n\n}\n\n// Array of matrices (from flat array or array of THREE.MatrixN)\n\nfunction setValueM2Array( gl, v ) {\n\n\tconst data = flatten( v, this.size, 4 );\n\n\tgl.uniformMatrix2fv( this.addr, false, data );\n\n}\n\nfunction setValueM3Array( gl, v ) {\n\n\tconst data = flatten( v, this.size, 9 );\n\n\tgl.uniformMatrix3fv( this.addr, false, data );\n\n}\n\nfunction setValueM4Array( gl, v ) {\n\n\tconst data = flatten( v, this.size, 16 );\n\n\tgl.uniformMatrix4fv( this.addr, false, data );\n\n}\n\n// Array of integer / boolean\n\nfunction setValueV1iArray( gl, v ) {\n\n\tgl.uniform1iv( this.addr, v );\n\n}\n\n// Array of integer / boolean vectors (from flat array)\n\nfunction setValueV2iArray( gl, v ) {\n\n\tgl.uniform2iv( this.addr, v );\n\n}\n\nfunction setValueV3iArray( gl, v ) {\n\n\tgl.uniform3iv( this.addr, v );\n\n}\n\nfunction setValueV4iArray( gl, v ) {\n\n\tgl.uniform4iv( this.addr, v );\n\n}\n\n// Array of unsigned integer\n\nfunction setValueV1uiArray( gl, v ) {\n\n\tgl.uniform1uiv( this.addr, v );\n\n}\n\n// Array of unsigned integer vectors (from flat array)\n\nfunction setValueV2uiArray( gl, v ) {\n\n\tgl.uniform2uiv( this.addr, v );\n\n}\n\nfunction setValueV3uiArray( gl, v ) {\n\n\tgl.uniform3uiv( this.addr, v );\n\n}\n\nfunction setValueV4uiArray( gl, v ) {\n\n\tgl.uniform4uiv( this.addr, v );\n\n}\n\n\n// Array of textures (2D / 3D / Cube / 2DArray)\n\nfunction setValueT1Array( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tif ( ! arraysEqual( cache, units ) ) {\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tcopyArray( cache, units );\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t}\n\n}\n\nfunction setValueT3DArray( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tif ( ! arraysEqual( cache, units ) ) {\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tcopyArray( cache, units );\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.setTexture3D( v[ i ] || empty3dTexture, units[ i ] );\n\n\t}\n\n}\n\nfunction setValueT6Array( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tif ( ! arraysEqual( cache, units ) ) {\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tcopyArray( cache, units );\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t}\n\n}\n\nfunction setValueT2DArrayArray( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tif ( ! arraysEqual( cache, units ) ) {\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tcopyArray( cache, units );\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.setTexture2DArray( v[ i ] || emptyArrayTexture, units[ i ] );\n\n\t}\n\n}\n\n\n// Helper to pick the right setter for a pure (bottom-level) array\n\nfunction getPureArraySetter( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase 0x1406: return setValueV1fArray; // FLOAT\n\t\tcase 0x8b50: return setValueV2fArray; // _VEC2\n\t\tcase 0x8b51: return setValueV3fArray; // _VEC3\n\t\tcase 0x8b52: return setValueV4fArray; // _VEC4\n\n\t\tcase 0x8b5a: return setValueM2Array; // _MAT2\n\t\tcase 0x8b5b: return setValueM3Array; // _MAT3\n\t\tcase 0x8b5c: return setValueM4Array; // _MAT4\n\n\t\tcase 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL\n\t\tcase 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2\n\t\tcase 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3\n\t\tcase 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4\n\n\t\tcase 0x1405: return setValueV1uiArray; // UINT\n\t\tcase 0x8dc6: return setValueV2uiArray; // _VEC2\n\t\tcase 0x8dc7: return setValueV3uiArray; // _VEC3\n\t\tcase 0x8dc8: return setValueV4uiArray; // _VEC4\n\n\t\tcase 0x8b5e: // SAMPLER_2D\n\t\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\n\t\tcase 0x8dca: // INT_SAMPLER_2D\n\t\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\t\tcase 0x8b62: // SAMPLER_2D_SHADOW\n\t\t\treturn setValueT1Array;\n\n\t\tcase 0x8b5f: // SAMPLER_3D\n\t\tcase 0x8dcb: // INT_SAMPLER_3D\n\t\tcase 0x8dd3: // UNSIGNED_INT_SAMPLER_3D\n\t\t\treturn setValueT3DArray;\n\n\t\tcase 0x8b60: // SAMPLER_CUBE\n\t\tcase 0x8dcc: // INT_SAMPLER_CUBE\n\t\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\t\tcase 0x8dc5: // SAMPLER_CUBE_SHADOW\n\t\t\treturn setValueT6Array;\n\n\t\tcase 0x8dc1: // SAMPLER_2D_ARRAY\n\t\tcase 0x8dcf: // INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW\n\t\t\treturn setValueT2DArrayArray;\n\n\t}\n\n}\n\n// --- Uniform Classes ---\n\nclass SingleUniform {\n\n\tconstructor( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.cache = [];\n\t\tthis.type = activeInfo.type;\n\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n}\n\nclass PureArrayUniform {\n\n\tconstructor( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.cache = [];\n\t\tthis.type = activeInfo.type;\n\t\tthis.size = activeInfo.size;\n\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n}\n\nclass StructuredUniform {\n\n\tconstructor( id ) {\n\n\t\tthis.id = id;\n\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\n\t}\n\n\tsetValue( gl, value, textures ) {\n\n\t\tconst seq = this.seq;\n\n\t\tfor ( let i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tconst u = seq[ i ];\n\t\t\tu.setValue( gl, value[ u.id ], textures );\n\n\t\t}\n\n\t}\n\n}\n\n// --- Top-level ---\n\n// Parser - builds up the property tree from the path strings\n\nconst RePathPart = /(\\w+)(\\])?(\\[|\\.)?/g;\n\n// extracts\n// \t- the identifier (member name or array index)\n//  - followed by an optional right bracket (found when array index)\n//  - followed by an optional left bracket or dot (type of subscript)\n//\n// Note: These portions can be read in a non-overlapping fashion and\n// allow straightforward parsing of the hierarchy that WebGL encodes\n// in the uniform names.\n\nfunction addUniform( container, uniformObject ) {\n\n\tcontainer.seq.push( uniformObject );\n\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n}\n\nfunction parseUniform( activeInfo, addr, container ) {\n\n\tconst path = activeInfo.name,\n\t\tpathLength = path.length;\n\n\t// reset RegExp object, because of the early exit of a previous run\n\tRePathPart.lastIndex = 0;\n\n\twhile ( true ) {\n\n\t\tconst match = RePathPart.exec( path ),\n\t\t\tmatchEnd = RePathPart.lastIndex;\n\n\t\tlet id = match[ 1 ];\n\t\tconst idIsIndex = match[ 2 ] === ']',\n\t\t\tsubscript = match[ 3 ];\n\n\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\tif ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {\n\n\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\tbreak;\n\n\t\t} else {\n\n\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\tconst map = container.map;\n\t\t\tlet next = map[ id ];\n\n\t\t\tif ( next === undefined ) {\n\n\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\taddUniform( container, next );\n\n\t\t\t}\n\n\t\t\tcontainer = next;\n\n\t\t}\n\n\t}\n\n}\n\n// Root Container\n\nclass WebGLUniforms {\n\n\tconstructor( gl, program ) {\n\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\n\t\tconst n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\n\t\tfor ( let i = 0; i < n; ++ i ) {\n\n\t\t\tconst info = gl.getActiveUniform( program, i ),\n\t\t\t\taddr = gl.getUniformLocation( program, info.name );\n\n\t\t\tparseUniform( info, addr, this );\n\n\t\t}\n\n\t}\n\n\tsetValue( gl, name, value, textures ) {\n\n\t\tconst u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, value, textures );\n\n\t}\n\n\tsetOptional( gl, object, name ) {\n\n\t\tconst v = object[ name ];\n\n\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n\t}\n\n\tstatic upload( gl, seq, values, textures ) {\n\n\t\tfor ( let i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tconst u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v.needsUpdate !== false ) {\n\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\t\t\t\tu.setValue( gl, v.value, textures );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic seqWithValue( seq, values ) {\n\n\t\tconst r = [];\n\n\t\tfor ( let i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tconst u = seq[ i ];\n\t\t\tif ( u.id in values ) r.push( u );\n\n\t\t}\n\n\t\treturn r;\n\n\t}\n\n}\n\nfunction WebGLShader( gl, type, string ) {\n\n\tconst shader = gl.createShader( type );\n\n\tgl.shaderSource( shader, string );\n\tgl.compileShader( shader );\n\n\treturn shader;\n\n}\n\n// From https://www.khronos.org/registry/webgl/extensions/KHR_parallel_shader_compile/\nconst COMPLETION_STATUS_KHR = 0x91B1;\n\nlet programIdCount = 0;\n\nfunction handleSource( string, errorLine ) {\n\n\tconst lines = string.split( '\\n' );\n\tconst lines2 = [];\n\n\tconst from = Math.max( errorLine - 6, 0 );\n\tconst to = Math.min( errorLine + 6, lines.length );\n\n\tfor ( let i = from; i < to; i ++ ) {\n\n\t\tconst line = i + 1;\n\t\tlines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );\n\n\t}\n\n\treturn lines2.join( '\\n' );\n\n}\n\nconst _m0 = /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n\nfunction getEncodingComponents( colorSpace ) {\n\n\t_three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement._getMatrix( _m0, _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.workingColorSpace, colorSpace );\n\n\tconst encodingMatrix = `mat3( ${ _m0.elements.map( ( v ) => v.toFixed( 4 ) ) } )`;\n\n\tswitch ( _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.getTransfer( colorSpace ) ) {\n\n\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearTransfer:\n\t\t\treturn [ encodingMatrix, 'LinearTransferOETF' ];\n\n\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer:\n\t\t\treturn [ encodingMatrix, 'sRGBTransferOETF' ];\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.WebGLProgram: Unsupported color space: ', colorSpace );\n\t\t\treturn [ encodingMatrix, 'LinearTransferOETF' ];\n\n\t}\n\n}\n\nfunction getShaderErrors( gl, shader, type ) {\n\n\tconst status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );\n\tconst errors = gl.getShaderInfoLog( shader ).trim();\n\n\tif ( status && errors === '' ) return '';\n\n\tconst errorMatches = /ERROR: 0:(\\d+)/.exec( errors );\n\tif ( errorMatches ) {\n\n\t\t// --enable-privileged-webgl-extension\n\t\t// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\tconst errorLine = parseInt( errorMatches[ 1 ] );\n\t\treturn type.toUpperCase() + '\\n\\n' + errors + '\\n\\n' + handleSource( gl.getShaderSource( shader ), errorLine );\n\n\t} else {\n\n\t\treturn errors;\n\n\t}\n\n}\n\nfunction getTexelEncodingFunction( functionName, colorSpace ) {\n\n\tconst components = getEncodingComponents( colorSpace );\n\n\treturn [\n\n\t\t`vec4 ${functionName}( vec4 value ) {`,\n\n\t\t`\treturn ${components[ 1 ]}( vec4( value.rgb * ${components[ 0 ]}, value.a ) );`,\n\n\t\t'}',\n\n\t].join( '\\n' );\n\n}\n\nfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\tlet toneMappingName;\n\n\tswitch ( toneMapping ) {\n\n\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearToneMapping:\n\t\t\ttoneMappingName = 'Linear';\n\t\t\tbreak;\n\n\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ReinhardToneMapping:\n\t\t\ttoneMappingName = 'Reinhard';\n\t\t\tbreak;\n\n\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CineonToneMapping:\n\t\t\ttoneMappingName = 'Cineon';\n\t\t\tbreak;\n\n\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ACESFilmicToneMapping:\n\t\t\ttoneMappingName = 'ACESFilmic';\n\t\t\tbreak;\n\n\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AgXToneMapping:\n\t\t\ttoneMappingName = 'AgX';\n\t\t\tbreak;\n\n\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NeutralToneMapping:\n\t\t\ttoneMappingName = 'Neutral';\n\t\t\tbreak;\n\n\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CustomToneMapping:\n\t\t\ttoneMappingName = 'Custom';\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );\n\t\t\ttoneMappingName = 'Linear';\n\n\t}\n\n\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\n\n}\n\nconst _v0 = /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\nfunction getLuminanceFunction() {\n\n\t_three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.getLuminanceCoefficients( _v0 );\n\n\tconst r = _v0.x.toFixed( 4 );\n\tconst g = _v0.y.toFixed( 4 );\n\tconst b = _v0.z.toFixed( 4 );\n\n\treturn [\n\n\t\t'float luminance( const in vec3 rgb ) {',\n\n\t\t`\tconst vec3 weights = vec3( ${ r }, ${ g }, ${ b } );`,\n\n\t\t'\treturn dot( weights, rgb );',\n\n\t\t'}'\n\n\t].join( '\\n' );\n\n}\n\nfunction generateVertexExtensions( parameters ) {\n\n\tconst chunks = [\n\t\tparameters.extensionClipCullDistance ? '#extension GL_ANGLE_clip_cull_distance : require' : '',\n\t\tparameters.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '',\n\t];\n\n\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n}\n\nfunction generateDefines( defines ) {\n\n\tconst chunks = [];\n\n\tfor ( const name in defines ) {\n\n\t\tconst value = defines[ name ];\n\n\t\tif ( value === false ) continue;\n\n\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t}\n\n\treturn chunks.join( '\\n' );\n\n}\n\nfunction fetchAttributeLocations( gl, program ) {\n\n\tconst attributes = {};\n\n\tconst n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\n\tfor ( let i = 0; i < n; i ++ ) {\n\n\t\tconst info = gl.getActiveAttrib( program, i );\n\t\tconst name = info.name;\n\n\t\tlet locationSize = 1;\n\t\tif ( info.type === gl.FLOAT_MAT2 ) locationSize = 2;\n\t\tif ( info.type === gl.FLOAT_MAT3 ) locationSize = 3;\n\t\tif ( info.type === gl.FLOAT_MAT4 ) locationSize = 4;\n\n\t\t// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\n\n\t\tattributes[ name ] = {\n\t\t\ttype: info.type,\n\t\t\tlocation: gl.getAttribLocation( program, name ),\n\t\t\tlocationSize: locationSize\n\t\t};\n\n\t}\n\n\treturn attributes;\n\n}\n\nfunction filterEmptyLine( string ) {\n\n\treturn string !== '';\n\n}\n\nfunction replaceLightNums( string, parameters ) {\n\n\tconst numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;\n\n\treturn string\n\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t.replace( /NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps )\n\t\t.replace( /NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords )\n\t\t.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )\n\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )\n\t\t.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )\n\t\t.replace( /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps )\n\t\t.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )\n\t\t.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );\n\n}\n\nfunction replaceClippingPlaneNums( string, parameters ) {\n\n\treturn string\n\t\t.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )\n\t\t.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );\n\n}\n\n// Resolve Includes\n\nconst includePattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\nfunction resolveIncludes( string ) {\n\n\treturn string.replace( includePattern, includeReplacer );\n\n}\n\nconst shaderChunkMap = new Map();\n\nfunction includeReplacer( match, include ) {\n\n\tlet string = ShaderChunk[ include ];\n\n\tif ( string === undefined ) {\n\n\t\tconst newInclude = shaderChunkMap.get( include );\n\n\t\tif ( newInclude !== undefined ) {\n\n\t\t\tstring = ShaderChunk[ newInclude ];\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Shader chunk \"%s\" has been deprecated. Use \"%s\" instead.', include, newInclude );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t\t}\n\n\t}\n\n\treturn resolveIncludes( string );\n\n}\n\n// Unroll Loops\n\nconst unrollLoopPattern = /#pragma unroll_loop_start\\s+for\\s*\\(\\s*int\\s+i\\s*=\\s*(\\d+)\\s*;\\s*i\\s*<\\s*(\\d+)\\s*;\\s*i\\s*\\+\\+\\s*\\)\\s*{([\\s\\S]+?)}\\s+#pragma unroll_loop_end/g;\n\nfunction unrollLoops( string ) {\n\n\treturn string.replace( unrollLoopPattern, loopReplacer );\n\n}\n\nfunction loopReplacer( match, start, end, snippet ) {\n\n\tlet string = '';\n\n\tfor ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\tstring += snippet\n\t\t\t.replace( /\\[\\s*i\\s*\\]/g, '[ ' + i + ' ]' )\n\t\t\t.replace( /UNROLLED_LOOP_INDEX/g, i );\n\n\t}\n\n\treturn string;\n\n}\n\n//\n\nfunction generatePrecision( parameters ) {\n\n\tlet precisionstring = `precision ${parameters.precision} float;\n\tprecision ${parameters.precision} int;\n\tprecision ${parameters.precision} sampler2D;\n\tprecision ${parameters.precision} samplerCube;\n\tprecision ${parameters.precision} sampler3D;\n\tprecision ${parameters.precision} sampler2DArray;\n\tprecision ${parameters.precision} sampler2DShadow;\n\tprecision ${parameters.precision} samplerCubeShadow;\n\tprecision ${parameters.precision} sampler2DArrayShadow;\n\tprecision ${parameters.precision} isampler2D;\n\tprecision ${parameters.precision} isampler3D;\n\tprecision ${parameters.precision} isamplerCube;\n\tprecision ${parameters.precision} isampler2DArray;\n\tprecision ${parameters.precision} usampler2D;\n\tprecision ${parameters.precision} usampler3D;\n\tprecision ${parameters.precision} usamplerCube;\n\tprecision ${parameters.precision} usampler2DArray;\n\t`;\n\n\tif ( parameters.precision === 'highp' ) {\n\n\t\tprecisionstring += '\\n#define HIGH_PRECISION';\n\n\t} else if ( parameters.precision === 'mediump' ) {\n\n\t\tprecisionstring += '\\n#define MEDIUM_PRECISION';\n\n\t} else if ( parameters.precision === 'lowp' ) {\n\n\t\tprecisionstring += '\\n#define LOW_PRECISION';\n\n\t}\n\n\treturn precisionstring;\n\n}\n\nfunction generateShadowMapTypeDefine( parameters ) {\n\n\tlet shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\tif ( parameters.shadowMapType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PCFShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t} else if ( parameters.shadowMapType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PCFSoftShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t} else if ( parameters.shadowMapType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.VSMShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';\n\n\t}\n\n\treturn shadowMapTypeDefine;\n\n}\n\nfunction generateEnvMapTypeDefine( parameters ) {\n\n\tlet envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( parameters.envMapMode ) {\n\n\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeReflectionMapping:\n\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeRefractionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\tbreak;\n\n\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeUVReflectionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn envMapTypeDefine;\n\n}\n\nfunction generateEnvMapModeDefine( parameters ) {\n\n\tlet envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( parameters.envMapMode ) {\n\n\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeRefractionMapping:\n\n\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn envMapModeDefine;\n\n}\n\nfunction generateEnvMapBlendingDefine( parameters ) {\n\n\tlet envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( parameters.combine ) {\n\n\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MultiplyOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\tbreak;\n\n\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MixOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\tbreak;\n\n\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AddOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn envMapBlendingDefine;\n\n}\n\nfunction generateCubeUVSize( parameters ) {\n\n\tconst imageHeight = parameters.envMapCubeUVHeight;\n\n\tif ( imageHeight === null ) return null;\n\n\tconst maxMip = Math.log2( imageHeight ) - 2;\n\n\tconst texelHeight = 1.0 / imageHeight;\n\n\tconst texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );\n\n\treturn { texelWidth, texelHeight, maxMip };\n\n}\n\nfunction WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {\n\n\t// TODO Send this event to Three.js DevTools\n\t// console.log( 'WebGLProgram', cacheKey );\n\n\tconst gl = renderer.getContext();\n\n\tconst defines = parameters.defines;\n\n\tlet vertexShader = parameters.vertexShader;\n\tlet fragmentShader = parameters.fragmentShader;\n\n\tconst shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );\n\tconst envMapTypeDefine = generateEnvMapTypeDefine( parameters );\n\tconst envMapModeDefine = generateEnvMapModeDefine( parameters );\n\tconst envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );\n\tconst envMapCubeUVSize = generateCubeUVSize( parameters );\n\n\tconst customVertexExtensions = generateVertexExtensions( parameters );\n\n\tconst customDefines = generateDefines( defines );\n\n\tconst program = gl.createProgram();\n\n\tlet prefixVertex, prefixFragment;\n\tlet versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\\n' : '';\n\n\tif ( parameters.isRawShaderMaterial ) {\n\n\t\tprefixVertex = [\n\n\t\t\t'#define SHADER_TYPE ' + parameters.shaderType,\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tif ( prefixVertex.length > 0 ) {\n\n\t\t\tprefixVertex += '\\n';\n\n\t\t}\n\n\t\tprefixFragment = [\n\n\t\t\t'#define SHADER_TYPE ' + parameters.shaderType,\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tif ( prefixFragment.length > 0 ) {\n\n\t\t\tprefixFragment += '\\n';\n\n\t\t}\n\n\t} else {\n\n\t\tprefixVertex = [\n\n\t\t\tgeneratePrecision( parameters ),\n\n\t\t\t'#define SHADER_TYPE ' + parameters.shaderType,\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines,\n\n\t\t\tparameters.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',\n\t\t\tparameters.batching ? '#define USE_BATCHING' : '',\n\t\t\tparameters.batchingColor ? '#define USE_BATCHING_COLOR' : '',\n\t\t\tparameters.instancing ? '#define USE_INSTANCING' : '',\n\t\t\tparameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',\n\t\t\tparameters.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',\n\n\t\t\tparameters.useFog && parameters.fog ? '#define USE_FOG' : '',\n\t\t\tparameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',\n\n\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\tparameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',\n\t\t\tparameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',\n\t\t\tparameters.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\n\t\t\tparameters.anisotropy ? '#define USE_ANISOTROPY' : '',\n\t\t\tparameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',\n\n\t\t\tparameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',\n\t\t\tparameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',\n\t\t\tparameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',\n\n\t\t\tparameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',\n\t\t\tparameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',\n\n\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\tparameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',\n\t\t\tparameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',\n\n\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\tparameters.alphaHash ? '#define USE_ALPHAHASH' : '',\n\n\t\t\tparameters.transmission ? '#define USE_TRANSMISSION' : '',\n\t\t\tparameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',\n\t\t\tparameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',\n\n\t\t\tparameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',\n\t\t\tparameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',\n\n\t\t\t//\n\n\t\t\tparameters.mapUv ? '#define MAP_UV ' + parameters.mapUv : '',\n\t\t\tparameters.alphaMapUv ? '#define ALPHAMAP_UV ' + parameters.alphaMapUv : '',\n\t\t\tparameters.lightMapUv ? '#define LIGHTMAP_UV ' + parameters.lightMapUv : '',\n\t\t\tparameters.aoMapUv ? '#define AOMAP_UV ' + parameters.aoMapUv : '',\n\t\t\tparameters.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + parameters.emissiveMapUv : '',\n\t\t\tparameters.bumpMapUv ? '#define BUMPMAP_UV ' + parameters.bumpMapUv : '',\n\t\t\tparameters.normalMapUv ? '#define NORMALMAP_UV ' + parameters.normalMapUv : '',\n\t\t\tparameters.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + parameters.displacementMapUv : '',\n\n\t\t\tparameters.metalnessMapUv ? '#define METALNESSMAP_UV ' + parameters.metalnessMapUv : '',\n\t\t\tparameters.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + parameters.roughnessMapUv : '',\n\n\t\t\tparameters.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + parameters.anisotropyMapUv : '',\n\n\t\t\tparameters.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + parameters.clearcoatMapUv : '',\n\t\t\tparameters.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + parameters.clearcoatNormalMapUv : '',\n\t\t\tparameters.clearcoatRoughnessMapUv ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + parameters.clearcoatRoughnessMapUv : '',\n\n\t\t\tparameters.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + parameters.iridescenceMapUv : '',\n\t\t\tparameters.iridescenceThicknessMapUv ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + parameters.iridescenceThicknessMapUv : '',\n\n\t\t\tparameters.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + parameters.sheenColorMapUv : '',\n\t\t\tparameters.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + parameters.sheenRoughnessMapUv : '',\n\n\t\t\tparameters.specularMapUv ? '#define SPECULARMAP_UV ' + parameters.specularMapUv : '',\n\t\t\tparameters.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + parameters.specularColorMapUv : '',\n\t\t\tparameters.specularIntensityMapUv ? '#define SPECULAR_INTENSITYMAP_UV ' + parameters.specularIntensityMapUv : '',\n\n\t\t\tparameters.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + parameters.transmissionMapUv : '',\n\t\t\tparameters.thicknessMapUv ? '#define THICKNESSMAP_UV ' + parameters.thicknessMapUv : '',\n\n\t\t\t//\n\n\t\t\tparameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',\n\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\t\t\tparameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',\n\t\t\tparameters.vertexUv1s ? '#define USE_UV1' : '',\n\t\t\tparameters.vertexUv2s ? '#define USE_UV2' : '',\n\t\t\tparameters.vertexUv3s ? '#define USE_UV3' : '',\n\n\t\t\tparameters.pointsUvs ? '#define USE_POINTS_UV' : '',\n\n\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\n\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t( parameters.morphColors ) ? '#define USE_MORPHCOLORS' : '',\n\t\t\t( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',\n\t\t\t( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',\n\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\tparameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',\n\n\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\tparameters.reverseDepthBuffer ? '#define USE_REVERSEDEPTHBUF' : '',\n\n\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t'uniform vec3 cameraPosition;',\n\t\t\t'uniform bool isOrthographic;',\n\n\t\t\t'#ifdef USE_INSTANCING',\n\n\t\t\t'\tattribute mat4 instanceMatrix;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_INSTANCING_COLOR',\n\n\t\t\t'\tattribute vec3 instanceColor;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_INSTANCING_MORPH',\n\n\t\t\t'\tuniform sampler2D morphTexture;',\n\n\t\t\t'#endif',\n\n\t\t\t'attribute vec3 position;',\n\t\t\t'attribute vec3 normal;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'#ifdef USE_UV1',\n\n\t\t\t'\tattribute vec2 uv1;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_UV2',\n\n\t\t\t'\tattribute vec2 uv2;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_UV3',\n\n\t\t\t'\tattribute vec2 uv3;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_TANGENT',\n\n\t\t\t'\tattribute vec4 tangent;',\n\n\t\t\t'#endif',\n\n\t\t\t'#if defined( USE_COLOR_ALPHA )',\n\n\t\t\t'\tattribute vec4 color;',\n\n\t\t\t'#elif defined( USE_COLOR )',\n\n\t\t\t'\tattribute vec3 color;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t'#endif',\n\n\t\t\t'\\n'\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tprefixFragment = [\n\n\t\t\tgeneratePrecision( parameters ),\n\n\t\t\t'#define SHADER_TYPE ' + parameters.shaderType,\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines,\n\n\t\t\tparameters.useFog && parameters.fog ? '#define USE_FOG' : '',\n\t\t\tparameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',\n\n\t\t\tparameters.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',\n\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\tparameters.matcap ? '#define USE_MATCAP' : '',\n\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\tenvMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',\n\t\t\tenvMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',\n\t\t\tenvMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',\n\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\tparameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',\n\t\t\tparameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',\n\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\n\t\t\tparameters.anisotropy ? '#define USE_ANISOTROPY' : '',\n\t\t\tparameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',\n\n\t\t\tparameters.clearcoat ? '#define USE_CLEARCOAT' : '',\n\t\t\tparameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',\n\t\t\tparameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',\n\t\t\tparameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',\n\n\t\t\tparameters.dispersion ? '#define USE_DISPERSION' : '',\n\n\t\t\tparameters.iridescence ? '#define USE_IRIDESCENCE' : '',\n\t\t\tparameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',\n\t\t\tparameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',\n\n\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\tparameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',\n\t\t\tparameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',\n\n\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\n\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\tparameters.alphaTest ? '#define USE_ALPHATEST' : '',\n\t\t\tparameters.alphaHash ? '#define USE_ALPHAHASH' : '',\n\n\t\t\tparameters.sheen ? '#define USE_SHEEN' : '',\n\t\t\tparameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',\n\t\t\tparameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',\n\n\t\t\tparameters.transmission ? '#define USE_TRANSMISSION' : '',\n\t\t\tparameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',\n\t\t\tparameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',\n\n\t\t\tparameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',\n\t\t\tparameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? '#define USE_COLOR' : '',\n\t\t\tparameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',\n\t\t\tparameters.vertexUv1s ? '#define USE_UV1' : '',\n\t\t\tparameters.vertexUv2s ? '#define USE_UV2' : '',\n\t\t\tparameters.vertexUv3s ? '#define USE_UV3' : '',\n\n\t\t\tparameters.pointsUvs ? '#define USE_POINTS_UV' : '',\n\n\t\t\tparameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\n\n\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\tparameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',\n\n\t\t\tparameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',\n\n\t\t\tparameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',\n\t\t\tparameters.decodeVideoTextureEmissive ? '#define DECODE_VIDEO_TEXTURE_EMISSIVE' : '',\n\n\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\tparameters.reverseDepthBuffer ? '#define USE_REVERSEDEPTHBUF' : '',\n\n\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t'uniform vec3 cameraPosition;',\n\t\t\t'uniform bool isOrthographic;',\n\n\t\t\t( parameters.toneMapping !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoToneMapping ) ? '#define TONE_MAPPING' : '',\n\t\t\t( parameters.toneMapping !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t( parameters.toneMapping !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',\n\n\t\t\tparameters.dithering ? '#define DITHERING' : '',\n\t\t\tparameters.opaque ? '#define OPAQUE' : '',\n\n\t\t\tShaderChunk[ 'colorspace_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\tgetTexelEncodingFunction( 'linearToOutputTexel', parameters.outputColorSpace ),\n\t\t\tgetLuminanceFunction(),\n\n\t\t\tparameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',\n\n\t\t\t'\\n'\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tvertexShader = resolveIncludes( vertexShader );\n\tvertexShader = replaceLightNums( vertexShader, parameters );\n\tvertexShader = replaceClippingPlaneNums( vertexShader, parameters );\n\n\tfragmentShader = resolveIncludes( fragmentShader );\n\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\tfragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );\n\n\tvertexShader = unrollLoops( vertexShader );\n\tfragmentShader = unrollLoops( fragmentShader );\n\n\tif ( parameters.isRawShaderMaterial !== true ) {\n\n\t\t// GLSL 3.0 conversion for built-in materials and ShaderMaterial\n\n\t\tversionString = '#version 300 es\\n';\n\n\t\tprefixVertex = [\n\t\t\tcustomVertexExtensions,\n\t\t\t'#define attribute in',\n\t\t\t'#define varying out',\n\t\t\t'#define texture2D texture'\n\t\t].join( '\\n' ) + '\\n' + prefixVertex;\n\n\t\tprefixFragment = [\n\t\t\t'#define varying in',\n\t\t\t( parameters.glslVersion === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GLSL3 ) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',\n\t\t\t( parameters.glslVersion === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',\n\t\t\t'#define gl_FragDepthEXT gl_FragDepth',\n\t\t\t'#define texture2D texture',\n\t\t\t'#define textureCube texture',\n\t\t\t'#define texture2DProj textureProj',\n\t\t\t'#define texture2DLodEXT textureLod',\n\t\t\t'#define texture2DProjLodEXT textureProjLod',\n\t\t\t'#define textureCubeLodEXT textureLod',\n\t\t\t'#define texture2DGradEXT textureGrad',\n\t\t\t'#define texture2DProjGradEXT textureProjGrad',\n\t\t\t'#define textureCubeGradEXT textureGrad'\n\t\t].join( '\\n' ) + '\\n' + prefixFragment;\n\n\t}\n\n\tconst vertexGlsl = versionString + prefixVertex + vertexShader;\n\tconst fragmentGlsl = versionString + prefixFragment + fragmentShader;\n\n\t// console.log( '*VERTEX*', vertexGlsl );\n\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\tconst glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\tconst glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\n\tgl.attachShader( program, glVertexShader );\n\tgl.attachShader( program, glFragmentShader );\n\n\t// Force a particular attribute to index 0.\n\n\tif ( parameters.index0AttributeName !== undefined ) {\n\n\t\tgl.bindAttribLocation( program, 0, parameters.index0AttributeName );\n\n\t} else if ( parameters.morphTargets === true ) {\n\n\t\t// programs with morphTargets displace position out of attribute 0\n\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t}\n\n\tgl.linkProgram( program );\n\n\tfunction onFirstUse( self ) {\n\n\t\t// check for link errors\n\t\tif ( renderer.debug.checkShaderErrors ) {\n\n\t\t\tconst programLog = gl.getProgramInfoLog( program ).trim();\n\t\t\tconst vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();\n\t\t\tconst fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();\n\n\t\t\tlet runnable = true;\n\t\t\tlet haveDiagnostics = true;\n\n\t\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\n\t\t\t\trunnable = false;\n\n\t\t\t\tif ( typeof renderer.debug.onShaderError === 'function' ) {\n\n\t\t\t\t\trenderer.debug.onShaderError( gl, program, glVertexShader, glFragmentShader );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// default error reporting\n\n\t\t\t\t\tconst vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );\n\t\t\t\t\tconst fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );\n\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +\n\t\t\t\t\t\t'VALIDATE_STATUS ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + '\\n\\n' +\n\t\t\t\t\t\t'Material Name: ' + self.name + '\\n' +\n\t\t\t\t\t\t'Material Type: ' + self.type + '\\n\\n' +\n\t\t\t\t\t\t'Program Info Log: ' + programLog + '\\n' +\n\t\t\t\t\t\tvertexErrors + '\\n' +\n\t\t\t\t\t\tfragmentErrors\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} else if ( programLog !== '' ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );\n\n\t\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\t\thaveDiagnostics = false;\n\n\t\t\t}\n\n\t\t\tif ( haveDiagnostics ) {\n\n\t\t\t\tself.diagnostics = {\n\n\t\t\t\t\trunnable: runnable,\n\n\t\t\t\t\tprogramLog: programLog,\n\n\t\t\t\t\tvertexShader: {\n\n\t\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t\t},\n\n\t\t\t\t\tfragmentShader: {\n\n\t\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Clean up\n\n\t\t// Crashes in iOS9 and iOS10. #18402\n\t\t// gl.detachShader( program, glVertexShader );\n\t\t// gl.detachShader( program, glFragmentShader );\n\n\t\tgl.deleteShader( glVertexShader );\n\t\tgl.deleteShader( glFragmentShader );\n\n\t\tcachedUniforms = new WebGLUniforms( gl, program );\n\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t}\n\n\t// set up caching for uniform locations\n\n\tlet cachedUniforms;\n\n\tthis.getUniforms = function () {\n\n\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\t// Populates cachedUniforms and cachedAttributes\n\t\t\tonFirstUse( this );\n\n\t\t}\n\n\t\treturn cachedUniforms;\n\n\t};\n\n\t// set up caching for attribute locations\n\n\tlet cachedAttributes;\n\n\tthis.getAttributes = function () {\n\n\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\t// Populates cachedAttributes and cachedUniforms\n\t\t\tonFirstUse( this );\n\n\t\t}\n\n\t\treturn cachedAttributes;\n\n\t};\n\n\t// indicate when the program is ready to be used. if the KHR_parallel_shader_compile extension isn't supported,\n\t// flag the program as ready immediately. It may cause a stall when it's first used.\n\n\tlet programReady = ( parameters.rendererExtensionParallelShaderCompile === false );\n\n\tthis.isReady = function () {\n\n\t\tif ( programReady === false ) {\n\n\t\t\tprogramReady = gl.getProgramParameter( program, COMPLETION_STATUS_KHR );\n\n\t\t}\n\n\t\treturn programReady;\n\n\t};\n\n\t// free resource\n\n\tthis.destroy = function () {\n\n\t\tbindingStates.releaseStatesOfProgram( this );\n\n\t\tgl.deleteProgram( program );\n\t\tthis.program = undefined;\n\n\t};\n\n\t//\n\n\tthis.type = parameters.shaderType;\n\tthis.name = parameters.shaderName;\n\tthis.id = programIdCount ++;\n\tthis.cacheKey = cacheKey;\n\tthis.usedTimes = 1;\n\tthis.program = program;\n\tthis.vertexShader = glVertexShader;\n\tthis.fragmentShader = glFragmentShader;\n\n\treturn this;\n\n}\n\nlet _id = 0;\n\nclass WebGLShaderCache {\n\n\tconstructor() {\n\n\t\tthis.shaderCache = new Map();\n\t\tthis.materialCache = new Map();\n\n\t}\n\n\tupdate( material ) {\n\n\t\tconst vertexShader = material.vertexShader;\n\t\tconst fragmentShader = material.fragmentShader;\n\n\t\tconst vertexShaderStage = this._getShaderStage( vertexShader );\n\t\tconst fragmentShaderStage = this._getShaderStage( fragmentShader );\n\n\t\tconst materialShaders = this._getShaderCacheForMaterial( material );\n\n\t\tif ( materialShaders.has( vertexShaderStage ) === false ) {\n\n\t\t\tmaterialShaders.add( vertexShaderStage );\n\t\t\tvertexShaderStage.usedTimes ++;\n\n\t\t}\n\n\t\tif ( materialShaders.has( fragmentShaderStage ) === false ) {\n\n\t\t\tmaterialShaders.add( fragmentShaderStage );\n\t\t\tfragmentShaderStage.usedTimes ++;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tremove( material ) {\n\n\t\tconst materialShaders = this.materialCache.get( material );\n\n\t\tfor ( const shaderStage of materialShaders ) {\n\n\t\t\tshaderStage.usedTimes --;\n\n\t\t\tif ( shaderStage.usedTimes === 0 ) this.shaderCache.delete( shaderStage.code );\n\n\t\t}\n\n\t\tthis.materialCache.delete( material );\n\n\t\treturn this;\n\n\t}\n\n\tgetVertexShaderID( material ) {\n\n\t\treturn this._getShaderStage( material.vertexShader ).id;\n\n\t}\n\n\tgetFragmentShaderID( material ) {\n\n\t\treturn this._getShaderStage( material.fragmentShader ).id;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shaderCache.clear();\n\t\tthis.materialCache.clear();\n\n\t}\n\n\t_getShaderCacheForMaterial( material ) {\n\n\t\tconst cache = this.materialCache;\n\t\tlet set = cache.get( material );\n\n\t\tif ( set === undefined ) {\n\n\t\t\tset = new Set();\n\t\t\tcache.set( material, set );\n\n\t\t}\n\n\t\treturn set;\n\n\t}\n\n\t_getShaderStage( code ) {\n\n\t\tconst cache = this.shaderCache;\n\t\tlet stage = cache.get( code );\n\n\t\tif ( stage === undefined ) {\n\n\t\t\tstage = new WebGLShaderStage( code );\n\t\t\tcache.set( code, stage );\n\n\t\t}\n\n\t\treturn stage;\n\n\t}\n\n}\n\nclass WebGLShaderStage {\n\n\tconstructor( code ) {\n\n\t\tthis.id = _id ++;\n\n\t\tthis.code = code;\n\t\tthis.usedTimes = 0;\n\n\t}\n\n}\n\nfunction WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {\n\n\tconst _programLayers = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Layers();\n\tconst _customShaders = new WebGLShaderCache();\n\tconst _activeChannels = new Set();\n\tconst programs = [];\n\n\tconst logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;\n\tconst SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;\n\n\tlet precision = capabilities.precision;\n\n\tconst shaderIDs = {\n\t\tMeshDepthMaterial: 'depth',\n\t\tMeshDistanceMaterial: 'distanceRGBA',\n\t\tMeshNormalMaterial: 'normal',\n\t\tMeshBasicMaterial: 'basic',\n\t\tMeshLambertMaterial: 'lambert',\n\t\tMeshPhongMaterial: 'phong',\n\t\tMeshToonMaterial: 'toon',\n\t\tMeshStandardMaterial: 'physical',\n\t\tMeshPhysicalMaterial: 'physical',\n\t\tMeshMatcapMaterial: 'matcap',\n\t\tLineBasicMaterial: 'basic',\n\t\tLineDashedMaterial: 'dashed',\n\t\tPointsMaterial: 'points',\n\t\tShadowMaterial: 'shadow',\n\t\tSpriteMaterial: 'sprite'\n\t};\n\n\tfunction getChannel( value ) {\n\n\t\t_activeChannels.add( value );\n\n\t\tif ( value === 0 ) return 'uv';\n\n\t\treturn `uv${ value }`;\n\n\t}\n\n\tfunction getParameters( material, lights, shadows, scene, object ) {\n\n\t\tconst fog = scene.fog;\n\t\tconst geometry = object.geometry;\n\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\n\t\tconst envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );\n\t\tconst envMapCubeUVHeight = ( !! envMap ) && ( envMap.mapping === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CubeUVReflectionMapping ) ? envMap.image.height : null;\n\n\t\tconst shaderID = shaderIDs[ material.type ];\n\n\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t// (not to blow over maxLights budget)\n\n\t\tif ( material.precision !== null ) {\n\n\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\tlet morphTextureStride = 0;\n\n\t\tif ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;\n\t\tif ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;\n\t\tif ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3;\n\n\t\t//\n\n\t\tlet vertexShader, fragmentShader;\n\t\tlet customVertexShaderID, customFragmentShaderID;\n\n\t\tif ( shaderID ) {\n\n\t\t\tconst shader = ShaderLib[ shaderID ];\n\n\t\t\tvertexShader = shader.vertexShader;\n\t\t\tfragmentShader = shader.fragmentShader;\n\n\t\t} else {\n\n\t\t\tvertexShader = material.vertexShader;\n\t\t\tfragmentShader = material.fragmentShader;\n\n\t\t\t_customShaders.update( material );\n\n\t\t\tcustomVertexShaderID = _customShaders.getVertexShaderID( material );\n\t\t\tcustomFragmentShaderID = _customShaders.getFragmentShaderID( material );\n\n\t\t}\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst reverseDepthBuffer = renderer.state.buffers.depth.getReversed();\n\n\t\tconst IS_INSTANCEDMESH = object.isInstancedMesh === true;\n\t\tconst IS_BATCHEDMESH = object.isBatchedMesh === true;\n\n\t\tconst HAS_MAP = !! material.map;\n\t\tconst HAS_MATCAP = !! material.matcap;\n\t\tconst HAS_ENVMAP = !! envMap;\n\t\tconst HAS_AOMAP = !! material.aoMap;\n\t\tconst HAS_LIGHTMAP = !! material.lightMap;\n\t\tconst HAS_BUMPMAP = !! material.bumpMap;\n\t\tconst HAS_NORMALMAP = !! material.normalMap;\n\t\tconst HAS_DISPLACEMENTMAP = !! material.displacementMap;\n\t\tconst HAS_EMISSIVEMAP = !! material.emissiveMap;\n\n\t\tconst HAS_METALNESSMAP = !! material.metalnessMap;\n\t\tconst HAS_ROUGHNESSMAP = !! material.roughnessMap;\n\n\t\tconst HAS_ANISOTROPY = material.anisotropy > 0;\n\t\tconst HAS_CLEARCOAT = material.clearcoat > 0;\n\t\tconst HAS_DISPERSION = material.dispersion > 0;\n\t\tconst HAS_IRIDESCENCE = material.iridescence > 0;\n\t\tconst HAS_SHEEN = material.sheen > 0;\n\t\tconst HAS_TRANSMISSION = material.transmission > 0;\n\n\t\tconst HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !! material.anisotropyMap;\n\n\t\tconst HAS_CLEARCOATMAP = HAS_CLEARCOAT && !! material.clearcoatMap;\n\t\tconst HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !! material.clearcoatNormalMap;\n\t\tconst HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !! material.clearcoatRoughnessMap;\n\n\t\tconst HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !! material.iridescenceMap;\n\t\tconst HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !! material.iridescenceThicknessMap;\n\n\t\tconst HAS_SHEEN_COLORMAP = HAS_SHEEN && !! material.sheenColorMap;\n\t\tconst HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !! material.sheenRoughnessMap;\n\n\t\tconst HAS_SPECULARMAP = !! material.specularMap;\n\t\tconst HAS_SPECULAR_COLORMAP = !! material.specularColorMap;\n\t\tconst HAS_SPECULAR_INTENSITYMAP = !! material.specularIntensityMap;\n\n\t\tconst HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !! material.transmissionMap;\n\t\tconst HAS_THICKNESSMAP = HAS_TRANSMISSION && !! material.thicknessMap;\n\n\t\tconst HAS_GRADIENTMAP = !! material.gradientMap;\n\n\t\tconst HAS_ALPHAMAP = !! material.alphaMap;\n\n\t\tconst HAS_ALPHATEST = material.alphaTest > 0;\n\n\t\tconst HAS_ALPHAHASH = !! material.alphaHash;\n\n\t\tconst HAS_EXTENSIONS = !! material.extensions;\n\n\t\tlet toneMapping = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoToneMapping;\n\n\t\tif ( material.toneMapped ) {\n\n\t\t\tif ( currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true ) {\n\n\t\t\t\ttoneMapping = renderer.toneMapping;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst parameters = {\n\n\t\t\tshaderID: shaderID,\n\t\t\tshaderType: material.type,\n\t\t\tshaderName: material.name,\n\n\t\t\tvertexShader: vertexShader,\n\t\t\tfragmentShader: fragmentShader,\n\t\t\tdefines: material.defines,\n\n\t\t\tcustomVertexShaderID: customVertexShaderID,\n\t\t\tcustomFragmentShaderID: customFragmentShaderID,\n\n\t\t\tisRawShaderMaterial: material.isRawShaderMaterial === true,\n\t\t\tglslVersion: material.glslVersion,\n\n\t\t\tprecision: precision,\n\n\t\t\tbatching: IS_BATCHEDMESH,\n\t\t\tbatchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,\n\t\t\tinstancing: IS_INSTANCEDMESH,\n\t\t\tinstancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,\n\t\t\tinstancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,\n\n\t\t\tsupportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,\n\t\t\toutputColorSpace: ( currentRenderTarget === null ) ? renderer.outputColorSpace : ( currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace ),\n\t\t\talphaToCoverage: !! material.alphaToCoverage,\n\n\t\t\tmap: HAS_MAP,\n\t\t\tmatcap: HAS_MATCAP,\n\t\t\tenvMap: HAS_ENVMAP,\n\t\t\tenvMapMode: HAS_ENVMAP && envMap.mapping,\n\t\t\tenvMapCubeUVHeight: envMapCubeUVHeight,\n\t\t\taoMap: HAS_AOMAP,\n\t\t\tlightMap: HAS_LIGHTMAP,\n\t\t\tbumpMap: HAS_BUMPMAP,\n\t\t\tnormalMap: HAS_NORMALMAP,\n\t\t\tdisplacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,\n\t\t\temissiveMap: HAS_EMISSIVEMAP,\n\n\t\t\tnormalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ObjectSpaceNormalMap,\n\t\t\tnormalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.TangentSpaceNormalMap,\n\n\t\t\tmetalnessMap: HAS_METALNESSMAP,\n\t\t\troughnessMap: HAS_ROUGHNESSMAP,\n\n\t\t\tanisotropy: HAS_ANISOTROPY,\n\t\t\tanisotropyMap: HAS_ANISOTROPYMAP,\n\n\t\t\tclearcoat: HAS_CLEARCOAT,\n\t\t\tclearcoatMap: HAS_CLEARCOATMAP,\n\t\t\tclearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,\n\t\t\tclearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,\n\n\t\t\tdispersion: HAS_DISPERSION,\n\n\t\t\tiridescence: HAS_IRIDESCENCE,\n\t\t\tiridescenceMap: HAS_IRIDESCENCEMAP,\n\t\t\tiridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,\n\n\t\t\tsheen: HAS_SHEEN,\n\t\t\tsheenColorMap: HAS_SHEEN_COLORMAP,\n\t\t\tsheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,\n\n\t\t\tspecularMap: HAS_SPECULARMAP,\n\t\t\tspecularColorMap: HAS_SPECULAR_COLORMAP,\n\t\t\tspecularIntensityMap: HAS_SPECULAR_INTENSITYMAP,\n\n\t\t\ttransmission: HAS_TRANSMISSION,\n\t\t\ttransmissionMap: HAS_TRANSMISSIONMAP,\n\t\t\tthicknessMap: HAS_THICKNESSMAP,\n\n\t\t\tgradientMap: HAS_GRADIENTMAP,\n\n\t\t\topaque: material.transparent === false && material.blending === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NormalBlending && material.alphaToCoverage === false,\n\n\t\t\talphaMap: HAS_ALPHAMAP,\n\t\t\talphaTest: HAS_ALPHATEST,\n\t\t\talphaHash: HAS_ALPHAHASH,\n\n\t\t\tcombine: material.combine,\n\n\t\t\t//\n\n\t\t\tmapUv: HAS_MAP && getChannel( material.map.channel ),\n\t\t\taoMapUv: HAS_AOMAP && getChannel( material.aoMap.channel ),\n\t\t\tlightMapUv: HAS_LIGHTMAP && getChannel( material.lightMap.channel ),\n\t\t\tbumpMapUv: HAS_BUMPMAP && getChannel( material.bumpMap.channel ),\n\t\t\tnormalMapUv: HAS_NORMALMAP && getChannel( material.normalMap.channel ),\n\t\t\tdisplacementMapUv: HAS_DISPLACEMENTMAP && getChannel( material.displacementMap.channel ),\n\t\t\temissiveMapUv: HAS_EMISSIVEMAP && getChannel( material.emissiveMap.channel ),\n\n\t\t\tmetalnessMapUv: HAS_METALNESSMAP && getChannel( material.metalnessMap.channel ),\n\t\t\troughnessMapUv: HAS_ROUGHNESSMAP && getChannel( material.roughnessMap.channel ),\n\n\t\t\tanisotropyMapUv: HAS_ANISOTROPYMAP && getChannel( material.anisotropyMap.channel ),\n\n\t\t\tclearcoatMapUv: HAS_CLEARCOATMAP && getChannel( material.clearcoatMap.channel ),\n\t\t\tclearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel( material.clearcoatNormalMap.channel ),\n\t\t\tclearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel( material.clearcoatRoughnessMap.channel ),\n\n\t\t\tiridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel( material.iridescenceMap.channel ),\n\t\t\tiridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel( material.iridescenceThicknessMap.channel ),\n\n\t\t\tsheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel( material.sheenColorMap.channel ),\n\t\t\tsheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel( material.sheenRoughnessMap.channel ),\n\n\t\t\tspecularMapUv: HAS_SPECULARMAP && getChannel( material.specularMap.channel ),\n\t\t\tspecularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel( material.specularColorMap.channel ),\n\t\t\tspecularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel( material.specularIntensityMap.channel ),\n\n\t\t\ttransmissionMapUv: HAS_TRANSMISSIONMAP && getChannel( material.transmissionMap.channel ),\n\t\t\tthicknessMapUv: HAS_THICKNESSMAP && getChannel( material.thicknessMap.channel ),\n\n\t\t\talphaMapUv: HAS_ALPHAMAP && getChannel( material.alphaMap.channel ),\n\n\t\t\t//\n\n\t\t\tvertexTangents: !! geometry.attributes.tangent && ( HAS_NORMALMAP || HAS_ANISOTROPY ),\n\t\t\tvertexColors: material.vertexColors,\n\t\t\tvertexAlphas: material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4,\n\n\t\t\tpointsUvs: object.isPoints === true && !! geometry.attributes.uv && ( HAS_MAP || HAS_ALPHAMAP ),\n\n\t\t\tfog: !! fog,\n\t\t\tuseFog: material.fog === true,\n\t\t\tfogExp2: ( !! fog && fog.isFogExp2 ),\n\n\t\t\tflatShading: material.flatShading === true,\n\n\t\t\tsizeAttenuation: material.sizeAttenuation === true,\n\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\t\t\treverseDepthBuffer: reverseDepthBuffer,\n\n\t\t\tskinning: object.isSkinnedMesh === true,\n\n\t\t\tmorphTargets: geometry.morphAttributes.position !== undefined,\n\t\t\tmorphNormals: geometry.morphAttributes.normal !== undefined,\n\t\t\tmorphColors: geometry.morphAttributes.color !== undefined,\n\t\t\tmorphTargetsCount: morphTargetsCount,\n\t\t\tmorphTextureStride: morphTextureStride,\n\n\t\t\tnumDirLights: lights.directional.length,\n\t\t\tnumPointLights: lights.point.length,\n\t\t\tnumSpotLights: lights.spot.length,\n\t\t\tnumSpotLightMaps: lights.spotLightMap.length,\n\t\t\tnumRectAreaLights: lights.rectArea.length,\n\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\tnumDirLightShadows: lights.directionalShadowMap.length,\n\t\t\tnumPointLightShadows: lights.pointShadowMap.length,\n\t\t\tnumSpotLightShadows: lights.spotShadowMap.length,\n\t\t\tnumSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,\n\n\t\t\tnumLightProbes: lights.numLightProbes,\n\n\t\t\tnumClippingPlanes: clipping.numPlanes,\n\t\t\tnumClipIntersection: clipping.numIntersection,\n\n\t\t\tdithering: material.dithering,\n\n\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,\n\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\ttoneMapping: toneMapping,\n\n\t\t\tdecodeVideoTexture: HAS_MAP && ( material.map.isVideoTexture === true ) && ( _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.getTransfer( material.map.colorSpace ) === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ),\n\t\t\tdecodeVideoTextureEmissive: HAS_EMISSIVEMAP && ( material.emissiveMap.isVideoTexture === true ) && ( _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.getTransfer( material.emissiveMap.colorSpace ) === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ),\n\n\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\tdoubleSided: material.side === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,\n\t\t\tflipSided: material.side === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BackSide,\n\n\t\t\tuseDepthPacking: material.depthPacking >= 0,\n\t\t\tdepthPacking: material.depthPacking || 0,\n\n\t\t\tindex0AttributeName: material.index0AttributeName,\n\n\t\t\textensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has( 'WEBGL_clip_cull_distance' ),\n\t\t\textensionMultiDraw: ( HAS_EXTENSIONS && material.extensions.multiDraw === true || IS_BATCHEDMESH ) && extensions.has( 'WEBGL_multi_draw' ),\n\n\t\t\trendererExtensionParallelShaderCompile: extensions.has( 'KHR_parallel_shader_compile' ),\n\n\t\t\tcustomProgramCacheKey: material.customProgramCacheKey()\n\n\t\t};\n\n\t\t// the usage of getChannel() determines the active texture channels for this shader\n\n\t\tparameters.vertexUv1s = _activeChannels.has( 1 );\n\t\tparameters.vertexUv2s = _activeChannels.has( 2 );\n\t\tparameters.vertexUv3s = _activeChannels.has( 3 );\n\n\t\t_activeChannels.clear();\n\n\t\treturn parameters;\n\n\t}\n\n\tfunction getProgramCacheKey( parameters ) {\n\n\t\tconst array = [];\n\n\t\tif ( parameters.shaderID ) {\n\n\t\t\tarray.push( parameters.shaderID );\n\n\t\t} else {\n\n\t\t\tarray.push( parameters.customVertexShaderID );\n\t\t\tarray.push( parameters.customFragmentShaderID );\n\n\t\t}\n\n\t\tif ( parameters.defines !== undefined ) {\n\n\t\t\tfor ( const name in parameters.defines ) {\n\n\t\t\t\tarray.push( name );\n\t\t\t\tarray.push( parameters.defines[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parameters.isRawShaderMaterial === false ) {\n\n\t\t\tgetProgramCacheKeyParameters( array, parameters );\n\t\t\tgetProgramCacheKeyBooleans( array, parameters );\n\t\t\tarray.push( renderer.outputColorSpace );\n\n\t\t}\n\n\t\tarray.push( parameters.customProgramCacheKey );\n\n\t\treturn array.join();\n\n\t}\n\n\tfunction getProgramCacheKeyParameters( array, parameters ) {\n\n\t\tarray.push( parameters.precision );\n\t\tarray.push( parameters.outputColorSpace );\n\t\tarray.push( parameters.envMapMode );\n\t\tarray.push( parameters.envMapCubeUVHeight );\n\t\tarray.push( parameters.mapUv );\n\t\tarray.push( parameters.alphaMapUv );\n\t\tarray.push( parameters.lightMapUv );\n\t\tarray.push( parameters.aoMapUv );\n\t\tarray.push( parameters.bumpMapUv );\n\t\tarray.push( parameters.normalMapUv );\n\t\tarray.push( parameters.displacementMapUv );\n\t\tarray.push( parameters.emissiveMapUv );\n\t\tarray.push( parameters.metalnessMapUv );\n\t\tarray.push( parameters.roughnessMapUv );\n\t\tarray.push( parameters.anisotropyMapUv );\n\t\tarray.push( parameters.clearcoatMapUv );\n\t\tarray.push( parameters.clearcoatNormalMapUv );\n\t\tarray.push( parameters.clearcoatRoughnessMapUv );\n\t\tarray.push( parameters.iridescenceMapUv );\n\t\tarray.push( parameters.iridescenceThicknessMapUv );\n\t\tarray.push( parameters.sheenColorMapUv );\n\t\tarray.push( parameters.sheenRoughnessMapUv );\n\t\tarray.push( parameters.specularMapUv );\n\t\tarray.push( parameters.specularColorMapUv );\n\t\tarray.push( parameters.specularIntensityMapUv );\n\t\tarray.push( parameters.transmissionMapUv );\n\t\tarray.push( parameters.thicknessMapUv );\n\t\tarray.push( parameters.combine );\n\t\tarray.push( parameters.fogExp2 );\n\t\tarray.push( parameters.sizeAttenuation );\n\t\tarray.push( parameters.morphTargetsCount );\n\t\tarray.push( parameters.morphAttributeCount );\n\t\tarray.push( parameters.numDirLights );\n\t\tarray.push( parameters.numPointLights );\n\t\tarray.push( parameters.numSpotLights );\n\t\tarray.push( parameters.numSpotLightMaps );\n\t\tarray.push( parameters.numHemiLights );\n\t\tarray.push( parameters.numRectAreaLights );\n\t\tarray.push( parameters.numDirLightShadows );\n\t\tarray.push( parameters.numPointLightShadows );\n\t\tarray.push( parameters.numSpotLightShadows );\n\t\tarray.push( parameters.numSpotLightShadowsWithMaps );\n\t\tarray.push( parameters.numLightProbes );\n\t\tarray.push( parameters.shadowMapType );\n\t\tarray.push( parameters.toneMapping );\n\t\tarray.push( parameters.numClippingPlanes );\n\t\tarray.push( parameters.numClipIntersection );\n\t\tarray.push( parameters.depthPacking );\n\n\t}\n\n\tfunction getProgramCacheKeyBooleans( array, parameters ) {\n\n\t\t_programLayers.disableAll();\n\n\t\tif ( parameters.supportsVertexTextures )\n\t\t\t_programLayers.enable( 0 );\n\t\tif ( parameters.instancing )\n\t\t\t_programLayers.enable( 1 );\n\t\tif ( parameters.instancingColor )\n\t\t\t_programLayers.enable( 2 );\n\t\tif ( parameters.instancingMorph )\n\t\t\t_programLayers.enable( 3 );\n\t\tif ( parameters.matcap )\n\t\t\t_programLayers.enable( 4 );\n\t\tif ( parameters.envMap )\n\t\t\t_programLayers.enable( 5 );\n\t\tif ( parameters.normalMapObjectSpace )\n\t\t\t_programLayers.enable( 6 );\n\t\tif ( parameters.normalMapTangentSpace )\n\t\t\t_programLayers.enable( 7 );\n\t\tif ( parameters.clearcoat )\n\t\t\t_programLayers.enable( 8 );\n\t\tif ( parameters.iridescence )\n\t\t\t_programLayers.enable( 9 );\n\t\tif ( parameters.alphaTest )\n\t\t\t_programLayers.enable( 10 );\n\t\tif ( parameters.vertexColors )\n\t\t\t_programLayers.enable( 11 );\n\t\tif ( parameters.vertexAlphas )\n\t\t\t_programLayers.enable( 12 );\n\t\tif ( parameters.vertexUv1s )\n\t\t\t_programLayers.enable( 13 );\n\t\tif ( parameters.vertexUv2s )\n\t\t\t_programLayers.enable( 14 );\n\t\tif ( parameters.vertexUv3s )\n\t\t\t_programLayers.enable( 15 );\n\t\tif ( parameters.vertexTangents )\n\t\t\t_programLayers.enable( 16 );\n\t\tif ( parameters.anisotropy )\n\t\t\t_programLayers.enable( 17 );\n\t\tif ( parameters.alphaHash )\n\t\t\t_programLayers.enable( 18 );\n\t\tif ( parameters.batching )\n\t\t\t_programLayers.enable( 19 );\n\t\tif ( parameters.dispersion )\n\t\t\t_programLayers.enable( 20 );\n\t\tif ( parameters.batchingColor )\n\t\t\t_programLayers.enable( 21 );\n\n\t\tarray.push( _programLayers.mask );\n\t\t_programLayers.disableAll();\n\n\t\tif ( parameters.fog )\n\t\t\t_programLayers.enable( 0 );\n\t\tif ( parameters.useFog )\n\t\t\t_programLayers.enable( 1 );\n\t\tif ( parameters.flatShading )\n\t\t\t_programLayers.enable( 2 );\n\t\tif ( parameters.logarithmicDepthBuffer )\n\t\t\t_programLayers.enable( 3 );\n\t\tif ( parameters.reverseDepthBuffer )\n\t\t\t_programLayers.enable( 4 );\n\t\tif ( parameters.skinning )\n\t\t\t_programLayers.enable( 5 );\n\t\tif ( parameters.morphTargets )\n\t\t\t_programLayers.enable( 6 );\n\t\tif ( parameters.morphNormals )\n\t\t\t_programLayers.enable( 7 );\n\t\tif ( parameters.morphColors )\n\t\t\t_programLayers.enable( 8 );\n\t\tif ( parameters.premultipliedAlpha )\n\t\t\t_programLayers.enable( 9 );\n\t\tif ( parameters.shadowMapEnabled )\n\t\t\t_programLayers.enable( 10 );\n\t\tif ( parameters.doubleSided )\n\t\t\t_programLayers.enable( 11 );\n\t\tif ( parameters.flipSided )\n\t\t\t_programLayers.enable( 12 );\n\t\tif ( parameters.useDepthPacking )\n\t\t\t_programLayers.enable( 13 );\n\t\tif ( parameters.dithering )\n\t\t\t_programLayers.enable( 14 );\n\t\tif ( parameters.transmission )\n\t\t\t_programLayers.enable( 15 );\n\t\tif ( parameters.sheen )\n\t\t\t_programLayers.enable( 16 );\n\t\tif ( parameters.opaque )\n\t\t\t_programLayers.enable( 17 );\n\t\tif ( parameters.pointsUvs )\n\t\t\t_programLayers.enable( 18 );\n\t\tif ( parameters.decodeVideoTexture )\n\t\t\t_programLayers.enable( 19 );\n\t\tif ( parameters.decodeVideoTextureEmissive )\n\t\t\t_programLayers.enable( 20 );\n\t\tif ( parameters.alphaToCoverage )\n\t\t\t_programLayers.enable( 21 );\n\n\t\tarray.push( _programLayers.mask );\n\n\t}\n\n\tfunction getUniforms( material ) {\n\n\t\tconst shaderID = shaderIDs[ material.type ];\n\t\tlet uniforms;\n\n\t\tif ( shaderID ) {\n\n\t\t\tconst shader = ShaderLib[ shaderID ];\n\t\t\tuniforms = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.clone( shader.uniforms );\n\n\t\t} else {\n\n\t\t\tuniforms = material.uniforms;\n\n\t\t}\n\n\t\treturn uniforms;\n\n\t}\n\n\tfunction acquireProgram( parameters, cacheKey ) {\n\n\t\tlet program;\n\n\t\t// Check if code has been already compiled\n\t\tfor ( let p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\tconst preexistingProgram = programs[ p ];\n\n\t\t\tif ( preexistingProgram.cacheKey === cacheKey ) {\n\n\t\t\t\tprogram = preexistingProgram;\n\t\t\t\t++ program.usedTimes;\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( program === undefined ) {\n\n\t\t\tprogram = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );\n\t\t\tprograms.push( program );\n\n\t\t}\n\n\t\treturn program;\n\n\t}\n\n\tfunction releaseProgram( program ) {\n\n\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t// Remove from unordered set\n\t\t\tconst i = programs.indexOf( program );\n\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\tprograms.pop();\n\n\t\t\t// Free WebGL resources\n\t\t\tprogram.destroy();\n\n\t\t}\n\n\t}\n\n\tfunction releaseShaderCache( material ) {\n\n\t\t_customShaders.remove( material );\n\n\t}\n\n\tfunction dispose() {\n\n\t\t_customShaders.dispose();\n\n\t}\n\n\treturn {\n\t\tgetParameters: getParameters,\n\t\tgetProgramCacheKey: getProgramCacheKey,\n\t\tgetUniforms: getUniforms,\n\t\tacquireProgram: acquireProgram,\n\t\treleaseProgram: releaseProgram,\n\t\treleaseShaderCache: releaseShaderCache,\n\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\tprograms: programs,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction WebGLProperties() {\n\n\tlet properties = new WeakMap();\n\n\tfunction has( object ) {\n\n\t\treturn properties.has( object );\n\n\t}\n\n\tfunction get( object ) {\n\n\t\tlet map = properties.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tproperties.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\tfunction remove( object ) {\n\n\t\tproperties.delete( object );\n\n\t}\n\n\tfunction update( object, key, value ) {\n\n\t\tproperties.get( object )[ key ] = value;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tproperties = new WeakMap();\n\n\t}\n\n\treturn {\n\t\thas: has,\n\t\tget: get,\n\t\tremove: remove,\n\t\tupdate: update,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction painterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.material.id !== b.material.id ) {\n\n\t\treturn a.material.id - b.material.id;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn a.z - b.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\nfunction reversePainterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn b.z - a.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\n\nfunction WebGLRenderList() {\n\n\tconst renderItems = [];\n\tlet renderItemsIndex = 0;\n\n\tconst opaque = [];\n\tconst transmissive = [];\n\tconst transparent = [];\n\n\tfunction init() {\n\n\t\trenderItemsIndex = 0;\n\n\t\topaque.length = 0;\n\t\ttransmissive.length = 0;\n\t\ttransparent.length = 0;\n\n\t}\n\n\tfunction getNextRenderItem( object, geometry, material, groupOrder, z, group ) {\n\n\t\tlet renderItem = renderItems[ renderItemsIndex ];\n\n\t\tif ( renderItem === undefined ) {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tgroupOrder: groupOrder,\n\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t\tz: z,\n\t\t\t\tgroup: group\n\t\t\t};\n\n\t\t\trenderItems[ renderItemsIndex ] = renderItem;\n\n\t\t} else {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.groupOrder = groupOrder;\n\t\t\trenderItem.renderOrder = object.renderOrder;\n\t\t\trenderItem.z = z;\n\t\t\trenderItem.group = group;\n\n\t\t}\n\n\t\trenderItemsIndex ++;\n\n\t\treturn renderItem;\n\n\t}\n\n\tfunction push( object, geometry, material, groupOrder, z, group ) {\n\n\t\tconst renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );\n\n\t\tif ( material.transmission > 0.0 ) {\n\n\t\t\ttransmissive.push( renderItem );\n\n\t\t} else if ( material.transparent === true ) {\n\n\t\t\ttransparent.push( renderItem );\n\n\t\t} else {\n\n\t\t\topaque.push( renderItem );\n\n\t\t}\n\n\t}\n\n\tfunction unshift( object, geometry, material, groupOrder, z, group ) {\n\n\t\tconst renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );\n\n\t\tif ( material.transmission > 0.0 ) {\n\n\t\t\ttransmissive.unshift( renderItem );\n\n\t\t} else if ( material.transparent === true ) {\n\n\t\t\ttransparent.unshift( renderItem );\n\n\t\t} else {\n\n\t\t\topaque.unshift( renderItem );\n\n\t\t}\n\n\t}\n\n\tfunction sort( customOpaqueSort, customTransparentSort ) {\n\n\t\tif ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );\n\t\tif ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );\n\t\tif ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );\n\n\t}\n\n\tfunction finish() {\n\n\t\t// Clear references from inactive renderItems in the list\n\n\t\tfor ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {\n\n\t\t\tconst renderItem = renderItems[ i ];\n\n\t\t\tif ( renderItem.id === null ) break;\n\n\t\t\trenderItem.id = null;\n\t\t\trenderItem.object = null;\n\t\t\trenderItem.geometry = null;\n\t\t\trenderItem.material = null;\n\t\t\trenderItem.group = null;\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\topaque: opaque,\n\t\ttransmissive: transmissive,\n\t\ttransparent: transparent,\n\n\t\tinit: init,\n\t\tpush: push,\n\t\tunshift: unshift,\n\t\tfinish: finish,\n\n\t\tsort: sort\n\t};\n\n}\n\nfunction WebGLRenderLists() {\n\n\tlet lists = new WeakMap();\n\n\tfunction get( scene, renderCallDepth ) {\n\n\t\tconst listArray = lists.get( scene );\n\t\tlet list;\n\n\t\tif ( listArray === undefined ) {\n\n\t\t\tlist = new WebGLRenderList();\n\t\t\tlists.set( scene, [ list ] );\n\n\t\t} else {\n\n\t\t\tif ( renderCallDepth >= listArray.length ) {\n\n\t\t\t\tlist = new WebGLRenderList();\n\t\t\t\tlistArray.push( list );\n\n\t\t\t} else {\n\n\t\t\t\tlist = listArray[ renderCallDepth ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn list;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tlists = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction UniformsCache() {\n\n\tconst lights = {};\n\n\treturn {\n\n\t\tget: function ( light ) {\n\n\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\treturn lights[ light.id ];\n\n\t\t\t}\n\n\t\t\tlet uniforms;\n\n\t\t\tswitch ( light.type ) {\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n\t\t\t\t\t\tcolor: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n\t\t\t\t\t\tdirection: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n\t\t\t\t\t\tcolor: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n\t\t\t\t\t\tcolor: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n\t\t\t\t\t\tskyColor: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color(),\n\t\t\t\t\t\tgroundColor: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RectAreaLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tcolor: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color(),\n\t\t\t\t\t\tposition: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n\t\t\t\t\t\thalfWidth: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n\t\t\t\t\t\thalfHeight: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\treturn uniforms;\n\n\t\t}\n\n\t};\n\n}\n\nfunction ShadowUniformsCache() {\n\n\tconst lights = {};\n\n\treturn {\n\n\t\tget: function ( light ) {\n\n\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\treturn lights[ light.id ];\n\n\t\t\t}\n\n\t\t\tlet uniforms;\n\n\t\t\tswitch ( light.type ) {\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowIntensity: 1,\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowIntensity: 1,\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowIntensity: 1,\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector2(),\n\t\t\t\t\t\tshadowCameraNear: 1,\n\t\t\t\t\t\tshadowCameraFar: 1000\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\t// TODO (abelnation): set RectAreaLight shadow uniforms\n\n\t\t\t}\n\n\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\treturn uniforms;\n\n\t\t}\n\n\t};\n\n}\n\n\n\nlet nextVersion = 0;\n\nfunction shadowCastingAndTexturingLightsFirst( lightA, lightB ) {\n\n\treturn ( lightB.castShadow ? 2 : 0 ) - ( lightA.castShadow ? 2 : 0 ) + ( lightB.map ? 1 : 0 ) - ( lightA.map ? 1 : 0 );\n\n}\n\nfunction WebGLLights( extensions ) {\n\n\tconst cache = new UniformsCache();\n\n\tconst shadowCache = ShadowUniformsCache();\n\n\tconst state = {\n\n\t\tversion: 0,\n\n\t\thash: {\n\t\t\tdirectionalLength: - 1,\n\t\t\tpointLength: - 1,\n\t\t\tspotLength: - 1,\n\t\t\trectAreaLength: - 1,\n\t\t\themiLength: - 1,\n\n\t\t\tnumDirectionalShadows: - 1,\n\t\t\tnumPointShadows: - 1,\n\t\t\tnumSpotShadows: - 1,\n\t\t\tnumSpotMaps: - 1,\n\n\t\t\tnumLightProbes: - 1\n\t\t},\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tprobe: [],\n\t\tdirectional: [],\n\t\tdirectionalShadow: [],\n\t\tdirectionalShadowMap: [],\n\t\tdirectionalShadowMatrix: [],\n\t\tspot: [],\n\t\tspotLightMap: [],\n\t\tspotShadow: [],\n\t\tspotShadowMap: [],\n\t\tspotLightMatrix: [],\n\t\trectArea: [],\n\t\trectAreaLTC1: null,\n\t\trectAreaLTC2: null,\n\t\tpoint: [],\n\t\tpointShadow: [],\n\t\tpointShadowMap: [],\n\t\tpointShadowMatrix: [],\n\t\themi: [],\n\t\tnumSpotLightShadowsWithMaps: 0,\n\t\tnumLightProbes: 0\n\n\t};\n\n\tfor ( let i = 0; i < 9; i ++ ) state.probe.push( new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3() );\n\n\tconst vector3 = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\tconst matrix4 = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\tconst matrix42 = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\n\tfunction setup( lights ) {\n\n\t\tlet r = 0, g = 0, b = 0;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );\n\n\t\tlet directionalLength = 0;\n\t\tlet pointLength = 0;\n\t\tlet spotLength = 0;\n\t\tlet rectAreaLength = 0;\n\t\tlet hemiLength = 0;\n\n\t\tlet numDirectionalShadows = 0;\n\t\tlet numPointShadows = 0;\n\t\tlet numSpotShadows = 0;\n\t\tlet numSpotMaps = 0;\n\t\tlet numSpotShadowsWithMaps = 0;\n\n\t\tlet numLightProbes = 0;\n\n\t\t// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]\n\t\tlights.sort( shadowCastingAndTexturingLightsFirst );\n\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\n\t\t\tconst color = light.color;\n\t\t\tconst intensity = light.intensity;\n\t\t\tconst distance = light.distance;\n\n\t\t\tconst shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\tif ( light.isAmbientLight ) {\n\n\t\t\t\tr += color.r * intensity;\n\t\t\t\tg += color.g * intensity;\n\t\t\t\tb += color.b * intensity;\n\n\t\t\t} else if ( light.isLightProbe ) {\n\n\t\t\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\t\t\tstate.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );\n\n\t\t\t\t}\n\n\t\t\t\tnumLightProbes ++;\n\n\t\t\t} else if ( light.isDirectionalLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowIntensity = shadow.intensity;\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t\tstate.directionalShadow[ directionalLength ] = shadowUniforms;\n\t\t\t\t\tstate.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\tstate.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\n\t\t\t\t\tnumDirectionalShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.directional[ directionalLength ] = uniforms;\n\n\t\t\t\tdirectionalLength ++;\n\n\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\tstate.spot[ spotLength ] = uniforms;\n\n\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\tif ( light.map ) {\n\n\t\t\t\t\tstate.spotLightMap[ numSpotMaps ] = light.map;\n\t\t\t\t\tnumSpotMaps ++;\n\n\t\t\t\t\t// make sure the lightMatrix is up to date\n\t\t\t\t\t// TODO : do it if required only\n\t\t\t\t\tshadow.updateMatrices( light );\n\n\t\t\t\t\tif ( light.castShadow ) numSpotShadowsWithMaps ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.spotLightMatrix[ spotLength ] = shadow.matrix;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowIntensity = shadow.intensity;\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t\tstate.spotShadow[ spotLength ] = shadowUniforms;\n\t\t\t\t\tstate.spotShadowMap[ spotLength ] = shadowMap;\n\n\t\t\t\t\tnumSpotShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tspotLength ++;\n\n\t\t\t} else if ( light.isRectAreaLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\t\t\tstate.rectArea[ rectAreaLength ] = uniforms;\n\n\t\t\t\trectAreaLength ++;\n\n\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowIntensity = shadow.intensity;\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\tshadowUniforms.shadowCameraNear = shadow.camera.near;\n\t\t\t\t\tshadowUniforms.shadowCameraFar = shadow.camera.far;\n\n\t\t\t\t\tstate.pointShadow[ pointLength ] = shadowUniforms;\n\t\t\t\t\tstate.pointShadowMap[ pointLength ] = shadowMap;\n\t\t\t\t\tstate.pointShadowMatrix[ pointLength ] = light.shadow.matrix;\n\n\t\t\t\t\tnumPointShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.point[ pointLength ] = uniforms;\n\n\t\t\t\tpointLength ++;\n\n\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n\t\t\t\tstate.hemi[ hemiLength ] = uniforms;\n\n\t\t\t\themiLength ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( rectAreaLength > 0 ) {\n\n\t\t\tif ( extensions.has( 'OES_texture_float_linear' ) === true ) {\n\n\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n\n\t\t\t} else {\n\n\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\n\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.ambient[ 0 ] = r;\n\t\tstate.ambient[ 1 ] = g;\n\t\tstate.ambient[ 2 ] = b;\n\n\t\tconst hash = state.hash;\n\n\t\tif ( hash.directionalLength !== directionalLength ||\n\t\t\thash.pointLength !== pointLength ||\n\t\t\thash.spotLength !== spotLength ||\n\t\t\thash.rectAreaLength !== rectAreaLength ||\n\t\t\thash.hemiLength !== hemiLength ||\n\t\t\thash.numDirectionalShadows !== numDirectionalShadows ||\n\t\t\thash.numPointShadows !== numPointShadows ||\n\t\t\thash.numSpotShadows !== numSpotShadows ||\n\t\t\thash.numSpotMaps !== numSpotMaps ||\n\t\t\thash.numLightProbes !== numLightProbes ) {\n\n\t\t\tstate.directional.length = directionalLength;\n\t\t\tstate.spot.length = spotLength;\n\t\t\tstate.rectArea.length = rectAreaLength;\n\t\t\tstate.point.length = pointLength;\n\t\t\tstate.hemi.length = hemiLength;\n\n\t\t\tstate.directionalShadow.length = numDirectionalShadows;\n\t\t\tstate.directionalShadowMap.length = numDirectionalShadows;\n\t\t\tstate.pointShadow.length = numPointShadows;\n\t\t\tstate.pointShadowMap.length = numPointShadows;\n\t\t\tstate.spotShadow.length = numSpotShadows;\n\t\t\tstate.spotShadowMap.length = numSpotShadows;\n\t\t\tstate.directionalShadowMatrix.length = numDirectionalShadows;\n\t\t\tstate.pointShadowMatrix.length = numPointShadows;\n\t\t\tstate.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;\n\t\t\tstate.spotLightMap.length = numSpotMaps;\n\t\t\tstate.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;\n\t\t\tstate.numLightProbes = numLightProbes;\n\n\t\t\thash.directionalLength = directionalLength;\n\t\t\thash.pointLength = pointLength;\n\t\t\thash.spotLength = spotLength;\n\t\t\thash.rectAreaLength = rectAreaLength;\n\t\t\thash.hemiLength = hemiLength;\n\n\t\t\thash.numDirectionalShadows = numDirectionalShadows;\n\t\t\thash.numPointShadows = numPointShadows;\n\t\t\thash.numSpotShadows = numSpotShadows;\n\t\t\thash.numSpotMaps = numSpotMaps;\n\n\t\t\thash.numLightProbes = numLightProbes;\n\n\t\t\tstate.version = nextVersion ++;\n\n\t\t}\n\n\t}\n\n\tfunction setupView( lights, camera ) {\n\n\t\tlet directionalLength = 0;\n\t\tlet pointLength = 0;\n\t\tlet spotLength = 0;\n\t\tlet rectAreaLength = 0;\n\t\tlet hemiLength = 0;\n\n\t\tconst viewMatrix = camera.matrixWorldInverse;\n\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\n\t\t\tif ( light.isDirectionalLight ) {\n\n\t\t\t\tconst uniforms = state.directional[ directionalLength ];\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tdirectionalLength ++;\n\n\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\tconst uniforms = state.spot[ spotLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tspotLength ++;\n\n\t\t\t} else if ( light.isRectAreaLight ) {\n\n\t\t\t\tconst uniforms = state.rectArea[ rectAreaLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t// extract local rotation of light to derive width/height half vectors\n\t\t\t\tmatrix42.identity();\n\t\t\t\tmatrix4.copy( light.matrixWorld );\n\t\t\t\tmatrix4.premultiply( viewMatrix );\n\t\t\t\tmatrix42.extractRotation( matrix4 );\n\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\t\t\tuniforms.halfWidth.applyMatrix4( matrix42 );\n\t\t\t\tuniforms.halfHeight.applyMatrix4( matrix42 );\n\n\t\t\t\trectAreaLength ++;\n\n\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\tconst uniforms = state.point[ pointLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tpointLength ++;\n\n\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\tconst uniforms = state.hemi[ hemiLength ];\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\themiLength ++;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tsetup: setup,\n\t\tsetupView: setupView,\n\t\tstate: state\n\t};\n\n}\n\nfunction WebGLRenderState( extensions ) {\n\n\tconst lights = new WebGLLights( extensions );\n\n\tconst lightsArray = [];\n\tconst shadowsArray = [];\n\n\tfunction init( camera ) {\n\n\t\tstate.camera = camera;\n\n\t\tlightsArray.length = 0;\n\t\tshadowsArray.length = 0;\n\n\t}\n\n\tfunction pushLight( light ) {\n\n\t\tlightsArray.push( light );\n\n\t}\n\n\tfunction pushShadow( shadowLight ) {\n\n\t\tshadowsArray.push( shadowLight );\n\n\t}\n\n\tfunction setupLights() {\n\n\t\tlights.setup( lightsArray );\n\n\t}\n\n\tfunction setupLightsView( camera ) {\n\n\t\tlights.setupView( lightsArray, camera );\n\n\t}\n\n\tconst state = {\n\t\tlightsArray: lightsArray,\n\t\tshadowsArray: shadowsArray,\n\n\t\tcamera: null,\n\n\t\tlights: lights,\n\n\t\ttransmissionRenderTarget: {}\n\t};\n\n\treturn {\n\t\tinit: init,\n\t\tstate: state,\n\t\tsetupLights: setupLights,\n\t\tsetupLightsView: setupLightsView,\n\n\t\tpushLight: pushLight,\n\t\tpushShadow: pushShadow\n\t};\n\n}\n\nfunction WebGLRenderStates( extensions ) {\n\n\tlet renderStates = new WeakMap();\n\n\tfunction get( scene, renderCallDepth = 0 ) {\n\n\t\tconst renderStateArray = renderStates.get( scene );\n\t\tlet renderState;\n\n\t\tif ( renderStateArray === undefined ) {\n\n\t\t\trenderState = new WebGLRenderState( extensions );\n\t\t\trenderStates.set( scene, [ renderState ] );\n\n\t\t} else {\n\n\t\t\tif ( renderCallDepth >= renderStateArray.length ) {\n\n\t\t\t\trenderState = new WebGLRenderState( extensions );\n\t\t\t\trenderStateArray.push( renderState );\n\n\t\t\t} else {\n\n\t\t\t\trenderState = renderStateArray[ renderCallDepth ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn renderState;\n\n\t}\n\n\tfunction dispose() {\n\n\t\trenderStates = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nconst vertex = \"void main() {\\n\\tgl_Position = vec4( position, 1.0 );\\n}\";\n\nconst fragment = \"uniform sampler2D shadow_pass;\\nuniform vec2 resolution;\\nuniform float radius;\\n#include <packing>\\nvoid main() {\\n\\tconst float samples = float( VSM_SAMPLES );\\n\\tfloat mean = 0.0;\\n\\tfloat squared_mean = 0.0;\\n\\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\\n\\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\\n\\tfor ( float i = 0.0; i < samples; i ++ ) {\\n\\t\\tfloat uvOffset = uvStart + i * uvStride;\\n\\t\\t#ifdef HORIZONTAL_PASS\\n\\t\\t\\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\\n\\t\\t\\tmean += distribution.x;\\n\\t\\t\\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\\n\\t\\t#else\\n\\t\\t\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\\n\\t\\t\\tmean += depth;\\n\\t\\t\\tsquared_mean += depth * depth;\\n\\t\\t#endif\\n\\t}\\n\\tmean = mean / samples;\\n\\tsquared_mean = squared_mean / samples;\\n\\tfloat std_dev = sqrt( squared_mean - mean * mean );\\n\\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\\n}\";\n\nfunction WebGLShadowMap( renderer, objects, capabilities ) {\n\n\tlet _frustum = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Frustum();\n\n\tconst _shadowMapSize = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector2(),\n\t\t_viewportSize = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector2(),\n\n\t\t_viewport = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector4(),\n\n\t\t_depthMaterial = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MeshDepthMaterial( { depthPacking: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking } ),\n\t\t_distanceMaterial = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MeshDistanceMaterial(),\n\n\t\t_materialCache = {},\n\n\t\t_maxTextureSize = capabilities.maxTextureSize;\n\n\tconst shadowSide = { [ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.FrontSide ]: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BackSide, [ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BackSide ]: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.FrontSide, [ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DoubleSide ]: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DoubleSide };\n\n\tconst shadowMaterialVertical = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial( {\n\t\tdefines: {\n\t\t\tVSM_SAMPLES: 8\n\t\t},\n\t\tuniforms: {\n\t\t\tshadow_pass: { value: null },\n\t\t\tresolution: { value: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector2() },\n\t\t\tradius: { value: 4.0 }\n\t\t},\n\n\t\tvertexShader: vertex,\n\t\tfragmentShader: fragment\n\n\t} );\n\n\tconst shadowMaterialHorizontal = shadowMaterialVertical.clone();\n\tshadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n\n\tconst fullScreenTri = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\tfullScreenTri.setAttribute(\n\t\t'position',\n\t\tnew _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(\n\t\t\tnew Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),\n\t\t\t3\n\t\t)\n\t);\n\n\tconst fullScreenMesh = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Mesh( fullScreenTri, shadowMaterialVertical );\n\n\tconst scope = this;\n\n\tthis.enabled = false;\n\n\tthis.autoUpdate = true;\n\tthis.needsUpdate = false;\n\n\tthis.type = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PCFShadowMap;\n\tlet _previousType = this.type;\n\n\tthis.render = function ( lights, scene, camera ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\tif ( lights.length === 0 ) return;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst activeCubeFace = renderer.getActiveCubeFace();\n\t\tconst activeMipmapLevel = renderer.getActiveMipmapLevel();\n\n\t\tconst _state = renderer.state;\n\n\t\t// Set GL state for depth map.\n\t\t_state.setBlending( _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoBlending );\n\t\t_state.buffers.color.setClear( 1, 1, 1, 1 );\n\t\t_state.buffers.depth.setTest( true );\n\t\t_state.setScissorTest( false );\n\n\t\t// check for shadow map type changes\n\n\t\tconst toVSM = ( _previousType !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.VSMShadowMap && this.type === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.VSMShadowMap );\n\t\tconst fromVSM = ( _previousType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.VSMShadowMap && this.type !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.VSMShadowMap );\n\n\t\t// render depth map\n\n\t\tfor ( let i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\t\t\tconst shadow = light.shadow;\n\n\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;\n\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\n\t\t\tconst shadowFrameExtents = shadow.getFrameExtents();\n\n\t\t\t_shadowMapSize.multiply( shadowFrameExtents );\n\n\t\t\t_viewportSize.copy( shadow.mapSize );\n\n\t\t\tif ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {\n\n\t\t\t\tif ( _shadowMapSize.x > _maxTextureSize ) {\n\n\t\t\t\t\t_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );\n\t\t\t\t\t_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n\t\t\t\t\tshadow.mapSize.x = _viewportSize.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _shadowMapSize.y > _maxTextureSize ) {\n\n\t\t\t\t\t_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );\n\t\t\t\t\t_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n\t\t\t\t\tshadow.mapSize.y = _viewportSize.y;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null || toVSM === true || fromVSM === true ) {\n\n\t\t\t\tconst pars = ( this.type !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.VSMShadowMap ) ? { minFilter: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NearestFilter, magFilter: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NearestFilter } : {};\n\n\t\t\t\tif ( shadow.map !== null ) {\n\n\t\t\t\t\tshadow.map.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tshadow.map = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\t\t\tshadow.map.texture.name = light.name + '.shadowMap';\n\n\t\t\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\trenderer.setRenderTarget( shadow.map );\n\t\t\trenderer.clear();\n\n\t\t\tconst viewportCount = shadow.getViewportCount();\n\n\t\t\tfor ( let vp = 0; vp < viewportCount; vp ++ ) {\n\n\t\t\t\tconst viewport = shadow.getViewport( vp );\n\n\t\t\t\t_viewport.set(\n\t\t\t\t\t_viewportSize.x * viewport.x,\n\t\t\t\t\t_viewportSize.y * viewport.y,\n\t\t\t\t\t_viewportSize.x * viewport.z,\n\t\t\t\t\t_viewportSize.y * viewport.w\n\t\t\t\t);\n\n\t\t\t\t_state.viewport( _viewport );\n\n\t\t\t\tshadow.updateMatrices( light, vp );\n\n\t\t\t\t_frustum = shadow.getFrustum();\n\n\t\t\t\trenderObject( scene, camera, shadow.camera, light, this.type );\n\n\t\t\t}\n\n\t\t\t// do blur pass for VSM\n\n\t\t\tif ( shadow.isPointLightShadow !== true && this.type === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.VSMShadowMap ) {\n\n\t\t\t\tVSMPass( shadow, camera );\n\n\t\t\t}\n\n\t\t\tshadow.needsUpdate = false;\n\n\t\t}\n\n\t\t_previousType = this.type;\n\n\t\tscope.needsUpdate = false;\n\n\t\trenderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );\n\n\t};\n\n\tfunction VSMPass( shadow, camera ) {\n\n\t\tconst geometry = objects.update( fullScreenMesh );\n\n\t\tif ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {\n\n\t\t\tshadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;\n\t\t\tshadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;\n\n\t\t\tshadowMaterialVertical.needsUpdate = true;\n\t\t\tshadowMaterialHorizontal.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( shadow.mapPass === null ) {\n\n\t\t\tshadow.mapPass = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );\n\n\t\t}\n\n\t\t// vertical pass\n\n\t\tshadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n\t\tshadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n\t\tshadowMaterialVertical.uniforms.radius.value = shadow.radius;\n\t\trenderer.setRenderTarget( shadow.mapPass );\n\t\trenderer.clear();\n\t\trenderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );\n\n\t\t// horizontal pass\n\n\t\tshadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n\t\tshadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\n\t\tshadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\n\t\trenderer.setRenderTarget( shadow.map );\n\t\trenderer.clear();\n\t\trenderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );\n\n\t}\n\n\tfunction getDepthMaterial( object, material, light, type ) {\n\n\t\tlet result = null;\n\n\t\tconst customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;\n\n\t\tif ( customMaterial !== undefined ) {\n\n\t\t\tresult = customMaterial;\n\n\t\t} else {\n\n\t\t\tresult = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;\n\n\t\t\tif ( ( renderer.localClippingEnabled && material.clipShadows === true && Array.isArray( material.clippingPlanes ) && material.clippingPlanes.length !== 0 ) ||\n\t\t\t\t( material.displacementMap && material.displacementScale !== 0 ) ||\n\t\t\t\t( material.alphaMap && material.alphaTest > 0 ) ||\n\t\t\t\t( material.map && material.alphaTest > 0 ) ) {\n\n\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t// appropriate state\n\n\t\t\t\tconst keyA = result.uuid, keyB = material.uuid;\n\n\t\t\t\tlet materialsForVariant = _materialCache[ keyA ];\n\n\t\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t\t}\n\n\t\t\t\tlet cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\t\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t\t\t}\n\n\t\t\t\tresult = cachedMaterial;\n\n\t\t\t}\n\n\t\t}\n\n\t\tresult.visible = material.visible;\n\t\tresult.wireframe = material.wireframe;\n\n\t\tif ( type === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.VSMShadowMap ) {\n\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;\n\n\t\t} else {\n\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];\n\n\t\t}\n\n\t\tresult.alphaMap = material.alphaMap;\n\t\tresult.alphaTest = material.alphaTest;\n\t\tresult.map = material.map;\n\n\t\tresult.clipShadows = material.clipShadows;\n\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\tresult.clipIntersection = material.clipIntersection;\n\n\t\tresult.displacementMap = material.displacementMap;\n\t\tresult.displacementScale = material.displacementScale;\n\t\tresult.displacementBias = material.displacementBias;\n\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\tresult.linewidth = material.linewidth;\n\n\t\tif ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {\n\n\t\t\tconst materialProperties = renderer.properties.get( result );\n\t\t\tmaterialProperties.light = light;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction renderObject( object, camera, shadowCamera, light, type ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\n\t\t\tif ( ( object.castShadow || ( object.receiveShadow && type === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\n\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\tconst material = object.material;\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\tfor ( let k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\tconst group = groups[ k ];\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, groupMaterial, light, type );\n\n\t\t\t\t\t\t\tobject.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );\n\n\t\t\t\t\t\t\trenderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t\tobject.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, material, light, type );\n\n\t\t\t\t\tobject.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );\n\n\t\t\t\t\trenderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t\tobject.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trenderObject( children[ i ], camera, shadowCamera, light, type );\n\n\t\t}\n\n\t}\n\n\tfunction onMaterialDispose( event ) {\n\n\t\tconst material = event.target;\n\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\t// make sure to remove the unique distance/depth materials used for shadow map rendering\n\n\t\tfor ( const id in _materialCache ) {\n\n\t\t\tconst cache = _materialCache[ id ];\n\n\t\t\tconst uuid = event.target.uuid;\n\n\t\t\tif ( uuid in cache ) {\n\n\t\t\t\tconst shadowMaterial = cache[ uuid ];\n\t\t\t\tshadowMaterial.dispose();\n\t\t\t\tdelete cache[ uuid ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nconst reversedFuncs = {\n\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NeverDepth ]: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AlwaysDepth,\n\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LessDepth ]: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GreaterDepth,\n\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EqualDepth ]: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NotEqualDepth,\n\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LessEqualDepth ]: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GreaterEqualDepth,\n\n\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AlwaysDepth ]: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NeverDepth,\n\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GreaterDepth ]: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LessDepth,\n\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NotEqualDepth ]: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EqualDepth,\n\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GreaterEqualDepth ]: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LessEqualDepth,\n};\n\nfunction WebGLState( gl, extensions ) {\n\n\tfunction ColorBuffer() {\n\n\t\tlet locked = false;\n\n\t\tconst color = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector4();\n\t\tlet currentColorMask = null;\n\t\tconst currentColorClear = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector4( 0, 0, 0, 0 );\n\n\t\treturn {\n\n\t\t\tsetMask: function ( colorMask ) {\n\n\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\t\tcurrentColorMask = colorMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( r, g, b, a, premultipliedAlpha ) {\n\n\t\t\t\tif ( premultipliedAlpha === true ) {\n\n\t\t\t\t\tr *= a; g *= a; b *= a;\n\n\t\t\t\t}\n\n\t\t\t\tcolor.set( r, g, b, a );\n\n\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\t\tcurrentColorClear.copy( color );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentColorMask = null;\n\t\t\t\tcurrentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction DepthBuffer() {\n\n\t\tlet locked = false;\n\t\tlet reversed = false;\n\n\t\tlet currentDepthMask = null;\n\t\tlet currentDepthFunc = null;\n\t\tlet currentDepthClear = null;\n\n\t\treturn {\n\n\t\t\tsetReversed: function ( value ) {\n\n\t\t\t\tif ( reversed !== value ) {\n\n\t\t\t\t\tconst ext = extensions.get( 'EXT_clip_control' );\n\n\t\t\t\t\tif ( reversed ) {\n\n\t\t\t\t\t\text.clipControlEXT( ext.LOWER_LEFT_EXT, ext.ZERO_TO_ONE_EXT );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\text.clipControlEXT( ext.LOWER_LEFT_EXT, ext.NEGATIVE_ONE_TO_ONE_EXT );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst oldDepth = currentDepthClear;\n\t\t\t\t\tcurrentDepthClear = null;\n\t\t\t\t\tthis.setClear( oldDepth );\n\n\t\t\t\t}\n\n\t\t\t\treversed = value;\n\n\t\t\t},\n\n\t\t\tgetReversed: function () {\n\n\t\t\t\treturn reversed;\n\n\t\t\t},\n\n\t\t\tsetTest: function ( depthTest ) {\n\n\t\t\t\tif ( depthTest ) {\n\n\t\t\t\t\tenable( gl.DEPTH_TEST );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdisable( gl.DEPTH_TEST );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetMask: function ( depthMask ) {\n\n\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\t\tcurrentDepthMask = depthMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetFunc: function ( depthFunc ) {\n\n\t\t\t\tif ( reversed ) depthFunc = reversedFuncs[ depthFunc ];\n\n\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NeverDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AlwaysDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LessDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LessEqualDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EqualDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GreaterEqualDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GreaterDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NotEqualDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( depth ) {\n\n\t\t\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\t\t\tif ( reversed ) {\n\n\t\t\t\t\t\tdepth = 1 - depth;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl.clearDepth( depth );\n\t\t\t\t\tcurrentDepthClear = depth;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentDepthMask = null;\n\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\tcurrentDepthClear = null;\n\t\t\t\treversed = false;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction StencilBuffer() {\n\n\t\tlet locked = false;\n\n\t\tlet currentStencilMask = null;\n\t\tlet currentStencilFunc = null;\n\t\tlet currentStencilRef = null;\n\t\tlet currentStencilFuncMask = null;\n\t\tlet currentStencilFail = null;\n\t\tlet currentStencilZFail = null;\n\t\tlet currentStencilZPass = null;\n\t\tlet currentStencilClear = null;\n\n\t\treturn {\n\n\t\t\tsetTest: function ( stencilTest ) {\n\n\t\t\t\tif ( ! locked ) {\n\n\t\t\t\t\tif ( stencilTest ) {\n\n\t\t\t\t\t\tenable( gl.STENCIL_TEST );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdisable( gl.STENCIL_TEST );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetMask: function ( stencilMask ) {\n\n\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t\t     currentStencilRef !== stencilRef ||\n\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\t\t\tgl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\tcurrentStencilRef = stencilRef;\n\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\t\tif ( currentStencilFail !== stencilFail ||\n\t\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\t\t\tgl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t\t\t\tcurrentStencilFail = stencilFail;\n\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( stencil ) {\n\n\t\t\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\t\tcurrentStencilClear = stencil;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentStencilMask = null;\n\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\tcurrentStencilRef = null;\n\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\tcurrentStencilFail = null;\n\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\tcurrentStencilClear = null;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t//\n\n\tconst colorBuffer = new ColorBuffer();\n\tconst depthBuffer = new DepthBuffer();\n\tconst stencilBuffer = new StencilBuffer();\n\n\tconst uboBindings = new WeakMap();\n\tconst uboProgramMap = new WeakMap();\n\n\tlet enabledCapabilities = {};\n\n\tlet currentBoundFramebuffers = {};\n\tlet currentDrawbuffers = new WeakMap();\n\tlet defaultDrawbuffers = [];\n\n\tlet currentProgram = null;\n\n\tlet currentBlendingEnabled = false;\n\tlet currentBlending = null;\n\tlet currentBlendEquation = null;\n\tlet currentBlendSrc = null;\n\tlet currentBlendDst = null;\n\tlet currentBlendEquationAlpha = null;\n\tlet currentBlendSrcAlpha = null;\n\tlet currentBlendDstAlpha = null;\n\tlet currentBlendColor = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color( 0, 0, 0 );\n\tlet currentBlendAlpha = 0;\n\tlet currentPremultipledAlpha = false;\n\n\tlet currentFlipSided = null;\n\tlet currentCullFace = null;\n\n\tlet currentLineWidth = null;\n\n\tlet currentPolygonOffsetFactor = null;\n\tlet currentPolygonOffsetUnits = null;\n\n\tconst maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );\n\n\tlet lineWidthAvailable = false;\n\tlet version = 0;\n\tconst glVersion = gl.getParameter( gl.VERSION );\n\n\tif ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {\n\n\t\tversion = parseFloat( /^WebGL (\\d)/.exec( glVersion )[ 1 ] );\n\t\tlineWidthAvailable = ( version >= 1.0 );\n\n\t} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {\n\n\t\tversion = parseFloat( /^OpenGL ES (\\d)/.exec( glVersion )[ 1 ] );\n\t\tlineWidthAvailable = ( version >= 2.0 );\n\n\t}\n\n\tlet currentTextureSlot = null;\n\tlet currentBoundTextures = {};\n\n\tconst scissorParam = gl.getParameter( gl.SCISSOR_BOX );\n\tconst viewportParam = gl.getParameter( gl.VIEWPORT );\n\n\tconst currentScissor = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector4().fromArray( scissorParam );\n\tconst currentViewport = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector4().fromArray( viewportParam );\n\n\tfunction createTexture( type, target, count, dimensions ) {\n\n\t\tconst data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\tconst texture = gl.createTexture();\n\n\t\tgl.bindTexture( type, texture );\n\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tif ( type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY ) {\n\n\t\t\t\tgl.texImage3D( target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\t} else {\n\n\t\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tconst emptyTextures = {};\n\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\temptyTextures[ gl.TEXTURE_2D_ARRAY ] = createTexture( gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1 );\n\temptyTextures[ gl.TEXTURE_3D ] = createTexture( gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1 );\n\n\t// init\n\n\tcolorBuffer.setClear( 0, 0, 0, 1 );\n\tdepthBuffer.setClear( 1 );\n\tstencilBuffer.setClear( 0 );\n\n\tenable( gl.DEPTH_TEST );\n\tdepthBuffer.setFunc( _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LessEqualDepth );\n\n\tsetFlipSided( false );\n\tsetCullFace( _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CullFaceBack );\n\tenable( gl.CULL_FACE );\n\n\tsetBlending( _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoBlending );\n\n\t//\n\n\tfunction enable( id ) {\n\n\t\tif ( enabledCapabilities[ id ] !== true ) {\n\n\t\t\tgl.enable( id );\n\t\t\tenabledCapabilities[ id ] = true;\n\n\t\t}\n\n\t}\n\n\tfunction disable( id ) {\n\n\t\tif ( enabledCapabilities[ id ] !== false ) {\n\n\t\t\tgl.disable( id );\n\t\t\tenabledCapabilities[ id ] = false;\n\n\t\t}\n\n\t}\n\n\tfunction bindFramebuffer( target, framebuffer ) {\n\n\t\tif ( currentBoundFramebuffers[ target ] !== framebuffer ) {\n\n\t\t\tgl.bindFramebuffer( target, framebuffer );\n\n\t\t\tcurrentBoundFramebuffers[ target ] = framebuffer;\n\n\t\t\t// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER\n\n\t\t\tif ( target === gl.DRAW_FRAMEBUFFER ) {\n\n\t\t\t\tcurrentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;\n\n\t\t\t}\n\n\t\t\tif ( target === gl.FRAMEBUFFER ) {\n\n\t\t\t\tcurrentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tfunction drawBuffers( renderTarget, framebuffer ) {\n\n\t\tlet drawBuffers = defaultDrawbuffers;\n\n\t\tlet needsUpdate = false;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tdrawBuffers = currentDrawbuffers.get( framebuffer );\n\n\t\t\tif ( drawBuffers === undefined ) {\n\n\t\t\t\tdrawBuffers = [];\n\t\t\t\tcurrentDrawbuffers.set( framebuffer, drawBuffers );\n\n\t\t\t}\n\n\t\t\tconst textures = renderTarget.textures;\n\n\t\t\tif ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {\n\n\t\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\t\tdrawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;\n\n\t\t\t\t}\n\n\t\t\t\tdrawBuffers.length = textures.length;\n\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( drawBuffers[ 0 ] !== gl.BACK ) {\n\n\t\t\t\tdrawBuffers[ 0 ] = gl.BACK;\n\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tgl.drawBuffers( drawBuffers );\n\n\t\t}\n\n\t}\n\n\tfunction useProgram( program ) {\n\n\t\tif ( currentProgram !== program ) {\n\n\t\t\tgl.useProgram( program );\n\n\t\t\tcurrentProgram = program;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tconst equationToGL = {\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AddEquation ]: gl.FUNC_ADD,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SubtractEquation ]: gl.FUNC_SUBTRACT,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT\n\t};\n\n\tequationToGL[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MinEquation ] = gl.MIN;\n\tequationToGL[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MaxEquation ] = gl.MAX;\n\n\tconst factorToGL = {\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ZeroFactor ]: gl.ZERO,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.OneFactor ]: gl.ONE,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SrcColorFactor ]: gl.SRC_COLOR,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SrcAlphaFactor ]: gl.SRC_ALPHA,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DstColorFactor ]: gl.DST_COLOR,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DstAlphaFactor ]: gl.DST_ALPHA,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ConstantColorFactor ]: gl.CONSTANT_COLOR,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.OneMinusConstantColorFactor ]: gl.ONE_MINUS_CONSTANT_COLOR,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ConstantAlphaFactor ]: gl.CONSTANT_ALPHA,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.OneMinusConstantAlphaFactor ]: gl.ONE_MINUS_CONSTANT_ALPHA\n\t};\n\n\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha ) {\n\n\t\tif ( blending === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoBlending ) {\n\n\t\t\tif ( currentBlendingEnabled === true ) {\n\n\t\t\t\tdisable( gl.BLEND );\n\t\t\t\tcurrentBlendingEnabled = false;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( currentBlendingEnabled === false ) {\n\n\t\t\tenable( gl.BLEND );\n\t\t\tcurrentBlendingEnabled = true;\n\n\t\t}\n\n\t\tif ( blending !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CustomBlending ) {\n\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\t\tif ( currentBlendEquation !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AddEquation || currentBlendEquationAlpha !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AddEquation ) {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\n\t\t\t\t\tcurrentBlendEquation = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AddEquation;\n\t\t\t\t\tcurrentBlendEquationAlpha = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AddEquation;\n\n\t\t\t\t}\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.ONE, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\tcurrentBlendDst = null;\n\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\tcurrentBlendDstAlpha = null;\n\t\t\t\tcurrentBlendColor.set( 0, 0, 0 );\n\t\t\t\tcurrentBlendAlpha = 0;\n\n\t\t\t\tcurrentBlending = blending;\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// custom blending\n\n\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\tgl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );\n\n\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t}\n\n\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\tgl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );\n\n\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\tcurrentBlendDst = blendDst;\n\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t}\n\n\t\tif ( blendColor.equals( currentBlendColor ) === false || blendAlpha !== currentBlendAlpha ) {\n\n\t\t\tgl.blendColor( blendColor.r, blendColor.g, blendColor.b, blendAlpha );\n\n\t\t\tcurrentBlendColor.copy( blendColor );\n\t\t\tcurrentBlendAlpha = blendAlpha;\n\n\t\t}\n\n\t\tcurrentBlending = blending;\n\t\tcurrentPremultipledAlpha = false;\n\n\t}\n\n\tfunction setMaterial( material, frontFaceCW ) {\n\n\t\tmaterial.side === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DoubleSide\n\t\t\t? disable( gl.CULL_FACE )\n\t\t\t: enable( gl.CULL_FACE );\n\n\t\tlet flipSided = ( material.side === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BackSide );\n\t\tif ( frontFaceCW ) flipSided = ! flipSided;\n\n\t\tsetFlipSided( flipSided );\n\n\t\t( material.blending === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NormalBlending && material.transparent === false )\n\t\t\t? setBlending( _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoBlending )\n\t\t\t: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha );\n\n\t\tdepthBuffer.setFunc( material.depthFunc );\n\t\tdepthBuffer.setTest( material.depthTest );\n\t\tdepthBuffer.setMask( material.depthWrite );\n\t\tcolorBuffer.setMask( material.colorWrite );\n\n\t\tconst stencilWrite = material.stencilWrite;\n\t\tstencilBuffer.setTest( stencilWrite );\n\t\tif ( stencilWrite ) {\n\n\t\t\tstencilBuffer.setMask( material.stencilWriteMask );\n\t\t\tstencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );\n\t\t\tstencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );\n\n\t\t}\n\n\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\tmaterial.alphaToCoverage === true\n\t\t\t? enable( gl.SAMPLE_ALPHA_TO_COVERAGE )\n\t\t\t: disable( gl.SAMPLE_ALPHA_TO_COVERAGE );\n\n\t}\n\n\t//\n\n\tfunction setFlipSided( flipSided ) {\n\n\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t}\n\n\t\t\tcurrentFlipSided = flipSided;\n\n\t\t}\n\n\t}\n\n\tfunction setCullFace( cullFace ) {\n\n\t\tif ( cullFace !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CullFaceNone ) {\n\n\t\t\tenable( gl.CULL_FACE );\n\n\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\tif ( cullFace === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t} else if ( cullFace === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdisable( gl.CULL_FACE );\n\n\t\t}\n\n\t\tcurrentCullFace = cullFace;\n\n\t}\n\n\tfunction setLineWidth( width ) {\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tif ( lineWidthAvailable ) gl.lineWidth( width );\n\n\t\t\tcurrentLineWidth = width;\n\n\t\t}\n\n\t}\n\n\tfunction setPolygonOffset( polygonOffset, factor, units ) {\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tenable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdisable( gl.POLYGON_OFFSET_FILL );\n\n\t\t}\n\n\t}\n\n\tfunction setScissorTest( scissorTest ) {\n\n\t\tif ( scissorTest ) {\n\n\t\t\tenable( gl.SCISSOR_TEST );\n\n\t\t} else {\n\n\t\t\tdisable( gl.SCISSOR_TEST );\n\n\t\t}\n\n\t}\n\n\t// texture\n\n\tfunction activeTexture( webglSlot ) {\n\n\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t}\n\n\t}\n\n\tfunction bindTexture( webglType, webglTexture, webglSlot ) {\n\n\t\tif ( webglSlot === undefined ) {\n\n\t\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t\twebglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\t\t} else {\n\n\t\t\t\twebglSlot = currentTextureSlot;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet boundTexture = currentBoundTextures[ webglSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ webglSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t\t}\n\n\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t}\n\n\tfunction unbindTexture() {\n\n\t\tconst boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture !== undefined && boundTexture.type !== undefined ) {\n\n\t\t\tgl.bindTexture( boundTexture.type, null );\n\n\t\t\tboundTexture.type = undefined;\n\t\t\tboundTexture.texture = undefined;\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texSubImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.texSubImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texSubImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.texSubImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexSubImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexSubImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexSubImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexSubImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texStorage2D() {\n\n\t\ttry {\n\n\t\t\tgl.texStorage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texStorage3D() {\n\n\t\ttry {\n\n\t\t\tgl.texStorage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.texImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction scissor( scissor ) {\n\n\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\tcurrentScissor.copy( scissor );\n\n\t\t}\n\n\t}\n\n\tfunction viewport( viewport ) {\n\n\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\tcurrentViewport.copy( viewport );\n\n\t\t}\n\n\t}\n\n\tfunction updateUBOMapping( uniformsGroup, program ) {\n\n\t\tlet mapping = uboProgramMap.get( program );\n\n\t\tif ( mapping === undefined ) {\n\n\t\t\tmapping = new WeakMap();\n\n\t\t\tuboProgramMap.set( program, mapping );\n\n\t\t}\n\n\t\tlet blockIndex = mapping.get( uniformsGroup );\n\n\t\tif ( blockIndex === undefined ) {\n\n\t\t\tblockIndex = gl.getUniformBlockIndex( program, uniformsGroup.name );\n\n\t\t\tmapping.set( uniformsGroup, blockIndex );\n\n\t\t}\n\n\t}\n\n\tfunction uniformBlockBinding( uniformsGroup, program ) {\n\n\t\tconst mapping = uboProgramMap.get( program );\n\t\tconst blockIndex = mapping.get( uniformsGroup );\n\n\t\tif ( uboBindings.get( program ) !== blockIndex ) {\n\n\t\t\t// bind shader specific block index to global block point\n\t\t\tgl.uniformBlockBinding( program, blockIndex, uniformsGroup.__bindingPointIndex );\n\n\t\t\tuboBindings.set( program, blockIndex );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction reset() {\n\n\t\t// reset state\n\n\t\tgl.disable( gl.BLEND );\n\t\tgl.disable( gl.CULL_FACE );\n\t\tgl.disable( gl.DEPTH_TEST );\n\t\tgl.disable( gl.POLYGON_OFFSET_FILL );\n\t\tgl.disable( gl.SCISSOR_TEST );\n\t\tgl.disable( gl.STENCIL_TEST );\n\t\tgl.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );\n\n\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\tgl.blendFunc( gl.ONE, gl.ZERO );\n\t\tgl.blendFuncSeparate( gl.ONE, gl.ZERO, gl.ONE, gl.ZERO );\n\t\tgl.blendColor( 0, 0, 0, 0 );\n\n\t\tgl.colorMask( true, true, true, true );\n\t\tgl.clearColor( 0, 0, 0, 0 );\n\n\t\tgl.depthMask( true );\n\t\tgl.depthFunc( gl.LESS );\n\n\t\tdepthBuffer.setReversed( false );\n\n\t\tgl.clearDepth( 1 );\n\n\t\tgl.stencilMask( 0xffffffff );\n\t\tgl.stencilFunc( gl.ALWAYS, 0, 0xffffffff );\n\t\tgl.stencilOp( gl.KEEP, gl.KEEP, gl.KEEP );\n\t\tgl.clearStencil( 0 );\n\n\t\tgl.cullFace( gl.BACK );\n\t\tgl.frontFace( gl.CCW );\n\n\t\tgl.polygonOffset( 0, 0 );\n\n\t\tgl.activeTexture( gl.TEXTURE0 );\n\n\t\tgl.bindFramebuffer( gl.FRAMEBUFFER, null );\n\t\tgl.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );\n\t\tgl.bindFramebuffer( gl.READ_FRAMEBUFFER, null );\n\n\t\tgl.useProgram( null );\n\n\t\tgl.lineWidth( 1 );\n\n\t\tgl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );\n\t\tgl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );\n\n\t\t// reset internals\n\n\t\tenabledCapabilities = {};\n\n\t\tcurrentTextureSlot = null;\n\t\tcurrentBoundTextures = {};\n\n\t\tcurrentBoundFramebuffers = {};\n\t\tcurrentDrawbuffers = new WeakMap();\n\t\tdefaultDrawbuffers = [];\n\n\t\tcurrentProgram = null;\n\n\t\tcurrentBlendingEnabled = false;\n\t\tcurrentBlending = null;\n\t\tcurrentBlendEquation = null;\n\t\tcurrentBlendSrc = null;\n\t\tcurrentBlendDst = null;\n\t\tcurrentBlendEquationAlpha = null;\n\t\tcurrentBlendSrcAlpha = null;\n\t\tcurrentBlendDstAlpha = null;\n\t\tcurrentBlendColor = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color( 0, 0, 0 );\n\t\tcurrentBlendAlpha = 0;\n\t\tcurrentPremultipledAlpha = false;\n\n\t\tcurrentFlipSided = null;\n\t\tcurrentCullFace = null;\n\n\t\tcurrentLineWidth = null;\n\n\t\tcurrentPolygonOffsetFactor = null;\n\t\tcurrentPolygonOffsetUnits = null;\n\n\t\tcurrentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );\n\t\tcurrentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );\n\n\t\tcolorBuffer.reset();\n\t\tdepthBuffer.reset();\n\t\tstencilBuffer.reset();\n\n\t}\n\n\treturn {\n\n\t\tbuffers: {\n\t\t\tcolor: colorBuffer,\n\t\t\tdepth: depthBuffer,\n\t\t\tstencil: stencilBuffer\n\t\t},\n\n\t\tenable: enable,\n\t\tdisable: disable,\n\n\t\tbindFramebuffer: bindFramebuffer,\n\t\tdrawBuffers: drawBuffers,\n\n\t\tuseProgram: useProgram,\n\n\t\tsetBlending: setBlending,\n\t\tsetMaterial: setMaterial,\n\n\t\tsetFlipSided: setFlipSided,\n\t\tsetCullFace: setCullFace,\n\n\t\tsetLineWidth: setLineWidth,\n\t\tsetPolygonOffset: setPolygonOffset,\n\n\t\tsetScissorTest: setScissorTest,\n\n\t\tactiveTexture: activeTexture,\n\t\tbindTexture: bindTexture,\n\t\tunbindTexture: unbindTexture,\n\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\tcompressedTexImage3D: compressedTexImage3D,\n\t\ttexImage2D: texImage2D,\n\t\ttexImage3D: texImage3D,\n\n\t\tupdateUBOMapping: updateUBOMapping,\n\t\tuniformBlockBinding: uniformBlockBinding,\n\n\t\ttexStorage2D: texStorage2D,\n\t\ttexStorage3D: texStorage3D,\n\t\ttexSubImage2D: texSubImage2D,\n\t\ttexSubImage3D: texSubImage3D,\n\t\tcompressedTexSubImage2D: compressedTexSubImage2D,\n\t\tcompressedTexSubImage3D: compressedTexSubImage3D,\n\n\t\tscissor: scissor,\n\t\tviewport: viewport,\n\n\t\treset: reset\n\n\t};\n\n}\n\nfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {\n\n\tconst multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;\n\tconst supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test( navigator.userAgent );\n\n\tconst _imageDimensions = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\tconst _videoTextures = new WeakMap();\n\tlet _canvas;\n\n\tconst _sources = new WeakMap(); // maps WebglTexture objects to instances of Source\n\n\t// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,\n\t// also OffscreenCanvas.getContext(\"webgl\"), but not OffscreenCanvas.getContext(\"2d\")!\n\t// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).\n\n\tlet useOffscreenCanvas = false;\n\n\ttry {\n\n\t\tuseOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'\n\t\t\t// eslint-disable-next-line compat/compat\n\t\t\t&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;\n\n\t} catch ( err ) {\n\n\t\t// Ignore any errors\n\n\t}\n\n\tfunction createCanvas( width, height ) {\n\n\t\t// Use OffscreenCanvas when available. Specially needed in web workers\n\n\t\treturn useOffscreenCanvas ?\n\t\t\t// eslint-disable-next-line compat/compat\n\t\t\tnew OffscreenCanvas( width, height ) : (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.createElementNS)( 'canvas' );\n\n\t}\n\n\tfunction resizeImage( image, needsNewCanvas, maxSize ) {\n\n\t\tlet scale = 1;\n\n\t\tconst dimensions = getDimensions( image );\n\n\t\t// handle case if texture exceeds max size\n\n\t\tif ( dimensions.width > maxSize || dimensions.height > maxSize ) {\n\n\t\t\tscale = maxSize / Math.max( dimensions.width, dimensions.height );\n\n\t\t}\n\n\t\t// only perform resize if necessary\n\n\t\tif ( scale < 1 ) {\n\n\t\t\t// only perform resize for certain image types\n\n\t\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ||\n\t\t\t\t( typeof VideoFrame !== 'undefined' && image instanceof VideoFrame ) ) {\n\n\t\t\t\tconst width = Math.floor( scale * dimensions.width );\n\t\t\t\tconst height = Math.floor( scale * dimensions.height );\n\n\t\t\t\tif ( _canvas === undefined ) _canvas = createCanvas( width, height );\n\n\t\t\t\t// cube textures can't reuse the same canvas\n\n\t\t\t\tconst canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;\n\n\t\t\t\tcanvas.width = width;\n\t\t\t\tcanvas.height = height;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, width, height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + dimensions.width + 'x' + dimensions.height + ') to (' + width + 'x' + height + ').' );\n\n\t\t\t\treturn canvas;\n\n\t\t\t} else {\n\n\t\t\t\tif ( 'data' in image ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + dimensions.width + 'x' + dimensions.height + ').' );\n\n\t\t\t\t}\n\n\t\t\t\treturn image;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction textureNeedsGenerateMipmaps( texture ) {\n\n\t\treturn texture.generateMipmaps;\n\n\t}\n\n\tfunction generateMipmap( target ) {\n\n\t\t_gl.generateMipmap( target );\n\n\t}\n\n\tfunction getTargetType( texture ) {\n\n\t\tif ( texture.isWebGLCubeRenderTarget ) return _gl.TEXTURE_CUBE_MAP;\n\t\tif ( texture.isWebGL3DRenderTarget ) return _gl.TEXTURE_3D;\n\t\tif ( texture.isWebGLArrayRenderTarget || texture.isCompressedArrayTexture ) return _gl.TEXTURE_2D_ARRAY;\n\t\treturn _gl.TEXTURE_2D;\n\n\t}\n\n\tfunction getInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {\n\n\t\tif ( internalFormatName !== null ) {\n\n\t\t\tif ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'' );\n\n\t\t}\n\n\t\tlet internalFormat = glFormat;\n\n\t\tif ( glFormat === _gl.RED ) {\n\n\t\t\tif ( glType === _gl.FLOAT ) internalFormat = _gl.R32F;\n\t\t\tif ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.R16F;\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RED_INTEGER ) {\n\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8UI;\n\t\t\tif ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.R16UI;\n\t\t\tif ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.R32UI;\n\t\t\tif ( glType === _gl.BYTE ) internalFormat = _gl.R8I;\n\t\t\tif ( glType === _gl.SHORT ) internalFormat = _gl.R16I;\n\t\t\tif ( glType === _gl.INT ) internalFormat = _gl.R32I;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RG ) {\n\n\t\t\tif ( glType === _gl.FLOAT ) internalFormat = _gl.RG32F;\n\t\t\tif ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RG16F;\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RG_INTEGER ) {\n\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8UI;\n\t\t\tif ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.RG16UI;\n\t\t\tif ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.RG32UI;\n\t\t\tif ( glType === _gl.BYTE ) internalFormat = _gl.RG8I;\n\t\t\tif ( glType === _gl.SHORT ) internalFormat = _gl.RG16I;\n\t\t\tif ( glType === _gl.INT ) internalFormat = _gl.RG32I;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RGB_INTEGER ) {\n\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RGB8UI;\n\t\t\tif ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.RGB16UI;\n\t\t\tif ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.RGB32UI;\n\t\t\tif ( glType === _gl.BYTE ) internalFormat = _gl.RGB8I;\n\t\t\tif ( glType === _gl.SHORT ) internalFormat = _gl.RGB16I;\n\t\t\tif ( glType === _gl.INT ) internalFormat = _gl.RGB32I;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RGBA_INTEGER ) {\n\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RGBA8UI;\n\t\t\tif ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.RGBA16UI;\n\t\t\tif ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.RGBA32UI;\n\t\t\tif ( glType === _gl.BYTE ) internalFormat = _gl.RGBA8I;\n\t\t\tif ( glType === _gl.SHORT ) internalFormat = _gl.RGBA16I;\n\t\t\tif ( glType === _gl.INT ) internalFormat = _gl.RGBA32I;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RGB ) {\n\n\t\t\tif ( glType === _gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = _gl.RGB9_E5;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RGBA ) {\n\n\t\t\tconst transfer = forceLinearTransfer ? _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearTransfer : _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.getTransfer( colorSpace );\n\n\t\t\tif ( glType === _gl.FLOAT ) internalFormat = _gl.RGBA32F;\n\t\t\tif ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RGBA16F;\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;\n\t\t\tif ( glType === _gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = _gl.RGBA4;\n\t\t\tif ( glType === _gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = _gl.RGB5_A1;\n\n\t\t}\n\n\t\tif ( internalFormat === _gl.R16F || internalFormat === _gl.R32F ||\n\t\t\tinternalFormat === _gl.RG16F || internalFormat === _gl.RG32F ||\n\t\t\tinternalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F ) {\n\n\t\t\textensions.get( 'EXT_color_buffer_float' );\n\n\t\t}\n\n\t\treturn internalFormat;\n\n\t}\n\n\tfunction getInternalDepthFormat( useStencil, depthType ) {\n\n\t\tlet glInternalFormat;\n\t\tif ( useStencil ) {\n\n\t\t\tif ( depthType === null || depthType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType || depthType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedInt248Type ) {\n\n\t\t\t\tglInternalFormat = _gl.DEPTH24_STENCIL8;\n\n\t\t\t} else if ( depthType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.FloatType ) {\n\n\t\t\t\tglInternalFormat = _gl.DEPTH32F_STENCIL8;\n\n\t\t\t} else if ( depthType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedShortType ) {\n\n\t\t\t\tglInternalFormat = _gl.DEPTH24_STENCIL8;\n\t\t\t\tconsole.warn( 'DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.' );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( depthType === null || depthType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType || depthType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedInt248Type ) {\n\n\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT24;\n\n\t\t\t} else if ( depthType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.FloatType ) {\n\n\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT32F;\n\n\t\t\t} else if ( depthType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedShortType ) {\n\n\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn glInternalFormat;\n\n\t}\n\n\tfunction getMipLevels( texture, image ) {\n\n\t\tif ( textureNeedsGenerateMipmaps( texture ) === true || ( texture.isFramebufferTexture && texture.minFilter !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NearestFilter && texture.minFilter !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearFilter ) ) {\n\n\t\t\treturn Math.log2( Math.max( image.width, image.height ) ) + 1;\n\n\t\t} else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) {\n\n\t\t\t// user-defined mipmaps\n\n\t\t\treturn texture.mipmaps.length;\n\n\t\t} else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {\n\n\t\t\treturn image.mipmaps.length;\n\n\t\t} else {\n\n\t\t\t// texture without mipmaps (only base level)\n\n\t\t\treturn 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction onTextureDispose( event ) {\n\n\t\tconst texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tdeallocateTexture( texture );\n\n\t\tif ( texture.isVideoTexture ) {\n\n\t\t\t_videoTextures.delete( texture );\n\n\t\t}\n\n\t}\n\n\tfunction onRenderTargetDispose( event ) {\n\n\t\tconst renderTarget = event.target;\n\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tdeallocateRenderTarget( renderTarget );\n\n\t}\n\n\t//\n\n\tfunction deallocateTexture( texture ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t// check if it's necessary to remove the WebGLTexture object\n\n\t\tconst source = texture.source;\n\t\tconst webglTextures = _sources.get( source );\n\n\t\tif ( webglTextures ) {\n\n\t\t\tconst webglTexture = webglTextures[ textureProperties.__cacheKey ];\n\t\t\twebglTexture.usedTimes --;\n\n\t\t\t// the WebGLTexture object is not used anymore, remove it\n\n\t\t\tif ( webglTexture.usedTimes === 0 ) {\n\n\t\t\t\tdeleteTexture( texture );\n\n\t\t\t}\n\n\t\t\t// remove the weak map entry if no WebGLTexture uses the source anymore\n\n\t\t\tif ( Object.keys( webglTextures ).length === 0 ) {\n\n\t\t\t\t_sources.delete( source );\n\n\t\t\t}\n\n\t\t}\n\n\t\tproperties.remove( texture );\n\n\t}\n\n\tfunction deleteTexture( texture ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\tconst source = texture.source;\n\t\tconst webglTextures = _sources.get( source );\n\t\tdelete webglTextures[ textureProperties.__cacheKey ];\n\n\t\tinfo.memory.textures --;\n\n\t}\n\n\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t\tproperties.remove( renderTarget.depthTexture );\n\n\t\t}\n\n\t\tif ( renderTarget.isWebGLCubeRenderTarget ) {\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( Array.isArray( renderTargetProperties.__webglFramebuffer[ i ] ) ) {\n\n\t\t\t\t\tfor ( let level = 0; level < renderTargetProperties.__webglFramebuffer[ i ].length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ][ level ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( Array.isArray( renderTargetProperties.__webglFramebuffer ) ) {\n\n\t\t\t\tfor ( let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ level ] );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\n\t\t\t}\n\n\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\t\t\tif ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );\n\n\t\t\tif ( renderTargetProperties.__webglColorRenderbuffer ) {\n\n\t\t\t\tfor ( let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i ++ ) {\n\n\t\t\t\t\tif ( renderTargetProperties.__webglColorRenderbuffer[ i ] ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );\n\n\t\t}\n\n\t\tconst textures = renderTarget.textures;\n\n\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\tconst attachmentProperties = properties.get( textures[ i ] );\n\n\t\t\tif ( attachmentProperties.__webglTexture ) {\n\n\t\t\t\t_gl.deleteTexture( attachmentProperties.__webglTexture );\n\n\t\t\t\tinfo.memory.textures --;\n\n\t\t\t}\n\n\t\t\tproperties.remove( textures[ i ] );\n\n\t\t}\n\n\t\tproperties.remove( renderTarget );\n\n\t}\n\n\t//\n\n\tlet textureUnits = 0;\n\n\tfunction resetTextureUnits() {\n\n\t\ttextureUnits = 0;\n\n\t}\n\n\tfunction allocateTextureUnit() {\n\n\t\tconst textureUnit = textureUnits;\n\n\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\n\t\t}\n\n\t\ttextureUnits += 1;\n\n\t\treturn textureUnit;\n\n\t}\n\n\tfunction getTextureCacheKey( texture ) {\n\n\t\tconst array = [];\n\n\t\tarray.push( texture.wrapS );\n\t\tarray.push( texture.wrapT );\n\t\tarray.push( texture.wrapR || 0 );\n\t\tarray.push( texture.magFilter );\n\t\tarray.push( texture.minFilter );\n\t\tarray.push( texture.anisotropy );\n\t\tarray.push( texture.internalFormat );\n\t\tarray.push( texture.format );\n\t\tarray.push( texture.type );\n\t\tarray.push( texture.generateMipmaps );\n\t\tarray.push( texture.premultiplyAlpha );\n\t\tarray.push( texture.flipY );\n\t\tarray.push( texture.unpackAlignment );\n\t\tarray.push( texture.colorSpace );\n\n\t\treturn array.join();\n\n\t}\n\n\t//\n\n\tfunction setTexture2D( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.isVideoTexture ) updateVideoTexture( texture );\n\n\t\tif ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tconst image = texture.image;\n\n\t\t\tif ( image === null ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but no image data found.' );\n\n\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );\n\n\t\t\t} else {\n\n\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t}\n\n\tfunction setTexture2DArray( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.bindTexture( _gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t}\n\n\tfunction setTexture3D( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.bindTexture( _gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t}\n\n\tfunction setTextureCube( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadCubeTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t}\n\n\tconst wrappingToGL = {\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping ]: _gl.REPEAT,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping ]: _gl.CLAMP_TO_EDGE,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping ]: _gl.MIRRORED_REPEAT\n\t};\n\n\tconst filterToGL = {\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NearestFilter ]: _gl.NEAREST,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter ]: _gl.NEAREST_MIPMAP_NEAREST,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter ]: _gl.NEAREST_MIPMAP_LINEAR,\n\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearFilter ]: _gl.LINEAR,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter ]: _gl.LINEAR_MIPMAP_NEAREST,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter ]: _gl.LINEAR_MIPMAP_LINEAR\n\t};\n\n\tconst compareToGL = {\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NeverCompare ]: _gl.NEVER,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AlwaysCompare ]: _gl.ALWAYS,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LessCompare ]: _gl.LESS,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LessEqualCompare ]: _gl.LEQUAL,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EqualCompare ]: _gl.EQUAL,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GreaterEqualCompare ]: _gl.GEQUAL,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.GreaterCompare ]: _gl.GREATER,\n\t\t[ _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NotEqualCompare ]: _gl.NOTEQUAL\n\t};\n\n\tfunction setTextureParameters( textureType, texture ) {\n\n\t\tif ( texture.type === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.FloatType && extensions.has( 'OES_texture_float_linear' ) === false &&\n\t\t\t( texture.magFilter === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearFilter || texture.magFilter === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter || texture.magFilter === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter || texture.magFilter === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter ||\n\t\t\ttexture.minFilter === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearFilter || texture.minFilter === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter || texture.minFilter === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter || texture.minFilter === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter ) ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.' );\n\n\t\t}\n\n\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );\n\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );\n\n\t\tif ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );\n\n\t\t}\n\n\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );\n\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[ texture.minFilter ] );\n\n\t\tif ( texture.compareFunction ) {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );\n\n\t\t}\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tif ( texture.magFilter === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NearestFilter ) return;\n\t\t\tif ( texture.minFilter !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter && texture.minFilter !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter ) return;\n\t\t\tif ( texture.type === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension\n\n\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction initTexture( textureProperties, texture ) {\n\n\t\tlet forceUpload = false;\n\n\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t}\n\n\t\t// create Source <-> WebGLTextures mapping if necessary\n\n\t\tconst source = texture.source;\n\t\tlet webglTextures = _sources.get( source );\n\n\t\tif ( webglTextures === undefined ) {\n\n\t\t\twebglTextures = {};\n\t\t\t_sources.set( source, webglTextures );\n\n\t\t}\n\n\t\t// check if there is already a WebGLTexture object for the given texture parameters\n\n\t\tconst textureCacheKey = getTextureCacheKey( texture );\n\n\t\tif ( textureCacheKey !== textureProperties.__cacheKey ) {\n\n\t\t\t// if not, create a new instance of WebGLTexture\n\n\t\t\tif ( webglTextures[ textureCacheKey ] === undefined ) {\n\n\t\t\t\t// create new entry\n\n\t\t\t\twebglTextures[ textureCacheKey ] = {\n\t\t\t\t\ttexture: _gl.createTexture(),\n\t\t\t\t\tusedTimes: 0\n\t\t\t\t};\n\n\t\t\t\tinfo.memory.textures ++;\n\n\t\t\t\t// when a new instance of WebGLTexture was created, a texture upload is required\n\t\t\t\t// even if the image contents are identical\n\n\t\t\t\tforceUpload = true;\n\n\t\t\t}\n\n\t\t\twebglTextures[ textureCacheKey ].usedTimes ++;\n\n\t\t\t// every time the texture cache key changes, it's necessary to check if an instance of\n\t\t\t// WebGLTexture can be deleted in order to avoid a memory leak.\n\n\t\t\tconst webglTexture = webglTextures[ textureProperties.__cacheKey ];\n\n\t\t\tif ( webglTexture !== undefined ) {\n\n\t\t\t\twebglTextures[ textureProperties.__cacheKey ].usedTimes --;\n\n\t\t\t\tif ( webglTexture.usedTimes === 0 ) {\n\n\t\t\t\t\tdeleteTexture( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// store references to cache key and WebGLTexture object\n\n\t\t\ttextureProperties.__cacheKey = textureCacheKey;\n\t\t\ttextureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;\n\n\t\t}\n\n\t\treturn forceUpload;\n\n\t}\n\n\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\tlet textureType = _gl.TEXTURE_2D;\n\n\t\tif ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) textureType = _gl.TEXTURE_2D_ARRAY;\n\t\tif ( texture.isData3DTexture ) textureType = _gl.TEXTURE_3D;\n\n\t\tconst forceUpload = initTexture( textureProperties, texture );\n\t\tconst source = texture.source;\n\n\t\tstate.bindTexture( textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t\tconst sourceProperties = properties.get( source );\n\n\t\tif ( source.version !== sourceProperties.__version || forceUpload === true ) {\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\n\t\t\tconst workingPrimaries = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.getPrimaries( _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.workingColorSpace );\n\t\t\tconst texturePrimaries = texture.colorSpace === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoColorSpace ? null : _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.getPrimaries( texture.colorSpace );\n\t\t\tconst unpackConversion = texture.colorSpace === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );\n\n\t\t\tlet image = resizeImage( texture.image, false, capabilities.maxTextureSize );\n\t\t\timage = verifyColorSpace( texture, image );\n\n\t\t\tconst glFormat = utils.convert( texture.format, texture.colorSpace );\n\n\t\t\tconst glType = utils.convert( texture.type );\n\t\t\tlet glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );\n\n\t\t\tsetTextureParameters( textureType, texture );\n\n\t\t\tlet mipmap;\n\t\t\tconst mipmaps = texture.mipmaps;\n\n\t\t\tconst useTexStorage = ( texture.isVideoTexture !== true );\n\t\t\tconst allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );\n\t\t\tconst dataReady = source.dataReady;\n\t\t\tconst levels = getMipLevels( texture, image );\n\n\t\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t\tglInternalFormat = getInternalDepthFormat( texture.format === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DepthStencilFormat, texture.type );\n\n\t\t\t\t//\n\n\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isDataTexture ) {\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 ) {\n\n\t\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isCompressedTexture ) {\n\n\t\t\t\tif ( texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height, image.depth );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\t\tif ( texture.format !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat ) {\n\n\t\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\t\tif ( texture.layerUpdates.size > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst layerByteLength = (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.getByteLength)( mipmap.width, mipmap.height, texture.format, texture.type );\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( const layerIndex of texture.layerUpdates ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconst layerData = mipmap.data.subarray(\n\t\t\t\t\t\t\t\t\t\t\t\t\tlayerIndex * layerByteLength / mipmap.data.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t( layerIndex + 1 ) * layerByteLength / mipmap.data.BYTES_PER_ELEMENT\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tstate.compressedTexSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, layerData );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\ttexture.clearLayerUpdates();\n\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\tstate.compressedTexSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\tstate.texSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\t\tif ( texture.format !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat ) {\n\n\t\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\t\tstate.compressedTexSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isDataArrayTexture ) {\n\n\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\tif ( texture.layerUpdates.size > 0 ) {\n\n\t\t\t\t\t\t\tconst layerByteLength = (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.getByteLength)( image.width, image.height, texture.format, texture.type );\n\n\t\t\t\t\t\t\tfor ( const layerIndex of texture.layerUpdates ) {\n\n\t\t\t\t\t\t\t\tconst layerData = image.data.subarray(\n\t\t\t\t\t\t\t\t\tlayerIndex * layerByteLength / image.data.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t\t\t\t( layerIndex + 1 ) * layerByteLength / image.data.BYTES_PER_ELEMENT\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tstate.texSubImage3D( _gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, layerData );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttexture.clearLayerUpdates();\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texSubImage3D( _gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage3D( _gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage3D( _gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\tstate.texSubImage3D( _gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage3D( _gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isFramebufferTexture ) {\n\n\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tlet width = image.width, height = image.height;\n\n\t\t\t\t\t\tfor ( let i = 0; i < levels; i ++ ) {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null );\n\n\t\t\t\t\t\t\twidth >>= 1;\n\t\t\t\t\t\t\theight >>= 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 ) {\n\n\t\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t\tconst dimensions = getDimensions( mipmaps[ 0 ] );\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\t\t\tconst dimensions = getDimensions( image );\n\n\t\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture ) ) {\n\n\t\t\t\tgenerateMipmap( textureType );\n\n\t\t\t}\n\n\t\t\tsourceProperties.__version = source.version;\n\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t}\n\n\t\ttextureProperties.__version = texture.version;\n\n\t}\n\n\tfunction uploadCubeTexture( textureProperties, texture, slot ) {\n\n\t\tif ( texture.image.length !== 6 ) return;\n\n\t\tconst forceUpload = initTexture( textureProperties, texture );\n\t\tconst source = texture.source;\n\n\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t\tconst sourceProperties = properties.get( source );\n\n\t\tif ( source.version !== sourceProperties.__version || forceUpload === true ) {\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\n\t\t\tconst workingPrimaries = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.getPrimaries( _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.workingColorSpace );\n\t\t\tconst texturePrimaries = texture.colorSpace === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoColorSpace ? null : _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.getPrimaries( texture.colorSpace );\n\t\t\tconst unpackConversion = texture.colorSpace === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );\n\n\t\t\tconst isCompressed = ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture );\n\t\t\tconst isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );\n\n\t\t\tconst cubeImage = [];\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\t\tcubeImage[ i ] = resizeImage( texture.image[ i ], true, capabilities.maxCubemapSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tcubeImage[ i ] = verifyColorSpace( texture, cubeImage[ i ] );\n\n\t\t\t}\n\n\t\t\tconst image = cubeImage[ 0 ],\n\t\t\t\tglFormat = utils.convert( texture.format, texture.colorSpace ),\n\t\t\t\tglType = utils.convert( texture.type ),\n\t\t\t\tglInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );\n\n\t\t\tconst useTexStorage = ( texture.isVideoTexture !== true );\n\t\t\tconst allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );\n\t\t\tconst dataReady = source.dataReady;\n\t\t\tlet levels = getMipLevels( texture, image );\n\n\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture );\n\n\t\t\tlet mipmaps;\n\n\t\t\tif ( isCompressed ) {\n\n\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tmipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\n\t\t\t\t\t\tif ( texture.format !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat ) {\n\n\t\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\t\tstate.compressedTexSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tmipmaps = texture.mipmaps;\n\n\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t// TODO: Uniformly handle mipmap definitions\n\t\t\t\t\t// Normal textures and compressed cube textures define base level + mips with their mipmap array\n\t\t\t\t\t// Uncompressed cube textures use their mipmap array only for mips (no base level)\n\n\t\t\t\t\tif ( mipmaps.length > 0 ) levels ++;\n\n\t\t\t\t\tconst dimensions = getDimensions( cubeImage[ 0 ] );\n\n\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[ i ].width, cubeImage[ i ].height, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\t\t\t\t\t\t\tconst mipmapImage = mipmap.image[ i ].image;\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[ i ] );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture ) ) {\n\n\t\t\t\t// We assume images for cube map have the same size.\n\t\t\t\tgenerateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t}\n\n\t\t\tsourceProperties.__version = source.version;\n\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t}\n\n\t\ttextureProperties.__version = texture.version;\n\n\t}\n\n\t// Render targets\n\n\t// Setup storage for target texture and bind it to correct framebuffer\n\tfunction setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget, level ) {\n\n\t\tconst glFormat = utils.convert( texture.format, texture.colorSpace );\n\t\tconst glType = utils.convert( texture.type );\n\t\tconst glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\tconst textureProperties = properties.get( texture );\n\n\t\ttextureProperties.__renderTarget = renderTarget;\n\n\t\tif ( ! renderTargetProperties.__hasExternalTextures ) {\n\n\t\t\tconst width = Math.max( 1, renderTarget.width >> level );\n\t\t\tconst height = Math.max( 1, renderTarget.height >> level );\n\n\t\t\tif ( textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY ) {\n\n\t\t\t\tstate.texImage3D( textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null );\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null );\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\tif ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, 0, getRenderTargetSamples( renderTarget ) );\n\n\t\t} else if ( textureTarget === _gl.TEXTURE_2D || ( textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z ) ) { // see #24753\n\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, level );\n\n\t\t}\n\n\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\tfunction setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\t// retrieve the depth attachment types\n\t\t\tconst depthTexture = renderTarget.depthTexture;\n\t\t\tconst depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;\n\t\t\tconst glInternalFormat = getInternalDepthFormat( renderTarget.stencilBuffer, depthType );\n\t\t\tconst glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;\n\n\t\t\t// set up the attachment\n\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\t\t\tconst isUseMultisampledRTT = useMultisampledRTT( renderTarget );\n\t\t\tif ( isUseMultisampledRTT ) {\n\n\t\t\t\tmultisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t} else if ( isMultisample ) {\n\n\t\t\t\t_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else {\n\n\t\t\tconst textures = renderTarget.textures;\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tconst glFormat = utils.convert( texture.format, texture.colorSpace );\n\t\t\t\tconst glType = utils.convert( texture.type );\n\t\t\t\tconst glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );\n\t\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\n\t\t\t\tif ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\t\t_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t} else if ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\t\t\tmultisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t}\n\n\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\tfunction setupDepthTexture( framebuffer, renderTarget ) {\n\n\t\tconst isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );\n\t\tif ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );\n\n\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\tif ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {\n\n\t\t\tthrow new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );\n\n\t\t}\n\n\t\tconst textureProperties = properties.get( renderTarget.depthTexture );\n\t\ttextureProperties.__renderTarget = renderTarget;\n\n\t\t// upload an empty depth texture with framebuffer size\n\t\tif ( ! textureProperties.__webglTexture ||\n\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\n\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\n\t\t}\n\n\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\tconst webglDepthTexture = textureProperties.__webglTexture;\n\t\tconst samples = getRenderTargetSamples( renderTarget );\n\n\t\tif ( renderTarget.depthTexture.format === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DepthFormat ) {\n\n\t\t\tif ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t}\n\n\t\t} else if ( renderTarget.depthTexture.format === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DepthStencilFormat ) {\n\n\t\t\tif ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'Unknown depthTexture format' );\n\n\t\t}\n\n\t}\n\n\t// Setup GL resources for a non-texture depth buffer\n\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\tconst isCube = ( renderTarget.isWebGLCubeRenderTarget === true );\n\n\t\t// if the bound depth texture has changed\n\t\tif ( renderTargetProperties.__boundDepthTexture !== renderTarget.depthTexture ) {\n\n\t\t\t// fire the dispose event to get rid of stored state associated with the previously bound depth buffer\n\t\t\tconst depthTexture = renderTarget.depthTexture;\n\t\t\tif ( renderTargetProperties.__depthDisposeCallback ) {\n\n\t\t\t\trenderTargetProperties.__depthDisposeCallback();\n\n\t\t\t}\n\n\t\t\t// set up dispose listeners to track when the currently attached buffer is implicitly unbound\n\t\t\tif ( depthTexture ) {\n\n\t\t\t\tconst disposeEvent = () => {\n\n\t\t\t\t\tdelete renderTargetProperties.__boundDepthTexture;\n\t\t\t\t\tdelete renderTargetProperties.__depthDisposeCallback;\n\t\t\t\t\tdepthTexture.removeEventListener( 'dispose', disposeEvent );\n\n\t\t\t\t};\n\n\t\t\t\tdepthTexture.addEventListener( 'dispose', disposeEvent );\n\t\t\t\trenderTargetProperties.__depthDisposeCallback = disposeEvent;\n\n\t\t\t}\n\n\t\t\trenderTargetProperties.__boundDepthTexture = depthTexture;\n\n\t\t}\n\n\t\tif ( renderTarget.depthTexture && ! renderTargetProperties.__autoAllocateDepthBuffer ) {\n\n\t\t\tif ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );\n\n\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t} else {\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\n\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer[ i ] === undefined ) {\n\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// attach buffer if it's been created already\n\t\t\t\t\t\tconst glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;\n\t\t\t\t\t\tconst renderbuffer = renderTargetProperties.__webglDepthbuffer[ i ];\n\t\t\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer === undefined ) {\n\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// attach buffer if it's been created already\n\t\t\t\t\tconst glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;\n\t\t\t\t\tconst renderbuffer = renderTargetProperties.__webglDepthbuffer;\n\t\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\t// rebind framebuffer with external textures\n\tfunction rebindTextures( renderTarget, colorTexture, depthTexture ) {\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\tif ( colorTexture !== undefined ) {\n\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0 );\n\n\t\t}\n\n\t\tif ( depthTexture !== undefined ) {\n\n\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t}\n\n\t}\n\n\t// Set up GL resources for the render target\n\tfunction setupRenderTarget( renderTarget ) {\n\n\t\tconst texture = renderTarget.texture;\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\tconst textureProperties = properties.get( texture );\n\n\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tconst textures = renderTarget.textures;\n\n\t\tconst isCube = ( renderTarget.isWebGLCubeRenderTarget === true );\n\t\tconst isMultipleRenderTargets = ( textures.length > 1 );\n\n\t\tif ( ! isMultipleRenderTargets ) {\n\n\t\t\tif ( textureProperties.__webglTexture === undefined ) {\n\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t}\n\n\t\t\ttextureProperties.__version = texture.version;\n\t\t\tinfo.memory.textures ++;\n\n\t\t}\n\n\t\t// Setup framebuffer\n\n\t\tif ( isCube ) {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( texture.mipmaps && texture.mipmaps.length > 0 ) {\n\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = [];\n\n\t\t\t\t\tfor ( let level = 0; level < texture.mipmaps.length; level ++ ) {\n\n\t\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ][ level ] = _gl.createFramebuffer();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( texture.mipmaps && texture.mipmaps.length > 0 ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\t\tfor ( let level = 0; level < texture.mipmaps.length; level ++ ) {\n\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ level ] = _gl.createFramebuffer();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t\tif ( isMultipleRenderTargets ) {\n\n\t\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst attachmentProperties = properties.get( textures[ i ] );\n\n\t\t\t\t\tif ( attachmentProperties.__webglTexture === undefined ) {\n\n\t\t\t\t\t\tattachmentProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t\t\t\tinfo.memory.textures ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ( renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\trenderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();\n\t\t\t\trenderTargetProperties.__webglColorRenderbuffer = [];\n\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\trenderTargetProperties.__webglColorRenderbuffer[ i ] = _gl.createRenderbuffer();\n\n\t\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t\tconst glFormat = utils.convert( texture.format, texture.colorSpace );\n\t\t\t\t\tconst glType = utils.convert( texture.type );\n\t\t\t\t\tconst glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, renderTarget.isXRRenderTarget === true );\n\t\t\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\t\t\t\t\t_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t\t\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\t\t\trenderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );\n\n\t\t\t\t}\n\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Setup color buffer\n\n\t\tif ( isCube ) {\n\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture );\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( texture.mipmaps && texture.mipmaps.length > 0 ) {\n\n\t\t\t\t\tfor ( let level = 0; level < texture.mipmaps.length; level ++ ) {\n\n\t\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ][ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture ) ) {\n\n\t\t\t\tgenerateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t} else if ( isMultipleRenderTargets ) {\n\n\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\tconst attachment = textures[ i ];\n\t\t\t\tconst attachmentProperties = properties.get( attachment );\n\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, attachmentProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, attachment );\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, 0 );\n\n\t\t\t\tif ( textureNeedsGenerateMipmaps( attachment ) ) {\n\n\t\t\t\t\tgenerateMipmap( _gl.TEXTURE_2D );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t} else {\n\n\t\t\tlet glTextureType = _gl.TEXTURE_2D;\n\n\t\t\tif ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {\n\n\t\t\t\tglTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;\n\n\t\t\t}\n\n\t\t\tstate.bindTexture( glTextureType, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( glTextureType, texture );\n\n\t\t\tif ( texture.mipmaps && texture.mipmaps.length > 0 ) {\n\n\t\t\t\tfor ( let level = 0; level < texture.mipmaps.length; level ++ ) {\n\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0 );\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture ) ) {\n\n\t\t\t\tgenerateMipmap( glTextureType );\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t}\n\n\t\t// Setup depth and stencil buffers\n\n\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t}\n\n\t}\n\n\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\tconst textures = renderTarget.textures;\n\n\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\tconst texture = textures[ i ];\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture ) ) {\n\n\t\t\t\tconst targetType = getTargetType( renderTarget );\n\t\t\t\tconst webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\t\tstate.bindTexture( targetType, webglTexture );\n\t\t\t\tgenerateMipmap( targetType );\n\t\t\t\tstate.unbindTexture();\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst invalidationArrayRead = [];\n\tconst invalidationArrayDraw = [];\n\n\tfunction updateMultisampleRenderTarget( renderTarget ) {\n\n\t\tif ( renderTarget.samples > 0 ) {\n\n\t\t\tif ( useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\tconst textures = renderTarget.textures;\n\t\t\t\tconst width = renderTarget.width;\n\t\t\t\tconst height = renderTarget.height;\n\t\t\t\tlet mask = _gl.COLOR_BUFFER_BIT;\n\t\t\t\tconst depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;\n\t\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\t\t\tconst isMultipleRenderTargets = ( textures.length > 1 );\n\n\t\t\t\t// If MRT we need to remove FBO attachments\n\t\t\t\tif ( isMultipleRenderTargets ) {\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null );\n\n\t\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\t\t_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tstate.bindFramebuffer( _gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\tif ( renderTarget.resolveDepthBuffer ) {\n\n\t\t\t\t\t\tif ( renderTarget.depthBuffer ) mask |= _gl.DEPTH_BUFFER_BIT;\n\n\t\t\t\t\t\t// resolving stencil is slow with a D3D backend. disable it for all transmission render targets (see #27799)\n\n\t\t\t\t\t\tif ( renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer ) mask |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( isMultipleRenderTargets ) {\n\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t\t\tconst webglTexture = properties.get( textures[ i ] ).__webglTexture;\n\t\t\t\t\t\t_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST );\n\n\t\t\t\t\tif ( supportsInvalidateFramebuffer === true ) {\n\n\t\t\t\t\t\tinvalidationArrayRead.length = 0;\n\t\t\t\t\t\tinvalidationArrayDraw.length = 0;\n\n\t\t\t\t\t\tinvalidationArrayRead.push( _gl.COLOR_ATTACHMENT0 + i );\n\n\t\t\t\t\t\tif ( renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false ) {\n\n\t\t\t\t\t\t\tinvalidationArrayRead.push( depthStyle );\n\t\t\t\t\t\t\tinvalidationArrayDraw.push( depthStyle );\n\n\t\t\t\t\t\t\t_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, invalidationArrayDraw );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.invalidateFramebuffer( _gl.READ_FRAMEBUFFER, invalidationArrayRead );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tstate.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );\n\t\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );\n\n\t\t\t\t// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments\n\t\t\t\tif ( isMultipleRenderTargets ) {\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t\t\tconst webglTexture = properties.get( textures[ i ] ).__webglTexture;\n\n\t\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\t\t_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\n\t\t\t} else {\n\n\t\t\t\tif ( renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer ) {\n\n\t\t\t\t\tconst depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;\n\n\t\t\t\t\t_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, [ depthStyle ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction getRenderTargetSamples( renderTarget ) {\n\n\t\treturn Math.min( capabilities.maxSamples, renderTarget.samples );\n\n\t}\n\n\tfunction useMultisampledRTT( renderTarget ) {\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\treturn renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;\n\n\t}\n\n\tfunction updateVideoTexture( texture ) {\n\n\t\tconst frame = info.render.frame;\n\n\t\t// Check the last frame we updated the VideoTexture\n\n\t\tif ( _videoTextures.get( texture ) !== frame ) {\n\n\t\t\t_videoTextures.set( texture, frame );\n\t\t\ttexture.update();\n\n\t\t}\n\n\t}\n\n\tfunction verifyColorSpace( texture, image ) {\n\n\t\tconst colorSpace = texture.colorSpace;\n\t\tconst format = texture.format;\n\t\tconst type = texture.type;\n\n\t\tif ( texture.isCompressedTexture === true || texture.isVideoTexture === true ) return image;\n\n\t\tif ( colorSpace !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace && colorSpace !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoColorSpace ) {\n\n\t\t\t// sRGB\n\n\t\t\tif ( _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.getTransfer( colorSpace ) === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) {\n\n\t\t\t\t// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format\n\n\t\t\t\tif ( format !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat || type !== _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.' );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.WebGLTextures: Unsupported texture color space:', colorSpace );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction getDimensions( image ) {\n\n\t\tif ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) {\n\n\t\t\t// if intrinsic data are not available, fallback to width/height\n\n\t\t\t_imageDimensions.width = image.naturalWidth || image.width;\n\t\t\t_imageDimensions.height = image.naturalHeight || image.height;\n\n\t\t} else if ( typeof VideoFrame !== 'undefined' && image instanceof VideoFrame ) {\n\n\t\t\t_imageDimensions.width = image.displayWidth;\n\t\t\t_imageDimensions.height = image.displayHeight;\n\n\t\t} else {\n\n\t\t\t_imageDimensions.width = image.width;\n\t\t\t_imageDimensions.height = image.height;\n\n\t\t}\n\n\t\treturn _imageDimensions;\n\n\t}\n\n\t//\n\n\tthis.allocateTextureUnit = allocateTextureUnit;\n\tthis.resetTextureUnits = resetTextureUnits;\n\n\tthis.setTexture2D = setTexture2D;\n\tthis.setTexture2DArray = setTexture2DArray;\n\tthis.setTexture3D = setTexture3D;\n\tthis.setTextureCube = setTextureCube;\n\tthis.rebindTextures = rebindTextures;\n\tthis.setupRenderTarget = setupRenderTarget;\n\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\tthis.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\n\tthis.setupDepthRenderbuffer = setupDepthRenderbuffer;\n\tthis.setupFrameBufferTexture = setupFrameBufferTexture;\n\tthis.useMultisampledRTT = useMultisampledRTT;\n\n}\n\nfunction WebGLUtils( gl, extensions ) {\n\n\tfunction convert( p, colorSpace = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoColorSpace ) {\n\n\t\tlet extension;\n\n\t\tconst transfer = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.getTransfer( colorSpace );\n\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType ) return gl.UNSIGNED_BYTE;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;\n\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ByteType ) return gl.BYTE;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ShortType ) return gl.SHORT;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedShortType ) return gl.UNSIGNED_SHORT;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.IntType ) return gl.INT;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType ) return gl.UNSIGNED_INT;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.FloatType ) return gl.FLOAT;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType ) return gl.HALF_FLOAT;\n\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.AlphaFormat ) return gl.ALPHA;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBFormat ) return gl.RGB;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat ) return gl.RGBA;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LuminanceFormat ) return gl.LUMINANCE;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DepthFormat ) return gl.DEPTH_COMPONENT;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DepthStencilFormat ) return gl.DEPTH_STENCIL;\n\n\t\t// WebGL2 formats.\n\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RedFormat ) return gl.RED;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RedIntegerFormat ) return gl.RED_INTEGER;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGFormat ) return gl.RG;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGIntegerFormat ) return gl.RG_INTEGER;\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBAIntegerFormat ) return gl.RGBA_INTEGER;\n\n\t\t// S3TC\n\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_S3TC_DXT1_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_S3TC_DXT1_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_S3TC_DXT3_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_S3TC_DXT5_Format ) {\n\n\t\t\tif ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// PVRTC\n\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_PVRTC_4BPPV1_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_PVRTC_2BPPV1_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_PVRTC_4BPPV1_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ETC\n\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_ETC1_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_ETC2_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ETC2_EAC_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_ETC1_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_ETC2_Format ) return ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ETC2_EAC_Format ) return ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ASTC\n\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_4x4_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_5x4_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_5x5_Format ||\n\t\t\tp === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_6x5_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_6x6_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_8x5_Format ||\n\t\t\tp === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_8x6_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_8x8_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_10x5_Format ||\n\t\t\tp === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_10x6_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_10x8_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_10x10_Format ||\n\t\t\tp === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_12x10_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_12x12_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_astc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_4x4_Format ) return ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_5x4_Format ) return ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_5x5_Format ) return ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_6x5_Format ) return ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_6x6_Format ) return ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_8x5_Format ) return ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_8x6_Format ) return ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_8x8_Format ) return ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_10x5_Format ) return ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_10x6_Format ) return ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_10x8_Format ) return ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_10x10_Format ) return ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_12x10_Format ) return ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_12x12_Format ) return ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// BPTC\n\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_BPTC_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_BPTC_SIGNED_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_BPTC_UNSIGNED_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_bptc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_BPTC_Format ) return ( transfer === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBTransfer ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_BPTC_SIGNED_Format ) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGB_BPTC_UNSIGNED_Format ) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// RGTC\n\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RED_RGTC1_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SIGNED_RED_RGTC1_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RED_GREEN_RGTC2_Format || p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SIGNED_RED_GREEN_RGTC2_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_rgtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;\n\t\t\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( p === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedInt248Type ) return gl.UNSIGNED_INT_24_8;\n\n\t\t// if \"p\" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)\n\n\t\treturn ( gl[ p ] !== undefined ) ? gl[ p ] : null;\n\n\t}\n\n\treturn { convert: convert };\n\n}\n\nconst _moveEvent = { type: 'move' };\n\nclass WebXRController {\n\n\tconstructor() {\n\n\t\tthis._targetRay = null;\n\t\tthis._grip = null;\n\t\tthis._hand = null;\n\n\t}\n\n\tgetHandSpace() {\n\n\t\tif ( this._hand === null ) {\n\n\t\t\tthis._hand = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Group();\n\t\t\tthis._hand.matrixAutoUpdate = false;\n\t\t\tthis._hand.visible = false;\n\n\t\t\tthis._hand.joints = {};\n\t\t\tthis._hand.inputState = { pinching: false };\n\n\t\t}\n\n\t\treturn this._hand;\n\n\t}\n\n\tgetTargetRaySpace() {\n\n\t\tif ( this._targetRay === null ) {\n\n\t\t\tthis._targetRay = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Group();\n\t\t\tthis._targetRay.matrixAutoUpdate = false;\n\t\t\tthis._targetRay.visible = false;\n\t\t\tthis._targetRay.hasLinearVelocity = false;\n\t\t\tthis._targetRay.linearVelocity = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\t\tthis._targetRay.hasAngularVelocity = false;\n\t\t\tthis._targetRay.angularVelocity = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t}\n\n\t\treturn this._targetRay;\n\n\t}\n\n\tgetGripSpace() {\n\n\t\tif ( this._grip === null ) {\n\n\t\t\tthis._grip = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Group();\n\t\t\tthis._grip.matrixAutoUpdate = false;\n\t\t\tthis._grip.visible = false;\n\t\t\tthis._grip.hasLinearVelocity = false;\n\t\t\tthis._grip.linearVelocity = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\t\tthis._grip.hasAngularVelocity = false;\n\t\t\tthis._grip.angularVelocity = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t}\n\n\t\treturn this._grip;\n\n\t}\n\n\tdispatchEvent( event ) {\n\n\t\tif ( this._targetRay !== null ) {\n\n\t\t\tthis._targetRay.dispatchEvent( event );\n\n\t\t}\n\n\t\tif ( this._grip !== null ) {\n\n\t\t\tthis._grip.dispatchEvent( event );\n\n\t\t}\n\n\t\tif ( this._hand !== null ) {\n\n\t\t\tthis._hand.dispatchEvent( event );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tconnect( inputSource ) {\n\n\t\tif ( inputSource && inputSource.hand ) {\n\n\t\t\tconst hand = this._hand;\n\n\t\t\tif ( hand ) {\n\n\t\t\t\tfor ( const inputjoint of inputSource.hand.values() ) {\n\n\t\t\t\t\t// Initialize hand with joints when connected\n\t\t\t\t\tthis._getHandJoint( hand, inputjoint );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.dispatchEvent( { type: 'connected', data: inputSource } );\n\n\t\treturn this;\n\n\t}\n\n\tdisconnect( inputSource ) {\n\n\t\tthis.dispatchEvent( { type: 'disconnected', data: inputSource } );\n\n\t\tif ( this._targetRay !== null ) {\n\n\t\t\tthis._targetRay.visible = false;\n\n\t\t}\n\n\t\tif ( this._grip !== null ) {\n\n\t\t\tthis._grip.visible = false;\n\n\t\t}\n\n\t\tif ( this._hand !== null ) {\n\n\t\t\tthis._hand.visible = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tupdate( inputSource, frame, referenceSpace ) {\n\n\t\tlet inputPose = null;\n\t\tlet gripPose = null;\n\t\tlet handPose = null;\n\n\t\tconst targetRay = this._targetRay;\n\t\tconst grip = this._grip;\n\t\tconst hand = this._hand;\n\n\t\tif ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {\n\n\t\t\tif ( hand && inputSource.hand ) {\n\n\t\t\t\thandPose = true;\n\n\t\t\t\tfor ( const inputjoint of inputSource.hand.values() ) {\n\n\t\t\t\t\t// Update the joints groups with the XRJoint poses\n\t\t\t\t\tconst jointPose = frame.getJointPose( inputjoint, referenceSpace );\n\n\t\t\t\t\t// The transform of this joint will be updated with the joint pose on each frame\n\t\t\t\t\tconst joint = this._getHandJoint( hand, inputjoint );\n\n\t\t\t\t\tif ( jointPose !== null ) {\n\n\t\t\t\t\t\tjoint.matrix.fromArray( jointPose.transform.matrix );\n\t\t\t\t\t\tjoint.matrix.decompose( joint.position, joint.rotation, joint.scale );\n\t\t\t\t\t\tjoint.matrixWorldNeedsUpdate = true;\n\t\t\t\t\t\tjoint.jointRadius = jointPose.radius;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tjoint.visible = jointPose !== null;\n\n\t\t\t\t}\n\n\t\t\t\t// Custom events\n\n\t\t\t\t// Check pinchz\n\t\t\t\tconst indexTip = hand.joints[ 'index-finger-tip' ];\n\t\t\t\tconst thumbTip = hand.joints[ 'thumb-tip' ];\n\t\t\t\tconst distance = indexTip.position.distanceTo( thumbTip.position );\n\n\t\t\t\tconst distanceToPinch = 0.02;\n\t\t\t\tconst threshold = 0.005;\n\n\t\t\t\tif ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {\n\n\t\t\t\t\thand.inputState.pinching = false;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'pinchend',\n\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\ttarget: this\n\t\t\t\t\t} );\n\n\t\t\t\t} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {\n\n\t\t\t\t\thand.inputState.pinching = true;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'pinchstart',\n\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\ttarget: this\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( grip !== null && inputSource.gripSpace ) {\n\n\t\t\t\t\tgripPose = frame.getPose( inputSource.gripSpace, referenceSpace );\n\n\t\t\t\t\tif ( gripPose !== null ) {\n\n\t\t\t\t\t\tgrip.matrix.fromArray( gripPose.transform.matrix );\n\t\t\t\t\t\tgrip.matrix.decompose( grip.position, grip.rotation, grip.scale );\n\t\t\t\t\t\tgrip.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t\t\tif ( gripPose.linearVelocity ) {\n\n\t\t\t\t\t\t\tgrip.hasLinearVelocity = true;\n\t\t\t\t\t\t\tgrip.linearVelocity.copy( gripPose.linearVelocity );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgrip.hasLinearVelocity = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( gripPose.angularVelocity ) {\n\n\t\t\t\t\t\t\tgrip.hasAngularVelocity = true;\n\t\t\t\t\t\t\tgrip.angularVelocity.copy( gripPose.angularVelocity );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgrip.hasAngularVelocity = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( targetRay !== null ) {\n\n\t\t\t\tinputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );\n\n\t\t\t\t// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it\n\t\t\t\tif ( inputPose === null && gripPose !== null ) {\n\n\t\t\t\t\tinputPose = gripPose;\n\n\t\t\t\t}\n\n\t\t\t\tif ( inputPose !== null ) {\n\n\t\t\t\t\ttargetRay.matrix.fromArray( inputPose.transform.matrix );\n\t\t\t\t\ttargetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );\n\t\t\t\t\ttargetRay.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t\tif ( inputPose.linearVelocity ) {\n\n\t\t\t\t\t\ttargetRay.hasLinearVelocity = true;\n\t\t\t\t\t\ttargetRay.linearVelocity.copy( inputPose.linearVelocity );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetRay.hasLinearVelocity = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( inputPose.angularVelocity ) {\n\n\t\t\t\t\t\ttargetRay.hasAngularVelocity = true;\n\t\t\t\t\t\ttargetRay.angularVelocity.copy( inputPose.angularVelocity );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetRay.hasAngularVelocity = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.dispatchEvent( _moveEvent );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tif ( targetRay !== null ) {\n\n\t\t\ttargetRay.visible = ( inputPose !== null );\n\n\t\t}\n\n\t\tif ( grip !== null ) {\n\n\t\t\tgrip.visible = ( gripPose !== null );\n\n\t\t}\n\n\t\tif ( hand !== null ) {\n\n\t\t\thand.visible = ( handPose !== null );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// private method\n\n\t_getHandJoint( hand, inputjoint ) {\n\n\t\tif ( hand.joints[ inputjoint.jointName ] === undefined ) {\n\n\t\t\tconst joint = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Group();\n\t\t\tjoint.matrixAutoUpdate = false;\n\t\t\tjoint.visible = false;\n\t\t\thand.joints[ inputjoint.jointName ] = joint;\n\n\t\t\thand.add( joint );\n\n\t\t}\n\n\t\treturn hand.joints[ inputjoint.jointName ];\n\n\t}\n\n}\n\nconst _occlusion_vertex = `\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}`;\n\nconst _occlusion_fragment = `\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}`;\n\nclass WebXRDepthSensing {\n\n\tconstructor() {\n\n\t\tthis.texture = null;\n\t\tthis.mesh = null;\n\n\t\tthis.depthNear = 0;\n\t\tthis.depthFar = 0;\n\n\t}\n\n\tinit( renderer, depthData, renderState ) {\n\n\t\tif ( this.texture === null ) {\n\n\t\t\tconst texture = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Texture();\n\n\t\t\tconst texProps = renderer.properties.get( texture );\n\t\t\ttexProps.__webglTexture = depthData.texture;\n\n\t\t\tif ( ( depthData.depthNear !== renderState.depthNear ) || ( depthData.depthFar !== renderState.depthFar ) ) {\n\n\t\t\t\tthis.depthNear = depthData.depthNear;\n\t\t\t\tthis.depthFar = depthData.depthFar;\n\n\t\t\t}\n\n\t\t\tthis.texture = texture;\n\n\t\t}\n\n\t}\n\n\tgetMesh( cameraXR ) {\n\n\t\tif ( this.texture !== null ) {\n\n\t\t\tif ( this.mesh === null ) {\n\n\t\t\t\tconst viewport = cameraXR.cameras[ 0 ].viewport;\n\t\t\t\tconst material = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial( {\n\t\t\t\t\tvertexShader: _occlusion_vertex,\n\t\t\t\t\tfragmentShader: _occlusion_fragment,\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tdepthColor: { value: this.texture },\n\t\t\t\t\t\tdepthWidth: { value: viewport.z },\n\t\t\t\t\t\tdepthHeight: { value: viewport.w }\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tthis.mesh = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Mesh( new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry( 20, 20 ), material );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this.mesh;\n\n\t}\n\n\treset() {\n\n\t\tthis.texture = null;\n\t\tthis.mesh = null;\n\n\t}\n\n\tgetDepthTexture() {\n\n\t\treturn this.texture;\n\n\t}\n\n}\n\nclass WebXRManager extends _three_core_js__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n\n\tconstructor( renderer, gl ) {\n\n\t\tsuper();\n\n\t\tconst scope = this;\n\n\t\tlet session = null;\n\n\t\tlet framebufferScaleFactor = 1.0;\n\n\t\tlet referenceSpace = null;\n\t\tlet referenceSpaceType = 'local-floor';\n\t\t// Set default foveation to maximum.\n\t\tlet foveation = 1.0;\n\t\tlet customReferenceSpace = null;\n\n\t\tlet pose = null;\n\t\tlet glBinding = null;\n\t\tlet glProjLayer = null;\n\t\tlet glBaseLayer = null;\n\t\tlet xrFrame = null;\n\n\t\tconst depthSensing = new WebXRDepthSensing();\n\t\tconst attributes = gl.getContextAttributes();\n\n\t\tlet initialRenderTarget = null;\n\t\tlet newRenderTarget = null;\n\n\t\tconst controllers = [];\n\t\tconst controllerInputSources = [];\n\n\t\tconst currentSize = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tlet currentPixelRatio = null;\n\n\t\t//\n\n\t\tconst cameraL = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera();\n\t\tcameraL.viewport = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector4();\n\n\t\tconst cameraR = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera();\n\t\tcameraR.viewport = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector4();\n\n\t\tconst cameras = [ cameraL, cameraR ];\n\n\t\tconst cameraXR = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ArrayCamera();\n\n\t\tlet _currentDepthNear = null;\n\t\tlet _currentDepthFar = null;\n\n\t\t//\n\n\t\tthis.cameraAutoUpdate = true;\n\t\tthis.enabled = false;\n\n\t\tthis.isPresenting = false;\n\n\t\tthis.getController = function ( index ) {\n\n\t\t\tlet controller = controllers[ index ];\n\n\t\t\tif ( controller === undefined ) {\n\n\t\t\t\tcontroller = new WebXRController();\n\t\t\t\tcontrollers[ index ] = controller;\n\n\t\t\t}\n\n\t\t\treturn controller.getTargetRaySpace();\n\n\t\t};\n\n\t\tthis.getControllerGrip = function ( index ) {\n\n\t\t\tlet controller = controllers[ index ];\n\n\t\t\tif ( controller === undefined ) {\n\n\t\t\t\tcontroller = new WebXRController();\n\t\t\t\tcontrollers[ index ] = controller;\n\n\t\t\t}\n\n\t\t\treturn controller.getGripSpace();\n\n\t\t};\n\n\t\tthis.getHand = function ( index ) {\n\n\t\t\tlet controller = controllers[ index ];\n\n\t\t\tif ( controller === undefined ) {\n\n\t\t\t\tcontroller = new WebXRController();\n\t\t\t\tcontrollers[ index ] = controller;\n\n\t\t\t}\n\n\t\t\treturn controller.getHandSpace();\n\n\t\t};\n\n\t\t//\n\n\t\tfunction onSessionEvent( event ) {\n\n\t\t\tconst controllerIndex = controllerInputSources.indexOf( event.inputSource );\n\n\t\t\tif ( controllerIndex === - 1 ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst controller = controllers[ controllerIndex ];\n\n\t\t\tif ( controller !== undefined ) {\n\n\t\t\t\tcontroller.update( event.inputSource, event.frame, customReferenceSpace || referenceSpace );\n\t\t\t\tcontroller.dispatchEvent( { type: event.type, data: event.inputSource } );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onSessionEnd() {\n\n\t\t\tsession.removeEventListener( 'select', onSessionEvent );\n\t\t\tsession.removeEventListener( 'selectstart', onSessionEvent );\n\t\t\tsession.removeEventListener( 'selectend', onSessionEvent );\n\t\t\tsession.removeEventListener( 'squeeze', onSessionEvent );\n\t\t\tsession.removeEventListener( 'squeezestart', onSessionEvent );\n\t\t\tsession.removeEventListener( 'squeezeend', onSessionEvent );\n\t\t\tsession.removeEventListener( 'end', onSessionEnd );\n\t\t\tsession.removeEventListener( 'inputsourceschange', onInputSourcesChange );\n\n\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\tconst inputSource = controllerInputSources[ i ];\n\n\t\t\t\tif ( inputSource === null ) continue;\n\n\t\t\t\tcontrollerInputSources[ i ] = null;\n\n\t\t\t\tcontrollers[ i ].disconnect( inputSource );\n\n\t\t\t}\n\n\t\t\t_currentDepthNear = null;\n\t\t\t_currentDepthFar = null;\n\n\t\t\tdepthSensing.reset();\n\n\t\t\t// restore framebuffer/rendering state\n\n\t\t\trenderer.setRenderTarget( initialRenderTarget );\n\n\t\t\tglBaseLayer = null;\n\t\t\tglProjLayer = null;\n\t\t\tglBinding = null;\n\t\t\tsession = null;\n\t\t\tnewRenderTarget = null;\n\n\t\t\t//\n\n\t\t\tanimation.stop();\n\n\t\t\tscope.isPresenting = false;\n\n\t\t\trenderer.setPixelRatio( currentPixelRatio );\n\t\t\trenderer.setSize( currentSize.width, currentSize.height, false );\n\n\t\t\tscope.dispatchEvent( { type: 'sessionend' } );\n\n\t\t}\n\n\t\tthis.setFramebufferScaleFactor = function ( value ) {\n\n\t\t\tframebufferScaleFactor = value;\n\n\t\t\tif ( scope.isPresenting === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.setReferenceSpaceType = function ( value ) {\n\n\t\t\treferenceSpaceType = value;\n\n\t\t\tif ( scope.isPresenting === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getReferenceSpace = function () {\n\n\t\t\treturn customReferenceSpace || referenceSpace;\n\n\t\t};\n\n\t\tthis.setReferenceSpace = function ( space ) {\n\n\t\t\tcustomReferenceSpace = space;\n\n\t\t};\n\n\t\tthis.getBaseLayer = function () {\n\n\t\t\treturn glProjLayer !== null ? glProjLayer : glBaseLayer;\n\n\t\t};\n\n\t\tthis.getBinding = function () {\n\n\t\t\treturn glBinding;\n\n\t\t};\n\n\t\tthis.getFrame = function () {\n\n\t\t\treturn xrFrame;\n\n\t\t};\n\n\t\tthis.getSession = function () {\n\n\t\t\treturn session;\n\n\t\t};\n\n\t\tthis.setSession = async function ( value ) {\n\n\t\t\tsession = value;\n\n\t\t\tif ( session !== null ) {\n\n\t\t\t\tinitialRenderTarget = renderer.getRenderTarget();\n\n\t\t\t\tsession.addEventListener( 'select', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'selectstart', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'selectend', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'squeeze', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'squeezestart', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'squeezeend', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'end', onSessionEnd );\n\t\t\t\tsession.addEventListener( 'inputsourceschange', onInputSourcesChange );\n\n\t\t\t\tif ( attributes.xrCompatible !== true ) {\n\n\t\t\t\t\tawait gl.makeXRCompatible();\n\n\t\t\t\t}\n\n\t\t\t\tcurrentPixelRatio = renderer.getPixelRatio();\n\t\t\t\trenderer.getSize( currentSize );\n\n\t\t\t\tconst useLayers = session.enabledFeatures !== undefined && session.enabledFeatures.includes( 'layers' );\n\n\t\t\t\tif ( ! useLayers ) {\n\n\t\t\t\t\tconst layerInit = {\n\t\t\t\t\t\tantialias: attributes.antialias,\n\t\t\t\t\t\talpha: true,\n\t\t\t\t\t\tdepth: attributes.depth,\n\t\t\t\t\t\tstencil: attributes.stencil,\n\t\t\t\t\t\tframebufferScaleFactor: framebufferScaleFactor\n\t\t\t\t\t};\n\n\t\t\t\t\tglBaseLayer = new XRWebGLLayer( session, gl, layerInit );\n\n\t\t\t\t\tsession.updateRenderState( { baseLayer: glBaseLayer } );\n\n\t\t\t\t\trenderer.setPixelRatio( 1 );\n\t\t\t\t\trenderer.setSize( glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false );\n\n\t\t\t\t\tnewRenderTarget = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(\n\t\t\t\t\t\tglBaseLayer.framebufferWidth,\n\t\t\t\t\t\tglBaseLayer.framebufferHeight,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tformat: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,\n\t\t\t\t\t\t\ttype: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType,\n\t\t\t\t\t\t\tcolorSpace: renderer.outputColorSpace,\n\t\t\t\t\t\t\tstencilBuffer: attributes.stencil\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlet depthFormat = null;\n\t\t\t\t\tlet depthType = null;\n\t\t\t\t\tlet glDepthFormat = null;\n\n\t\t\t\t\tif ( attributes.depth ) {\n\n\t\t\t\t\t\tglDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;\n\t\t\t\t\t\tdepthFormat = attributes.stencil ? _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DepthStencilFormat : _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DepthFormat;\n\t\t\t\t\t\tdepthType = attributes.stencil ? _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedInt248Type : _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst projectionlayerInit = {\n\t\t\t\t\t\tcolorFormat: gl.RGBA8,\n\t\t\t\t\t\tdepthFormat: glDepthFormat,\n\t\t\t\t\t\tscaleFactor: framebufferScaleFactor\n\t\t\t\t\t};\n\n\t\t\t\t\tglBinding = new XRWebGLBinding( session, gl );\n\n\t\t\t\t\tglProjLayer = glBinding.createProjectionLayer( projectionlayerInit );\n\n\t\t\t\t\tsession.updateRenderState( { layers: [ glProjLayer ] } );\n\n\t\t\t\t\trenderer.setPixelRatio( 1 );\n\t\t\t\t\trenderer.setSize( glProjLayer.textureWidth, glProjLayer.textureHeight, false );\n\n\t\t\t\t\tnewRenderTarget = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(\n\t\t\t\t\t\tglProjLayer.textureWidth,\n\t\t\t\t\t\tglProjLayer.textureHeight,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tformat: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,\n\t\t\t\t\t\t\ttype: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType,\n\t\t\t\t\t\t\tdepthTexture: new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),\n\t\t\t\t\t\t\tstencilBuffer: attributes.stencil,\n\t\t\t\t\t\t\tcolorSpace: renderer.outputColorSpace,\n\t\t\t\t\t\t\tsamples: attributes.antialias ? 4 : 0,\n\t\t\t\t\t\t\tresolveDepthBuffer: ( glProjLayer.ignoreDepthValues === false )\n\t\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tnewRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278\n\n\t\t\t\tthis.setFoveation( foveation );\n\n\t\t\t\tcustomReferenceSpace = null;\n\t\t\t\treferenceSpace = await session.requestReferenceSpace( referenceSpaceType );\n\n\t\t\t\tanimation.setContext( session );\n\t\t\t\tanimation.start();\n\n\t\t\t\tscope.isPresenting = true;\n\n\t\t\t\tscope.dispatchEvent( { type: 'sessionstart' } );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getEnvironmentBlendMode = function () {\n\n\t\t\tif ( session !== null ) {\n\n\t\t\t\treturn session.environmentBlendMode;\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getDepthTexture = function () {\n\n\t\t\treturn depthSensing.getDepthTexture();\n\n\t\t};\n\n\t\tfunction onInputSourcesChange( event ) {\n\n\t\t\t// Notify disconnected\n\n\t\t\tfor ( let i = 0; i < event.removed.length; i ++ ) {\n\n\t\t\t\tconst inputSource = event.removed[ i ];\n\t\t\t\tconst index = controllerInputSources.indexOf( inputSource );\n\n\t\t\t\tif ( index >= 0 ) {\n\n\t\t\t\t\tcontrollerInputSources[ index ] = null;\n\t\t\t\t\tcontrollers[ index ].disconnect( inputSource );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Notify connected\n\n\t\t\tfor ( let i = 0; i < event.added.length; i ++ ) {\n\n\t\t\t\tconst inputSource = event.added[ i ];\n\n\t\t\t\tlet controllerIndex = controllerInputSources.indexOf( inputSource );\n\n\t\t\t\tif ( controllerIndex === - 1 ) {\n\n\t\t\t\t\t// Assign input source a controller that currently has no input source\n\n\t\t\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\t\t\tif ( i >= controllerInputSources.length ) {\n\n\t\t\t\t\t\t\tcontrollerInputSources.push( inputSource );\n\t\t\t\t\t\t\tcontrollerIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} else if ( controllerInputSources[ i ] === null ) {\n\n\t\t\t\t\t\t\tcontrollerInputSources[ i ] = inputSource;\n\t\t\t\t\t\t\tcontrollerIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// If all controllers do currently receive input we ignore new ones\n\n\t\t\t\t\tif ( controllerIndex === - 1 ) break;\n\n\t\t\t\t}\n\n\t\t\t\tconst controller = controllers[ controllerIndex ];\n\n\t\t\t\tif ( controller ) {\n\n\t\t\t\t\tcontroller.connect( inputSource );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst cameraLPos = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst cameraRPos = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t/**\n\t\t * Assumes 2 cameras that are parallel and share an X-axis, and that\n\t\t * the cameras' projection and world matrices have already been set.\n\t\t * And that near and far planes are identical for both cameras.\n\t\t * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n\t\t *\n\t\t * @param {ArrayCamera} camera - The camera to update.\n\t\t * @param {PerspectiveCamera} cameraL - The left camera.\n\t\t * @param {PerspectiveCamera} cameraR - The right camera.\n\t\t */\n\t\tfunction setProjectionFromUnion( camera, cameraL, cameraR ) {\n\n\t\t\tcameraLPos.setFromMatrixPosition( cameraL.matrixWorld );\n\t\t\tcameraRPos.setFromMatrixPosition( cameraR.matrixWorld );\n\n\t\t\tconst ipd = cameraLPos.distanceTo( cameraRPos );\n\n\t\t\tconst projL = cameraL.projectionMatrix.elements;\n\t\t\tconst projR = cameraR.projectionMatrix.elements;\n\n\t\t\t// VR systems will have identical far and near planes, and\n\t\t\t// most likely identical top and bottom frustum extents.\n\t\t\t// Use the left camera for these values.\n\t\t\tconst near = projL[ 14 ] / ( projL[ 10 ] - 1 );\n\t\t\tconst far = projL[ 14 ] / ( projL[ 10 ] + 1 );\n\t\t\tconst topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];\n\t\t\tconst bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];\n\n\t\t\tconst leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];\n\t\t\tconst rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];\n\t\t\tconst left = near * leftFov;\n\t\t\tconst right = near * rightFov;\n\n\t\t\t// Calculate the new camera's position offset from the\n\t\t\t// left camera. xOffset should be roughly half `ipd`.\n\t\t\tconst zOffset = ipd / ( - leftFov + rightFov );\n\t\t\tconst xOffset = zOffset * - leftFov;\n\n\t\t\t// TODO: Better way to apply this offset?\n\t\t\tcameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );\n\t\t\tcamera.translateX( xOffset );\n\t\t\tcamera.translateZ( zOffset );\n\t\t\tcamera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );\n\t\t\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\n\n\t\t\t// Check if the projection uses an infinite far plane.\n\t\t\tif ( projL[ 10 ] === - 1.0 ) {\n\n\t\t\t\t// Use the projection matrix from the left eye.\n\t\t\t\t// The camera offset is sufficient to include the view volumes\n\t\t\t\t// of both eyes (assuming symmetric projections).\n\t\t\t\tcamera.projectionMatrix.copy( cameraL.projectionMatrix );\n\t\t\t\tcamera.projectionMatrixInverse.copy( cameraL.projectionMatrixInverse );\n\n\t\t\t} else {\n\n\t\t\t\t// Find the union of the frustum values of the cameras and scale\n\t\t\t\t// the values so that the near plane's position does not change in world space,\n\t\t\t\t// although must now be relative to the new union camera.\n\t\t\t\tconst near2 = near + zOffset;\n\t\t\t\tconst far2 = far + zOffset;\n\t\t\t\tconst left2 = left - xOffset;\n\t\t\t\tconst right2 = right + ( ipd - xOffset );\n\t\t\t\tconst top2 = topFov * far / far2 * near2;\n\t\t\t\tconst bottom2 = bottomFov * far / far2 * near2;\n\n\t\t\t\tcamera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );\n\t\t\t\tcamera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction updateCamera( camera, parent ) {\n\n\t\t\tif ( parent === null ) {\n\n\t\t\t\tcamera.matrixWorld.copy( camera.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tcamera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );\n\n\t\t\t}\n\n\t\t\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\n\n\t\t}\n\n\t\tthis.updateCamera = function ( camera ) {\n\n\t\t\tif ( session === null ) return;\n\n\t\t\tlet depthNear = camera.near;\n\t\t\tlet depthFar = camera.far;\n\n\t\t\tif ( depthSensing.texture !== null ) {\n\n\t\t\t\tif ( depthSensing.depthNear > 0 ) depthNear = depthSensing.depthNear;\n\t\t\t\tif ( depthSensing.depthFar > 0 ) depthFar = depthSensing.depthFar;\n\n\t\t\t}\n\n\t\t\tcameraXR.near = cameraR.near = cameraL.near = depthNear;\n\t\t\tcameraXR.far = cameraR.far = cameraL.far = depthFar;\n\n\t\t\tif ( _currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far ) {\n\n\t\t\t\t// Note that the new renderState won't apply until the next frame. See #18320\n\n\t\t\t\tsession.updateRenderState( {\n\t\t\t\t\tdepthNear: cameraXR.near,\n\t\t\t\t\tdepthFar: cameraXR.far\n\t\t\t\t} );\n\n\t\t\t\t_currentDepthNear = cameraXR.near;\n\t\t\t\t_currentDepthFar = cameraXR.far;\n\n\t\t\t}\n\n\t\t\tcameraL.layers.mask = camera.layers.mask | 0b010;\n\t\t\tcameraR.layers.mask = camera.layers.mask | 0b100;\n\t\t\tcameraXR.layers.mask = cameraL.layers.mask | cameraR.layers.mask;\n\n\t\t\tconst parent = camera.parent;\n\t\t\tconst cameras = cameraXR.cameras;\n\n\t\t\tupdateCamera( cameraXR, parent );\n\n\t\t\tfor ( let i = 0; i < cameras.length; i ++ ) {\n\n\t\t\t\tupdateCamera( cameras[ i ], parent );\n\n\t\t\t}\n\n\t\t\t// update projection matrix for proper view frustum culling\n\n\t\t\tif ( cameras.length === 2 ) {\n\n\t\t\t\tsetProjectionFromUnion( cameraXR, cameraL, cameraR );\n\n\t\t\t} else {\n\n\t\t\t\t// assume single camera setup (AR)\n\n\t\t\t\tcameraXR.projectionMatrix.copy( cameraL.projectionMatrix );\n\n\t\t\t}\n\n\t\t\t// update user camera and its children\n\n\t\t\tupdateUserCamera( camera, cameraXR, parent );\n\n\t\t};\n\n\t\tfunction updateUserCamera( camera, cameraXR, parent ) {\n\n\t\t\tif ( parent === null ) {\n\n\t\t\t\tcamera.matrix.copy( cameraXR.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tcamera.matrix.copy( parent.matrixWorld );\n\t\t\t\tcamera.matrix.invert();\n\t\t\t\tcamera.matrix.multiply( cameraXR.matrixWorld );\n\n\t\t\t}\n\n\t\t\tcamera.matrix.decompose( camera.position, camera.quaternion, camera.scale );\n\t\t\tcamera.updateMatrixWorld( true );\n\n\t\t\tcamera.projectionMatrix.copy( cameraXR.projectionMatrix );\n\t\t\tcamera.projectionMatrixInverse.copy( cameraXR.projectionMatrixInverse );\n\n\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\tcamera.fov = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RAD2DEG * 2 * Math.atan( 1 / camera.projectionMatrix.elements[ 5 ] );\n\t\t\t\tcamera.zoom = 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.getCamera = function () {\n\n\t\t\treturn cameraXR;\n\n\t\t};\n\n\t\tthis.getFoveation = function () {\n\n\t\t\tif ( glProjLayer === null && glBaseLayer === null ) {\n\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\treturn foveation;\n\n\t\t};\n\n\t\tthis.setFoveation = function ( value ) {\n\n\t\t\t// 0 = no foveation = full resolution\n\t\t\t// 1 = maximum foveation = the edges render at lower resolution\n\n\t\t\tfoveation = value;\n\n\t\t\tif ( glProjLayer !== null ) {\n\n\t\t\t\tglProjLayer.fixedFoveation = value;\n\n\t\t\t}\n\n\t\t\tif ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {\n\n\t\t\t\tglBaseLayer.fixedFoveation = value;\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.hasDepthSensing = function () {\n\n\t\t\treturn depthSensing.texture !== null;\n\n\t\t};\n\n\t\tthis.getDepthSensingMesh = function () {\n\n\t\t\treturn depthSensing.getMesh( cameraXR );\n\n\t\t};\n\n\t\t// Animation Loop\n\n\t\tlet onAnimationFrameCallback = null;\n\n\t\tfunction onAnimationFrame( time, frame ) {\n\n\t\t\tpose = frame.getViewerPose( customReferenceSpace || referenceSpace );\n\t\t\txrFrame = frame;\n\n\t\t\tif ( pose !== null ) {\n\n\t\t\t\tconst views = pose.views;\n\n\t\t\t\tif ( glBaseLayer !== null ) {\n\n\t\t\t\t\trenderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );\n\t\t\t\t\trenderer.setRenderTarget( newRenderTarget );\n\n\t\t\t\t}\n\n\t\t\t\tlet cameraXRNeedsUpdate = false;\n\n\t\t\t\t// check if it's necessary to rebuild cameraXR's camera list\n\n\t\t\t\tif ( views.length !== cameraXR.cameras.length ) {\n\n\t\t\t\t\tcameraXR.cameras.length = 0;\n\t\t\t\t\tcameraXRNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < views.length; i ++ ) {\n\n\t\t\t\t\tconst view = views[ i ];\n\n\t\t\t\t\tlet viewport = null;\n\n\t\t\t\t\tif ( glBaseLayer !== null ) {\n\n\t\t\t\t\t\tviewport = glBaseLayer.getViewport( view );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst glSubImage = glBinding.getViewSubImage( glProjLayer, view );\n\t\t\t\t\t\tviewport = glSubImage.viewport;\n\n\t\t\t\t\t\t// For side-by-side projection, we only produce a single texture for both eyes.\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\trenderer.setRenderTargetTextures(\n\t\t\t\t\t\t\t\tnewRenderTarget,\n\t\t\t\t\t\t\t\tglSubImage.colorTexture,\n\t\t\t\t\t\t\t\tglProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture );\n\n\t\t\t\t\t\t\trenderer.setRenderTarget( newRenderTarget );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet camera = cameras[ i ];\n\n\t\t\t\t\tif ( camera === undefined ) {\n\n\t\t\t\t\t\tcamera = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera();\n\t\t\t\t\t\tcamera.layers.enable( i );\n\t\t\t\t\t\tcamera.viewport = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector4();\n\t\t\t\t\t\tcameras[ i ] = camera;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcamera.matrix.fromArray( view.transform.matrix );\n\t\t\t\t\tcamera.matrix.decompose( camera.position, camera.quaternion, camera.scale );\n\t\t\t\t\tcamera.projectionMatrix.fromArray( view.projectionMatrix );\n\t\t\t\t\tcamera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();\n\t\t\t\t\tcamera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );\n\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tcameraXR.matrix.copy( camera.matrix );\n\t\t\t\t\t\tcameraXR.matrix.decompose( cameraXR.position, cameraXR.quaternion, cameraXR.scale );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( cameraXRNeedsUpdate === true ) {\n\n\t\t\t\t\t\tcameraXR.cameras.push( camera );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tconst enabledFeatures = session.enabledFeatures;\n\n\t\t\t\tif ( enabledFeatures && enabledFeatures.includes( 'depth-sensing' ) ) {\n\n\t\t\t\t\tconst depthData = glBinding.getDepthInformation( views[ 0 ] );\n\n\t\t\t\t\tif ( depthData && depthData.isValid && depthData.texture ) {\n\n\t\t\t\t\t\tdepthSensing.init( renderer, depthData, session.renderState );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\tconst inputSource = controllerInputSources[ i ];\n\t\t\t\tconst controller = controllers[ i ];\n\n\t\t\t\tif ( inputSource !== null && controller !== undefined ) {\n\n\t\t\t\t\tcontroller.update( inputSource, frame, customReferenceSpace || referenceSpace );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );\n\n\t\t\tif ( frame.detectedPlanes ) {\n\n\t\t\t\tscope.dispatchEvent( { type: 'planesdetected', data: frame } );\n\n\t\t\t}\n\n\t\t\txrFrame = null;\n\n\t\t}\n\n\t\tconst animation = new WebGLAnimation();\n\n\t\tanimation.setAnimationLoop( onAnimationFrame );\n\n\t\tthis.setAnimationLoop = function ( callback ) {\n\n\t\t\tonAnimationFrameCallback = callback;\n\n\t\t};\n\n\t\tthis.dispose = function () {};\n\n\t}\n\n}\n\nconst _e1 = /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Euler();\nconst _m1 = /*@__PURE__*/ new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\nfunction WebGLMaterials( renderer, properties ) {\n\n\tfunction refreshTransformUniform( map, uniform ) {\n\n\t\tif ( map.matrixAutoUpdate === true ) {\n\n\t\t\tmap.updateMatrix();\n\n\t\t}\n\n\t\tuniform.value.copy( map.matrix );\n\n\t}\n\n\tfunction refreshFogUniforms( uniforms, fog ) {\n\n\t\tfog.color.getRGB( uniforms.fogColor.value, (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnlitUniformColorSpace)( renderer ) );\n\n\t\tif ( fog.isFog ) {\n\n\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t} else if ( fog.isFogExp2 ) {\n\n\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t}\n\n\t}\n\n\tfunction refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {\n\n\t\tif ( material.isMeshBasicMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t} else if ( material.isMeshLambertMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t} else if ( material.isMeshToonMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsToon( uniforms, material );\n\n\t\t} else if ( material.isMeshPhongMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsPhong( uniforms, material );\n\n\t\t} else if ( material.isMeshStandardMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsStandard( uniforms, material );\n\n\t\t\tif ( material.isMeshPhysicalMaterial ) {\n\n\t\t\t\trefreshUniformsPhysical( uniforms, material, transmissionRenderTarget );\n\n\t\t\t}\n\n\t\t} else if ( material.isMeshMatcapMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsMatcap( uniforms, material );\n\n\t\t} else if ( material.isMeshDepthMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t} else if ( material.isMeshDistanceMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsDistance( uniforms, material );\n\n\t\t} else if ( material.isMeshNormalMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t} else if ( material.isLineBasicMaterial ) {\n\n\t\t\trefreshUniformsLine( uniforms, material );\n\n\t\t\tif ( material.isLineDashedMaterial ) {\n\n\t\t\t\trefreshUniformsDash( uniforms, material );\n\n\t\t\t}\n\n\t\t} else if ( material.isPointsMaterial ) {\n\n\t\t\trefreshUniformsPoints( uniforms, material, pixelRatio, height );\n\n\t\t} else if ( material.isSpriteMaterial ) {\n\n\t\t\trefreshUniformsSprites( uniforms, material );\n\n\t\t} else if ( material.isShadowMaterial ) {\n\n\t\t\tuniforms.color.value.copy( material.color );\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t} else if ( material.isShaderMaterial ) {\n\n\t\t\tmaterial.uniformsNeedUpdate = false; // #15581\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsCommon( uniforms, material ) {\n\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tif ( material.color ) {\n\n\t\t\tuniforms.diffuse.value.copy( material.color );\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t}\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\trefreshTransformUniform( material.map, uniforms.mapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\trefreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\n\t\t\trefreshTransformUniform( material.bumpMap, uniforms.bumpMapTransform );\n\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t\tif ( material.side === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BackSide ) {\n\n\t\t\t\tuniforms.bumpScale.value *= - 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\n\t\t\trefreshTransformUniform( material.normalMap, uniforms.normalMapTransform );\n\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t\tif ( material.side === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BackSide ) {\n\n\t\t\t\tuniforms.normalScale.value.negate();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\n\t\t\trefreshTransformUniform( material.displacementMap, uniforms.displacementMapTransform );\n\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\trefreshTransformUniform( material.emissiveMap, uniforms.emissiveMapTransform );\n\n\t\t}\n\n\t\tif ( material.specularMap ) {\n\n\t\t\tuniforms.specularMap.value = material.specularMap;\n\n\t\t\trefreshTransformUniform( material.specularMap, uniforms.specularMapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaTest > 0 ) {\n\n\t\t\tuniforms.alphaTest.value = material.alphaTest;\n\n\t\t}\n\n\t\tconst materialProperties = properties.get( material );\n\n\t\tconst envMap = materialProperties.envMap;\n\t\tconst envMapRotation = materialProperties.envMapRotation;\n\n\t\tif ( envMap ) {\n\n\t\t\tuniforms.envMap.value = envMap;\n\n\t\t\t_e1.copy( envMapRotation );\n\n\t\t\t// accommodate left-handed frame\n\t\t\t_e1.x *= - 1; _e1.y *= - 1; _e1.z *= - 1;\n\n\t\t\tif ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) {\n\n\t\t\t\t// environment maps which are not cube render targets or PMREMs follow a different convention\n\t\t\t\t_e1.y *= - 1;\n\t\t\t\t_e1.z *= - 1;\n\n\t\t\t}\n\n\t\t\tuniforms.envMapRotation.value.setFromMatrix4( _m1.makeRotationFromEuler( _e1 ) );\n\n\t\t\tuniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;\n\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\tuniforms.ior.value = material.ior;\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t}\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\trefreshTransformUniform( material.lightMap, uniforms.lightMapTransform );\n\n\t\t}\n\n\t\tif ( material.aoMap ) {\n\n\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t\trefreshTransformUniform( material.aoMap, uniforms.aoMapTransform );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsLine( uniforms, material ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\trefreshTransformUniform( material.map, uniforms.mapTransform );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsDash( uniforms, material ) {\n\n\t\tuniforms.dashSize.value = material.dashSize;\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\tuniforms.scale.value = material.scale;\n\n\t}\n\n\tfunction refreshUniformsPoints( uniforms, material, pixelRatio, height ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.size.value = material.size * pixelRatio;\n\t\tuniforms.scale.value = height * 0.5;\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\trefreshTransformUniform( material.map, uniforms.uvTransform );\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\trefreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaTest > 0 ) {\n\n\t\t\tuniforms.alphaTest.value = material.alphaTest;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsSprites( uniforms, material ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.rotation.value = material.rotation;\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\trefreshTransformUniform( material.map, uniforms.mapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\trefreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaTest > 0 ) {\n\n\t\t\tuniforms.alphaTest.value = material.alphaTest;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhong( uniforms, material ) {\n\n\t\tuniforms.specular.value.copy( material.specular );\n\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t}\n\n\tfunction refreshUniformsToon( uniforms, material ) {\n\n\t\tif ( material.gradientMap ) {\n\n\t\t\tuniforms.gradientMap.value = material.gradientMap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsStandard( uniforms, material ) {\n\n\t\tuniforms.metalness.value = material.metalness;\n\n\t\tif ( material.metalnessMap ) {\n\n\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t\trefreshTransformUniform( material.metalnessMap, uniforms.metalnessMapTransform );\n\n\t\t}\n\n\t\tuniforms.roughness.value = material.roughness;\n\n\t\tif ( material.roughnessMap ) {\n\n\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t\trefreshTransformUniform( material.roughnessMap, uniforms.roughnessMapTransform );\n\n\t\t}\n\n\t\tif ( material.envMap ) {\n\n\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\n\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {\n\n\t\tuniforms.ior.value = material.ior; // also part of uniforms common\n\n\t\tif ( material.sheen > 0 ) {\n\n\t\t\tuniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );\n\n\t\t\tuniforms.sheenRoughness.value = material.sheenRoughness;\n\n\t\t\tif ( material.sheenColorMap ) {\n\n\t\t\t\tuniforms.sheenColorMap.value = material.sheenColorMap;\n\n\t\t\t\trefreshTransformUniform( material.sheenColorMap, uniforms.sheenColorMapTransform );\n\n\t\t\t}\n\n\t\t\tif ( material.sheenRoughnessMap ) {\n\n\t\t\t\tuniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;\n\n\t\t\t\trefreshTransformUniform( material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.clearcoat > 0 ) {\n\n\t\t\tuniforms.clearcoat.value = material.clearcoat;\n\t\t\tuniforms.clearcoatRoughness.value = material.clearcoatRoughness;\n\n\t\t\tif ( material.clearcoatMap ) {\n\n\t\t\t\tuniforms.clearcoatMap.value = material.clearcoatMap;\n\n\t\t\t\trefreshTransformUniform( material.clearcoatMap, uniforms.clearcoatMapTransform );\n\n\t\t\t}\n\n\t\t\tif ( material.clearcoatRoughnessMap ) {\n\n\t\t\t\tuniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;\n\n\t\t\t\trefreshTransformUniform( material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform );\n\n\t\t\t}\n\n\t\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\t\tuniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;\n\n\t\t\t\trefreshTransformUniform( material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform );\n\n\t\t\t\tuniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );\n\n\t\t\t\tif ( material.side === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BackSide ) {\n\n\t\t\t\t\tuniforms.clearcoatNormalScale.value.negate();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.dispersion > 0 ) {\n\n\t\t\tuniforms.dispersion.value = material.dispersion;\n\n\t\t}\n\n\t\tif ( material.iridescence > 0 ) {\n\n\t\t\tuniforms.iridescence.value = material.iridescence;\n\t\t\tuniforms.iridescenceIOR.value = material.iridescenceIOR;\n\t\t\tuniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[ 0 ];\n\t\t\tuniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[ 1 ];\n\n\t\t\tif ( material.iridescenceMap ) {\n\n\t\t\t\tuniforms.iridescenceMap.value = material.iridescenceMap;\n\n\t\t\t\trefreshTransformUniform( material.iridescenceMap, uniforms.iridescenceMapTransform );\n\n\t\t\t}\n\n\t\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\t\tuniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;\n\n\t\t\t\trefreshTransformUniform( material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.transmission > 0 ) {\n\n\t\t\tuniforms.transmission.value = material.transmission;\n\t\t\tuniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;\n\t\t\tuniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );\n\n\t\t\tif ( material.transmissionMap ) {\n\n\t\t\t\tuniforms.transmissionMap.value = material.transmissionMap;\n\n\t\t\t\trefreshTransformUniform( material.transmissionMap, uniforms.transmissionMapTransform );\n\n\t\t\t}\n\n\t\t\tuniforms.thickness.value = material.thickness;\n\n\t\t\tif ( material.thicknessMap ) {\n\n\t\t\t\tuniforms.thicknessMap.value = material.thicknessMap;\n\n\t\t\t\trefreshTransformUniform( material.thicknessMap, uniforms.thicknessMapTransform );\n\n\t\t\t}\n\n\t\t\tuniforms.attenuationDistance.value = material.attenuationDistance;\n\t\t\tuniforms.attenuationColor.value.copy( material.attenuationColor );\n\n\t\t}\n\n\t\tif ( material.anisotropy > 0 ) {\n\n\t\t\tuniforms.anisotropyVector.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );\n\n\t\t\tif ( material.anisotropyMap ) {\n\n\t\t\t\tuniforms.anisotropyMap.value = material.anisotropyMap;\n\n\t\t\t\trefreshTransformUniform( material.anisotropyMap, uniforms.anisotropyMapTransform );\n\n\t\t\t}\n\n\t\t}\n\n\t\tuniforms.specularIntensity.value = material.specularIntensity;\n\t\tuniforms.specularColor.value.copy( material.specularColor );\n\n\t\tif ( material.specularColorMap ) {\n\n\t\t\tuniforms.specularColorMap.value = material.specularColorMap;\n\n\t\t\trefreshTransformUniform( material.specularColorMap, uniforms.specularColorMapTransform );\n\n\t\t}\n\n\t\tif ( material.specularIntensityMap ) {\n\n\t\t\tuniforms.specularIntensityMap.value = material.specularIntensityMap;\n\n\t\t\trefreshTransformUniform( material.specularIntensityMap, uniforms.specularIntensityMapTransform );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsMatcap( uniforms, material ) {\n\n\t\tif ( material.matcap ) {\n\n\t\t\tuniforms.matcap.value = material.matcap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsDistance( uniforms, material ) {\n\n\t\tconst light = properties.get( material ).light;\n\n\t\tuniforms.referencePosition.value.setFromMatrixPosition( light.matrixWorld );\n\t\tuniforms.nearDistance.value = light.shadow.camera.near;\n\t\tuniforms.farDistance.value = light.shadow.camera.far;\n\n\t}\n\n\treturn {\n\t\trefreshFogUniforms: refreshFogUniforms,\n\t\trefreshMaterialUniforms: refreshMaterialUniforms\n\t};\n\n}\n\nfunction WebGLUniformsGroups( gl, info, capabilities, state ) {\n\n\tlet buffers = {};\n\tlet updateList = {};\n\tlet allocatedBindingPoints = [];\n\n\tconst maxBindingPoints = gl.getParameter( gl.MAX_UNIFORM_BUFFER_BINDINGS ); // binding points are global whereas block indices are per shader program\n\n\tfunction bind( uniformsGroup, program ) {\n\n\t\tconst webglProgram = program.program;\n\t\tstate.uniformBlockBinding( uniformsGroup, webglProgram );\n\n\t}\n\n\tfunction update( uniformsGroup, program ) {\n\n\t\tlet buffer = buffers[ uniformsGroup.id ];\n\n\t\tif ( buffer === undefined ) {\n\n\t\t\tprepareUniformsGroup( uniformsGroup );\n\n\t\t\tbuffer = createBuffer( uniformsGroup );\n\t\t\tbuffers[ uniformsGroup.id ] = buffer;\n\n\t\t\tuniformsGroup.addEventListener( 'dispose', onUniformsGroupsDispose );\n\n\t\t}\n\n\t\t// ensure to update the binding points/block indices mapping for this program\n\n\t\tconst webglProgram = program.program;\n\t\tstate.updateUBOMapping( uniformsGroup, webglProgram );\n\n\t\t// update UBO once per frame\n\n\t\tconst frame = info.render.frame;\n\n\t\tif ( updateList[ uniformsGroup.id ] !== frame ) {\n\n\t\t\tupdateBufferData( uniformsGroup );\n\n\t\t\tupdateList[ uniformsGroup.id ] = frame;\n\n\t\t}\n\n\t}\n\n\tfunction createBuffer( uniformsGroup ) {\n\n\t\t// the setup of an UBO is independent of a particular shader program but global\n\n\t\tconst bindingPointIndex = allocateBindingPointIndex();\n\t\tuniformsGroup.__bindingPointIndex = bindingPointIndex;\n\n\t\tconst buffer = gl.createBuffer();\n\t\tconst size = uniformsGroup.__size;\n\t\tconst usage = uniformsGroup.usage;\n\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, buffer );\n\t\tgl.bufferData( gl.UNIFORM_BUFFER, size, usage );\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, null );\n\t\tgl.bindBufferBase( gl.UNIFORM_BUFFER, bindingPointIndex, buffer );\n\n\t\treturn buffer;\n\n\t}\n\n\tfunction allocateBindingPointIndex() {\n\n\t\tfor ( let i = 0; i < maxBindingPoints; i ++ ) {\n\n\t\t\tif ( allocatedBindingPoints.indexOf( i ) === - 1 ) {\n\n\t\t\t\tallocatedBindingPoints.push( i );\n\t\t\t\treturn i;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconsole.error( 'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.' );\n\n\t\treturn 0;\n\n\t}\n\n\tfunction updateBufferData( uniformsGroup ) {\n\n\t\tconst buffer = buffers[ uniformsGroup.id ];\n\t\tconst uniforms = uniformsGroup.uniforms;\n\t\tconst cache = uniformsGroup.__cache;\n\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, buffer );\n\n\t\tfor ( let i = 0, il = uniforms.length; i < il; i ++ ) {\n\n\t\t\tconst uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];\n\n\t\t\tfor ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {\n\n\t\t\t\tconst uniform = uniformArray[ j ];\n\n\t\t\t\tif ( hasUniformChanged( uniform, i, j, cache ) === true ) {\n\n\t\t\t\t\tconst offset = uniform.__offset;\n\n\t\t\t\t\tconst values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];\n\n\t\t\t\t\tlet arrayOffset = 0;\n\n\t\t\t\t\tfor ( let k = 0; k < values.length; k ++ ) {\n\n\t\t\t\t\t\tconst value = values[ k ];\n\n\t\t\t\t\t\tconst info = getUniformSize( value );\n\n\t\t\t\t\t\t// TODO add integer and struct support\n\t\t\t\t\t\tif ( typeof value === 'number' || typeof value === 'boolean' ) {\n\n\t\t\t\t\t\t\tuniform.__data[ 0 ] = value;\n\t\t\t\t\t\t\tgl.bufferSubData( gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data );\n\n\t\t\t\t\t\t} else if ( value.isMatrix3 ) {\n\n\t\t\t\t\t\t\t// manually converting 3x3 to 3x4\n\n\t\t\t\t\t\t\tuniform.__data[ 0 ] = value.elements[ 0 ];\n\t\t\t\t\t\t\tuniform.__data[ 1 ] = value.elements[ 1 ];\n\t\t\t\t\t\t\tuniform.__data[ 2 ] = value.elements[ 2 ];\n\t\t\t\t\t\t\tuniform.__data[ 3 ] = 0;\n\t\t\t\t\t\t\tuniform.__data[ 4 ] = value.elements[ 3 ];\n\t\t\t\t\t\t\tuniform.__data[ 5 ] = value.elements[ 4 ];\n\t\t\t\t\t\t\tuniform.__data[ 6 ] = value.elements[ 5 ];\n\t\t\t\t\t\t\tuniform.__data[ 7 ] = 0;\n\t\t\t\t\t\t\tuniform.__data[ 8 ] = value.elements[ 6 ];\n\t\t\t\t\t\t\tuniform.__data[ 9 ] = value.elements[ 7 ];\n\t\t\t\t\t\t\tuniform.__data[ 10 ] = value.elements[ 8 ];\n\t\t\t\t\t\t\tuniform.__data[ 11 ] = 0;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvalue.toArray( uniform.__data, arrayOffset );\n\n\t\t\t\t\t\t\tarrayOffset += info.storage / Float32Array.BYTES_PER_ELEMENT;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl.bufferSubData( gl.UNIFORM_BUFFER, offset, uniform.__data );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, null );\n\n\t}\n\n\tfunction hasUniformChanged( uniform, index, indexArray, cache ) {\n\n\t\tconst value = uniform.value;\n\t\tconst indexString = index + '_' + indexArray;\n\n\t\tif ( cache[ indexString ] === undefined ) {\n\n\t\t\t// cache entry does not exist so far\n\n\t\t\tif ( typeof value === 'number' || typeof value === 'boolean' ) {\n\n\t\t\t\tcache[ indexString ] = value;\n\n\t\t\t} else {\n\n\t\t\t\tcache[ indexString ] = value.clone();\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\tconst cachedObject = cache[ indexString ];\n\n\t\t\t// compare current value with cached entry\n\n\t\t\tif ( typeof value === 'number' || typeof value === 'boolean' ) {\n\n\t\t\t\tif ( cachedObject !== value ) {\n\n\t\t\t\t\tcache[ indexString ] = value;\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( cachedObject.equals( value ) === false ) {\n\n\t\t\t\t\tcachedObject.copy( value );\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tfunction prepareUniformsGroup( uniformsGroup ) {\n\n\t\t// determine total buffer size according to the STD140 layout\n\t\t// Hint: STD140 is the only supported layout in WebGL 2\n\n\t\tconst uniforms = uniformsGroup.uniforms;\n\n\t\tlet offset = 0; // global buffer offset in bytes\n\t\tconst chunkSize = 16; // size of a chunk in bytes\n\n\t\tfor ( let i = 0, l = uniforms.length; i < l; i ++ ) {\n\n\t\t\tconst uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];\n\n\t\t\tfor ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {\n\n\t\t\t\tconst uniform = uniformArray[ j ];\n\n\t\t\t\tconst values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];\n\n\t\t\t\tfor ( let k = 0, kl = values.length; k < kl; k ++ ) {\n\n\t\t\t\t\tconst value = values[ k ];\n\n\t\t\t\t\tconst info = getUniformSize( value );\n\n\t\t\t\t\tconst chunkOffset = offset % chunkSize; // offset in the current chunk\n\t\t\t\t\tconst chunkPadding = chunkOffset % info.boundary; // required padding to match boundary\n\t\t\t\t\tconst chunkStart = chunkOffset + chunkPadding; // the start position in the current chunk for the data\n\n\t\t\t\t\toffset += chunkPadding;\n\n\t\t\t\t\t// Check for chunk overflow\n\t\t\t\t\tif ( chunkStart !== 0 && ( chunkSize - chunkStart ) < info.storage ) {\n\n\t\t\t\t\t\t// Add padding and adjust offset\n\t\t\t\t\t\toffset += ( chunkSize - chunkStart );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the following two properties will be used for partial buffer updates\n\t\t\t\t\tuniform.__data = new Float32Array( info.storage / Float32Array.BYTES_PER_ELEMENT );\n\t\t\t\t\tuniform.__offset = offset;\n\n\t\t\t\t\t// Update the global offset\n\t\t\t\t\toffset += info.storage;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ensure correct final padding\n\n\t\tconst chunkOffset = offset % chunkSize;\n\n\t\tif ( chunkOffset > 0 ) offset += ( chunkSize - chunkOffset );\n\n\t\t//\n\n\t\tuniformsGroup.__size = offset;\n\t\tuniformsGroup.__cache = {};\n\n\t\treturn this;\n\n\t}\n\n\tfunction getUniformSize( value ) {\n\n\t\tconst info = {\n\t\t\tboundary: 0, // bytes\n\t\t\tstorage: 0 // bytes\n\t\t};\n\n\t\t// determine sizes according to STD140\n\n\t\tif ( typeof value === 'number' || typeof value === 'boolean' ) {\n\n\t\t\t// float/int/bool\n\n\t\t\tinfo.boundary = 4;\n\t\t\tinfo.storage = 4;\n\n\t\t} else if ( value.isVector2 ) {\n\n\t\t\t// vec2\n\n\t\t\tinfo.boundary = 8;\n\t\t\tinfo.storage = 8;\n\n\t\t} else if ( value.isVector3 || value.isColor ) {\n\n\t\t\t// vec3\n\n\t\t\tinfo.boundary = 16;\n\t\t\tinfo.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes\n\n\t\t} else if ( value.isVector4 ) {\n\n\t\t\t// vec4\n\n\t\t\tinfo.boundary = 16;\n\t\t\tinfo.storage = 16;\n\n\t\t} else if ( value.isMatrix3 ) {\n\n\t\t\t// mat3 (in STD140 a 3x3 matrix is represented as 3x4)\n\n\t\t\tinfo.boundary = 48;\n\t\t\tinfo.storage = 48;\n\n\t\t} else if ( value.isMatrix4 ) {\n\n\t\t\t// mat4\n\n\t\t\tinfo.boundary = 64;\n\t\t\tinfo.storage = 64;\n\n\t\t} else if ( value.isTexture ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.' );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Unsupported uniform value type.', value );\n\n\t\t}\n\n\t\treturn info;\n\n\t}\n\n\tfunction onUniformsGroupsDispose( event ) {\n\n\t\tconst uniformsGroup = event.target;\n\n\t\tuniformsGroup.removeEventListener( 'dispose', onUniformsGroupsDispose );\n\n\t\tconst index = allocatedBindingPoints.indexOf( uniformsGroup.__bindingPointIndex );\n\t\tallocatedBindingPoints.splice( index, 1 );\n\n\t\tgl.deleteBuffer( buffers[ uniformsGroup.id ] );\n\n\t\tdelete buffers[ uniformsGroup.id ];\n\t\tdelete updateList[ uniformsGroup.id ];\n\n\t}\n\n\tfunction dispose() {\n\n\t\tfor ( const id in buffers ) {\n\n\t\t\tgl.deleteBuffer( buffers[ id ] );\n\n\t\t}\n\n\t\tallocatedBindingPoints = [];\n\t\tbuffers = {};\n\t\tupdateList = {};\n\n\t}\n\n\treturn {\n\n\t\tbind: bind,\n\t\tupdate: update,\n\n\t\tdispose: dispose\n\n\t};\n\n}\n\nclass WebGLRenderer {\n\n\tconstructor( parameters = {} ) {\n\n\t\tconst {\n\t\t\tcanvas = (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.createCanvasElement)(),\n\t\t\tcontext = null,\n\t\t\tdepth = true,\n\t\t\tstencil = false,\n\t\t\talpha = false,\n\t\t\tantialias = false,\n\t\t\tpremultipliedAlpha = true,\n\t\t\tpreserveDrawingBuffer = false,\n\t\t\tpowerPreference = 'default',\n\t\t\tfailIfMajorPerformanceCaveat = false,\n\t\t\treverseDepthBuffer = false,\n\t\t} = parameters;\n\n\t\tthis.isWebGLRenderer = true;\n\n\t\tlet _alpha;\n\n\t\tif ( context !== null ) {\n\n\t\t\tif ( typeof WebGLRenderingContext !== 'undefined' && context instanceof WebGLRenderingContext ) {\n\n\t\t\t\tthrow new Error( 'THREE.WebGLRenderer: WebGL 1 is not supported since r163.' );\n\n\t\t\t}\n\n\t\t\t_alpha = context.getContextAttributes().alpha;\n\n\t\t} else {\n\n\t\t\t_alpha = alpha;\n\n\t\t}\n\n\t\tconst uintClearColor = new Uint32Array( 4 );\n\t\tconst intClearColor = new Int32Array( 4 );\n\n\t\tlet currentRenderList = null;\n\t\tlet currentRenderState = null;\n\n\t\t// render() can be called from within a callback triggered by another render.\n\t\t// We track this so that the nested render call gets its list and state isolated from the parent render call.\n\n\t\tconst renderListStack = [];\n\t\tconst renderStateStack = [];\n\n\t\t// public properties\n\n\t\tthis.domElement = canvas;\n\n\t\t// Debug configuration container\n\t\tthis.debug = {\n\n\t\t\t/**\n\t\t\t * Enables error checking and reporting when shader programs are being compiled\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tcheckShaderErrors: true,\n\t\t\t/**\n\t\t\t * Callback for custom error reporting.\n\t\t\t * @type {?Function}\n\t\t\t */\n\t\t\tonShaderError: null\n\t\t};\n\n\t\t// clearing\n\n\t\tthis.autoClear = true;\n\t\tthis.autoClearColor = true;\n\t\tthis.autoClearDepth = true;\n\t\tthis.autoClearStencil = true;\n\n\t\t// scene graph\n\n\t\tthis.sortObjects = true;\n\n\t\t// user-defined clipping\n\n\t\tthis.clippingPlanes = [];\n\t\tthis.localClippingEnabled = false;\n\n\t\t// physically based shading\n\n\t\tthis._outputColorSpace = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n\n\t\t// tone mapping\n\n\t\tthis.toneMapping = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoToneMapping;\n\t\tthis.toneMappingExposure = 1.0;\n\n\t\t// internal properties\n\n\t\tconst _this = this;\n\n\t\tlet _isContextLost = false;\n\n\t\t// internal state cache\n\n\t\tlet _currentActiveCubeFace = 0;\n\t\tlet _currentActiveMipmapLevel = 0;\n\t\tlet _currentRenderTarget = null;\n\t\tlet _currentMaterialId = - 1;\n\n\t\tlet _currentCamera = null;\n\n\t\tconst _currentViewport = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector4();\n\t\tconst _currentScissor = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector4();\n\t\tlet _currentScissorTest = null;\n\n\t\tconst _currentClearColor = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Color( 0x000000 );\n\t\tlet _currentClearAlpha = 0;\n\n\t\t//\n\n\t\tlet _width = canvas.width;\n\t\tlet _height = canvas.height;\n\n\t\tlet _pixelRatio = 1;\n\t\tlet _opaqueSort = null;\n\t\tlet _transparentSort = null;\n\n\t\tconst _viewport = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector4( 0, 0, _width, _height );\n\t\tconst _scissor = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector4( 0, 0, _width, _height );\n\t\tlet _scissorTest = false;\n\n\t\t// frustum\n\n\t\tconst _frustum = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Frustum();\n\n\t\t// clipping\n\n\t\tlet _clippingEnabled = false;\n\t\tlet _localClippingEnabled = false;\n\n\t\t// transmission render target scale\n\t\tthis.transmissionResolutionScale = 1.0;\n\n\t\t// camera matrices cache\n\n\t\tconst _currentProjectionMatrix = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\t\tconst _projScreenMatrix = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\n\t\tconst _vector3 = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\tconst _vector4 = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.Vector4();\n\n\t\tconst _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };\n\n\t\tlet _renderBackground = false;\n\n\t\tfunction getTargetPixelRatio() {\n\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t\t}\n\n\t\t// initialize\n\n\t\tlet _gl = context;\n\n\t\tfunction getContext( contextName, contextAttributes ) {\n\n\t\t\treturn canvas.getContext( contextName, contextAttributes );\n\n\t\t}\n\n\t\ttry {\n\n\t\t\tconst contextAttributes = {\n\t\t\t\talpha: true,\n\t\t\t\tdepth,\n\t\t\t\tstencil,\n\t\t\t\tantialias,\n\t\t\t\tpremultipliedAlpha,\n\t\t\t\tpreserveDrawingBuffer,\n\t\t\t\tpowerPreference,\n\t\t\t\tfailIfMajorPerformanceCaveat,\n\t\t\t};\n\n\t\t\t// OffscreenCanvas does not have setAttribute, see #22811\n\t\t\tif ( 'setAttribute' in canvas ) canvas.setAttribute( 'data-engine', `three.js r${_three_core_js__WEBPACK_IMPORTED_MODULE_0__.REVISION}` );\n\n\t\t\t// event listeners must be registered before WebGL context is created, see #12753\n\t\t\tcanvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\t\t\tcanvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\n\t\t\tcanvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );\n\n\t\t\tif ( _gl === null ) {\n\n\t\t\t\tconst contextName = 'webgl2';\n\n\t\t\t\t_gl = getContext( contextName, contextAttributes );\n\n\t\t\t\tif ( _gl === null ) {\n\n\t\t\t\t\tif ( getContext( contextName ) ) {\n\n\t\t\t\t\t\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( 'Error creating WebGL context.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error.message );\n\t\t\tthrow error;\n\n\t\t}\n\n\t\tlet extensions, capabilities, state, info;\n\t\tlet properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;\n\t\tlet programCache, materials, renderLists, renderStates, clipping, shadowMap;\n\n\t\tlet background, morphtargets, bufferRenderer, indexedBufferRenderer;\n\n\t\tlet utils, bindingStates, uniformsGroups;\n\n\t\tfunction initGLContext() {\n\n\t\t\textensions = new WebGLExtensions( _gl );\n\t\t\textensions.init();\n\n\t\t\tutils = new WebGLUtils( _gl, extensions );\n\n\t\t\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters, utils );\n\n\t\t\tstate = new WebGLState( _gl, extensions );\n\n\t\t\tif ( capabilities.reverseDepthBuffer && reverseDepthBuffer ) {\n\n\t\t\t\tstate.buffers.depth.setReversed( true );\n\n\t\t\t}\n\n\t\t\tinfo = new WebGLInfo( _gl );\n\t\t\tproperties = new WebGLProperties();\n\t\t\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );\n\t\t\tcubemaps = new WebGLCubeMaps( _this );\n\t\t\tcubeuvmaps = new WebGLCubeUVMaps( _this );\n\t\t\tattributes = new WebGLAttributes( _gl );\n\t\t\tbindingStates = new WebGLBindingStates( _gl, attributes );\n\t\t\tgeometries = new WebGLGeometries( _gl, attributes, info, bindingStates );\n\t\t\tobjects = new WebGLObjects( _gl, geometries, attributes, info );\n\t\t\tmorphtargets = new WebGLMorphtargets( _gl, capabilities, textures );\n\t\t\tclipping = new WebGLClipping( properties );\n\t\t\tprogramCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );\n\t\t\tmaterials = new WebGLMaterials( _this, properties );\n\t\t\trenderLists = new WebGLRenderLists();\n\t\t\trenderStates = new WebGLRenderStates( extensions );\n\t\t\tbackground = new WebGLBackground( _this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha );\n\t\t\tshadowMap = new WebGLShadowMap( _this, objects, capabilities );\n\t\t\tuniformsGroups = new WebGLUniformsGroups( _gl, info, capabilities, state );\n\n\t\t\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, info );\n\t\t\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info );\n\n\t\t\tinfo.programs = programCache.programs;\n\n\t\t\t_this.capabilities = capabilities;\n\t\t\t_this.extensions = extensions;\n\t\t\t_this.properties = properties;\n\t\t\t_this.renderLists = renderLists;\n\t\t\t_this.shadowMap = shadowMap;\n\t\t\t_this.state = state;\n\t\t\t_this.info = info;\n\n\t\t}\n\n\t\tinitGLContext();\n\n\t\t// xr\n\n\t\tconst xr = new WebXRManager( _this, _gl );\n\n\t\tthis.xr = xr;\n\n\t\t// API\n\n\t\tthis.getContext = function () {\n\n\t\t\treturn _gl;\n\n\t\t};\n\n\t\tthis.getContextAttributes = function () {\n\n\t\t\treturn _gl.getContextAttributes();\n\n\t\t};\n\n\t\tthis.forceContextLoss = function () {\n\n\t\t\tconst extension = extensions.get( 'WEBGL_lose_context' );\n\t\t\tif ( extension ) extension.loseContext();\n\n\t\t};\n\n\t\tthis.forceContextRestore = function () {\n\n\t\t\tconst extension = extensions.get( 'WEBGL_lose_context' );\n\t\t\tif ( extension ) extension.restoreContext();\n\n\t\t};\n\n\t\tthis.getPixelRatio = function () {\n\n\t\t\treturn _pixelRatio;\n\n\t\t};\n\n\t\tthis.setPixelRatio = function ( value ) {\n\n\t\t\tif ( value === undefined ) return;\n\n\t\t\t_pixelRatio = value;\n\n\t\t\tthis.setSize( _width, _height, false );\n\n\t\t};\n\n\t\tthis.getSize = function ( target ) {\n\n\t\t\treturn target.set( _width, _height );\n\n\t\t};\n\n\t\tthis.setSize = function ( width, height, updateStyle = true ) {\n\n\t\t\tif ( xr.isPresenting ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\n\t\t\tcanvas.width = Math.floor( width * _pixelRatio );\n\t\t\tcanvas.height = Math.floor( height * _pixelRatio );\n\n\t\t\tif ( updateStyle === true ) {\n\n\t\t\t\tcanvas.style.width = width + 'px';\n\t\t\t\tcanvas.style.height = height + 'px';\n\n\t\t\t}\n\n\t\t\tthis.setViewport( 0, 0, width, height );\n\n\t\t};\n\n\t\tthis.getDrawingBufferSize = function ( target ) {\n\n\t\t\treturn target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();\n\n\t\t};\n\n\t\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\n\t\t\t_pixelRatio = pixelRatio;\n\n\t\t\tcanvas.width = Math.floor( width * pixelRatio );\n\t\t\tcanvas.height = Math.floor( height * pixelRatio );\n\n\t\t\tthis.setViewport( 0, 0, width, height );\n\n\t\t};\n\n\t\tthis.getCurrentViewport = function ( target ) {\n\n\t\t\treturn target.copy( _currentViewport );\n\n\t\t};\n\n\t\tthis.getViewport = function ( target ) {\n\n\t\t\treturn target.copy( _viewport );\n\n\t\t};\n\n\t\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t\tif ( x.isVector4 ) {\n\n\t\t\t\t_viewport.set( x.x, x.y, x.z, x.w );\n\n\t\t\t} else {\n\n\t\t\t\t_viewport.set( x, y, width, height );\n\n\t\t\t}\n\n\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).round() );\n\n\t\t};\n\n\t\tthis.getScissor = function ( target ) {\n\n\t\t\treturn target.copy( _scissor );\n\n\t\t};\n\n\t\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t\tif ( x.isVector4 ) {\n\n\t\t\t\t_scissor.set( x.x, x.y, x.z, x.w );\n\n\t\t\t} else {\n\n\t\t\t\t_scissor.set( x, y, width, height );\n\n\t\t\t}\n\n\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).round() );\n\n\t\t};\n\n\t\tthis.getScissorTest = function () {\n\n\t\t\treturn _scissorTest;\n\n\t\t};\n\n\t\tthis.setScissorTest = function ( boolean ) {\n\n\t\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t\t};\n\n\t\tthis.setOpaqueSort = function ( method ) {\n\n\t\t\t_opaqueSort = method;\n\n\t\t};\n\n\t\tthis.setTransparentSort = function ( method ) {\n\n\t\t\t_transparentSort = method;\n\n\t\t};\n\n\t\t// Clearing\n\n\t\tthis.getClearColor = function ( target ) {\n\n\t\t\treturn target.copy( background.getClearColor() );\n\n\t\t};\n\n\t\tthis.setClearColor = function () {\n\n\t\t\tbackground.setClearColor.apply( background, arguments );\n\n\t\t};\n\n\t\tthis.getClearAlpha = function () {\n\n\t\t\treturn background.getClearAlpha();\n\n\t\t};\n\n\t\tthis.setClearAlpha = function () {\n\n\t\t\tbackground.setClearAlpha.apply( background, arguments );\n\n\t\t};\n\n\t\tthis.clear = function ( color = true, depth = true, stencil = true ) {\n\n\t\t\tlet bits = 0;\n\n\t\t\tif ( color ) {\n\n\t\t\t\t// check if we're trying to clear an integer target\n\t\t\t\tlet isIntegerFormat = false;\n\t\t\t\tif ( _currentRenderTarget !== null ) {\n\n\t\t\t\t\tconst targetFormat = _currentRenderTarget.texture.format;\n\t\t\t\t\tisIntegerFormat = targetFormat === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGBAIntegerFormat ||\n\t\t\t\t\t\ttargetFormat === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RGIntegerFormat ||\n\t\t\t\t\t\ttargetFormat === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.RedIntegerFormat;\n\n\t\t\t\t}\n\n\t\t\t\t// use the appropriate clear functions to clear the target if it's a signed\n\t\t\t\t// or unsigned integer target\n\t\t\t\tif ( isIntegerFormat ) {\n\n\t\t\t\t\tconst targetType = _currentRenderTarget.texture.type;\n\t\t\t\t\tconst isUnsignedType = targetType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType ||\n\t\t\t\t\t\ttargetType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType ||\n\t\t\t\t\t\ttargetType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedShortType ||\n\t\t\t\t\t\ttargetType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedInt248Type ||\n\t\t\t\t\t\ttargetType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedShort4444Type ||\n\t\t\t\t\t\ttargetType === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedShort5551Type;\n\n\t\t\t\t\tconst clearColor = background.getClearColor();\n\t\t\t\t\tconst a = background.getClearAlpha();\n\t\t\t\t\tconst r = clearColor.r;\n\t\t\t\t\tconst g = clearColor.g;\n\t\t\t\t\tconst b = clearColor.b;\n\n\t\t\t\t\tif ( isUnsignedType ) {\n\n\t\t\t\t\t\tuintClearColor[ 0 ] = r;\n\t\t\t\t\t\tuintClearColor[ 1 ] = g;\n\t\t\t\t\t\tuintClearColor[ 2 ] = b;\n\t\t\t\t\t\tuintClearColor[ 3 ] = a;\n\t\t\t\t\t\t_gl.clearBufferuiv( _gl.COLOR, 0, uintClearColor );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tintClearColor[ 0 ] = r;\n\t\t\t\t\t\tintClearColor[ 1 ] = g;\n\t\t\t\t\t\tintClearColor[ 2 ] = b;\n\t\t\t\t\t\tintClearColor[ 3 ] = a;\n\t\t\t\t\t\t_gl.clearBufferiv( _gl.COLOR, 0, intClearColor );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbits |= _gl.COLOR_BUFFER_BIT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( depth ) {\n\n\t\t\t\tbits |= _gl.DEPTH_BUFFER_BIT;\n\n\t\t\t}\n\n\t\t\tif ( stencil ) {\n\n\t\t\t\tbits |= _gl.STENCIL_BUFFER_BIT;\n\t\t\t\tthis.state.buffers.stencil.setMask( 0xffffffff );\n\n\t\t\t}\n\n\t\t\t_gl.clear( bits );\n\n\t\t};\n\n\t\tthis.clearColor = function () {\n\n\t\t\tthis.clear( true, false, false );\n\n\t\t};\n\n\t\tthis.clearDepth = function () {\n\n\t\t\tthis.clear( false, true, false );\n\n\t\t};\n\n\t\tthis.clearStencil = function () {\n\n\t\t\tthis.clear( false, false, true );\n\n\t\t};\n\n\t\t//\n\n\t\tthis.dispose = function () {\n\n\t\t\tcanvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\t\t\tcanvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\n\t\t\tcanvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );\n\n\t\t\tbackground.dispose();\n\t\t\trenderLists.dispose();\n\t\t\trenderStates.dispose();\n\t\t\tproperties.dispose();\n\t\t\tcubemaps.dispose();\n\t\t\tcubeuvmaps.dispose();\n\t\t\tobjects.dispose();\n\t\t\tbindingStates.dispose();\n\t\t\tuniformsGroups.dispose();\n\t\t\tprogramCache.dispose();\n\n\t\t\txr.dispose();\n\n\t\t\txr.removeEventListener( 'sessionstart', onXRSessionStart );\n\t\t\txr.removeEventListener( 'sessionend', onXRSessionEnd );\n\n\t\t\tanimation.stop();\n\n\t\t};\n\n\t\t// Events\n\n\t\tfunction onContextLost( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Context Lost.' );\n\n\t\t\t_isContextLost = true;\n\n\t\t}\n\n\t\tfunction onContextRestore( /* event */ ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Context Restored.' );\n\n\t\t\t_isContextLost = false;\n\n\t\t\tconst infoAutoReset = info.autoReset;\n\t\t\tconst shadowMapEnabled = shadowMap.enabled;\n\t\t\tconst shadowMapAutoUpdate = shadowMap.autoUpdate;\n\t\t\tconst shadowMapNeedsUpdate = shadowMap.needsUpdate;\n\t\t\tconst shadowMapType = shadowMap.type;\n\n\t\t\tinitGLContext();\n\n\t\t\tinfo.autoReset = infoAutoReset;\n\t\t\tshadowMap.enabled = shadowMapEnabled;\n\t\t\tshadowMap.autoUpdate = shadowMapAutoUpdate;\n\t\t\tshadowMap.needsUpdate = shadowMapNeedsUpdate;\n\t\t\tshadowMap.type = shadowMapType;\n\n\t\t}\n\n\t\tfunction onContextCreationError( event ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage );\n\n\t\t}\n\n\t\tfunction onMaterialDispose( event ) {\n\n\t\t\tconst material = event.target;\n\n\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\t\tdeallocateMaterial( material );\n\n\t\t}\n\n\t\t// Buffer deallocation\n\n\t\tfunction deallocateMaterial( material ) {\n\n\t\t\treleaseMaterialProgramReferences( material );\n\n\t\t\tproperties.remove( material );\n\n\t\t}\n\n\n\t\tfunction releaseMaterialProgramReferences( material ) {\n\n\t\t\tconst programs = properties.get( material ).programs;\n\n\t\t\tif ( programs !== undefined ) {\n\n\t\t\t\tprograms.forEach( function ( program ) {\n\n\t\t\t\t\tprogramCache.releaseProgram( program );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( material.isShaderMaterial ) {\n\n\t\t\t\t\tprogramCache.releaseShaderCache( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Buffer rendering\n\n\t\tthis.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {\n\n\t\t\tif ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)\n\n\t\t\tconst frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\n\t\t\tconst program = setProgram( camera, scene, geometry, material, object );\n\n\t\t\tstate.setMaterial( material, frontFaceCW );\n\n\t\t\t//\n\n\t\t\tlet index = geometry.index;\n\t\t\tlet rangeFactor = 1;\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tindex = geometries.getWireframeAttribute( geometry );\n\n\t\t\t\tif ( index === undefined ) return;\n\n\t\t\t\trangeFactor = 2;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst drawRange = geometry.drawRange;\n\t\t\tconst position = geometry.attributes.position;\n\n\t\t\tlet drawStart = drawRange.start * rangeFactor;\n\t\t\tlet drawEnd = ( drawRange.start + drawRange.count ) * rangeFactor;\n\n\t\t\tif ( group !== null ) {\n\n\t\t\t\tdrawStart = Math.max( drawStart, group.start * rangeFactor );\n\t\t\t\tdrawEnd = Math.min( drawEnd, ( group.start + group.count ) * rangeFactor );\n\n\t\t\t}\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tdrawStart = Math.max( drawStart, 0 );\n\t\t\t\tdrawEnd = Math.min( drawEnd, index.count );\n\n\t\t\t} else if ( position !== undefined && position !== null ) {\n\n\t\t\t\tdrawStart = Math.max( drawStart, 0 );\n\t\t\t\tdrawEnd = Math.min( drawEnd, position.count );\n\n\t\t\t}\n\n\t\t\tconst drawCount = drawEnd - drawStart;\n\n\t\t\tif ( drawCount < 0 || drawCount === Infinity ) return;\n\n\t\t\t//\n\n\t\t\tbindingStates.setup( object, material, program, geometry, index );\n\n\t\t\tlet attribute;\n\t\t\tlet renderer = bufferRenderer;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tattribute = attributes.get( index );\n\n\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\trenderer.setIndex( attribute );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isLine ) {\n\n\t\t\t\tlet lineWidth = material.linewidth;\n\n\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\t\tif ( object.isLineSegments ) {\n\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else if ( object.isLineLoop ) {\n\n\t\t\t\t\trenderer.setMode( _gl.LINE_LOOP );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isPoints ) {\n\n\t\t\t\trenderer.setMode( _gl.POINTS );\n\n\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\n\t\t\t}\n\n\t\t\tif ( object.isBatchedMesh ) {\n\n\t\t\t\tif ( object._multiDrawInstances !== null ) {\n\n\t\t\t\t\trenderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ! extensions.get( 'WEBGL_multi_draw' ) ) {\n\n\t\t\t\t\t\tconst starts = object._multiDrawStarts;\n\t\t\t\t\t\tconst counts = object._multiDrawCounts;\n\t\t\t\t\t\tconst drawCount = object._multiDrawCount;\n\t\t\t\t\t\tconst bytesPerElement = index ? attributes.get( index ).bytesPerElement : 1;\n\t\t\t\t\t\tconst uniforms = properties.get( material ).currentProgram.getUniforms();\n\t\t\t\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\t\t\t\tuniforms.setValue( _gl, '_gl_DrawID', i );\n\t\t\t\t\t\t\trenderer.render( starts[ i ] / bytesPerElement, counts[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\trenderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isInstancedMesh ) {\n\n\t\t\t\trenderer.renderInstances( drawStart, drawCount, object.count );\n\n\t\t\t} else if ( geometry.isInstancedBufferGeometry ) {\n\n\t\t\t\tconst maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;\n\t\t\t\tconst instanceCount = Math.min( geometry.instanceCount, maxInstanceCount );\n\n\t\t\t\trenderer.renderInstances( drawStart, drawCount, instanceCount );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t\t}\n\n\t\t};\n\n\t\t// Compile\n\n\t\tfunction prepareMaterial( material, scene, object ) {\n\n\t\t\tif ( material.transparent === true && material.side === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DoubleSide && material.forceSinglePass === false ) {\n\n\t\t\t\tmaterial.side = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BackSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t\tmaterial.side = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.FrontSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t\tmaterial.side = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n\n\t\t\t} else {\n\n\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.compile = function ( scene, camera, targetScene = null ) {\n\n\t\t\tif ( targetScene === null ) targetScene = scene;\n\n\t\t\tcurrentRenderState = renderStates.get( targetScene );\n\t\t\tcurrentRenderState.init( camera );\n\n\t\t\trenderStateStack.push( currentRenderState );\n\n\t\t\t// gather lights from both the target scene and the new object that will be added to the scene.\n\n\t\t\ttargetScene.traverseVisible( function ( object ) {\n\n\t\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( scene !== targetScene ) {\n\n\t\t\t\tscene.traverseVisible( function ( object ) {\n\n\t\t\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tcurrentRenderState.setupLights();\n\n\t\t\t// Only initialize materials in the new scene, not the targetScene.\n\n\t\t\tconst materials = new Set();\n\n\t\t\tscene.traverse( function ( object ) {\n\n\t\t\t\tif ( ! ( object.isMesh || object.isPoints || object.isLine || object.isSprite ) ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tconst material = object.material;\n\n\t\t\t\tif ( material ) {\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\n\n\t\t\t\t\t\t\tconst material2 = material[ i ];\n\n\t\t\t\t\t\t\tprepareMaterial( material2, targetScene, object );\n\t\t\t\t\t\t\tmaterials.add( material2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tprepareMaterial( material, targetScene, object );\n\t\t\t\t\t\tmaterials.add( material );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\trenderStateStack.pop();\n\t\t\tcurrentRenderState = null;\n\n\t\t\treturn materials;\n\n\t\t};\n\n\t\t// compileAsync\n\n\t\tthis.compileAsync = function ( scene, camera, targetScene = null ) {\n\n\t\t\tconst materials = this.compile( scene, camera, targetScene );\n\n\t\t\t// Wait for all the materials in the new object to indicate that they're\n\t\t\t// ready to be used before resolving the promise.\n\n\t\t\treturn new Promise( ( resolve ) => {\n\n\t\t\t\tfunction checkMaterialsReady() {\n\n\t\t\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\t\t\tconst materialProperties = properties.get( material );\n\t\t\t\t\t\tconst program = materialProperties.currentProgram;\n\n\t\t\t\t\t\tif ( program.isReady() ) {\n\n\t\t\t\t\t\t\t// remove any programs that report they're ready to use from the list\n\t\t\t\t\t\t\tmaterials.delete( material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t// once the list of compiling materials is empty, call the callback\n\n\t\t\t\t\tif ( materials.size === 0 ) {\n\n\t\t\t\t\t\tresolve( scene );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if some materials are still not ready, wait a bit and check again\n\n\t\t\t\t\tsetTimeout( checkMaterialsReady, 10 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( extensions.get( 'KHR_parallel_shader_compile' ) !== null ) {\n\n\t\t\t\t\t// If we can check the compilation status of the materials without\n\t\t\t\t\t// blocking then do so right away.\n\n\t\t\t\t\tcheckMaterialsReady();\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise start by waiting a bit to give the materials we just\n\t\t\t\t\t// initialized a chance to finish.\n\n\t\t\t\t\tsetTimeout( checkMaterialsReady, 10 );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t};\n\n\t\t// Animation Loop\n\n\t\tlet onAnimationFrameCallback = null;\n\n\t\tfunction onAnimationFrame( time ) {\n\n\t\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time );\n\n\t\t}\n\n\t\tfunction onXRSessionStart() {\n\n\t\t\tanimation.stop();\n\n\t\t}\n\n\t\tfunction onXRSessionEnd() {\n\n\t\t\tanimation.start();\n\n\t\t}\n\n\t\tconst animation = new WebGLAnimation();\n\t\tanimation.setAnimationLoop( onAnimationFrame );\n\n\t\tif ( typeof self !== 'undefined' ) animation.setContext( self );\n\n\t\tthis.setAnimationLoop = function ( callback ) {\n\n\t\t\tonAnimationFrameCallback = callback;\n\t\t\txr.setAnimationLoop( callback );\n\n\t\t\t( callback === null ) ? animation.stop() : animation.start();\n\n\t\t};\n\n\t\txr.addEventListener( 'sessionstart', onXRSessionStart );\n\t\txr.addEventListener( 'sessionend', onXRSessionEnd );\n\n\t\t// Rendering\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( camera !== undefined && camera.isCamera !== true ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( _isContextLost === true ) return;\n\n\t\t\t// update scene graph\n\n\t\t\tif ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t\t// update camera matrices and frustum\n\n\t\t\tif ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();\n\n\t\t\tif ( xr.enabled === true && xr.isPresenting === true ) {\n\n\t\t\t\tif ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );\n\n\t\t\t\tcamera = xr.getCamera(); // use XR camera for rendering\n\n\t\t\t}\n\n\t\t\t//\n\t\t\tif ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );\n\n\t\t\tcurrentRenderState = renderStates.get( scene, renderStateStack.length );\n\t\t\tcurrentRenderState.init( camera );\n\n\t\t\trenderStateStack.push( currentRenderState );\n\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\t_frustum.setFromProjectionMatrix( _projScreenMatrix );\n\n\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled );\n\n\t\t\tcurrentRenderList = renderLists.get( scene, renderListStack.length );\n\t\t\tcurrentRenderList.init();\n\n\t\t\trenderListStack.push( currentRenderList );\n\n\t\t\tif ( xr.enabled === true && xr.isPresenting === true ) {\n\n\t\t\t\tconst depthSensingMesh = _this.xr.getDepthSensingMesh();\n\n\t\t\t\tif ( depthSensingMesh !== null ) {\n\n\t\t\t\t\tprojectObject( depthSensingMesh, camera, - Infinity, _this.sortObjects );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tprojectObject( scene, camera, 0, _this.sortObjects );\n\n\t\t\tcurrentRenderList.finish();\n\n\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\tcurrentRenderList.sort( _opaqueSort, _transparentSort );\n\n\t\t\t}\n\n\t\t\t_renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;\n\t\t\tif ( _renderBackground ) {\n\n\t\t\t\tbackground.addToRenderList( currentRenderList, scene );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tthis.info.render.frame ++;\n\n\t\t\tif ( _clippingEnabled === true ) clipping.beginShadows();\n\n\t\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\t\tshadowMap.render( shadowsArray, scene, camera );\n\n\t\t\tif ( _clippingEnabled === true ) clipping.endShadows();\n\n\t\t\t//\n\n\t\t\tif ( this.info.autoReset === true ) this.info.reset();\n\n\t\t\t// render scene\n\n\t\t\tconst opaqueObjects = currentRenderList.opaque;\n\t\t\tconst transmissiveObjects = currentRenderList.transmissive;\n\n\t\t\tcurrentRenderState.setupLights();\n\n\t\t\tif ( camera.isArrayCamera ) {\n\n\t\t\t\tconst cameras = camera.cameras;\n\n\t\t\t\tif ( transmissiveObjects.length > 0 ) {\n\n\t\t\t\t\tfor ( let i = 0, l = cameras.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst camera2 = cameras[ i ];\n\n\t\t\t\t\t\trenderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( _renderBackground ) background.render( scene );\n\n\t\t\t\tfor ( let i = 0, l = cameras.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst camera2 = cameras[ i ];\n\n\t\t\t\t\trenderScene( currentRenderList, scene, camera2, camera2.viewport );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera );\n\n\t\t\t\tif ( _renderBackground ) background.render( scene );\n\n\t\t\t\trenderScene( currentRenderList, scene, camera );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( _currentRenderTarget !== null && _currentActiveMipmapLevel === 0 ) {\n\n\t\t\t\t// resolve multisample renderbuffers to a single-sample texture if necessary\n\n\t\t\t\ttextures.updateMultisampleRenderTarget( _currentRenderTarget );\n\n\t\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\t\t\ttextures.updateRenderTargetMipmap( _currentRenderTarget );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );\n\n\t\t\t// _gl.finish();\n\n\t\t\tbindingStates.resetDefaultState();\n\t\t\t_currentMaterialId = - 1;\n\t\t\t_currentCamera = null;\n\n\t\t\trenderStateStack.pop();\n\n\t\t\tif ( renderStateStack.length > 0 ) {\n\n\t\t\t\tcurrentRenderState = renderStateStack[ renderStateStack.length - 1 ];\n\n\t\t\t\tif ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, currentRenderState.state.camera );\n\n\t\t\t} else {\n\n\t\t\t\tcurrentRenderState = null;\n\n\t\t\t}\n\n\t\t\trenderListStack.pop();\n\n\t\t\tif ( renderListStack.length > 0 ) {\n\n\t\t\t\tcurrentRenderList = renderListStack[ renderListStack.length - 1 ];\n\n\t\t\t} else {\n\n\t\t\t\tcurrentRenderList = null;\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction projectObject( object, camera, groupOrder, sortObjects ) {\n\n\t\t\tif ( object.visible === false ) return;\n\n\t\t\tconst visible = object.layers.test( camera.layers );\n\n\t\t\tif ( visible ) {\n\n\t\t\t\tif ( object.isGroup ) {\n\n\t\t\t\t\tgroupOrder = object.renderOrder;\n\n\t\t\t\t} else if ( object.isLOD ) {\n\n\t\t\t\t\tif ( object.autoUpdate === true ) object.update( camera );\n\n\t\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\n\n\t\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t\t_vector4.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\t\tif ( material.visible ) {\n\n\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector4.z, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t\tif ( object.boundingSphere !== undefined ) {\n\n\t\t\t\t\t\t\t\tif ( object.boundingSphere === null ) object.computeBoundingSphere();\n\t\t\t\t\t\t\t\t_vector4.copy( object.boundingSphere.center );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\t\t\t\t\t\t\t_vector4.copy( geometry.boundingSphere.center );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_vector4\n\t\t\t\t\t\t\t\t.applyMatrix4( object.matrixWorld )\n\t\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector4.z, group );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector4.z, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst children = object.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tprojectObject( children[ i ], camera, groupOrder, sortObjects );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderScene( currentRenderList, scene, camera, viewport ) {\n\n\t\t\tconst opaqueObjects = currentRenderList.opaque;\n\t\t\tconst transmissiveObjects = currentRenderList.transmissive;\n\t\t\tconst transparentObjects = currentRenderList.transparent;\n\n\t\t\tcurrentRenderState.setupLightsView( camera );\n\n\t\t\tif ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );\n\n\t\t\tif ( viewport ) state.viewport( _currentViewport.copy( viewport ) );\n\n\t\t\tif ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );\n\t\t\tif ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );\n\t\t\tif ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );\n\n\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\t\tstate.buffers.depth.setTest( true );\n\t\t\tstate.buffers.depth.setMask( true );\n\t\t\tstate.buffers.color.setMask( true );\n\n\t\t\tstate.setPolygonOffset( false );\n\n\t\t}\n\n\t\tfunction renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera ) {\n\n\t\t\tconst overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n\n\t\t\tif ( overrideMaterial !== null ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( currentRenderState.state.transmissionRenderTarget[ camera.id ] === undefined ) {\n\n\t\t\t\tcurrentRenderState.state.transmissionRenderTarget[ camera.id ] = new _three_core_js__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget( 1, 1, {\n\t\t\t\t\tgenerateMipmaps: true,\n\t\t\t\t\ttype: ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) ) ? _three_core_js__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType : _three_core_js__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType,\n\t\t\t\t\tminFilter: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter,\n\t\t\t\t\tsamples: 4,\n\t\t\t\t\tstencilBuffer: stencil,\n\t\t\t\t\tresolveDepthBuffer: false,\n\t\t\t\t\tresolveStencilBuffer: false,\n\t\t\t\t\tcolorSpace: _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.workingColorSpace,\n\t\t\t\t} );\n\n\t\t\t\t// debug\n\n\t\t\t\t/*\n\t\t\t\tconst geometry = new PlaneGeometry();\n\t\t\t\tconst material = new MeshBasicMaterial( { map: _transmissionRenderTarget.texture } );\n\n\t\t\t\tconst mesh = new Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\t\t\t\t*/\n\n\t\t\t}\n\n\t\t\tconst transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[ camera.id ];\n\n\t\t\tconst activeViewport = camera.viewport || _currentViewport;\n\t\t\ttransmissionRenderTarget.setSize( activeViewport.z * _this.transmissionResolutionScale, activeViewport.w * _this.transmissionResolutionScale );\n\n\t\t\t//\n\n\t\t\tconst currentRenderTarget = _this.getRenderTarget();\n\t\t\t_this.setRenderTarget( transmissionRenderTarget );\n\n\t\t\t_this.getClearColor( _currentClearColor );\n\t\t\t_currentClearAlpha = _this.getClearAlpha();\n\t\t\tif ( _currentClearAlpha < 1 ) _this.setClearColor( 0xffffff, 0.5 );\n\n\t\t\t_this.clear();\n\n\t\t\tif ( _renderBackground ) background.render( scene );\n\n\t\t\t// Turn off the features which can affect the frag color for opaque objects pass.\n\t\t\t// Otherwise they are applied twice in opaque objects pass and transmission objects pass.\n\t\t\tconst currentToneMapping = _this.toneMapping;\n\t\t\t_this.toneMapping = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoToneMapping;\n\n\t\t\t// Remove viewport from camera to avoid nested render calls resetting viewport to it (e.g Reflector).\n\t\t\t// Transmission render pass requires viewport to match the transmissionRenderTarget.\n\t\t\tconst currentCameraViewport = camera.viewport;\n\t\t\tif ( camera.viewport !== undefined ) camera.viewport = undefined;\n\n\t\t\tcurrentRenderState.setupLightsView( camera );\n\n\t\t\tif ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );\n\n\t\t\trenderObjects( opaqueObjects, scene, camera );\n\n\t\t\ttextures.updateMultisampleRenderTarget( transmissionRenderTarget );\n\t\t\ttextures.updateRenderTargetMipmap( transmissionRenderTarget );\n\n\t\t\tif ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === false ) { // see #28131\n\n\t\t\t\tlet renderTargetNeedsUpdate = false;\n\n\t\t\t\tfor ( let i = 0, l = transmissiveObjects.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst renderItem = transmissiveObjects[ i ];\n\n\t\t\t\t\tconst object = renderItem.object;\n\t\t\t\t\tconst geometry = renderItem.geometry;\n\t\t\t\t\tconst material = renderItem.material;\n\t\t\t\t\tconst group = renderItem.group;\n\n\t\t\t\t\tif ( material.side === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DoubleSide && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\t\tconst currentSide = material.side;\n\n\t\t\t\t\t\tmaterial.side = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BackSide;\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\n\n\t\t\t\t\t\tmaterial.side = currentSide;\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t\t\trenderTargetNeedsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( renderTargetNeedsUpdate === true ) {\n\n\t\t\t\t\ttextures.updateMultisampleRenderTarget( transmissionRenderTarget );\n\t\t\t\t\ttextures.updateRenderTargetMipmap( transmissionRenderTarget );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_this.setRenderTarget( currentRenderTarget );\n\n\t\t\t_this.setClearColor( _currentClearColor, _currentClearAlpha );\n\n\t\t\tif ( currentCameraViewport !== undefined ) camera.viewport = currentCameraViewport;\n\n\t\t\t_this.toneMapping = currentToneMapping;\n\n\t\t}\n\n\t\tfunction renderObjects( renderList, scene, camera ) {\n\n\t\t\tconst overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n\n\t\t\tfor ( let i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\t\tconst renderItem = renderList[ i ];\n\n\t\t\t\tconst object = renderItem.object;\n\t\t\t\tconst geometry = renderItem.geometry;\n\t\t\t\tconst material = overrideMaterial === null ? renderItem.material : overrideMaterial;\n\t\t\t\tconst group = renderItem.group;\n\n\t\t\t\tif ( object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderObject( object, scene, camera, geometry, material, group ) {\n\n\t\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\t\tmaterial.onBeforeRender( _this, scene, camera, geometry, object, group );\n\n\t\t\tif ( material.transparent === true && material.side === _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DoubleSide && material.forceSinglePass === false ) {\n\n\t\t\t\tmaterial.side = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.BackSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\t\tmaterial.side = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.FrontSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\t\tmaterial.side = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n\n\t\t\t} else {\n\n\t\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\t}\n\n\t\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\n\t\t}\n\n\t\tfunction getProgram( material, scene, object ) {\n\n\t\t\tif ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\t\tconst materialProperties = properties.get( material );\n\n\t\t\tconst lights = currentRenderState.state.lights;\n\t\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\t\tconst lightsStateVersion = lights.state.version;\n\n\t\t\tconst parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );\n\t\t\tconst programCacheKey = programCache.getProgramCacheKey( parameters );\n\n\t\t\tlet programs = materialProperties.programs;\n\n\t\t\t// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change\n\n\t\t\tmaterialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tmaterialProperties.fog = scene.fog;\n\t\t\tmaterialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );\n\t\t\tmaterialProperties.envMapRotation = ( materialProperties.environment !== null && material.envMap === null ) ? scene.environmentRotation : material.envMapRotation;\n\n\t\t\tif ( programs === undefined ) {\n\n\t\t\t\t// new material\n\n\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t\t\tprograms = new Map();\n\t\t\t\tmaterialProperties.programs = programs;\n\n\t\t\t}\n\n\t\t\tlet program = programs.get( programCacheKey );\n\n\t\t\tif ( program !== undefined ) {\n\n\t\t\t\t// early out if program and light state is identical\n\n\t\t\t\tif ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {\n\n\t\t\t\t\tupdateCommonMaterialProperties( material, parameters );\n\n\t\t\t\t\treturn program;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tparameters.uniforms = programCache.getUniforms( material );\n\n\t\t\t\tmaterial.onBeforeCompile( parameters, _this );\n\n\t\t\t\tprogram = programCache.acquireProgram( parameters, programCacheKey );\n\t\t\t\tprograms.set( programCacheKey, program );\n\n\t\t\t\tmaterialProperties.uniforms = parameters.uniforms;\n\n\t\t\t}\n\n\t\t\tconst uniforms = materialProperties.uniforms;\n\n\t\t\tif ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {\n\n\t\t\t\tuniforms.clippingPlanes = clipping.uniform;\n\n\t\t\t}\n\n\t\t\tupdateCommonMaterialProperties( material, parameters );\n\n\t\t\t// store the light setup it was created for\n\n\t\t\tmaterialProperties.needsLights = materialNeedsLights( material );\n\t\t\tmaterialProperties.lightsStateVersion = lightsStateVersion;\n\n\t\t\tif ( materialProperties.needsLights ) {\n\n\t\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\t\tuniforms.ambientLightColor.value = lights.state.ambient;\n\t\t\t\tuniforms.lightProbe.value = lights.state.probe;\n\t\t\t\tuniforms.directionalLights.value = lights.state.directional;\n\t\t\t\tuniforms.directionalLightShadows.value = lights.state.directionalShadow;\n\t\t\t\tuniforms.spotLights.value = lights.state.spot;\n\t\t\t\tuniforms.spotLightShadows.value = lights.state.spotShadow;\n\t\t\t\tuniforms.rectAreaLights.value = lights.state.rectArea;\n\t\t\t\tuniforms.ltc_1.value = lights.state.rectAreaLTC1;\n\t\t\t\tuniforms.ltc_2.value = lights.state.rectAreaLTC2;\n\t\t\t\tuniforms.pointLights.value = lights.state.point;\n\t\t\t\tuniforms.pointLightShadows.value = lights.state.pointShadow;\n\t\t\t\tuniforms.hemisphereLights.value = lights.state.hemi;\n\n\t\t\t\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n\t\t\t\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n\t\t\t\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\n\t\t\t\tuniforms.spotLightMatrix.value = lights.state.spotLightMatrix;\n\t\t\t\tuniforms.spotLightMap.value = lights.state.spotLightMap;\n\t\t\t\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\n\t\t\t\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\n\t\t\t\t// TODO (abelnation): add area lights shadow info to uniforms\n\n\t\t\t}\n\n\t\t\tmaterialProperties.currentProgram = program;\n\t\t\tmaterialProperties.uniformsList = null;\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\tfunction getUniformList( materialProperties ) {\n\n\t\t\tif ( materialProperties.uniformsList === null ) {\n\n\t\t\t\tconst progUniforms = materialProperties.currentProgram.getUniforms();\n\t\t\t\tmaterialProperties.uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, materialProperties.uniforms );\n\n\t\t\t}\n\n\t\t\treturn materialProperties.uniformsList;\n\n\t\t}\n\n\t\tfunction updateCommonMaterialProperties( material, parameters ) {\n\n\t\t\tconst materialProperties = properties.get( material );\n\n\t\t\tmaterialProperties.outputColorSpace = parameters.outputColorSpace;\n\t\t\tmaterialProperties.batching = parameters.batching;\n\t\t\tmaterialProperties.batchingColor = parameters.batchingColor;\n\t\t\tmaterialProperties.instancing = parameters.instancing;\n\t\t\tmaterialProperties.instancingColor = parameters.instancingColor;\n\t\t\tmaterialProperties.instancingMorph = parameters.instancingMorph;\n\t\t\tmaterialProperties.skinning = parameters.skinning;\n\t\t\tmaterialProperties.morphTargets = parameters.morphTargets;\n\t\t\tmaterialProperties.morphNormals = parameters.morphNormals;\n\t\t\tmaterialProperties.morphColors = parameters.morphColors;\n\t\t\tmaterialProperties.morphTargetsCount = parameters.morphTargetsCount;\n\t\t\tmaterialProperties.numClippingPlanes = parameters.numClippingPlanes;\n\t\t\tmaterialProperties.numIntersection = parameters.numClipIntersection;\n\t\t\tmaterialProperties.vertexAlphas = parameters.vertexAlphas;\n\t\t\tmaterialProperties.vertexTangents = parameters.vertexTangents;\n\t\t\tmaterialProperties.toneMapping = parameters.toneMapping;\n\n\t\t}\n\n\t\tfunction setProgram( camera, scene, geometry, material, object ) {\n\n\t\t\tif ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\t\ttextures.resetTextureUnits();\n\n\t\t\tconst fog = scene.fog;\n\t\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tconst colorSpace = ( _currentRenderTarget === null ) ? _this.outputColorSpace : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : _three_core_js__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace );\n\t\t\tconst envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );\n\t\t\tconst vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;\n\t\t\tconst vertexTangents = !! geometry.attributes.tangent && ( !! material.normalMap || material.anisotropy > 0 );\n\t\t\tconst morphTargets = !! geometry.morphAttributes.position;\n\t\t\tconst morphNormals = !! geometry.morphAttributes.normal;\n\t\t\tconst morphColors = !! geometry.morphAttributes.color;\n\n\t\t\tlet toneMapping = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.NoToneMapping;\n\n\t\t\tif ( material.toneMapped ) {\n\n\t\t\t\tif ( _currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true ) {\n\n\t\t\t\t\ttoneMapping = _this.toneMapping;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\t\tconst materialProperties = properties.get( material );\n\t\t\tconst lights = currentRenderState.state.lights;\n\n\t\t\tif ( _clippingEnabled === true ) {\n\n\t\t\t\tif ( _localClippingEnabled === true || camera !== _currentCamera ) {\n\n\t\t\t\t\tconst useCache =\n\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t// (#8465, #8379)\n\t\t\t\t\tclipping.setState( material, camera, useCache );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet needsProgramChange = false;\n\n\t\t\tif ( material.version === materialProperties.__version ) {\n\n\t\t\t\tif ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.outputColorSpace !== colorSpace ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isBatchedMesh && materialProperties.batching === false ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( ! object.isBatchedMesh && materialProperties.batching === true ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.envMap !== envMap ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( material.fog === true && materialProperties.fog !== fog ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t\t( materialProperties.numClippingPlanes !== clipping.numPlanes ||\n\t\t\t\t\tmaterialProperties.numIntersection !== clipping.numIntersection ) ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.vertexTangents !== vertexTangents ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphTargets !== morphTargets ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphNormals !== morphNormals ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphColors !== morphColors ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.toneMapping !== toneMapping ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphTargetsCount !== morphTargetsCount ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tneedsProgramChange = true;\n\t\t\t\tmaterialProperties.__version = material.version;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet program = materialProperties.currentProgram;\n\n\t\t\tif ( needsProgramChange === true ) {\n\n\t\t\t\tprogram = getProgram( material, scene, object );\n\n\t\t\t}\n\n\t\t\tlet refreshProgram = false;\n\t\t\tlet refreshMaterial = false;\n\t\t\tlet refreshLights = false;\n\n\t\t\tconst p_uniforms = program.getUniforms(),\n\t\t\t\tm_uniforms = materialProperties.uniforms;\n\n\t\t\tif ( state.useProgram( program.program ) ) {\n\n\t\t\t\trefreshProgram = true;\n\t\t\t\trefreshMaterial = true;\n\t\t\t\trefreshLights = true;\n\n\t\t\t}\n\n\t\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t\t_currentMaterialId = material.id;\n\n\t\t\t\trefreshMaterial = true;\n\n\t\t\t}\n\n\t\t\tif ( refreshProgram || _currentCamera !== camera ) {\n\n\t\t\t\t// common camera uniforms\n\n\t\t\t\tconst reverseDepthBuffer = state.buffers.depth.getReversed();\n\n\t\t\t\tif ( reverseDepthBuffer ) {\n\n\t\t\t\t\t_currentProjectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\t\t\t(0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.toNormalizedProjectionMatrix)( _currentProjectionMatrix );\n\t\t\t\t\t(0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.toReversedProjectionMatrix)( _currentProjectionMatrix );\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'projectionMatrix', _currentProjectionMatrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t\tconst uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\tuCamPos.setValue( _gl, _vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t\t}\n\n\t\t\t\t// consider moving isOrthographic to UniformLib and WebGLMaterials, see https://github.com/mrdoob/three.js/pull/26467#issuecomment-1645185067\n\n\t\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\t\tmaterial.isMeshToonMaterial ||\n\t\t\t\t\tmaterial.isMeshLambertMaterial ||\n\t\t\t\t\tmaterial.isMeshBasicMaterial ||\n\t\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\t\tmaterial.isShaderMaterial ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );\n\n\t\t\t\t}\n\n\t\t\t\tif ( _currentCamera !== camera ) {\n\n\t\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// skinning and morph target uniforms must be set even if material didn't change\n\t\t\t// auto-setting of texture unit for bone and morph texture must go before other textures\n\t\t\t// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures\n\n\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\t\tconst skeleton = object.skeleton;\n\n\t\t\t\tif ( skeleton ) {\n\n\t\t\t\t\tif ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( object.isBatchedMesh ) {\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'batchingTexture' );\n\t\t\t\tp_uniforms.setValue( _gl, 'batchingTexture', object._matricesTexture, textures );\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'batchingIdTexture' );\n\t\t\t\tp_uniforms.setValue( _gl, 'batchingIdTexture', object._indirectTexture, textures );\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'batchingColorTexture' );\n\t\t\t\tif ( object._colorsTexture !== null ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'batchingColorTexture', object._colorsTexture, textures );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst morphAttributes = geometry.morphAttributes;\n\n\t\t\tif ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined ) ) {\n\n\t\t\t\tmorphtargets.update( object, geometry, program );\n\n\t\t\t}\n\n\t\t\tif ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {\n\n\t\t\t\tmaterialProperties.receiveShadow = object.receiveShadow;\n\t\t\t\tp_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );\n\n\t\t\t}\n\n\t\t\t// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512\n\n\t\t\tif ( material.isMeshGouraudMaterial && material.envMap !== null ) {\n\n\t\t\t\tm_uniforms.envMap.value = envMap;\n\n\t\t\t\tm_uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;\n\n\t\t\t}\n\n\t\t\tif ( material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null ) {\n\n\t\t\t\tm_uniforms.envMapIntensity.value = scene.environmentIntensity;\n\n\t\t\t}\n\n\t\t\tif ( refreshMaterial ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\n\n\t\t\t\tif ( materialProperties.needsLights ) {\n\n\t\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t// values\n\t\t\t\t\t//\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t// the GL state when required\n\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t\t}\n\n\t\t\t\t// refresh uniforms common to several materials\n\n\t\t\t\tif ( fog && material.fog === true ) {\n\n\t\t\t\t\tmaterials.refreshFogUniforms( m_uniforms, fog );\n\n\t\t\t\t}\n\n\t\t\t\tmaterials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[ camera.id ] );\n\n\t\t\t\tWebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );\n\n\t\t\t}\n\n\t\t\tif ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {\n\n\t\t\t\tWebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );\n\t\t\t\tmaterial.uniformsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( material.isSpriteMaterial ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'center', object.center );\n\n\t\t\t}\n\n\t\t\t// common matrices\n\n\t\t\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\n\t\t\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\n\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\t\t\t// UBOs\n\n\t\t\tif ( material.isShaderMaterial || material.isRawShaderMaterial ) {\n\n\t\t\t\tconst groups = material.uniformsGroups;\n\n\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\t\tuniformsGroups.update( group, program );\n\t\t\t\t\tuniformsGroups.bind( group, program );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\t\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\t\t\tuniforms.lightProbe.needsUpdate = value;\n\n\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\tuniforms.directionalLightShadows.needsUpdate = value;\n\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\tuniforms.pointLightShadows.needsUpdate = value;\n\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\tuniforms.spotLightShadows.needsUpdate = value;\n\t\t\tuniforms.rectAreaLights.needsUpdate = value;\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t\t}\n\n\t\tfunction materialNeedsLights( material ) {\n\n\t\t\treturn material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||\n\t\t\t\tmaterial.isMeshStandardMaterial || material.isShadowMaterial ||\n\t\t\t\t( material.isShaderMaterial && material.lights === true );\n\n\t\t}\n\n\t\tthis.getActiveCubeFace = function () {\n\n\t\t\treturn _currentActiveCubeFace;\n\n\t\t};\n\n\t\tthis.getActiveMipmapLevel = function () {\n\n\t\t\treturn _currentActiveMipmapLevel;\n\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn _currentRenderTarget;\n\n\t\t};\n\n\t\tthis.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {\n\n\t\t\tproperties.get( renderTarget.texture ).__webglTexture = colorTexture;\n\t\t\tproperties.get( renderTarget.depthTexture ).__webglTexture = depthTexture;\n\n\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\t\trenderTargetProperties.__hasExternalTextures = true;\n\n\t\t\trenderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;\n\n\t\t\tif ( ! renderTargetProperties.__autoAllocateDepthBuffer ) {\n\n\t\t\t\t// The multisample_render_to_texture extension doesn't work properly if there\n\t\t\t\t// are midframe flushes and an external depth buffer. Disable use of the extension.\n\t\t\t\tif ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided' );\n\t\t\t\t\trenderTargetProperties.__useRenderToTexture = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {\n\n\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\t\trenderTargetProperties.__webglFramebuffer = defaultFramebuffer;\n\t\t\trenderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;\n\n\t\t};\n\n\t\tconst _scratchFrameBuffer = _gl.createFramebuffer();\n\t\tthis.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {\n\n\t\t\t_currentRenderTarget = renderTarget;\n\t\t\t_currentActiveCubeFace = activeCubeFace;\n\t\t\t_currentActiveMipmapLevel = activeMipmapLevel;\n\n\t\t\tlet useDefaultFramebuffer = true;\n\t\t\tlet framebuffer = null;\n\t\t\tlet isCube = false;\n\t\t\tlet isRenderTarget3D = false;\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\t\t\tif ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {\n\n\t\t\t\t\t// We need to make sure to rebind the framebuffer.\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\t\t\t\t\tuseDefaultFramebuffer = false;\n\n\t\t\t\t} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {\n\n\t\t\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t\t\t} else if ( renderTargetProperties.__hasExternalTextures ) {\n\n\t\t\t\t\t// Color and depth texture must be rebound in order for the swapchain to update.\n\t\t\t\t\ttextures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );\n\n\t\t\t\t} else if ( renderTarget.depthBuffer ) {\n\n\t\t\t\t\t// check if the depth texture is already bound to the frame buffer and that it's been initialized\n\t\t\t\t\tconst depthTexture = renderTarget.depthTexture;\n\t\t\t\t\tif ( renderTargetProperties.__boundDepthTexture !== depthTexture ) {\n\n\t\t\t\t\t\t// check if the depth texture is compatible\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tdepthTexture !== null &&\n\t\t\t\t\t\t\tproperties.has( depthTexture ) &&\n\t\t\t\t\t\t\t( renderTarget.width !== depthTexture.image.width || renderTarget.height !== depthTexture.image.height )\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\tthrow new Error( 'WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Swap the depth buffer to the currently attached one\n\t\t\t\t\t\ttextures.setupDepthRenderbuffer( renderTarget );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst texture = renderTarget.texture;\n\n\t\t\t\tif ( texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\tisRenderTarget3D = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\t\tif ( renderTarget.isWebGLCubeRenderTarget ) {\n\n\t\t\t\t\tif ( Array.isArray( __webglFramebuffer[ activeCubeFace ] ) ) {\n\n\t\t\t\t\t\tframebuffer = __webglFramebuffer[ activeCubeFace ][ activeMipmapLevel ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tframebuffer = __webglFramebuffer[ activeCubeFace ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tisCube = true;\n\n\t\t\t\t} else if ( ( renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\t\tframebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( Array.isArray( __webglFramebuffer ) ) {\n\n\t\t\t\t\t\tframebuffer = __webglFramebuffer[ activeMipmapLevel ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tframebuffer = __webglFramebuffer;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t_currentViewport.copy( renderTarget.viewport );\n\t\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t\t} else {\n\n\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();\n\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();\n\t\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t\t}\n\n\t\t\t// Use a scratch frame buffer if rendering to a mip level to avoid depth buffers\n\t\t\t// being bound that are different sizes.\n\t\t\tif ( activeMipmapLevel !== 0 ) {\n\n\t\t\t\tframebuffer = _scratchFrameBuffer;\n\n\t\t\t}\n\n\t\t\tconst framebufferBound = state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\tif ( framebufferBound && useDefaultFramebuffer ) {\n\n\t\t\t\tstate.drawBuffers( renderTarget, framebuffer );\n\n\t\t\t}\n\n\t\t\tstate.viewport( _currentViewport );\n\t\t\tstate.scissor( _currentScissor );\n\t\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tconst textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );\n\n\t\t\t} else if ( isRenderTarget3D ) {\n\n\t\t\t\tconst textureProperties = properties.get( renderTarget.texture );\n\t\t\t\tconst layer = activeCubeFace;\n\t\t\t\t_gl.framebufferTextureLayer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel, layer );\n\n\t\t\t} else if ( renderTarget !== null && activeMipmapLevel !== 0 ) {\n\n\t\t\t\t// Only bind the frame buffer if we are using a scratch frame buffer to render to a mipmap.\n\t\t\t\t// If we rebind the texture when using a multi sample buffer then an error about inconsistent samples will be thrown.\n\t\t\t\tconst textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, textureProperties.__webglTexture, activeMipmapLevel );\n\n\t\t\t}\n\n\t\t\t_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings\n\n\t\t};\n\n\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {\n\n\t\t\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\tif ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {\n\n\t\t\t\tframebuffer = framebuffer[ activeCubeFaceIndex ];\n\n\t\t\t}\n\n\t\t\tif ( framebuffer ) {\n\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\ttry {\n\n\t\t\t\t\tconst texture = renderTarget.texture;\n\t\t\t\t\tconst textureFormat = texture.format;\n\t\t\t\t\tconst textureType = texture.type;\n\n\t\t\t\t\tif ( ! capabilities.textureFormatReadable( textureFormat ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! capabilities.textureTypeReadable( textureType ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t} finally {\n\n\t\t\t\t\t// restore framebuffer of current render target if necessary\n\n\t\t\t\t\tconst framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.readRenderTargetPixelsAsync = async function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {\n\n\t\t\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\n\n\t\t\t\tthrow new Error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\n\t\t\t}\n\n\t\t\tlet framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\t\t\tif ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {\n\n\t\t\t\tframebuffer = framebuffer[ activeCubeFaceIndex ];\n\n\t\t\t}\n\n\t\t\tif ( framebuffer ) {\n\n\t\t\t\tconst texture = renderTarget.texture;\n\t\t\t\tconst textureFormat = texture.format;\n\t\t\t\tconst textureType = texture.type;\n\n\t\t\t\tif ( ! capabilities.textureFormatReadable( textureFormat ) ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! capabilities.textureTypeReadable( textureType ) ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\n\t\t\t\t}\n\n\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t// set the active frame buffer to the one we want to read\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\t\tconst glBuffer = _gl.createBuffer();\n\t\t\t\t\t_gl.bindBuffer( _gl.PIXEL_PACK_BUFFER, glBuffer );\n\t\t\t\t\t_gl.bufferData( _gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ );\n\t\t\t\t\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), 0 );\n\n\t\t\t\t\t// reset the frame buffer to the currently set buffer before waiting\n\t\t\t\t\tconst currFramebuffer = _currentRenderTarget !== null ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, currFramebuffer );\n\n\t\t\t\t\t// check if the commands have finished every 8 ms\n\t\t\t\t\tconst sync = _gl.fenceSync( _gl.SYNC_GPU_COMMANDS_COMPLETE, 0 );\n\n\t\t\t\t\t_gl.flush();\n\n\t\t\t\t\tawait (0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.probeAsync)( _gl, sync, 4 );\n\n\t\t\t\t\t// read the data and delete the buffer\n\t\t\t\t\t_gl.bindBuffer( _gl.PIXEL_PACK_BUFFER, glBuffer );\n\t\t\t\t\t_gl.getBufferSubData( _gl.PIXEL_PACK_BUFFER, 0, buffer );\n\t\t\t\t\t_gl.deleteBuffer( glBuffer );\n\t\t\t\t\t_gl.deleteSync( sync );\n\n\t\t\t\t\treturn buffer;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.copyFramebufferToTexture = function ( texture, position = null, level = 0 ) {\n\n\t\t\t// support previous signature with position first\n\t\t\tif ( texture.isTexture !== true ) {\n\n\t\t\t\t// @deprecated, r165\n\t\t\t\t(0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.warnOnce)( 'WebGLRenderer: copyFramebufferToTexture function signature has changed.' );\n\n\t\t\t\tposition = arguments[ 0 ] || null;\n\t\t\t\ttexture = arguments[ 1 ];\n\n\t\t\t}\n\n\t\t\tconst levelScale = Math.pow( 2, - level );\n\t\t\tconst width = Math.floor( texture.image.width * levelScale );\n\t\t\tconst height = Math.floor( texture.image.height * levelScale );\n\n\t\t\tconst x = position !== null ? position.x : 0;\n\t\t\tconst y = position !== null ? position.y : 0;\n\n\t\t\ttextures.setTexture2D( texture, 0 );\n\n\t\t\t_gl.copyTexSubImage2D( _gl.TEXTURE_2D, level, 0, 0, x, y, width, height );\n\n\t\t\tstate.unbindTexture();\n\n\t\t};\n\n\t\tconst _srcFramebuffer = _gl.createFramebuffer();\n\t\tconst _dstFramebuffer = _gl.createFramebuffer();\n\t\tthis.copyTextureToTexture = function ( srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = null ) {\n\n\t\t\t// support previous signature with dstPosition first\n\t\t\tif ( srcTexture.isTexture !== true ) {\n\n\t\t\t\t// @deprecated, r165\n\t\t\t\t(0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.warnOnce)( 'WebGLRenderer: copyTextureToTexture function signature has changed.' );\n\n\t\t\t\tdstPosition = arguments[ 0 ] || null;\n\t\t\t\tsrcTexture = arguments[ 1 ];\n\t\t\t\tdstTexture = arguments[ 2 ];\n\t\t\t\tdstLevel = arguments[ 3 ] || 0;\n\t\t\t\tsrcRegion = null;\n\n\t\t\t}\n\n\t\t\t// support the previous signature with just a single dst mipmap level\n\t\t\tif ( dstLevel === null ) {\n\n\t\t\t\tif ( srcLevel !== 0 ) {\n\n\t\t\t\t\t// @deprecated, r171\n\t\t\t\t\t(0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.warnOnce)( 'WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.' );\n\t\t\t\t\tdstLevel = srcLevel;\n\t\t\t\t\tsrcLevel = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdstLevel = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// gather the necessary dimensions to copy\n\t\t\tlet width, height, depth, minX, minY, minZ;\n\t\t\tlet dstX, dstY, dstZ;\n\t\t\tconst image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ dstLevel ] : srcTexture.image;\n\t\t\tif ( srcRegion !== null ) {\n\n\t\t\t\twidth = srcRegion.max.x - srcRegion.min.x;\n\t\t\t\theight = srcRegion.max.y - srcRegion.min.y;\n\t\t\t\tdepth = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;\n\t\t\t\tminX = srcRegion.min.x;\n\t\t\t\tminY = srcRegion.min.y;\n\t\t\t\tminZ = srcRegion.isBox3 ? srcRegion.min.z : 0;\n\n\t\t\t} else {\n\n\t\t\t\tconst levelScale = Math.pow( 2, - srcLevel );\n\t\t\t\twidth = Math.floor( image.width * levelScale );\n\t\t\t\theight = Math.floor( image.height * levelScale );\n\t\t\t\tif ( srcTexture.isDataArrayTexture ) {\n\n\t\t\t\t\tdepth = image.depth;\n\n\t\t\t\t} else if ( srcTexture.isData3DTexture ) {\n\n\t\t\t\t\tdepth = Math.floor( image.depth * levelScale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdepth = 1;\n\n\t\t\t\t}\n\n\t\t\t\tminX = 0;\n\t\t\t\tminY = 0;\n\t\t\t\tminZ = 0;\n\n\t\t\t}\n\n\t\t\tif ( dstPosition !== null ) {\n\n\t\t\t\tdstX = dstPosition.x;\n\t\t\t\tdstY = dstPosition.y;\n\t\t\t\tdstZ = dstPosition.z;\n\n\t\t\t} else {\n\n\t\t\t\tdstX = 0;\n\t\t\t\tdstY = 0;\n\t\t\t\tdstZ = 0;\n\n\t\t\t}\n\n\t\t\t// Set up the destination target\n\t\t\tconst glFormat = utils.convert( dstTexture.format );\n\t\t\tconst glType = utils.convert( dstTexture.type );\n\t\t\tlet glTarget;\n\n\t\t\tif ( dstTexture.isData3DTexture ) {\n\n\t\t\t\ttextures.setTexture3D( dstTexture, 0 );\n\t\t\t\tglTarget = _gl.TEXTURE_3D;\n\n\t\t\t} else if ( dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture ) {\n\n\t\t\t\ttextures.setTexture2DArray( dstTexture, 0 );\n\t\t\t\tglTarget = _gl.TEXTURE_2D_ARRAY;\n\n\t\t\t} else {\n\n\t\t\t\ttextures.setTexture2D( dstTexture, 0 );\n\t\t\t\tglTarget = _gl.TEXTURE_2D;\n\n\t\t\t}\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\n\t\t\t// used for copying data from cpu\n\t\t\tconst currentUnpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );\n\t\t\tconst currentUnpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );\n\t\t\tconst currentUnpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );\n\t\t\tconst currentUnpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );\n\t\t\tconst currentUnpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, image.height );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, minX );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, minY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, minZ );\n\n\t\t\t// set up the src texture\n\t\t\tconst isSrc3D = srcTexture.isDataArrayTexture || srcTexture.isData3DTexture;\n\t\t\tconst isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture;\n\t\t\tif ( srcTexture.isDepthTexture ) {\n\n\t\t\t\tconst srcTextureProperties = properties.get( srcTexture );\n\t\t\t\tconst dstTextureProperties = properties.get( dstTexture );\n\t\t\t\tconst srcRenderTargetProperties = properties.get( srcTextureProperties.__renderTarget );\n\t\t\t\tconst dstRenderTargetProperties = properties.get( dstTextureProperties.__renderTarget );\n\t\t\t\tstate.bindFramebuffer( _gl.READ_FRAMEBUFFER, srcRenderTargetProperties.__webglFramebuffer );\n\t\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, dstRenderTargetProperties.__webglFramebuffer );\n\n\t\t\t\tfor ( let i = 0; i < depth; i ++ ) {\n\n\t\t\t\t\t// if the source or destination are a 3d target then a layer needs to be bound\n\t\t\t\t\tif ( isSrc3D ) {\n\n\t\t\t\t\t\t_gl.framebufferTextureLayer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get( srcTexture ).__webglTexture, srcLevel, minZ + i );\n\t\t\t\t\t\t_gl.framebufferTextureLayer( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get( dstTexture ).__webglTexture, dstLevel, dstZ + i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_gl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, _gl.DEPTH_BUFFER_BIT, _gl.NEAREST );\n\n\t\t\t\t}\n\n\t\t\t\tstate.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );\n\t\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );\n\n\t\t\t} else if ( srcLevel !== 0 || srcTexture.isRenderTargetTexture || properties.has( srcTexture ) ) {\n\n\t\t\t\t// get the appropriate frame buffers\n\t\t\t\tconst srcTextureProperties = properties.get( srcTexture );\n\t\t\t\tconst dstTextureProperties = properties.get( dstTexture );\n\n\t\t\t\t// bind the frame buffer targets\n\t\t\t\tstate.bindFramebuffer( _gl.READ_FRAMEBUFFER, _srcFramebuffer );\n\t\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, _dstFramebuffer );\n\n\t\t\t\tfor ( let i = 0; i < depth; i ++ ) {\n\n\t\t\t\t\t// assign the correct layers and mip maps to the frame buffers\n\t\t\t\t\tif ( isSrc3D ) {\n\n\t\t\t\t\t\t_gl.framebufferTextureLayer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, srcTextureProperties.__webglTexture, srcLevel, minZ + i );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_gl.framebufferTexture2D( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, srcTextureProperties.__webglTexture, srcLevel );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( isDst3D ) {\n\n\t\t\t\t\t\t_gl.framebufferTextureLayer( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, dstTextureProperties.__webglTexture, dstLevel, dstZ + i );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, dstTextureProperties.__webglTexture, dstLevel );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// copy the data using the fastest function that can achieve the copy\n\t\t\t\t\tif ( srcLevel !== 0 ) {\n\n\t\t\t\t\t\t_gl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, _gl.COLOR_BUFFER_BIT, _gl.NEAREST );\n\n\t\t\t\t\t} else if ( isDst3D ) {\n\n\t\t\t\t\t\t_gl.copyTexSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ + i, minX, minY, width, height );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_gl.copyTexSubImage2D( glTarget, dstLevel, dstX, dstY, minX, minY, width, height );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// unbind read, draw buffers\n\t\t\t\tstate.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );\n\t\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );\n\n\t\t\t} else {\n\n\t\t\t\tif ( isDst3D ) {\n\n\t\t\t\t\t// copy data into the 3d texture\n\t\t\t\t\tif ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {\n\n\t\t\t\t\t\t_gl.texSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image.data );\n\n\t\t\t\t\t} else if ( dstTexture.isCompressedArrayTexture ) {\n\n\t\t\t\t\t\t_gl.compressedTexSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, image.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_gl.texSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// copy data into the 2d texture\n\t\t\t\t\tif ( srcTexture.isDataTexture ) {\n\n\t\t\t\t\t\t_gl.texSubImage2D( _gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image.data );\n\n\t\t\t\t\t} else if ( srcTexture.isCompressedTexture ) {\n\n\t\t\t\t\t\t_gl.compressedTexSubImage2D( _gl.TEXTURE_2D, dstLevel, dstX, dstY, image.width, image.height, glFormat, image.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_gl.texSubImage2D( _gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// reset values\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );\n\n\t\t\t// Generate mipmaps only when copying level 0\n\t\t\tif ( dstLevel === 0 && dstTexture.generateMipmaps ) {\n\n\t\t\t\t_gl.generateMipmap( glTarget );\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t};\n\n\t\tthis.copyTextureToTexture3D = function ( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {\n\n\t\t\t// support previous signature with source box first\n\t\t\tif ( srcTexture.isTexture !== true ) {\n\n\t\t\t\t// @deprecated, r165\n\t\t\t\t(0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.warnOnce)( 'WebGLRenderer: copyTextureToTexture3D function signature has changed.' );\n\n\t\t\t\tsrcRegion = arguments[ 0 ] || null;\n\t\t\t\tdstPosition = arguments[ 1 ] || null;\n\t\t\t\tsrcTexture = arguments[ 2 ];\n\t\t\t\tdstTexture = arguments[ 3 ];\n\t\t\t\tlevel = arguments[ 4 ] || 0;\n\n\t\t\t}\n\n\t\t\t// @deprecated, r170\n\t\t\t(0,_three_core_js__WEBPACK_IMPORTED_MODULE_0__.warnOnce)( 'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use \"copyTextureToTexture\" instead.' );\n\n\t\t\treturn this.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level );\n\n\t\t};\n\n\t\tthis.initRenderTarget = function ( target ) {\n\n\t\t\tif ( properties.get( target ).__webglFramebuffer === undefined ) {\n\n\t\t\t\ttextures.setupRenderTarget( target );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.initTexture = function ( texture ) {\n\n\t\t\tif ( texture.isCubeTexture ) {\n\n\t\t\t\ttextures.setTextureCube( texture, 0 );\n\n\t\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\t\ttextures.setTexture3D( texture, 0 );\n\n\t\t\t} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\t\ttextures.setTexture2DArray( texture, 0 );\n\n\t\t\t} else {\n\n\t\t\t\ttextures.setTexture2D( texture, 0 );\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t};\n\n\t\tthis.resetState = function () {\n\n\t\t\t_currentActiveCubeFace = 0;\n\t\t\t_currentActiveMipmapLevel = 0;\n\t\t\t_currentRenderTarget = null;\n\n\t\t\tstate.reset();\n\t\t\tbindingStates.reset();\n\n\t\t};\n\n\t\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );\n\n\t\t}\n\n\t}\n\n\tget coordinateSystem() {\n\n\t\treturn _three_core_js__WEBPACK_IMPORTED_MODULE_0__.WebGLCoordinateSystem;\n\n\t}\n\n\tget outputColorSpace() {\n\n\t\treturn this._outputColorSpace;\n\n\t}\n\n\tset outputColorSpace( colorSpace ) {\n\n\t\tthis._outputColorSpace = colorSpace;\n\n\t\tconst gl = this.getContext();\n\t\tgl.drawingBufferColorspace = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement._getDrawingBufferColorSpace( colorSpace );\n\t\tgl.unpackColorSpace = _three_core_js__WEBPACK_IMPORTED_MODULE_0__.ColorManagement._getUnpackColorSpace();\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdGhyZWVAMC4xNzIuMC9ub2RlX21vZHVsZXMvdGhyZWUvYnVpbGQvdGhyZWUubW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDazJHO0FBQzJYOztBQUU3dEg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IseUJBQXlCOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw2Q0FBNkMsT0FBTzs7QUFFcEQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxxSEFBcUg7O0FBRXJILDJGQUEyRixnQ0FBZ0MsdUhBQXVILEtBQUssZ0NBQWdDLDJEQUEyRCxLQUFLLGtEQUFrRCxnSEFBZ0gsNkRBQTZELHNIQUFzSCwySUFBMkksbURBQW1ELHNFQUFzRSxvREFBb0QsdUxBQXVMLHdHQUF3Ryw4Q0FBOEMsS0FBSzs7QUFFdHpDLHVHQUF1Rzs7QUFFdkcsZ0ZBQWdGOztBQUVoRiw2S0FBNksseUNBQXlDLHVEQUF1RDs7QUFFN1EsK0VBQStFOztBQUUvRSxtSUFBbUksdURBQXVELHFGQUFxRix1RkFBdUYscUlBQXFJLGlIQUFpSDs7QUFFNWxCLHVFQUF1RSxpQ0FBaUM7O0FBRXhHLGtKQUFrSixzREFBc0QsK0NBQStDLGdEQUFnRCxxREFBcUQsMkJBQTJCLHVCQUF1Qix1QkFBdUIsZ0VBQWdFLG9FQUFvRSxvRUFBb0Usb0VBQW9FLG9DQUFvQyxLQUFLLDhDQUE4Qyx1REFBdUQsdUJBQXVCLHVCQUF1QiwwRUFBMEUsS0FBSyw4RUFBOEUsK0NBQStDLDBEQUEwRCx1QkFBdUIsdUJBQXVCLHVCQUF1QixzRUFBc0UsS0FBSzs7QUFFbndDLHVIQUF1SDs7QUFFdkgsd0RBQXdELHVEQUF1RDs7QUFFL0csNkRBQTZELGlFQUFpRTs7QUFFOUgsNkNBQTZDLGdCQUFnQixHQUFHLHdFQUF3RSwrRUFBK0UsR0FBRyxzSkFBc0osbURBQW1ELHFEQUFxRCxzREFBc0Qsb0RBQW9ELHVDQUF1QywrQ0FBK0MseUJBQXlCLElBQUk7O0FBRXJyQixzTkFBc04seUNBQXlDLHFDQUFxQyxpRUFBaUUsS0FBSyxrRUFBa0UseUdBQXlHLEtBQUssb0VBQW9FLHdGQUF3RixLQUFLLG1EQUFtRCw0Q0FBNEMsNERBQTRELDREQUE0RCw0REFBNEQsMEdBQTBHLHlJQUF5SSx1QkFBdUIscUNBQXFDLGlCQUFpQixLQUFLLGlIQUFpSCxhQUFhLGlHQUFpRyw0RkFBNEYsNENBQTRDLGdDQUFnQywyQkFBMkIsT0FBTyw0Q0FBNEMsNkRBQTZELGtEQUFrRCw2QkFBNkIsd0JBQXdCLG9EQUFvRCwrQkFBK0IsbUVBQW1FLHVEQUF1RCxpREFBaUQsK0JBQStCLDJEQUEyRCwyREFBMkQsMkRBQTJELHVFQUF1RSx1Q0FBdUMsbURBQW1ELCtCQUErQiw0REFBNEQseUJBQXlCLGFBQWEsMEJBQTBCLHVCQUF1QixRQUFRLFFBQVEsbUJBQW1CLDhFQUE4RSxxQkFBcUIsT0FBTyxtQ0FBbUMsS0FBSzs7QUFFbDJGLDZFQUE2RSw0QkFBNEIsc0JBQXNCLHNDQUFzQyxzQ0FBc0MsaUVBQWlFLCtFQUErRSwrRUFBK0UsOEJBQThCLEtBQUssNkZBQTZGLHVEQUF1RCx1REFBdUQsMEJBQTBCLHFDQUFxQyxxQ0FBcUMsc0RBQXNELGtFQUFrRSwwREFBMEQsS0FBSzs7QUFFbjdCLDBFQUEwRSwwRUFBMEUsOEJBQThCLHNEQUFzRCwyQkFBMkIsUUFBUSxvQ0FBb0Msc0VBQXNFLDJEQUEyRCwyRkFBMkYsMENBQTBDLE9BQU8sdUhBQXVILDhFQUE4RSx5QkFBeUIsUUFBUSxzQ0FBc0Msd0VBQXdFLDZEQUE2RCx3R0FBd0csU0FBUyw2RUFBNkUsZ0RBQWdELDJDQUEyQywrREFBK0QsMkJBQTJCLFFBQVEsb0NBQW9DLGlFQUFpRSxPQUFPLDhHQUE4Ryw4RUFBOEUseUJBQXlCLFFBQVEsc0NBQXNDLDZFQUE2RSxTQUFTLDhEQUE4RDs7QUFFMzBELCtGQUErRix1REFBdUQ7O0FBRXRKLDZGQUE2Rjs7QUFFN0YsOEZBQThGOztBQUU5RiwrRUFBK0UsMkRBQTJEOztBQUUxSSxpRkFBaUYsb0RBQW9EOztBQUVySSwrRUFBK0Usd0hBQXdIOztBQUV2TSwyRUFBMkUseUhBQXlILDhDQUE4Qyx5RUFBeUUsOEdBQThHLG9DQUFvQzs7QUFFN2Msd1hBQXdYLGFBQWEsaUNBQWlDLGFBQWEsbUNBQW1DLGVBQWUsbUNBQW1DLGdCQUFnQixlQUFlLGtDQUFrQyxxQ0FBcUMscUNBQXFDLHFDQUFxQyx3Q0FBd0MsOERBQThELG1FQUFtRSxrQ0FBa0MsR0FBRyxpRUFBaUUscUJBQXFCLGdEQUFnRCw0Q0FBNEMsdURBQXVELEtBQUssZ0NBQWdDLGVBQWUsbUJBQW1CLGlCQUFpQixJQUFJLHlCQUF5Qix1QkFBdUIsd0JBQXdCLHlCQUF5QiwwQkFBMEIsSUFBSSxpREFBaUQsa0VBQWtFLDBEQUEwRCxHQUFHLGlFQUFpRSwwREFBMEQsR0FBRyx5Q0FBeUMsYUFBYSxvREFBb0Qsb0RBQW9ELG9EQUFvRCxlQUFlLEdBQUcsc0NBQXNDLGdDQUFnQyxHQUFHLGtDQUFrQywwREFBMEQsdUVBQXVFLHdCQUF3QixHQUFHLG1EQUFtRCx3Q0FBd0MsR0FBRyxnRkFBZ0Ysb0VBQW9FLHNEQUFzRCxHQUFHLGtGQUFrRixvRUFBb0Usc0RBQXNELElBQUk7O0FBRTlsRix1S0FBdUssMkNBQTJDLHlCQUF5Qiw4Q0FBOEMsNkZBQTZGLDJEQUEyRCxRQUFRLE1BQU0sNkZBQTZGLDJEQUEyRCxPQUFPLGtCQUFrQixLQUFLLDhDQUE4QyxjQUFjLDBCQUEwQixtRUFBbUUsUUFBUSx5QkFBeUIsdUVBQXVFLFFBQVEseUJBQXlCLHFFQUFxRSxRQUFRLHlCQUF5QixxRUFBcUUsUUFBUSx5QkFBeUIscUVBQXFFLFFBQVEsTUFBTSxtRUFBbUUsT0FBTyxnQ0FBZ0MsS0FBSywyRUFBMkUsd0NBQXdDLGdFQUFnRSxpREFBaUQsc0NBQXNDLDBFQUEwRSx5QkFBeUIseUJBQXlCLG9CQUFvQixPQUFPLDhCQUE4QixtREFBbUQsMERBQTBELGlDQUFpQyxrQ0FBa0MseUdBQXlHLHNEQUFzRCxpQkFBaUIsOFNBQThTLHNCQUFzQixxQ0FBcUMsNEdBQTRHLFFBQVEsb0NBQW9DLDRHQUE0RyxRQUFRLG9DQUFvQyw0R0FBNEcsUUFBUSxvQ0FBb0MsNEdBQTRHLFFBQVEsTUFBTSwrQ0FBK0MsS0FBSyxpQkFBaUIsS0FBSyw2RUFBNkUsa0ZBQWtGLGdDQUFnQyxrQ0FBa0MsZ0VBQWdFLDBCQUEwQixtQ0FBbUMsUUFBUSxNQUFNLHdFQUF3RSx3REFBd0QsT0FBTyxLQUFLOztBQUVqakgsa0VBQWtFLGdFQUFnRSxrRUFBa0UsMkdBQTJHLCtDQUErQyx5RUFBeUUsOEVBQThFLDJHQUEyRywrQ0FBK0MseUVBQXlFLHlFQUF5RSwrREFBK0QsK0dBQStHLHFFQUFxRTs7QUFFcGhDLG1HQUFtRyxvQ0FBb0MsbUNBQW1DOztBQUUxSyxxTUFBcU07O0FBRXJNLG9IQUFvSCxnR0FBZ0cseURBQXlEOztBQUU3USx5RkFBeUY7O0FBRXpGLDhFQUE4RTs7QUFFOUUsMEVBQTBFLGlCQUFpQixHQUFHLDBDQUEwQyxzTEFBc0wsR0FBRywwQ0FBMEMsdUtBQXVLLEdBQUc7O0FBRXJoQix1RkFBdUYsNkJBQTZCLG1IQUFtSCxRQUFRLE1BQU0sb0VBQW9FLE9BQU8seUVBQXlFLGtHQUFrRywyRkFBMkYsc0RBQXNELG9KQUFvSiwyQ0FBMkMsdUpBQXVKLGtJQUFrSSw4R0FBOEc7O0FBRWxzQyxzRkFBc0YsNkJBQTZCLGdDQUFnQyw0REFBNEQsd0NBQXdDOztBQUV2UCw0RUFBNEUsaU1BQWlNLG9DQUFvQyxxQ0FBcUM7O0FBRXRWLGtQQUFrUCxxQ0FBcUMsb0NBQW9DOztBQUUzVCxzR0FBc0csbUNBQW1DLDZCQUE2QixxSEFBcUgsUUFBUSxNQUFNLHlFQUF5RSxPQUFPLG9GQUFvRiw2RkFBNkYsc0ZBQXNGOztBQUVob0IsK0RBQStEOztBQUUvRCxpRUFBaUU7O0FBRWpFLDRJQUE0SSwwRUFBMEUsOEVBQThFOztBQUVwUyxpRUFBaUUsNEJBQTRCLGtEQUFrRCxxQ0FBcUMsMkJBQTJCOztBQUUvTSx5RkFBeUYsMEVBQTBFLGdEQUFnRCxnREFBZ0QsaUZBQWlGLCtDQUErQyw0RkFBNEYsYUFBYTs7QUFFNWUsZ0ZBQWdGLG9DQUFvQzs7QUFFcEgsd0RBQXdELDJDQUEyQywrQ0FBK0M7O0FBRWxKLCtEQUErRCwwQkFBMEIsc0JBQXNCLDJCQUEyQixJQUFJLDRRQUE0USwyRUFBMkUsZ0RBQWdELHVGQUF1RixHQUFHLDJRQUEyUSx5RkFBeUYsR0FBRzs7QUFFdDlCLG9EQUFvRCxpQ0FBaUMsa0VBQWtFLGlGQUFpRixtREFBbUQsaURBQWlELHVEQUF1RCx1REFBdUQsdURBQXVELDJEQUEyRCwyREFBMkQsb0VBQW9FLDJEQUEyRCxpRUFBaUUsa0JBQWtCLEdBQUcsdUZBQXVGLHVFQUF1RSxtRUFBbUUsc0JBQXNCLEdBQUcscUVBQXFFLHdDQUF3QyxzQkFBc0IsR0FBRyw2SEFBNkgsbUZBQW1GLGlDQUFpQywwRkFBMEYsS0FBSywyQkFBMkIsR0FBRyxvSEFBb0gsaUVBQWlFLEdBQUcscURBQXFELHFCQUFxQixpQkFBaUIsTUFBTSxpRUFBaUUseUdBQXlHLDJDQUEyQyxtREFBbUQsMkJBQTJCLEtBQUsseURBQXlELG9CQUFvQixpQkFBaUIscUJBQXFCLGtCQUFrQixNQUFNLHVEQUF1RCx1SEFBdUgsNERBQTRELDZDQUE2Qyw4Q0FBOEMscUNBQXFDLG9HQUFvRyxxREFBcUQsS0FBSyx1REFBdUQsb0JBQW9CLHFCQUFxQixpQkFBaUIscUJBQXFCLGtCQUFrQixvQkFBb0Isd0JBQXdCLE1BQU0sb0RBQW9ELG9IQUFvSCwyREFBMkQsNkNBQTZDLG1FQUFtRSx1R0FBdUcsb0NBQW9DLGdEQUFnRCx3REFBd0Qsb0dBQW9HLHVEQUF1RCxRQUFRLE1BQU0sa0NBQWtDLDhCQUE4QixPQUFPLEtBQUssZ0VBQWdFLGlCQUFpQixvQkFBb0IscUJBQXFCLHNCQUFzQixNQUFNLDRCQUE0QiwwQkFBMEIsaUVBQWlFLDZEQUE2RCxxQkFBcUIsb0JBQW9CLHVCQUF1QixNQUFNLGdFQUFnRSxtR0FBbUcsdURBQXVELGtEQUFrRCw0RkFBNEYsd0JBQXdCLEtBQUs7O0FBRXhoSix5R0FBeUcsMkdBQTJHLHNGQUFzRixzREFBc0Qsc0NBQXNDLGlCQUFpQixrR0FBa0csdUZBQXVGLGtGQUFrRix5RUFBeUUsMkZBQTJGLGlEQUFpRCxzQ0FBc0MsaUJBQWlCLDJMQUEyTCwwRkFBMEYsbUVBQW1FLHNIQUFzSCxrRUFBa0UsMENBQTBDLHFCQUFxQjs7QUFFNy9DLGtEQUFrRCwyQ0FBMkM7O0FBRTdGLDREQUE0RCx1QkFBdUIsc0JBQXNCLElBQUksc1FBQXNRLHlHQUF5Ryx1RkFBdUYsR0FBRyxxUUFBcVEseUZBQXlGLEdBQUc7O0FBRXY1Qix5REFBeUQsMkNBQTJDLG9DQUFvQyx5Q0FBeUMsK0NBQStDOztBQUVoTyw2REFBNkQsNkJBQTZCLHNCQUFzQix1QkFBdUIsNEJBQTRCLDJCQUEyQixJQUFJLGtSQUFrUiwyRUFBMkUsZ0RBQWdELHVGQUF1Riw0TUFBNE0sR0FBRyxpUkFBaVIseUZBQXlGLEdBQUc7O0FBRWx1QywwREFBMEQsdUVBQXVFLHlGQUF5Riw4REFBOEQsc0RBQXNELHdDQUF3QyxzREFBc0QsbUNBQW1DLCtFQUErRSwrQ0FBK0Msd0hBQXdILGtKQUFrSiw4RkFBOEYsbURBQW1ELDZDQUE2QyxpQ0FBaUMsNk1BQTZNLDJGQUEyRiwrQkFBK0IsaUVBQWlFLHFEQUFxRCx3Q0FBd0MsZ0NBQWdDLG9HQUFvRyxtSkFBbUosa0VBQWtFLDJFQUEyRSxxREFBcUQsMEVBQTBFLG9FQUFvRSx1RUFBdUUsNkNBQTZDLDRHQUE0RyxzUEFBc1AsMkVBQTJFLHlFQUF5RSwyR0FBMkcsMkVBQTJFLHlIQUF5SCx5TEFBeUwsOEVBQThFLGlIQUFpSCxtREFBbUQsMERBQTBELHNDQUFzQyxxQ0FBcUMsTUFBTSxNQUFNLHlDQUF5Qyw0REFBNEQsS0FBSywwRkFBMEYsK0VBQStFLCtFQUErRTs7QUFFejdILDhEQUE4RCxzQkFBc0Isb0JBQW9CLHVCQUF1QixzQkFBc0IscUJBQXFCLDhDQUE4QywrQkFBK0IsdUJBQXVCLHlCQUF5Qiw0REFBNEQsMkJBQTJCLGlDQUFpQyw4QkFBOEIseUJBQXlCLG9EQUFvRCwyQkFBMkIsd0NBQXdDLDhEQUE4RCw4QkFBOEIsc0JBQXNCLGdDQUFnQyw0QkFBNEIsMERBQTBELG1CQUFtQix1QkFBdUIsdUJBQXVCLGNBQWMsNkNBQTZDLCtDQUErQyx5Q0FBeUMsMENBQTBDLG1GQUFtRiwrQ0FBK0MsdUJBQXVCLG1EQUFtRCxxREFBcUQsR0FBRyxtR0FBbUcsNkJBQTZCLGlFQUFpRSxpRUFBaUUseUNBQXlDLEdBQUcsNkRBQTZELDZCQUE2QixxREFBcUQsOENBQThDLEdBQUcsd1BBQXdQLGlGQUFpRixpRkFBaUYsa0NBQWtDLHlCQUF5QixLQUFLLCtJQUErSSxpQ0FBaUMsd0VBQXdFLG1DQUFtQyx5QkFBeUIsOENBQThDLEtBQUsscUtBQXFLLHFDQUFxQyx3Q0FBd0Msb0RBQW9ELHNDQUFzQyxxREFBcUQsd0RBQXdELHVEQUF1RCx1REFBdUQsd0RBQXdELDJDQUEyQyw2REFBNkQsc0NBQXNDLDJCQUEyQixLQUFLLG9JQUFvSSxxQ0FBcUMscUNBQXFDLHlDQUF5QyxvQ0FBb0MsbURBQW1ELHNEQUFzRCxxREFBcUQscURBQXFELHNEQUFzRCx5Q0FBeUMsZ0dBQWdHLDZGQUE2Rix5REFBeUQseURBQXlELDBEQUEwRCx5REFBeUQseURBQXlELHNIQUFzSCxpRkFBaUYsc0VBQXNFLHNDQUFzQyxtQ0FBbUMsR0FBRyw2RUFBNkUsZ0NBQWdDLDBEQUEwRCwwQ0FBMEMsMENBQTBDLHFEQUFxRCxtQ0FBbUMsY0FBYyxHQUFHLHdEQUF3RCwwQkFBMEIscURBQXFELEdBQUcsdUVBQXVFLDRCQUE0Qix1QkFBdUIsNERBQTRELGdEQUFnRCxvQkFBb0IsK0ZBQStGLDRDQUE0QyxHQUFHLDZIQUE2SCxnREFBZ0QsZ0RBQWdELHVDQUF1QywyRUFBMkUsZ0JBQWdCLDBDQUEwQywwQkFBMEIseURBQXlELHFCQUFxQixnREFBZ0QsZ0RBQWdELGdEQUFnRCxnREFBZ0QsMkNBQTJDLDJDQUEyQywyQ0FBMkMsMkNBQTJDLHdDQUF3Qyw2RUFBNkUsNkVBQTZFLDZFQUE2RSw2RUFBNkUsbUVBQW1FLDBCQUEwQixHQUFHLDZFQUE2RSxvQ0FBb0MsaUNBQWlDLGdDQUFnQyxnREFBZ0QsNEVBQTRFLEdBQUcsK0NBQStDLHlFQUF5RSxHQUFHLDBJQUEwSSxtREFBbUQsc0RBQXNELHFEQUFxRCxxREFBcUQsaURBQWlELHdDQUF3QyxrQ0FBa0MsR0FBRyx1R0FBdUcscURBQXFELHFDQUFxQywrR0FBK0csMkdBQTJHLDhGQUE4RiwwQ0FBMEMsR0FBRywyRkFBMkYscURBQXFELDBEQUEwRCxvREFBb0QsaUNBQWlDLHNFQUFzRSxrREFBa0QsZUFBZSxHQUFHLDBKQUEwSix1REFBdUQsdURBQXVELEdBQUcsZ1RBQWdULDJOQUEyTiwrREFBK0QsMkZBQTJGLHVDQUF1Qyw2REFBNkQsOEJBQThCLDBCQUEwQiw2Q0FBNkMsa0RBQWtELDRCQUE0Qiw4QkFBOEIsR0FBRyx5VEFBeVQsbUNBQW1DLHFDQUFxQyx1Q0FBdUMsNkNBQTZDLCtDQUErQyxpREFBaUQsNENBQTRDLDJDQUEyQywyQkFBMkIsMERBQTBELHdEQUF3RCwwREFBMEQsMERBQTBELHFEQUFxRCx1Q0FBdUMsdUNBQXVDLHdIQUF3SCx5R0FBeUcsMEhBQTBILDhJQUE4SSxLQUFLLHNSQUFzUiwyRUFBMkUsZ0RBQWdELGdIQUFnSCxzREFBc0QsZ0pBQWdKLDJMQUEyTCx5SUFBeUksdUZBQXVGLEdBQUcsNlFBQTZRLHlGQUF5RixHQUFHLHNVQUFzVSxxTkFBcU4seUtBQXlLLGtEQUFrRCx1Q0FBdUMsK0RBQStELDZQQUE2UCw4S0FBOEssd0VBQXdFLDJIQUEySCxtRUFBbUUsa0ZBQWtGLHlFQUF5RSxHQUFHLHFWQUFxVixrSEFBa0gsR0FBRzs7QUFFbGdlLHVFQUF1RSwrQkFBK0IsMkZBQTJGLDZDQUE2QyxvRUFBb0UsOEZBQThGLGlEQUFpRCxpQ0FBaUMsTUFBTSxNQUFNLDhEQUE4RCxLQUFLLHVDQUF1QyxtSkFBbUoseUZBQXlGLEtBQUssb0NBQW9DLGdGQUFnRixxR0FBcUcsNERBQTRELHNCQUFzQixRQUFRLG9DQUFvQyxxRUFBcUUsdUlBQXVJLDZVQUE2VSxpSkFBaUosS0FBSyxnSEFBZ0gsbUJBQW1CLHdCQUF3Qix3QkFBd0Isa0dBQWtHLDREQUE0RCxxQkFBcUIsUUFBUSxrQ0FBa0MsbUVBQW1FLDRmQUE0Zix5RkFBeUYseUZBQXlGLG1HQUFtRyxpTEFBaUwsNFBBQTRQLGlKQUFpSixLQUFLLDZIQUE2SCwrR0FBK0csNERBQTRELG9CQUFvQixRQUFRLGdEQUFnRCwrREFBK0QsaUpBQWlKLHVTQUF1UyxpSkFBaUosS0FBSyxzSUFBc0ksa0RBQWtELDBCQUEwQixRQUFRLDBDQUEwQyxnSkFBZ0osS0FBSywyR0FBMkcscUVBQXFFLDZHQUE2RywrRkFBK0YscUJBQXFCLFFBQVEsNEZBQTRGLE9BQU8sbUhBQW1ILHlDQUF5Qzs7QUFFeHFMLGtKQUFrSixzRUFBc0UsdUNBQXVDLDBKQUEwSixxUEFBcVAsaUdBQWlHLHFKQUFxSjs7QUFFcDRCLHVNQUF1TSx3TkFBd047O0FBRS9aLCtKQUErSjs7QUFFL0osK0ZBQStGLDZCQUE2QixpQ0FBaUM7O0FBRTdKLGtGQUFrRixpQ0FBaUM7O0FBRW5ILHFGQUFxRixzRUFBc0U7O0FBRTNKLDBGQUEwRixtR0FBbUcsa0RBQWtEOztBQUUvTyxpRUFBaUU7O0FBRWpFLGtJQUFrSSxnR0FBZ0csMkVBQTJFLCtFQUErRTs7QUFFNVgsbUZBQW1GLDJGQUEyRiw0REFBNEQsNERBQTREOztBQUV0UywrREFBK0QsOEZBQThGLHdDQUF3Qzs7QUFFck0sNEZBQTRGOztBQUU1Riw2R0FBNkcsZ0dBQWdHLHFCQUFxQix3QkFBd0IsUUFBUSxpR0FBaUcsS0FBSzs7QUFFeFcsOEZBQThGLHFCQUFxQix3QkFBd0IsUUFBUSwwSkFBMEosMEpBQTBKLGlCQUFpQjs7QUFFeGQsOEZBQThGLHFCQUFxQix3QkFBd0IsUUFBUSw4SEFBOEgsS0FBSzs7QUFFdFIsbUlBQW1JLGdFQUFnRSx5REFBeUQsMENBQTBDLG1HQUFtRywwRUFBMEUscURBQXFELHlEQUF5RCxzREFBc0QsMkRBQTJELEtBQUs7O0FBRXZyQiw2RkFBNkYscUJBQXFCLHdCQUF3QixRQUFRLDZIQUE2SCxLQUFLOztBQUVwUixnRkFBZ0YseURBQXlELHFDQUFxQyxpREFBaUQsOENBQThDLHFEQUFxRCxzT0FBc08sOE9BQThPLG1HQUFtRyw4QkFBOEIseUpBQXlKLDZGQUE2RixvR0FBb0csK0JBQStCLHFEQUFxRDs7QUFFcjBDLDhIQUE4SCw2Q0FBNkMsdUVBQXVFLDBEQUEwRCxrSEFBa0gsMkJBQTJCLHFDQUFxQyxtSEFBbUg7O0FBRWpsQix3RUFBd0Usa0RBQWtELDhCQUE4Qjs7QUFFeEosc0VBQXNFLGtEQUFrRCw4QkFBOEI7O0FBRXRKLHFGQUFxRix1RUFBdUUsdUVBQXVFOztBQUVuTyxtRkFBbUYsNkJBQTZCLHdFQUF3RSw0TkFBNE4sb0NBQW9DLG9DQUFvQywrQkFBK0IsK0JBQStCLHlCQUF5QixtQ0FBbUMsbUNBQW1DLCtDQUErQywrQ0FBK0Msa0RBQWtELDhEQUE4RCw2Q0FBNkMsS0FBSzs7QUFFejNCLHlHQUF5Rzs7QUFFekcsb0tBQW9LLDZDQUE2Qyx3REFBd0Q7O0FBRXpRLHlGQUF5RixpRkFBaUYsc0NBQXNDLHVGQUF1Rjs7QUFFdlMsK0ZBQStGLDJGQUEyRjs7QUFFMUwsMkRBQTJELGdGQUFnRiwrREFBK0Q7O0FBRTFNLDZEQUE2RCwyQ0FBMkMsR0FBRywrQ0FBK0MsK0JBQStCLEdBQUcsd0NBQXdDLDBDQUEwQyxvQ0FBb0MsaUNBQWlDLG9GQUFvRiwyRUFBMkUsNEZBQTRGLDZGQUE2Riw0Q0FBNEMsc0RBQXNELHNEQUFzRCxjQUFjLDhDQUE4Qyw4Q0FBOEMsOENBQThDLHdFQUF3RSxHQUFHLDJDQUEyQyxrREFBa0Qsa0RBQWtELGNBQWMsOENBQThDLDhDQUE4QyxzREFBc0QsR0FBRywwQ0FBMEMsOENBQThDLDhDQUE4QyxjQUFjLHFDQUFxQyxvQ0FBb0MsR0FBRyw4Q0FBOEMsb0NBQW9DLEdBQUcsNkNBQTZDLG9DQUFvQyxHQUFHLDRDQUE0QywyREFBMkQsR0FBRywyQ0FBMkMsMEVBQTBFLGtFQUFrRSxHQUFHLDZDQUE2QyxnRUFBZ0UsR0FBRyxtR0FBbUcsNkNBQTZDLEdBQUcsbUdBQW1HLHlDQUF5QyxHQUFHLGtHQUFrRyxtRUFBbUUsR0FBRyxrR0FBa0csNkRBQTZELEdBQUc7O0FBRWp1RixxR0FBcUc7O0FBRXJHLGlFQUFpRSxrRUFBa0UsNEVBQTRFLG9EQUFvRCw4Q0FBOEM7O0FBRWpULCtGQUErRjs7QUFFL0YsaUZBQWlGLG9EQUFvRCxnRkFBZ0YsK0ZBQStGLHNDQUFzQyxLQUFLOztBQUUvViwrREFBK0QsOEZBQThGLHdDQUF3Qzs7QUFFck0sNEZBQTRGOztBQUU1RixzSEFBc0gsK0ZBQStGLHFJQUFxSSxvRUFBb0UscUNBQXFDLDhCQUE4Qix5QkFBeUIsK0JBQStCLDJCQUEyQiwyQkFBMkIsUUFBUSxzRkFBc0YsNEdBQTRHLDhCQUE4Qiw4QkFBOEIseUJBQXlCLCtCQUErQiwyQkFBMkIsMkJBQTJCLFFBQVEseUVBQXlFLCtHQUErRyxnRUFBZ0UsK0JBQStCLDhCQUE4Qix5QkFBeUIsK0JBQStCLDJCQUEyQiwyQkFBMkIsK0JBQStCLDhCQUE4QixRQUFRLDRFQUE0RSxrRkFBa0YsMkVBQTJFLEtBQUssNkRBQTZELDBEQUEwRCxLQUFLLGdFQUFnRSw0QkFBNEIsOERBQThELDJEQUEyRCxnQ0FBZ0MsbURBQW1ELHlFQUF5RSxrRkFBa0YsZ0dBQWdHLDhFQUE4RSxPQUFPLHVCQUF1QixLQUFLLCtJQUErSSx5QkFBeUIsdUNBQXVDLGtDQUFrQyxvSEFBb0gsMkRBQTJELDBCQUEwQiw0RkFBNEYsaURBQWlELGlEQUFpRCxpREFBaUQsaURBQWlELDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4QixtaURBQW1pRCxtR0FBbUcsK0JBQStCLCtCQUErQixpQ0FBaUMsbURBQW1ELDRCQUE0QixvK0NBQW8rQyxnSEFBZ0gseUZBQXlGLG1CQUFtQixpREFBaUQsS0FBSywrQ0FBK0MsMkJBQTJCLHFFQUFxRSwwQkFBMEIsb0RBQW9ELHlCQUF5Qiw0Q0FBNEMsMkNBQTJDLGtDQUFrQyx1REFBdUQsUUFBUSxpQ0FBaUMsa0NBQWtDLDZDQUE2QyxRQUFRLGlDQUFpQyxrQ0FBa0MsMkNBQTJDLHFDQUFxQyxPQUFPLGdFQUFnRSxLQUFLLG1NQUFtTSx5QkFBeUIsNkNBQTZDLG9FQUFvRSxnSEFBZ0gseUdBQXlHLHVCQUF1QixpREFBaUQsNEVBQTRFLG9MQUFvTCxvMUJBQW8xQixpR0FBaUcscUJBQXFCLGlEQUFpRCxLQUFLOztBQUVoNlMsb0hBQW9ILDBEQUEwRCxtSUFBbUksb0VBQW9FLHFDQUFxQyw4QkFBOEIseUJBQXlCLCtCQUErQiwyQkFBMkIsMkJBQTJCLFFBQVEsc0ZBQXNGLDBFQUEwRSw4QkFBOEIseUJBQXlCLCtCQUErQiwyQkFBMkIsMkJBQTJCLFFBQVEseUVBQXlFLDZHQUE2RyxnRUFBZ0UsK0JBQStCLDhCQUE4Qix5QkFBeUIsK0JBQStCLDJCQUEyQiwyQkFBMkIsK0JBQStCLDhCQUE4QixRQUFRLDRFQUE0RTs7QUFFcDVDLGlQQUFpUCw2QkFBNkIsNkhBQTZILDJCQUEyQixRQUFRLDJIQUEySCwwRkFBMEYsT0FBTyxnSUFBZ0ksNkJBQTZCLFFBQVEscUhBQXFILDhFQUE4RSxPQUFPLGdJQUFnSSwyQkFBMkIsUUFBUSwwQ0FBMEMsb0xBQW9MLG9GQUFvRixLQUFLOztBQUVuOUMsdURBQXVELHVCQUF1QixxR0FBcUcsa0RBQWtELDJCQUEyQixRQUFRLHNEQUFzRCx5T0FBeU8sS0FBSyxxR0FBcUcsa0RBQWtELDRCQUE0QixRQUFRLHdDQUF3Qyw4TEFBOEwsS0FBSyx3R0FBd0csa0RBQWtELDZCQUE2QixRQUFRLDBDQUEwQyxtUUFBbVEsS0FBSyxpRUFBaUUsR0FBRzs7QUFFdmdELDJGQUEyRixpREFBaUQsaURBQWlELGlEQUFpRDs7QUFFOU8sMkVBQTJFLG1DQUFtQyx3Q0FBd0MsNENBQTRDLGlEQUFpRCwyQkFBMkIsdUJBQXVCLHVCQUF1Qiw0REFBNEQsZ0VBQWdFLGdFQUFnRSxnRUFBZ0Usb0NBQW9DLEtBQUs7O0FBRWptQixzR0FBc0csK0JBQStCLG9EQUFvRCxvREFBb0Qsb0RBQW9ELG9EQUFvRCxzREFBc0Q7O0FBRTNZLDhFQUE4RSwwQ0FBMEMsMENBQTBDLDBDQUEwQywwQ0FBMEMsNkRBQTZELHNFQUFzRSxnR0FBZ0c7O0FBRXpkLG1EQUFtRCwwRkFBMEYsdUNBQXVDLGtDQUFrQzs7QUFFdE4seUZBQXlGOztBQUV6Riw4R0FBOEc7O0FBRTlHLHlJQUF5SSx3Q0FBd0MsbURBQW1ELEdBQUcsMENBQTBDLGlDQUFpQyx1REFBdUQsR0FBRyx3Q0FBd0MsaUNBQWlDLDhDQUE4Qyw0R0FBNEcsR0FBRywrQkFBK0IsaURBQWlELHlEQUF5RCxpQkFBaUIsR0FBRyw0Q0FBNEMsOEpBQThKLHdLQUF3Syx1Q0FBdUMsaUNBQWlDLGtDQUFrQyxrQ0FBa0MsNkJBQTZCLEdBQUcsMEtBQTBLLDhKQUE4SiwyQ0FBMkMsb0JBQW9CLHNCQUFzQiw4SUFBOEksR0FBRyxxQ0FBcUMsOFBBQThQLHdSQUF3UixzQ0FBc0Msa0NBQWtDLGlDQUFpQyxrREFBa0QsbUNBQW1DLGdDQUFnQyx3QkFBd0IsMkRBQTJELHFDQUFxQyw4Q0FBOEMsb0NBQW9DLDBEQUEwRCxrREFBa0QscUNBQXFDLGlCQUFpQixHQUFHLHlDQUF5Qyw4Q0FBOEMsb0NBQW9DLGlDQUFpQyxzREFBc0Qsc0RBQXNELG9CQUFvQix5REFBeUQsZ0RBQWdELG9DQUFvQyxpRUFBaUUsNEJBQTRCLG1FQUFtRSw0Q0FBNEMsR0FBRyx5Q0FBeUMsZUFBZTs7QUFFbm5ILDZGQUE2RixxQ0FBcUMsbUNBQW1DLHVEQUF1RCxpREFBaUQsZ0hBQWdILDhHQUE4Ryx3Q0FBd0MsK0NBQStDLDZEQUE2RCw4VEFBOFQseUdBQXlHLCtFQUErRTs7QUFFcm5DLHdGQUF3Riw0QkFBNEIsc0NBQXNDLGtDQUFrQyxzRUFBc0UsMEVBQTBFLG1EQUFtRCw2Q0FBNkMsNkJBQTZCLGtDQUFrQyxnQ0FBZ0MseUJBQXlCLHVFQUF1RSxLQUFLLHlCQUF5QixrRUFBa0UsS0FBSyx3QkFBd0IsNkVBQTZFLEtBQUsseUJBQXlCLDJDQUEyQyxLQUFLLHlCQUF5QiwrQkFBK0IsS0FBSyx5QkFBeUIsK0JBQStCLEtBQUsseUJBQXlCLHFEQUFxRCxLQUFLLHlCQUF5QixtREFBbUQsS0FBSyx1RUFBdUUsbUNBQW1DLDZCQUE2Qiw2QkFBNkIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsMEVBQTBFLDBFQUEwRSwwRUFBMEUsMEVBQTBFLGtNQUFrTSxLQUFLLGtFQUFrRSxpRUFBaUUsdUVBQXVFLHdDQUF3Qyx3Q0FBd0MseUZBQXlGLHdGQUF3RixtREFBbUQsS0FBSyxnSkFBZ0osd0VBQXdFLHNCQUFzQiw0REFBNEQsNERBQTRELDREQUE0RCxvRUFBb0UsS0FBSywrRUFBK0UsNERBQTRELEtBQUsseUdBQXlHLDRGQUE0Rix5RUFBeUUsS0FBSyx1SUFBdUksMkNBQTJDLDJCQUEyQixRQUFRLE1BQU0scUZBQXFGLG9GQUFvRiwyQkFBMkIsT0FBTyxLQUFLLHViQUF1Yiw0QkFBNEIseUJBQXlCLHlGQUF5RixvRUFBb0UseUJBQXlCLE9BQU8sUUFBUSxxR0FBcUcsNkRBQTZELGdGQUFnRix1REFBdUQsa0NBQWtDLGtDQUFrQyxvR0FBb0csMERBQTBELHFEQUFxRCw4SUFBOEksU0FBUyxrQ0FBa0Msd0dBQXdHLDJEQUEyRCw4RUFBOEUscURBQXFELGdDQUFnQyxnQ0FBZ0MscUZBQXFGLDZIQUE2SCw4RUFBOEUsOEVBQThFLGdHQUFnRyw2R0FBNkcsS0FBSzs7QUFFcG5NLCtGQUErRixnREFBZ0QsMERBQTBELDBEQUEwRCxvREFBb0Qsd0RBQXdELDREQUE0RCxnRUFBZ0Usa0VBQWtFLGtFQUFrRSxvRUFBb0Usa0VBQWtFLCtFQUErRSxxRkFBcUYsc0VBQXNFLHlGQUF5RixxRUFBcUUsNkVBQTZFLGdFQUFnRSwyRUFBMkUsbUZBQW1GLDhFQUE4RSxvQ0FBb0Msd0VBQXdFLGlDQUFpQzs7QUFFbm9ELDZGQUE2RixzREFBc0Qsd0JBQXdCLGdFQUFnRSw2QkFBNkIsZ0VBQWdFLDZCQUE2QiwwREFBMEQsMEJBQTBCLDhEQUE4RCw0QkFBNEIsa0VBQWtFLDhCQUE4Qiw4RUFBOEUsb0NBQW9DLHNFQUFzRSxnQ0FBZ0Msd0VBQXdFLGlDQUFpQyx3RUFBd0UsaUNBQWlDLDBFQUEwRSxrQ0FBa0Msd0VBQXdFLGlDQUFpQyxxRkFBcUYsdUNBQXVDLDJGQUEyRiwwQ0FBMEMsMkVBQTJFLGtDQUFrQyxtRkFBbUYsc0NBQXNDLDRFQUE0RSxtQ0FBbUMsK0ZBQStGLDRDQUE0QyxzRUFBc0UsZ0NBQWdDLGlGQUFpRixxQ0FBcUMseUZBQXlGLHlDQUF5Qyw4RUFBOEUsb0NBQW9DLHdFQUF3RSxpQ0FBaUM7O0FBRTVnRiw4RkFBOEYsNkVBQTZFLGlHQUFpRyxpR0FBaUcscUZBQXFGLDZGQUE2RixxR0FBcUcsNkhBQTZILDZHQUE2RyxpSEFBaUgsaUhBQWlILHFIQUFxSCxpSEFBaUgsMklBQTJJLHVKQUF1Six5SEFBeUgsK0pBQStKLHVIQUF1SCx1SUFBdUksNkdBQTZHLG1JQUFtSSxtSkFBbUosNkhBQTZILGlIQUFpSDs7QUFFL3RGLG1OQUFtTiw0RUFBNEUsd0ZBQXdGLDBEQUEwRDs7QUFFamIsbUNBQW1DLDJCQUEyQixlQUFlLDZDQUE2QyxnREFBZ0QsR0FBRzs7QUFFN0ssMENBQTBDLG9DQUFvQyxtQkFBbUIsZUFBZSwwQ0FBMEMsdU9BQXVPLGtEQUFrRCw0QkFBNEIsd0VBQXdFOztBQUV2aEIsK0NBQStDLGtDQUFrQyxrRUFBa0UsMEZBQTBGLEdBQUc7O0FBRWhQLDBFQUEwRSxtRUFBbUUsbUNBQW1DLHFDQUFxQyxvQ0FBb0Msa0NBQWtDLCtCQUErQix1REFBdUQsd0pBQXdKLGtKQUFrSiwwREFBMEQsa0RBQWtELDRCQUE0Qix3RUFBd0U7O0FBRTMyQiwrQ0FBK0Msa0NBQWtDLGtFQUFrRSwwRkFBMEYsR0FBRzs7QUFFaFAsOENBQThDLHNCQUFzQix3QkFBd0IsK0JBQStCLGVBQWUsZ0dBQWdHLDRCQUE0Qiw4QkFBOEIsd0VBQXdFOztBQUU1Vyx3VEFBd1QsZUFBZSwrZ0JBQStnQixHQUFHOztBQUV6MUIsdUVBQXVFLHFVQUFxVSxlQUFlLG9DQUFvQyxtR0FBbUcsdVBBQXVQLDRGQUE0RixrRkFBa0YsOEZBQThGLGtHQUFrRyxhQUFhOztBQUVwcEMsZ0VBQWdFLG1QQUFtUCw2Z0JBQTZnQixHQUFHOztBQUVuMEIscUVBQXFFLDZCQUE2Qiw0QkFBNEIsOEJBQThCLHVRQUF1USxvQ0FBb0Msa09BQWtPLG9FQUFvRSw0QkFBNEIsMkNBQTJDLEdBQUc7O0FBRXZ6QiwrQ0FBK0Msa0NBQWtDLGtFQUFrRSwyREFBMkQ7O0FBRTlNLGdEQUFnRCwrQkFBK0Isa0NBQWtDLGtEQUFrRCw0Q0FBNEMsb0RBQW9ELHdFQUF3RTs7QUFFM1Usc0NBQXNDLCtCQUErQiw4QkFBOEIsdU9BQXVPLHlDQUF5QyxpVEFBaVQ7O0FBRXBxQix5Q0FBeUMsd0JBQXdCLHlCQUF5QiwwQkFBMEIsOEJBQThCLDJPQUEyTyxpREFBaUQsOEZBQThGLGNBQWMsS0FBSyxxQ0FBcUMsZ0lBQWdJLDRLQUE0Szs7QUFFaDNCLHdWQUF3Vix3cEJBQXdwQjs7QUFFaC9CLHlDQUF5Qyx3QkFBd0IsOENBQThDLG9qQkFBb2pCLGlEQUFpRCxnWEFBZ1gscUZBQXFGLDhGQUE4Riw2REFBNkQsOEZBQThGLHdEQUF3RCwyT0FBMk87O0FBRXJyRCw4REFBOEQsaWJBQWliLDBsQkFBMGxCLHFIQUFxSDs7QUFFOXJDLDBEQUEwRCx3QkFBd0Isd0JBQXdCLDAwQkFBMDBCLGlEQUFpRCxnSkFBZ0osMENBQTBDLHFtQkFBcW1CLDJPQUEyTzs7QUFFLytELDZEQUE2RCxnWEFBZ1gsbW5CQUFtbkIsR0FBRzs7QUFFbmlDLHlEQUF5RCx3QkFBd0IsMkJBQTJCLDZCQUE2QixpZUFBaWUsaURBQWlELHlWQUF5Viw4REFBOEQsaUNBQWlDLHVFQUF1RSxzRUFBc0UsNkVBQTZFLHNFQUFzRSw2TUFBNk07O0FBRWhrRCw4SkFBOEosOFRBQThULDhuQkFBOG5CLFdBQVc7O0FBRXJtQywwREFBMEQsOEhBQThILCtQQUErUCx1REFBdUQsc05BQXNOLDRDQUE0QyxhQUFhOztBQUU3dkIsNERBQTRELGliQUFpYiwwbEJBQTBsQixxSEFBcUg7O0FBRTVyQyx3REFBd0Qsd0JBQXdCLHdCQUF3QiwwQkFBMEIsd0JBQXdCLHcwQkFBdzBCLGlEQUFpRCxnSkFBZ0osMENBQTBDLHFxQkFBcXFCLDJPQUEyTzs7QUFFN2xFLCtEQUErRCx5REFBeUQsMFpBQTBaLDBsQkFBMGxCLHNKQUFzSixXQUFXOztBQUU3d0MsMkhBQTJILHdCQUF3QiwwQkFBMEIsMEJBQTBCLHdCQUF3QixrQ0FBa0MsaUVBQWlFLCtCQUErQix5RUFBeUUsMkZBQTJGLG9FQUFvRSxxQ0FBcUMsNERBQTRELDhEQUE4RCxpQ0FBaUMsOENBQThDLDhDQUE4QyxzREFBc0QsaUNBQWlDLG1FQUFtRSxxRkFBcUYsMkVBQTJFLGtFQUFrRSwrQ0FBK0Msb2lDQUFvaUMsaURBQWlELGdKQUFnSiwwQ0FBMEMsNnNCQUE2c0IseUZBQXlGLGtIQUFrSCw0RkFBNEYsb0dBQW9HLG9IQUFvSCxtRkFBbUYsd0pBQXdKLHVOQUF1Tjs7QUFFN3FJLDJEQUEyRCxrWkFBa1osMGxCQUEwbEIseUZBQXlGOztBQUVob0MsdURBQXVELHdCQUF3Qix3QkFBd0IsOHZCQUE4dkIsaURBQWlELGdKQUFnSiwwQ0FBMEMsK2pCQUErakIsNk1BQTZNOztBQUU1MUQscUNBQXFDLHNCQUFzQix3T0FBd08sNkJBQTZCLHVCQUF1Qix1RUFBdUUseU5BQXlOLGlHQUFpRyxzRUFBc0UsMElBQTBJOztBQUV4NkIseUNBQXlDLHdCQUF3QiwrUkFBK1IsaURBQWlELDRFQUE0RSwyTUFBMk0sNEtBQTRLOztBQUVwMUIsMFBBQTBQLHFkQUFxZDs7QUFFL3NCLHVDQUF1Qyx3QkFBd0IsbVBBQW1QLHlHQUF5RyxtR0FBbUc7O0FBRTlmLHlDQUF5QyxzQkFBc0IscUtBQXFLLG1FQUFtRSx3RkFBd0Ysa0dBQWtHLG1EQUFtRCx3RkFBd0YseUJBQXlCLGtHQUFrRyxrR0FBa0cscUNBQXFDLGdEQUFnRCxrR0FBa0c7O0FBRWhnQyx5Q0FBeUMsd0JBQXdCLHNUQUFzVCxpREFBaUQsNEVBQTRFLHFNQUFxTSxpSUFBaUk7O0FBRTF6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsYUFBYSx5QkFBeUIsaURBQUssY0FBYztBQUN6RCxhQUFhLFlBQVk7O0FBRXpCLFNBQVMsYUFBYTtBQUN0QixrQkFBa0IseUJBQXlCLG1EQUFPLElBQUk7O0FBRXRELGNBQWMsYUFBYTtBQUMzQix1QkFBdUIseUJBQXlCLG1EQUFPLElBQUk7O0FBRTNELGVBQWU7O0FBRWYsRUFBRTs7QUFFRjs7QUFFQSxpQkFBaUIsYUFBYTtBQUM5QiwwQkFBMEIseUJBQXlCLG1EQUFPOztBQUUxRCxFQUFFOztBQUVGOztBQUVBLFlBQVksYUFBYTtBQUN6QixvQkFBb0IseUJBQXlCLG1EQUFPLElBQUk7QUFDeEQsZ0JBQWdCLFlBQVk7QUFDNUIsa0JBQWtCLFlBQVk7QUFDOUIsU0FBUyxZQUFZO0FBQ3JCLHFCQUFxQixhQUFhOztBQUVsQyxFQUFFOztBQUVGOztBQUVBLFdBQVcsYUFBYTtBQUN4QixvQkFBb0IsVUFBVTtBQUM5QixvQkFBb0IseUJBQXlCLG1EQUFPOztBQUVwRCxFQUFFOztBQUVGOztBQUVBLGNBQWMsYUFBYTtBQUMzQix1QkFBdUIsVUFBVTtBQUNqQyx1QkFBdUIseUJBQXlCLG1EQUFPOztBQUV2RCxFQUFFOztBQUVGOztBQUVBLGFBQWEsYUFBYTtBQUMxQixzQkFBc0IseUJBQXlCLG1EQUFPLElBQUk7QUFDMUQsZUFBZTs7QUFFZixFQUFFOztBQUVGOztBQUVBLGVBQWUsYUFBYTtBQUM1Qix3QkFBd0IseUJBQXlCLG1EQUFPLElBQUk7QUFDNUQsaUJBQWlCLHlCQUF5QixtREFBTzs7QUFFakQsRUFBRTs7QUFFRjs7QUFFQSxxQkFBcUIsYUFBYTtBQUNsQyw4QkFBOEIseUJBQXlCLG1EQUFPLElBQUk7QUFDbEUsdUJBQXVCLFVBQVU7QUFDakMsc0JBQXNCOztBQUV0QixFQUFFOztBQUVGOztBQUVBLGlCQUFpQixhQUFhO0FBQzlCLDBCQUEwQix5QkFBeUIsbURBQU87O0FBRTFELEVBQUU7O0FBRUY7O0FBRUEsa0JBQWtCLGFBQWE7QUFDL0IsMkJBQTJCLHlCQUF5QixtREFBTzs7QUFFM0QsRUFBRTs7QUFFRjs7QUFFQSxrQkFBa0IsYUFBYTtBQUMvQiwyQkFBMkIseUJBQXlCLG1EQUFPOztBQUUzRCxFQUFFOztBQUVGOztBQUVBLGlCQUFpQjs7QUFFakIsRUFBRTs7QUFFRjs7QUFFQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGFBQWEsVUFBVTtBQUN2QixZQUFZLGFBQWE7QUFDekIsY0FBYyx5QkFBeUIsaURBQUs7O0FBRTVDLEVBQUU7O0FBRUY7O0FBRUEsdUJBQXVCLFdBQVc7O0FBRWxDLGdCQUFnQixXQUFXOztBQUUzQix1QkFBdUI7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0EsS0FBSzs7QUFFTCw2QkFBNkI7QUFDN0I7QUFDQSxpQkFBaUI7QUFDakIsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQjtBQUNBLEtBQUs7O0FBRUwsMEJBQTBCLFdBQVc7QUFDckMsNkJBQTZCLFdBQVc7O0FBRXhDLGdCQUFnQjtBQUNoQixZQUFZO0FBQ1osZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YsY0FBYztBQUNkLGtCQUFrQjtBQUNsQjtBQUNBLEtBQUs7O0FBRUwsc0JBQXNCO0FBQ3RCO0FBQ0EsaUJBQWlCO0FBQ2pCLHVCQUF1QjtBQUN2QixtQkFBbUI7QUFDbkI7QUFDQSxLQUFLOztBQUVMLGtCQUFrQixXQUFXO0FBQzdCLG1CQUFtQixXQUFXO0FBQzlCLHFCQUFxQixXQUFXOztBQUVoQyxpQkFBaUI7QUFDakIsWUFBWTtBQUNaLGVBQWU7QUFDZixZQUFZO0FBQ1o7QUFDQSxLQUFLOztBQUVMLHVCQUF1QjtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkI7QUFDQSxLQUFLOztBQUVMLG9CQUFvQixXQUFXO0FBQy9CLHVCQUF1QixXQUFXOztBQUVsQyxzQkFBc0I7QUFDdEIsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZjtBQUNBLEtBQUs7O0FBRUw7QUFDQSxvQkFBb0I7QUFDcEIsWUFBWTtBQUNaLGVBQWU7QUFDZixZQUFZO0FBQ1o7QUFDQSxLQUFLOztBQUVMLFdBQVcsYUFBYTtBQUN4QixXQUFXOztBQUVYLEVBQUU7O0FBRUY7O0FBRUEsYUFBYSx5QkFBeUIsaURBQUssY0FBYztBQUN6RCxhQUFhLFlBQVk7QUFDekIsVUFBVSxZQUFZO0FBQ3RCLFdBQVcsWUFBWTtBQUN2QixTQUFTLGFBQWE7QUFDdEIsY0FBYyxhQUFhO0FBQzNCLHVCQUF1Qix5QkFBeUIsbURBQU8sSUFBSTtBQUMzRCxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLHlCQUF5QixtREFBTzs7QUFFakQsRUFBRTs7QUFFRjs7QUFFQSxhQUFhLHlCQUF5QixpREFBSyxjQUFjO0FBQ3pELGFBQWEsWUFBWTtBQUN6QixZQUFZLHlCQUF5QixtREFBTyxjQUFjO0FBQzFELGNBQWMsWUFBWTtBQUMxQixTQUFTLGFBQWE7QUFDdEIsa0JBQWtCLHlCQUF5QixtREFBTyxJQUFJO0FBQ3RELGNBQWMsYUFBYTtBQUMzQix1QkFBdUIseUJBQXlCLG1EQUFPLElBQUk7QUFDM0QsZUFBZTs7QUFFZjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwQkFBMEIsNkRBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBLDBCQUEwQiw2REFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCLGlEQUFLO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBLDBCQUEwQiw2REFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCLGlEQUFLLGNBQWM7QUFDNUQsZ0JBQWdCLHlCQUF5QixpREFBSyxjQUFjO0FBQzVELGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQSwwQkFBMEIsNkRBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCLGlEQUFLLGNBQWM7QUFDNUQsaUJBQWlCLFlBQVk7QUFDN0IsaUJBQWlCLFlBQVk7QUFDN0IsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBLDBCQUEwQiw2REFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QixpREFBSztBQUM5QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQSwwQkFBMEIsNkRBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBLDBCQUEwQiw2REFBYTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBLDBCQUEwQiw2REFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsZ0JBQWdCLFVBQVU7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBLDBCQUEwQiw2REFBYTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBLDBCQUEwQiw2REFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBLDBCQUEwQiw2REFBYTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0Esa0JBQWtCLHlCQUF5QixtREFBTyxJQUFJO0FBQ3RELFVBQVUsYUFBYTtBQUN2QiwwQkFBMEI7QUFDMUIsR0FBRzs7QUFFSDtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQSxhQUFhLGFBQWE7QUFDMUIsaUJBQWlCLFlBQVk7QUFDN0IsMkJBQTJCLFVBQVU7QUFDckMsMEJBQTBCLFVBQVU7QUFDcEMseUJBQXlCLHlCQUF5QixtREFBTztBQUN6RCxHQUFHOztBQUVIO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLFlBQVk7QUFDeEIsY0FBYztBQUNkLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0IsR0FBRzs7QUFFSDtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUEsMEJBQTBCLDZEQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5QkFBeUIsbURBQU8sSUFBSTtBQUM3RCxvQkFBb0IsVUFBVTtBQUM5QixtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUEsMEJBQTBCLDZEQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCLGlEQUFLLGFBQWE7QUFDeEQsZUFBZTtBQUNmLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlCQUF5Qiw2REFBYTtBQUN0QztBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUIsbUJBQW1CLGFBQWE7QUFDaEMsNEJBQTRCLHlCQUF5QixtREFBTyxJQUFJO0FBQ2hFLHlCQUF5QixhQUFhO0FBQ3RDLGtDQUFrQyx5QkFBeUIsbURBQU8sSUFBSTtBQUN0RSwyQkFBMkIseUJBQXlCLG1EQUFPLFVBQVU7QUFDckUseUJBQXlCLFVBQVU7QUFDbkMsNEJBQTRCLGFBQWE7QUFDekMscUNBQXFDLHlCQUF5QixtREFBTyxJQUFJO0FBQ3pFLGlCQUFpQixVQUFVO0FBQzNCLGtCQUFrQixVQUFVO0FBQzVCLHFCQUFxQixhQUFhO0FBQ2xDLDhCQUE4Qix5QkFBeUIsbURBQU8sSUFBSTtBQUNsRSxxQkFBcUIsWUFBWTtBQUNqQyxrQ0FBa0MsWUFBWTtBQUM5QyxrQ0FBa0MsWUFBWTtBQUM5Qyw4QkFBOEIsYUFBYTtBQUMzQyx1Q0FBdUMseUJBQXlCLG1EQUFPLElBQUk7QUFDM0UsWUFBWSxVQUFVO0FBQ3RCLGlCQUFpQix5QkFBeUIsaURBQUssY0FBYztBQUM3RCxvQkFBb0IsYUFBYTtBQUNqQyw2QkFBNkIseUJBQXlCLG1EQUFPLElBQUk7QUFDakUscUJBQXFCLFVBQVU7QUFDL0Isd0JBQXdCLGFBQWE7QUFDckMsaUNBQWlDLHlCQUF5QixtREFBTyxJQUFJO0FBQ3JFLG1CQUFtQixVQUFVO0FBQzdCLHNCQUFzQixhQUFhO0FBQ25DLCtCQUErQix5QkFBeUIsbURBQU8sSUFBSTtBQUNuRSw4QkFBOEIseUJBQXlCLG1EQUFPLElBQUk7QUFDbEUsNkJBQTZCLGFBQWE7QUFDMUMsZ0JBQWdCLFVBQVU7QUFDMUIsbUJBQW1CLGFBQWE7QUFDaEMsNEJBQTRCLHlCQUF5QixtREFBTyxJQUFJO0FBQ2hFLDBCQUEwQixVQUFVO0FBQ3BDLHVCQUF1Qix5QkFBeUIsaURBQUssY0FBYztBQUNuRSxvQkFBb0IseUJBQXlCLGlEQUFLLGFBQWE7QUFDL0QsdUJBQXVCLGFBQWE7QUFDcEMsZ0NBQWdDLHlCQUF5QixtREFBTyxJQUFJO0FBQ3BFLHdCQUF3QixVQUFVO0FBQ2xDLDJCQUEyQixhQUFhO0FBQ3hDLG9DQUFvQyx5QkFBeUIsbURBQU8sSUFBSTtBQUN4RSx1QkFBdUIseUJBQXlCLG1EQUFPLElBQUk7QUFDM0Qsb0JBQW9CLGFBQWE7QUFDakMsNkJBQTZCLHlCQUF5QixtREFBTyxJQUFJO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxlQUFlO0FBQ2YsZ0NBQWdDLGlEQUFLO0FBQ3JDLGdDQUFnQyxtREFBTzs7QUFFdkM7O0FBRUEsd0JBQXdCLGlEQUFLO0FBQzdCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9EQUFvRDtBQUNwRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwRUFBMEUsbUVBQXVCOztBQUVqRzs7QUFFQSxrQkFBa0IsZ0RBQUk7QUFDdEIsU0FBUyx1REFBVztBQUNwQixTQUFTLDBEQUFjO0FBQ3ZCO0FBQ0EsZ0JBQWdCLDZEQUFhO0FBQzdCO0FBQ0E7QUFDQSxZQUFZLG9EQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQixnQkFBZ0I7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJEQUFlLDBDQUEwQyx3REFBWTs7QUFFdEc7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsb0JBQW9CLGdEQUFJO0FBQ3hCLFNBQVMseURBQWE7QUFDdEIsU0FBUywwREFBYztBQUN2QjtBQUNBLGdCQUFnQiw2REFBYTtBQUM3QjtBQUNBO0FBQ0EsWUFBWSxxREFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsMkRBQWUsMENBQTBDLHdEQUFZOztBQUV4Rzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0JBQXNCLHlFQUF5Qjs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix5QkFBeUI7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsOENBQThDLFFBQVE7O0FBRXREOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrREFBa0QsUUFBUTs7QUFFMUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0dBQW9HLG1EQUFPOztBQUUzRzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLG1DQUFtQzs7QUFFM0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUix3QkFBd0IsbUNBQW1DOztBQUUzRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUIsbUNBQW1DOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQSx3QkFBd0IsbUNBQW1DOztBQUUzRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxRQUFROztBQUVSLHdCQUF3QixtQ0FBbUM7O0FBRTNEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1QixtQ0FBbUM7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZUFBZTs7QUFFbEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLG1CQUFtQjs7QUFFdkM7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBLG9CQUFvQixlQUFlOztBQUVuQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUJBQXlCLHNEQUFVOztBQUVuQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvREFBb0QseURBQWE7O0FBRWpFLHVCQUF1Qiw0REFBZ0I7QUFDdkMsbUJBQW1CLHFEQUFTOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsaURBQUs7QUFDeEIseUJBQXlCLG1EQUFPOztBQUVoQyxjQUFjOztBQUVkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSw2QkFBNkI7O0FBRTdCOztBQUVBLG9CQUFvQixlQUFlOztBQUVuQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDLGVBQWU7O0FBRXBEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQiw0RUFBZ0M7O0FBRW5ELHFCQUFxQixpRUFBcUI7O0FBRTFDLElBQUksc0JBQXNCLDRFQUFnQzs7QUFFMUQscUJBQXFCLGlFQUFxQjs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLDRFQUFnQyxnQkFBZ0IsNEVBQWdDOztBQUVwRzs7QUFFQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsK0JBQStCLGlFQUFxQjtBQUNwRDtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsOERBQWtCO0FBQ3hELHNDQUFzQyxpREFBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1EQUFPO0FBQzFCLG1CQUFtQixtREFBTztBQUMxQixtQkFBbUIsbURBQU87QUFDMUIsbUJBQW1CLG1EQUFPO0FBQzFCLG1CQUFtQixtREFBTztBQUMxQixtQkFBbUIsbURBQU87QUFDMUIsbUJBQW1CLG1EQUFPO0FBQzFCLG1CQUFtQixtREFBTztBQUMxQixtQkFBbUIsbURBQU87QUFDMUIsbUJBQW1CLG1EQUFPOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLG1CQUFtQjtBQUMvQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSxNQUFNO0FBQ2xCLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsNEJBQTRCOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMkJBQTJCLGlFQUFxQix3QkFBd0IsaUVBQXFCOztBQUU3Rjs7QUFFQSxJQUFJLE9BQU87O0FBRVg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsd0RBQVk7QUFDMUIsY0FBYyx3REFBWTtBQUMxQjtBQUNBLFNBQVMseURBQWE7QUFDdEIsV0FBVyxzREFBVTtBQUNyQixlQUFlLGdFQUFvQjtBQUNuQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFdBQVcsVUFBVTtBQUNyQixPQUFPLDZFQUE2RTs7QUFFcEY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0JBQXNCLGdEQUFJO0FBQzFCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsNkRBQWlCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLHlEQUFhO0FBQ3RDOztBQUVBLGlDQUFpQyw2REFBaUI7QUFDbEQ7QUFDQSxTQUFTLG9EQUFRO0FBQ2pCO0FBQ0E7QUFDQSxJQUFJOztBQUVKLDRCQUE0QixnREFBSSxNQUFNLHVEQUFXOztBQUVqRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEMsaUVBQXFCLHdCQUF3QixpRUFBcUI7O0FBRWhIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsZ0RBQUk7O0FBRXZCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0IsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixnREFBSTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhLHFDQUFxQyxZQUFZOztBQUU5RDs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixvQkFBb0I7O0FBRXZDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFVBQVUsVUFBVTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLGVBQWU7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixrQkFBa0I7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLDBEQUFjO0FBQ25DLHVDQUF1QywyREFBZTtBQUN0RCxpQ0FBaUMsMkRBQWU7QUFDaEQsd0NBQXdDLDJEQUFlO0FBQ3ZEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFVBQVU7O0FBRVY7O0FBRUE7O0FBRUEsZ0NBQWdDLDZEQUFpQjtBQUNqRCxzQ0FBc0MsbUVBQXVCO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLG1EQUFPO0FBQzdCLDRCQUE0QiwwREFBYzs7QUFFMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQixHQUFHOztBQUVIO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixnQkFBZ0I7QUFDaEMsb0JBQW9CLGNBQWM7QUFDbEMsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUI7QUFDakIsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixPQUFPOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxZQUFZLHNEQUFVO0FBQ3RCO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxZQUFZLDBEQUFjOztBQUUxQjs7QUFFQTtBQUNBLGVBQWU7QUFDZixHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFlBQVksc0RBQVU7QUFDdEI7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLFlBQVksMERBQWM7O0FBRTFCOztBQUVBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLG1CQUFtQjtBQUNuQixHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxZQUFZLHNEQUFVO0FBQ3RCO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDJCQUEyQjtBQUMzQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwrQkFBK0I7O0FBRS9CLEtBQUs7O0FBRUw7QUFDQSwwQkFBMEI7O0FBRTFCLEtBQUs7O0FBRUwseUJBQXlCOztBQUV6QixLQUFLOztBQUVMO0FBQ0EsMEJBQTBCOztBQUUxQixLQUFLOztBQUVMO0FBQ0EsMEJBQTBCOztBQUUxQixLQUFLOztBQUVMLHlCQUF5Qjs7QUFFekI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyw0RUFBZ0MsZ0JBQWdCLDRFQUFnQztBQUN2SCxtQ0FBbUMsaUVBQXFCLGdCQUFnQixpRUFBcUI7O0FBRTdGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixZQUFZOztBQUUvQjs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSSx3REFBUTs7QUFFWjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsa0RBQWtELE9BQU87O0FBRXpEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLDBCQUEwQixnRUFBZ0IsY0FBYyxpRUFBcUIsR0FBRyxpRUFBcUI7QUFDckc7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixlQUFlOztBQUVsQzs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLG1CQUFtQjs7QUFFdkM7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBLG9CQUFvQixlQUFlOztBQUVuQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQixtREFBTzs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLDREQUFnQjtBQUN2QyxrQkFBa0IscURBQVM7QUFDM0I7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHVCQUF1Qjs7QUFFM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQix1QkFBdUI7O0FBRTVDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbURBQU87QUFDckI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLG9CQUFvQiw2QkFBNkI7O0FBRWpEOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsdUNBQXVDLG1EQUFPOztBQUU5Qyw2Q0FBNkMsd0RBQVk7O0FBRXpELDRDQUE0Qyw0REFBZ0I7QUFDNUQseUNBQXlDLHlEQUFhO0FBQ3RELDJDQUEyQyx1REFBVzs7QUFFdEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwrQkFBK0IsZUFBZTs7QUFFOUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnQ0FBZ0MsT0FBTzs7QUFFdkM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZ0NBQWdDLE9BQU87O0FBRXZDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLFNBQVM7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsNERBQWdCLEVBQUU7QUFDekQ7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7O0FBRW5DLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsa0NBQWtDOztBQUVsQyxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRCxnREFBZ0Q7O0FBRWhELG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixTQUFTOztBQUUzQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IsU0FBUzs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLFNBQVM7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixTQUFTOztBQUUzQjs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsd0NBQXdDOztBQUV4Qyx1Q0FBdUM7QUFDdkMsdUNBQXVDO0FBQ3ZDLHVDQUF1Qzs7QUFFdkMscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQscURBQXFEOztBQUVyRCx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6Qyx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DLFNBQVM7O0FBRTVDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxTQUFTOztBQUU1QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DLFNBQVM7O0FBRTVDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsUUFBUTs7QUFFN0I7QUFDQSxrQkFBa0IsZ0NBQWdDLEVBQUUsS0FBSyxJQUFJLFdBQVc7O0FBRXhFOztBQUVBOztBQUVBOztBQUVBLDhCQUE4QixtREFBTzs7QUFFckM7O0FBRUEsQ0FBQywyREFBZSxrQkFBa0IsMkRBQWU7O0FBRWpELGtDQUFrQyw4Q0FBOEM7O0FBRWhGLFVBQVUsMkRBQWU7O0FBRXpCLE9BQU8sMERBQWM7QUFDckI7O0FBRUEsT0FBTyx3REFBWTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFVBQVUsYUFBYSxnQkFBZ0I7O0FBRXZDLGFBQWEsZ0JBQWdCLHNCQUFzQixnQkFBZ0IsY0FBYzs7QUFFakYsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPLDZEQUFpQjtBQUN4QjtBQUNBOztBQUVBLE9BQU8sK0RBQW1CO0FBQzFCO0FBQ0E7O0FBRUEsT0FBTyw2REFBaUI7QUFDeEI7QUFDQTs7QUFFQSxPQUFPLGlFQUFxQjtBQUM1QjtBQUNBOztBQUVBLE9BQU8sMERBQWM7QUFDckI7QUFDQTs7QUFFQSxPQUFPLDhEQUFrQjtBQUN6QjtBQUNBOztBQUVBLE9BQU8sNkRBQWlCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1EQUFtRCxxREFBcUQ7O0FBRXhHOztBQUVBLDhCQUE4QixtREFBTzs7QUFFckM7O0FBRUEsQ0FBQywyREFBZTs7QUFFaEI7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlDQUF5Qzs7QUFFekMsa0NBQWtDLEdBQUcsS0FBSyxHQUFHLEtBQUssSUFBSSxFQUFFOztBQUV4RCwrQkFBK0I7O0FBRS9CLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLE9BQU87O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5RkFBeUYsb0JBQW9CLG9CQUFvQixXQUFXOztBQUU1STs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQ0FBa0MscUJBQXFCOztBQUV2RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0NBQW9DLHNCQUFzQjtBQUMxRCxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DLHdEQUFZOztBQUUvQzs7QUFFQSxHQUFHLHVDQUF1Qyw0REFBZ0I7O0FBRTFEOztBQUVBLEdBQUcsdUNBQXVDLHdEQUFZOztBQUV0RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxRQUFRLGlFQUFxQjtBQUM3QixRQUFRLGlFQUFxQjtBQUM3QjtBQUNBOztBQUVBLFFBQVEsbUVBQXVCO0FBQy9CO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUSxpRUFBcUI7O0FBRTdCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUSw2REFBaUI7QUFDekI7QUFDQTs7QUFFQSxRQUFRLHdEQUFZO0FBQ3BCO0FBQ0E7O0FBRUEsUUFBUSx3REFBWTtBQUNwQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFVBQVU7O0FBRVY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0IsaUNBQWlDO0FBQ2pDLGtDQUFrQztBQUNsQyw0QkFBNEI7QUFDNUIsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQyxnQ0FBZ0M7O0FBRWhDOztBQUVBLG1DQUFtQzs7QUFFbkM7O0FBRUE7O0FBRUEsa0NBQWtDOztBQUVsQzs7QUFFQTs7QUFFQSxvQ0FBb0M7O0FBRXBDOztBQUVBLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUIsc0JBQXNCOztBQUV0Qjs7QUFFQSx3QkFBd0I7O0FBRXhCOztBQUVBOztBQUVBLHdCQUF3Qjs7QUFFeEI7O0FBRUE7O0FBRUEsd0JBQXdCOztBQUV4Qjs7QUFFQTs7QUFFQSw0QkFBNEI7O0FBRTVCOztBQUVBOztBQUVBLDBCQUEwQjs7QUFFMUI7O0FBRUEsMEJBQTBCOztBQUUxQjs7QUFFQTs7QUFFQSw4QkFBOEI7QUFDOUIsK0JBQStCOztBQUUvQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIsZ0NBQWdDO0FBQ2hDLGdDQUFnQzs7QUFFaEMsZ0NBQWdDLHlEQUFhO0FBQzdDLGdDQUFnQyx5REFBYTtBQUM3QyxnQ0FBZ0MseURBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxpREFBSyw0REFBNEQ7QUFDakcsZ0NBQWdDLGlEQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNEJBQTRCLGtEQUFNO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZSxPQUFPOztBQUV0Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBbUUsbUVBQXVCOztBQUUxRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHlEQUFhOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0tBQStLLGdFQUFvQjtBQUNuTTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFFQUFxRSxnRUFBb0I7QUFDekYsc0VBQXNFLGlFQUFxQjs7QUFFM0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtRUFBbUUsMERBQWM7O0FBRWpGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGdGQUFnRiwyREFBZSw0Q0FBNEMsd0RBQVk7QUFDdkosd0dBQXdHLDJEQUFlLG9EQUFvRCx3REFBWTs7QUFFdkw7O0FBRUEsa0NBQWtDLHNEQUFVO0FBQzVDLGdDQUFnQyxvREFBUTs7QUFFeEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxjQUFjLHlEQUFhOztBQUUzQixJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EseUNBQXlDLFFBQVE7O0FBRWpEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJEQUEyRCxRQUFROztBQUVuRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFPO0FBQzVCLGlCQUFpQixpREFBSztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQU87QUFDM0IscUJBQXFCLG1EQUFPO0FBQzVCLGlCQUFpQixpREFBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixtREFBTztBQUMzQixpQkFBaUIsaURBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixtREFBTztBQUM1QixvQkFBb0IsaURBQUs7QUFDekIsdUJBQXVCLGlEQUFLO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixpREFBSztBQUN0QixvQkFBb0IsbURBQU87QUFDM0IscUJBQXFCLG1EQUFPO0FBQzVCLHNCQUFzQixtREFBTztBQUM3QjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtREFBTztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtREFBTztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtREFBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixPQUFPLDZCQUE2QixtREFBTzs7QUFFN0QscUJBQXFCLG1EQUFPO0FBQzVCLHFCQUFxQixtREFBTztBQUM1QixzQkFBc0IsbURBQU87O0FBRTdCOztBQUVBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMLHFCQUFxQixPQUFPOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNkJBQTZCLHdDQUF3QyxHQUFHOztBQUV4RSxnREFBZ0QsMEJBQTBCLHVCQUF1QixtQ0FBbUMsK0NBQStDLHFCQUFxQiw2QkFBNkIsb0VBQW9FLGlEQUFpRCx5QkFBeUIsYUFBYSxRQUFRLDhDQUE4Qyx5S0FBeUssK0JBQStCLDBGQUEwRixrSkFBa0osc0JBQXNCLHNDQUFzQyxpQkFBaUIsMEJBQTBCLDBDQUEwQyx1REFBdUQsNERBQTRELEdBQUc7O0FBRWpuQzs7QUFFQSxvQkFBb0IsbURBQU87O0FBRTNCLDRCQUE0QixtREFBTztBQUNuQyxzQkFBc0IsbURBQU87O0FBRTdCLGtCQUFrQixtREFBTzs7QUFFekIsdUJBQXVCLDZEQUFpQixJQUFJLGNBQWMsNERBQWdCLEdBQUc7QUFDN0UsMEJBQTBCLGdFQUFvQjs7QUFFOUMscUJBQXFCOztBQUVyQjs7QUFFQSxzQkFBc0IsRUFBRSxxREFBUyxJQUFJLG9EQUFRLElBQUksb0RBQVEsSUFBSSxxREFBUyxJQUFJLHNEQUFVLElBQUksc0RBQVU7O0FBRWxHLG9DQUFvQywwREFBYztBQUNsRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0IsaUJBQWlCLFdBQVcsbURBQU8sSUFBSTtBQUN2QyxhQUFhO0FBQ2IsR0FBRzs7QUFFSDtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSwyQkFBMkIsMERBQWM7QUFDekM7QUFDQTtBQUNBLE1BQU0sMkRBQWU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGdEQUFJOztBQUVoQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsd0RBQVk7QUFDekI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0Isc0RBQVU7QUFDaEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQyx3REFBWSxrQkFBa0Isd0RBQVk7QUFDOUUsc0NBQXNDLHdEQUFZLGtCQUFrQix3REFBWTs7QUFFaEY7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlDQUFpQyx3REFBWSxPQUFPLFdBQVcseURBQWEsYUFBYSx5REFBYSxHQUFHOztBQUV6Rzs7QUFFQTs7QUFFQTs7QUFFQSxxQkFBcUIsNkRBQWlCO0FBQ3RDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLG9CQUFvQjs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDREQUE0RCx3REFBWTs7QUFFeEU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHdCQUF3Qiw2REFBaUI7O0FBRXpDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLHdEQUFZOztBQUU1Qjs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrRUFBa0Usd0RBQVk7O0FBRTlFOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLFFBQVE7O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsR0FBRyxzREFBVSxJQUFJLHVEQUFXO0FBQzVCLEdBQUcscURBQVMsSUFBSSx3REFBWTtBQUM1QixHQUFHLHNEQUFVLElBQUkseURBQWE7QUFDOUIsR0FBRywwREFBYyxJQUFJLDZEQUFpQjs7QUFFdEMsR0FBRyx1REFBVyxJQUFJLHNEQUFVO0FBQzVCLEdBQUcsd0RBQVksSUFBSSxxREFBUztBQUM1QixHQUFHLHlEQUFhLElBQUksc0RBQVU7QUFDOUIsR0FBRyw2REFBaUIsSUFBSSwwREFBYztBQUN0Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsbURBQU87QUFDM0I7QUFDQSxnQ0FBZ0MsbURBQU87O0FBRXZDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLGFBQWEsUUFBUTs7QUFFckI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0EsMkNBQTJDOztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxXQUFXLHNEQUFVOztBQUVyQjtBQUNBOztBQUVBLFdBQVcsdURBQVc7O0FBRXRCO0FBQ0E7O0FBRUEsV0FBVyxxREFBUzs7QUFFcEI7QUFDQTs7QUFFQSxXQUFXLDBEQUFjOztBQUV6QjtBQUNBOztBQUVBLFdBQVcsc0RBQVU7O0FBRXJCO0FBQ0E7O0FBRUEsV0FBVyw2REFBaUI7O0FBRTVCO0FBQ0E7O0FBRUEsV0FBVyx3REFBWTs7QUFFdkI7QUFDQTs7QUFFQSxXQUFXLHlEQUFhOztBQUV4QjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpREFBSztBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixtREFBTztBQUNuQyw2QkFBNkIsbURBQU87O0FBRXBDOztBQUVBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFdBQVc7O0FBRTlCOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsMERBQWM7O0FBRXBDO0FBQ0EsY0FBYyx3REFBWTtBQUMxQjs7QUFFQSxjQUFjLHNEQUFVOztBQUV4Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLElBQUksdURBQVc7QUFDZixJQUFJLDREQUFnQjtBQUNwQixJQUFJLG1FQUF1QjtBQUMzQjs7QUFFQSxlQUFlLHVEQUFXO0FBQzFCLGVBQWUsdURBQVc7O0FBRTFCO0FBQ0EsSUFBSSxzREFBVTtBQUNkLElBQUkscURBQVM7QUFDYixJQUFJLDBEQUFjO0FBQ2xCLElBQUksMERBQWM7QUFDbEIsSUFBSSxrRUFBc0I7QUFDMUIsSUFBSSwwREFBYztBQUNsQixJQUFJLDBEQUFjO0FBQ2xCLElBQUksa0VBQXNCO0FBQzFCLElBQUksa0VBQXNCO0FBQzFCLElBQUksa0VBQXNCO0FBQzFCLElBQUksa0VBQXNCO0FBQzFCLElBQUksK0RBQW1CO0FBQ3ZCLElBQUksdUVBQTJCO0FBQy9CLElBQUksK0RBQW1CO0FBQ3ZCLElBQUksdUVBQTJCO0FBQy9COztBQUVBOztBQUVBLG9CQUFvQixzREFBVTs7QUFFOUI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQiwwREFBYzs7QUFFbEM7O0FBRUEsa0NBQWtDLHVEQUFXLGtDQUFrQyx1REFBVzs7QUFFMUY7O0FBRUEsNEJBQTRCLHVEQUFXO0FBQ3ZDLGlDQUFpQyx1REFBVzs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVywwREFBYztBQUN6QjtBQUNBOztBQUVBLFdBQVcsNERBQWdCO0FBQzNCO0FBQ0E7O0FBRUEsV0FBVywrREFBbUI7QUFDOUI7QUFDQTs7QUFFQSxXQUFXLDREQUFnQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLFdBQVcsMERBQWM7QUFDekI7QUFDQTs7QUFFQSxXQUFXLDREQUFnQjtBQUMzQjtBQUNBOztBQUVBLFdBQVcsK0RBQW1CO0FBQzlCO0FBQ0E7O0FBRUEsV0FBVyw0REFBZ0I7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixzREFBVTtBQUM5QjtBQUNBOztBQUVBLHNDQUFzQyxvREFBUTtBQUM5Qzs7QUFFQTs7QUFFQSwwQkFBMEIsMERBQWM7QUFDeEMsa0JBQWtCLHNEQUFVO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHdEQUFZOztBQUVoQzs7QUFFQTs7QUFFQSxzQkFBc0Isd0RBQVk7O0FBRWxDOztBQUVBLE1BQU0sdUJBQXVCLHlEQUFhOztBQUUxQzs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQjtBQUNwQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpREFBSztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEIsbURBQU87QUFDckM7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLCtEQUFlOztBQUV6RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBDQUEwQywwREFBYyxHQUFHLDJEQUFlOztBQUUxRTtBQUNBO0FBQ0EsdUVBQXVFLHdEQUFZO0FBQ25GO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNENBQTRDLDJEQUFlLGtCQUFrQiw4REFBa0I7O0FBRS9GOztBQUVBLEtBQUssd0JBQXdCLHFEQUFTOztBQUV0Qzs7QUFFQSxLQUFLLHdCQUF3Qiw2REFBaUI7O0FBRTlDO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSiw0Q0FBNEMsMkRBQWUsa0JBQWtCLDhEQUFrQjs7QUFFL0Y7O0FBRUEsS0FBSyx3QkFBd0IscURBQVM7O0FBRXRDOztBQUVBLEtBQUssd0JBQXdCLDZEQUFpQjs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0hBQWtILHlEQUFhLDBCQUEwQix3REFBWTs7QUFFcks7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixPQUFPOztBQUUzQjs7QUFFQSwwQkFBMEIsK0RBQStEOztBQUV6RixNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEseUJBQXlCLDBEQUEwRDs7QUFFbkYsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQiw0REFBNEQ7O0FBRWpGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsSUFBSSwwREFBYztBQUNsQixJQUFJLCtEQUFtQjtBQUN2QixJQUFJLGtFQUFzQjtBQUMxQjs7QUFFQTtBQUNBLElBQUkseURBQWE7QUFDakIsSUFBSSxzRUFBMEI7QUFDOUIsSUFBSSxxRUFBeUI7O0FBRTdCLElBQUksd0RBQVk7QUFDaEIsSUFBSSxxRUFBeUI7QUFDN0IsSUFBSSxvRUFBd0I7QUFDNUI7O0FBRUE7QUFDQSxJQUFJLHdEQUFZO0FBQ2hCLElBQUkseURBQWE7QUFDakIsSUFBSSx1REFBVztBQUNmLElBQUksNERBQWdCO0FBQ3BCLElBQUksd0RBQVk7QUFDaEIsSUFBSSwrREFBbUI7QUFDdkIsSUFBSSwwREFBYztBQUNsQixJQUFJLDJEQUFlO0FBQ25COztBQUVBOztBQUVBLHdCQUF3QixxREFBUztBQUNqQywyQkFBMkIsd0RBQVksMEJBQTBCLHFFQUF5QiwwQkFBMEIscUVBQXlCLDBCQUEwQixvRUFBd0I7QUFDL0wseUJBQXlCLHdEQUFZLDBCQUEwQixxRUFBeUIsMEJBQTBCLHFFQUF5QiwwQkFBMEIsb0VBQXdCOztBQUU3TDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw4QkFBOEIseURBQWE7QUFDM0MsOEJBQThCLHFFQUF5QiwwQkFBMEIsb0VBQXdCO0FBQ3pHLHlCQUF5QixxREFBUyxxRUFBcUU7O0FBRXZHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRCQUE0QiwyREFBZSxlQUFlLDJEQUFlO0FBQ3pFLG1EQUFtRCx3REFBWSxVQUFVLDJEQUFlO0FBQ3hGLG1EQUFtRCx3REFBWTs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0VBQWtFLDhEQUFrQjs7QUFFcEY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7O0FBRUEsOEJBQThCLHNEQUFVOztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBbUMsNkRBQWE7O0FBRWhEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsWUFBWTs7QUFFWjs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVOztBQUVWOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EOztBQUVBLDhCQUE4QixzREFBVTs7QUFFeEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsVUFBVTs7QUFFVjs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLCtCQUErQiw2REFBYTs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxRQUFROztBQUVSOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQSx1QkFBdUIsWUFBWTs7QUFFbkM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw0QkFBNEIsMkRBQWUsZUFBZSwyREFBZTtBQUN6RSxtREFBbUQsd0RBQVksVUFBVSwyREFBZTtBQUN4RixtREFBbUQsd0RBQVk7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLE9BQU87O0FBRTNCOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCLE9BQU87O0FBRTVCOztBQUVBLHNCQUFzQixvQkFBb0I7O0FBRTFDOztBQUVBLDhCQUE4QixzREFBVTs7QUFFeEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsVUFBVTs7QUFFVjs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQkFBcUIsT0FBTzs7QUFFNUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQSx1QkFBdUIsb0JBQW9COztBQUUzQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxRQUFROztBQUVSOztBQUVBOztBQUVBLHVCQUF1QixvQkFBb0I7O0FBRTNDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUksMkpBQTJKOztBQUUvSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsb0JBQW9CLHFCQUFxQjs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRDQUE0Qyx1REFBVzs7QUFFdkQ7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxJQUFJLCtDQUErQyw4REFBa0I7O0FBRXJFOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLHFCQUFxQixPQUFPOztBQUU1Qjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsT0FBTzs7QUFFM0I7O0FBRUE7O0FBRUEsMEJBQTBCLGdDQUFnQzs7QUFFMUQ7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLHlCQUF5QixnQ0FBZ0M7O0FBRXpEOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLHFCQUFxQjs7QUFFMUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTzs7QUFFM0I7O0FBRUEsMEJBQTBCLGdDQUFnQzs7QUFFMUQ7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKLDBDQUEwQyxRQUFROztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCLGdDQUFnQzs7QUFFekQ7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsUUFBUTs7QUFFakQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixxQkFBcUI7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixxQkFBcUI7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IscUJBQXFCOztBQUUzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsZ0VBQW9CLG1CQUFtQix3REFBWTs7QUFFekU7O0FBRUEsUUFBUSwyREFBZSwrQkFBK0Isd0RBQVk7O0FBRWxFOztBQUVBLG9CQUFvQixzREFBVSxhQUFhLDREQUFnQjs7QUFFM0Q7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyx3REFBWTs7QUFFL0M7O0FBRUEsbUJBQW1CLDJEQUFlOztBQUVsQyxhQUFhLDREQUFnQjtBQUM3QixhQUFhLGlFQUFxQjtBQUNsQyxhQUFhLGlFQUFxQjtBQUNsQyxhQUFhLCtEQUFtQjs7QUFFaEMsYUFBYSxvREFBUTtBQUNyQixhQUFhLHFEQUFTO0FBQ3RCLGFBQWEsNkRBQWlCO0FBQzlCLGFBQWEsbURBQU87QUFDcEIsYUFBYSwyREFBZTtBQUM1QixhQUFhLHFEQUFTO0FBQ3RCLGFBQWEseURBQWE7O0FBRTFCLGFBQWEsdURBQVc7QUFDeEIsYUFBYSxxREFBUztBQUN0QixhQUFhLHNEQUFVO0FBQ3ZCLGFBQWEsMkRBQWU7QUFDNUIsYUFBYSxnRUFBb0I7QUFDakMsYUFBYSx1REFBVztBQUN4QixhQUFhLDhEQUFrQjs7QUFFL0I7O0FBRUEsYUFBYSxxREFBUztBQUN0QixhQUFhLDREQUFnQjtBQUM3QixhQUFhLG9EQUFRO0FBQ3JCLGFBQWEsMkRBQWU7QUFDNUIsYUFBYSw2REFBaUI7O0FBRTlCOztBQUVBLGFBQWEsZ0VBQW9CLFVBQVUsaUVBQXFCLFVBQVUsaUVBQXFCLFVBQVUsaUVBQXFCOztBQUU5SCxxQkFBcUIsd0RBQVk7O0FBRWpDOztBQUVBOztBQUVBLGdCQUFnQixnRUFBb0I7QUFDcEMsZ0JBQWdCLGlFQUFxQjtBQUNyQyxnQkFBZ0IsaUVBQXFCO0FBQ3JDLGdCQUFnQixpRUFBcUI7O0FBRXJDLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxnQkFBZ0IsZ0VBQW9CO0FBQ3BDLGdCQUFnQixpRUFBcUI7QUFDckMsZ0JBQWdCLGlFQUFxQjtBQUNyQyxnQkFBZ0IsaUVBQXFCOztBQUVyQyxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGFBQWEsbUVBQXVCLFVBQVUsbUVBQXVCLFVBQVUsb0VBQXdCLFVBQVUsb0VBQXdCOztBQUV6STs7QUFFQTs7QUFFQSxlQUFlLG1FQUF1QjtBQUN0QyxlQUFlLG1FQUF1QjtBQUN0QyxlQUFlLG9FQUF3QjtBQUN2QyxlQUFlLG9FQUF3Qjs7QUFFdkMsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxhQUFhLDJEQUFlLFVBQVUsMkRBQWUsVUFBVSxnRUFBb0I7O0FBRW5GOztBQUVBOztBQUVBLGVBQWUsMkRBQWUsVUFBVSwyREFBZSx5QkFBeUIsd0RBQVk7QUFDNUYsZUFBZSxnRUFBb0IseUJBQXlCLHdEQUFZOztBQUV4RSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGFBQWEsZ0VBQW9CLFVBQVUsZ0VBQW9CLFVBQVUsZ0VBQW9CO0FBQzdGLFNBQVMsZ0VBQW9CLFVBQVUsZ0VBQW9CLFVBQVUsZ0VBQW9CO0FBQ3pGLFNBQVMsZ0VBQW9CLFVBQVUsZ0VBQW9CLFVBQVUsaUVBQXFCO0FBQzFGLFNBQVMsaUVBQXFCLFVBQVUsaUVBQXFCLFVBQVUsa0VBQXNCO0FBQzdGLFNBQVMsa0VBQXNCLFVBQVUsa0VBQXNCOztBQUUvRDs7QUFFQTs7QUFFQSxlQUFlLGdFQUFvQix5QkFBeUIsd0RBQVk7QUFDeEUsZUFBZSxnRUFBb0IseUJBQXlCLHdEQUFZO0FBQ3hFLGVBQWUsZ0VBQW9CLHlCQUF5Qix3REFBWTtBQUN4RSxlQUFlLGdFQUFvQix5QkFBeUIsd0RBQVk7QUFDeEUsZUFBZSxnRUFBb0IseUJBQXlCLHdEQUFZO0FBQ3hFLGVBQWUsZ0VBQW9CLHlCQUF5Qix3REFBWTtBQUN4RSxlQUFlLGdFQUFvQix5QkFBeUIsd0RBQVk7QUFDeEUsZUFBZSxnRUFBb0IseUJBQXlCLHdEQUFZO0FBQ3hFLGVBQWUsaUVBQXFCLHlCQUF5Qix3REFBWTtBQUN6RSxlQUFlLGlFQUFxQix5QkFBeUIsd0RBQVk7QUFDekUsZUFBZSxpRUFBcUIseUJBQXlCLHdEQUFZO0FBQ3pFLGVBQWUsa0VBQXNCLHlCQUF5Qix3REFBWTtBQUMxRSxlQUFlLGtFQUFzQix5QkFBeUIsd0RBQVk7QUFDMUUsZUFBZSxrRUFBc0IseUJBQXlCLHdEQUFZOztBQUUxRSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGFBQWEsNERBQWdCLFVBQVUsa0VBQXNCLFVBQVUsb0VBQXdCOztBQUUvRjs7QUFFQTs7QUFFQSxlQUFlLDREQUFnQix5QkFBeUIsd0RBQVk7QUFDcEUsZUFBZSxrRUFBc0I7QUFDckMsZUFBZSxvRUFBd0I7O0FBRXZDLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsYUFBYSw0REFBZ0IsVUFBVSxtRUFBdUIsVUFBVSxrRUFBc0IsVUFBVSx5RUFBNkI7O0FBRXJJOztBQUVBOztBQUVBLGVBQWUsNERBQWdCO0FBQy9CLGVBQWUsbUVBQXVCO0FBQ3RDLGVBQWUsa0VBQXNCO0FBQ3JDLGVBQWUseUVBQTZCOztBQUU1QyxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGFBQWEsOERBQWtCOztBQUUvQjs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVOztBQUVWOztBQUVBLHFCQUFxQjs7QUFFckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixpREFBSztBQUN6QjtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5QkFBeUIsaURBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1EQUFPO0FBQy9DO0FBQ0EseUNBQXlDLG1EQUFPOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsaURBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1EQUFPO0FBQzFDO0FBQ0Esb0NBQW9DLG1EQUFPOztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdCQUF3Qix1Q0FBdUM7O0FBRS9EOztBQUVBOztBQUVBOztBQUVBLHdCQUF3QiwwQ0FBMEM7O0FBRWxFOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxRQUFROztBQUVSOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQixpREFBSztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLG1EQUFPOztBQUU5QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUIsMERBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QyxvQkFBb0IsbUJBQW1CO0FBQ3ZDLHFCQUFxQjtBQUNyQjtBQUNBLE1BQU07O0FBRU4sb0JBQW9CLGdEQUFJLE1BQU0seURBQWE7O0FBRTNDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkJBQTJCLDJEQUFlOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCLG1EQUFPO0FBQ2pDOztBQUVBOztBQUVBLHNCQUFzQiw2REFBaUI7QUFDdkMseUJBQXlCLG1EQUFPOztBQUVoQyxzQkFBc0IsNkRBQWlCO0FBQ3ZDLHlCQUF5QixtREFBTzs7QUFFaEM7O0FBRUEsdUJBQXVCLHVEQUFXOztBQUVsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0MsNENBQTRDOztBQUU1RTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix3QkFBd0I7O0FBRTVDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQixxQkFBcUI7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQ0FBa0MseUJBQXlCOztBQUUzRDtBQUNBOztBQUVBLDJCQUEyQiw2REFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBVTtBQUN6QixhQUFhLDREQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlDQUF5Qyw4REFBa0IsR0FBRyx1REFBVztBQUN6RSx1Q0FBdUMsOERBQWtCLEdBQUcsMkRBQWU7O0FBRTNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDLDBCQUEwQjs7QUFFNUQ7QUFDQTs7QUFFQSwyQkFBMkIsNkRBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQVU7QUFDekIsYUFBYSw0REFBZ0I7QUFDN0IseUJBQXlCLHdEQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjs7QUFFQSw2Q0FBNkM7O0FBRTdDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkIsdUJBQXVCOztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsMEJBQTBCOztBQUU5QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHdCQUF3Qjs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0JBQXNCLHdCQUF3Qjs7QUFFOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFFBQVE7O0FBRVI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlCQUF5QixtREFBTztBQUNoQyx5QkFBeUIsbURBQU87O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLG1CQUFtQjtBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLG9CQUFvQjs7QUFFeEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLG1EQUFPO0FBQ3hCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLGtCQUFrQjs7QUFFdkM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLDZEQUFpQjtBQUNwQztBQUNBLDRCQUE0QixtREFBTztBQUNuQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHdCQUF3Qjs7QUFFNUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQkFBMkIsc0NBQXNDOztBQUVqRTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4QkFBOEIsaURBQUs7QUFDbkMsOEJBQThCLG1EQUFPOztBQUVyQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw2Q0FBNkMseUVBQXlCOztBQUV0RTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSix3Q0FBd0M7O0FBRXhDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBCQUEwQixvREFBUTs7QUFFbEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQTBCLG9EQUFROztBQUVsQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUIsY0FBYzs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbUVBQW1FOztBQUVuRTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEM7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQkFBMkIsb0RBQVE7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2RUFBNkU7O0FBRTdFOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixzQkFBc0I7O0FBRXpDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDs7QUFFQSw4Q0FBOEMsUUFBUTs7QUFFdEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0JBQXNCLG1CQUFtQjs7QUFFekM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0I7QUFDbEIsd0JBQXdCOztBQUV4Qix3Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUEsOENBQThDLFFBQVE7O0FBRXREOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDs7QUFFQTs7QUFFQSw2Q0FBNkM7QUFDN0MsdURBQXVEO0FBQ3ZELG9EQUFvRDs7QUFFcEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBLHNCQUFzQjs7QUFFdEIsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0EsWUFBWSxtRUFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCLDBEQUFjOztBQUV6Qzs7QUFFQSxxQkFBcUIseURBQWE7QUFDbEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0JBQStCLG1EQUFPO0FBQ3RDLDhCQUE4QixtREFBTztBQUNyQzs7QUFFQSxpQ0FBaUMsaURBQUs7QUFDdEM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG1EQUFPO0FBQy9CLHVCQUF1QixtREFBTztBQUM5Qjs7QUFFQTs7QUFFQSx1QkFBdUIsbURBQU87O0FBRTlCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsbURBQU87QUFDOUMsZ0NBQWdDLG1EQUFPOztBQUV2Qyx1QkFBdUIsbURBQU87O0FBRTlCLHVCQUF1QixtREFBTzs7QUFFOUIsd0JBQXdCOztBQUV4Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9GQUFvRixvREFBUSxDQUFDOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3Qyw2REFBaUI7QUFDekQsdUJBQXVCLDJEQUFlO0FBQ3RDLHVCQUF1Qiw0REFBZ0I7O0FBRXZDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyw0REFBZ0I7QUFDM0QscUJBQXFCLDJEQUFlO0FBQ3BDLHFCQUFxQiw2REFBaUI7QUFDdEMscUJBQXFCLDhEQUFrQjtBQUN2QyxxQkFBcUIsaUVBQXFCO0FBQzFDLHFCQUFxQixpRUFBcUI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEM7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLGtEQUFrRDs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTs7QUFFdEM7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkRBQTJELHNEQUFVOztBQUVyRSxvQkFBb0Isb0RBQVE7QUFDNUI7QUFDQTs7QUFFQSxvQkFBb0IscURBQVM7QUFDN0I7QUFDQTs7QUFFQSxvQkFBb0Isc0RBQVU7O0FBRTlCLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLHFCQUFxQjs7QUFFNUM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkJBQTZCOztBQUU3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBDQUEwQyxPQUFPOztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsT0FBTzs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQyxPQUFPOztBQUVsRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLE9BQU87O0FBRWhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlFQUF5RSw2REFBaUI7QUFDMUY7QUFDQSwrR0FBK0cseURBQWEsR0FBRyw0REFBZ0I7QUFDL0ksZ0JBQWdCLG9FQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyREFBZTtBQUNoQyxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMseUNBQXlDOztBQUV2RjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQWE7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsK0VBQStFOztBQUUvRTs7QUFFQSxxREFBcUQsT0FBTzs7QUFFNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLHNEQUFVOztBQUV0Qzs7QUFFQSxzQkFBc0Isb0RBQVE7QUFDOUI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQyxPQUFPOztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDJEQUEyRCxzREFBVTs7QUFFckUsb0JBQW9CLG9EQUFRO0FBQzVCO0FBQ0E7O0FBRUEsb0JBQW9CLHFEQUFTO0FBQzdCO0FBQ0E7O0FBRUEsb0JBQW9CLHNEQUFVOztBQUU5QixLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNEQUFzRDs7QUFFdEQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHNEQUFzRDs7QUFFdEQ7O0FBRUE7QUFDQTtBQUNBLGdMQUFnTCxnRUFBb0I7QUFDcE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQix5REFBYTs7QUFFbEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSyw0RUFBNEI7QUFDakMsS0FBSywwRUFBMEI7O0FBRS9COztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qiw0QkFBNEI7O0FBRTVCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxPQUFPOztBQUUvQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNkJBQTZCOztBQUU3Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxXQUFXLDBEQUFVOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUksd0RBQVE7O0FBRVo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUksd0RBQVE7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSyx3REFBUTtBQUNiO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixXQUFXOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFdBQVc7O0FBRWhDO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBLE1BQU07O0FBRU47QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUksd0RBQVE7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUcsd0RBQVE7O0FBRVg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUVBQW1FLGVBQWU7O0FBRWxGOztBQUVBOztBQUVBOztBQUVBLFNBQVMsaUVBQXFCOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLCtCQUErQiwyREFBZTtBQUM5Qyx3QkFBd0IsMkRBQWU7O0FBRXZDOztBQUVBOztBQUV1dEciLCJzb3VyY2VzIjpbIi9Vc2Vycy9qZXJlbXlqL0RvY3VtZW50cy9zb3VyY2UvcmVwb3Mvc2hhZGVycy9ub2RlX21vZHVsZXMvLnBucG0vdGhyZWVAMC4xNzIuMC9ub2RlX21vZHVsZXMvdGhyZWUvYnVpbGQvdGhyZWUubW9kdWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEwLTIwMjQgVGhyZWUuanMgQXV0aG9yc1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuICovXG5pbXBvcnQgeyBDb2xvciwgTWF0cml4MywgVmVjdG9yMiwgbWVyZ2VVbmlmb3JtcywgVmVjdG9yMywgQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcsIE1lc2gsIEJveEdlb21ldHJ5LCBTaGFkZXJNYXRlcmlhbCwgY2xvbmVVbmlmb3JtcywgQmFja1NpZGUsIENvbG9yTWFuYWdlbWVudCwgU1JHQlRyYW5zZmVyLCBQbGFuZUdlb21ldHJ5LCBGcm9udFNpZGUsIGdldFVubGl0VW5pZm9ybUNvbG9yU3BhY2UsIEV1bGVyLCBNYXRyaXg0LCBJbnRUeXBlLCBSR0JBRm9ybWF0LCBIYWxmRmxvYXRUeXBlLCBVbnNpZ25lZEJ5dGVUeXBlLCBGbG9hdFR5cGUsIFBsYW5lLCBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZywgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcsIFdlYkdMQ3ViZVJlbmRlclRhcmdldCwgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nLCBDdWJlUmVmcmFjdGlvbk1hcHBpbmcsIFBlcnNwZWN0aXZlQ2FtZXJhLCBOb1RvbmVNYXBwaW5nLCBNZXNoQmFzaWNNYXRlcmlhbCwgQnVmZmVyR2VvbWV0cnksIEJ1ZmZlckF0dHJpYnV0ZSwgV2ViR0xSZW5kZXJUYXJnZXQsIE5vQmxlbmRpbmcsIE9ydGhvZ3JhcGhpY0NhbWVyYSwgTGluZWFyRmlsdGVyLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSwgd2Fybk9uY2UsIGFycmF5TmVlZHNVaW50MzIsIFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSwgVWludDE2QnVmZmVyQXR0cmlidXRlLCBWZWN0b3I0LCBEYXRhQXJyYXlUZXh0dXJlLCBMZXNzRXF1YWxDb21wYXJlLCBUZXh0dXJlLCBEZXB0aFRleHR1cmUsIERhdGEzRFRleHR1cmUsIEN1YmVUZXh0dXJlLCBHTFNMMywgQ3VzdG9tVG9uZU1hcHBpbmcsIE5ldXRyYWxUb25lTWFwcGluZywgQWdYVG9uZU1hcHBpbmcsIEFDRVNGaWxtaWNUb25lTWFwcGluZywgQ2luZW9uVG9uZU1hcHBpbmcsIFJlaW5oYXJkVG9uZU1hcHBpbmcsIExpbmVhclRvbmVNYXBwaW5nLCBQQ0ZTaGFkb3dNYXAsIFBDRlNvZnRTaGFkb3dNYXAsIFZTTVNoYWRvd01hcCwgTGluZWFyVHJhbnNmZXIsIEFkZE9wZXJhdGlvbiwgTWl4T3BlcmF0aW9uLCBNdWx0aXBseU9wZXJhdGlvbiwgT2JqZWN0U3BhY2VOb3JtYWxNYXAsIFRhbmdlbnRTcGFjZU5vcm1hbE1hcCwgTm9ybWFsQmxlbmRpbmcsIERvdWJsZVNpZGUsIFVuaWZvcm1zVXRpbHMsIExheWVycywgRnJ1c3R1bSwgTWVzaERlcHRoTWF0ZXJpYWwsIFJHQkFEZXB0aFBhY2tpbmcsIE1lc2hEaXN0YW5jZU1hdGVyaWFsLCBOZWFyZXN0RmlsdGVyLCBMZXNzRXF1YWxEZXB0aCwgQWRkRXF1YXRpb24sIFN1YnRyYWN0RXF1YXRpb24sIFJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uLCBaZXJvRmFjdG9yLCBPbmVGYWN0b3IsIFNyY0NvbG9yRmFjdG9yLCBTcmNBbHBoYUZhY3RvciwgU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciwgRHN0Q29sb3JGYWN0b3IsIERzdEFscGhhRmFjdG9yLCBPbmVNaW51c1NyY0NvbG9yRmFjdG9yLCBPbmVNaW51c1NyY0FscGhhRmFjdG9yLCBPbmVNaW51c0RzdENvbG9yRmFjdG9yLCBPbmVNaW51c0RzdEFscGhhRmFjdG9yLCBDb25zdGFudENvbG9yRmFjdG9yLCBPbmVNaW51c0NvbnN0YW50Q29sb3JGYWN0b3IsIENvbnN0YW50QWxwaGFGYWN0b3IsIE9uZU1pbnVzQ29uc3RhbnRBbHBoYUZhY3RvciwgQ3VzdG9tQmxlbmRpbmcsIE11bHRpcGx5QmxlbmRpbmcsIFN1YnRyYWN0aXZlQmxlbmRpbmcsIEFkZGl0aXZlQmxlbmRpbmcsIEN1bGxGYWNlTm9uZSwgQ3VsbEZhY2VCYWNrLCBDdWxsRmFjZUZyb250LCBOb3RFcXVhbERlcHRoLCBHcmVhdGVyRGVwdGgsIEdyZWF0ZXJFcXVhbERlcHRoLCBFcXVhbERlcHRoLCBMZXNzRGVwdGgsIEFsd2F5c0RlcHRoLCBOZXZlckRlcHRoLCBNaW5FcXVhdGlvbiwgTWF4RXF1YXRpb24sIFJlcGVhdFdyYXBwaW5nLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLCBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciwgTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciwgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciwgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLCBOZXZlckNvbXBhcmUsIEFsd2F5c0NvbXBhcmUsIExlc3NDb21wYXJlLCBFcXVhbENvbXBhcmUsIEdyZWF0ZXJFcXVhbENvbXBhcmUsIEdyZWF0ZXJDb21wYXJlLCBOb3RFcXVhbENvbXBhcmUsIE5vQ29sb3JTcGFjZSwgRGVwdGhTdGVuY2lsRm9ybWF0LCBnZXRCeXRlTGVuZ3RoLCBVbnNpZ25lZEludFR5cGUsIFVuc2lnbmVkSW50MjQ4VHlwZSwgVW5zaWduZWRTaG9ydFR5cGUsIERlcHRoRm9ybWF0LCBjcmVhdGVFbGVtZW50TlMsIFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSwgVW5zaWduZWRTaG9ydDU1NTFUeXBlLCBVbnNpZ25lZEludDU5OTlUeXBlLCBCeXRlVHlwZSwgU2hvcnRUeXBlLCBBbHBoYUZvcm1hdCwgUkdCRm9ybWF0LCBMdW1pbmFuY2VGb3JtYXQsIEx1bWluYW5jZUFscGhhRm9ybWF0LCBSZWRGb3JtYXQsIFJlZEludGVnZXJGb3JtYXQsIFJHRm9ybWF0LCBSR0ludGVnZXJGb3JtYXQsIFJHQkFJbnRlZ2VyRm9ybWF0LCBSR0JfUzNUQ19EWFQxX0Zvcm1hdCwgUkdCQV9TM1RDX0RYVDFfRm9ybWF0LCBSR0JBX1MzVENfRFhUM19Gb3JtYXQsIFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCwgUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQsIFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0LCBSR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQsIFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCwgUkdCX0VUQzFfRm9ybWF0LCBSR0JfRVRDMl9Gb3JtYXQsIFJHQkFfRVRDMl9FQUNfRm9ybWF0LCBSR0JBX0FTVENfNHg0X0Zvcm1hdCwgUkdCQV9BU1RDXzV4NF9Gb3JtYXQsIFJHQkFfQVNUQ181eDVfRm9ybWF0LCBSR0JBX0FTVENfNng1X0Zvcm1hdCwgUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQsIFJHQkFfQVNUQ184eDVfRm9ybWF0LCBSR0JBX0FTVENfOHg2X0Zvcm1hdCwgUkdCQV9BU1RDXzh4OF9Gb3JtYXQsIFJHQkFfQVNUQ18xMHg1X0Zvcm1hdCwgUkdCQV9BU1RDXzEweDZfRm9ybWF0LCBSR0JBX0FTVENfMTB4OF9Gb3JtYXQsIFJHQkFfQVNUQ18xMHgxMF9Gb3JtYXQsIFJHQkFfQVNUQ18xMngxMF9Gb3JtYXQsIFJHQkFfQVNUQ18xMngxMl9Gb3JtYXQsIFJHQkFfQlBUQ19Gb3JtYXQsIFJHQl9CUFRDX1NJR05FRF9Gb3JtYXQsIFJHQl9CUFRDX1VOU0lHTkVEX0Zvcm1hdCwgUkVEX1JHVEMxX0Zvcm1hdCwgU0lHTkVEX1JFRF9SR1RDMV9Gb3JtYXQsIFJFRF9HUkVFTl9SR1RDMl9Gb3JtYXQsIFNJR05FRF9SRURfR1JFRU5fUkdUQzJfRm9ybWF0LCBHcm91cCwgRXZlbnREaXNwYXRjaGVyLCBBcnJheUNhbWVyYSwgUkFEMkRFRywgY3JlYXRlQ2FudmFzRWxlbWVudCwgU1JHQkNvbG9yU3BhY2UsIFJFVklTSU9OLCB0b05vcm1hbGl6ZWRQcm9qZWN0aW9uTWF0cml4LCB0b1JldmVyc2VkUHJvamVjdGlvbk1hdHJpeCwgcHJvYmVBc3luYywgV2ViR0xDb29yZGluYXRlU3lzdGVtIH0gZnJvbSAnLi90aHJlZS5jb3JlLmpzJztcbmV4cG9ydCB7IEFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlLCBBbHdheXNTdGVuY2lsRnVuYywgQW1iaWVudExpZ2h0LCBBbmltYXRpb25BY3Rpb24sIEFuaW1hdGlvbkNsaXAsIEFuaW1hdGlvbkxvYWRlciwgQW5pbWF0aW9uTWl4ZXIsIEFuaW1hdGlvbk9iamVjdEdyb3VwLCBBbmltYXRpb25VdGlscywgQXJjQ3VydmUsIEFycm93SGVscGVyLCBBdHRhY2hlZEJpbmRNb2RlLCBBdWRpbywgQXVkaW9BbmFseXNlciwgQXVkaW9Db250ZXh0LCBBdWRpb0xpc3RlbmVyLCBBdWRpb0xvYWRlciwgQXhlc0hlbHBlciwgQmFzaWNEZXB0aFBhY2tpbmcsIEJhc2ljU2hhZG93TWFwLCBCYXRjaGVkTWVzaCwgQm9uZSwgQm9vbGVhbktleWZyYW1lVHJhY2ssIEJveDIsIEJveDMsIEJveDNIZWxwZXIsIEJveEhlbHBlciwgQnVmZmVyR2VvbWV0cnlMb2FkZXIsIENhY2hlLCBDYW1lcmEsIENhbWVyYUhlbHBlciwgQ2FudmFzVGV4dHVyZSwgQ2Fwc3VsZUdlb21ldHJ5LCBDYXRtdWxsUm9tQ3VydmUzLCBDaXJjbGVHZW9tZXRyeSwgQ2xvY2ssIENvbG9yS2V5ZnJhbWVUcmFjaywgQ29tcHJlc3NlZEFycmF5VGV4dHVyZSwgQ29tcHJlc3NlZEN1YmVUZXh0dXJlLCBDb21wcmVzc2VkVGV4dHVyZSwgQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIsIENvbmVHZW9tZXRyeSwgQ29udHJvbHMsIEN1YmVDYW1lcmEsIEN1YmVUZXh0dXJlTG9hZGVyLCBDdWJpY0JlemllckN1cnZlLCBDdWJpY0JlemllckN1cnZlMywgQ3ViaWNJbnRlcnBvbGFudCwgQ3VsbEZhY2VGcm9udEJhY2ssIEN1cnZlLCBDdXJ2ZVBhdGgsIEN5bGluZGVyR2VvbWV0cnksIEN5bGluZHJpY2FsLCBEYXRhVGV4dHVyZSwgRGF0YVRleHR1cmVMb2FkZXIsIERhdGFVdGlscywgRGVjcmVtZW50U3RlbmNpbE9wLCBEZWNyZW1lbnRXcmFwU3RlbmNpbE9wLCBEZWZhdWx0TG9hZGluZ01hbmFnZXIsIERldGFjaGVkQmluZE1vZGUsIERpcmVjdGlvbmFsTGlnaHQsIERpcmVjdGlvbmFsTGlnaHRIZWxwZXIsIERpc2NyZXRlSW50ZXJwb2xhbnQsIERvZGVjYWhlZHJvbkdlb21ldHJ5LCBEeW5hbWljQ29weVVzYWdlLCBEeW5hbWljRHJhd1VzYWdlLCBEeW5hbWljUmVhZFVzYWdlLCBFZGdlc0dlb21ldHJ5LCBFbGxpcHNlQ3VydmUsIEVxdWFsU3RlbmNpbEZ1bmMsIEV4dHJ1ZGVHZW9tZXRyeSwgRmlsZUxvYWRlciwgRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSwgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSwgRm9nLCBGb2dFeHAyLCBGcmFtZWJ1ZmZlclRleHR1cmUsIEdMQnVmZmVyQXR0cmlidXRlLCBHTFNMMSwgR3JlYXRlckVxdWFsU3RlbmNpbEZ1bmMsIEdyZWF0ZXJTdGVuY2lsRnVuYywgR3JpZEhlbHBlciwgSGVtaXNwaGVyZUxpZ2h0LCBIZW1pc3BoZXJlTGlnaHRIZWxwZXIsIEljb3NhaGVkcm9uR2VvbWV0cnksIEltYWdlQml0bWFwTG9hZGVyLCBJbWFnZUxvYWRlciwgSW1hZ2VVdGlscywgSW5jcmVtZW50U3RlbmNpbE9wLCBJbmNyZW1lbnRXcmFwU3RlbmNpbE9wLCBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUsIEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LCBJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciwgSW5zdGFuY2VkTWVzaCwgSW50MTZCdWZmZXJBdHRyaWJ1dGUsIEludDMyQnVmZmVyQXR0cmlidXRlLCBJbnQ4QnVmZmVyQXR0cmlidXRlLCBJbnRlcmxlYXZlZEJ1ZmZlciwgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUsIEludGVycG9sYW50LCBJbnRlcnBvbGF0ZURpc2NyZXRlLCBJbnRlcnBvbGF0ZUxpbmVhciwgSW50ZXJwb2xhdGVTbW9vdGgsIEludmVydFN0ZW5jaWxPcCwgS2VlcFN0ZW5jaWxPcCwgS2V5ZnJhbWVUcmFjaywgTE9ELCBMYXRoZUdlb21ldHJ5LCBMZXNzRXF1YWxTdGVuY2lsRnVuYywgTGVzc1N0ZW5jaWxGdW5jLCBMaWdodCwgTGlnaHRQcm9iZSwgTGluZSwgTGluZTMsIExpbmVCYXNpY01hdGVyaWFsLCBMaW5lQ3VydmUsIExpbmVDdXJ2ZTMsIExpbmVEYXNoZWRNYXRlcmlhbCwgTGluZUxvb3AsIExpbmVTZWdtZW50cywgTGluZWFySW50ZXJwb2xhbnQsIExpbmVhck1pcE1hcExpbmVhckZpbHRlciwgTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciwgTG9hZGVyLCBMb2FkZXJVdGlscywgTG9hZGluZ01hbmFnZXIsIExvb3BPbmNlLCBMb29wUGluZ1BvbmcsIExvb3BSZXBlYXQsIE1PVVNFLCBNYXRlcmlhbCwgTWF0ZXJpYWxMb2FkZXIsIE1hdGhVdGlscywgTWF0cml4MiwgTWVzaExhbWJlcnRNYXRlcmlhbCwgTWVzaE1hdGNhcE1hdGVyaWFsLCBNZXNoTm9ybWFsTWF0ZXJpYWwsIE1lc2hQaG9uZ01hdGVyaWFsLCBNZXNoUGh5c2ljYWxNYXRlcmlhbCwgTWVzaFN0YW5kYXJkTWF0ZXJpYWwsIE1lc2hUb29uTWF0ZXJpYWwsIE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIsIE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyLCBOZXZlclN0ZW5jaWxGdW5jLCBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGUsIE5vdEVxdWFsU3RlbmNpbEZ1bmMsIE51bWJlcktleWZyYW1lVHJhY2ssIE9iamVjdDNELCBPYmplY3RMb2FkZXIsIE9jdGFoZWRyb25HZW9tZXRyeSwgUGF0aCwgUGxhbmVIZWxwZXIsIFBvaW50TGlnaHQsIFBvaW50TGlnaHRIZWxwZXIsIFBvaW50cywgUG9pbnRzTWF0ZXJpYWwsIFBvbGFyR3JpZEhlbHBlciwgUG9seWhlZHJvbkdlb21ldHJ5LCBQb3NpdGlvbmFsQXVkaW8sIFByb3BlcnR5QmluZGluZywgUHJvcGVydHlNaXhlciwgUXVhZHJhdGljQmV6aWVyQ3VydmUsIFF1YWRyYXRpY0JlemllckN1cnZlMywgUXVhdGVybmlvbiwgUXVhdGVybmlvbktleWZyYW1lVHJhY2ssIFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCwgUkdCRGVwdGhQYWNraW5nLCBSR0JJbnRlZ2VyRm9ybWF0LCBSR0RlcHRoUGFja2luZywgUmF3U2hhZGVyTWF0ZXJpYWwsIFJheSwgUmF5Y2FzdGVyLCBSZWN0QXJlYUxpZ2h0LCBSZW5kZXJUYXJnZXQsIFJlbmRlclRhcmdldDNELCBSZW5kZXJUYXJnZXRBcnJheSwgUmVwbGFjZVN0ZW5jaWxPcCwgUmluZ0dlb21ldHJ5LCBTY2VuZSwgU2hhZG93TWF0ZXJpYWwsIFNoYXBlLCBTaGFwZUdlb21ldHJ5LCBTaGFwZVBhdGgsIFNoYXBlVXRpbHMsIFNrZWxldG9uLCBTa2VsZXRvbkhlbHBlciwgU2tpbm5lZE1lc2gsIFNvdXJjZSwgU3BoZXJlLCBTcGhlcmVHZW9tZXRyeSwgU3BoZXJpY2FsLCBTcGhlcmljYWxIYXJtb25pY3MzLCBTcGxpbmVDdXJ2ZSwgU3BvdExpZ2h0LCBTcG90TGlnaHRIZWxwZXIsIFNwcml0ZSwgU3ByaXRlTWF0ZXJpYWwsIFN0YXRpY0NvcHlVc2FnZSwgU3RhdGljRHJhd1VzYWdlLCBTdGF0aWNSZWFkVXNhZ2UsIFN0ZXJlb0NhbWVyYSwgU3RyZWFtQ29weVVzYWdlLCBTdHJlYW1EcmF3VXNhZ2UsIFN0cmVhbVJlYWRVc2FnZSwgU3RyaW5nS2V5ZnJhbWVUcmFjaywgVE9VQ0gsIFRldHJhaGVkcm9uR2VvbWV0cnksIFRleHR1cmVMb2FkZXIsIFRleHR1cmVVdGlscywgVG9ydXNHZW9tZXRyeSwgVG9ydXNLbm90R2VvbWV0cnksIFRyaWFuZ2xlLCBUcmlhbmdsZUZhbkRyYXdNb2RlLCBUcmlhbmdsZVN0cmlwRHJhd01vZGUsIFRyaWFuZ2xlc0RyYXdNb2RlLCBUdWJlR2VvbWV0cnksIFVWTWFwcGluZywgVWludDhCdWZmZXJBdHRyaWJ1dGUsIFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSwgVW5pZm9ybSwgVW5pZm9ybXNHcm91cCwgVmVjdG9yS2V5ZnJhbWVUcmFjaywgVmlkZW9UZXh0dXJlLCBXZWJHTDNEUmVuZGVyVGFyZ2V0LCBXZWJHTEFycmF5UmVuZGVyVGFyZ2V0LCBXZWJHUFVDb29yZGluYXRlU3lzdGVtLCBXaXJlZnJhbWVHZW9tZXRyeSwgV3JhcEFyb3VuZEVuZGluZywgWmVyb0N1cnZhdHVyZUVuZGluZywgWmVyb1Nsb3BlRW5kaW5nLCBaZXJvU3RlbmNpbE9wIH0gZnJvbSAnLi90aHJlZS5jb3JlLmpzJztcblxuZnVuY3Rpb24gV2ViR0xBbmltYXRpb24oKSB7XG5cblx0bGV0IGNvbnRleHQgPSBudWxsO1xuXHRsZXQgaXNBbmltYXRpbmcgPSBmYWxzZTtcblx0bGV0IGFuaW1hdGlvbkxvb3AgPSBudWxsO1xuXHRsZXQgcmVxdWVzdElkID0gbnVsbDtcblxuXHRmdW5jdGlvbiBvbkFuaW1hdGlvbkZyYW1lKCB0aW1lLCBmcmFtZSApIHtcblxuXHRcdGFuaW1hdGlvbkxvb3AoIHRpbWUsIGZyYW1lICk7XG5cblx0XHRyZXF1ZXN0SWQgPSBjb250ZXh0LnJlcXVlc3RBbmltYXRpb25GcmFtZSggb25BbmltYXRpb25GcmFtZSApO1xuXG5cdH1cblxuXHRyZXR1cm4ge1xuXG5cdFx0c3RhcnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0aWYgKCBpc0FuaW1hdGluZyA9PT0gdHJ1ZSApIHJldHVybjtcblx0XHRcdGlmICggYW5pbWF0aW9uTG9vcCA9PT0gbnVsbCApIHJldHVybjtcblxuXHRcdFx0cmVxdWVzdElkID0gY29udGV4dC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIG9uQW5pbWF0aW9uRnJhbWUgKTtcblxuXHRcdFx0aXNBbmltYXRpbmcgPSB0cnVlO1xuXG5cdFx0fSxcblxuXHRcdHN0b3A6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29udGV4dC5jYW5jZWxBbmltYXRpb25GcmFtZSggcmVxdWVzdElkICk7XG5cblx0XHRcdGlzQW5pbWF0aW5nID0gZmFsc2U7XG5cblx0XHR9LFxuXG5cdFx0c2V0QW5pbWF0aW9uTG9vcDogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdFx0YW5pbWF0aW9uTG9vcCA9IGNhbGxiYWNrO1xuXG5cdFx0fSxcblxuXHRcdHNldENvbnRleHQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnRleHQgPSB2YWx1ZTtcblxuXHRcdH1cblxuXHR9O1xuXG59XG5cbmZ1bmN0aW9uIFdlYkdMQXR0cmlidXRlcyggZ2wgKSB7XG5cblx0Y29uc3QgYnVmZmVycyA9IG5ldyBXZWFrTWFwKCk7XG5cblx0ZnVuY3Rpb24gY3JlYXRlQnVmZmVyKCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKSB7XG5cblx0XHRjb25zdCBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcblx0XHRjb25zdCB1c2FnZSA9IGF0dHJpYnV0ZS51c2FnZTtcblx0XHRjb25zdCBzaXplID0gYXJyYXkuYnl0ZUxlbmd0aDtcblxuXHRcdGNvbnN0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG5cdFx0Z2wuYmluZEJ1ZmZlciggYnVmZmVyVHlwZSwgYnVmZmVyICk7XG5cdFx0Z2wuYnVmZmVyRGF0YSggYnVmZmVyVHlwZSwgYXJyYXksIHVzYWdlICk7XG5cblx0XHRhdHRyaWJ1dGUub25VcGxvYWRDYWxsYmFjaygpO1xuXG5cdFx0bGV0IHR5cGU7XG5cblx0XHRpZiAoIGFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICkge1xuXG5cdFx0XHR0eXBlID0gZ2wuRkxPQVQ7XG5cblx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5ICkge1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5pc0Zsb2F0MTZCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdFx0dHlwZSA9IGdsLkhBTEZfRkxPQVQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dHlwZSA9IGdsLlVOU0lHTkVEX1NIT1JUO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkgKSB7XG5cblx0XHRcdHR5cGUgPSBnbC5TSE9SVDtcblxuXHRcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkgKSB7XG5cblx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9JTlQ7XG5cblx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkgKSB7XG5cblx0XHRcdHR5cGUgPSBnbC5JTlQ7XG5cblx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSApIHtcblxuXHRcdFx0dHlwZSA9IGdsLkJZVEU7XG5cblx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgKSB7XG5cblx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuXG5cdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSApIHtcblxuXHRcdFx0dHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5XZWJHTEF0dHJpYnV0ZXM6IFVuc3VwcG9ydGVkIGJ1ZmZlciBkYXRhIGZvcm1hdDogJyArIGFycmF5ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YnVmZmVyOiBidWZmZXIsXG5cdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0Ynl0ZXNQZXJFbGVtZW50OiBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcblx0XHRcdHZlcnNpb246IGF0dHJpYnV0ZS52ZXJzaW9uLFxuXHRcdFx0c2l6ZTogc2l6ZVxuXHRcdH07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZUJ1ZmZlciggYnVmZmVyLCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKSB7XG5cblx0XHRjb25zdCBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcblx0XHRjb25zdCB1cGRhdGVSYW5nZXMgPSBhdHRyaWJ1dGUudXBkYXRlUmFuZ2VzO1xuXG5cdFx0Z2wuYmluZEJ1ZmZlciggYnVmZmVyVHlwZSwgYnVmZmVyICk7XG5cblx0XHRpZiAoIHVwZGF0ZVJhbmdlcy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdC8vIE5vdCB1c2luZyB1cGRhdGUgcmFuZ2VzXG5cdFx0XHRnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCAwLCBhcnJheSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQmVmb3JlIGFwcGx5aW5nIHVwZGF0ZSByYW5nZXMsIHdlIG1lcmdlIGFueSBhZGphY2VudCAvIG92ZXJsYXBwaW5nXG5cdFx0XHQvLyByYW5nZXMgdG8gcmVkdWNlIGxvYWQgb24gYGdsLmJ1ZmZlclN1YkRhdGFgLiBFbXBpcmljYWxseSwgdGhpcyBoYXMgbGVkXG5cdFx0XHQvLyB0byBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudHMgZm9yIGFwcGxpY2F0aW9ucyB3aGljaCBtYWtlIGhlYXZ5IHVzZSBvZlxuXHRcdFx0Ly8gdXBkYXRlIHJhbmdlcy4gTGlrZWx5IGR1ZSB0byBHUFUgY29tbWFuZCBvdmVyaGVhZC5cblx0XHRcdC8vXG5cdFx0XHQvLyBOb3RlIHRoYXQgdG8gcmVkdWNlIGdhcmJhZ2UgY29sbGVjdGlvbiBiZXR3ZWVuIGZyYW1lcywgd2UgbWVyZ2UgdGhlXG5cdFx0XHQvLyB1cGRhdGUgcmFuZ2VzIGluLXBsYWNlLiBUaGlzIGlzIHNhZmUgYmVjYXVzZSB0aGlzIG1ldGhvZCB3aWxsIGNsZWFyIHRoZVxuXHRcdFx0Ly8gdXBkYXRlIHJhbmdlcyBvbmNlIHVwZGF0ZWQuXG5cblx0XHRcdHVwZGF0ZVJhbmdlcy5zb3J0KCAoIGEsIGIgKSA9PiBhLnN0YXJ0IC0gYi5zdGFydCApO1xuXG5cdFx0XHQvLyBUbyBtZXJnZSB0aGUgdXBkYXRlIHJhbmdlcyBpbi1wbGFjZSwgd2Ugd29yayBmcm9tIGxlZnQgdG8gcmlnaHQgaW4gdGhlXG5cdFx0XHQvLyBleGlzdGluZyB1cGRhdGVSYW5nZXMgYXJyYXksIG1lcmdpbmcgcmFuZ2VzLiBUaGlzIG1heSByZXN1bHQgaW4gYSBmaW5hbFxuXHRcdFx0Ly8gYXJyYXkgd2hpY2ggaXMgc21hbGxlciB0aGFuIHRoZSBvcmlnaW5hbC4gVGhpcyBpbmRleCB0cmFja3MgdGhlIGxhc3Rcblx0XHRcdC8vIGluZGV4IHJlcHJlc2VudGluZyBhIG1lcmdlZCByYW5nZSwgYW55IGRhdGEgYWZ0ZXIgdGhpcyBpbmRleCBjYW4gYmVcblx0XHRcdC8vIHRyaW1tZWQgb25jZSB0aGUgbWVyZ2UgYWxnb3JpdGhtIGlzIGNvbXBsZXRlZC5cblx0XHRcdGxldCBtZXJnZUluZGV4ID0gMDtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAxOyBpIDwgdXBkYXRlUmFuZ2VzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBwcmV2aW91c1JhbmdlID0gdXBkYXRlUmFuZ2VzWyBtZXJnZUluZGV4IF07XG5cdFx0XHRcdGNvbnN0IHJhbmdlID0gdXBkYXRlUmFuZ2VzWyBpIF07XG5cblx0XHRcdFx0Ly8gV2UgYWRkIG9uZSBoZXJlIHRvIG1lcmdlIGFkamFjZW50IHJhbmdlcy4gVGhpcyBpcyBzYWZlIGJlY2F1c2UgcmFuZ2VzXG5cdFx0XHRcdC8vIG9wZXJhdGUgb3ZlciBwb3NpdGl2ZSBpbnRlZ2Vycy5cblx0XHRcdFx0aWYgKCByYW5nZS5zdGFydCA8PSBwcmV2aW91c1JhbmdlLnN0YXJ0ICsgcHJldmlvdXNSYW5nZS5jb3VudCArIDEgKSB7XG5cblx0XHRcdFx0XHRwcmV2aW91c1JhbmdlLmNvdW50ID0gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRwcmV2aW91c1JhbmdlLmNvdW50LFxuXHRcdFx0XHRcdFx0cmFuZ2Uuc3RhcnQgKyByYW5nZS5jb3VudCAtIHByZXZpb3VzUmFuZ2Uuc3RhcnRcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQrKyBtZXJnZUluZGV4O1xuXHRcdFx0XHRcdHVwZGF0ZVJhbmdlc1sgbWVyZ2VJbmRleCBdID0gcmFuZ2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyaW0gdGhlIGFycmF5IHRvIG9ubHkgY29udGFpbiB0aGUgbWVyZ2VkIHJhbmdlcy5cblx0XHRcdHVwZGF0ZVJhbmdlcy5sZW5ndGggPSBtZXJnZUluZGV4ICsgMTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdXBkYXRlUmFuZ2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgcmFuZ2UgPSB1cGRhdGVSYW5nZXNbIGkgXTtcblxuXHRcdFx0XHRnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCByYW5nZS5zdGFydCAqIGFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuXHRcdFx0XHRcdGFycmF5LCByYW5nZS5zdGFydCwgcmFuZ2UuY291bnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRhdHRyaWJ1dGUuY2xlYXJVcGRhdGVSYW5nZXMoKTtcblxuXHRcdH1cblxuXHRcdGF0dHJpYnV0ZS5vblVwbG9hZENhbGxiYWNrKCk7XG5cblx0fVxuXG5cdC8vXG5cblx0ZnVuY3Rpb24gZ2V0KCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgYXR0cmlidXRlID0gYXR0cmlidXRlLmRhdGE7XG5cblx0XHRyZXR1cm4gYnVmZmVycy5nZXQoIGF0dHJpYnV0ZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZW1vdmUoIGF0dHJpYnV0ZSApIHtcblxuXHRcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuZGF0YTtcblxuXHRcdGNvbnN0IGRhdGEgPSBidWZmZXJzLmdldCggYXR0cmlidXRlICk7XG5cblx0XHRpZiAoIGRhdGEgKSB7XG5cblx0XHRcdGdsLmRlbGV0ZUJ1ZmZlciggZGF0YS5idWZmZXIgKTtcblxuXHRcdFx0YnVmZmVycy5kZWxldGUoIGF0dHJpYnV0ZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGUoIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSApIHtcblxuXHRcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuZGF0YTtcblxuXHRcdGlmICggYXR0cmlidXRlLmlzR0xCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdGNvbnN0IGNhY2hlZCA9IGJ1ZmZlcnMuZ2V0KCBhdHRyaWJ1dGUgKTtcblxuXHRcdFx0aWYgKCAhIGNhY2hlZCB8fCBjYWNoZWQudmVyc2lvbiA8IGF0dHJpYnV0ZS52ZXJzaW9uICkge1xuXG5cdFx0XHRcdGJ1ZmZlcnMuc2V0KCBhdHRyaWJ1dGUsIHtcblx0XHRcdFx0XHRidWZmZXI6IGF0dHJpYnV0ZS5idWZmZXIsXG5cdFx0XHRcdFx0dHlwZTogYXR0cmlidXRlLnR5cGUsXG5cdFx0XHRcdFx0Ynl0ZXNQZXJFbGVtZW50OiBhdHRyaWJ1dGUuZWxlbWVudFNpemUsXG5cdFx0XHRcdFx0dmVyc2lvbjogYXR0cmlidXRlLnZlcnNpb25cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGRhdGEgPSBidWZmZXJzLmdldCggYXR0cmlidXRlICk7XG5cblx0XHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0YnVmZmVycy5zZXQoIGF0dHJpYnV0ZSwgY3JlYXRlQnVmZmVyKCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKSApO1xuXG5cdFx0fSBlbHNlIGlmICggZGF0YS52ZXJzaW9uIDwgYXR0cmlidXRlLnZlcnNpb24gKSB7XG5cblx0XHRcdGlmICggZGF0YS5zaXplICE9PSBhdHRyaWJ1dGUuYXJyYXkuYnl0ZUxlbmd0aCApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5XZWJHTEF0dHJpYnV0ZXM6IFRoZSBzaXplIG9mIHRoZSBidWZmZXIgYXR0cmlidXRlXFwncyBhcnJheSBidWZmZXIgZG9lcyBub3QgbWF0Y2ggdGhlIG9yaWdpbmFsIHNpemUuIFJlc2l6aW5nIGJ1ZmZlciBhdHRyaWJ1dGVzIGlzIG5vdCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZUJ1ZmZlciggZGF0YS5idWZmZXIsIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSApO1xuXG5cdFx0XHRkYXRhLnZlcnNpb24gPSBhdHRyaWJ1dGUudmVyc2lvbjtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHtcblxuXHRcdGdldDogZ2V0LFxuXHRcdHJlbW92ZTogcmVtb3ZlLFxuXHRcdHVwZGF0ZTogdXBkYXRlXG5cblx0fTtcblxufVxuXG52YXIgYWxwaGFoYXNoX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FMUEhBSEFTSFxcblxcdGlmICggZGlmZnVzZUNvbG9yLmEgPCBnZXRBbHBoYUhhc2hUaHJlc2hvbGQoIHZQb3NpdGlvbiApICkgZGlzY2FyZDtcXG4jZW5kaWZcIjtcblxudmFyIGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FMUEhBSEFTSFxcblxcdGNvbnN0IGZsb2F0IEFMUEhBX0hBU0hfU0NBTEUgPSAwLjA1O1xcblxcdGZsb2F0IGhhc2gyRCggdmVjMiB2YWx1ZSApIHtcXG5cXHRcXHRyZXR1cm4gZnJhY3QoIDEuMGU0ICogc2luKCAxNy4wICogdmFsdWUueCArIDAuMSAqIHZhbHVlLnkgKSAqICggMC4xICsgYWJzKCBzaW4oIDEzLjAgKiB2YWx1ZS55ICsgdmFsdWUueCApICkgKSApO1xcblxcdH1cXG5cXHRmbG9hdCBoYXNoM0QoIHZlYzMgdmFsdWUgKSB7XFxuXFx0XFx0cmV0dXJuIGhhc2gyRCggdmVjMiggaGFzaDJEKCB2YWx1ZS54eSApLCB2YWx1ZS56ICkgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgZ2V0QWxwaGFIYXNoVGhyZXNob2xkKCB2ZWMzIHBvc2l0aW9uICkge1xcblxcdFxcdGZsb2F0IG1heERlcml2ID0gbWF4KFxcblxcdFxcdFxcdGxlbmd0aCggZEZkeCggcG9zaXRpb24ueHl6ICkgKSxcXG5cXHRcXHRcXHRsZW5ndGgoIGRGZHkoIHBvc2l0aW9uLnh5eiApIClcXG5cXHRcXHQpO1xcblxcdFxcdGZsb2F0IHBpeFNjYWxlID0gMS4wIC8gKCBBTFBIQV9IQVNIX1NDQUxFICogbWF4RGVyaXYgKTtcXG5cXHRcXHR2ZWMyIHBpeFNjYWxlcyA9IHZlYzIoXFxuXFx0XFx0XFx0ZXhwMiggZmxvb3IoIGxvZzIoIHBpeFNjYWxlICkgKSApLFxcblxcdFxcdFxcdGV4cDIoIGNlaWwoIGxvZzIoIHBpeFNjYWxlICkgKSApXFxuXFx0XFx0KTtcXG5cXHRcXHR2ZWMyIGFscGhhID0gdmVjMihcXG5cXHRcXHRcXHRoYXNoM0QoIGZsb29yKCBwaXhTY2FsZXMueCAqIHBvc2l0aW9uLnh5eiApICksXFxuXFx0XFx0XFx0aGFzaDNEKCBmbG9vciggcGl4U2NhbGVzLnkgKiBwb3NpdGlvbi54eXogKSApXFxuXFx0XFx0KTtcXG5cXHRcXHRmbG9hdCBsZXJwRmFjdG9yID0gZnJhY3QoIGxvZzIoIHBpeFNjYWxlICkgKTtcXG5cXHRcXHRmbG9hdCB4ID0gKCAxLjAgLSBsZXJwRmFjdG9yICkgKiBhbHBoYS54ICsgbGVycEZhY3RvciAqIGFscGhhLnk7XFxuXFx0XFx0ZmxvYXQgYSA9IG1pbiggbGVycEZhY3RvciwgMS4wIC0gbGVycEZhY3RvciApO1xcblxcdFxcdHZlYzMgY2FzZXMgPSB2ZWMzKFxcblxcdFxcdFxcdHggKiB4IC8gKCAyLjAgKiBhICogKCAxLjAgLSBhICkgKSxcXG5cXHRcXHRcXHQoIHggLSAwLjUgKiBhICkgLyAoIDEuMCAtIGEgKSxcXG5cXHRcXHRcXHQxLjAgLSAoICggMS4wIC0geCApICogKCAxLjAgLSB4ICkgLyAoIDIuMCAqIGEgKiAoIDEuMCAtIGEgKSApIClcXG5cXHRcXHQpO1xcblxcdFxcdGZsb2F0IHRocmVzaG9sZCA9ICggeCA8ICggMS4wIC0gYSApIClcXG5cXHRcXHRcXHQ/ICggKCB4IDwgYSApID8gY2FzZXMueCA6IGNhc2VzLnkgKVxcblxcdFxcdFxcdDogY2FzZXMuejtcXG5cXHRcXHRyZXR1cm4gY2xhbXAoIHRocmVzaG9sZCAsIDEuMGUtNiwgMS4wICk7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG52YXIgYWxwaGFtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXHRkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB2QWxwaGFNYXBVdiApLmc7XFxuI2VuZGlmXCI7XG5cbnZhciBhbHBoYW1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYWxwaGFNYXA7XFxuI2VuZGlmXCI7XG5cbnZhciBhbHBoYXRlc3RfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQUxQSEFURVNUXFxuXFx0I2lmZGVmIEFMUEhBX1RPX0NPVkVSQUdFXFxuXFx0ZGlmZnVzZUNvbG9yLmEgPSBzbW9vdGhzdGVwKCBhbHBoYVRlc3QsIGFscGhhVGVzdCArIGZ3aWR0aCggZGlmZnVzZUNvbG9yLmEgKSwgZGlmZnVzZUNvbG9yLmEgKTtcXG5cXHRpZiAoIGRpZmZ1c2VDb2xvci5hID09IDAuMCApIGRpc2NhcmQ7XFxuXFx0I2Vsc2VcXG5cXHRpZiAoIGRpZmZ1c2VDb2xvci5hIDwgYWxwaGFUZXN0ICkgZGlzY2FyZDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxudmFyIGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FMUEhBVEVTVFxcblxcdHVuaWZvcm0gZmxvYXQgYWxwaGFUZXN0O1xcbiNlbmRpZlwiO1xuXG52YXIgYW9tYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQU9NQVBcXG5cXHRmbG9hdCBhbWJpZW50T2NjbHVzaW9uID0gKCB0ZXh0dXJlMkQoIGFvTWFwLCB2QW9NYXBVdiApLnIgLSAxLjAgKSAqIGFvTWFwSW50ZW5zaXR5ICsgMS4wO1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBhbWJpZW50T2NjbHVzaW9uO1xcblxcdCNpZiBkZWZpbmVkKCBVU0VfQ0xFQVJDT0FUICkgXFxuXFx0XFx0Y2xlYXJjb2F0U3BlY3VsYXJJbmRpcmVjdCAqPSBhbWJpZW50T2NjbHVzaW9uO1xcblxcdCNlbmRpZlxcblxcdCNpZiBkZWZpbmVkKCBVU0VfU0hFRU4gKSBcXG5cXHRcXHRzaGVlblNwZWN1bGFySW5kaXJlY3QgKj0gYW1iaWVudE9jY2x1c2lvbjtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFNUQU5EQVJEIClcXG5cXHRcXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIgKSApO1xcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKj0gY29tcHV0ZVNwZWN1bGFyT2NjbHVzaW9uKCBkb3ROViwgYW1iaWVudE9jY2x1c2lvbiwgbWF0ZXJpYWwucm91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBhb21hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FPTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYW9NYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBhb01hcEludGVuc2l0eTtcXG4jZW5kaWZcIjtcblxudmFyIGJhdGNoaW5nX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0JBVENISU5HXFxuXFx0I2lmICEgZGVmaW5lZCggR0xfQU5HTEVfbXVsdGlfZHJhdyApXFxuXFx0I2RlZmluZSBnbF9EcmF3SUQgX2dsX0RyYXdJRFxcblxcdHVuaWZvcm0gaW50IF9nbF9EcmF3SUQ7XFxuXFx0I2VuZGlmXFxuXFx0dW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgYmF0Y2hpbmdUZXh0dXJlO1xcblxcdHVuaWZvcm0gaGlnaHAgdXNhbXBsZXIyRCBiYXRjaGluZ0lkVGV4dHVyZTtcXG5cXHRtYXQ0IGdldEJhdGNoaW5nTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcdFxcdGludCBzaXplID0gdGV4dHVyZVNpemUoIGJhdGNoaW5nVGV4dHVyZSwgMCApLng7XFxuXFx0XFx0aW50IGogPSBpbnQoIGkgKSAqIDQ7XFxuXFx0XFx0aW50IHggPSBqICUgc2l6ZTtcXG5cXHRcXHRpbnQgeSA9IGogLyBzaXplO1xcblxcdFxcdHZlYzQgdjEgPSB0ZXhlbEZldGNoKCBiYXRjaGluZ1RleHR1cmUsIGl2ZWMyKCB4LCB5ICksIDAgKTtcXG5cXHRcXHR2ZWM0IHYyID0gdGV4ZWxGZXRjaCggYmF0Y2hpbmdUZXh0dXJlLCBpdmVjMiggeCArIDEsIHkgKSwgMCApO1xcblxcdFxcdHZlYzQgdjMgPSB0ZXhlbEZldGNoKCBiYXRjaGluZ1RleHR1cmUsIGl2ZWMyKCB4ICsgMiwgeSApLCAwICk7XFxuXFx0XFx0dmVjNCB2NCA9IHRleGVsRmV0Y2goIGJhdGNoaW5nVGV4dHVyZSwgaXZlYzIoIHggKyAzLCB5ICksIDAgKTtcXG5cXHRcXHRyZXR1cm4gbWF0NCggdjEsIHYyLCB2MywgdjQgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgZ2V0SW5kaXJlY3RJbmRleCggY29uc3QgaW4gaW50IGkgKSB7XFxuXFx0XFx0aW50IHNpemUgPSB0ZXh0dXJlU2l6ZSggYmF0Y2hpbmdJZFRleHR1cmUsIDAgKS54O1xcblxcdFxcdGludCB4ID0gaSAlIHNpemU7XFxuXFx0XFx0aW50IHkgPSBpIC8gc2l6ZTtcXG5cXHRcXHRyZXR1cm4gZmxvYXQoIHRleGVsRmV0Y2goIGJhdGNoaW5nSWRUZXh0dXJlLCBpdmVjMiggeCwgeSApLCAwICkuciApO1xcblxcdH1cXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0JBVENISU5HX0NPTE9SXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYmF0Y2hpbmdDb2xvclRleHR1cmU7XFxuXFx0dmVjMyBnZXRCYXRjaGluZ0NvbG9yKCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcdFxcdGludCBzaXplID0gdGV4dHVyZVNpemUoIGJhdGNoaW5nQ29sb3JUZXh0dXJlLCAwICkueDtcXG5cXHRcXHRpbnQgaiA9IGludCggaSApO1xcblxcdFxcdGludCB4ID0gaiAlIHNpemU7XFxuXFx0XFx0aW50IHkgPSBqIC8gc2l6ZTtcXG5cXHRcXHRyZXR1cm4gdGV4ZWxGZXRjaCggYmF0Y2hpbmdDb2xvclRleHR1cmUsIGl2ZWMyKCB4LCB5ICksIDAgKS5yZ2I7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG52YXIgYmF0Y2hpbmdfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0JBVENISU5HXFxuXFx0bWF0NCBiYXRjaGluZ01hdHJpeCA9IGdldEJhdGNoaW5nTWF0cml4KCBnZXRJbmRpcmVjdEluZGV4KCBnbF9EcmF3SUQgKSApO1xcbiNlbmRpZlwiO1xuXG52YXIgYmVnaW5fdmVydGV4ID0gXCJ2ZWMzIHRyYW5zZm9ybWVkID0gdmVjMyggcG9zaXRpb24gKTtcXG4jaWZkZWYgVVNFX0FMUEhBSEFTSFxcblxcdHZQb3NpdGlvbiA9IHZlYzMoIHBvc2l0aW9uICk7XFxuI2VuZGlmXCI7XG5cbnZhciBiZWdpbm5vcm1hbF92ZXJ0ZXggPSBcInZlYzMgb2JqZWN0Tm9ybWFsID0gdmVjMyggbm9ybWFsICk7XFxuI2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0dmVjMyBvYmplY3RUYW5nZW50ID0gdmVjMyggdGFuZ2VudC54eXogKTtcXG4jZW5kaWZcIjtcblxudmFyIGJzZGZzID0gXCJmbG9hdCBHX0JsaW5uUGhvbmdfSW1wbGljaXQoICkge1xcblxcdHJldHVybiAwLjI1O1xcbn1cXG5mbG9hdCBEX0JsaW5uUGhvbmcoIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcywgY29uc3QgaW4gZmxvYXQgZG90TkggKSB7XFxuXFx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiAoIHNoaW5pbmVzcyAqIDAuNSArIDEuMCApICogcG93KCBkb3ROSCwgc2hpbmluZXNzICk7XFxufVxcbnZlYzMgQlJERl9CbGlublBob25nKCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcyApIHtcXG5cXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGxpZ2h0RGlyICsgdmlld0RpciApO1xcblxcdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoYWxmRGlyICkgKTtcXG5cXHRmbG9hdCBkb3RWSCA9IHNhdHVyYXRlKCBkb3QoIHZpZXdEaXIsIGhhbGZEaXIgKSApO1xcblxcdHZlYzMgRiA9IEZfU2NobGljayggc3BlY3VsYXJDb2xvciwgMS4wLCBkb3RWSCApO1xcblxcdGZsb2F0IEcgPSBHX0JsaW5uUGhvbmdfSW1wbGljaXQoICk7XFxuXFx0ZmxvYXQgRCA9IERfQmxpbm5QaG9uZyggc2hpbmluZXNzLCBkb3ROSCApO1xcblxcdHJldHVybiBGICogKCBHICogRCApO1xcbn0gLy8gdmFsaWRhdGVkXCI7XG5cbnZhciBpcmlkZXNjZW5jZV9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9JUklERVNDRU5DRVxcblxcdGNvbnN0IG1hdDMgWFlaX1RPX1JFQzcwOSA9IG1hdDMoXFxuXFx0XFx0IDMuMjQwNDU0MiwgLTAuOTY5MjY2MCwgIDAuMDU1NjQzNCxcXG5cXHRcXHQtMS41MzcxMzg1LCAgMS44NzYwMTA4LCAtMC4yMDQwMjU5LFxcblxcdFxcdC0wLjQ5ODUzMTQsICAwLjA0MTU1NjAsICAxLjA1NzIyNTJcXG5cXHQpO1xcblxcdHZlYzMgRnJlc25lbDBUb0lvciggdmVjMyBmcmVzbmVsMCApIHtcXG5cXHRcXHR2ZWMzIHNxcnRGMCA9IHNxcnQoIGZyZXNuZWwwICk7XFxuXFx0XFx0cmV0dXJuICggdmVjMyggMS4wICkgKyBzcXJ0RjAgKSAvICggdmVjMyggMS4wICkgLSBzcXJ0RjAgKTtcXG5cXHR9XFxuXFx0dmVjMyBJb3JUb0ZyZXNuZWwwKCB2ZWMzIHRyYW5zbWl0dGVkSW9yLCBmbG9hdCBpbmNpZGVudElvciApIHtcXG5cXHRcXHRyZXR1cm4gcG93MiggKCB0cmFuc21pdHRlZElvciAtIHZlYzMoIGluY2lkZW50SW9yICkgKSAvICggdHJhbnNtaXR0ZWRJb3IgKyB2ZWMzKCBpbmNpZGVudElvciApICkgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgSW9yVG9GcmVzbmVsMCggZmxvYXQgdHJhbnNtaXR0ZWRJb3IsIGZsb2F0IGluY2lkZW50SW9yICkge1xcblxcdFxcdHJldHVybiBwb3cyKCAoIHRyYW5zbWl0dGVkSW9yIC0gaW5jaWRlbnRJb3IgKSAvICggdHJhbnNtaXR0ZWRJb3IgKyBpbmNpZGVudElvciApKTtcXG5cXHR9XFxuXFx0dmVjMyBldmFsU2Vuc2l0aXZpdHkoIGZsb2F0IE9QRCwgdmVjMyBzaGlmdCApIHtcXG5cXHRcXHRmbG9hdCBwaGFzZSA9IDIuMCAqIFBJICogT1BEICogMS4wZS05O1xcblxcdFxcdHZlYzMgdmFsID0gdmVjMyggNS40ODU2ZS0xMywgNC40MjAxZS0xMywgNS4yNDgxZS0xMyApO1xcblxcdFxcdHZlYzMgcG9zID0gdmVjMyggMS42ODEwZSswNiwgMS43OTUzZSswNiwgMi4yMDg0ZSswNiApO1xcblxcdFxcdHZlYzMgdmFyID0gdmVjMyggNC4zMjc4ZSswOSwgOS4zMDQ2ZSswOSwgNi42MTIxZSswOSApO1xcblxcdFxcdHZlYzMgeHl6ID0gdmFsICogc3FydCggMi4wICogUEkgKiB2YXIgKSAqIGNvcyggcG9zICogcGhhc2UgKyBzaGlmdCApICogZXhwKCAtIHBvdzIoIHBoYXNlICkgKiB2YXIgKTtcXG5cXHRcXHR4eXoueCArPSA5Ljc0NzBlLTE0ICogc3FydCggMi4wICogUEkgKiA0LjUyODJlKzA5ICkgKiBjb3MoIDIuMjM5OWUrMDYgKiBwaGFzZSArIHNoaWZ0WyAwIF0gKSAqIGV4cCggLSA0LjUyODJlKzA5ICogcG93MiggcGhhc2UgKSApO1xcblxcdFxcdHh5eiAvPSAxLjA2ODVlLTc7XFxuXFx0XFx0dmVjMyByZ2IgPSBYWVpfVE9fUkVDNzA5ICogeHl6O1xcblxcdFxcdHJldHVybiByZ2I7XFxuXFx0fVxcblxcdHZlYzMgZXZhbElyaWRlc2NlbmNlKCBmbG9hdCBvdXRzaWRlSU9SLCBmbG9hdCBldGEyLCBmbG9hdCBjb3NUaGV0YTEsIGZsb2F0IHRoaW5GaWxtVGhpY2tuZXNzLCB2ZWMzIGJhc2VGMCApIHtcXG5cXHRcXHR2ZWMzIEk7XFxuXFx0XFx0ZmxvYXQgaXJpZGVzY2VuY2VJT1IgPSBtaXgoIG91dHNpZGVJT1IsIGV0YTIsIHNtb290aHN0ZXAoIDAuMCwgMC4wMywgdGhpbkZpbG1UaGlja25lc3MgKSApO1xcblxcdFxcdGZsb2F0IHNpblRoZXRhMlNxID0gcG93Miggb3V0c2lkZUlPUiAvIGlyaWRlc2NlbmNlSU9SICkgKiAoIDEuMCAtIHBvdzIoIGNvc1RoZXRhMSApICk7XFxuXFx0XFx0ZmxvYXQgY29zVGhldGEyU3EgPSAxLjAgLSBzaW5UaGV0YTJTcTtcXG5cXHRcXHRpZiAoIGNvc1RoZXRhMlNxIDwgMC4wICkge1xcblxcdFxcdFxcdHJldHVybiB2ZWMzKCAxLjAgKTtcXG5cXHRcXHR9XFxuXFx0XFx0ZmxvYXQgY29zVGhldGEyID0gc3FydCggY29zVGhldGEyU3EgKTtcXG5cXHRcXHRmbG9hdCBSMCA9IElvclRvRnJlc25lbDAoIGlyaWRlc2NlbmNlSU9SLCBvdXRzaWRlSU9SICk7XFxuXFx0XFx0ZmxvYXQgUjEyID0gRl9TY2hsaWNrKCBSMCwgMS4wLCBjb3NUaGV0YTEgKTtcXG5cXHRcXHRmbG9hdCBUMTIxID0gMS4wIC0gUjEyO1xcblxcdFxcdGZsb2F0IHBoaTEyID0gMC4wO1xcblxcdFxcdGlmICggaXJpZGVzY2VuY2VJT1IgPCBvdXRzaWRlSU9SICkgcGhpMTIgPSBQSTtcXG5cXHRcXHRmbG9hdCBwaGkyMSA9IFBJIC0gcGhpMTI7XFxuXFx0XFx0dmVjMyBiYXNlSU9SID0gRnJlc25lbDBUb0lvciggY2xhbXAoIGJhc2VGMCwgMC4wLCAwLjk5OTkgKSApO1xcdFxcdHZlYzMgUjEgPSBJb3JUb0ZyZXNuZWwwKCBiYXNlSU9SLCBpcmlkZXNjZW5jZUlPUiApO1xcblxcdFxcdHZlYzMgUjIzID0gRl9TY2hsaWNrKCBSMSwgMS4wLCBjb3NUaGV0YTIgKTtcXG5cXHRcXHR2ZWMzIHBoaTIzID0gdmVjMyggMC4wICk7XFxuXFx0XFx0aWYgKCBiYXNlSU9SWyAwIF0gPCBpcmlkZXNjZW5jZUlPUiApIHBoaTIzWyAwIF0gPSBQSTtcXG5cXHRcXHRpZiAoIGJhc2VJT1JbIDEgXSA8IGlyaWRlc2NlbmNlSU9SICkgcGhpMjNbIDEgXSA9IFBJO1xcblxcdFxcdGlmICggYmFzZUlPUlsgMiBdIDwgaXJpZGVzY2VuY2VJT1IgKSBwaGkyM1sgMiBdID0gUEk7XFxuXFx0XFx0ZmxvYXQgT1BEID0gMi4wICogaXJpZGVzY2VuY2VJT1IgKiB0aGluRmlsbVRoaWNrbmVzcyAqIGNvc1RoZXRhMjtcXG5cXHRcXHR2ZWMzIHBoaSA9IHZlYzMoIHBoaTIxICkgKyBwaGkyMztcXG5cXHRcXHR2ZWMzIFIxMjMgPSBjbGFtcCggUjEyICogUjIzLCAxZS01LCAwLjk5OTkgKTtcXG5cXHRcXHR2ZWMzIHIxMjMgPSBzcXJ0KCBSMTIzICk7XFxuXFx0XFx0dmVjMyBScyA9IHBvdzIoIFQxMjEgKSAqIFIyMyAvICggdmVjMyggMS4wICkgLSBSMTIzICk7XFxuXFx0XFx0dmVjMyBDMCA9IFIxMiArIFJzO1xcblxcdFxcdEkgPSBDMDtcXG5cXHRcXHR2ZWMzIENtID0gUnMgLSBUMTIxO1xcblxcdFxcdGZvciAoIGludCBtID0gMTsgbSA8PSAyOyArKyBtICkge1xcblxcdFxcdFxcdENtICo9IHIxMjM7XFxuXFx0XFx0XFx0dmVjMyBTbSA9IDIuMCAqIGV2YWxTZW5zaXRpdml0eSggZmxvYXQoIG0gKSAqIE9QRCwgZmxvYXQoIG0gKSAqIHBoaSApO1xcblxcdFxcdFxcdEkgKz0gQ20gKiBTbTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIG1heCggSSwgdmVjMyggMC4wICkgKTtcXG5cXHR9XFxuI2VuZGlmXCI7XG5cbnZhciBidW1wbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQlVNUE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGJ1bXBNYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBidW1wU2NhbGU7XFxuXFx0dmVjMiBkSGR4eV9md2QoKSB7XFxuXFx0XFx0dmVjMiBkU1RkeCA9IGRGZHgoIHZCdW1wTWFwVXYgKTtcXG5cXHRcXHR2ZWMyIGRTVGR5ID0gZEZkeSggdkJ1bXBNYXBVdiApO1xcblxcdFxcdGZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdkJ1bXBNYXBVdiApLng7XFxuXFx0XFx0ZmxvYXQgZEJ4ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2QnVtcE1hcFV2ICsgZFNUZHggKS54IC0gSGxsO1xcblxcdFxcdGZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdkJ1bXBNYXBVdiArIGRTVGR5ICkueCAtIEhsbDtcXG5cXHRcXHRyZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTtcXG5cXHR9XFxuXFx0dmVjMyBwZXJ0dXJiTm9ybWFsQXJiKCB2ZWMzIHN1cmZfcG9zLCB2ZWMzIHN1cmZfbm9ybSwgdmVjMiBkSGR4eSwgZmxvYXQgZmFjZURpcmVjdGlvbiApIHtcXG5cXHRcXHR2ZWMzIHZTaWdtYVggPSBub3JtYWxpemUoIGRGZHgoIHN1cmZfcG9zLnh5eiApICk7XFxuXFx0XFx0dmVjMyB2U2lnbWFZID0gbm9ybWFsaXplKCBkRmR5KCBzdXJmX3Bvcy54eXogKSApO1xcblxcdFxcdHZlYzMgdk4gPSBzdXJmX25vcm07XFxuXFx0XFx0dmVjMyBSMSA9IGNyb3NzKCB2U2lnbWFZLCB2TiApO1xcblxcdFxcdHZlYzMgUjIgPSBjcm9zcyggdk4sIHZTaWdtYVggKTtcXG5cXHRcXHRmbG9hdCBmRGV0ID0gZG90KCB2U2lnbWFYLCBSMSApICogZmFjZURpcmVjdGlvbjtcXG5cXHRcXHR2ZWMzIHZHcmFkID0gc2lnbiggZkRldCApICogKCBkSGR4eS54ICogUjEgKyBkSGR4eS55ICogUjIgKTtcXG5cXHRcXHRyZXR1cm4gbm9ybWFsaXplKCBhYnMoIGZEZXQgKSAqIHN1cmZfbm9ybSAtIHZHcmFkICk7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG52YXIgY2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXG5cXHR2ZWM0IHBsYW5lO1xcblxcdCNpZmRlZiBBTFBIQV9UT19DT1ZFUkFHRVxcblxcdFxcdGZsb2F0IGRpc3RhbmNlVG9QbGFuZSwgZGlzdGFuY2VHcmFkaWVudDtcXG5cXHRcXHRmbG9hdCBjbGlwT3BhY2l0eSA9IDEuMDtcXG5cXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0XFx0Zm9yICggaW50IGkgPSAwOyBpIDwgVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpICsrICkge1xcblxcdFxcdFxcdHBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTtcXG5cXHRcXHRcXHRkaXN0YW5jZVRvUGxhbmUgPSAtIGRvdCggdkNsaXBQb3NpdGlvbiwgcGxhbmUueHl6ICkgKyBwbGFuZS53O1xcblxcdFxcdFxcdGRpc3RhbmNlR3JhZGllbnQgPSBmd2lkdGgoIGRpc3RhbmNlVG9QbGFuZSApIC8gMi4wO1xcblxcdFxcdFxcdGNsaXBPcGFjaXR5ICo9IHNtb290aHN0ZXAoIC0gZGlzdGFuY2VHcmFkaWVudCwgZGlzdGFuY2VHcmFkaWVudCwgZGlzdGFuY2VUb1BsYW5lICk7XFxuXFx0XFx0XFx0aWYgKCBjbGlwT3BhY2l0eSA9PSAwLjAgKSBkaXNjYXJkO1xcblxcdFxcdH1cXG5cXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdFxcdCNpZiBVTklPTl9DTElQUElOR19QTEFORVMgPCBOVU1fQ0xJUFBJTkdfUExBTkVTXFxuXFx0XFx0XFx0ZmxvYXQgdW5pb25DbGlwT3BhY2l0eSA9IDEuMDtcXG5cXHRcXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0XFx0XFx0Zm9yICggaW50IGkgPSBVTklPTl9DTElQUElOR19QTEFORVM7IGkgPCBOVU1fQ0xJUFBJTkdfUExBTkVTOyBpICsrICkge1xcblxcdFxcdFxcdFxcdHBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTtcXG5cXHRcXHRcXHRcXHRkaXN0YW5jZVRvUGxhbmUgPSAtIGRvdCggdkNsaXBQb3NpdGlvbiwgcGxhbmUueHl6ICkgKyBwbGFuZS53O1xcblxcdFxcdFxcdFxcdGRpc3RhbmNlR3JhZGllbnQgPSBmd2lkdGgoIGRpc3RhbmNlVG9QbGFuZSApIC8gMi4wO1xcblxcdFxcdFxcdFxcdHVuaW9uQ2xpcE9wYWNpdHkgKj0gMS4wIC0gc21vb3Roc3RlcCggLSBkaXN0YW5jZUdyYWRpZW50LCBkaXN0YW5jZUdyYWRpZW50LCBkaXN0YW5jZVRvUGxhbmUgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHRcXHRcXHRjbGlwT3BhY2l0eSAqPSAxLjAgLSB1bmlvbkNsaXBPcGFjaXR5O1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdGRpZmZ1c2VDb2xvci5hICo9IGNsaXBPcGFjaXR5O1xcblxcdFxcdGlmICggZGlmZnVzZUNvbG9yLmEgPT0gMC4wICkgZGlzY2FyZDtcXG5cXHQjZWxzZVxcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBVTklPTl9DTElQUElOR19QTEFORVM7IGkgKysgKSB7XFxuXFx0XFx0XFx0cGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdO1xcblxcdFxcdFxcdGlmICggZG90KCB2Q2xpcFBvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSBkaXNjYXJkO1xcblxcdFxcdH1cXG5cXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdFxcdCNpZiBVTklPTl9DTElQUElOR19QTEFORVMgPCBOVU1fQ0xJUFBJTkdfUExBTkVTXFxuXFx0XFx0XFx0Ym9vbCBjbGlwcGVkID0gdHJ1ZTtcXG5cXHRcXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0XFx0XFx0Zm9yICggaW50IGkgPSBVTklPTl9DTElQUElOR19QTEFORVM7IGkgPCBOVU1fQ0xJUFBJTkdfUExBTkVTOyBpICsrICkge1xcblxcdFxcdFxcdFxcdHBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTtcXG5cXHRcXHRcXHRcXHRjbGlwcGVkID0gKCBkb3QoIHZDbGlwUG9zaXRpb24sIHBsYW5lLnh5eiApID4gcGxhbmUudyApICYmIGNsaXBwZWQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0XFx0XFx0aWYgKCBjbGlwcGVkICkgZGlzY2FyZDtcXG5cXHRcXHQjZW5kaWZcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxudmFyIGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXG5cXHR2YXJ5aW5nIHZlYzMgdkNsaXBQb3NpdGlvbjtcXG5cXHR1bmlmb3JtIHZlYzQgY2xpcHBpbmdQbGFuZXNbIE5VTV9DTElQUElOR19QTEFORVMgXTtcXG4jZW5kaWZcIjtcblxudmFyIGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleCA9IFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXFxuXFx0dmFyeWluZyB2ZWMzIHZDbGlwUG9zaXRpb247XFxuI2VuZGlmXCI7XG5cbnZhciBjbGlwcGluZ19wbGFuZXNfdmVydGV4ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXG5cXHR2Q2xpcFBvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG4jZW5kaWZcIjtcblxudmFyIGNvbG9yX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBIClcXG5cXHRkaWZmdXNlQ29sb3IgKj0gdkNvbG9yO1xcbiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApXFxuXFx0ZGlmZnVzZUNvbG9yLnJnYiAqPSB2Q29sb3I7XFxuI2VuZGlmXCI7XG5cbnZhciBjb2xvcl9wYXJzX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBIClcXG5cXHR2YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApXFxuXFx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG4jZW5kaWZcIjtcblxudmFyIGNvbG9yX3BhcnNfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBIClcXG5cXHR2YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApIHx8IGRlZmluZWQoIFVTRV9JTlNUQU5DSU5HX0NPTE9SICkgfHwgZGVmaW5lZCggVVNFX0JBVENISU5HX0NPTE9SIClcXG5cXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbiNlbmRpZlwiO1xuXG52YXIgY29sb3JfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBIClcXG5cXHR2Q29sb3IgPSB2ZWM0KCAxLjAgKTtcXG4jZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKSB8fCBkZWZpbmVkKCBVU0VfSU5TVEFOQ0lOR19DT0xPUiApIHx8IGRlZmluZWQoIFVTRV9CQVRDSElOR19DT0xPUiApXFxuXFx0dkNvbG9yID0gdmVjMyggMS4wICk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DT0xPUlxcblxcdHZDb2xvciAqPSBjb2xvcjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0lOU1RBTkNJTkdfQ09MT1JcXG5cXHR2Q29sb3IueHl6ICo9IGluc3RhbmNlQ29sb3IueHl6O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQkFUQ0hJTkdfQ09MT1JcXG5cXHR2ZWMzIGJhdGNoaW5nQ29sb3IgPSBnZXRCYXRjaGluZ0NvbG9yKCBnZXRJbmRpcmVjdEluZGV4KCBnbF9EcmF3SUQgKSApO1xcblxcdHZDb2xvci54eXogKj0gYmF0Y2hpbmdDb2xvci54eXo7XFxuI2VuZGlmXCI7XG5cbnZhciBjb21tb24gPSBcIiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODk3OTNcXG4jZGVmaW5lIFBJMiA2LjI4MzE4NTMwNzE3OTU4NlxcbiNkZWZpbmUgUElfSEFMRiAxLjU3MDc5NjMyNjc5NDg5NjZcXG4jZGVmaW5lIFJFQ0lQUk9DQUxfUEkgMC4zMTgzMDk4ODYxODM3OTA3XFxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJMiAwLjE1OTE1NDk0MzA5MTg5NTM1XFxuI2RlZmluZSBFUFNJTE9OIDFlLTZcXG4jaWZuZGVmIHNhdHVyYXRlXFxuI2RlZmluZSBzYXR1cmF0ZSggYSApIGNsYW1wKCBhLCAwLjAsIDEuMCApXFxuI2VuZGlmXFxuI2RlZmluZSB3aGl0ZUNvbXBsZW1lbnQoIGEgKSAoIDEuMCAtIHNhdHVyYXRlKCBhICkgKVxcbmZsb2F0IHBvdzIoIGNvbnN0IGluIGZsb2F0IHggKSB7IHJldHVybiB4Kng7IH1cXG52ZWMzIHBvdzIoIGNvbnN0IGluIHZlYzMgeCApIHsgcmV0dXJuIHgqeDsgfVxcbmZsb2F0IHBvdzMoIGNvbnN0IGluIGZsb2F0IHggKSB7IHJldHVybiB4KngqeDsgfVxcbmZsb2F0IHBvdzQoIGNvbnN0IGluIGZsb2F0IHggKSB7IGZsb2F0IHgyID0geCp4OyByZXR1cm4geDIqeDI7IH1cXG5mbG9hdCBtYXgzKCBjb25zdCBpbiB2ZWMzIHYgKSB7IHJldHVybiBtYXgoIG1heCggdi54LCB2LnkgKSwgdi56ICk7IH1cXG5mbG9hdCBhdmVyYWdlKCBjb25zdCBpbiB2ZWMzIHYgKSB7IHJldHVybiBkb3QoIHYsIHZlYzMoIDAuMzMzMzMzMyApICk7IH1cXG5oaWdocCBmbG9hdCByYW5kKCBjb25zdCBpbiB2ZWMyIHV2ICkge1xcblxcdGNvbnN0IGhpZ2hwIGZsb2F0IGEgPSAxMi45ODk4LCBiID0gNzguMjMzLCBjID0gNDM3NTguNTQ1MztcXG5cXHRoaWdocCBmbG9hdCBkdCA9IGRvdCggdXYueHksIHZlYzIoIGEsYiApICksIHNuID0gbW9kKCBkdCwgUEkgKTtcXG5cXHRyZXR1cm4gZnJhY3QoIHNpbiggc24gKSAqIGMgKTtcXG59XFxuI2lmZGVmIEhJR0hfUFJFQ0lTSU9OXFxuXFx0ZmxvYXQgcHJlY2lzaW9uU2FmZUxlbmd0aCggdmVjMyB2ICkgeyByZXR1cm4gbGVuZ3RoKCB2ICk7IH1cXG4jZWxzZVxcblxcdGZsb2F0IHByZWNpc2lvblNhZmVMZW5ndGgoIHZlYzMgdiApIHtcXG5cXHRcXHRmbG9hdCBtYXhDb21wb25lbnQgPSBtYXgzKCBhYnMoIHYgKSApO1xcblxcdFxcdHJldHVybiBsZW5ndGgoIHYgLyBtYXhDb21wb25lbnQgKSAqIG1heENvbXBvbmVudDtcXG5cXHR9XFxuI2VuZGlmXFxuc3RydWN0IEluY2lkZW50TGlnaHQge1xcblxcdHZlYzMgY29sb3I7XFxuXFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0Ym9vbCB2aXNpYmxlO1xcbn07XFxuc3RydWN0IFJlZmxlY3RlZExpZ2h0IHtcXG5cXHR2ZWMzIGRpcmVjdERpZmZ1c2U7XFxuXFx0dmVjMyBkaXJlY3RTcGVjdWxhcjtcXG5cXHR2ZWMzIGluZGlyZWN0RGlmZnVzZTtcXG5cXHR2ZWMzIGluZGlyZWN0U3BlY3VsYXI7XFxufTtcXG4jaWZkZWYgVVNFX0FMUEhBSEFTSFxcblxcdHZhcnlpbmcgdmVjMyB2UG9zaXRpb247XFxuI2VuZGlmXFxudmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHtcXG5cXHRyZXR1cm4gbm9ybWFsaXplKCAoIG1hdHJpeCAqIHZlYzQoIGRpciwgMC4wICkgKS54eXogKTtcXG59XFxudmVjMyBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFx0cmV0dXJuIG5vcm1hbGl6ZSggKCB2ZWM0KCBkaXIsIDAuMCApICogbWF0cml4ICkueHl6ICk7XFxufVxcbm1hdDMgdHJhbnNwb3NlTWF0MyggY29uc3QgaW4gbWF0MyBtICkge1xcblxcdG1hdDMgdG1wO1xcblxcdHRtcFsgMCBdID0gdmVjMyggbVsgMCBdLngsIG1bIDEgXS54LCBtWyAyIF0ueCApO1xcblxcdHRtcFsgMSBdID0gdmVjMyggbVsgMCBdLnksIG1bIDEgXS55LCBtWyAyIF0ueSApO1xcblxcdHRtcFsgMiBdID0gdmVjMyggbVsgMCBdLnosIG1bIDEgXS56LCBtWyAyIF0ueiApO1xcblxcdHJldHVybiB0bXA7XFxufVxcbmJvb2wgaXNQZXJzcGVjdGl2ZU1hdHJpeCggbWF0NCBtICkge1xcblxcdHJldHVybiBtWyAyIF1bIDMgXSA9PSAtIDEuMDtcXG59XFxudmVjMiBlcXVpcmVjdFV2KCBpbiB2ZWMzIGRpciApIHtcXG5cXHRmbG9hdCB1ID0gYXRhbiggZGlyLnosIGRpci54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcXG5cXHRmbG9hdCB2ID0gYXNpbiggY2xhbXAoIGRpci55LCAtIDEuMCwgMS4wICkgKSAqIFJFQ0lQUk9DQUxfUEkgKyAwLjU7XFxuXFx0cmV0dXJuIHZlYzIoIHUsIHYgKTtcXG59XFxudmVjMyBCUkRGX0xhbWJlcnQoIGNvbnN0IGluIHZlYzMgZGlmZnVzZUNvbG9yICkge1xcblxcdHJldHVybiBSRUNJUFJPQ0FMX1BJICogZGlmZnVzZUNvbG9yO1xcbn1cXG52ZWMzIEZfU2NobGljayggY29uc3QgaW4gdmVjMyBmMCwgY29uc3QgaW4gZmxvYXQgZjkwLCBjb25zdCBpbiBmbG9hdCBkb3RWSCApIHtcXG5cXHRmbG9hdCBmcmVzbmVsID0gZXhwMiggKCAtIDUuNTU0NzMgKiBkb3RWSCAtIDYuOTgzMTYgKSAqIGRvdFZIICk7XFxuXFx0cmV0dXJuIGYwICogKCAxLjAgLSBmcmVzbmVsICkgKyAoIGY5MCAqIGZyZXNuZWwgKTtcXG59XFxuZmxvYXQgRl9TY2hsaWNrKCBjb25zdCBpbiBmbG9hdCBmMCwgY29uc3QgaW4gZmxvYXQgZjkwLCBjb25zdCBpbiBmbG9hdCBkb3RWSCApIHtcXG5cXHRmbG9hdCBmcmVzbmVsID0gZXhwMiggKCAtIDUuNTU0NzMgKiBkb3RWSCAtIDYuOTgzMTYgKSAqIGRvdFZIICk7XFxuXFx0cmV0dXJuIGYwICogKCAxLjAgLSBmcmVzbmVsICkgKyAoIGY5MCAqIGZyZXNuZWwgKTtcXG59IC8vIHZhbGlkYXRlZFwiO1xuXG52YXIgY3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50ID0gXCIjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRV9VVlxcblxcdCNkZWZpbmUgY3ViZVVWX21pbk1pcExldmVsIDQuMFxcblxcdCNkZWZpbmUgY3ViZVVWX21pblRpbGVTaXplIDE2LjBcXG5cXHRmbG9hdCBnZXRGYWNlKCB2ZWMzIGRpcmVjdGlvbiApIHtcXG5cXHRcXHR2ZWMzIGFic0RpcmVjdGlvbiA9IGFicyggZGlyZWN0aW9uICk7XFxuXFx0XFx0ZmxvYXQgZmFjZSA9IC0gMS4wO1xcblxcdFxcdGlmICggYWJzRGlyZWN0aW9uLnggPiBhYnNEaXJlY3Rpb24ueiApIHtcXG5cXHRcXHRcXHRpZiAoIGFic0RpcmVjdGlvbi54ID4gYWJzRGlyZWN0aW9uLnkgKVxcblxcdFxcdFxcdFxcdGZhY2UgPSBkaXJlY3Rpb24ueCA+IDAuMCA/IDAuMCA6IDMuMDtcXG5cXHRcXHRcXHRlbHNlXFxuXFx0XFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi55ID4gMC4wID8gMS4wIDogNC4wO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0aWYgKCBhYnNEaXJlY3Rpb24ueiA+IGFic0RpcmVjdGlvbi55IClcXG5cXHRcXHRcXHRcXHRmYWNlID0gZGlyZWN0aW9uLnogPiAwLjAgPyAyLjAgOiA1LjA7XFxuXFx0XFx0XFx0ZWxzZVxcblxcdFxcdFxcdFxcdGZhY2UgPSBkaXJlY3Rpb24ueSA+IDAuMCA/IDEuMCA6IDQuMDtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIGZhY2U7XFxuXFx0fVxcblxcdHZlYzIgZ2V0VVYoIHZlYzMgZGlyZWN0aW9uLCBmbG9hdCBmYWNlICkge1xcblxcdFxcdHZlYzIgdXY7XFxuXFx0XFx0aWYgKCBmYWNlID09IDAuMCApIHtcXG5cXHRcXHRcXHR1diA9IHZlYzIoIGRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueSApIC8gYWJzKCBkaXJlY3Rpb24ueCApO1xcblxcdFxcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMS4wICkge1xcblxcdFxcdFxcdHV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueCwgLSBkaXJlY3Rpb24ueiApIC8gYWJzKCBkaXJlY3Rpb24ueSApO1xcblxcdFxcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMi4wICkge1xcblxcdFxcdFxcdHV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnogKTtcXG5cXHRcXHR9IGVsc2UgaWYgKCBmYWNlID09IDMuMCApIHtcXG5cXHRcXHRcXHR1diA9IHZlYzIoIC0gZGlyZWN0aW9uLnosIGRpcmVjdGlvbi55ICkgLyBhYnMoIGRpcmVjdGlvbi54ICk7XFxuXFx0XFx0fSBlbHNlIGlmICggZmFjZSA9PSA0LjAgKSB7XFxuXFx0XFx0XFx0dXYgPSB2ZWMyKCAtIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueiApIC8gYWJzKCBkaXJlY3Rpb24ueSApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0dXYgPSB2ZWMyKCBkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnogKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIDAuNSAqICggdXYgKyAxLjAgKTtcXG5cXHR9XFxuXFx0dmVjMyBiaWxpbmVhckN1YmVVViggc2FtcGxlcjJEIGVudk1hcCwgdmVjMyBkaXJlY3Rpb24sIGZsb2F0IG1pcEludCApIHtcXG5cXHRcXHRmbG9hdCBmYWNlID0gZ2V0RmFjZSggZGlyZWN0aW9uICk7XFxuXFx0XFx0ZmxvYXQgZmlsdGVySW50ID0gbWF4KCBjdWJlVVZfbWluTWlwTGV2ZWwgLSBtaXBJbnQsIDAuMCApO1xcblxcdFxcdG1pcEludCA9IG1heCggbWlwSW50LCBjdWJlVVZfbWluTWlwTGV2ZWwgKTtcXG5cXHRcXHRmbG9hdCBmYWNlU2l6ZSA9IGV4cDIoIG1pcEludCApO1xcblxcdFxcdGhpZ2hwIHZlYzIgdXYgPSBnZXRVViggZGlyZWN0aW9uLCBmYWNlICkgKiAoIGZhY2VTaXplIC0gMi4wICkgKyAxLjA7XFxuXFx0XFx0aWYgKCBmYWNlID4gMi4wICkge1xcblxcdFxcdFxcdHV2LnkgKz0gZmFjZVNpemU7XFxuXFx0XFx0XFx0ZmFjZSAtPSAzLjA7XFxuXFx0XFx0fVxcblxcdFxcdHV2LnggKz0gZmFjZSAqIGZhY2VTaXplO1xcblxcdFxcdHV2LnggKz0gZmlsdGVySW50ICogMy4wICogY3ViZVVWX21pblRpbGVTaXplO1xcblxcdFxcdHV2LnkgKz0gNC4wICogKCBleHAyKCBDVUJFVVZfTUFYX01JUCApIC0gZmFjZVNpemUgKTtcXG5cXHRcXHR1di54ICo9IENVQkVVVl9URVhFTF9XSURUSDtcXG5cXHRcXHR1di55ICo9IENVQkVVVl9URVhFTF9IRUlHSFQ7XFxuXFx0XFx0I2lmZGVmIHRleHR1cmUyREdyYWRFWFRcXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZTJER3JhZEVYVCggZW52TWFwLCB1diwgdmVjMiggMC4wICksIHZlYzIoIDAuMCApICkucmdiO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmUyRCggZW52TWFwLCB1diApLnJnYjtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuXFx0I2RlZmluZSBjdWJlVVZfcjAgMS4wXFxuXFx0I2RlZmluZSBjdWJlVVZfbTAgLSAyLjBcXG5cXHQjZGVmaW5lIGN1YmVVVl9yMSAwLjhcXG5cXHQjZGVmaW5lIGN1YmVVVl9tMSAtIDEuMFxcblxcdCNkZWZpbmUgY3ViZVVWX3I0IDAuNFxcblxcdCNkZWZpbmUgY3ViZVVWX200IDIuMFxcblxcdCNkZWZpbmUgY3ViZVVWX3I1IDAuMzA1XFxuXFx0I2RlZmluZSBjdWJlVVZfbTUgMy4wXFxuXFx0I2RlZmluZSBjdWJlVVZfcjYgMC4yMVxcblxcdCNkZWZpbmUgY3ViZVVWX202IDQuMFxcblxcdGZsb2F0IHJvdWdobmVzc1RvTWlwKCBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0XFx0ZmxvYXQgbWlwID0gMC4wO1xcblxcdFxcdGlmICggcm91Z2huZXNzID49IGN1YmVVVl9yMSApIHtcXG5cXHRcXHRcXHRtaXAgPSAoIGN1YmVVVl9yMCAtIHJvdWdobmVzcyApICogKCBjdWJlVVZfbTEgLSBjdWJlVVZfbTAgKSAvICggY3ViZVVWX3IwIC0gY3ViZVVWX3IxICkgKyBjdWJlVVZfbTA7XFxuXFx0XFx0fSBlbHNlIGlmICggcm91Z2huZXNzID49IGN1YmVVVl9yNCApIHtcXG5cXHRcXHRcXHRtaXAgPSAoIGN1YmVVVl9yMSAtIHJvdWdobmVzcyApICogKCBjdWJlVVZfbTQgLSBjdWJlVVZfbTEgKSAvICggY3ViZVVWX3IxIC0gY3ViZVVWX3I0ICkgKyBjdWJlVVZfbTE7XFxuXFx0XFx0fSBlbHNlIGlmICggcm91Z2huZXNzID49IGN1YmVVVl9yNSApIHtcXG5cXHRcXHRcXHRtaXAgPSAoIGN1YmVVVl9yNCAtIHJvdWdobmVzcyApICogKCBjdWJlVVZfbTUgLSBjdWJlVVZfbTQgKSAvICggY3ViZVVWX3I0IC0gY3ViZVVWX3I1ICkgKyBjdWJlVVZfbTQ7XFxuXFx0XFx0fSBlbHNlIGlmICggcm91Z2huZXNzID49IGN1YmVVVl9yNiApIHtcXG5cXHRcXHRcXHRtaXAgPSAoIGN1YmVVVl9yNSAtIHJvdWdobmVzcyApICogKCBjdWJlVVZfbTYgLSBjdWJlVVZfbTUgKSAvICggY3ViZVVWX3I1IC0gY3ViZVVWX3I2ICkgKyBjdWJlVVZfbTU7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRtaXAgPSAtIDIuMCAqIGxvZzIoIDEuMTYgKiByb3VnaG5lc3MgKTtcXHRcXHR9XFxuXFx0XFx0cmV0dXJuIG1pcDtcXG5cXHR9XFxuXFx0dmVjNCB0ZXh0dXJlQ3ViZVVWKCBzYW1wbGVyMkQgZW52TWFwLCB2ZWMzIHNhbXBsZURpciwgZmxvYXQgcm91Z2huZXNzICkge1xcblxcdFxcdGZsb2F0IG1pcCA9IGNsYW1wKCByb3VnaG5lc3NUb01pcCggcm91Z2huZXNzICksIGN1YmVVVl9tMCwgQ1VCRVVWX01BWF9NSVAgKTtcXG5cXHRcXHRmbG9hdCBtaXBGID0gZnJhY3QoIG1pcCApO1xcblxcdFxcdGZsb2F0IG1pcEludCA9IGZsb29yKCBtaXAgKTtcXG5cXHRcXHR2ZWMzIGNvbG9yMCA9IGJpbGluZWFyQ3ViZVVWKCBlbnZNYXAsIHNhbXBsZURpciwgbWlwSW50ICk7XFxuXFx0XFx0aWYgKCBtaXBGID09IDAuMCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdmVjNCggY29sb3IwLCAxLjAgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHZlYzMgY29sb3IxID0gYmlsaW5lYXJDdWJlVVYoIGVudk1hcCwgc2FtcGxlRGlyLCBtaXBJbnQgKyAxLjAgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdmVjNCggbWl4KCBjb2xvcjAsIGNvbG9yMSwgbWlwRiApLCAxLjAgKTtcXG5cXHRcXHR9XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG52YXIgZGVmYXVsdG5vcm1hbF92ZXJ0ZXggPSBcInZlYzMgdHJhbnNmb3JtZWROb3JtYWwgPSBvYmplY3ROb3JtYWw7XFxuI2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0dmVjMyB0cmFuc2Zvcm1lZFRhbmdlbnQgPSBvYmplY3RUYW5nZW50O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQkFUQ0hJTkdcXG5cXHRtYXQzIGJtID0gbWF0MyggYmF0Y2hpbmdNYXRyaXggKTtcXG5cXHR0cmFuc2Zvcm1lZE5vcm1hbCAvPSB2ZWMzKCBkb3QoIGJtWyAwIF0sIGJtWyAwIF0gKSwgZG90KCBibVsgMSBdLCBibVsgMSBdICksIGRvdCggYm1bIDIgXSwgYm1bIDIgXSApICk7XFxuXFx0dHJhbnNmb3JtZWROb3JtYWwgPSBibSAqIHRyYW5zZm9ybWVkTm9ybWFsO1xcblxcdCNpZmRlZiBVU0VfVEFOR0VOVFxcblxcdFxcdHRyYW5zZm9ybWVkVGFuZ2VudCA9IGJtICogdHJhbnNmb3JtZWRUYW5nZW50O1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZmRlZiBVU0VfSU5TVEFOQ0lOR1xcblxcdG1hdDMgaW0gPSBtYXQzKCBpbnN0YW5jZU1hdHJpeCApO1xcblxcdHRyYW5zZm9ybWVkTm9ybWFsIC89IHZlYzMoIGRvdCggaW1bIDAgXSwgaW1bIDAgXSApLCBkb3QoIGltWyAxIF0sIGltWyAxIF0gKSwgZG90KCBpbVsgMiBdLCBpbVsgMiBdICkgKTtcXG5cXHR0cmFuc2Zvcm1lZE5vcm1hbCA9IGltICogdHJhbnNmb3JtZWROb3JtYWw7XFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0dHJhbnNmb3JtZWRUYW5nZW50ID0gaW0gKiB0cmFuc2Zvcm1lZFRhbmdlbnQ7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxudHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWxNYXRyaXggKiB0cmFuc2Zvcm1lZE5vcm1hbDtcXG4jaWZkZWYgRkxJUF9TSURFRFxcblxcdHRyYW5zZm9ybWVkTm9ybWFsID0gLSB0cmFuc2Zvcm1lZE5vcm1hbDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHR0cmFuc2Zvcm1lZFRhbmdlbnQgPSAoIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkVGFuZ2VudCwgMC4wICkgKS54eXo7XFxuXFx0I2lmZGVmIEZMSVBfU0lERURcXG5cXHRcXHR0cmFuc2Zvcm1lZFRhbmdlbnQgPSAtIHRyYW5zZm9ybWVkVGFuZ2VudDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxudmFyIGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBkaXNwbGFjZW1lbnRNYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRTY2FsZTtcXG5cXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudEJpYXM7XFxuI2VuZGlmXCI7XG5cbnZhciBkaXNwbGFjZW1lbnRtYXBfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcdHRyYW5zZm9ybWVkICs9IG5vcm1hbGl6ZSggb2JqZWN0Tm9ybWFsICkgKiAoIHRleHR1cmUyRCggZGlzcGxhY2VtZW50TWFwLCB2RGlzcGxhY2VtZW50TWFwVXYgKS54ICogZGlzcGxhY2VtZW50U2NhbGUgKyBkaXNwbGFjZW1lbnRCaWFzICk7XFxuI2VuZGlmXCI7XG5cbnZhciBlbWlzc2l2ZW1hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblxcdHZlYzQgZW1pc3NpdmVDb2xvciA9IHRleHR1cmUyRCggZW1pc3NpdmVNYXAsIHZFbWlzc2l2ZU1hcFV2ICk7XFxuXFx0I2lmZGVmIERFQ09ERV9WSURFT19URVhUVVJFX0VNSVNTSVZFXFxuXFx0XFx0ZW1pc3NpdmVDb2xvciA9IHNSR0JUcmFuc2ZlckVPVEYoIGVtaXNzaXZlQ29sb3IgKTtcXG5cXHQjZW5kaWZcXG5cXHR0b3RhbEVtaXNzaXZlUmFkaWFuY2UgKj0gZW1pc3NpdmVDb2xvci5yZ2I7XFxuI2VuZGlmXCI7XG5cbnZhciBlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVNYXA7XFxuI2VuZGlmXCI7XG5cbnZhciBjb2xvcnNwYWNlX2ZyYWdtZW50ID0gXCJnbF9GcmFnQ29sb3IgPSBsaW5lYXJUb091dHB1dFRleGVsKCBnbF9GcmFnQ29sb3IgKTtcIjtcblxudmFyIGNvbG9yc3BhY2VfcGFyc19mcmFnbWVudCA9IFwidmVjNCBMaW5lYXJUcmFuc2Zlck9FVEYoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0cmV0dXJuIHZhbHVlO1xcbn1cXG52ZWM0IHNSR0JUcmFuc2ZlckVPVEYoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIG1peCggcG93KCB2YWx1ZS5yZ2IgKiAwLjk0Nzg2NzI5ODYgKyB2ZWMzKCAwLjA1MjEzMjcwMTQgKSwgdmVjMyggMi40ICkgKSwgdmFsdWUucmdiICogMC4wNzczOTkzODA4LCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB2YWx1ZS5yZ2IsIHZlYzMoIDAuMDQwNDUgKSApICkgKSwgdmFsdWUuYSApO1xcbn1cXG52ZWM0IHNSR0JUcmFuc2Zlck9FVEYoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIG1peCggcG93KCB2YWx1ZS5yZ2IsIHZlYzMoIDAuNDE2NjYgKSApICogMS4wNTUgLSB2ZWMzKCAwLjA1NSApLCB2YWx1ZS5yZ2IgKiAxMi45MiwgdmVjMyggbGVzc1RoYW5FcXVhbCggdmFsdWUucmdiLCB2ZWMzKCAwLjAwMzEzMDggKSApICkgKSwgdmFsdWUuYSApO1xcbn1cIjtcblxudmFyIGVudm1hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHQjaWZkZWYgRU5WX1dPUkxEUE9TXFxuXFx0XFx0dmVjMyBjYW1lcmFUb0ZyYWc7XFxuXFx0XFx0aWYgKCBpc09ydGhvZ3JhcGhpYyApIHtcXG5cXHRcXHRcXHRjYW1lcmFUb0ZyYWcgPSBub3JtYWxpemUoIHZlYzMoIC0gdmlld01hdHJpeFsgMCBdWyAyIF0sIC0gdmlld01hdHJpeFsgMSBdWyAyIF0sIC0gdmlld01hdHJpeFsgMiBdWyAyIF0gKSApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Y2FtZXJhVG9GcmFnID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXFx0XFx0fVxcblxcdFxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIGNhbWVyYVRvRnJhZywgd29ybGROb3JtYWwgKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZnJhY3QoIGNhbWVyYVRvRnJhZywgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcdFxcdCNlbmRpZlxcblxcdCNlbHNlXFxuXFx0XFx0dmVjMyByZWZsZWN0VmVjID0gdlJlZmxlY3Q7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cXHRcXHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgZW52TWFwUm90YXRpb24gKiB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICkgKTtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB2ZWM0KCAwLjAgKTtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZXFxuXFx0XFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgb3V0Z29pbmdMaWdodCAqIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19NSVggKVxcblxcdFxcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19BREQgKVxcblxcdFxcdG91dGdvaW5nTGlnaHQgKz0gZW52Q29sb3IueHl6ICogc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxudmFyIGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHR1bmlmb3JtIGZsb2F0IGVudk1hcEludGVuc2l0eTtcXG5cXHR1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7XFxuXFx0dW5pZm9ybSBtYXQzIGVudk1hcFJvdGF0aW9uO1xcblxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7XFxuXFx0I2Vsc2VcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XFxuXFx0I2VuZGlmXFxuXFx0XFxuI2VuZGlmXCI7XG5cbnZhciBlbnZtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHR1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKSB8fCBkZWZpbmVkKCBMQU1CRVJUIClcXG5cXHRcXHQjZGVmaW5lIEVOVl9XT1JMRFBPU1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBFTlZfV09STERQT1NcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFx0XFx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxuXFx0I2Vsc2VcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBlbnZtYXBfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggTEFNQkVSVCApXFxuXFx0XFx0I2RlZmluZSBFTlZfV09STERQT1NcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRU5WX1dPUkxEUE9TXFxuXFx0XFx0XFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcdCNlbHNlXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcblxcdFxcdHVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG52YXIgZW52bWFwX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHQjaWZkZWYgRU5WX1dPUkxEUE9TXFxuXFx0XFx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzMgY2FtZXJhVG9WZXJ0ZXg7XFxuXFx0XFx0aWYgKCBpc09ydGhvZ3JhcGhpYyApIHtcXG5cXHRcXHRcXHRjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggdmVjMyggLSB2aWV3TWF0cml4WyAwIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAxIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAyIF1bIDIgXSApICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggd29ybGRQb3NpdGlvbi54eXogLSBjYW1lcmFQb3NpdGlvbiApO1xcblxcdFxcdH1cXG5cXHRcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggdHJhbnNmb3JtZWROb3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcblxcdFxcdFxcdHZSZWZsZWN0ID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHR2UmVmbGVjdCA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBmb2dfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcdHZGb2dEZXB0aCA9IC0gbXZQb3NpdGlvbi56O1xcbiNlbmRpZlwiO1xuXG52YXIgZm9nX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcdHZhcnlpbmcgZmxvYXQgdkZvZ0RlcHRoO1xcbiNlbmRpZlwiO1xuXG52YXIgZm9nX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcdCNpZmRlZiBGT0dfRVhQMlxcblxcdFxcdGZsb2F0IGZvZ0ZhY3RvciA9IDEuMCAtIGV4cCggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIHZGb2dEZXB0aCAqIHZGb2dEZXB0aCApO1xcblxcdCNlbHNlXFxuXFx0XFx0ZmxvYXQgZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCB2Rm9nRGVwdGggKTtcXG5cXHQjZW5kaWZcXG5cXHRnbF9GcmFnQ29sb3IucmdiID0gbWl4KCBnbF9GcmFnQ29sb3IucmdiLCBmb2dDb2xvciwgZm9nRmFjdG9yICk7XFxuI2VuZGlmXCI7XG5cbnZhciBmb2dfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXHR1bmlmb3JtIHZlYzMgZm9nQ29sb3I7XFxuXFx0dmFyeWluZyBmbG9hdCB2Rm9nRGVwdGg7XFxuXFx0I2lmZGVmIEZPR19FWFAyXFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5O1xcblxcdCNlbHNlXFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBmb2dOZWFyO1xcblxcdFxcdHVuaWZvcm0gZmxvYXQgZm9nRmFyO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG52YXIgZ3JhZGllbnRtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9HUkFESUVOVE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGdyYWRpZW50TWFwO1xcbiNlbmRpZlxcbnZlYzMgZ2V0R3JhZGllbnRJcnJhZGlhbmNlKCB2ZWMzIG5vcm1hbCwgdmVjMyBsaWdodERpcmVjdGlvbiApIHtcXG5cXHRmbG9hdCBkb3ROTCA9IGRvdCggbm9ybWFsLCBsaWdodERpcmVjdGlvbiApO1xcblxcdHZlYzIgY29vcmQgPSB2ZWMyKCBkb3ROTCAqIDAuNSArIDAuNSwgMC4wICk7XFxuXFx0I2lmZGVmIFVTRV9HUkFESUVOVE1BUFxcblxcdFxcdHJldHVybiB2ZWMzKCB0ZXh0dXJlMkQoIGdyYWRpZW50TWFwLCBjb29yZCApLnIgKTtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzIgZncgPSBmd2lkdGgoIGNvb3JkICkgKiAwLjU7XFxuXFx0XFx0cmV0dXJuIG1peCggdmVjMyggMC43ICksIHZlYzMoIDEuMCApLCBzbW9vdGhzdGVwKCAwLjcgLSBmdy54LCAwLjcgKyBmdy54LCBjb29yZC54ICkgKTtcXG5cXHQjZW5kaWZcXG59XCI7XG5cbnZhciBsaWdodG1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBsaWdodE1hcEludGVuc2l0eTtcXG4jZW5kaWZcIjtcblxudmFyIGxpZ2h0c19sYW1iZXJ0X2ZyYWdtZW50ID0gXCJMYW1iZXJ0TWF0ZXJpYWwgbWF0ZXJpYWw7XFxubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5tYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoID0gc3BlY3VsYXJTdHJlbmd0aDtcIjtcblxudmFyIGxpZ2h0c19sYW1iZXJ0X3BhcnNfZnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbnN0cnVjdCBMYW1iZXJ0TWF0ZXJpYWwge1xcblxcdHZlYzMgZGlmZnVzZUNvbG9yO1xcblxcdGZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7XFxufTtcXG52b2lkIFJFX0RpcmVjdF9MYW1iZXJ0KCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBMYW1iZXJ0TWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnlOb3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICk7XFxuXFx0dmVjMyBpcnJhZGlhbmNlID0gZG90TkwgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9MYW1iZXJ0KCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIExhbWJlcnRNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG4jZGVmaW5lIFJFX0RpcmVjdFxcdFxcdFxcdFxcdFJFX0RpcmVjdF9MYW1iZXJ0XFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcXHRcXHRSRV9JbmRpcmVjdERpZmZ1c2VfTGFtYmVydFwiO1xuXG52YXIgbGlnaHRzX3BhcnNfYmVnaW4gPSBcInVuaWZvcm0gYm9vbCByZWNlaXZlU2hhZG93O1xcbnVuaWZvcm0gdmVjMyBhbWJpZW50TGlnaHRDb2xvcjtcXG4jaWYgZGVmaW5lZCggVVNFX0xJR0hUX1BST0JFUyApXFxuXFx0dW5pZm9ybSB2ZWMzIGxpZ2h0UHJvYmVbIDkgXTtcXG4jZW5kaWZcXG52ZWMzIHNoR2V0SXJyYWRpYW5jZUF0KCBpbiB2ZWMzIG5vcm1hbCwgaW4gdmVjMyBzaENvZWZmaWNpZW50c1sgOSBdICkge1xcblxcdGZsb2F0IHggPSBub3JtYWwueCwgeSA9IG5vcm1hbC55LCB6ID0gbm9ybWFsLno7XFxuXFx0dmVjMyByZXN1bHQgPSBzaENvZWZmaWNpZW50c1sgMCBdICogMC44ODYyMjc7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyAxIF0gKiAyLjAgKiAwLjUxMTY2NCAqIHk7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyAyIF0gKiAyLjAgKiAwLjUxMTY2NCAqIHo7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyAzIF0gKiAyLjAgKiAwLjUxMTY2NCAqIHg7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyA0IF0gKiAyLjAgKiAwLjQyOTA0MyAqIHggKiB5O1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNSBdICogMi4wICogMC40MjkwNDMgKiB5ICogejtcXG5cXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDYgXSAqICggMC43NDMxMjUgKiB6ICogeiAtIDAuMjQ3NzA4ICk7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyA3IF0gKiAyLjAgKiAwLjQyOTA0MyAqIHggKiB6O1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgOCBdICogMC40MjkwNDMgKiAoIHggKiB4IC0geSAqIHkgKTtcXG5cXHRyZXR1cm4gcmVzdWx0O1xcbn1cXG52ZWMzIGdldExpZ2h0UHJvYmVJcnJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIGxpZ2h0UHJvYmVbIDkgXSwgY29uc3QgaW4gdmVjMyBub3JtYWwgKSB7XFxuXFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IHNoR2V0SXJyYWRpYW5jZUF0KCB3b3JsZE5vcm1hbCwgbGlnaHRQcm9iZSApO1xcblxcdHJldHVybiBpcnJhZGlhbmNlO1xcbn1cXG52ZWMzIGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgYW1iaWVudExpZ2h0Q29sb3IgKSB7XFxuXFx0dmVjMyBpcnJhZGlhbmNlID0gYW1iaWVudExpZ2h0Q29sb3I7XFxuXFx0cmV0dXJuIGlycmFkaWFuY2U7XFxufVxcbmZsb2F0IGdldERpc3RhbmNlQXR0ZW51YXRpb24oIGNvbnN0IGluIGZsb2F0IGxpZ2h0RGlzdGFuY2UsIGNvbnN0IGluIGZsb2F0IGN1dG9mZkRpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBkZWNheUV4cG9uZW50ICkge1xcblxcdGZsb2F0IGRpc3RhbmNlRmFsbG9mZiA9IDEuMCAvIG1heCggcG93KCBsaWdodERpc3RhbmNlLCBkZWNheUV4cG9uZW50ICksIDAuMDEgKTtcXG5cXHRpZiAoIGN1dG9mZkRpc3RhbmNlID4gMC4wICkge1xcblxcdFxcdGRpc3RhbmNlRmFsbG9mZiAqPSBwb3cyKCBzYXR1cmF0ZSggMS4wIC0gcG93NCggbGlnaHREaXN0YW5jZSAvIGN1dG9mZkRpc3RhbmNlICkgKSApO1xcblxcdH1cXG5cXHRyZXR1cm4gZGlzdGFuY2VGYWxsb2ZmO1xcbn1cXG5mbG9hdCBnZXRTcG90QXR0ZW51YXRpb24oIGNvbnN0IGluIGZsb2F0IGNvbmVDb3NpbmUsIGNvbnN0IGluIGZsb2F0IHBlbnVtYnJhQ29zaW5lLCBjb25zdCBpbiBmbG9hdCBhbmdsZUNvc2luZSApIHtcXG5cXHRyZXR1cm4gc21vb3Roc3RlcCggY29uZUNvc2luZSwgcGVudW1icmFDb3NpbmUsIGFuZ2xlQ29zaW5lICk7XFxufVxcbiNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cXHRzdHJ1Y3QgRGlyZWN0aW9uYWxMaWdodCB7XFxuXFx0XFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0XFx0dmVjMyBjb2xvcjtcXG5cXHR9O1xcblxcdHVuaWZvcm0gRGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0c1sgTlVNX0RJUl9MSUdIVFMgXTtcXG5cXHR2b2lkIGdldERpcmVjdGlvbmFsTGlnaHRJbmZvKCBjb25zdCBpbiBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQsIG91dCBJbmNpZGVudExpZ2h0IGxpZ2h0ICkge1xcblxcdFxcdGxpZ2h0LmNvbG9yID0gZGlyZWN0aW9uYWxMaWdodC5jb2xvcjtcXG5cXHRcXHRsaWdodC5kaXJlY3Rpb24gPSBkaXJlY3Rpb25hbExpZ2h0LmRpcmVjdGlvbjtcXG5cXHRcXHRsaWdodC52aXNpYmxlID0gdHJ1ZTtcXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IFBvaW50TGlnaHQge1xcblxcdFxcdHZlYzMgcG9zaXRpb247XFxuXFx0XFx0dmVjMyBjb2xvcjtcXG5cXHRcXHRmbG9hdCBkaXN0YW5jZTtcXG5cXHRcXHRmbG9hdCBkZWNheTtcXG5cXHR9O1xcblxcdHVuaWZvcm0gUG9pbnRMaWdodCBwb2ludExpZ2h0c1sgTlVNX1BPSU5UX0xJR0hUUyBdO1xcblxcdHZvaWQgZ2V0UG9pbnRMaWdodEluZm8oIGNvbnN0IGluIFBvaW50TGlnaHQgcG9pbnRMaWdodCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBvdXQgSW5jaWRlbnRMaWdodCBsaWdodCApIHtcXG5cXHRcXHR2ZWMzIGxWZWN0b3IgPSBwb2ludExpZ2h0LnBvc2l0aW9uIC0gZ2VvbWV0cnlQb3NpdGlvbjtcXG5cXHRcXHRsaWdodC5kaXJlY3Rpb24gPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXHRcXHRmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKCBsVmVjdG9yICk7XFxuXFx0XFx0bGlnaHQuY29sb3IgPSBwb2ludExpZ2h0LmNvbG9yO1xcblxcdFxcdGxpZ2h0LmNvbG9yICo9IGdldERpc3RhbmNlQXR0ZW51YXRpb24oIGxpZ2h0RGlzdGFuY2UsIHBvaW50TGlnaHQuZGlzdGFuY2UsIHBvaW50TGlnaHQuZGVjYXkgKTtcXG5cXHRcXHRsaWdodC52aXNpYmxlID0gKCBsaWdodC5jb2xvciAhPSB2ZWMzKCAwLjAgKSApO1xcblxcdH1cXG4jZW5kaWZcXG4jaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdHN0cnVjdCBTcG90TGlnaHQge1xcblxcdFxcdHZlYzMgcG9zaXRpb247XFxuXFx0XFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0XFx0dmVjMyBjb2xvcjtcXG5cXHRcXHRmbG9hdCBkaXN0YW5jZTtcXG5cXHRcXHRmbG9hdCBkZWNheTtcXG5cXHRcXHRmbG9hdCBjb25lQ29zO1xcblxcdFxcdGZsb2F0IHBlbnVtYnJhQ29zO1xcblxcdH07XFxuXFx0dW5pZm9ybSBTcG90TGlnaHQgc3BvdExpZ2h0c1sgTlVNX1NQT1RfTElHSFRTIF07XFxuXFx0dm9pZCBnZXRTcG90TGlnaHRJbmZvKCBjb25zdCBpbiBTcG90TGlnaHQgc3BvdExpZ2h0LCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIG91dCBJbmNpZGVudExpZ2h0IGxpZ2h0ICkge1xcblxcdFxcdHZlYzMgbFZlY3RvciA9IHNwb3RMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5UG9zaXRpb247XFxuXFx0XFx0bGlnaHQuZGlyZWN0aW9uID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFx0XFx0ZmxvYXQgYW5nbGVDb3MgPSBkb3QoIGxpZ2h0LmRpcmVjdGlvbiwgc3BvdExpZ2h0LmRpcmVjdGlvbiApO1xcblxcdFxcdGZsb2F0IHNwb3RBdHRlbnVhdGlvbiA9IGdldFNwb3RBdHRlbnVhdGlvbiggc3BvdExpZ2h0LmNvbmVDb3MsIHNwb3RMaWdodC5wZW51bWJyYUNvcywgYW5nbGVDb3MgKTtcXG5cXHRcXHRpZiAoIHNwb3RBdHRlbnVhdGlvbiA+IDAuMCApIHtcXG5cXHRcXHRcXHRmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKCBsVmVjdG9yICk7XFxuXFx0XFx0XFx0bGlnaHQuY29sb3IgPSBzcG90TGlnaHQuY29sb3IgKiBzcG90QXR0ZW51YXRpb247XFxuXFx0XFx0XFx0bGlnaHQuY29sb3IgKj0gZ2V0RGlzdGFuY2VBdHRlbnVhdGlvbiggbGlnaHREaXN0YW5jZSwgc3BvdExpZ2h0LmRpc3RhbmNlLCBzcG90TGlnaHQuZGVjYXkgKTtcXG5cXHRcXHRcXHRsaWdodC52aXNpYmxlID0gKCBsaWdodC5jb2xvciAhPSB2ZWMzKCAwLjAgKSApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0bGlnaHQuY29sb3IgPSB2ZWMzKCAwLjAgKTtcXG5cXHRcXHRcXHRsaWdodC52aXNpYmxlID0gZmFsc2U7XFxuXFx0XFx0fVxcblxcdH1cXG4jZW5kaWZcXG4jaWYgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IFJlY3RBcmVhTGlnaHQge1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0XFx0dmVjMyBwb3NpdGlvbjtcXG5cXHRcXHR2ZWMzIGhhbGZXaWR0aDtcXG5cXHRcXHR2ZWMzIGhhbGZIZWlnaHQ7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBsdGNfMTtcXHR1bmlmb3JtIHNhbXBsZXIyRCBsdGNfMjtcXG5cXHR1bmlmb3JtIFJlY3RBcmVhTGlnaHQgcmVjdEFyZWFMaWdodHNbIE5VTV9SRUNUX0FSRUFfTElHSFRTIF07XFxuI2VuZGlmXFxuI2lmIE5VTV9IRU1JX0xJR0hUUyA+IDBcXG5cXHRzdHJ1Y3QgSGVtaXNwaGVyZUxpZ2h0IHtcXG5cXHRcXHR2ZWMzIGRpcmVjdGlvbjtcXG5cXHRcXHR2ZWMzIHNreUNvbG9yO1xcblxcdFxcdHZlYzMgZ3JvdW5kQ29sb3I7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIEhlbWlzcGhlcmVMaWdodCBoZW1pc3BoZXJlTGlnaHRzWyBOVU1fSEVNSV9MSUdIVFMgXTtcXG5cXHR2ZWMzIGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIEhlbWlzcGhlcmVMaWdodCBoZW1pTGlnaHQsIGNvbnN0IGluIHZlYzMgbm9ybWFsICkge1xcblxcdFxcdGZsb2F0IGRvdE5MID0gZG90KCBub3JtYWwsIGhlbWlMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdE5MICsgMC41O1xcblxcdFxcdHZlYzMgaXJyYWRpYW5jZSA9IG1peCggaGVtaUxpZ2h0Lmdyb3VuZENvbG9yLCBoZW1pTGlnaHQuc2t5Q29sb3IsIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxuXFx0XFx0cmV0dXJuIGlycmFkaWFuY2U7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG52YXIgZW52bWFwX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0dmVjMyBnZXRJQkxJcnJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCApIHtcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRV9VVlxcblxcdFxcdFxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVVViggZW52TWFwLCBlbnZNYXBSb3RhdGlvbiAqIHdvcmxkTm9ybWFsLCAxLjAgKTtcXG5cXHRcXHRcXHRyZXR1cm4gUEkgKiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRyZXR1cm4gdmVjMyggMC4wICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcblxcdHZlYzMgZ2V0SUJMUmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRV9VVlxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIC0gdmlld0Rpciwgbm9ybWFsICk7XFxuXFx0XFx0XFx0cmVmbGVjdFZlYyA9IG5vcm1hbGl6ZSggbWl4KCByZWZsZWN0VmVjLCBub3JtYWwsIHJvdWdobmVzcyAqIHJvdWdobmVzcykgKTtcXG5cXHRcXHRcXHRyZWZsZWN0VmVjID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggcmVmbGVjdFZlYywgdmlld01hdHJpeCApO1xcblxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZVVWKCBlbnZNYXAsIGVudk1hcFJvdGF0aW9uICogcmVmbGVjdFZlYywgcm91Z2huZXNzICk7XFxuXFx0XFx0XFx0cmV0dXJuIGVudk1hcENvbG9yLnJnYiAqIGVudk1hcEludGVuc2l0eTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHJldHVybiB2ZWMzKCAwLjAgKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuXFx0I2lmZGVmIFVTRV9BTklTT1RST1BZXFxuXFx0XFx0dmVjMyBnZXRJQkxBbmlzb3Ryb3B5UmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gdmVjMyBiaXRhbmdlbnQsIGNvbnN0IGluIGZsb2F0IGFuaXNvdHJvcHkgKSB7XFxuXFx0XFx0XFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVfVVZcXG5cXHRcXHRcXHRcXHR2ZWMzIGJlbnROb3JtYWwgPSBjcm9zcyggYml0YW5nZW50LCB2aWV3RGlyICk7XFxuXFx0XFx0XFx0XFx0YmVudE5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGJlbnROb3JtYWwsIGJpdGFuZ2VudCApICk7XFxuXFx0XFx0XFx0XFx0YmVudE5vcm1hbCA9IG5vcm1hbGl6ZSggbWl4KCBiZW50Tm9ybWFsLCBub3JtYWwsIHBvdzIoIHBvdzIoIDEuMCAtIGFuaXNvdHJvcHkgKiAoIDEuMCAtIHJvdWdobmVzcyApICkgKSApICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGdldElCTFJhZGlhbmNlKCB2aWV3RGlyLCBiZW50Tm9ybWFsLCByb3VnaG5lc3MgKTtcXG5cXHRcXHRcXHQjZWxzZVxcblxcdFxcdFxcdFxcdHJldHVybiB2ZWMzKCAwLjAgKTtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBsaWdodHNfdG9vbl9mcmFnbWVudCA9IFwiVG9vbk1hdGVyaWFsIG1hdGVyaWFsO1xcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2I7XCI7XG5cbnZhciBsaWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG5zdHJ1Y3QgVG9vbk1hdGVyaWFsIHtcXG5cXHR2ZWMzIGRpZmZ1c2VDb2xvcjtcXG59O1xcbnZvaWQgUkVfRGlyZWN0X1Rvb24oIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIFRvb25NYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0dmVjMyBpcnJhZGlhbmNlID0gZ2V0R3JhZGllbnRJcnJhZGlhbmNlKCBnZW9tZXRyeU5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9Ub29uKCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIFRvb25NYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG4jZGVmaW5lIFJFX0RpcmVjdFxcdFxcdFxcdFxcdFJFX0RpcmVjdF9Ub29uXFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcXHRcXHRSRV9JbmRpcmVjdERpZmZ1c2VfVG9vblwiO1xuXG52YXIgbGlnaHRzX3Bob25nX2ZyYWdtZW50ID0gXCJCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWw7XFxubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5tYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gc3BlY3VsYXI7XFxubWF0ZXJpYWwuc3BlY3VsYXJTaGluaW5lc3MgPSBzaGluaW5lc3M7XFxubWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aCA9IHNwZWN1bGFyU3RyZW5ndGg7XCI7XG5cbnZhciBsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudCA9IFwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuc3RydWN0IEJsaW5uUGhvbmdNYXRlcmlhbCB7XFxuXFx0dmVjMyBkaWZmdXNlQ29sb3I7XFxuXFx0dmVjMyBzcGVjdWxhckNvbG9yO1xcblxcdGZsb2F0IHNwZWN1bGFyU2hpbmluZXNzO1xcblxcdGZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7XFxufTtcXG52b2lkIFJFX0RpcmVjdF9CbGlublBob25nKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnlOb3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICk7XFxuXFx0dmVjMyBpcnJhZGlhbmNlID0gZG90TkwgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBCUkRGX0JsaW5uUGhvbmcoIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeU5vcm1hbCwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJTaGluaW5lc3MgKSAqIG1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGg7XFxufVxcbnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmcoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxufVxcbiNkZWZpbmUgUkVfRGlyZWN0XFx0XFx0XFx0XFx0UkVfRGlyZWN0X0JsaW5uUGhvbmdcXG4jZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZVxcdFxcdFJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nXCI7XG5cbnZhciBsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQgPSBcIlBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWw7XFxubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYiAqICggMS4wIC0gbWV0YWxuZXNzRmFjdG9yICk7XFxudmVjMyBkeHkgPSBtYXgoIGFicyggZEZkeCggbm9uUGVydHVyYmVkTm9ybWFsICkgKSwgYWJzKCBkRmR5KCBub25QZXJ0dXJiZWROb3JtYWwgKSApICk7XFxuZmxvYXQgZ2VvbWV0cnlSb3VnaG5lc3MgPSBtYXgoIG1heCggZHh5LngsIGR4eS55ICksIGR4eS56ICk7XFxubWF0ZXJpYWwucm91Z2huZXNzID0gbWF4KCByb3VnaG5lc3NGYWN0b3IsIDAuMDUyNSApO21hdGVyaWFsLnJvdWdobmVzcyArPSBnZW9tZXRyeVJvdWdobmVzcztcXG5tYXRlcmlhbC5yb3VnaG5lc3MgPSBtaW4oIG1hdGVyaWFsLnJvdWdobmVzcywgMS4wICk7XFxuI2lmZGVmIElPUlxcblxcdG1hdGVyaWFsLmlvciA9IGlvcjtcXG5cXHQjaWZkZWYgVVNFX1NQRUNVTEFSXFxuXFx0XFx0ZmxvYXQgc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IgPSBzcGVjdWxhckludGVuc2l0eTtcXG5cXHRcXHR2ZWMzIHNwZWN1bGFyQ29sb3JGYWN0b3IgPSBzcGVjdWxhckNvbG9yO1xcblxcdFxcdCNpZmRlZiBVU0VfU1BFQ1VMQVJfQ09MT1JNQVBcXG5cXHRcXHRcXHRzcGVjdWxhckNvbG9yRmFjdG9yICo9IHRleHR1cmUyRCggc3BlY3VsYXJDb2xvck1hcCwgdlNwZWN1bGFyQ29sb3JNYXBVdiApLnJnYjtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHQjaWZkZWYgVVNFX1NQRUNVTEFSX0lOVEVOU0lUWU1BUFxcblxcdFxcdFxcdHNwZWN1bGFySW50ZW5zaXR5RmFjdG9yICo9IHRleHR1cmUyRCggc3BlY3VsYXJJbnRlbnNpdHlNYXAsIHZTcGVjdWxhckludGVuc2l0eU1hcFV2ICkuYTtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRtYXRlcmlhbC5zcGVjdWxhckY5MCA9IG1peCggc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IsIDEuMCwgbWV0YWxuZXNzRmFjdG9yICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRmbG9hdCBzcGVjdWxhckludGVuc2l0eUZhY3RvciA9IDEuMDtcXG5cXHRcXHR2ZWMzIHNwZWN1bGFyQ29sb3JGYWN0b3IgPSB2ZWMzKCAxLjAgKTtcXG5cXHRcXHRtYXRlcmlhbC5zcGVjdWxhckY5MCA9IDEuMDtcXG5cXHQjZW5kaWZcXG5cXHRtYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gbWl4KCBtaW4oIHBvdzIoICggbWF0ZXJpYWwuaW9yIC0gMS4wICkgLyAoIG1hdGVyaWFsLmlvciArIDEuMCApICkgKiBzcGVjdWxhckNvbG9yRmFjdG9yLCB2ZWMzKCAxLjAgKSApICogc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IsIGRpZmZ1c2VDb2xvci5yZ2IsIG1ldGFsbmVzc0ZhY3RvciApO1xcbiNlbHNlXFxuXFx0bWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggdmVjMyggMC4wNCApLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcXG5cXHRtYXRlcmlhbC5zcGVjdWxhckY5MCA9IDEuMDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdG1hdGVyaWFsLmNsZWFyY29hdCA9IGNsZWFyY29hdDtcXG5cXHRtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgPSBjbGVhcmNvYXRSb3VnaG5lc3M7XFxuXFx0bWF0ZXJpYWwuY2xlYXJjb2F0RjAgPSB2ZWMzKCAwLjA0ICk7XFxuXFx0bWF0ZXJpYWwuY2xlYXJjb2F0RjkwID0gMS4wO1xcblxcdCNpZmRlZiBVU0VfQ0xFQVJDT0FUTUFQXFxuXFx0XFx0bWF0ZXJpYWwuY2xlYXJjb2F0ICo9IHRleHR1cmUyRCggY2xlYXJjb2F0TWFwLCB2Q2xlYXJjb2F0TWFwVXYgKS54O1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUFxcblxcdFxcdG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyAqPSB0ZXh0dXJlMkQoIGNsZWFyY29hdFJvdWdobmVzc01hcCwgdkNsZWFyY29hdFJvdWdobmVzc01hcFV2ICkueTtcXG5cXHQjZW5kaWZcXG5cXHRtYXRlcmlhbC5jbGVhcmNvYXQgPSBzYXR1cmF0ZSggbWF0ZXJpYWwuY2xlYXJjb2F0ICk7XFx0bWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0gbWF4KCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MsIDAuMDUyNSApO1xcblxcdG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyArPSBnZW9tZXRyeVJvdWdobmVzcztcXG5cXHRtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgPSBtaW4oIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcywgMS4wICk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9ESVNQRVJTSU9OXFxuXFx0bWF0ZXJpYWwuZGlzcGVyc2lvbiA9IGRpc3BlcnNpb247XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9JUklERVNDRU5DRVxcblxcdG1hdGVyaWFsLmlyaWRlc2NlbmNlID0gaXJpZGVzY2VuY2U7XFxuXFx0bWF0ZXJpYWwuaXJpZGVzY2VuY2VJT1IgPSBpcmlkZXNjZW5jZUlPUjtcXG5cXHQjaWZkZWYgVVNFX0lSSURFU0NFTkNFTUFQXFxuXFx0XFx0bWF0ZXJpYWwuaXJpZGVzY2VuY2UgKj0gdGV4dHVyZTJEKCBpcmlkZXNjZW5jZU1hcCwgdklyaWRlc2NlbmNlTWFwVXYgKS5yO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQXFxuXFx0XFx0bWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3MgPSAoaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtIC0gaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtKSAqIHRleHR1cmUyRCggaXJpZGVzY2VuY2VUaGlja25lc3NNYXAsIHZJcmlkZXNjZW5jZVRoaWNrbmVzc01hcFV2ICkuZyArIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bTtcXG5cXHQjZWxzZVxcblxcdFxcdG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzID0gaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU0hFRU5cXG5cXHRtYXRlcmlhbC5zaGVlbkNvbG9yID0gc2hlZW5Db2xvcjtcXG5cXHQjaWZkZWYgVVNFX1NIRUVOX0NPTE9STUFQXFxuXFx0XFx0bWF0ZXJpYWwuc2hlZW5Db2xvciAqPSB0ZXh0dXJlMkQoIHNoZWVuQ29sb3JNYXAsIHZTaGVlbkNvbG9yTWFwVXYgKS5yZ2I7XFxuXFx0I2VuZGlmXFxuXFx0bWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgPSBjbGFtcCggc2hlZW5Sb3VnaG5lc3MsIDAuMDcsIDEuMCApO1xcblxcdCNpZmRlZiBVU0VfU0hFRU5fUk9VR0hORVNTTUFQXFxuXFx0XFx0bWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgKj0gdGV4dHVyZTJEKCBzaGVlblJvdWdobmVzc01hcCwgdlNoZWVuUm91Z2huZXNzTWFwVXYgKS5hO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQU5JU09UUk9QWVxcblxcdCNpZmRlZiBVU0VfQU5JU09UUk9QWU1BUFxcblxcdFxcdG1hdDIgYW5pc290cm9weU1hdCA9IG1hdDIoIGFuaXNvdHJvcHlWZWN0b3IueCwgYW5pc290cm9weVZlY3Rvci55LCAtIGFuaXNvdHJvcHlWZWN0b3IueSwgYW5pc290cm9weVZlY3Rvci54ICk7XFxuXFx0XFx0dmVjMyBhbmlzb3Ryb3B5UG9sYXIgPSB0ZXh0dXJlMkQoIGFuaXNvdHJvcHlNYXAsIHZBbmlzb3Ryb3B5TWFwVXYgKS5yZ2I7XFxuXFx0XFx0dmVjMiBhbmlzb3Ryb3B5ViA9IGFuaXNvdHJvcHlNYXQgKiBub3JtYWxpemUoIDIuMCAqIGFuaXNvdHJvcHlQb2xhci5yZyAtIHZlYzIoIDEuMCApICkgKiBhbmlzb3Ryb3B5UG9sYXIuYjtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzIgYW5pc290cm9weVYgPSBhbmlzb3Ryb3B5VmVjdG9yO1xcblxcdCNlbmRpZlxcblxcdG1hdGVyaWFsLmFuaXNvdHJvcHkgPSBsZW5ndGgoIGFuaXNvdHJvcHlWICk7XFxuXFx0aWYoIG1hdGVyaWFsLmFuaXNvdHJvcHkgPT0gMC4wICkge1xcblxcdFxcdGFuaXNvdHJvcHlWID0gdmVjMiggMS4wLCAwLjAgKTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdGFuaXNvdHJvcHlWIC89IG1hdGVyaWFsLmFuaXNvdHJvcHk7XFxuXFx0XFx0bWF0ZXJpYWwuYW5pc290cm9weSA9IHNhdHVyYXRlKCBtYXRlcmlhbC5hbmlzb3Ryb3B5ICk7XFxuXFx0fVxcblxcdG1hdGVyaWFsLmFscGhhVCA9IG1peCggcG93MiggbWF0ZXJpYWwucm91Z2huZXNzICksIDEuMCwgcG93MiggbWF0ZXJpYWwuYW5pc290cm9weSApICk7XFxuXFx0bWF0ZXJpYWwuYW5pc290cm9weVQgPSB0Ym5bIDAgXSAqIGFuaXNvdHJvcHlWLnggKyB0Ym5bIDEgXSAqIGFuaXNvdHJvcHlWLnk7XFxuXFx0bWF0ZXJpYWwuYW5pc290cm9weUIgPSB0Ym5bIDEgXSAqIGFuaXNvdHJvcHlWLnggLSB0Ym5bIDAgXSAqIGFuaXNvdHJvcHlWLnk7XFxuI2VuZGlmXCI7XG5cbnZhciBsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudCA9IFwic3RydWN0IFBoeXNpY2FsTWF0ZXJpYWwge1xcblxcdHZlYzMgZGlmZnVzZUNvbG9yO1xcblxcdGZsb2F0IHJvdWdobmVzcztcXG5cXHR2ZWMzIHNwZWN1bGFyQ29sb3I7XFxuXFx0ZmxvYXQgc3BlY3VsYXJGOTA7XFxuXFx0ZmxvYXQgZGlzcGVyc2lvbjtcXG5cXHQjaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdFxcdGZsb2F0IGNsZWFyY29hdDtcXG5cXHRcXHRmbG9hdCBjbGVhcmNvYXRSb3VnaG5lc3M7XFxuXFx0XFx0dmVjMyBjbGVhcmNvYXRGMDtcXG5cXHRcXHRmbG9hdCBjbGVhcmNvYXRGOTA7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9JUklERVNDRU5DRVxcblxcdFxcdGZsb2F0IGlyaWRlc2NlbmNlO1xcblxcdFxcdGZsb2F0IGlyaWRlc2NlbmNlSU9SO1xcblxcdFxcdGZsb2F0IGlyaWRlc2NlbmNlVGhpY2tuZXNzO1xcblxcdFxcdHZlYzMgaXJpZGVzY2VuY2VGcmVzbmVsO1xcblxcdFxcdHZlYzMgaXJpZGVzY2VuY2VGMDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX1NIRUVOXFxuXFx0XFx0dmVjMyBzaGVlbkNvbG9yO1xcblxcdFxcdGZsb2F0IHNoZWVuUm91Z2huZXNzO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBJT1JcXG5cXHRcXHRmbG9hdCBpb3I7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9UUkFOU01JU1NJT05cXG5cXHRcXHRmbG9hdCB0cmFuc21pc3Npb247XFxuXFx0XFx0ZmxvYXQgdHJhbnNtaXNzaW9uQWxwaGE7XFxuXFx0XFx0ZmxvYXQgdGhpY2tuZXNzO1xcblxcdFxcdGZsb2F0IGF0dGVudWF0aW9uRGlzdGFuY2U7XFxuXFx0XFx0dmVjMyBhdHRlbnVhdGlvbkNvbG9yO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfQU5JU09UUk9QWVxcblxcdFxcdGZsb2F0IGFuaXNvdHJvcHk7XFxuXFx0XFx0ZmxvYXQgYWxwaGFUO1xcblxcdFxcdHZlYzMgYW5pc290cm9weVQ7XFxuXFx0XFx0dmVjMyBhbmlzb3Ryb3B5QjtcXG5cXHQjZW5kaWZcXG59O1xcbnZlYzMgY2xlYXJjb2F0U3BlY3VsYXJEaXJlY3QgPSB2ZWMzKCAwLjAgKTtcXG52ZWMzIGNsZWFyY29hdFNwZWN1bGFySW5kaXJlY3QgPSB2ZWMzKCAwLjAgKTtcXG52ZWMzIHNoZWVuU3BlY3VsYXJEaXJlY3QgPSB2ZWMzKCAwLjAgKTtcXG52ZWMzIHNoZWVuU3BlY3VsYXJJbmRpcmVjdCA9IHZlYzMoMC4wICk7XFxudmVjMyBTY2hsaWNrX3RvX0YwKCBjb25zdCBpbiB2ZWMzIGYsIGNvbnN0IGluIGZsb2F0IGY5MCwgY29uc3QgaW4gZmxvYXQgZG90VkggKSB7XFxuICAgIGZsb2F0IHggPSBjbGFtcCggMS4wIC0gZG90VkgsIDAuMCwgMS4wICk7XFxuICAgIGZsb2F0IHgyID0geCAqIHg7XFxuICAgIGZsb2F0IHg1ID0gY2xhbXAoIHggKiB4MiAqIHgyLCAwLjAsIDAuOTk5OSApO1xcbiAgICByZXR1cm4gKCBmIC0gdmVjMyggZjkwICkgKiB4NSApIC8gKCAxLjAgLSB4NSApO1xcbn1cXG5mbG9hdCBWX0dHWF9TbWl0aENvcnJlbGF0ZWQoIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROTCwgY29uc3QgaW4gZmxvYXQgZG90TlYgKSB7XFxuXFx0ZmxvYXQgYTIgPSBwb3cyKCBhbHBoYSApO1xcblxcdGZsb2F0IGd2ID0gZG90TkwgKiBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5WICkgKTtcXG5cXHRmbG9hdCBnbCA9IGRvdE5WICogc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROTCApICk7XFxuXFx0cmV0dXJuIDAuNSAvIG1heCggZ3YgKyBnbCwgRVBTSUxPTiApO1xcbn1cXG5mbG9hdCBEX0dHWCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5IICkge1xcblxcdGZsb2F0IGEyID0gcG93MiggYWxwaGEgKTtcXG5cXHRmbG9hdCBkZW5vbSA9IHBvdzIoIGRvdE5IICkgKiAoIGEyIC0gMS4wICkgKyAxLjA7XFxuXFx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBhMiAvIHBvdzIoIGRlbm9tICk7XFxufVxcbiNpZmRlZiBVU0VfQU5JU09UUk9QWVxcblxcdGZsb2F0IFZfR0dYX1NtaXRoQ29ycmVsYXRlZF9Bbmlzb3Ryb3BpYyggY29uc3QgaW4gZmxvYXQgYWxwaGFULCBjb25zdCBpbiBmbG9hdCBhbHBoYUIsIGNvbnN0IGluIGZsb2F0IGRvdFRWLCBjb25zdCBpbiBmbG9hdCBkb3RCViwgY29uc3QgaW4gZmxvYXQgZG90VEwsIGNvbnN0IGluIGZsb2F0IGRvdEJMLCBjb25zdCBpbiBmbG9hdCBkb3ROViwgY29uc3QgaW4gZmxvYXQgZG90TkwgKSB7XFxuXFx0XFx0ZmxvYXQgZ3YgPSBkb3ROTCAqIGxlbmd0aCggdmVjMyggYWxwaGFUICogZG90VFYsIGFscGhhQiAqIGRvdEJWLCBkb3ROViApICk7XFxuXFx0XFx0ZmxvYXQgZ2wgPSBkb3ROViAqIGxlbmd0aCggdmVjMyggYWxwaGFUICogZG90VEwsIGFscGhhQiAqIGRvdEJMLCBkb3ROTCApICk7XFxuXFx0XFx0ZmxvYXQgdiA9IDAuNSAvICggZ3YgKyBnbCApO1xcblxcdFxcdHJldHVybiBzYXR1cmF0ZSh2KTtcXG5cXHR9XFxuXFx0ZmxvYXQgRF9HR1hfQW5pc290cm9waWMoIGNvbnN0IGluIGZsb2F0IGFscGhhVCwgY29uc3QgaW4gZmxvYXQgYWxwaGFCLCBjb25zdCBpbiBmbG9hdCBkb3ROSCwgY29uc3QgaW4gZmxvYXQgZG90VEgsIGNvbnN0IGluIGZsb2F0IGRvdEJIICkge1xcblxcdFxcdGZsb2F0IGEyID0gYWxwaGFUICogYWxwaGFCO1xcblxcdFxcdGhpZ2hwIHZlYzMgdiA9IHZlYzMoIGFscGhhQiAqIGRvdFRILCBhbHBoYVQgKiBkb3RCSCwgYTIgKiBkb3ROSCApO1xcblxcdFxcdGhpZ2hwIGZsb2F0IHYyID0gZG90KCB2LCB2ICk7XFxuXFx0XFx0ZmxvYXQgdzIgPSBhMiAvIHYyO1xcblxcdFxcdHJldHVybiBSRUNJUFJPQ0FMX1BJICogYTIgKiBwb3cyICggdzIgKTtcXG5cXHR9XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHR2ZWMzIEJSREZfR0dYX0NsZWFyY29hdCggY29uc3QgaW4gdmVjMyBsaWdodERpciwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCkge1xcblxcdFxcdHZlYzMgZjAgPSBtYXRlcmlhbC5jbGVhcmNvYXRGMDtcXG5cXHRcXHRmbG9hdCBmOTAgPSBtYXRlcmlhbC5jbGVhcmNvYXRGOTA7XFxuXFx0XFx0ZmxvYXQgcm91Z2huZXNzID0gbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzO1xcblxcdFxcdGZsb2F0IGFscGhhID0gcG93Miggcm91Z2huZXNzICk7XFxuXFx0XFx0dmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBsaWdodERpciArIHZpZXdEaXIgKTtcXG5cXHRcXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xcblxcdFxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTtcXG5cXHRcXHRmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaGFsZkRpciApICk7XFxuXFx0XFx0ZmxvYXQgZG90VkggPSBzYXR1cmF0ZSggZG90KCB2aWV3RGlyLCBoYWxmRGlyICkgKTtcXG5cXHRcXHR2ZWMzIEYgPSBGX1NjaGxpY2soIGYwLCBmOTAsIGRvdFZIICk7XFxuXFx0XFx0ZmxvYXQgViA9IFZfR0dYX1NtaXRoQ29ycmVsYXRlZCggYWxwaGEsIGRvdE5MLCBkb3ROViApO1xcblxcdFxcdGZsb2F0IEQgPSBEX0dHWCggYWxwaGEsIGRvdE5IICk7XFxuXFx0XFx0cmV0dXJuIEYgKiAoIFYgKiBEICk7XFxuXFx0fVxcbiNlbmRpZlxcbnZlYzMgQlJERl9HR1goIGNvbnN0IGluIHZlYzMgbGlnaHREaXIsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwgKSB7XFxuXFx0dmVjMyBmMCA9IG1hdGVyaWFsLnNwZWN1bGFyQ29sb3I7XFxuXFx0ZmxvYXQgZjkwID0gbWF0ZXJpYWwuc3BlY3VsYXJGOTA7XFxuXFx0ZmxvYXQgcm91Z2huZXNzID0gbWF0ZXJpYWwucm91Z2huZXNzO1xcblxcdGZsb2F0IGFscGhhID0gcG93Miggcm91Z2huZXNzICk7XFxuXFx0dmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBsaWdodERpciArIHZpZXdEaXIgKTtcXG5cXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xcblxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTtcXG5cXHRmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaGFsZkRpciApICk7XFxuXFx0ZmxvYXQgZG90VkggPSBzYXR1cmF0ZSggZG90KCB2aWV3RGlyLCBoYWxmRGlyICkgKTtcXG5cXHR2ZWMzIEYgPSBGX1NjaGxpY2soIGYwLCBmOTAsIGRvdFZIICk7XFxuXFx0I2lmZGVmIFVTRV9JUklERVNDRU5DRVxcblxcdFxcdEYgPSBtaXgoIEYsIG1hdGVyaWFsLmlyaWRlc2NlbmNlRnJlc25lbCwgbWF0ZXJpYWwuaXJpZGVzY2VuY2UgKTtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX0FOSVNPVFJPUFlcXG5cXHRcXHRmbG9hdCBkb3RUTCA9IGRvdCggbWF0ZXJpYWwuYW5pc290cm9weVQsIGxpZ2h0RGlyICk7XFxuXFx0XFx0ZmxvYXQgZG90VFYgPSBkb3QoIG1hdGVyaWFsLmFuaXNvdHJvcHlULCB2aWV3RGlyICk7XFxuXFx0XFx0ZmxvYXQgZG90VEggPSBkb3QoIG1hdGVyaWFsLmFuaXNvdHJvcHlULCBoYWxmRGlyICk7XFxuXFx0XFx0ZmxvYXQgZG90QkwgPSBkb3QoIG1hdGVyaWFsLmFuaXNvdHJvcHlCLCBsaWdodERpciApO1xcblxcdFxcdGZsb2F0IGRvdEJWID0gZG90KCBtYXRlcmlhbC5hbmlzb3Ryb3B5Qiwgdmlld0RpciApO1xcblxcdFxcdGZsb2F0IGRvdEJIID0gZG90KCBtYXRlcmlhbC5hbmlzb3Ryb3B5QiwgaGFsZkRpciApO1xcblxcdFxcdGZsb2F0IFYgPSBWX0dHWF9TbWl0aENvcnJlbGF0ZWRfQW5pc290cm9waWMoIG1hdGVyaWFsLmFscGhhVCwgYWxwaGEsIGRvdFRWLCBkb3RCViwgZG90VEwsIGRvdEJMLCBkb3ROViwgZG90TkwgKTtcXG5cXHRcXHRmbG9hdCBEID0gRF9HR1hfQW5pc290cm9waWMoIG1hdGVyaWFsLmFscGhhVCwgYWxwaGEsIGRvdE5ILCBkb3RUSCwgZG90QkggKTtcXG5cXHQjZWxzZVxcblxcdFxcdGZsb2F0IFYgPSBWX0dHWF9TbWl0aENvcnJlbGF0ZWQoIGFscGhhLCBkb3ROTCwgZG90TlYgKTtcXG5cXHRcXHRmbG9hdCBEID0gRF9HR1goIGFscGhhLCBkb3ROSCApO1xcblxcdCNlbmRpZlxcblxcdHJldHVybiBGICogKCBWICogRCApO1xcbn1cXG52ZWMyIExUQ19VdiggY29uc3QgaW4gdmVjMyBOLCBjb25zdCBpbiB2ZWMzIFYsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRjb25zdCBmbG9hdCBMVVRfU0laRSA9IDY0LjA7XFxuXFx0Y29uc3QgZmxvYXQgTFVUX1NDQUxFID0gKCBMVVRfU0laRSAtIDEuMCApIC8gTFVUX1NJWkU7XFxuXFx0Y29uc3QgZmxvYXQgTFVUX0JJQVMgPSAwLjUgLyBMVVRfU0laRTtcXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIE4sIFYgKSApO1xcblxcdHZlYzIgdXYgPSB2ZWMyKCByb3VnaG5lc3MsIHNxcnQoIDEuMCAtIGRvdE5WICkgKTtcXG5cXHR1diA9IHV2ICogTFVUX1NDQUxFICsgTFVUX0JJQVM7XFxuXFx0cmV0dXJuIHV2O1xcbn1cXG5mbG9hdCBMVENfQ2xpcHBlZFNwaGVyZUZvcm1GYWN0b3IoIGNvbnN0IGluIHZlYzMgZiApIHtcXG5cXHRmbG9hdCBsID0gbGVuZ3RoKCBmICk7XFxuXFx0cmV0dXJuIG1heCggKCBsICogbCArIGYueiApIC8gKCBsICsgMS4wICksIDAuMCApO1xcbn1cXG52ZWMzIExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29uc3QgaW4gdmVjMyB2MSwgY29uc3QgaW4gdmVjMyB2MiApIHtcXG5cXHRmbG9hdCB4ID0gZG90KCB2MSwgdjIgKTtcXG5cXHRmbG9hdCB5ID0gYWJzKCB4ICk7XFxuXFx0ZmxvYXQgYSA9IDAuODU0Mzk4NSArICggMC40OTY1MTU1ICsgMC4wMTQ1MjA2ICogeSApICogeTtcXG5cXHRmbG9hdCBiID0gMy40MTc1OTQwICsgKCA0LjE2MTY3MjQgKyB5ICkgKiB5O1xcblxcdGZsb2F0IHYgPSBhIC8gYjtcXG5cXHRmbG9hdCB0aGV0YV9zaW50aGV0YSA9ICggeCA+IDAuMCApID8gdiA6IDAuNSAqIGludmVyc2VzcXJ0KCBtYXgoIDEuMCAtIHggKiB4LCAxZS03ICkgKSAtIHY7XFxuXFx0cmV0dXJuIGNyb3NzKCB2MSwgdjIgKSAqIHRoZXRhX3NpbnRoZXRhO1xcbn1cXG52ZWMzIExUQ19FdmFsdWF0ZSggY29uc3QgaW4gdmVjMyBOLCBjb25zdCBpbiB2ZWMzIFYsIGNvbnN0IGluIHZlYzMgUCwgY29uc3QgaW4gbWF0MyBtSW52LCBjb25zdCBpbiB2ZWMzIHJlY3RDb29yZHNbIDQgXSApIHtcXG5cXHR2ZWMzIHYxID0gcmVjdENvb3Jkc1sgMSBdIC0gcmVjdENvb3Jkc1sgMCBdO1xcblxcdHZlYzMgdjIgPSByZWN0Q29vcmRzWyAzIF0gLSByZWN0Q29vcmRzWyAwIF07XFxuXFx0dmVjMyBsaWdodE5vcm1hbCA9IGNyb3NzKCB2MSwgdjIgKTtcXG5cXHRpZiggZG90KCBsaWdodE5vcm1hbCwgUCAtIHJlY3RDb29yZHNbIDAgXSApIDwgMC4wICkgcmV0dXJuIHZlYzMoIDAuMCApO1xcblxcdHZlYzMgVDEsIFQyO1xcblxcdFQxID0gbm9ybWFsaXplKCBWIC0gTiAqIGRvdCggViwgTiApICk7XFxuXFx0VDIgPSAtIGNyb3NzKCBOLCBUMSApO1xcblxcdG1hdDMgbWF0ID0gbUludiAqIHRyYW5zcG9zZU1hdDMoIG1hdDMoIFQxLCBUMiwgTiApICk7XFxuXFx0dmVjMyBjb29yZHNbIDQgXTtcXG5cXHRjb29yZHNbIDAgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMCBdIC0gUCApO1xcblxcdGNvb3Jkc1sgMSBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAxIF0gLSBQICk7XFxuXFx0Y29vcmRzWyAyIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDIgXSAtIFAgKTtcXG5cXHRjb29yZHNbIDMgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMyBdIC0gUCApO1xcblxcdGNvb3Jkc1sgMCBdID0gbm9ybWFsaXplKCBjb29yZHNbIDAgXSApO1xcblxcdGNvb3Jkc1sgMSBdID0gbm9ybWFsaXplKCBjb29yZHNbIDEgXSApO1xcblxcdGNvb3Jkc1sgMiBdID0gbm9ybWFsaXplKCBjb29yZHNbIDIgXSApO1xcblxcdGNvb3Jkc1sgMyBdID0gbm9ybWFsaXplKCBjb29yZHNbIDMgXSApO1xcblxcdHZlYzMgdmVjdG9yRm9ybUZhY3RvciA9IHZlYzMoIDAuMCApO1xcblxcdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDAgXSwgY29vcmRzWyAxIF0gKTtcXG5cXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAxIF0sIGNvb3Jkc1sgMiBdICk7XFxuXFx0dmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMiBdLCBjb29yZHNbIDMgXSApO1xcblxcdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDMgXSwgY29vcmRzWyAwIF0gKTtcXG5cXHRmbG9hdCByZXN1bHQgPSBMVENfQ2xpcHBlZFNwaGVyZUZvcm1GYWN0b3IoIHZlY3RvckZvcm1GYWN0b3IgKTtcXG5cXHRyZXR1cm4gdmVjMyggcmVzdWx0ICk7XFxufVxcbiNpZiBkZWZpbmVkKCBVU0VfU0hFRU4gKVxcbmZsb2F0IERfQ2hhcmxpZSggZmxvYXQgcm91Z2huZXNzLCBmbG9hdCBkb3ROSCApIHtcXG5cXHRmbG9hdCBhbHBoYSA9IHBvdzIoIHJvdWdobmVzcyApO1xcblxcdGZsb2F0IGludkFscGhhID0gMS4wIC8gYWxwaGE7XFxuXFx0ZmxvYXQgY29zMmggPSBkb3ROSCAqIGRvdE5IO1xcblxcdGZsb2F0IHNpbjJoID0gbWF4KCAxLjAgLSBjb3MyaCwgMC4wMDc4MTI1ICk7XFxuXFx0cmV0dXJuICggMi4wICsgaW52QWxwaGEgKSAqIHBvdyggc2luMmgsIGludkFscGhhICogMC41ICkgLyAoIDIuMCAqIFBJICk7XFxufVxcbmZsb2F0IFZfTmV1YmVsdCggZmxvYXQgZG90TlYsIGZsb2F0IGRvdE5MICkge1xcblxcdHJldHVybiBzYXR1cmF0ZSggMS4wIC8gKCA0LjAgKiAoIGRvdE5MICsgZG90TlYgLSBkb3ROTCAqIGRvdE5WICkgKSApO1xcbn1cXG52ZWMzIEJSREZfU2hlZW4oIGNvbnN0IGluIHZlYzMgbGlnaHREaXIsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIHZlYzMgc2hlZW5Db2xvciwgY29uc3QgaW4gZmxvYXQgc2hlZW5Sb3VnaG5lc3MgKSB7XFxuXFx0dmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBsaWdodERpciArIHZpZXdEaXIgKTtcXG5cXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xcblxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTtcXG5cXHRmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaGFsZkRpciApICk7XFxuXFx0ZmxvYXQgRCA9IERfQ2hhcmxpZSggc2hlZW5Sb3VnaG5lc3MsIGRvdE5IICk7XFxuXFx0ZmxvYXQgViA9IFZfTmV1YmVsdCggZG90TlYsIGRvdE5MICk7XFxuXFx0cmV0dXJuIHNoZWVuQ29sb3IgKiAoIEQgKiBWICk7XFxufVxcbiNlbmRpZlxcbmZsb2F0IElCTFNoZWVuQlJERiggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTtcXG5cXHRmbG9hdCByMiA9IHJvdWdobmVzcyAqIHJvdWdobmVzcztcXG5cXHRmbG9hdCBhID0gcm91Z2huZXNzIDwgMC4yNSA/IC0zMzkuMiAqIHIyICsgMTYxLjQgKiByb3VnaG5lc3MgLSAyNS45IDogLTguNDggKiByMiArIDE0LjMgKiByb3VnaG5lc3MgLSA5Ljk1O1xcblxcdGZsb2F0IGIgPSByb3VnaG5lc3MgPCAwLjI1ID8gNDQuMCAqIHIyIC0gMjMuNyAqIHJvdWdobmVzcyArIDMuMjYgOiAxLjk3ICogcjIgLSAzLjI3ICogcm91Z2huZXNzICsgMC43MjtcXG5cXHRmbG9hdCBERyA9IGV4cCggYSAqIGRvdE5WICsgYiApICsgKCByb3VnaG5lc3MgPCAwLjI1ID8gMC4wIDogMC4xICogKCByb3VnaG5lc3MgLSAwLjI1ICkgKTtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIERHICogUkVDSVBST0NBTF9QSSApO1xcbn1cXG52ZWMyIERGR0FwcHJveCggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTtcXG5cXHRjb25zdCB2ZWM0IGMwID0gdmVjNCggLSAxLCAtIDAuMDI3NSwgLSAwLjU3MiwgMC4wMjIgKTtcXG5cXHRjb25zdCB2ZWM0IGMxID0gdmVjNCggMSwgMC4wNDI1LCAxLjA0LCAtIDAuMDQgKTtcXG5cXHR2ZWM0IHIgPSByb3VnaG5lc3MgKiBjMCArIGMxO1xcblxcdGZsb2F0IGEwMDQgPSBtaW4oIHIueCAqIHIueCwgZXhwMiggLSA5LjI4ICogZG90TlYgKSApICogci54ICsgci55O1xcblxcdHZlYzIgZmFiID0gdmVjMiggLSAxLjA0LCAxLjA0ICkgKiBhMDA0ICsgci56dztcXG5cXHRyZXR1cm4gZmFiO1xcbn1cXG52ZWMzIEVudmlyb25tZW50QlJERiggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdHZlYzIgZmFiID0gREZHQXBwcm94KCBub3JtYWwsIHZpZXdEaXIsIHJvdWdobmVzcyApO1xcblxcdHJldHVybiBzcGVjdWxhckNvbG9yICogZmFiLnggKyBzcGVjdWxhckY5MCAqIGZhYi55O1xcbn1cXG4jaWZkZWYgVVNFX0lSSURFU0NFTkNFXFxudm9pZCBjb21wdXRlTXVsdGlzY2F0dGVyaW5nSXJpZGVzY2VuY2UoIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc3BlY3VsYXJGOTAsIGNvbnN0IGluIGZsb2F0IGlyaWRlc2NlbmNlLCBjb25zdCBpbiB2ZWMzIGlyaWRlc2NlbmNlRjAsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgaW5vdXQgdmVjMyBzaW5nbGVTY2F0dGVyLCBpbm91dCB2ZWMzIG11bHRpU2NhdHRlciApIHtcXG4jZWxzZVxcbnZvaWQgY29tcHV0ZU11bHRpc2NhdHRlcmluZyggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBpbm91dCB2ZWMzIHNpbmdsZVNjYXR0ZXIsIGlub3V0IHZlYzMgbXVsdGlTY2F0dGVyICkge1xcbiNlbmRpZlxcblxcdHZlYzIgZmFiID0gREZHQXBwcm94KCBub3JtYWwsIHZpZXdEaXIsIHJvdWdobmVzcyApO1xcblxcdCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VcXG5cXHRcXHR2ZWMzIEZyID0gbWl4KCBzcGVjdWxhckNvbG9yLCBpcmlkZXNjZW5jZUYwLCBpcmlkZXNjZW5jZSApO1xcblxcdCNlbHNlXFxuXFx0XFx0dmVjMyBGciA9IHNwZWN1bGFyQ29sb3I7XFxuXFx0I2VuZGlmXFxuXFx0dmVjMyBGc3NFc3MgPSBGciAqIGZhYi54ICsgc3BlY3VsYXJGOTAgKiBmYWIueTtcXG5cXHRmbG9hdCBFc3MgPSBmYWIueCArIGZhYi55O1xcblxcdGZsb2F0IEVtcyA9IDEuMCAtIEVzcztcXG5cXHR2ZWMzIEZhdmcgPSBGciArICggMS4wIC0gRnIgKSAqIDAuMDQ3NjE5O1xcdHZlYzMgRm1zID0gRnNzRXNzICogRmF2ZyAvICggMS4wIC0gRW1zICogRmF2ZyApO1xcblxcdHNpbmdsZVNjYXR0ZXIgKz0gRnNzRXNzO1xcblxcdG11bHRpU2NhdHRlciArPSBGbXMgKiBFbXM7XFxufVxcbiNpZiBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDBcXG5cXHR2b2lkIFJFX0RpcmVjdF9SZWN0QXJlYV9QaHlzaWNhbCggY29uc3QgaW4gUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0LCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRcXHR2ZWMzIG5vcm1hbCA9IGdlb21ldHJ5Tm9ybWFsO1xcblxcdFxcdHZlYzMgdmlld0RpciA9IGdlb21ldHJ5Vmlld0RpcjtcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uID0gZ2VvbWV0cnlQb3NpdGlvbjtcXG5cXHRcXHR2ZWMzIGxpZ2h0UG9zID0gcmVjdEFyZWFMaWdodC5wb3NpdGlvbjtcXG5cXHRcXHR2ZWMzIGhhbGZXaWR0aCA9IHJlY3RBcmVhTGlnaHQuaGFsZldpZHRoO1xcblxcdFxcdHZlYzMgaGFsZkhlaWdodCA9IHJlY3RBcmVhTGlnaHQuaGFsZkhlaWdodDtcXG5cXHRcXHR2ZWMzIGxpZ2h0Q29sb3IgPSByZWN0QXJlYUxpZ2h0LmNvbG9yO1xcblxcdFxcdGZsb2F0IHJvdWdobmVzcyA9IG1hdGVyaWFsLnJvdWdobmVzcztcXG5cXHRcXHR2ZWMzIHJlY3RDb29yZHNbIDQgXTtcXG5cXHRcXHRyZWN0Q29vcmRzWyAwIF0gPSBsaWdodFBvcyArIGhhbGZXaWR0aCAtIGhhbGZIZWlnaHQ7XFx0XFx0cmVjdENvb3Jkc1sgMSBdID0gbGlnaHRQb3MgLSBoYWxmV2lkdGggLSBoYWxmSGVpZ2h0O1xcblxcdFxcdHJlY3RDb29yZHNbIDIgXSA9IGxpZ2h0UG9zIC0gaGFsZldpZHRoICsgaGFsZkhlaWdodDtcXG5cXHRcXHRyZWN0Q29vcmRzWyAzIF0gPSBsaWdodFBvcyArIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7XFxuXFx0XFx0dmVjMiB1diA9IExUQ19Vdiggbm9ybWFsLCB2aWV3RGlyLCByb3VnaG5lc3MgKTtcXG5cXHRcXHR2ZWM0IHQxID0gdGV4dHVyZTJEKCBsdGNfMSwgdXYgKTtcXG5cXHRcXHR2ZWM0IHQyID0gdGV4dHVyZTJEKCBsdGNfMiwgdXYgKTtcXG5cXHRcXHRtYXQzIG1JbnYgPSBtYXQzKFxcblxcdFxcdFxcdHZlYzMoIHQxLngsIDAsIHQxLnkgKSxcXG5cXHRcXHRcXHR2ZWMzKCAgICAwLCAxLCAgICAwICksXFxuXFx0XFx0XFx0dmVjMyggdDEueiwgMCwgdDEudyApXFxuXFx0XFx0KTtcXG5cXHRcXHR2ZWMzIGZyZXNuZWwgPSAoIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgKiB0Mi54ICsgKCB2ZWMzKCAxLjAgKSAtIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgKSAqIHQyLnkgKTtcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBsaWdodENvbG9yICogZnJlc25lbCAqIExUQ19FdmFsdWF0ZSggbm9ybWFsLCB2aWV3RGlyLCBwb3NpdGlvbiwgbUludiwgcmVjdENvb3JkcyApO1xcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gbGlnaHRDb2xvciAqIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciAqIExUQ19FdmFsdWF0ZSggbm9ybWFsLCB2aWV3RGlyLCBwb3NpdGlvbiwgbWF0MyggMS4wICksIHJlY3RDb29yZHMgKTtcXG5cXHR9XFxuI2VuZGlmXFxudm9pZCBSRV9EaXJlY3RfUGh5c2ljYWwoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnlOb3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICk7XFxuXFx0dmVjMyBpcnJhZGlhbmNlID0gZG90TkwgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHQjaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdFxcdGZsb2F0IGRvdE5MY2MgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTtcXG5cXHRcXHR2ZWMzIGNjSXJyYWRpYW5jZSA9IGRvdE5MY2MgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHRcXHRjbGVhcmNvYXRTcGVjdWxhckRpcmVjdCArPSBjY0lycmFkaWFuY2UgKiBCUkRGX0dHWF9DbGVhcmNvYXQoIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwgKTtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX1NIRUVOXFxuXFx0XFx0c2hlZW5TcGVjdWxhckRpcmVjdCArPSBpcnJhZGlhbmNlICogQlJERl9TaGVlbiggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Tm9ybWFsLCBtYXRlcmlhbC5zaGVlbkNvbG9yLCBtYXRlcmlhbC5zaGVlblJvdWdobmVzcyApO1xcblxcdCNlbmRpZlxcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBCUkRGX0dHWCggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Tm9ybWFsLCBtYXRlcmlhbCApO1xcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxufVxcbnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX1BoeXNpY2FsKCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG59XFxudm9pZCBSRV9JbmRpcmVjdFNwZWN1bGFyX1BoeXNpY2FsKCBjb25zdCBpbiB2ZWMzIHJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgY2xlYXJjb2F0UmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0KSB7XFxuXFx0I2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHRcXHRjbGVhcmNvYXRTcGVjdWxhckluZGlyZWN0ICs9IGNsZWFyY29hdFJhZGlhbmNlICogRW52aXJvbm1lbnRCUkRGKCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBtYXRlcmlhbC5jbGVhcmNvYXRGMCwgbWF0ZXJpYWwuY2xlYXJjb2F0RjkwLCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgKTtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX1NIRUVOXFxuXFx0XFx0c2hlZW5TcGVjdWxhckluZGlyZWN0ICs9IGlycmFkaWFuY2UgKiBtYXRlcmlhbC5zaGVlbkNvbG9yICogSUJMU2hlZW5CUkRGKCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBtYXRlcmlhbC5zaGVlblJvdWdobmVzcyApO1xcblxcdCNlbmRpZlxcblxcdHZlYzMgc2luZ2xlU2NhdHRlcmluZyA9IHZlYzMoIDAuMCApO1xcblxcdHZlYzMgbXVsdGlTY2F0dGVyaW5nID0gdmVjMyggMC4wICk7XFxuXFx0dmVjMyBjb3NpbmVXZWlnaHRlZElycmFkaWFuY2UgPSBpcnJhZGlhbmNlICogUkVDSVBST0NBTF9QSTtcXG5cXHQjaWZkZWYgVVNFX0lSSURFU0NFTkNFXFxuXFx0XFx0Y29tcHV0ZU11bHRpc2NhdHRlcmluZ0lyaWRlc2NlbmNlKCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCwgbWF0ZXJpYWwuaXJpZGVzY2VuY2UsIG1hdGVyaWFsLmlyaWRlc2NlbmNlRnJlc25lbCwgbWF0ZXJpYWwucm91Z2huZXNzLCBzaW5nbGVTY2F0dGVyaW5nLCBtdWx0aVNjYXR0ZXJpbmcgKTtcXG5cXHQjZWxzZVxcblxcdFxcdGNvbXB1dGVNdWx0aXNjYXR0ZXJpbmcoIGdlb21ldHJ5Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyRjkwLCBtYXRlcmlhbC5yb3VnaG5lc3MsIHNpbmdsZVNjYXR0ZXJpbmcsIG11bHRpU2NhdHRlcmluZyApO1xcblxcdCNlbmRpZlxcblxcdHZlYzMgdG90YWxTY2F0dGVyaW5nID0gc2luZ2xlU2NhdHRlcmluZyArIG11bHRpU2NhdHRlcmluZztcXG5cXHR2ZWMzIGRpZmZ1c2UgPSBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKiAoIDEuMCAtIG1heCggbWF4KCB0b3RhbFNjYXR0ZXJpbmcuciwgdG90YWxTY2F0dGVyaW5nLmcgKSwgdG90YWxTY2F0dGVyaW5nLmIgKSApO1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKz0gcmFkaWFuY2UgKiBzaW5nbGVTY2F0dGVyaW5nO1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKz0gbXVsdGlTY2F0dGVyaW5nICogY29zaW5lV2VpZ2h0ZWRJcnJhZGlhbmNlO1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBkaWZmdXNlICogY29zaW5lV2VpZ2h0ZWRJcnJhZGlhbmNlO1xcbn1cXG4jZGVmaW5lIFJFX0RpcmVjdFxcdFxcdFxcdFxcdFJFX0RpcmVjdF9QaHlzaWNhbFxcbiNkZWZpbmUgUkVfRGlyZWN0X1JlY3RBcmVhXFx0XFx0UkVfRGlyZWN0X1JlY3RBcmVhX1BoeXNpY2FsXFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcXHRcXHRSRV9JbmRpcmVjdERpZmZ1c2VfUGh5c2ljYWxcXG4jZGVmaW5lIFJFX0luZGlyZWN0U3BlY3VsYXJcXHRcXHRSRV9JbmRpcmVjdFNwZWN1bGFyX1BoeXNpY2FsXFxuZmxvYXQgY29tcHV0ZVNwZWN1bGFyT2NjbHVzaW9uKCBjb25zdCBpbiBmbG9hdCBkb3ROViwgY29uc3QgaW4gZmxvYXQgYW1iaWVudE9jY2x1c2lvbiwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdHJldHVybiBzYXR1cmF0ZSggcG93KCBkb3ROViArIGFtYmllbnRPY2NsdXNpb24sIGV4cDIoIC0gMTYuMCAqIHJvdWdobmVzcyAtIDEuMCApICkgLSAxLjAgKyBhbWJpZW50T2NjbHVzaW9uICk7XFxufVwiO1xuXG52YXIgbGlnaHRzX2ZyYWdtZW50X2JlZ2luID0gXCJcXG52ZWMzIGdlb21ldHJ5UG9zaXRpb24gPSAtIHZWaWV3UG9zaXRpb247XFxudmVjMyBnZW9tZXRyeU5vcm1hbCA9IG5vcm1hbDtcXG52ZWMzIGdlb21ldHJ5Vmlld0RpciA9ICggaXNPcnRob2dyYXBoaWMgKSA/IHZlYzMoIDAsIDAsIDEgKSA6IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1xcbnZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwgPSB2ZWMzKCAwLjAgKTtcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsID0gY2xlYXJjb2F0Tm9ybWFsO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VcXG5cXHRmbG9hdCBkb3ROVmkgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGdlb21ldHJ5Vmlld0RpciApICk7XFxuXFx0aWYgKCBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzcyA9PSAwLjAgKSB7XFxuXFx0XFx0bWF0ZXJpYWwuaXJpZGVzY2VuY2UgPSAwLjA7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHRtYXRlcmlhbC5pcmlkZXNjZW5jZSA9IHNhdHVyYXRlKCBtYXRlcmlhbC5pcmlkZXNjZW5jZSApO1xcblxcdH1cXG5cXHRpZiAoIG1hdGVyaWFsLmlyaWRlc2NlbmNlID4gMC4wICkge1xcblxcdFxcdG1hdGVyaWFsLmlyaWRlc2NlbmNlRnJlc25lbCA9IGV2YWxJcmlkZXNjZW5jZSggMS4wLCBtYXRlcmlhbC5pcmlkZXNjZW5jZUlPUiwgZG90TlZpLCBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzcywgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciApO1xcblxcdFxcdG1hdGVyaWFsLmlyaWRlc2NlbmNlRjAgPSBTY2hsaWNrX3RvX0YwKCBtYXRlcmlhbC5pcmlkZXNjZW5jZUZyZXNuZWwsIDEuMCwgZG90TlZpICk7XFxuXFx0fVxcbiNlbmRpZlxcbkluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7XFxuI2lmICggTlVNX1BPSU5UX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxcblxcdFBvaW50TGlnaHQgcG9pbnRMaWdodDtcXG5cXHQjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFBvaW50TGlnaHRTaGFkb3cgcG9pbnRMaWdodFNoYWRvdztcXG5cXHQjZW5kaWZcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRwb2ludExpZ2h0ID0gcG9pbnRMaWdodHNbIGkgXTtcXG5cXHRcXHRnZXRQb2ludExpZ2h0SW5mbyggcG9pbnRMaWdodCwgZ2VvbWV0cnlQb3NpdGlvbiwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHQjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmICggVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIClcXG5cXHRcXHRwb2ludExpZ2h0U2hhZG93ID0gcG9pbnRMaWdodFNoYWRvd3NbIGkgXTtcXG5cXHRcXHRkaXJlY3RMaWdodC5jb2xvciAqPSAoIGRpcmVjdExpZ2h0LnZpc2libGUgJiYgcmVjZWl2ZVNoYWRvdyApID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dJbnRlbnNpdHksIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93QmlhcywgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dSYWRpdXMsIHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0sIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93Q2FtZXJhTmVhciwgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dDYW1lcmFGYXIgKSA6IDEuMDtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeVBvc2l0aW9uLCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuI2VuZGlmXFxuI2lmICggTlVNX1NQT1RfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXFx0U3BvdExpZ2h0IHNwb3RMaWdodDtcXG5cXHR2ZWM0IHNwb3RDb2xvcjtcXG5cXHR2ZWMzIHNwb3RMaWdodENvb3JkO1xcblxcdGJvb2wgaW5TcG90TGlnaHRNYXA7XFxuXFx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiBOVU1fU1BPVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHRTaGFkb3c7XFxuXFx0I2VuZGlmXFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRzcG90TGlnaHQgPSBzcG90TGlnaHRzWyBpIF07XFxuXFx0XFx0Z2V0U3BvdExpZ2h0SW5mbyggc3BvdExpZ2h0LCBnZW9tZXRyeVBvc2l0aW9uLCBkaXJlY3RMaWdodCApO1xcblxcdFxcdCNpZiAoIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTX1dJVEhfTUFQUyApXFxuXFx0XFx0I2RlZmluZSBTUE9UX0xJR0hUX01BUF9JTkRFWCBVTlJPTExFRF9MT09QX0lOREVYXFxuXFx0XFx0I2VsaWYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyApXFxuXFx0XFx0I2RlZmluZSBTUE9UX0xJR0hUX01BUF9JTkRFWCBOVU1fU1BPVF9MSUdIVF9NQVBTXFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHQjZGVmaW5lIFNQT1RfTElHSFRfTUFQX0lOREVYICggVU5ST0xMRURfTE9PUF9JTkRFWCAtIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgKyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTX1dJVEhfTUFQUyApXFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0I2lmICggU1BPVF9MSUdIVF9NQVBfSU5ERVggPCBOVU1fU1BPVF9MSUdIVF9NQVBTIClcXG5cXHRcXHRcXHRzcG90TGlnaHRDb29yZCA9IHZTcG90TGlnaHRDb29yZFsgaSBdLnh5eiAvIHZTcG90TGlnaHRDb29yZFsgaSBdLnc7XFxuXFx0XFx0XFx0aW5TcG90TGlnaHRNYXAgPSBhbGwoIGxlc3NUaGFuKCBhYnMoIHNwb3RMaWdodENvb3JkICogMi4gLSAxLiApLCB2ZWMzKCAxLjAgKSApICk7XFxuXFx0XFx0XFx0c3BvdENvbG9yID0gdGV4dHVyZTJEKCBzcG90TGlnaHRNYXBbIFNQT1RfTElHSFRfTUFQX0lOREVYIF0sIHNwb3RMaWdodENvb3JkLnh5ICk7XFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgPSBpblNwb3RMaWdodE1hcCA/IGRpcmVjdExpZ2h0LmNvbG9yICogc3BvdENvbG9yLnJnYiA6IGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdCN1bmRlZiBTUE9UX0xJR0hUX01BUF9JTkRFWFxcblxcdFxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyApXFxuXFx0XFx0c3BvdExpZ2h0U2hhZG93ID0gc3BvdExpZ2h0U2hhZG93c1sgaSBdO1xcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9ICggZGlyZWN0TGlnaHQudmlzaWJsZSAmJiByZWNlaXZlU2hhZG93ICkgPyBnZXRTaGFkb3coIHNwb3RTaGFkb3dNYXBbIGkgXSwgc3BvdExpZ2h0U2hhZG93LnNoYWRvd01hcFNpemUsIHNwb3RMaWdodFNoYWRvdy5zaGFkb3dJbnRlbnNpdHksIHNwb3RMaWdodFNoYWRvdy5zaGFkb3dCaWFzLCBzcG90TGlnaHRTaGFkb3cuc2hhZG93UmFkaXVzLCB2U3BvdExpZ2h0Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdFJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5UG9zaXRpb24sIGdlb21ldHJ5Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG4jZW5kaWZcXG4jaWYgKCBOVU1fRElSX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxcblxcdERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodDtcXG5cXHQjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHREaXJlY3Rpb25hbExpZ2h0U2hhZG93IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3c7XFxuXFx0I2VuZGlmXFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcblxcdFxcdGRpcmVjdGlvbmFsTGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0c1sgaSBdO1xcblxcdFxcdGdldERpcmVjdGlvbmFsTGlnaHRJbmZvKCBkaXJlY3Rpb25hbExpZ2h0LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX0RJUl9MSUdIVF9TSEFET1dTIClcXG5cXHRcXHRkaXJlY3Rpb25hbExpZ2h0U2hhZG93ID0gZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIGkgXTtcXG5cXHRcXHRkaXJlY3RMaWdodC5jb2xvciAqPSAoIGRpcmVjdExpZ2h0LnZpc2libGUgJiYgcmVjZWl2ZVNoYWRvdyApID8gZ2V0U2hhZG93KCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgaSBdLCBkaXJlY3Rpb25hbExpZ2h0U2hhZG93LnNoYWRvd01hcFNpemUsIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3cuc2hhZG93SW50ZW5zaXR5LCBkaXJlY3Rpb25hbExpZ2h0U2hhZG93LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3cuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnlQb3NpdGlvbiwgZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcbiNlbmRpZlxcbiNpZiAoIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdF9SZWN0QXJlYSApXFxuXFx0UmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0O1xcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUkVDVF9BUkVBX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRyZWN0QXJlYUxpZ2h0ID0gcmVjdEFyZWFMaWdodHNbIGkgXTtcXG5cXHRcXHRSRV9EaXJlY3RfUmVjdEFyZWEoIHJlY3RBcmVhTGlnaHQsIGdlb21ldHJ5UG9zaXRpb24sIGdlb21ldHJ5Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggUkVfSW5kaXJlY3REaWZmdXNlIClcXG5cXHR2ZWMzIGlibElycmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcblxcdCNpZiBkZWZpbmVkKCBVU0VfTElHSFRfUFJPQkVTIClcXG5cXHRcXHRpcnJhZGlhbmNlICs9IGdldExpZ2h0UHJvYmVJcnJhZGlhbmNlKCBsaWdodFByb2JlLCBnZW9tZXRyeU5vcm1hbCApO1xcblxcdCNlbmRpZlxcblxcdCNpZiAoIE5VTV9IRU1JX0xJR0hUUyA+IDAgKVxcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0XFx0aXJyYWRpYW5jZSArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGdlb21ldHJ5Tm9ybWFsICk7XFxuXFx0XFx0fVxcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0U3BlY3VsYXIgKVxcblxcdHZlYzMgcmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWMzIGNsZWFyY29hdFJhZGlhbmNlID0gdmVjMyggMC4wICk7XFxuI2VuZGlmXCI7XG5cbnZhciBsaWdodHNfZnJhZ21lbnRfbWFwcyA9IFwiI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApXFxuXFx0I2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdFxcdHZlYzQgbGlnaHRNYXBUZXhlbCA9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZMaWdodE1hcFV2ICk7XFxuXFx0XFx0dmVjMyBsaWdodE1hcElycmFkaWFuY2UgPSBsaWdodE1hcFRleGVsLnJnYiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcdFxcdGlycmFkaWFuY2UgKz0gbGlnaHRNYXBJcnJhZGlhbmNlO1xcblxcdCNlbmRpZlxcblxcdCNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggU1RBTkRBUkQgKSAmJiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHRcXHRpYmxJcnJhZGlhbmNlICs9IGdldElCTElycmFkaWFuY2UoIGdlb21ldHJ5Tm9ybWFsICk7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBSRV9JbmRpcmVjdFNwZWN1bGFyIClcXG5cXHQjaWZkZWYgVVNFX0FOSVNPVFJPUFlcXG5cXHRcXHRyYWRpYW5jZSArPSBnZXRJQkxBbmlzb3Ryb3B5UmFkaWFuY2UoIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlOb3JtYWwsIG1hdGVyaWFsLnJvdWdobmVzcywgbWF0ZXJpYWwuYW5pc290cm9weUIsIG1hdGVyaWFsLmFuaXNvdHJvcHkgKTtcXG5cXHQjZWxzZVxcblxcdFxcdHJhZGlhbmNlICs9IGdldElCTFJhZGlhbmNlKCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Tm9ybWFsLCBtYXRlcmlhbC5yb3VnaG5lc3MgKTtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdFxcdGNsZWFyY29hdFJhZGlhbmNlICs9IGdldElCTFJhZGlhbmNlKCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxudmFyIGxpZ2h0c19mcmFnbWVudF9lbmQgPSBcIiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdERpZmZ1c2UgKVxcblxcdFJFX0luZGlyZWN0RGlmZnVzZSggaXJyYWRpYW5jZSwgZ2VvbWV0cnlQb3NpdGlvbiwgZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdFNwZWN1bGFyIClcXG5cXHRSRV9JbmRpcmVjdFNwZWN1bGFyKCByYWRpYW5jZSwgaWJsSXJyYWRpYW5jZSwgY2xlYXJjb2F0UmFkaWFuY2UsIGdlb21ldHJ5UG9zaXRpb24sIGdlb21ldHJ5Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG4jZW5kaWZcIjtcblxudmFyIGxvZ2RlcHRoYnVmX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX0xPR0RFUFRIQlVGIClcXG5cXHRnbF9GcmFnRGVwdGggPSB2SXNQZXJzcGVjdGl2ZSA9PSAwLjAgPyBnbF9GcmFnQ29vcmQueiA6IGxvZzIoIHZGcmFnRGVwdGggKSAqIGxvZ0RlcHRoQnVmRkMgKiAwLjU7XFxuI2VuZGlmXCI7XG5cbnZhciBsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX0xPR0RFUFRIQlVGIClcXG5cXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcdHZhcnlpbmcgZmxvYXQgdklzUGVyc3BlY3RpdmU7XFxuI2VuZGlmXCI7XG5cbnZhciBsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXHR2YXJ5aW5nIGZsb2F0IHZJc1BlcnNwZWN0aXZlO1xcbiNlbmRpZlwiO1xuXG52YXIgbG9nZGVwdGhidWZfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFx0dkZyYWdEZXB0aCA9IDEuMCArIGdsX1Bvc2l0aW9uLnc7XFxuXFx0dklzUGVyc3BlY3RpdmUgPSBmbG9hdCggaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApICk7XFxuI2VuZGlmXCI7XG5cbnZhciBtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFx0dmVjNCBzYW1wbGVkRGlmZnVzZUNvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZNYXBVdiApO1xcblxcdCNpZmRlZiBERUNPREVfVklERU9fVEVYVFVSRVxcblxcdFxcdHNhbXBsZWREaWZmdXNlQ29sb3IgPSBzUkdCVHJhbnNmZXJFT1RGKCBzYW1wbGVkRGlmZnVzZUNvbG9yICk7XFxuXFx0I2VuZGlmXFxuXFx0ZGlmZnVzZUNvbG9yICo9IHNhbXBsZWREaWZmdXNlQ29sb3I7XFxuI2VuZGlmXCI7XG5cbnZhciBtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxuI2VuZGlmXCI7XG5cbnZhciBtYXBfcGFydGljbGVfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQIClcXG5cXHQjaWYgZGVmaW5lZCggVVNFX1BPSU5UU19VViApXFxuXFx0XFx0dmVjMiB1diA9IHZVdjtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzIgdXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggZ2xfUG9pbnRDb29yZC54LCAxLjAgLSBnbF9Qb2ludENvb3JkLnksIDEgKSApLnh5O1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTUFQXFxuXFx0ZGlmZnVzZUNvbG9yICo9IHRleHR1cmUyRCggbWFwLCB1diApO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXHRkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB1diApLmc7XFxuI2VuZGlmXCI7XG5cbnZhciBtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9QT0lOVFNfVVYgKVxcblxcdHZhcnlpbmcgdmVjMiB2VXY7XFxuI2Vsc2VcXG5cXHQjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApXFxuXFx0XFx0dW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBhbHBoYU1hcDtcXG4jZW5kaWZcIjtcblxudmFyIG1ldGFsbmVzc21hcF9mcmFnbWVudCA9IFwiZmxvYXQgbWV0YWxuZXNzRmFjdG9yID0gbWV0YWxuZXNzO1xcbiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQXFxuXFx0dmVjNCB0ZXhlbE1ldGFsbmVzcyA9IHRleHR1cmUyRCggbWV0YWxuZXNzTWFwLCB2TWV0YWxuZXNzTWFwVXYgKTtcXG5cXHRtZXRhbG5lc3NGYWN0b3IgKj0gdGV4ZWxNZXRhbG5lc3MuYjtcXG4jZW5kaWZcIjtcblxudmFyIG1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX01FVEFMTkVTU01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG1ldGFsbmVzc01hcDtcXG4jZW5kaWZcIjtcblxudmFyIG1vcnBoaW5zdGFuY2VfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0lOU1RBTkNJTkdfTU9SUEhcXG5cXHRmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIE1PUlBIVEFSR0VUU19DT1VOVCBdO1xcblxcdGZsb2F0IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZSA9IHRleGVsRmV0Y2goIG1vcnBoVGV4dHVyZSwgaXZlYzIoIDAsIGdsX0luc3RhbmNlSUQgKSwgMCApLnI7XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTU9SUEhUQVJHRVRTX0NPVU5UOyBpICsrICkge1xcblxcdFxcdG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tpXSA9ICB0ZXhlbEZldGNoKCBtb3JwaFRleHR1cmUsIGl2ZWMyKCBpICsgMSwgZ2xfSW5zdGFuY2VJRCApLCAwICkucjtcXG5cXHR9XFxuI2VuZGlmXCI7XG5cbnZhciBtb3JwaGNvbG9yX3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9NT1JQSENPTE9SUyApXFxuXFx0dkNvbG9yICo9IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZTtcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7XFxuXFx0XFx0I2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApXFxuXFx0XFx0XFx0aWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSAhPSAwLjAgKSB2Q29sb3IgKz0gZ2V0TW9ycGgoIGdsX1ZlcnRleElELCBpLCAyICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKVxcblxcdFxcdFxcdGlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gIT0gMC4wICkgdkNvbG9yICs9IGdldE1vcnBoKCBnbF9WZXJ0ZXhJRCwgaSwgMiApLnJnYiAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG4jZW5kaWZcIjtcblxudmFyIG1vcnBobm9ybWFsX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXHRvYmplY3ROb3JtYWwgKj0gbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlO1xcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE1PUlBIVEFSR0VUU19DT1VOVDsgaSArKyApIHtcXG5cXHRcXHRpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdICE9IDAuMCApIG9iamVjdE5vcm1hbCArPSBnZXRNb3JwaCggZ2xfVmVydGV4SUQsIGksIDEgKS54eXogKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcXG5cXHR9XFxuI2VuZGlmXCI7XG5cbnZhciBtb3JwaHRhcmdldF9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcXG5cXHQjaWZuZGVmIFVTRV9JTlNUQU5DSU5HX01PUlBIXFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2U7XFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIE1PUlBIVEFSR0VUU19DT1VOVCBdO1xcblxcdCNlbmRpZlxcblxcdHVuaWZvcm0gc2FtcGxlcjJEQXJyYXkgbW9ycGhUYXJnZXRzVGV4dHVyZTtcXG5cXHR1bmlmb3JtIGl2ZWMyIG1vcnBoVGFyZ2V0c1RleHR1cmVTaXplO1xcblxcdHZlYzQgZ2V0TW9ycGgoIGNvbnN0IGluIGludCB2ZXJ0ZXhJbmRleCwgY29uc3QgaW4gaW50IG1vcnBoVGFyZ2V0SW5kZXgsIGNvbnN0IGluIGludCBvZmZzZXQgKSB7XFxuXFx0XFx0aW50IHRleGVsSW5kZXggPSB2ZXJ0ZXhJbmRleCAqIE1PUlBIVEFSR0VUU19URVhUVVJFX1NUUklERSArIG9mZnNldDtcXG5cXHRcXHRpbnQgeSA9IHRleGVsSW5kZXggLyBtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZS54O1xcblxcdFxcdGludCB4ID0gdGV4ZWxJbmRleCAtIHkgKiBtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZS54O1xcblxcdFxcdGl2ZWMzIG1vcnBoVVYgPSBpdmVjMyggeCwgeSwgbW9ycGhUYXJnZXRJbmRleCApO1xcblxcdFxcdHJldHVybiB0ZXhlbEZldGNoKCBtb3JwaFRhcmdldHNUZXh0dXJlLCBtb3JwaFVWLCAwICk7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG52YXIgbW9ycGh0YXJnZXRfdmVydGV4ID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcdHRyYW5zZm9ybWVkICo9IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZTtcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7XFxuXFx0XFx0aWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSAhPSAwLjAgKSB0cmFuc2Zvcm1lZCArPSBnZXRNb3JwaCggZ2xfVmVydGV4SUQsIGksIDAgKS54eXogKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcXG5cXHR9XFxuI2VuZGlmXCI7XG5cbnZhciBub3JtYWxfZnJhZ21lbnRfYmVnaW4gPSBcImZsb2F0IGZhY2VEaXJlY3Rpb24gPSBnbF9Gcm9udEZhY2luZyA/IDEuMCA6IC0gMS4wO1xcbiNpZmRlZiBGTEFUX1NIQURFRFxcblxcdHZlYzMgZmR4ID0gZEZkeCggdlZpZXdQb3NpdGlvbiApO1xcblxcdHZlYzMgZmR5ID0gZEZkeSggdlZpZXdQb3NpdGlvbiApO1xcblxcdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggZmR4LCBmZHkgKSApO1xcbiNlbHNlXFxuXFx0dmVjMyBub3JtYWwgPSBub3JtYWxpemUoIHZOb3JtYWwgKTtcXG5cXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0bm9ybWFsICo9IGZhY2VEaXJlY3Rpb247XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFICkgfHwgZGVmaW5lZCggVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU5JU09UUk9QWSApXFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0bWF0MyB0Ym4gPSBtYXQzKCBub3JtYWxpemUoIHZUYW5nZW50ICksIG5vcm1hbGl6ZSggdkJpdGFuZ2VudCApLCBub3JtYWwgKTtcXG5cXHQjZWxzZVxcblxcdFxcdG1hdDMgdGJuID0gZ2V0VGFuZ2VudEZyYW1lKCAtIHZWaWV3UG9zaXRpb24sIG5vcm1hbCxcXG5cXHRcXHQjaWYgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApXFxuXFx0XFx0XFx0dk5vcm1hbE1hcFV2XFxuXFx0XFx0I2VsaWYgZGVmaW5lZCggVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAgKVxcblxcdFxcdFxcdHZDbGVhcmNvYXROb3JtYWxNYXBVdlxcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0dlV2XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0KTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgZGVmaW5lZCggRE9VQkxFX1NJREVEICkgJiYgISBkZWZpbmVkKCBGTEFUX1NIQURFRCApXFxuXFx0XFx0dGJuWzBdICo9IGZhY2VEaXJlY3Rpb247XFxuXFx0XFx0dGJuWzFdICo9IGZhY2VEaXJlY3Rpb247XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQXFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0bWF0MyB0Ym4yID0gbWF0Myggbm9ybWFsaXplKCB2VGFuZ2VudCApLCBub3JtYWxpemUoIHZCaXRhbmdlbnQgKSwgbm9ybWFsICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRtYXQzIHRibjIgPSBnZXRUYW5nZW50RnJhbWUoIC0gdlZpZXdQb3NpdGlvbiwgbm9ybWFsLCB2Q2xlYXJjb2F0Tm9ybWFsTWFwVXYgKTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgZGVmaW5lZCggRE9VQkxFX1NJREVEICkgJiYgISBkZWZpbmVkKCBGTEFUX1NIQURFRCApXFxuXFx0XFx0dGJuMlswXSAqPSBmYWNlRGlyZWN0aW9uO1xcblxcdFxcdHRibjJbMV0gKj0gZmFjZURpcmVjdGlvbjtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG52ZWMzIG5vblBlcnR1cmJlZE5vcm1hbCA9IG5vcm1hbDtcIjtcblxudmFyIG5vcm1hbF9mcmFnbWVudF9tYXBzID0gXCIjaWZkZWYgVVNFX05PUk1BTE1BUF9PQkpFQ1RTUEFDRVxcblxcdG5vcm1hbCA9IHRleHR1cmUyRCggbm9ybWFsTWFwLCB2Tm9ybWFsTWFwVXYgKS54eXogKiAyLjAgLSAxLjA7XFxuXFx0I2lmZGVmIEZMSVBfU0lERURcXG5cXHRcXHRub3JtYWwgPSAtIG5vcm1hbDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0bm9ybWFsID0gbm9ybWFsICogZmFjZURpcmVjdGlvbjtcXG5cXHQjZW5kaWZcXG5cXHRub3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApO1xcbiNlbGlmIGRlZmluZWQoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFIClcXG5cXHR2ZWMzIG1hcE4gPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdk5vcm1hbE1hcFV2ICkueHl6ICogMi4wIC0gMS4wO1xcblxcdG1hcE4ueHkgKj0gbm9ybWFsU2NhbGU7XFxuXFx0bm9ybWFsID0gbm9ybWFsaXplKCB0Ym4gKiBtYXBOICk7XFxuI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVxcblxcdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWxBcmIoIC0gdlZpZXdQb3NpdGlvbiwgbm9ybWFsLCBkSGR4eV9md2QoKSwgZmFjZURpcmVjdGlvbiApO1xcbiNlbmRpZlwiO1xuXG52YXIgbm9ybWFsX3BhcnNfZnJhZ21lbnQgPSBcIiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXHQjaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7XFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZCaXRhbmdlbnQ7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBub3JtYWxfcGFyc192ZXJ0ZXggPSBcIiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXHQjaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7XFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZCaXRhbmdlbnQ7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBub3JtYWxfdmVydGV4ID0gXCIjaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXG5cXHQjaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHRcXHR2VGFuZ2VudCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWRUYW5nZW50ICk7XFxuXFx0XFx0dkJpdGFuZ2VudCA9IG5vcm1hbGl6ZSggY3Jvc3MoIHZOb3JtYWwsIHZUYW5nZW50ICkgKiB0YW5nZW50LncgKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxudmFyIG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG5vcm1hbE1hcDtcXG5cXHR1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9OT1JNQUxNQVBfT0JKRUNUU1BBQ0VcXG5cXHR1bmlmb3JtIG1hdDMgbm9ybWFsTWF0cml4O1xcbiNlbmRpZlxcbiNpZiAhIGRlZmluZWQgKCBVU0VfVEFOR0VOVCApICYmICggZGVmaW5lZCAoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFICkgfHwgZGVmaW5lZCAoIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX0FOSVNPVFJPUFkgKSApXFxuXFx0bWF0MyBnZXRUYW5nZW50RnJhbWUoIHZlYzMgZXllX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgdXYgKSB7XFxuXFx0XFx0dmVjMyBxMCA9IGRGZHgoIGV5ZV9wb3MueHl6ICk7XFxuXFx0XFx0dmVjMyBxMSA9IGRGZHkoIGV5ZV9wb3MueHl6ICk7XFxuXFx0XFx0dmVjMiBzdDAgPSBkRmR4KCB1di5zdCApO1xcblxcdFxcdHZlYzIgc3QxID0gZEZkeSggdXYuc3QgKTtcXG5cXHRcXHR2ZWMzIE4gPSBzdXJmX25vcm07XFxuXFx0XFx0dmVjMyBxMXBlcnAgPSBjcm9zcyggcTEsIE4gKTtcXG5cXHRcXHR2ZWMzIHEwcGVycCA9IGNyb3NzKCBOLCBxMCApO1xcblxcdFxcdHZlYzMgVCA9IHExcGVycCAqIHN0MC54ICsgcTBwZXJwICogc3QxLng7XFxuXFx0XFx0dmVjMyBCID0gcTFwZXJwICogc3QwLnkgKyBxMHBlcnAgKiBzdDEueTtcXG5cXHRcXHRmbG9hdCBkZXQgPSBtYXgoIGRvdCggVCwgVCApLCBkb3QoIEIsIEIgKSApO1xcblxcdFxcdGZsb2F0IHNjYWxlID0gKCBkZXQgPT0gMC4wICkgPyAwLjAgOiBpbnZlcnNlc3FydCggZGV0ICk7XFxuXFx0XFx0cmV0dXJuIG1hdDMoIFQgKiBzY2FsZSwgQiAqIHNjYWxlLCBOICk7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG52YXIgY2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbiA9IFwiI2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHR2ZWMzIGNsZWFyY29hdE5vcm1hbCA9IG5vblBlcnR1cmJlZE5vcm1hbDtcXG4jZW5kaWZcIjtcblxudmFyIGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfbWFwcyA9IFwiI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQXFxuXFx0dmVjMyBjbGVhcmNvYXRNYXBOID0gdGV4dHVyZTJEKCBjbGVhcmNvYXROb3JtYWxNYXAsIHZDbGVhcmNvYXROb3JtYWxNYXBVdiApLnh5eiAqIDIuMCAtIDEuMDtcXG5cXHRjbGVhcmNvYXRNYXBOLnh5ICo9IGNsZWFyY29hdE5vcm1hbFNjYWxlO1xcblxcdGNsZWFyY29hdE5vcm1hbCA9IG5vcm1hbGl6ZSggdGJuMiAqIGNsZWFyY29hdE1hcE4gKTtcXG4jZW5kaWZcIjtcblxudmFyIGNsZWFyY29hdF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0NMRUFSQ09BVE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGNsZWFyY29hdE1hcDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBjbGVhcmNvYXROb3JtYWxNYXA7XFxuXFx0dW5pZm9ybSB2ZWMyIGNsZWFyY29hdE5vcm1hbFNjYWxlO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGNsZWFyY29hdFJvdWdobmVzc01hcDtcXG4jZW5kaWZcIjtcblxudmFyIGlyaWRlc2NlbmNlX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBpcmlkZXNjZW5jZU1hcDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwO1xcbiNlbmRpZlwiO1xuXG52YXIgb3BhcXVlX2ZyYWdtZW50ID0gXCIjaWZkZWYgT1BBUVVFXFxuZGlmZnVzZUNvbG9yLmEgPSAxLjA7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cXG5kaWZmdXNlQ29sb3IuYSAqPSBtYXRlcmlhbC50cmFuc21pc3Npb25BbHBoYTtcXG4jZW5kaWZcXG5nbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiO1xuXG52YXIgcGFja2luZyA9IFwidmVjMyBwYWNrTm9ybWFsVG9SR0IoIGNvbnN0IGluIHZlYzMgbm9ybWFsICkge1xcblxcdHJldHVybiBub3JtYWxpemUoIG5vcm1hbCApICogMC41ICsgMC41O1xcbn1cXG52ZWMzIHVucGFja1JHQlRvTm9ybWFsKCBjb25zdCBpbiB2ZWMzIHJnYiApIHtcXG5cXHRyZXR1cm4gMi4wICogcmdiLnh5eiAtIDEuMDtcXG59XFxuY29uc3QgZmxvYXQgUGFja1Vwc2NhbGUgPSAyNTYuIC8gMjU1Ljtjb25zdCBmbG9hdCBVbnBhY2tEb3duc2NhbGUgPSAyNTUuIC8gMjU2Ljtjb25zdCBmbG9hdCBTaGlmdFJpZ2h0OCA9IDEuIC8gMjU2LjtcXG5jb25zdCBmbG9hdCBJbnYyNTUgPSAxLiAvIDI1NS47XFxuY29uc3QgdmVjNCBQYWNrRmFjdG9ycyA9IHZlYzQoIDEuMCwgMjU2LjAsIDI1Ni4wICogMjU2LjAsIDI1Ni4wICogMjU2LjAgKiAyNTYuMCApO1xcbmNvbnN0IHZlYzIgVW5wYWNrRmFjdG9yczIgPSB2ZWMyKCBVbnBhY2tEb3duc2NhbGUsIDEuMCAvIFBhY2tGYWN0b3JzLmcgKTtcXG5jb25zdCB2ZWMzIFVucGFja0ZhY3RvcnMzID0gdmVjMyggVW5wYWNrRG93bnNjYWxlIC8gUGFja0ZhY3RvcnMucmcsIDEuMCAvIFBhY2tGYWN0b3JzLmIgKTtcXG5jb25zdCB2ZWM0IFVucGFja0ZhY3RvcnM0ID0gdmVjNCggVW5wYWNrRG93bnNjYWxlIC8gUGFja0ZhY3RvcnMucmdiLCAxLjAgLyBQYWNrRmFjdG9ycy5hICk7XFxudmVjNCBwYWNrRGVwdGhUb1JHQkEoIGNvbnN0IGluIGZsb2F0IHYgKSB7XFxuXFx0aWYoIHYgPD0gMC4wIClcXG5cXHRcXHRyZXR1cm4gdmVjNCggMC4sIDAuLCAwLiwgMC4gKTtcXG5cXHRpZiggdiA+PSAxLjAgKVxcblxcdFxcdHJldHVybiB2ZWM0KCAxLiwgMS4sIDEuLCAxLiApO1xcblxcdGZsb2F0IHZ1ZjtcXG5cXHRmbG9hdCBhZiA9IG1vZGYoIHYgKiBQYWNrRmFjdG9ycy5hLCB2dWYgKTtcXG5cXHRmbG9hdCBiZiA9IG1vZGYoIHZ1ZiAqIFNoaWZ0UmlnaHQ4LCB2dWYgKTtcXG5cXHRmbG9hdCBnZiA9IG1vZGYoIHZ1ZiAqIFNoaWZ0UmlnaHQ4LCB2dWYgKTtcXG5cXHRyZXR1cm4gdmVjNCggdnVmICogSW52MjU1LCBnZiAqIFBhY2tVcHNjYWxlLCBiZiAqIFBhY2tVcHNjYWxlLCBhZiApO1xcbn1cXG52ZWMzIHBhY2tEZXB0aFRvUkdCKCBjb25zdCBpbiBmbG9hdCB2ICkge1xcblxcdGlmKCB2IDw9IDAuMCApXFxuXFx0XFx0cmV0dXJuIHZlYzMoIDAuLCAwLiwgMC4gKTtcXG5cXHRpZiggdiA+PSAxLjAgKVxcblxcdFxcdHJldHVybiB2ZWMzKCAxLiwgMS4sIDEuICk7XFxuXFx0ZmxvYXQgdnVmO1xcblxcdGZsb2F0IGJmID0gbW9kZiggdiAqIFBhY2tGYWN0b3JzLmIsIHZ1ZiApO1xcblxcdGZsb2F0IGdmID0gbW9kZiggdnVmICogU2hpZnRSaWdodDgsIHZ1ZiApO1xcblxcdHJldHVybiB2ZWMzKCB2dWYgKiBJbnYyNTUsIGdmICogUGFja1Vwc2NhbGUsIGJmICk7XFxufVxcbnZlYzIgcGFja0RlcHRoVG9SRyggY29uc3QgaW4gZmxvYXQgdiApIHtcXG5cXHRpZiggdiA8PSAwLjAgKVxcblxcdFxcdHJldHVybiB2ZWMyKCAwLiwgMC4gKTtcXG5cXHRpZiggdiA+PSAxLjAgKVxcblxcdFxcdHJldHVybiB2ZWMyKCAxLiwgMS4gKTtcXG5cXHRmbG9hdCB2dWY7XFxuXFx0ZmxvYXQgZ2YgPSBtb2RmKCB2ICogMjU2LiwgdnVmICk7XFxuXFx0cmV0dXJuIHZlYzIoIHZ1ZiAqIEludjI1NSwgZ2YgKTtcXG59XFxuZmxvYXQgdW5wYWNrUkdCQVRvRGVwdGgoIGNvbnN0IGluIHZlYzQgdiApIHtcXG5cXHRyZXR1cm4gZG90KCB2LCBVbnBhY2tGYWN0b3JzNCApO1xcbn1cXG5mbG9hdCB1bnBhY2tSR0JUb0RlcHRoKCBjb25zdCBpbiB2ZWMzIHYgKSB7XFxuXFx0cmV0dXJuIGRvdCggdiwgVW5wYWNrRmFjdG9yczMgKTtcXG59XFxuZmxvYXQgdW5wYWNrUkdUb0RlcHRoKCBjb25zdCBpbiB2ZWMyIHYgKSB7XFxuXFx0cmV0dXJuIHYuciAqIFVucGFja0ZhY3RvcnMyLnIgKyB2LmcgKiBVbnBhY2tGYWN0b3JzMi5nO1xcbn1cXG52ZWM0IHBhY2sySGFsZlRvUkdCQSggY29uc3QgaW4gdmVjMiB2ICkge1xcblxcdHZlYzQgciA9IHZlYzQoIHYueCwgZnJhY3QoIHYueCAqIDI1NS4wICksIHYueSwgZnJhY3QoIHYueSAqIDI1NS4wICkgKTtcXG5cXHRyZXR1cm4gdmVjNCggci54IC0gci55IC8gMjU1LjAsIHIueSwgci56IC0gci53IC8gMjU1LjAsIHIudyApO1xcbn1cXG52ZWMyIHVucGFja1JHQkFUbzJIYWxmKCBjb25zdCBpbiB2ZWM0IHYgKSB7XFxuXFx0cmV0dXJuIHZlYzIoIHYueCArICggdi55IC8gMjU1LjAgKSwgdi56ICsgKCB2LncgLyAyNTUuMCApICk7XFxufVxcbmZsb2F0IHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCggY29uc3QgaW4gZmxvYXQgdmlld1osIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXG5cXHRyZXR1cm4gKCB2aWV3WiArIG5lYXIgKSAvICggbmVhciAtIGZhciApO1xcbn1cXG5mbG9hdCBvcnRob2dyYXBoaWNEZXB0aFRvVmlld1ooIGNvbnN0IGluIGZsb2F0IGRlcHRoLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XFxuXFx0cmV0dXJuIGRlcHRoICogKCBuZWFyIC0gZmFyICkgLSBuZWFyO1xcbn1cXG5mbG9hdCB2aWV3WlRvUGVyc3BlY3RpdmVEZXB0aCggY29uc3QgaW4gZmxvYXQgdmlld1osIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXG5cXHRyZXR1cm4gKCAoIG5lYXIgKyB2aWV3WiApICogZmFyICkgLyAoICggZmFyIC0gbmVhciApICogdmlld1ogKTtcXG59XFxuZmxvYXQgcGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooIGNvbnN0IGluIGZsb2F0IGRlcHRoLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XFxuXFx0cmV0dXJuICggbmVhciAqIGZhciApIC8gKCAoIGZhciAtIG5lYXIgKSAqIGRlcHRoIC0gZmFyICk7XFxufVwiO1xuXG52YXIgcHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudCA9IFwiI2lmZGVmIFBSRU1VTFRJUExJRURfQUxQSEFcXG5cXHRnbF9GcmFnQ29sb3IucmdiICo9IGdsX0ZyYWdDb2xvci5hO1xcbiNlbmRpZlwiO1xuXG52YXIgcHJvamVjdF92ZXJ0ZXggPSBcInZlYzQgbXZQb3NpdGlvbiA9IHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG4jaWZkZWYgVVNFX0JBVENISU5HXFxuXFx0bXZQb3NpdGlvbiA9IGJhdGNoaW5nTWF0cml4ICogbXZQb3NpdGlvbjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0lOU1RBTkNJTkdcXG5cXHRtdlBvc2l0aW9uID0gaW5zdGFuY2VNYXRyaXggKiBtdlBvc2l0aW9uO1xcbiNlbmRpZlxcbm12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiBtdlBvc2l0aW9uO1xcbmdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCI7XG5cbnZhciBkaXRoZXJpbmdfZnJhZ21lbnQgPSBcIiNpZmRlZiBESVRIRVJJTkdcXG5cXHRnbF9GcmFnQ29sb3IucmdiID0gZGl0aGVyaW5nKCBnbF9GcmFnQ29sb3IucmdiICk7XFxuI2VuZGlmXCI7XG5cbnZhciBkaXRoZXJpbmdfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIERJVEhFUklOR1xcblxcdHZlYzMgZGl0aGVyaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdFxcdGZsb2F0IGdyaWRfcG9zaXRpb24gPSByYW5kKCBnbF9GcmFnQ29vcmQueHkgKTtcXG5cXHRcXHR2ZWMzIGRpdGhlcl9zaGlmdF9SR0IgPSB2ZWMzKCAwLjI1IC8gMjU1LjAsIC0wLjI1IC8gMjU1LjAsIDAuMjUgLyAyNTUuMCApO1xcblxcdFxcdGRpdGhlcl9zaGlmdF9SR0IgPSBtaXgoIDIuMCAqIGRpdGhlcl9zaGlmdF9SR0IsIC0yLjAgKiBkaXRoZXJfc2hpZnRfUkdCLCBncmlkX3Bvc2l0aW9uICk7XFxuXFx0XFx0cmV0dXJuIGNvbG9yICsgZGl0aGVyX3NoaWZ0X1JHQjtcXG5cXHR9XFxuI2VuZGlmXCI7XG5cbnZhciByb3VnaG5lc3NtYXBfZnJhZ21lbnQgPSBcImZsb2F0IHJvdWdobmVzc0ZhY3RvciA9IHJvdWdobmVzcztcXG4jaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcblxcdHZlYzQgdGV4ZWxSb3VnaG5lc3MgPSB0ZXh0dXJlMkQoIHJvdWdobmVzc01hcCwgdlJvdWdobmVzc01hcFV2ICk7XFxuXFx0cm91Z2huZXNzRmFjdG9yICo9IHRleGVsUm91Z2huZXNzLmc7XFxuI2VuZGlmXCI7XG5cbnZhciByb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCByb3VnaG5lc3NNYXA7XFxuI2VuZGlmXCI7XG5cbnZhciBzaGFkb3dtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyA+IDBcXG5cXHR2YXJ5aW5nIHZlYzQgdlNwb3RMaWdodENvb3JkWyBOVU1fU1BPVF9MSUdIVF9DT09SRFMgXTtcXG4jZW5kaWZcXG4jaWYgTlVNX1NQT1RfTElHSFRfTUFQUyA+IDBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBzcG90TGlnaHRNYXBbIE5VTV9TUE9UX0xJR0hUX01BUFMgXTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdCNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgZGlyZWN0aW9uYWxTaGFkb3dNYXBbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0ludGVuc2l0eTtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cXHRcXHR9O1xcblxcdFxcdHVuaWZvcm0gRGlyZWN0aW9uYWxMaWdodFNoYWRvdyBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgc3BvdFNoYWRvd01hcFsgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHN0cnVjdCBTcG90TGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0ludGVuc2l0eTtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cXHRcXHR9O1xcblxcdFxcdHVuaWZvcm0gU3BvdExpZ2h0U2hhZG93IHNwb3RMaWdodFNoYWRvd3NbIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgcG9pbnRTaGFkb3dNYXBbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHN0cnVjdCBQb2ludExpZ2h0U2hhZG93IHtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dJbnRlbnNpdHk7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dOb3JtYWxCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Q2FtZXJhTmVhcjtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dDYW1lcmFGYXI7XFxuXFx0XFx0fTtcXG5cXHRcXHR1bmlmb3JtIFBvaW50TGlnaHRTaGFkb3cgcG9pbnRMaWdodFNoYWRvd3NbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0I2VuZGlmXFxuXFx0ZmxvYXQgdGV4dHVyZTJEQ29tcGFyZSggc2FtcGxlcjJEIGRlcHRocywgdmVjMiB1diwgZmxvYXQgY29tcGFyZSApIHtcXG5cXHRcXHRyZXR1cm4gc3RlcCggY29tcGFyZSwgdW5wYWNrUkdCQVRvRGVwdGgoIHRleHR1cmUyRCggZGVwdGhzLCB1diApICkgKTtcXG5cXHR9XFxuXFx0dmVjMiB0ZXh0dXJlMkREaXN0cmlidXRpb24oIHNhbXBsZXIyRCBzaGFkb3csIHZlYzIgdXYgKSB7XFxuXFx0XFx0cmV0dXJuIHVucGFja1JHQkFUbzJIYWxmKCB0ZXh0dXJlMkQoIHNoYWRvdywgdXYgKSApO1xcblxcdH1cXG5cXHRmbG9hdCBWU01TaGFkb3cgKHNhbXBsZXIyRCBzaGFkb3csIHZlYzIgdXYsIGZsb2F0IGNvbXBhcmUgKXtcXG5cXHRcXHRmbG9hdCBvY2NsdXNpb24gPSAxLjA7XFxuXFx0XFx0dmVjMiBkaXN0cmlidXRpb24gPSB0ZXh0dXJlMkREaXN0cmlidXRpb24oIHNoYWRvdywgdXYgKTtcXG5cXHRcXHRmbG9hdCBoYXJkX3NoYWRvdyA9IHN0ZXAoIGNvbXBhcmUgLCBkaXN0cmlidXRpb24ueCApO1xcblxcdFxcdGlmIChoYXJkX3NoYWRvdyAhPSAxLjAgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgZGlzdGFuY2UgPSBjb21wYXJlIC0gZGlzdHJpYnV0aW9uLnggO1xcblxcdFxcdFxcdGZsb2F0IHZhcmlhbmNlID0gbWF4KCAwLjAwMDAwLCBkaXN0cmlidXRpb24ueSAqIGRpc3RyaWJ1dGlvbi55ICk7XFxuXFx0XFx0XFx0ZmxvYXQgc29mdG5lc3NfcHJvYmFiaWxpdHkgPSB2YXJpYW5jZSAvICh2YXJpYW5jZSArIGRpc3RhbmNlICogZGlzdGFuY2UgKTtcXHRcXHRcXHRzb2Z0bmVzc19wcm9iYWJpbGl0eSA9IGNsYW1wKCAoIHNvZnRuZXNzX3Byb2JhYmlsaXR5IC0gMC4zICkgLyAoIDAuOTUgLSAwLjMgKSwgMC4wLCAxLjAgKTtcXHRcXHRcXHRvY2NsdXNpb24gPSBjbGFtcCggbWF4KCBoYXJkX3NoYWRvdywgc29mdG5lc3NfcHJvYmFiaWxpdHkgKSwgMC4wLCAxLjAgKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIG9jY2x1c2lvbjtcXG5cXHR9XFxuXFx0ZmxvYXQgZ2V0U2hhZG93KCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWMyIHNoYWRvd01hcFNpemUsIGZsb2F0IHNoYWRvd0ludGVuc2l0eSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkICkge1xcblxcdFxcdGZsb2F0IHNoYWRvdyA9IDEuMDtcXG5cXHRcXHRzaGFkb3dDb29yZC54eXogLz0gc2hhZG93Q29vcmQudztcXG5cXHRcXHRzaGFkb3dDb29yZC56ICs9IHNoYWRvd0JpYXM7XFxuXFx0XFx0Ym9vbCBpbkZydXN0dW0gPSBzaGFkb3dDb29yZC54ID49IDAuMCAmJiBzaGFkb3dDb29yZC54IDw9IDEuMCAmJiBzaGFkb3dDb29yZC55ID49IDAuMCAmJiBzaGFkb3dDb29yZC55IDw9IDEuMDtcXG5cXHRcXHRib29sIGZydXN0dW1UZXN0ID0gaW5GcnVzdHVtICYmIHNoYWRvd0Nvb3JkLnogPD0gMS4wO1xcblxcdFxcdGlmICggZnJ1c3R1bVRlc3QgKSB7XFxuXFx0XFx0I2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApXFxuXFx0XFx0XFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0XFx0ZmxvYXQgZHgwID0gLSB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeTAgPSAtIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdGZsb2F0IGR4MSA9ICsgdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHkxID0gKyB0ZXhlbFNpemUueSAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeDIgPSBkeDAgLyAyLjA7XFxuXFx0XFx0XFx0ZmxvYXQgZHkyID0gZHkwIC8gMi4wO1xcblxcdFxcdFxcdGZsb2F0IGR4MyA9IGR4MSAvIDIuMDtcXG5cXHRcXHRcXHRmbG9hdCBkeTMgPSBkeTEgLyAyLjA7XFxuXFx0XFx0XFx0c2hhZG93ID0gKFxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDIsIGR5MiApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MiApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDMsIGR5MiApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDIsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MywgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MiwgZHkzICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkzICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MywgZHkzICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICksIHNoYWRvd0Nvb3JkLnogKVxcblxcdFxcdFxcdCkgKiAoIDEuMCAvIDE3LjAgKTtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXFxuXFx0XFx0XFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0XFx0ZmxvYXQgZHggPSB0ZXhlbFNpemUueDtcXG5cXHRcXHRcXHRmbG9hdCBkeSA9IHRleGVsU2l6ZS55O1xcblxcdFxcdFxcdHZlYzIgdXYgPSBzaGFkb3dDb29yZC54eTtcXG5cXHRcXHRcXHR2ZWMyIGYgPSBmcmFjdCggdXYgKiBzaGFkb3dNYXBTaXplICsgMC41ICk7XFxuXFx0XFx0XFx0dXYgLT0gZiAqIHRleGVsU2l6ZTtcXG5cXHRcXHRcXHRzaGFkb3cgPSAoXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggZHgsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAwLjAsIGR5ICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHRleGVsU2l6ZSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHRtaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAtZHgsIDAuMCApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0IHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAyLjAgKiBkeCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHQgZi54ICkgK1xcblxcdFxcdFxcdFxcdG1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIC1keCwgZHkgKSwgc2hhZG93Q29vcmQueiApLFxcblxcdFxcdFxcdFxcdFxcdCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIGR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHQgZi54ICkgK1xcblxcdFxcdFxcdFxcdG1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDAuMCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHQgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDAuMCwgMi4wICogZHkgKSwgc2hhZG93Q29vcmQueiApLFxcblxcdFxcdFxcdFxcdFxcdCBmLnkgKSArXFxuXFx0XFx0XFx0XFx0bWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggZHgsIC1keSApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0IHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCBkeCwgMi4wICogZHkgKSwgc2hhZG93Q29vcmQueiApLFxcblxcdFxcdFxcdFxcdFxcdCBmLnkgKSArXFxuXFx0XFx0XFx0XFx0bWl4KCBtaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAtZHgsIC1keSApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0ICB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIC1keSApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0ICBmLnggKSxcXG5cXHRcXHRcXHRcXHRcXHQgbWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0ICB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHQgIGYueCApLFxcblxcdFxcdFxcdFxcdFxcdCBmLnkgKVxcblxcdFxcdFxcdCkgKiAoIDEuMCAvIDkuMCApO1xcblxcdFxcdCNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1ZTTSApXFxuXFx0XFx0XFx0c2hhZG93ID0gVlNNU2hhZG93KCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRzaGFkb3cgPSB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBtaXgoIDEuMCwgc2hhZG93LCBzaGFkb3dJbnRlbnNpdHkgKTtcXG5cXHR9XFxuXFx0dmVjMiBjdWJlVG9VViggdmVjMyB2LCBmbG9hdCB0ZXhlbFNpemVZICkge1xcblxcdFxcdHZlYzMgYWJzViA9IGFicyggdiApO1xcblxcdFxcdGZsb2F0IHNjYWxlVG9DdWJlID0gMS4wIC8gbWF4KCBhYnNWLngsIG1heCggYWJzVi55LCBhYnNWLnogKSApO1xcblxcdFxcdGFic1YgKj0gc2NhbGVUb0N1YmU7XFxuXFx0XFx0diAqPSBzY2FsZVRvQ3ViZSAqICggMS4wIC0gMi4wICogdGV4ZWxTaXplWSApO1xcblxcdFxcdHZlYzIgcGxhbmFyID0gdi54eTtcXG5cXHRcXHRmbG9hdCBhbG1vc3RBVGV4ZWwgPSAxLjUgKiB0ZXhlbFNpemVZO1xcblxcdFxcdGZsb2F0IGFsbW9zdE9uZSA9IDEuMCAtIGFsbW9zdEFUZXhlbDtcXG5cXHRcXHRpZiAoIGFic1YueiA+PSBhbG1vc3RPbmUgKSB7XFxuXFx0XFx0XFx0aWYgKCB2LnogPiAwLjAgKVxcblxcdFxcdFxcdFxcdHBsYW5hci54ID0gNC4wIC0gdi54O1xcblxcdFxcdH0gZWxzZSBpZiAoIGFic1YueCA+PSBhbG1vc3RPbmUgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgc2lnblggPSBzaWduKCB2LnggKTtcXG5cXHRcXHRcXHRwbGFuYXIueCA9IHYueiAqIHNpZ25YICsgMi4wICogc2lnblg7XFxuXFx0XFx0fSBlbHNlIGlmICggYWJzVi55ID49IGFsbW9zdE9uZSApIHtcXG5cXHRcXHRcXHRmbG9hdCBzaWduWSA9IHNpZ24oIHYueSApO1xcblxcdFxcdFxcdHBsYW5hci54ID0gdi54ICsgMi4wICogc2lnblkgKyAyLjA7XFxuXFx0XFx0XFx0cGxhbmFyLnkgPSB2LnogKiBzaWduWSAtIDIuMDtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHZlYzIoIDAuMTI1LCAwLjI1ICkgKiBwbGFuYXIgKyB2ZWMyKCAwLjM3NSwgMC43NSApO1xcblxcdH1cXG5cXHRmbG9hdCBnZXRQb2ludFNoYWRvdyggc2FtcGxlcjJEIHNoYWRvd01hcCwgdmVjMiBzaGFkb3dNYXBTaXplLCBmbG9hdCBzaGFkb3dJbnRlbnNpdHksIGZsb2F0IHNoYWRvd0JpYXMsIGZsb2F0IHNoYWRvd1JhZGl1cywgdmVjNCBzaGFkb3dDb29yZCwgZmxvYXQgc2hhZG93Q2FtZXJhTmVhciwgZmxvYXQgc2hhZG93Q2FtZXJhRmFyICkge1xcblxcdFxcdGZsb2F0IHNoYWRvdyA9IDEuMDtcXG5cXHRcXHR2ZWMzIGxpZ2h0VG9Qb3NpdGlvbiA9IHNoYWRvd0Nvb3JkLnh5ejtcXG5cXHRcXHRcXG5cXHRcXHRmbG9hdCBsaWdodFRvUG9zaXRpb25MZW5ndGggPSBsZW5ndGgoIGxpZ2h0VG9Qb3NpdGlvbiApO1xcblxcdFxcdGlmICggbGlnaHRUb1Bvc2l0aW9uTGVuZ3RoIC0gc2hhZG93Q2FtZXJhRmFyIDw9IDAuMCAmJiBsaWdodFRvUG9zaXRpb25MZW5ndGggLSBzaGFkb3dDYW1lcmFOZWFyID49IDAuMCApIHtcXG5cXHRcXHRcXHRmbG9hdCBkcCA9ICggbGlnaHRUb1Bvc2l0aW9uTGVuZ3RoIC0gc2hhZG93Q2FtZXJhTmVhciApIC8gKCBzaGFkb3dDYW1lcmFGYXIgLSBzaGFkb3dDYW1lcmFOZWFyICk7XFx0XFx0XFx0ZHAgKz0gc2hhZG93QmlhcztcXG5cXHRcXHRcXHR2ZWMzIGJkM0QgPSBub3JtYWxpemUoIGxpZ2h0VG9Qb3NpdGlvbiApO1xcblxcdFxcdFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyAoIHNoYWRvd01hcFNpemUgKiB2ZWMyKCA0LjAsIDIuMCApICk7XFxuXFx0XFx0XFx0I2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApIHx8IGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfVlNNIClcXG5cXHRcXHRcXHRcXHR2ZWMyIG9mZnNldCA9IHZlYzIoIC0gMSwgMSApICogc2hhZG93UmFkaXVzICogdGV4ZWxTaXplLnk7XFxuXFx0XFx0XFx0XFx0c2hhZG93ID0gKFxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl5eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eXgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXl4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh4eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHh4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl4eCwgdGV4ZWxTaXplLnkgKSwgZHAgKVxcblxcdFxcdFxcdFxcdCkgKiAoIDEuMCAvIDkuMCApO1xcblxcdFxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0XFx0c2hhZG93ID0gdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKTtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIG1peCggMS4wLCBzaGFkb3csIHNoYWRvd0ludGVuc2l0eSApO1xcblxcdH1cXG4jZW5kaWZcIjtcblxudmFyIHNoYWRvd21hcF9wYXJzX3ZlcnRleCA9IFwiI2lmIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyA+IDBcXG5cXHR1bmlmb3JtIG1hdDQgc3BvdExpZ2h0TWF0cml4WyBOVU1fU1BPVF9MSUdIVF9DT09SRFMgXTtcXG5cXHR2YXJ5aW5nIHZlYzQgdlNwb3RMaWdodENvb3JkWyBOVU1fU1BPVF9MSUdIVF9DT09SRFMgXTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdCNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0XFx0dW5pZm9ybSBtYXQ0IGRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHN0cnVjdCBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IHtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dJbnRlbnNpdHk7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dOb3JtYWxCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0fTtcXG5cXHRcXHR1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fU1BPVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFxcdHN0cnVjdCBTcG90TGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0ludGVuc2l0eTtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cXHRcXHR9O1xcblxcdFxcdHVuaWZvcm0gU3BvdExpZ2h0U2hhZG93IHNwb3RMaWdodFNoYWRvd3NbIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0XFx0dW5pZm9ybSBtYXQ0IHBvaW50U2hhZG93TWF0cml4WyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2UG9pbnRTaGFkb3dDb29yZFsgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHRzdHJ1Y3QgUG9pbnRMaWdodFNoYWRvdyB7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93SW50ZW5zaXR5O1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0NhbWVyYU5lYXI7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Q2FtZXJhRmFyO1xcblxcdFxcdH07XFxuXFx0XFx0dW5pZm9ybSBQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3dzWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG52YXIgc2hhZG93bWFwX3ZlcnRleCA9IFwiI2lmICggZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmICggTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMCB8fCBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDAgKSApIHx8ICggTlVNX1NQT1RfTElHSFRfQ09PUkRTID4gMCApXFxuXFx0dmVjMyBzaGFkb3dXb3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHRyYW5zZm9ybWVkTm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFx0dmVjNCBzaGFkb3dXb3JsZFBvc2l0aW9uO1xcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQIClcXG5cXHQjaWYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMFxcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XFxuXFx0XFx0XFx0c2hhZG93V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24gKyB2ZWM0KCBzaGFkb3dXb3JsZE5vcm1hbCAqIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBpIF0uc2hhZG93Tm9ybWFsQmlhcywgMCApO1xcblxcdFxcdFxcdHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gPSBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3NpdGlvbjtcXG5cXHRcXHR9XFxuXFx0XFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0XFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTOyBpICsrICkge1xcblxcdFxcdFxcdHNoYWRvd1dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uICsgdmVjNCggc2hhZG93V29ybGROb3JtYWwgKiBwb2ludExpZ2h0U2hhZG93c1sgaSBdLnNoYWRvd05vcm1hbEJpYXMsIDAgKTtcXG5cXHRcXHRcXHR2UG9pbnRTaGFkb3dDb29yZFsgaSBdID0gcG9pbnRTaGFkb3dNYXRyaXhbIGkgXSAqIHNoYWRvd1dvcmxkUG9zaXRpb247XFxuXFx0XFx0fVxcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuI2lmIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyA+IDBcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRfQ09PUkRTOyBpICsrICkge1xcblxcdFxcdHNoYWRvd1dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uO1xcblxcdFxcdCNpZiAoIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyApXFxuXFx0XFx0XFx0c2hhZG93V29ybGRQb3NpdGlvbi54eXogKz0gc2hhZG93V29ybGROb3JtYWwgKiBzcG90TGlnaHRTaGFkb3dzWyBpIF0uc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHR2U3BvdExpZ2h0Q29vcmRbIGkgXSA9IHNwb3RMaWdodE1hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3NpdGlvbjtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG4jZW5kaWZcIjtcblxudmFyIHNoYWRvd21hc2tfcGFyc19mcmFnbWVudCA9IFwiZmxvYXQgZ2V0U2hhZG93TWFzaygpIHtcXG5cXHRmbG9hdCBzaGFkb3cgPSAxLjA7XFxuXFx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXHQjaWYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMFxcblxcdERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodDtcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVF9TSEFET1dTOyBpICsrICkge1xcblxcdFxcdGRpcmVjdGlvbmFsTGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgaSBdO1xcblxcdFxcdHNoYWRvdyAqPSByZWNlaXZlU2hhZG93ID8gZ2V0U2hhZG93KCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgaSBdLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd01hcFNpemUsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93SW50ZW5zaXR5LCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0U3BvdExpZ2h0U2hhZG93IHNwb3RMaWdodDtcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUzsgaSArKyApIHtcXG5cXHRcXHRzcG90TGlnaHQgPSBzcG90TGlnaHRTaGFkb3dzWyBpIF07XFxuXFx0XFx0c2hhZG93ICo9IHJlY2VpdmVTaGFkb3cgPyBnZXRTaGFkb3coIHNwb3RTaGFkb3dNYXBbIGkgXSwgc3BvdExpZ2h0LnNoYWRvd01hcFNpemUsIHNwb3RMaWdodC5zaGFkb3dJbnRlbnNpdHksIHNwb3RMaWdodC5zaGFkb3dCaWFzLCBzcG90TGlnaHQuc2hhZG93UmFkaXVzLCB2U3BvdExpZ2h0Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHQ7XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTOyBpICsrICkge1xcblxcdFxcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0U2hhZG93c1sgaSBdO1xcblxcdFxcdHNoYWRvdyAqPSByZWNlaXZlU2hhZG93ID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodC5zaGFkb3dJbnRlbnNpdHksIHBvaW50TGlnaHQuc2hhZG93QmlhcywgcG9pbnRMaWdodC5zaGFkb3dSYWRpdXMsIHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93Q2FtZXJhTmVhciwgcG9pbnRMaWdodC5zaGFkb3dDYW1lcmFGYXIgKSA6IDEuMDtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHQjZW5kaWZcXG5cXHQjZW5kaWZcXG5cXHRyZXR1cm4gc2hhZG93O1xcbn1cIjtcblxudmFyIHNraW5iYXNlX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdG1hdDQgYm9uZU1hdFggPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueCApO1xcblxcdG1hdDQgYm9uZU1hdFkgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueSApO1xcblxcdG1hdDQgYm9uZU1hdFogPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueiApO1xcblxcdG1hdDQgYm9uZU1hdFcgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgudyApO1xcbiNlbmRpZlwiO1xuXG52YXIgc2tpbm5pbmdfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeDtcXG5cXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeEludmVyc2U7XFxuXFx0dW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgYm9uZVRleHR1cmU7XFxuXFx0bWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcdFxcdGludCBzaXplID0gdGV4dHVyZVNpemUoIGJvbmVUZXh0dXJlLCAwICkueDtcXG5cXHRcXHRpbnQgaiA9IGludCggaSApICogNDtcXG5cXHRcXHRpbnQgeCA9IGogJSBzaXplO1xcblxcdFxcdGludCB5ID0gaiAvIHNpemU7XFxuXFx0XFx0dmVjNCB2MSA9IHRleGVsRmV0Y2goIGJvbmVUZXh0dXJlLCBpdmVjMiggeCwgeSApLCAwICk7XFxuXFx0XFx0dmVjNCB2MiA9IHRleGVsRmV0Y2goIGJvbmVUZXh0dXJlLCBpdmVjMiggeCArIDEsIHkgKSwgMCApO1xcblxcdFxcdHZlYzQgdjMgPSB0ZXhlbEZldGNoKCBib25lVGV4dHVyZSwgaXZlYzIoIHggKyAyLCB5ICksIDAgKTtcXG5cXHRcXHR2ZWM0IHY0ID0gdGV4ZWxGZXRjaCggYm9uZVRleHR1cmUsIGl2ZWMyKCB4ICsgMywgeSApLCAwICk7XFxuXFx0XFx0cmV0dXJuIG1hdDQoIHYxLCB2MiwgdjMsIHY0ICk7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG52YXIgc2tpbm5pbmdfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFx0dmVjNCBza2luVmVydGV4ID0gYmluZE1hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG5cXHR2ZWM0IHNraW5uZWQgPSB2ZWM0KCAwLjAgKTtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRaICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQuejtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRXICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQudztcXG5cXHR0cmFuc2Zvcm1lZCA9ICggYmluZE1hdHJpeEludmVyc2UgKiBza2lubmVkICkueHl6O1xcbiNlbmRpZlwiO1xuXG52YXIgc2tpbm5vcm1hbF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHRtYXQ0IHNraW5NYXRyaXggPSBtYXQ0KCAwLjAgKTtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueCAqIGJvbmVNYXRYO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC55ICogYm9uZU1hdFk7XFxuXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnogKiBib25lTWF0WjtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQudyAqIGJvbmVNYXRXO1xcblxcdHNraW5NYXRyaXggPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5NYXRyaXggKiBiaW5kTWF0cml4O1xcblxcdG9iamVjdE5vcm1hbCA9IHZlYzQoIHNraW5NYXRyaXggKiB2ZWM0KCBvYmplY3ROb3JtYWwsIDAuMCApICkueHl6O1xcblxcdCNpZmRlZiBVU0VfVEFOR0VOVFxcblxcdFxcdG9iamVjdFRhbmdlbnQgPSB2ZWM0KCBza2luTWF0cml4ICogdmVjNCggb2JqZWN0VGFuZ2VudCwgMC4wICkgKS54eXo7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBzcGVjdWxhcm1hcF9mcmFnbWVudCA9IFwiZmxvYXQgc3BlY3VsYXJTdHJlbmd0aDtcXG4jaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXFx0dmVjNCB0ZXhlbFNwZWN1bGFyID0gdGV4dHVyZTJEKCBzcGVjdWxhck1hcCwgdlNwZWN1bGFyTWFwVXYgKTtcXG5cXHRzcGVjdWxhclN0cmVuZ3RoID0gdGV4ZWxTcGVjdWxhci5yO1xcbiNlbHNlXFxuXFx0c3BlY3VsYXJTdHJlbmd0aCA9IDEuMDtcXG4jZW5kaWZcIjtcblxudmFyIHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhck1hcDtcXG4jZW5kaWZcIjtcblxudmFyIHRvbmVtYXBwaW5nX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVE9ORV9NQVBQSU5HIClcXG5cXHRnbF9GcmFnQ29sb3IucmdiID0gdG9uZU1hcHBpbmcoIGdsX0ZyYWdDb2xvci5yZ2IgKTtcXG4jZW5kaWZcIjtcblxudmFyIHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQgPSBcIiNpZm5kZWYgc2F0dXJhdGVcXG4jZGVmaW5lIHNhdHVyYXRlKCBhICkgY2xhbXAoIGEsIDAuMCwgMS4wIClcXG4jZW5kaWZcXG51bmlmb3JtIGZsb2F0IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxudmVjMyBMaW5lYXJUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIHRvbmVNYXBwaW5nRXhwb3N1cmUgKiBjb2xvciApO1xcbn1cXG52ZWMzIFJlaW5oYXJkVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxuXFx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIGNvbG9yIC8gKCB2ZWMzKCAxLjAgKSArIGNvbG9yICkgKTtcXG59XFxudmVjMyBDaW5lb25Ub25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXG5cXHRjb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlO1xcblxcdGNvbG9yID0gbWF4KCB2ZWMzKCAwLjAgKSwgY29sb3IgLSAwLjAwNCApO1xcblxcdHJldHVybiBwb3coICggY29sb3IgKiAoIDYuMiAqIGNvbG9yICsgMC41ICkgKSAvICggY29sb3IgKiAoIDYuMiAqIGNvbG9yICsgMS43ICkgKyAwLjA2ICksIHZlYzMoIDIuMiApICk7XFxufVxcbnZlYzMgUlJUQW5kT0RURml0KCB2ZWMzIHYgKSB7XFxuXFx0dmVjMyBhID0gdiAqICggdiArIDAuMDI0NTc4NiApIC0gMC4wMDAwOTA1Mzc7XFxuXFx0dmVjMyBiID0gdiAqICggMC45ODM3MjkgKiB2ICsgMC40MzI5NTEwICkgKyAwLjIzODA4MTtcXG5cXHRyZXR1cm4gYSAvIGI7XFxufVxcbnZlYzMgQUNFU0ZpbG1pY1RvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdGNvbnN0IG1hdDMgQUNFU0lucHV0TWF0ID0gbWF0MyhcXG5cXHRcXHR2ZWMzKCAwLjU5NzE5LCAwLjA3NjAwLCAwLjAyODQwICksXFx0XFx0dmVjMyggMC4zNTQ1OCwgMC45MDgzNCwgMC4xMzM4MyApLFxcblxcdFxcdHZlYzMoIDAuMDQ4MjMsIDAuMDE1NjYsIDAuODM3NzcgKVxcblxcdCk7XFxuXFx0Y29uc3QgbWF0MyBBQ0VTT3V0cHV0TWF0ID0gbWF0MyhcXG5cXHRcXHR2ZWMzKCAgMS42MDQ3NSwgLTAuMTAyMDgsIC0wLjAwMzI3ICksXFx0XFx0dmVjMyggLTAuNTMxMDgsICAxLjEwODEzLCAtMC4wNzI3NiApLFxcblxcdFxcdHZlYzMoIC0wLjA3MzY3LCAtMC4wMDYwNSwgIDEuMDc2MDIgKVxcblxcdCk7XFxuXFx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZSAvIDAuNjtcXG5cXHRjb2xvciA9IEFDRVNJbnB1dE1hdCAqIGNvbG9yO1xcblxcdGNvbG9yID0gUlJUQW5kT0RURml0KCBjb2xvciApO1xcblxcdGNvbG9yID0gQUNFU091dHB1dE1hdCAqIGNvbG9yO1xcblxcdHJldHVybiBzYXR1cmF0ZSggY29sb3IgKTtcXG59XFxuY29uc3QgbWF0MyBMSU5FQVJfUkVDMjAyMF9UT19MSU5FQVJfU1JHQiA9IG1hdDMoXFxuXFx0dmVjMyggMS42NjA1LCAtIDAuMTI0NiwgLSAwLjAxODIgKSxcXG5cXHR2ZWMzKCAtIDAuNTg3NiwgMS4xMzI5LCAtIDAuMTAwNiApLFxcblxcdHZlYzMoIC0gMC4wNzI4LCAtIDAuMDA4MywgMS4xMTg3IClcXG4pO1xcbmNvbnN0IG1hdDMgTElORUFSX1NSR0JfVE9fTElORUFSX1JFQzIwMjAgPSBtYXQzKFxcblxcdHZlYzMoIDAuNjI3NCwgMC4wNjkxLCAwLjAxNjQgKSxcXG5cXHR2ZWMzKCAwLjMyOTMsIDAuOTE5NSwgMC4wODgwICksXFxuXFx0dmVjMyggMC4wNDMzLCAwLjAxMTMsIDAuODk1NiApXFxuKTtcXG52ZWMzIGFneERlZmF1bHRDb250cmFzdEFwcHJveCggdmVjMyB4ICkge1xcblxcdHZlYzMgeDIgPSB4ICogeDtcXG5cXHR2ZWMzIHg0ID0geDIgKiB4MjtcXG5cXHRyZXR1cm4gKyAxNS41ICogeDQgKiB4MlxcblxcdFxcdC0gNDAuMTQgKiB4NCAqIHhcXG5cXHRcXHQrIDMxLjk2ICogeDRcXG5cXHRcXHQtIDYuODY4ICogeDIgKiB4XFxuXFx0XFx0KyAwLjQyOTggKiB4MlxcblxcdFxcdCsgMC4xMTkxICogeFxcblxcdFxcdC0gMC4wMDIzMjtcXG59XFxudmVjMyBBZ1hUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXG5cXHRjb25zdCBtYXQzIEFnWEluc2V0TWF0cml4ID0gbWF0MyhcXG5cXHRcXHR2ZWMzKCAwLjg1NjYyNzE1MzMxNTk4MywgMC4xMzczMTg5NzI5Mjk4NDcsIDAuMTExODk4MjEyOTk5OTUgKSxcXG5cXHRcXHR2ZWMzKCAwLjA5NTEyMTI0MDUzODE1ODgsIDAuNzYxMjQxOTkwNjAyNTkxLCAwLjA3Njc5OTQxODYwMzE5MDMgKSxcXG5cXHRcXHR2ZWMzKCAwLjA0ODI1MTYwNjE0NTg1ODMsIDAuMTAxNDM5MDM2NDY3NTYyLCAwLjgxMTMwMjM2ODM5Njg1OSApXFxuXFx0KTtcXG5cXHRjb25zdCBtYXQzIEFnWE91dHNldE1hdHJpeCA9IG1hdDMoXFxuXFx0XFx0dmVjMyggMS4xMjcxMDA1ODE4MTQ0MzY4LCAtIDAuMTQxMzI5NzYzNDk4NDM4MywgLSAwLjE0MTMyOTc2MzQ5ODQzODI2ICksXFxuXFx0XFx0dmVjMyggLSAwLjExMDYwNjY0MzA5NjYwMzIzLCAxLjE1NzgyMzcwMjIxNjI3MiwgLSAwLjExMDYwNjY0MzA5NjYwMjk0ICksXFxuXFx0XFx0dmVjMyggLSAwLjAxNjQ5MzkzODcxNzgzNDU3MywgLSAwLjAxNjQ5MzkzODcxNzgzNDI1NywgMS4yNTE5MzY0MDY1OTUwNDA1IClcXG5cXHQpO1xcblxcdGNvbnN0IGZsb2F0IEFneE1pbkV2ID0gLSAxMi40NzM5MztcXHRjb25zdCBmbG9hdCBBZ3hNYXhFdiA9IDQuMDI2MDY5O1xcblxcdGNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxuXFx0Y29sb3IgPSBMSU5FQVJfU1JHQl9UT19MSU5FQVJfUkVDMjAyMCAqIGNvbG9yO1xcblxcdGNvbG9yID0gQWdYSW5zZXRNYXRyaXggKiBjb2xvcjtcXG5cXHRjb2xvciA9IG1heCggY29sb3IsIDFlLTEwICk7XFx0Y29sb3IgPSBsb2cyKCBjb2xvciApO1xcblxcdGNvbG9yID0gKCBjb2xvciAtIEFneE1pbkV2ICkgLyAoIEFneE1heEV2IC0gQWd4TWluRXYgKTtcXG5cXHRjb2xvciA9IGNsYW1wKCBjb2xvciwgMC4wLCAxLjAgKTtcXG5cXHRjb2xvciA9IGFneERlZmF1bHRDb250cmFzdEFwcHJveCggY29sb3IgKTtcXG5cXHRjb2xvciA9IEFnWE91dHNldE1hdHJpeCAqIGNvbG9yO1xcblxcdGNvbG9yID0gcG93KCBtYXgoIHZlYzMoIDAuMCApLCBjb2xvciApLCB2ZWMzKCAyLjIgKSApO1xcblxcdGNvbG9yID0gTElORUFSX1JFQzIwMjBfVE9fTElORUFSX1NSR0IgKiBjb2xvcjtcXG5cXHRjb2xvciA9IGNsYW1wKCBjb2xvciwgMC4wLCAxLjAgKTtcXG5cXHRyZXR1cm4gY29sb3I7XFxufVxcbnZlYzMgTmV1dHJhbFRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdGNvbnN0IGZsb2F0IFN0YXJ0Q29tcHJlc3Npb24gPSAwLjggLSAwLjA0O1xcblxcdGNvbnN0IGZsb2F0IERlc2F0dXJhdGlvbiA9IDAuMTU7XFxuXFx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcXG5cXHRmbG9hdCB4ID0gbWluKCBjb2xvci5yLCBtaW4oIGNvbG9yLmcsIGNvbG9yLmIgKSApO1xcblxcdGZsb2F0IG9mZnNldCA9IHggPCAwLjA4ID8geCAtIDYuMjUgKiB4ICogeCA6IDAuMDQ7XFxuXFx0Y29sb3IgLT0gb2Zmc2V0O1xcblxcdGZsb2F0IHBlYWsgPSBtYXgoIGNvbG9yLnIsIG1heCggY29sb3IuZywgY29sb3IuYiApICk7XFxuXFx0aWYgKCBwZWFrIDwgU3RhcnRDb21wcmVzc2lvbiApIHJldHVybiBjb2xvcjtcXG5cXHRmbG9hdCBkID0gMS4gLSBTdGFydENvbXByZXNzaW9uO1xcblxcdGZsb2F0IG5ld1BlYWsgPSAxLiAtIGQgKiBkIC8gKCBwZWFrICsgZCAtIFN0YXJ0Q29tcHJlc3Npb24gKTtcXG5cXHRjb2xvciAqPSBuZXdQZWFrIC8gcGVhaztcXG5cXHRmbG9hdCBnID0gMS4gLSAxLiAvICggRGVzYXR1cmF0aW9uICogKCBwZWFrIC0gbmV3UGVhayApICsgMS4gKTtcXG5cXHRyZXR1cm4gbWl4KCBjb2xvciwgdmVjMyggbmV3UGVhayApLCBnICk7XFxufVxcbnZlYzMgQ3VzdG9tVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7IHJldHVybiBjb2xvcjsgfVwiO1xuXG52YXIgdHJhbnNtaXNzaW9uX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTlxcblxcdG1hdGVyaWFsLnRyYW5zbWlzc2lvbiA9IHRyYW5zbWlzc2lvbjtcXG5cXHRtYXRlcmlhbC50cmFuc21pc3Npb25BbHBoYSA9IDEuMDtcXG5cXHRtYXRlcmlhbC50aGlja25lc3MgPSB0aGlja25lc3M7XFxuXFx0bWF0ZXJpYWwuYXR0ZW51YXRpb25EaXN0YW5jZSA9IGF0dGVudWF0aW9uRGlzdGFuY2U7XFxuXFx0bWF0ZXJpYWwuYXR0ZW51YXRpb25Db2xvciA9IGF0dGVudWF0aW9uQ29sb3I7XFxuXFx0I2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVBcXG5cXHRcXHRtYXRlcmlhbC50cmFuc21pc3Npb24gKj0gdGV4dHVyZTJEKCB0cmFuc21pc3Npb25NYXAsIHZUcmFuc21pc3Npb25NYXBVdiApLnI7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9USElDS05FU1NNQVBcXG5cXHRcXHRtYXRlcmlhbC50aGlja25lc3MgKj0gdGV4dHVyZTJEKCB0aGlja25lc3NNYXAsIHZUaGlja25lc3NNYXBVdiApLmc7XFxuXFx0I2VuZGlmXFxuXFx0dmVjMyBwb3MgPSB2V29ybGRQb3NpdGlvbjtcXG5cXHR2ZWMzIHYgPSBub3JtYWxpemUoIGNhbWVyYVBvc2l0aW9uIC0gcG9zICk7XFxuXFx0dmVjMyBuID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFx0dmVjNCB0cmFuc21pdHRlZCA9IGdldElCTFZvbHVtZVJlZnJhY3Rpb24oXFxuXFx0XFx0biwgdiwgbWF0ZXJpYWwucm91Z2huZXNzLCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyRjkwLFxcblxcdFxcdHBvcywgbW9kZWxNYXRyaXgsIHZpZXdNYXRyaXgsIHByb2plY3Rpb25NYXRyaXgsIG1hdGVyaWFsLmRpc3BlcnNpb24sIG1hdGVyaWFsLmlvciwgbWF0ZXJpYWwudGhpY2tuZXNzLFxcblxcdFxcdG1hdGVyaWFsLmF0dGVudWF0aW9uQ29sb3IsIG1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2UgKTtcXG5cXHRtYXRlcmlhbC50cmFuc21pc3Npb25BbHBoYSA9IG1peCggbWF0ZXJpYWwudHJhbnNtaXNzaW9uQWxwaGEsIHRyYW5zbWl0dGVkLmEsIG1hdGVyaWFsLnRyYW5zbWlzc2lvbiApO1xcblxcdHRvdGFsRGlmZnVzZSA9IG1peCggdG90YWxEaWZmdXNlLCB0cmFuc21pdHRlZC5yZ2IsIG1hdGVyaWFsLnRyYW5zbWlzc2lvbiApO1xcbiNlbmRpZlwiO1xuXG52YXIgdHJhbnNtaXNzaW9uX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXFxuXFx0dW5pZm9ybSBmbG9hdCB0cmFuc21pc3Npb247XFxuXFx0dW5pZm9ybSBmbG9hdCB0aGlja25lc3M7XFxuXFx0dW5pZm9ybSBmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlO1xcblxcdHVuaWZvcm0gdmVjMyBhdHRlbnVhdGlvbkNvbG9yO1xcblxcdCNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OTUFQXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgdHJhbnNtaXNzaW9uTWFwO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgdGhpY2tuZXNzTWFwO1xcblxcdCNlbmRpZlxcblxcdHVuaWZvcm0gdmVjMiB0cmFuc21pc3Npb25TYW1wbGVyU2l6ZTtcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCB0cmFuc21pc3Npb25TYW1wbGVyTWFwO1xcblxcdHVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcXG5cXHR1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDtcXG5cXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFx0ZmxvYXQgdzAoIGZsb2F0IGEgKSB7XFxuXFx0XFx0cmV0dXJuICggMS4wIC8gNi4wICkgKiAoIGEgKiAoIGEgKiAoIC0gYSArIDMuMCApIC0gMy4wICkgKyAxLjAgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgdzEoIGZsb2F0IGEgKSB7XFxuXFx0XFx0cmV0dXJuICggMS4wIC8gNi4wICkgKiAoIGEgKiAgYSAqICggMy4wICogYSAtIDYuMCApICsgNC4wICk7XFxuXFx0fVxcblxcdGZsb2F0IHcyKCBmbG9hdCBhICl7XFxuXFx0XFx0cmV0dXJuICggMS4wIC8gNi4wICkgKiAoIGEgKiAoIGEgKiAoIC0gMy4wICogYSArIDMuMCApICsgMy4wICkgKyAxLjAgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgdzMoIGZsb2F0IGEgKSB7XFxuXFx0XFx0cmV0dXJuICggMS4wIC8gNi4wICkgKiAoIGEgKiBhICogYSApO1xcblxcdH1cXG5cXHRmbG9hdCBnMCggZmxvYXQgYSApIHtcXG5cXHRcXHRyZXR1cm4gdzAoIGEgKSArIHcxKCBhICk7XFxuXFx0fVxcblxcdGZsb2F0IGcxKCBmbG9hdCBhICkge1xcblxcdFxcdHJldHVybiB3MiggYSApICsgdzMoIGEgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgaDAoIGZsb2F0IGEgKSB7XFxuXFx0XFx0cmV0dXJuIC0gMS4wICsgdzEoIGEgKSAvICggdzAoIGEgKSArIHcxKCBhICkgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgaDEoIGZsb2F0IGEgKSB7XFxuXFx0XFx0cmV0dXJuIDEuMCArIHczKCBhICkgLyAoIHcyKCBhICkgKyB3MyggYSApICk7XFxuXFx0fVxcblxcdHZlYzQgYmljdWJpYyggc2FtcGxlcjJEIHRleCwgdmVjMiB1diwgdmVjNCB0ZXhlbFNpemUsIGZsb2F0IGxvZCApIHtcXG5cXHRcXHR1diA9IHV2ICogdGV4ZWxTaXplLnp3ICsgMC41O1xcblxcdFxcdHZlYzIgaXV2ID0gZmxvb3IoIHV2ICk7XFxuXFx0XFx0dmVjMiBmdXYgPSBmcmFjdCggdXYgKTtcXG5cXHRcXHRmbG9hdCBnMHggPSBnMCggZnV2LnggKTtcXG5cXHRcXHRmbG9hdCBnMXggPSBnMSggZnV2LnggKTtcXG5cXHRcXHRmbG9hdCBoMHggPSBoMCggZnV2LnggKTtcXG5cXHRcXHRmbG9hdCBoMXggPSBoMSggZnV2LnggKTtcXG5cXHRcXHRmbG9hdCBoMHkgPSBoMCggZnV2LnkgKTtcXG5cXHRcXHRmbG9hdCBoMXkgPSBoMSggZnV2LnkgKTtcXG5cXHRcXHR2ZWMyIHAwID0gKCB2ZWMyKCBpdXYueCArIGgweCwgaXV2LnkgKyBoMHkgKSAtIDAuNSApICogdGV4ZWxTaXplLnh5O1xcblxcdFxcdHZlYzIgcDEgPSAoIHZlYzIoIGl1di54ICsgaDF4LCBpdXYueSArIGgweSApIC0gMC41ICkgKiB0ZXhlbFNpemUueHk7XFxuXFx0XFx0dmVjMiBwMiA9ICggdmVjMiggaXV2LnggKyBoMHgsIGl1di55ICsgaDF5ICkgLSAwLjUgKSAqIHRleGVsU2l6ZS54eTtcXG5cXHRcXHR2ZWMyIHAzID0gKCB2ZWMyKCBpdXYueCArIGgxeCwgaXV2LnkgKyBoMXkgKSAtIDAuNSApICogdGV4ZWxTaXplLnh5O1xcblxcdFxcdHJldHVybiBnMCggZnV2LnkgKSAqICggZzB4ICogdGV4dHVyZUxvZCggdGV4LCBwMCwgbG9kICkgKyBnMXggKiB0ZXh0dXJlTG9kKCB0ZXgsIHAxLCBsb2QgKSApICtcXG5cXHRcXHRcXHRnMSggZnV2LnkgKSAqICggZzB4ICogdGV4dHVyZUxvZCggdGV4LCBwMiwgbG9kICkgKyBnMXggKiB0ZXh0dXJlTG9kKCB0ZXgsIHAzLCBsb2QgKSApO1xcblxcdH1cXG5cXHR2ZWM0IHRleHR1cmVCaWN1YmljKCBzYW1wbGVyMkQgc2FtcGxlciwgdmVjMiB1diwgZmxvYXQgbG9kICkge1xcblxcdFxcdHZlYzIgZkxvZFNpemUgPSB2ZWMyKCB0ZXh0dXJlU2l6ZSggc2FtcGxlciwgaW50KCBsb2QgKSApICk7XFxuXFx0XFx0dmVjMiBjTG9kU2l6ZSA9IHZlYzIoIHRleHR1cmVTaXplKCBzYW1wbGVyLCBpbnQoIGxvZCArIDEuMCApICkgKTtcXG5cXHRcXHR2ZWMyIGZMb2RTaXplSW52ID0gMS4wIC8gZkxvZFNpemU7XFxuXFx0XFx0dmVjMiBjTG9kU2l6ZUludiA9IDEuMCAvIGNMb2RTaXplO1xcblxcdFxcdHZlYzQgZlNhbXBsZSA9IGJpY3ViaWMoIHNhbXBsZXIsIHV2LCB2ZWM0KCBmTG9kU2l6ZUludiwgZkxvZFNpemUgKSwgZmxvb3IoIGxvZCApICk7XFxuXFx0XFx0dmVjNCBjU2FtcGxlID0gYmljdWJpYyggc2FtcGxlciwgdXYsIHZlYzQoIGNMb2RTaXplSW52LCBjTG9kU2l6ZSApLCBjZWlsKCBsb2QgKSApO1xcblxcdFxcdHJldHVybiBtaXgoIGZTYW1wbGUsIGNTYW1wbGUsIGZyYWN0KCBsb2QgKSApO1xcblxcdH1cXG5cXHR2ZWMzIGdldFZvbHVtZVRyYW5zbWlzc2lvblJheSggY29uc3QgaW4gdmVjMyBuLCBjb25zdCBpbiB2ZWMzIHYsIGNvbnN0IGluIGZsb2F0IHRoaWNrbmVzcywgY29uc3QgaW4gZmxvYXQgaW9yLCBjb25zdCBpbiBtYXQ0IG1vZGVsTWF0cml4ICkge1xcblxcdFxcdHZlYzMgcmVmcmFjdGlvblZlY3RvciA9IHJlZnJhY3QoIC0gdiwgbm9ybWFsaXplKCBuICksIDEuMCAvIGlvciApO1xcblxcdFxcdHZlYzMgbW9kZWxTY2FsZTtcXG5cXHRcXHRtb2RlbFNjYWxlLnggPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAwIF0ueHl6ICkgKTtcXG5cXHRcXHRtb2RlbFNjYWxlLnkgPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAxIF0ueHl6ICkgKTtcXG5cXHRcXHRtb2RlbFNjYWxlLnogPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAyIF0ueHl6ICkgKTtcXG5cXHRcXHRyZXR1cm4gbm9ybWFsaXplKCByZWZyYWN0aW9uVmVjdG9yICkgKiB0aGlja25lc3MgKiBtb2RlbFNjYWxlO1xcblxcdH1cXG5cXHRmbG9hdCBhcHBseUlvclRvUm91Z2huZXNzKCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIGZsb2F0IGlvciApIHtcXG5cXHRcXHRyZXR1cm4gcm91Z2huZXNzICogY2xhbXAoIGlvciAqIDIuMCAtIDIuMCwgMC4wLCAxLjAgKTtcXG5cXHR9XFxuXFx0dmVjNCBnZXRUcmFuc21pc3Npb25TYW1wbGUoIGNvbnN0IGluIHZlYzIgZnJhZ0Nvb3JkLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIGZsb2F0IGlvciApIHtcXG5cXHRcXHRmbG9hdCBsb2QgPSBsb2cyKCB0cmFuc21pc3Npb25TYW1wbGVyU2l6ZS54ICkgKiBhcHBseUlvclRvUm91Z2huZXNzKCByb3VnaG5lc3MsIGlvciApO1xcblxcdFxcdHJldHVybiB0ZXh0dXJlQmljdWJpYyggdHJhbnNtaXNzaW9uU2FtcGxlck1hcCwgZnJhZ0Nvb3JkLnh5LCBsb2QgKTtcXG5cXHR9XFxuXFx0dmVjMyB2b2x1bWVBdHRlbnVhdGlvbiggY29uc3QgaW4gZmxvYXQgdHJhbnNtaXNzaW9uRGlzdGFuY2UsIGNvbnN0IGluIHZlYzMgYXR0ZW51YXRpb25Db2xvciwgY29uc3QgaW4gZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZSApIHtcXG5cXHRcXHRpZiAoIGlzaW5mKCBhdHRlbnVhdGlvbkRpc3RhbmNlICkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHZlYzMoIDEuMCApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0dmVjMyBhdHRlbnVhdGlvbkNvZWZmaWNpZW50ID0gLWxvZyggYXR0ZW51YXRpb25Db2xvciApIC8gYXR0ZW51YXRpb25EaXN0YW5jZTtcXG5cXHRcXHRcXHR2ZWMzIHRyYW5zbWl0dGFuY2UgPSBleHAoIC0gYXR0ZW51YXRpb25Db2VmZmljaWVudCAqIHRyYW5zbWlzc2lvbkRpc3RhbmNlICk7XFx0XFx0XFx0cmV0dXJuIHRyYW5zbWl0dGFuY2U7XFxuXFx0XFx0fVxcblxcdH1cXG5cXHR2ZWM0IGdldElCTFZvbHVtZVJlZnJhY3Rpb24oIGNvbnN0IGluIHZlYzMgbiwgY29uc3QgaW4gdmVjMyB2LCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIHZlYzMgZGlmZnVzZUNvbG9yLFxcblxcdFxcdGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc3BlY3VsYXJGOTAsIGNvbnN0IGluIHZlYzMgcG9zaXRpb24sIGNvbnN0IGluIG1hdDQgbW9kZWxNYXRyaXgsXFxuXFx0XFx0Y29uc3QgaW4gbWF0NCB2aWV3TWF0cml4LCBjb25zdCBpbiBtYXQ0IHByb2pNYXRyaXgsIGNvbnN0IGluIGZsb2F0IGRpc3BlcnNpb24sIGNvbnN0IGluIGZsb2F0IGlvciwgY29uc3QgaW4gZmxvYXQgdGhpY2tuZXNzLFxcblxcdFxcdGNvbnN0IGluIHZlYzMgYXR0ZW51YXRpb25Db2xvciwgY29uc3QgaW4gZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZSApIHtcXG5cXHRcXHR2ZWM0IHRyYW5zbWl0dGVkTGlnaHQ7XFxuXFx0XFx0dmVjMyB0cmFuc21pdHRhbmNlO1xcblxcdFxcdCNpZmRlZiBVU0VfRElTUEVSU0lPTlxcblxcdFxcdFxcdGZsb2F0IGhhbGZTcHJlYWQgPSAoIGlvciAtIDEuMCApICogMC4wMjUgKiBkaXNwZXJzaW9uO1xcblxcdFxcdFxcdHZlYzMgaW9ycyA9IHZlYzMoIGlvciAtIGhhbGZTcHJlYWQsIGlvciwgaW9yICsgaGFsZlNwcmVhZCApO1xcblxcdFxcdFxcdGZvciAoIGludCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XFxuXFx0XFx0XFx0XFx0dmVjMyB0cmFuc21pc3Npb25SYXkgPSBnZXRWb2x1bWVUcmFuc21pc3Npb25SYXkoIG4sIHYsIHRoaWNrbmVzcywgaW9yc1sgaSBdLCBtb2RlbE1hdHJpeCApO1xcblxcdFxcdFxcdFxcdHZlYzMgcmVmcmFjdGVkUmF5RXhpdCA9IHBvc2l0aW9uICsgdHJhbnNtaXNzaW9uUmF5O1xcblxcdFxcdFxcdFxcdHZlYzQgbmRjUG9zID0gcHJvak1hdHJpeCAqIHZpZXdNYXRyaXggKiB2ZWM0KCByZWZyYWN0ZWRSYXlFeGl0LCAxLjAgKTtcXG5cXHRcXHRcXHRcXHR2ZWMyIHJlZnJhY3Rpb25Db29yZHMgPSBuZGNQb3MueHkgLyBuZGNQb3MudztcXG5cXHRcXHRcXHRcXHRyZWZyYWN0aW9uQ29vcmRzICs9IDEuMDtcXG5cXHRcXHRcXHRcXHRyZWZyYWN0aW9uQ29vcmRzIC89IDIuMDtcXG5cXHRcXHRcXHRcXHR2ZWM0IHRyYW5zbWlzc2lvblNhbXBsZSA9IGdldFRyYW5zbWlzc2lvblNhbXBsZSggcmVmcmFjdGlvbkNvb3Jkcywgcm91Z2huZXNzLCBpb3JzWyBpIF0gKTtcXG5cXHRcXHRcXHRcXHR0cmFuc21pdHRlZExpZ2h0WyBpIF0gPSB0cmFuc21pc3Npb25TYW1wbGVbIGkgXTtcXG5cXHRcXHRcXHRcXHR0cmFuc21pdHRlZExpZ2h0LmEgKz0gdHJhbnNtaXNzaW9uU2FtcGxlLmE7XFxuXFx0XFx0XFx0XFx0dHJhbnNtaXR0YW5jZVsgaSBdID0gZGlmZnVzZUNvbG9yWyBpIF0gKiB2b2x1bWVBdHRlbnVhdGlvbiggbGVuZ3RoKCB0cmFuc21pc3Npb25SYXkgKSwgYXR0ZW51YXRpb25Db2xvciwgYXR0ZW51YXRpb25EaXN0YW5jZSApWyBpIF07XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRyYW5zbWl0dGVkTGlnaHQuYSAvPSAzLjA7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHR2ZWMzIHRyYW5zbWlzc2lvblJheSA9IGdldFZvbHVtZVRyYW5zbWlzc2lvblJheSggbiwgdiwgdGhpY2tuZXNzLCBpb3IsIG1vZGVsTWF0cml4ICk7XFxuXFx0XFx0XFx0dmVjMyByZWZyYWN0ZWRSYXlFeGl0ID0gcG9zaXRpb24gKyB0cmFuc21pc3Npb25SYXk7XFxuXFx0XFx0XFx0dmVjNCBuZGNQb3MgPSBwcm9qTWF0cml4ICogdmlld01hdHJpeCAqIHZlYzQoIHJlZnJhY3RlZFJheUV4aXQsIDEuMCApO1xcblxcdFxcdFxcdHZlYzIgcmVmcmFjdGlvbkNvb3JkcyA9IG5kY1Bvcy54eSAvIG5kY1Bvcy53O1xcblxcdFxcdFxcdHJlZnJhY3Rpb25Db29yZHMgKz0gMS4wO1xcblxcdFxcdFxcdHJlZnJhY3Rpb25Db29yZHMgLz0gMi4wO1xcblxcdFxcdFxcdHRyYW5zbWl0dGVkTGlnaHQgPSBnZXRUcmFuc21pc3Npb25TYW1wbGUoIHJlZnJhY3Rpb25Db29yZHMsIHJvdWdobmVzcywgaW9yICk7XFxuXFx0XFx0XFx0dHJhbnNtaXR0YW5jZSA9IGRpZmZ1c2VDb2xvciAqIHZvbHVtZUF0dGVudWF0aW9uKCBsZW5ndGgoIHRyYW5zbWlzc2lvblJheSApLCBhdHRlbnVhdGlvbkNvbG9yLCBhdHRlbnVhdGlvbkRpc3RhbmNlICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0dmVjMyBhdHRlbnVhdGVkQ29sb3IgPSB0cmFuc21pdHRhbmNlICogdHJhbnNtaXR0ZWRMaWdodC5yZ2I7XFxuXFx0XFx0dmVjMyBGID0gRW52aXJvbm1lbnRCUkRGKCBuLCB2LCBzcGVjdWxhckNvbG9yLCBzcGVjdWxhckY5MCwgcm91Z2huZXNzICk7XFxuXFx0XFx0ZmxvYXQgdHJhbnNtaXR0YW5jZUZhY3RvciA9ICggdHJhbnNtaXR0YW5jZS5yICsgdHJhbnNtaXR0YW5jZS5nICsgdHJhbnNtaXR0YW5jZS5iICkgLyAzLjA7XFxuXFx0XFx0cmV0dXJuIHZlYzQoICggMS4wIC0gRiApICogYXR0ZW51YXRlZENvbG9yLCAxLjAgLSAoIDEuMCAtIHRyYW5zbWl0dGVkTGlnaHQuYSApICogdHJhbnNtaXR0YW5jZUZhY3RvciApO1xcblxcdH1cXG4jZW5kaWZcIjtcblxudmFyIHV2X3BhcnNfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfVVYgKSB8fCBkZWZpbmVkKCBVU0VfQU5JU09UUk9QWSApXFxuXFx0dmFyeWluZyB2ZWMyIHZVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX01BUFxcblxcdHZhcnlpbmcgdmVjMiB2TWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcdHZhcnlpbmcgdmVjMiB2QWxwaGFNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFx0dmFyeWluZyB2ZWMyIHZMaWdodE1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQU9NQVBcXG5cXHR2YXJ5aW5nIHZlYzIgdkFvTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9CVU1QTUFQXFxuXFx0dmFyeWluZyB2ZWMyIHZCdW1wTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9OT1JNQUxNQVBcXG5cXHR2YXJ5aW5nIHZlYzIgdk5vcm1hbE1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXG5cXHR2YXJ5aW5nIHZlYzIgdkVtaXNzaXZlTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9NRVRBTE5FU1NNQVBcXG5cXHR2YXJ5aW5nIHZlYzIgdk1ldGFsbmVzc01hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfUk9VR0hORVNTTUFQXFxuXFx0dmFyeWluZyB2ZWMyIHZSb3VnaG5lc3NNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0FOSVNPVFJPUFlNQVBcXG5cXHR2YXJ5aW5nIHZlYzIgdkFuaXNvdHJvcHlNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVE1BUFxcblxcdHZhcnlpbmcgdmVjMiB2Q2xlYXJjb2F0TWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQXFxuXFx0dmFyeWluZyB2ZWMyIHZDbGVhcmNvYXROb3JtYWxNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVBcXG5cXHR2YXJ5aW5nIHZlYzIgdkNsZWFyY29hdFJvdWdobmVzc01hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VNQVBcXG5cXHR2YXJ5aW5nIHZlYzIgdklyaWRlc2NlbmNlTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVBcXG5cXHR2YXJ5aW5nIHZlYzIgdklyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9TSEVFTl9DT0xPUk1BUFxcblxcdHZhcnlpbmcgdmVjMiB2U2hlZW5Db2xvck1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU0hFRU5fUk9VR0hORVNTTUFQXFxuXFx0dmFyeWluZyB2ZWMyIHZTaGVlblJvdWdobmVzc01hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXHR2YXJ5aW5nIHZlYzIgdlNwZWN1bGFyTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9TUEVDVUxBUl9DT0xPUk1BUFxcblxcdHZhcnlpbmcgdmVjMiB2U3BlY3VsYXJDb2xvck1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU1BFQ1VMQVJfSU5URU5TSVRZTUFQXFxuXFx0dmFyeWluZyB2ZWMyIHZTcGVjdWxhckludGVuc2l0eU1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OTUFQXFxuXFx0dW5pZm9ybSBtYXQzIHRyYW5zbWlzc2lvbk1hcFRyYW5zZm9ybTtcXG5cXHR2YXJ5aW5nIHZlYzIgdlRyYW5zbWlzc2lvbk1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQXFxuXFx0dW5pZm9ybSBtYXQzIHRoaWNrbmVzc01hcFRyYW5zZm9ybTtcXG5cXHR2YXJ5aW5nIHZlYzIgdlRoaWNrbmVzc01hcFV2O1xcbiNlbmRpZlwiO1xuXG52YXIgdXZfcGFyc192ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfVVYgKSB8fCBkZWZpbmVkKCBVU0VfQU5JU09UUk9QWSApXFxuXFx0dmFyeWluZyB2ZWMyIHZVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX01BUFxcblxcdHVuaWZvcm0gbWF0MyBtYXBUcmFuc2Zvcm07XFxuXFx0dmFyeWluZyB2ZWMyIHZNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFx0dW5pZm9ybSBtYXQzIGFscGhhTWFwVHJhbnNmb3JtO1xcblxcdHZhcnlpbmcgdmVjMiB2QWxwaGFNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFx0dW5pZm9ybSBtYXQzIGxpZ2h0TWFwVHJhbnNmb3JtO1xcblxcdHZhcnlpbmcgdmVjMiB2TGlnaHRNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0FPTUFQXFxuXFx0dW5pZm9ybSBtYXQzIGFvTWFwVHJhbnNmb3JtO1xcblxcdHZhcnlpbmcgdmVjMiB2QW9NYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0JVTVBNQVBcXG5cXHR1bmlmb3JtIG1hdDMgYnVtcE1hcFRyYW5zZm9ybTtcXG5cXHR2YXJ5aW5nIHZlYzIgdkJ1bXBNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcdHVuaWZvcm0gbWF0MyBub3JtYWxNYXBUcmFuc2Zvcm07XFxuXFx0dmFyeWluZyB2ZWMyIHZOb3JtYWxNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcdHVuaWZvcm0gbWF0MyBkaXNwbGFjZW1lbnRNYXBUcmFuc2Zvcm07XFxuXFx0dmFyeWluZyB2ZWMyIHZEaXNwbGFjZW1lbnRNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxuXFx0dW5pZm9ybSBtYXQzIGVtaXNzaXZlTWFwVHJhbnNmb3JtO1xcblxcdHZhcnlpbmcgdmVjMiB2RW1pc3NpdmVNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX01FVEFMTkVTU01BUFxcblxcdHVuaWZvcm0gbWF0MyBtZXRhbG5lc3NNYXBUcmFuc2Zvcm07XFxuXFx0dmFyeWluZyB2ZWMyIHZNZXRhbG5lc3NNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcblxcdHVuaWZvcm0gbWF0MyByb3VnaG5lc3NNYXBUcmFuc2Zvcm07XFxuXFx0dmFyeWluZyB2ZWMyIHZSb3VnaG5lc3NNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0FOSVNPVFJPUFlNQVBcXG5cXHR1bmlmb3JtIG1hdDMgYW5pc290cm9weU1hcFRyYW5zZm9ybTtcXG5cXHR2YXJ5aW5nIHZlYzIgdkFuaXNvdHJvcHlNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVE1BUFxcblxcdHVuaWZvcm0gbWF0MyBjbGVhcmNvYXRNYXBUcmFuc2Zvcm07XFxuXFx0dmFyeWluZyB2ZWMyIHZDbGVhcmNvYXRNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVBcXG5cXHR1bmlmb3JtIG1hdDMgY2xlYXJjb2F0Tm9ybWFsTWFwVHJhbnNmb3JtO1xcblxcdHZhcnlpbmcgdmVjMiB2Q2xlYXJjb2F0Tm9ybWFsTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRfUk9VR0hORVNTTUFQXFxuXFx0dW5pZm9ybSBtYXQzIGNsZWFyY29hdFJvdWdobmVzc01hcFRyYW5zZm9ybTtcXG5cXHR2YXJ5aW5nIHZlYzIgdkNsZWFyY29hdFJvdWdobmVzc01hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU0hFRU5fQ09MT1JNQVBcXG5cXHR1bmlmb3JtIG1hdDMgc2hlZW5Db2xvck1hcFRyYW5zZm9ybTtcXG5cXHR2YXJ5aW5nIHZlYzIgdlNoZWVuQ29sb3JNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1NIRUVOX1JPVUdITkVTU01BUFxcblxcdHVuaWZvcm0gbWF0MyBzaGVlblJvdWdobmVzc01hcFRyYW5zZm9ybTtcXG5cXHR2YXJ5aW5nIHZlYzIgdlNoZWVuUm91Z2huZXNzTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9JUklERVNDRU5DRU1BUFxcblxcdHVuaWZvcm0gbWF0MyBpcmlkZXNjZW5jZU1hcFRyYW5zZm9ybTtcXG5cXHR2YXJ5aW5nIHZlYzIgdklyaWRlc2NlbmNlTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVBcXG5cXHR1bmlmb3JtIG1hdDMgaXJpZGVzY2VuY2VUaGlja25lc3NNYXBUcmFuc2Zvcm07XFxuXFx0dmFyeWluZyB2ZWMyIHZJcmlkZXNjZW5jZVRoaWNrbmVzc01hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXHR1bmlmb3JtIG1hdDMgc3BlY3VsYXJNYXBUcmFuc2Zvcm07XFxuXFx0dmFyeWluZyB2ZWMyIHZTcGVjdWxhck1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU1BFQ1VMQVJfQ09MT1JNQVBcXG5cXHR1bmlmb3JtIG1hdDMgc3BlY3VsYXJDb2xvck1hcFRyYW5zZm9ybTtcXG5cXHR2YXJ5aW5nIHZlYzIgdlNwZWN1bGFyQ29sb3JNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1NQRUNVTEFSX0lOVEVOU0lUWU1BUFxcblxcdHVuaWZvcm0gbWF0MyBzcGVjdWxhckludGVuc2l0eU1hcFRyYW5zZm9ybTtcXG5cXHR2YXJ5aW5nIHZlYzIgdlNwZWN1bGFySW50ZW5zaXR5TWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVBcXG5cXHR1bmlmb3JtIG1hdDMgdHJhbnNtaXNzaW9uTWFwVHJhbnNmb3JtO1xcblxcdHZhcnlpbmcgdmVjMiB2VHJhbnNtaXNzaW9uTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9USElDS05FU1NNQVBcXG5cXHR1bmlmb3JtIG1hdDMgdGhpY2tuZXNzTWFwVHJhbnNmb3JtO1xcblxcdHZhcnlpbmcgdmVjMiB2VGhpY2tuZXNzTWFwVXY7XFxuI2VuZGlmXCI7XG5cbnZhciB1dl92ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfVVYgKSB8fCBkZWZpbmVkKCBVU0VfQU5JU09UUk9QWSApXFxuXFx0dlV2ID0gdmVjMyggdXYsIDEgKS54eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX01BUFxcblxcdHZNYXBVdiA9ICggbWFwVHJhbnNmb3JtICogdmVjMyggTUFQX1VWLCAxICkgKS54eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFx0dkFscGhhTWFwVXYgPSAoIGFscGhhTWFwVHJhbnNmb3JtICogdmVjMyggQUxQSEFNQVBfVVYsIDEgKSApLnh5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXHR2TGlnaHRNYXBVdiA9ICggbGlnaHRNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBMSUdIVE1BUF9VViwgMSApICkueHk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9BT01BUFxcblxcdHZBb01hcFV2ID0gKCBhb01hcFRyYW5zZm9ybSAqIHZlYzMoIEFPTUFQX1VWLCAxICkgKS54eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0JVTVBNQVBcXG5cXHR2QnVtcE1hcFV2ID0gKCBidW1wTWFwVHJhbnNmb3JtICogdmVjMyggQlVNUE1BUF9VViwgMSApICkueHk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9OT1JNQUxNQVBcXG5cXHR2Tm9ybWFsTWFwVXYgPSAoIG5vcm1hbE1hcFRyYW5zZm9ybSAqIHZlYzMoIE5PUk1BTE1BUF9VViwgMSApICkueHk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXHR2RGlzcGxhY2VtZW50TWFwVXYgPSAoIGRpc3BsYWNlbWVudE1hcFRyYW5zZm9ybSAqIHZlYzMoIERJU1BMQUNFTUVOVE1BUF9VViwgMSApICkueHk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblxcdHZFbWlzc2l2ZU1hcFV2ID0gKCBlbWlzc2l2ZU1hcFRyYW5zZm9ybSAqIHZlYzMoIEVNSVNTSVZFTUFQX1VWLCAxICkgKS54eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX01FVEFMTkVTU01BUFxcblxcdHZNZXRhbG5lc3NNYXBVdiA9ICggbWV0YWxuZXNzTWFwVHJhbnNmb3JtICogdmVjMyggTUVUQUxORVNTTUFQX1VWLCAxICkgKS54eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcblxcdHZSb3VnaG5lc3NNYXBVdiA9ICggcm91Z2huZXNzTWFwVHJhbnNmb3JtICogdmVjMyggUk9VR0hORVNTTUFQX1VWLCAxICkgKS54eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0FOSVNPVFJPUFlNQVBcXG5cXHR2QW5pc290cm9weU1hcFV2ID0gKCBhbmlzb3Ryb3B5TWFwVHJhbnNmb3JtICogdmVjMyggQU5JU09UUk9QWU1BUF9VViwgMSApICkueHk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRNQVBcXG5cXHR2Q2xlYXJjb2F0TWFwVXYgPSAoIGNsZWFyY29hdE1hcFRyYW5zZm9ybSAqIHZlYzMoIENMRUFSQ09BVE1BUF9VViwgMSApICkueHk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQXFxuXFx0dkNsZWFyY29hdE5vcm1hbE1hcFV2ID0gKCBjbGVhcmNvYXROb3JtYWxNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBDTEVBUkNPQVRfTk9STUFMTUFQX1VWLCAxICkgKS54eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVBcXG5cXHR2Q2xlYXJjb2F0Um91Z2huZXNzTWFwVXYgPSAoIGNsZWFyY29hdFJvdWdobmVzc01hcFRyYW5zZm9ybSAqIHZlYzMoIENMRUFSQ09BVF9ST1VHSE5FU1NNQVBfVVYsIDEgKSApLnh5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VNQVBcXG5cXHR2SXJpZGVzY2VuY2VNYXBVdiA9ICggaXJpZGVzY2VuY2VNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBJUklERVNDRU5DRU1BUF9VViwgMSApICkueHk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVBcXG5cXHR2SXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdiA9ICggaXJpZGVzY2VuY2VUaGlja25lc3NNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBJUklERVNDRU5DRV9USElDS05FU1NNQVBfVVYsIDEgKSApLnh5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU0hFRU5fQ09MT1JNQVBcXG5cXHR2U2hlZW5Db2xvck1hcFV2ID0gKCBzaGVlbkNvbG9yTWFwVHJhbnNmb3JtICogdmVjMyggU0hFRU5fQ09MT1JNQVBfVVYsIDEgKSApLnh5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU0hFRU5fUk9VR0hORVNTTUFQXFxuXFx0dlNoZWVuUm91Z2huZXNzTWFwVXYgPSAoIHNoZWVuUm91Z2huZXNzTWFwVHJhbnNmb3JtICogdmVjMyggU0hFRU5fUk9VR0hORVNTTUFQX1VWLCAxICkgKS54eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXFx0dlNwZWN1bGFyTWFwVXYgPSAoIHNwZWN1bGFyTWFwVHJhbnNmb3JtICogdmVjMyggU1BFQ1VMQVJNQVBfVVYsIDEgKSApLnh5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU1BFQ1VMQVJfQ09MT1JNQVBcXG5cXHR2U3BlY3VsYXJDb2xvck1hcFV2ID0gKCBzcGVjdWxhckNvbG9yTWFwVHJhbnNmb3JtICogdmVjMyggU1BFQ1VMQVJfQ09MT1JNQVBfVVYsIDEgKSApLnh5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU1BFQ1VMQVJfSU5URU5TSVRZTUFQXFxuXFx0dlNwZWN1bGFySW50ZW5zaXR5TWFwVXYgPSAoIHNwZWN1bGFySW50ZW5zaXR5TWFwVHJhbnNmb3JtICogdmVjMyggU1BFQ1VMQVJfSU5URU5TSVRZTUFQX1VWLCAxICkgKS54eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1RSQU5TTUlTU0lPTk1BUFxcblxcdHZUcmFuc21pc3Npb25NYXBVdiA9ICggdHJhbnNtaXNzaW9uTWFwVHJhbnNmb3JtICogdmVjMyggVFJBTlNNSVNTSU9OTUFQX1VWLCAxICkgKS54eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1RISUNLTkVTU01BUFxcblxcdHZUaGlja25lc3NNYXBVdiA9ICggdGhpY2tuZXNzTWFwVHJhbnNmb3JtICogdmVjMyggVEhJQ0tORVNTTUFQX1VWLCAxICkgKS54eTtcXG4jZW5kaWZcIjtcblxudmFyIHdvcmxkcG9zX3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBESVNUQU5DRSApIHx8IGRlZmluZWQgKCBVU0VfU0hBRE9XTUFQICkgfHwgZGVmaW5lZCAoIFVTRV9UUkFOU01JU1NJT04gKSB8fCBOVU1fU1BPVF9MSUdIVF9DT09SRFMgPiAwXFxuXFx0dmVjNCB3b3JsZFBvc2l0aW9uID0gdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblxcdCNpZmRlZiBVU0VfQkFUQ0hJTkdcXG5cXHRcXHR3b3JsZFBvc2l0aW9uID0gYmF0Y2hpbmdNYXRyaXggKiB3b3JsZFBvc2l0aW9uO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfSU5TVEFOQ0lOR1xcblxcdFxcdHdvcmxkUG9zaXRpb24gPSBpbnN0YW5jZU1hdHJpeCAqIHdvcmxkUG9zaXRpb247XFxuXFx0I2VuZGlmXFxuXFx0d29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogd29ybGRQb3NpdGlvbjtcXG4jZW5kaWZcIjtcblxuY29uc3QgdmVydGV4JGggPSBcInZhcnlpbmcgdmVjMiB2VXY7XFxudW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xcbnZvaWQgbWFpbigpIHtcXG5cXHR2VXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggdXYsIDEgKSApLnh5O1xcblxcdGdsX1Bvc2l0aW9uID0gdmVjNCggcG9zaXRpb24ueHksIDEuMCwgMS4wICk7XFxufVwiO1xuXG5jb25zdCBmcmFnbWVudCRoID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCB0MkQ7XFxudW5pZm9ybSBmbG9hdCBiYWNrZ3JvdW5kSW50ZW5zaXR5O1xcbnZhcnlpbmcgdmVjMiB2VXY7XFxudm9pZCBtYWluKCkge1xcblxcdHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQoIHQyRCwgdlV2ICk7XFxuXFx0I2lmZGVmIERFQ09ERV9WSURFT19URVhUVVJFXFxuXFx0XFx0dGV4Q29sb3IgPSB2ZWM0KCBtaXgoIHBvdyggdGV4Q29sb3IucmdiICogMC45NDc4NjcyOTg2ICsgdmVjMyggMC4wNTIxMzI3MDE0ICksIHZlYzMoIDIuNCApICksIHRleENvbG9yLnJnYiAqIDAuMDc3Mzk5MzgwOCwgdmVjMyggbGVzc1RoYW5FcXVhbCggdGV4Q29sb3IucmdiLCB2ZWMzKCAwLjA0MDQ1ICkgKSApICksIHRleENvbG9yLncgKTtcXG5cXHQjZW5kaWZcXG5cXHR0ZXhDb2xvci5yZ2IgKj0gYmFja2dyb3VuZEludGVuc2l0eTtcXG5cXHRnbF9GcmFnQ29sb3IgPSB0ZXhDb2xvcjtcXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkZyA9IFwidmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdGdsX1Bvc2l0aW9uLnogPSBnbF9Qb3NpdGlvbi53O1xcbn1cIjtcblxuY29uc3QgZnJhZ21lbnQkZyA9IFwiI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cXHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG4jZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XFxuI2VuZGlmXFxudW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwO1xcbnVuaWZvcm0gZmxvYXQgYmFja2dyb3VuZEJsdXJyaW5lc3M7XFxudW5pZm9ybSBmbG9hdCBiYWNrZ3JvdW5kSW50ZW5zaXR5O1xcbnVuaWZvcm0gbWF0MyBiYWNrZ3JvdW5kUm90YXRpb247XFxudmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG4jaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblxcdFxcdHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBiYWNrZ3JvdW5kUm90YXRpb24gKiB2ZWMzKCBmbGlwRW52TWFwICogdldvcmxkRGlyZWN0aW9uLngsIHZXb3JsZERpcmVjdGlvbi55eiApICk7XFxuXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXFxuXFx0XFx0dmVjNCB0ZXhDb2xvciA9IHRleHR1cmVDdWJlVVYoIGVudk1hcCwgYmFja2dyb3VuZFJvdGF0aW9uICogdldvcmxkRGlyZWN0aW9uLCBiYWNrZ3JvdW5kQmx1cnJpbmVzcyApO1xcblxcdCNlbHNlXFxuXFx0XFx0dmVjNCB0ZXhDb2xvciA9IHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1xcblxcdCNlbmRpZlxcblxcdHRleENvbG9yLnJnYiAqPSBiYWNrZ3JvdW5kSW50ZW5zaXR5O1xcblxcdGdsX0ZyYWdDb2xvciA9IHRleENvbG9yO1xcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG59XCI7XG5cbmNvbnN0IHZlcnRleCRmID0gXCJ2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxudm9pZCBtYWluKCkge1xcblxcdHZXb3JsZERpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0Z2xfUG9zaXRpb24ueiA9IGdsX1Bvc2l0aW9uLnc7XFxufVwiO1xuXG5jb25zdCBmcmFnbWVudCRmID0gXCJ1bmlmb3JtIHNhbXBsZXJDdWJlIHRDdWJlO1xcbnVuaWZvcm0gZmxvYXQgdEZsaXA7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247XFxudm9pZCBtYWluKCkge1xcblxcdHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlQ3ViZSggdEN1YmUsIHZlYzMoIHRGbGlwICogdldvcmxkRGlyZWN0aW9uLngsIHZXb3JsZERpcmVjdGlvbi55eiApICk7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdGV4Q29sb3I7XFxuXFx0Z2xfRnJhZ0NvbG9yLmEgKj0gb3BhY2l0eTtcXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkZSA9IFwiI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52YXJ5aW5nIHZlYzIgdkhpZ2hQcmVjaXNpb25aVztcXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoaW5zdGFuY2VfdmVydGV4PlxcblxcdCNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFx0XFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2SGlnaFByZWNpc2lvblpXID0gZ2xfUG9zaXRpb24uenc7XFxufVwiO1xuXG5jb25zdCBmcmFnbWVudCRlID0gXCIjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0dW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZhcnlpbmcgdmVjMiB2SGlnaFByZWNpc2lvblpXO1xcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIDEuMCApO1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0I2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxcblxcdFxcdGRpZmZ1c2VDb2xvci5hID0gb3BhY2l0eTtcXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdGZsb2F0IGZyYWdDb29yZFogPSAwLjUgKiB2SGlnaFByZWNpc2lvblpXWzBdIC8gdkhpZ2hQcmVjaXNpb25aV1sxXSArIDAuNTtcXG5cXHQjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggMS4wIC0gZnJhZ0Nvb3JkWiApLCBvcGFjaXR5ICk7XFxuXFx0I2VsaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gcGFja0RlcHRoVG9SR0JBKCBmcmFnQ29vcmRaICk7XFxuXFx0I2VsaWYgREVQVEhfUEFDS0lORyA9PSAzMjAyXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggcGFja0RlcHRoVG9SR0IoIGZyYWdDb29yZFogKSwgMS4wICk7XFxuXFx0I2VsaWYgREVQVEhfUEFDS0lORyA9PSAzMjAzXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggcGFja0RlcHRoVG9SRyggZnJhZ0Nvb3JkWiApLCAwLjAsIDEuMCApO1xcblxcdCNlbmRpZlxcbn1cIjtcblxuY29uc3QgdmVydGV4JGQgPSBcIiNkZWZpbmUgRElTVEFOQ0VcXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+XFxuXFx0I2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXHRcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XFxufVwiO1xuXG5jb25zdCBmcmFnbWVudCRkID0gXCIjZGVmaW5lIERJU1RBTkNFXFxudW5pZm9ybSB2ZWMzIHJlZmVyZW5jZVBvc2l0aW9uO1xcbnVuaWZvcm0gZmxvYXQgbmVhckRpc3RhbmNlO1xcbnVuaWZvcm0gZmxvYXQgZmFyRGlzdGFuY2U7XFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbiAoKSB7XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCAxLjAgKTtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD5cXG5cXHRmbG9hdCBkaXN0ID0gbGVuZ3RoKCB2V29ybGRQb3NpdGlvbiAtIHJlZmVyZW5jZVBvc2l0aW9uICk7XFxuXFx0ZGlzdCA9ICggZGlzdCAtIG5lYXJEaXN0YW5jZSApIC8gKCBmYXJEaXN0YW5jZSAtIG5lYXJEaXN0YW5jZSApO1xcblxcdGRpc3QgPSBzYXR1cmF0ZSggZGlzdCApO1xcblxcdGdsX0ZyYWdDb2xvciA9IHBhY2tEZXB0aFRvUkdCQSggZGlzdCApO1xcbn1cIjtcblxuY29uc3QgdmVydGV4JGMgPSBcInZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG52b2lkIG1haW4oKSB7XFxuXFx0dldvcmxkRGlyZWN0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG59XCI7XG5cbmNvbnN0IGZyYWdtZW50JGMgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHRFcXVpcmVjdDtcXG52YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxudm9pZCBtYWluKCkge1xcblxcdHZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGREaXJlY3Rpb24gKTtcXG5cXHR2ZWMyIHNhbXBsZVVWID0gZXF1aXJlY3RVdiggZGlyZWN0aW9uICk7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB0RXF1aXJlY3QsIHNhbXBsZVVWICk7XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50Plxcbn1cIjtcblxuY29uc3QgdmVydGV4JGIgPSBcInVuaWZvcm0gZmxvYXQgc2NhbGU7XFxuYXR0cmlidXRlIGZsb2F0IGxpbmVEaXN0YW5jZTtcXG52YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2TGluZURpc3RhbmNlID0gc2NhbGUgKiBsaW5lRGlzdGFuY2U7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaGluc3RhbmNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cIjtcblxuY29uc3QgZnJhZ21lbnQkYiA9IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gZmxvYXQgZGFzaFNpemU7XFxudW5pZm9ybSBmbG9hdCB0b3RhbFNpemU7XFxudmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0aWYgKCBtb2QoIHZMaW5lRGlzdGFuY2UsIHRvdGFsU2l6ZSApID4gZGFzaFNpemUgKSB7XFxuXFx0XFx0ZGlzY2FyZDtcXG5cXHR9XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1xcblxcdCNpbmNsdWRlIDxvcGFxdWVfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkYSA9IFwiI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaGluc3RhbmNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJhdGNoaW5nX3ZlcnRleD5cXG5cXHQjaWYgZGVmaW5lZCAoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkICggVVNFX1NLSU5OSU5HIClcXG5cXHRcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVwiO1xuXG5jb25zdCBmcmFnbWVudCRhID0gXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0I2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdFxcdHZlYzQgbGlnaHRNYXBUZXhlbCA9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZMaWdodE1hcFV2ICk7XFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGxpZ2h0TWFwVGV4ZWwucmdiICogbGlnaHRNYXBJbnRlbnNpdHkgKiBSRUNJUFJPQ0FMX1BJO1xcblxcdCNlbHNlXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IHZlYzMoIDEuMCApO1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gZGlmZnVzZUNvbG9yLnJnYjtcXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2U7XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkOSA9IFwiI2RlZmluZSBMQU1CRVJUXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaGluc3RhbmNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJhdGNoaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVwiO1xuXG5jb25zdCBmcmFnbWVudCQ5ID0gXCIjZGVmaW5lIExBTUJFUlRcXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnNkZnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPlxcbiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRzX2xhbWJlcnRfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfbGFtYmVydF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfbWFwcz5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD5cXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcXG5cXHQjaW5jbHVkZSA8ZW52bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxvcGFxdWVfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXG59XCI7XG5cbmNvbnN0IHZlcnRleCQ4ID0gXCIjZGVmaW5lIE1BVENBUFxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaGluc3RhbmNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJhdGNoaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcbn1cIjtcblxuY29uc3QgZnJhZ21lbnQkOCA9IFwiI2RlZmluZSBNQVRDQVBcXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSBzYW1wbGVyMkQgbWF0Y2FwO1xcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxcblxcdHZlYzMgdmlld0RpciA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1xcblxcdHZlYzMgeCA9IG5vcm1hbGl6ZSggdmVjMyggdmlld0Rpci56LCAwLjAsIC0gdmlld0Rpci54ICkgKTtcXG5cXHR2ZWMzIHkgPSBjcm9zcyggdmlld0RpciwgeCApO1xcblxcdHZlYzIgdXYgPSB2ZWMyKCBkb3QoIHgsIG5vcm1hbCApLCBkb3QoIHksIG5vcm1hbCApICkgKiAwLjQ5NSArIDAuNTtcXG5cXHQjaWZkZWYgVVNFX01BVENBUFxcblxcdFxcdHZlYzQgbWF0Y2FwQ29sb3IgPSB0ZXh0dXJlMkQoIG1hdGNhcCwgdXYgKTtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzQgbWF0Y2FwQ29sb3IgPSB2ZWM0KCB2ZWMzKCBtaXgoIDAuMiwgMC44LCB1di55ICkgKSwgMS4wICk7XFxuXFx0I2VuZGlmXFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYiAqIG1hdGNhcENvbG9yLnJnYjtcXG5cXHQjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkNyA9IFwiI2RlZmluZSBOT1JNQUxcXG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFIClcXG5cXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxiYXRjaGluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJhdGNoaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaGluc3RhbmNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFIClcXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG4jZW5kaWZcXG59XCI7XG5cbmNvbnN0IGZyYWdtZW50JDcgPSBcIiNkZWZpbmUgTk9STUFMXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUF9UQU5HRU5UU1BBQ0UgKVxcblxcdHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggMC4wLCAwLjAsIDAuMCwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHBhY2tOb3JtYWxUb1JHQiggbm9ybWFsICksIGRpZmZ1c2VDb2xvci5hICk7XFxuXFx0I2lmZGVmIE9QQVFVRVxcblxcdFxcdGdsX0ZyYWdDb2xvci5hID0gMS4wO1xcblxcdCNlbmRpZlxcbn1cIjtcblxuY29uc3QgdmVydGV4JDYgPSBcIiNkZWZpbmUgUEhPTkdcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxiYXRjaGluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG5cbmNvbnN0IGZyYWdtZW50JDYgPSBcIiNkZWZpbmUgUEhPTkdcXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxudW5pZm9ybSB2ZWMzIHNwZWN1bGFyO1xcbnVuaWZvcm0gZmxvYXQgc2hpbmluZXNzO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxzcGVjdWxhcm1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz5cXG5cXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19waG9uZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfbWFwcz5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD5cXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcXG5cXHQjaW5jbHVkZSA8ZW52bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxvcGFxdWVfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXG59XCI7XG5cbmNvbnN0IHZlcnRleCQ1ID0gXCIjZGVmaW5lIFNUQU5EQVJEXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cXG5cXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxcbiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXFxuXFx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG4jZW5kaWZcXG59XCI7XG5cbmNvbnN0IGZyYWdtZW50JDUgPSBcIiNkZWZpbmUgU1RBTkRBUkRcXG4jaWZkZWYgUEhZU0lDQUxcXG5cXHQjZGVmaW5lIElPUlxcblxcdCNkZWZpbmUgVVNFX1NQRUNVTEFSXFxuI2VuZGlmXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gZmxvYXQgcm91Z2huZXNzO1xcbnVuaWZvcm0gZmxvYXQgbWV0YWxuZXNzO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaWZkZWYgSU9SXFxuXFx0dW5pZm9ybSBmbG9hdCBpb3I7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9TUEVDVUxBUlxcblxcdHVuaWZvcm0gZmxvYXQgc3BlY3VsYXJJbnRlbnNpdHk7XFxuXFx0dW5pZm9ybSB2ZWMzIHNwZWN1bGFyQ29sb3I7XFxuXFx0I2lmZGVmIFVTRV9TUEVDVUxBUl9DT0xPUk1BUFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyQ29sb3JNYXA7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9TUEVDVUxBUl9JTlRFTlNJVFlNQVBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhckludGVuc2l0eU1hcDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdHVuaWZvcm0gZmxvYXQgY2xlYXJjb2F0O1xcblxcdHVuaWZvcm0gZmxvYXQgY2xlYXJjb2F0Um91Z2huZXNzO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfRElTUEVSU0lPTlxcblxcdHVuaWZvcm0gZmxvYXQgZGlzcGVyc2lvbjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0lSSURFU0NFTkNFXFxuXFx0dW5pZm9ybSBmbG9hdCBpcmlkZXNjZW5jZTtcXG5cXHR1bmlmb3JtIGZsb2F0IGlyaWRlc2NlbmNlSU9SO1xcblxcdHVuaWZvcm0gZmxvYXQgaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtO1xcblxcdHVuaWZvcm0gZmxvYXQgaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU0hFRU5cXG5cXHR1bmlmb3JtIHZlYzMgc2hlZW5Db2xvcjtcXG5cXHR1bmlmb3JtIGZsb2F0IHNoZWVuUm91Z2huZXNzO1xcblxcdCNpZmRlZiBVU0VfU0hFRU5fQ09MT1JNQVBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBzaGVlbkNvbG9yTWFwO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfU0hFRU5fUk9VR0hORVNTTUFQXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgc2hlZW5Sb3VnaG5lc3NNYXA7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9BTklTT1RST1BZXFxuXFx0dW5pZm9ybSB2ZWMyIGFuaXNvdHJvcHlWZWN0b3I7XFxuXFx0I2lmZGVmIFVTRV9BTklTT1RST1BZTUFQXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgYW5pc290cm9weU1hcDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8aXJpZGVzY2VuY2VfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGh5c2ljYWxfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPlxcbiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHRyYW5zbWlzc2lvbl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xlYXJjb2F0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGlyaWRlc2NlbmNlX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1ldGFsbmVzc21hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz5cXG5cXHQjaW5jbHVkZSA8Y2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8Y2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9tYXBzPlxcblxcdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9tYXBzPlxcblxcdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfZW5kPlxcblxcdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cXG5cXHR2ZWMzIHRvdGFsRGlmZnVzZSA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2U7XFxuXFx0dmVjMyB0b3RhbFNwZWN1bGFyID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyO1xcblxcdCNpbmNsdWRlIDx0cmFuc21pc3Npb25fZnJhZ21lbnQ+XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdG90YWxEaWZmdXNlICsgdG90YWxTcGVjdWxhciArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcXG5cXHQjaWZkZWYgVVNFX1NIRUVOXFxuXFx0XFx0ZmxvYXQgc2hlZW5FbmVyZ3lDb21wID0gMS4wIC0gMC4xNTcgKiBtYXgzKCBtYXRlcmlhbC5zaGVlbkNvbG9yICk7XFxuXFx0XFx0b3V0Z29pbmdMaWdodCA9IG91dGdvaW5nTGlnaHQgKiBzaGVlbkVuZXJneUNvbXAgKyBzaGVlblNwZWN1bGFyRGlyZWN0ICsgc2hlZW5TcGVjdWxhckluZGlyZWN0O1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfQ0xFQVJDT0FUXFxuXFx0XFx0ZmxvYXQgZG90TlZjYyA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIgKSApO1xcblxcdFxcdHZlYzMgRmNjID0gRl9TY2hsaWNrKCBtYXRlcmlhbC5jbGVhcmNvYXRGMCwgbWF0ZXJpYWwuY2xlYXJjb2F0RjkwLCBkb3ROVmNjICk7XFxuXFx0XFx0b3V0Z29pbmdMaWdodCA9IG91dGdvaW5nTGlnaHQgKiAoIDEuMCAtIG1hdGVyaWFsLmNsZWFyY29hdCAqIEZjYyApICsgKCBjbGVhcmNvYXRTcGVjdWxhckRpcmVjdCArIGNsZWFyY29hdFNwZWN1bGFySW5kaXJlY3QgKSAqIG1hdGVyaWFsLmNsZWFyY29hdDtcXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkNCA9IFwiI2RlZmluZSBUT09OXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cIjtcblxuY29uc3QgZnJhZ21lbnQkNCA9IFwiI2RlZmluZSBUT09OXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Z3JhZGllbnRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0c190b29uX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xcblxcdHZlYzMgdG90YWxFbWlzc2l2ZVJhZGlhbmNlID0gZW1pc3NpdmU7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfdG9vbl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfbWFwcz5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD5cXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcXG5cXHQjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkMyA9IFwidW5pZm9ybSBmbG9hdCBzaXplO1xcbnVuaWZvcm0gZmxvYXQgc2NhbGU7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxuI2lmZGVmIFVTRV9QT0lOVFNfVVZcXG5cXHR2YXJ5aW5nIHZlYzIgdlV2O1xcblxcdHVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTtcXG4jZW5kaWZcXG52b2lkIG1haW4oKSB7XFxuXFx0I2lmZGVmIFVTRV9QT0lOVFNfVVZcXG5cXHRcXHR2VXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggdXYsIDEgKSApLnh5O1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoaW5zdGFuY2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdGdsX1BvaW50U2l6ZSA9IHNpemU7XFxuXFx0I2lmZGVmIFVTRV9TSVpFQVRURU5VQVRJT05cXG5cXHRcXHRib29sIGlzUGVyc3BlY3RpdmUgPSBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICk7XFxuXFx0XFx0aWYgKCBpc1BlcnNwZWN0aXZlICkgZ2xfUG9pbnRTaXplICo9ICggc2NhbGUgLyAtIG12UG9zaXRpb24ueiApO1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG5cbmNvbnN0IGZyYWdtZW50JDMgPSBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfcGFydGljbGVfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD5cXG5cXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5cXHQjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50Plxcbn1cIjtcblxuY29uc3QgdmVydGV4JDIgPSBcIiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGJhdGNoaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaGluc3RhbmNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cIjtcblxuY29uc3QgZnJhZ21lbnQkMiA9IFwidW5pZm9ybSB2ZWMzIGNvbG9yO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnNkZnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFza19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IsIG9wYWNpdHkgKiAoIDEuMCAtIGdldFNoYWRvd01hc2soKSApICk7XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkMSA9IFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcXG51bmlmb3JtIHZlYzIgY2VudGVyO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4WyAzIF07XFxuXFx0dmVjMiBzY2FsZSA9IHZlYzIoIGxlbmd0aCggbW9kZWxNYXRyaXhbIDAgXS54eXogKSwgbGVuZ3RoKCBtb2RlbE1hdHJpeFsgMSBdLnh5eiApICk7XFxuXFx0I2lmbmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OXFxuXFx0XFx0Ym9vbCBpc1BlcnNwZWN0aXZlID0gaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApO1xcblxcdFxcdGlmICggaXNQZXJzcGVjdGl2ZSApIHNjYWxlICo9IC0gbXZQb3NpdGlvbi56O1xcblxcdCNlbmRpZlxcblxcdHZlYzIgYWxpZ25lZFBvc2l0aW9uID0gKCBwb3NpdGlvbi54eSAtICggY2VudGVyIC0gdmVjMiggMC41ICkgKSApICogc2NhbGU7XFxuXFx0dmVjMiByb3RhdGVkUG9zaXRpb247XFxuXFx0cm90YXRlZFBvc2l0aW9uLnggPSBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55O1xcblxcdHJvdGF0ZWRQb3NpdGlvbi55ID0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTtcXG5cXHRtdlBvc2l0aW9uLnh5ICs9IHJvdGF0ZWRQb3NpdGlvbjtcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVwiO1xuXG5jb25zdCBmcmFnbWVudCQxID0gXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+XFxuXFx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxuXFx0I2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG59XCI7XG5cbmNvbnN0IFNoYWRlckNodW5rID0ge1xuXHRhbHBoYWhhc2hfZnJhZ21lbnQ6IGFscGhhaGFzaF9mcmFnbWVudCxcblx0YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ6IGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50LFxuXHRhbHBoYW1hcF9mcmFnbWVudDogYWxwaGFtYXBfZnJhZ21lbnQsXG5cdGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ6IGFscGhhbWFwX3BhcnNfZnJhZ21lbnQsXG5cdGFscGhhdGVzdF9mcmFnbWVudDogYWxwaGF0ZXN0X2ZyYWdtZW50LFxuXHRhbHBoYXRlc3RfcGFyc19mcmFnbWVudDogYWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQsXG5cdGFvbWFwX2ZyYWdtZW50OiBhb21hcF9mcmFnbWVudCxcblx0YW9tYXBfcGFyc19mcmFnbWVudDogYW9tYXBfcGFyc19mcmFnbWVudCxcblx0YmF0Y2hpbmdfcGFyc192ZXJ0ZXg6IGJhdGNoaW5nX3BhcnNfdmVydGV4LFxuXHRiYXRjaGluZ192ZXJ0ZXg6IGJhdGNoaW5nX3ZlcnRleCxcblx0YmVnaW5fdmVydGV4OiBiZWdpbl92ZXJ0ZXgsXG5cdGJlZ2lubm9ybWFsX3ZlcnRleDogYmVnaW5ub3JtYWxfdmVydGV4LFxuXHRic2RmczogYnNkZnMsXG5cdGlyaWRlc2NlbmNlX2ZyYWdtZW50OiBpcmlkZXNjZW5jZV9mcmFnbWVudCxcblx0YnVtcG1hcF9wYXJzX2ZyYWdtZW50OiBidW1wbWFwX3BhcnNfZnJhZ21lbnQsXG5cdGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudDogY2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50LFxuXHRjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudDogY2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQsXG5cdGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleDogY2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4LFxuXHRjbGlwcGluZ19wbGFuZXNfdmVydGV4OiBjbGlwcGluZ19wbGFuZXNfdmVydGV4LFxuXHRjb2xvcl9mcmFnbWVudDogY29sb3JfZnJhZ21lbnQsXG5cdGNvbG9yX3BhcnNfZnJhZ21lbnQ6IGNvbG9yX3BhcnNfZnJhZ21lbnQsXG5cdGNvbG9yX3BhcnNfdmVydGV4OiBjb2xvcl9wYXJzX3ZlcnRleCxcblx0Y29sb3JfdmVydGV4OiBjb2xvcl92ZXJ0ZXgsXG5cdGNvbW1vbjogY29tbW9uLFxuXHRjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ6IGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudCxcblx0ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg6IGRlZmF1bHRub3JtYWxfdmVydGV4LFxuXHRkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg6IGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCxcblx0ZGlzcGxhY2VtZW50bWFwX3ZlcnRleDogZGlzcGxhY2VtZW50bWFwX3ZlcnRleCxcblx0ZW1pc3NpdmVtYXBfZnJhZ21lbnQ6IGVtaXNzaXZlbWFwX2ZyYWdtZW50LFxuXHRlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50OiBlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50LFxuXHRjb2xvcnNwYWNlX2ZyYWdtZW50OiBjb2xvcnNwYWNlX2ZyYWdtZW50LFxuXHRjb2xvcnNwYWNlX3BhcnNfZnJhZ21lbnQ6IGNvbG9yc3BhY2VfcGFyc19mcmFnbWVudCxcblx0ZW52bWFwX2ZyYWdtZW50OiBlbnZtYXBfZnJhZ21lbnQsXG5cdGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudDogZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50LFxuXHRlbnZtYXBfcGFyc19mcmFnbWVudDogZW52bWFwX3BhcnNfZnJhZ21lbnQsXG5cdGVudm1hcF9wYXJzX3ZlcnRleDogZW52bWFwX3BhcnNfdmVydGV4LFxuXHRlbnZtYXBfcGh5c2ljYWxfcGFyc19mcmFnbWVudDogZW52bWFwX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQsXG5cdGVudm1hcF92ZXJ0ZXg6IGVudm1hcF92ZXJ0ZXgsXG5cdGZvZ192ZXJ0ZXg6IGZvZ192ZXJ0ZXgsXG5cdGZvZ19wYXJzX3ZlcnRleDogZm9nX3BhcnNfdmVydGV4LFxuXHRmb2dfZnJhZ21lbnQ6IGZvZ19mcmFnbWVudCxcblx0Zm9nX3BhcnNfZnJhZ21lbnQ6IGZvZ19wYXJzX2ZyYWdtZW50LFxuXHRncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50OiBncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50LFxuXHRsaWdodG1hcF9wYXJzX2ZyYWdtZW50OiBsaWdodG1hcF9wYXJzX2ZyYWdtZW50LFxuXHRsaWdodHNfbGFtYmVydF9mcmFnbWVudDogbGlnaHRzX2xhbWJlcnRfZnJhZ21lbnQsXG5cdGxpZ2h0c19sYW1iZXJ0X3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19sYW1iZXJ0X3BhcnNfZnJhZ21lbnQsXG5cdGxpZ2h0c19wYXJzX2JlZ2luOiBsaWdodHNfcGFyc19iZWdpbixcblx0bGlnaHRzX3Rvb25fZnJhZ21lbnQ6IGxpZ2h0c190b29uX2ZyYWdtZW50LFxuXHRsaWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50OiBsaWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50LFxuXHRsaWdodHNfcGhvbmdfZnJhZ21lbnQ6IGxpZ2h0c19waG9uZ19mcmFnbWVudCxcblx0bGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50LFxuXHRsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQ6IGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudCxcblx0bGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50LFxuXHRsaWdodHNfZnJhZ21lbnRfYmVnaW46IGxpZ2h0c19mcmFnbWVudF9iZWdpbixcblx0bGlnaHRzX2ZyYWdtZW50X21hcHM6IGxpZ2h0c19mcmFnbWVudF9tYXBzLFxuXHRsaWdodHNfZnJhZ21lbnRfZW5kOiBsaWdodHNfZnJhZ21lbnRfZW5kLFxuXHRsb2dkZXB0aGJ1Zl9mcmFnbWVudDogbG9nZGVwdGhidWZfZnJhZ21lbnQsXG5cdGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ6IGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQsXG5cdGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4OiBsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCxcblx0bG9nZGVwdGhidWZfdmVydGV4OiBsb2dkZXB0aGJ1Zl92ZXJ0ZXgsXG5cdG1hcF9mcmFnbWVudDogbWFwX2ZyYWdtZW50LFxuXHRtYXBfcGFyc19mcmFnbWVudDogbWFwX3BhcnNfZnJhZ21lbnQsXG5cdG1hcF9wYXJ0aWNsZV9mcmFnbWVudDogbWFwX3BhcnRpY2xlX2ZyYWdtZW50LFxuXHRtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudDogbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQsXG5cdG1ldGFsbmVzc21hcF9mcmFnbWVudDogbWV0YWxuZXNzbWFwX2ZyYWdtZW50LFxuXHRtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudDogbWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQsXG5cdG1vcnBoaW5zdGFuY2VfdmVydGV4OiBtb3JwaGluc3RhbmNlX3ZlcnRleCxcblx0bW9ycGhjb2xvcl92ZXJ0ZXg6IG1vcnBoY29sb3JfdmVydGV4LFxuXHRtb3JwaG5vcm1hbF92ZXJ0ZXg6IG1vcnBobm9ybWFsX3ZlcnRleCxcblx0bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg6IG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4LFxuXHRtb3JwaHRhcmdldF92ZXJ0ZXg6IG1vcnBodGFyZ2V0X3ZlcnRleCxcblx0bm9ybWFsX2ZyYWdtZW50X2JlZ2luOiBub3JtYWxfZnJhZ21lbnRfYmVnaW4sXG5cdG5vcm1hbF9mcmFnbWVudF9tYXBzOiBub3JtYWxfZnJhZ21lbnRfbWFwcyxcblx0bm9ybWFsX3BhcnNfZnJhZ21lbnQ6IG5vcm1hbF9wYXJzX2ZyYWdtZW50LFxuXHRub3JtYWxfcGFyc192ZXJ0ZXg6IG5vcm1hbF9wYXJzX3ZlcnRleCxcblx0bm9ybWFsX3ZlcnRleDogbm9ybWFsX3ZlcnRleCxcblx0bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ6IG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50LFxuXHRjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X2JlZ2luOiBjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X2JlZ2luLFxuXHRjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X21hcHM6IGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfbWFwcyxcblx0Y2xlYXJjb2F0X3BhcnNfZnJhZ21lbnQ6IGNsZWFyY29hdF9wYXJzX2ZyYWdtZW50LFxuXHRpcmlkZXNjZW5jZV9wYXJzX2ZyYWdtZW50OiBpcmlkZXNjZW5jZV9wYXJzX2ZyYWdtZW50LFxuXHRvcGFxdWVfZnJhZ21lbnQ6IG9wYXF1ZV9mcmFnbWVudCxcblx0cGFja2luZzogcGFja2luZyxcblx0cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudDogcHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudCxcblx0cHJvamVjdF92ZXJ0ZXg6IHByb2plY3RfdmVydGV4LFxuXHRkaXRoZXJpbmdfZnJhZ21lbnQ6IGRpdGhlcmluZ19mcmFnbWVudCxcblx0ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ6IGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50LFxuXHRyb3VnaG5lc3NtYXBfZnJhZ21lbnQ6IHJvdWdobmVzc21hcF9mcmFnbWVudCxcblx0cm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQ6IHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50LFxuXHRzaGFkb3dtYXBfcGFyc19mcmFnbWVudDogc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQsXG5cdHNoYWRvd21hcF9wYXJzX3ZlcnRleDogc2hhZG93bWFwX3BhcnNfdmVydGV4LFxuXHRzaGFkb3dtYXBfdmVydGV4OiBzaGFkb3dtYXBfdmVydGV4LFxuXHRzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ6IHNoYWRvd21hc2tfcGFyc19mcmFnbWVudCxcblx0c2tpbmJhc2VfdmVydGV4OiBza2luYmFzZV92ZXJ0ZXgsXG5cdHNraW5uaW5nX3BhcnNfdmVydGV4OiBza2lubmluZ19wYXJzX3ZlcnRleCxcblx0c2tpbm5pbmdfdmVydGV4OiBza2lubmluZ192ZXJ0ZXgsXG5cdHNraW5ub3JtYWxfdmVydGV4OiBza2lubm9ybWFsX3ZlcnRleCxcblx0c3BlY3VsYXJtYXBfZnJhZ21lbnQ6IHNwZWN1bGFybWFwX2ZyYWdtZW50LFxuXHRzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50OiBzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50LFxuXHR0b25lbWFwcGluZ19mcmFnbWVudDogdG9uZW1hcHBpbmdfZnJhZ21lbnQsXG5cdHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQ6IHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQsXG5cdHRyYW5zbWlzc2lvbl9mcmFnbWVudDogdHJhbnNtaXNzaW9uX2ZyYWdtZW50LFxuXHR0cmFuc21pc3Npb25fcGFyc19mcmFnbWVudDogdHJhbnNtaXNzaW9uX3BhcnNfZnJhZ21lbnQsXG5cdHV2X3BhcnNfZnJhZ21lbnQ6IHV2X3BhcnNfZnJhZ21lbnQsXG5cdHV2X3BhcnNfdmVydGV4OiB1dl9wYXJzX3ZlcnRleCxcblx0dXZfdmVydGV4OiB1dl92ZXJ0ZXgsXG5cdHdvcmxkcG9zX3ZlcnRleDogd29ybGRwb3NfdmVydGV4LFxuXG5cdGJhY2tncm91bmRfdmVydDogdmVydGV4JGgsXG5cdGJhY2tncm91bmRfZnJhZzogZnJhZ21lbnQkaCxcblx0YmFja2dyb3VuZEN1YmVfdmVydDogdmVydGV4JGcsXG5cdGJhY2tncm91bmRDdWJlX2ZyYWc6IGZyYWdtZW50JGcsXG5cdGN1YmVfdmVydDogdmVydGV4JGYsXG5cdGN1YmVfZnJhZzogZnJhZ21lbnQkZixcblx0ZGVwdGhfdmVydDogdmVydGV4JGUsXG5cdGRlcHRoX2ZyYWc6IGZyYWdtZW50JGUsXG5cdGRpc3RhbmNlUkdCQV92ZXJ0OiB2ZXJ0ZXgkZCxcblx0ZGlzdGFuY2VSR0JBX2ZyYWc6IGZyYWdtZW50JGQsXG5cdGVxdWlyZWN0X3ZlcnQ6IHZlcnRleCRjLFxuXHRlcXVpcmVjdF9mcmFnOiBmcmFnbWVudCRjLFxuXHRsaW5lZGFzaGVkX3ZlcnQ6IHZlcnRleCRiLFxuXHRsaW5lZGFzaGVkX2ZyYWc6IGZyYWdtZW50JGIsXG5cdG1lc2hiYXNpY192ZXJ0OiB2ZXJ0ZXgkYSxcblx0bWVzaGJhc2ljX2ZyYWc6IGZyYWdtZW50JGEsXG5cdG1lc2hsYW1iZXJ0X3ZlcnQ6IHZlcnRleCQ5LFxuXHRtZXNobGFtYmVydF9mcmFnOiBmcmFnbWVudCQ5LFxuXHRtZXNobWF0Y2FwX3ZlcnQ6IHZlcnRleCQ4LFxuXHRtZXNobWF0Y2FwX2ZyYWc6IGZyYWdtZW50JDgsXG5cdG1lc2hub3JtYWxfdmVydDogdmVydGV4JDcsXG5cdG1lc2hub3JtYWxfZnJhZzogZnJhZ21lbnQkNyxcblx0bWVzaHBob25nX3ZlcnQ6IHZlcnRleCQ2LFxuXHRtZXNocGhvbmdfZnJhZzogZnJhZ21lbnQkNixcblx0bWVzaHBoeXNpY2FsX3ZlcnQ6IHZlcnRleCQ1LFxuXHRtZXNocGh5c2ljYWxfZnJhZzogZnJhZ21lbnQkNSxcblx0bWVzaHRvb25fdmVydDogdmVydGV4JDQsXG5cdG1lc2h0b29uX2ZyYWc6IGZyYWdtZW50JDQsXG5cdHBvaW50c192ZXJ0OiB2ZXJ0ZXgkMyxcblx0cG9pbnRzX2ZyYWc6IGZyYWdtZW50JDMsXG5cdHNoYWRvd192ZXJ0OiB2ZXJ0ZXgkMixcblx0c2hhZG93X2ZyYWc6IGZyYWdtZW50JDIsXG5cdHNwcml0ZV92ZXJ0OiB2ZXJ0ZXgkMSxcblx0c3ByaXRlX2ZyYWc6IGZyYWdtZW50JDFcbn07XG5cbi8qKlxuICogVW5pZm9ybXMgbGlicmFyeSBmb3Igc2hhcmVkIHdlYmdsIHNoYWRlcnNcbiAqL1xuXG5jb25zdCBVbmlmb3Jtc0xpYiA9IHtcblxuXHRjb21tb246IHtcblxuXHRcdGRpZmZ1c2U6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweGZmZmZmZiApIH0sXG5cdFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH0sXG5cblx0XHRtYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRtYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxuXG5cdFx0YWxwaGFNYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRhbHBoYU1hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH0sXG5cblx0XHRhbHBoYVRlc3Q6IHsgdmFsdWU6IDAgfVxuXG5cdH0sXG5cblx0c3BlY3VsYXJtYXA6IHtcblxuXHRcdHNwZWN1bGFyTWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0c3BlY3VsYXJNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9XG5cblx0fSxcblxuXHRlbnZtYXA6IHtcblxuXHRcdGVudk1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdGVudk1hcFJvdGF0aW9uOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcblx0XHRmbGlwRW52TWFwOiB7IHZhbHVlOiAtIDEgfSxcblx0XHRyZWZsZWN0aXZpdHk6IHsgdmFsdWU6IDEuMCB9LCAvLyBiYXNpYywgbGFtYmVydCwgcGhvbmdcblx0XHRpb3I6IHsgdmFsdWU6IDEuNSB9LCAvLyBwaHlzaWNhbFxuXHRcdHJlZnJhY3Rpb25SYXRpbzogeyB2YWx1ZTogMC45OCB9LCAvLyBiYXNpYywgbGFtYmVydCwgcGhvbmdcblxuXHR9LFxuXG5cdGFvbWFwOiB7XG5cblx0XHRhb01hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdGFvTWFwSW50ZW5zaXR5OiB7IHZhbHVlOiAxIH0sXG5cdFx0YW9NYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9XG5cblx0fSxcblxuXHRsaWdodG1hcDoge1xuXG5cdFx0bGlnaHRNYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRsaWdodE1hcEludGVuc2l0eTogeyB2YWx1ZTogMSB9LFxuXHRcdGxpZ2h0TWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfVxuXG5cdH0sXG5cblx0YnVtcG1hcDoge1xuXG5cdFx0YnVtcE1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdGJ1bXBNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxuXHRcdGJ1bXBTY2FsZTogeyB2YWx1ZTogMSB9XG5cblx0fSxcblxuXHRub3JtYWxtYXA6IHtcblxuXHRcdG5vcm1hbE1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdG5vcm1hbE1hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH0sXG5cdFx0bm9ybWFsU2NhbGU6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoIDEsIDEgKSB9XG5cblx0fSxcblxuXHRkaXNwbGFjZW1lbnRtYXA6IHtcblxuXHRcdGRpc3BsYWNlbWVudE1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdGRpc3BsYWNlbWVudE1hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH0sXG5cdFx0ZGlzcGxhY2VtZW50U2NhbGU6IHsgdmFsdWU6IDEgfSxcblx0XHRkaXNwbGFjZW1lbnRCaWFzOiB7IHZhbHVlOiAwIH1cblxuXHR9LFxuXG5cdGVtaXNzaXZlbWFwOiB7XG5cblx0XHRlbWlzc2l2ZU1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdGVtaXNzaXZlTWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfVxuXG5cdH0sXG5cblx0bWV0YWxuZXNzbWFwOiB7XG5cblx0XHRtZXRhbG5lc3NNYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRtZXRhbG5lc3NNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9XG5cblx0fSxcblxuXHRyb3VnaG5lc3NtYXA6IHtcblxuXHRcdHJvdWdobmVzc01hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdHJvdWdobmVzc01hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH1cblxuXHR9LFxuXG5cdGdyYWRpZW50bWFwOiB7XG5cblx0XHRncmFkaWVudE1hcDogeyB2YWx1ZTogbnVsbCB9XG5cblx0fSxcblxuXHRmb2c6IHtcblxuXHRcdGZvZ0RlbnNpdHk6IHsgdmFsdWU6IDAuMDAwMjUgfSxcblx0XHRmb2dOZWFyOiB7IHZhbHVlOiAxIH0sXG5cdFx0Zm9nRmFyOiB7IHZhbHVlOiAyMDAwIH0sXG5cdFx0Zm9nQ29sb3I6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweGZmZmZmZiApIH1cblxuXHR9LFxuXG5cdGxpZ2h0czoge1xuXG5cdFx0YW1iaWVudExpZ2h0Q29sb3I6IHsgdmFsdWU6IFtdIH0sXG5cblx0XHRsaWdodFByb2JlOiB7IHZhbHVlOiBbXSB9LFxuXG5cdFx0ZGlyZWN0aW9uYWxMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XG5cdFx0XHRkaXJlY3Rpb246IHt9LFxuXHRcdFx0Y29sb3I6IHt9XG5cdFx0fSB9LFxuXG5cdFx0ZGlyZWN0aW9uYWxMaWdodFNoYWRvd3M6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XG5cdFx0XHRzaGFkb3dJbnRlbnNpdHk6IDEsXG5cdFx0XHRzaGFkb3dCaWFzOiB7fSxcblx0XHRcdHNoYWRvd05vcm1hbEJpYXM6IHt9LFxuXHRcdFx0c2hhZG93UmFkaXVzOiB7fSxcblx0XHRcdHNoYWRvd01hcFNpemU6IHt9XG5cdFx0fSB9LFxuXG5cdFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXA6IHsgdmFsdWU6IFtdIH0sXG5cdFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg6IHsgdmFsdWU6IFtdIH0sXG5cblx0XHRzcG90TGlnaHRzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xuXHRcdFx0Y29sb3I6IHt9LFxuXHRcdFx0cG9zaXRpb246IHt9LFxuXHRcdFx0ZGlyZWN0aW9uOiB7fSxcblx0XHRcdGRpc3RhbmNlOiB7fSxcblx0XHRcdGNvbmVDb3M6IHt9LFxuXHRcdFx0cGVudW1icmFDb3M6IHt9LFxuXHRcdFx0ZGVjYXk6IHt9XG5cdFx0fSB9LFxuXG5cdFx0c3BvdExpZ2h0U2hhZG93czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcblx0XHRcdHNoYWRvd0ludGVuc2l0eTogMSxcblx0XHRcdHNoYWRvd0JpYXM6IHt9LFxuXHRcdFx0c2hhZG93Tm9ybWFsQmlhczoge30sXG5cdFx0XHRzaGFkb3dSYWRpdXM6IHt9LFxuXHRcdFx0c2hhZG93TWFwU2l6ZToge31cblx0XHR9IH0sXG5cblx0XHRzcG90TGlnaHRNYXA6IHsgdmFsdWU6IFtdIH0sXG5cdFx0c3BvdFNoYWRvd01hcDogeyB2YWx1ZTogW10gfSxcblx0XHRzcG90TGlnaHRNYXRyaXg6IHsgdmFsdWU6IFtdIH0sXG5cblx0XHRwb2ludExpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcblx0XHRcdGNvbG9yOiB7fSxcblx0XHRcdHBvc2l0aW9uOiB7fSxcblx0XHRcdGRlY2F5OiB7fSxcblx0XHRcdGRpc3RhbmNlOiB7fVxuXHRcdH0gfSxcblxuXHRcdHBvaW50TGlnaHRTaGFkb3dzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xuXHRcdFx0c2hhZG93SW50ZW5zaXR5OiAxLFxuXHRcdFx0c2hhZG93Qmlhczoge30sXG5cdFx0XHRzaGFkb3dOb3JtYWxCaWFzOiB7fSxcblx0XHRcdHNoYWRvd1JhZGl1czoge30sXG5cdFx0XHRzaGFkb3dNYXBTaXplOiB7fSxcblx0XHRcdHNoYWRvd0NhbWVyYU5lYXI6IHt9LFxuXHRcdFx0c2hhZG93Q2FtZXJhRmFyOiB7fVxuXHRcdH0gfSxcblxuXHRcdHBvaW50U2hhZG93TWFwOiB7IHZhbHVlOiBbXSB9LFxuXHRcdHBvaW50U2hhZG93TWF0cml4OiB7IHZhbHVlOiBbXSB9LFxuXG5cdFx0aGVtaXNwaGVyZUxpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcblx0XHRcdGRpcmVjdGlvbjoge30sXG5cdFx0XHRza3lDb2xvcjoge30sXG5cdFx0XHRncm91bmRDb2xvcjoge31cblx0XHR9IH0sXG5cblx0XHQvLyBUT0RPIChhYmVsbmF0aW9uKTogUmVjdEFyZWFMaWdodCBCUkRGIGRhdGEgbmVlZHMgdG8gYmUgbW92ZWQgZnJvbSBleGFtcGxlIHRvIG1haW4gc3JjXG5cdFx0cmVjdEFyZWFMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XG5cdFx0XHRjb2xvcjoge30sXG5cdFx0XHRwb3NpdGlvbjoge30sXG5cdFx0XHR3aWR0aDoge30sXG5cdFx0XHRoZWlnaHQ6IHt9XG5cdFx0fSB9LFxuXG5cdFx0bHRjXzE6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRsdGNfMjogeyB2YWx1ZTogbnVsbCB9XG5cblx0fSxcblxuXHRwb2ludHM6IHtcblxuXHRcdGRpZmZ1c2U6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweGZmZmZmZiApIH0sXG5cdFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH0sXG5cdFx0c2l6ZTogeyB2YWx1ZTogMS4wIH0sXG5cdFx0c2NhbGU6IHsgdmFsdWU6IDEuMCB9LFxuXHRcdG1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdGFscGhhTWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0YWxwaGFNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxuXHRcdGFscGhhVGVzdDogeyB2YWx1ZTogMCB9LFxuXHRcdHV2VHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfVxuXG5cdH0sXG5cblx0c3ByaXRlOiB7XG5cblx0XHRkaWZmdXNlOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBDb2xvciggMHhmZmZmZmYgKSB9LFxuXHRcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9LFxuXHRcdGNlbnRlcjogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMiggMC41LCAwLjUgKSB9LFxuXHRcdHJvdGF0aW9uOiB7IHZhbHVlOiAwLjAgfSxcblx0XHRtYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRtYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxuXHRcdGFscGhhTWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0YWxwaGFNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxuXHRcdGFscGhhVGVzdDogeyB2YWx1ZTogMCB9XG5cblx0fVxuXG59O1xuXG5jb25zdCBTaGFkZXJMaWIgPSB7XG5cblx0YmFzaWM6IHtcblxuXHRcdHVuaWZvcm1zOiAvKkBfX1BVUkVfXyovIG1lcmdlVW5pZm9ybXMoIFtcblx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcblx0XHRcdFVuaWZvcm1zTGliLnNwZWN1bGFybWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIuZW52bWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIuYW9tYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5saWdodG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmZvZ1xuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaGJhc2ljX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hiYXNpY19mcmFnXG5cblx0fSxcblxuXHRsYW1iZXJ0OiB7XG5cblx0XHR1bmlmb3JtczogLypAX19QVVJFX18qLyBtZXJnZVVuaWZvcm1zKCBbXG5cdFx0XHRVbmlmb3Jtc0xpYi5jb21tb24sXG5cdFx0XHRVbmlmb3Jtc0xpYi5zcGVjdWxhcm1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmVudm1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmFvbWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmJ1bXBtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5mb2csXG5cdFx0XHRVbmlmb3Jtc0xpYi5saWdodHMsXG5cdFx0XHR7XG5cdFx0XHRcdGVtaXNzaXZlOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBDb2xvciggMHgwMDAwMDAgKSB9XG5cdFx0XHR9XG5cdFx0XSApLFxuXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobGFtYmVydF92ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobGFtYmVydF9mcmFnXG5cblx0fSxcblxuXHRwaG9uZzoge1xuXG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi8gbWVyZ2VVbmlmb3JtcyggW1xuXHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuXHRcdFx0VW5pZm9ybXNMaWIuc3BlY3VsYXJtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5lbnZtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5hb21hcCxcblx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0bWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIuZW1pc3NpdmVtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5idW1wbWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIubm9ybWFsbWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIuZm9nLFxuXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRzLFxuXHRcdFx0e1xuXHRcdFx0XHRlbWlzc2l2ZTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgQ29sb3IoIDB4MDAwMDAwICkgfSxcblx0XHRcdFx0c3BlY3VsYXI6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweDExMTExMSApIH0sXG5cdFx0XHRcdHNoaW5pbmVzczogeyB2YWx1ZTogMzAgfVxuXHRcdFx0fVxuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBob25nX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaG9uZ19mcmFnXG5cblx0fSxcblxuXHRzdGFuZGFyZDoge1xuXG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi8gbWVyZ2VVbmlmb3JtcyggW1xuXHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuXHRcdFx0VW5pZm9ybXNMaWIuZW52bWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIuYW9tYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5saWdodG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmVtaXNzaXZlbWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIuYnVtcG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLm5vcm1hbG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLnJvdWdobmVzc21hcCxcblx0XHRcdFVuaWZvcm1zTGliLm1ldGFsbmVzc21hcCxcblx0XHRcdFVuaWZvcm1zTGliLmZvZyxcblx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0cyxcblx0XHRcdHtcblx0XHRcdFx0ZW1pc3NpdmU6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweDAwMDAwMCApIH0sXG5cdFx0XHRcdHJvdWdobmVzczogeyB2YWx1ZTogMS4wIH0sXG5cdFx0XHRcdG1ldGFsbmVzczogeyB2YWx1ZTogMC4wIH0sXG5cdFx0XHRcdGVudk1hcEludGVuc2l0eTogeyB2YWx1ZTogMSB9XG5cdFx0XHR9XG5cdFx0XSApLFxuXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGh5c2ljYWxfdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX2ZyYWdcblxuXHR9LFxuXG5cdHRvb246IHtcblxuXHRcdHVuaWZvcm1zOiAvKkBfX1BVUkVfXyovIG1lcmdlVW5pZm9ybXMoIFtcblx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcblx0XHRcdFVuaWZvcm1zTGliLmFvbWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmJ1bXBtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5ncmFkaWVudG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmZvZyxcblx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0cyxcblx0XHRcdHtcblx0XHRcdFx0ZW1pc3NpdmU6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweDAwMDAwMCApIH1cblx0XHRcdH1cblx0XHRdICksXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2h0b29uX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2h0b29uX2ZyYWdcblxuXHR9LFxuXG5cdG1hdGNhcDoge1xuXG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi8gbWVyZ2VVbmlmb3JtcyggW1xuXHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuXHRcdFx0VW5pZm9ybXNMaWIuYnVtcG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLm5vcm1hbG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmZvZyxcblx0XHRcdHtcblx0XHRcdFx0bWF0Y2FwOiB7IHZhbHVlOiBudWxsIH1cblx0XHRcdH1cblx0XHRdICksXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2htYXRjYXBfdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaG1hdGNhcF9mcmFnXG5cblx0fSxcblxuXHRwb2ludHM6IHtcblxuXHRcdHVuaWZvcm1zOiAvKkBfX1BVUkVfXyovIG1lcmdlVW5pZm9ybXMoIFtcblx0XHRcdFVuaWZvcm1zTGliLnBvaW50cyxcblx0XHRcdFVuaWZvcm1zTGliLmZvZ1xuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsucG9pbnRzX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLnBvaW50c19mcmFnXG5cblx0fSxcblxuXHRkYXNoZWQ6IHtcblxuXHRcdHVuaWZvcm1zOiAvKkBfX1BVUkVfXyovIG1lcmdlVW5pZm9ybXMoIFtcblx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcblx0XHRcdFVuaWZvcm1zTGliLmZvZyxcblx0XHRcdHtcblx0XHRcdFx0c2NhbGU6IHsgdmFsdWU6IDEgfSxcblx0XHRcdFx0ZGFzaFNpemU6IHsgdmFsdWU6IDEgfSxcblx0XHRcdFx0dG90YWxTaXplOiB7IHZhbHVlOiAyIH1cblx0XHRcdH1cblx0XHRdICksXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmxpbmVkYXNoZWRfdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubGluZWRhc2hlZF9mcmFnXG5cblx0fSxcblxuXHRkZXB0aDoge1xuXG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi8gbWVyZ2VVbmlmb3JtcyggW1xuXHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuXHRcdFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwXG5cdFx0XSApLFxuXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5kZXB0aF92ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5kZXB0aF9mcmFnXG5cblx0fSxcblxuXHRub3JtYWw6IHtcblxuXHRcdHVuaWZvcm1zOiAvKkBfX1BVUkVfXyovIG1lcmdlVW5pZm9ybXMoIFtcblx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcblx0XHRcdFVuaWZvcm1zTGliLmJ1bXBtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXG5cdFx0XHR7XG5cdFx0XHRcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9XG5cdFx0XHR9XG5cdFx0XSApLFxuXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobm9ybWFsX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hub3JtYWxfZnJhZ1xuXG5cdH0sXG5cblx0c3ByaXRlOiB7XG5cblx0XHR1bmlmb3JtczogLypAX19QVVJFX18qLyBtZXJnZVVuaWZvcm1zKCBbXG5cdFx0XHRVbmlmb3Jtc0xpYi5zcHJpdGUsXG5cdFx0XHRVbmlmb3Jtc0xpYi5mb2dcblx0XHRdICksXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLnNwcml0ZV92ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5zcHJpdGVfZnJhZ1xuXG5cdH0sXG5cblx0YmFja2dyb3VuZDoge1xuXG5cdFx0dW5pZm9ybXM6IHtcblx0XHRcdHV2VHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcblx0XHRcdHQyRDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0YmFja2dyb3VuZEludGVuc2l0eTogeyB2YWx1ZTogMSB9XG5cdFx0fSxcblxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuYmFja2dyb3VuZF92ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5iYWNrZ3JvdW5kX2ZyYWdcblxuXHR9LFxuXG5cdGJhY2tncm91bmRDdWJlOiB7XG5cblx0XHR1bmlmb3Jtczoge1xuXHRcdFx0ZW52TWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0XHRmbGlwRW52TWFwOiB7IHZhbHVlOiAtIDEgfSxcblx0XHRcdGJhY2tncm91bmRCbHVycmluZXNzOiB7IHZhbHVlOiAwIH0sXG5cdFx0XHRiYWNrZ3JvdW5kSW50ZW5zaXR5OiB7IHZhbHVlOiAxIH0sXG5cdFx0XHRiYWNrZ3JvdW5kUm90YXRpb246IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9XG5cdFx0fSxcblxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuYmFja2dyb3VuZEN1YmVfdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuYmFja2dyb3VuZEN1YmVfZnJhZ1xuXG5cdH0sXG5cblx0Y3ViZToge1xuXG5cdFx0dW5pZm9ybXM6IHtcblx0XHRcdHRDdWJlOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0XHR0RmxpcDogeyB2YWx1ZTogLSAxIH0sXG5cdFx0XHRvcGFjaXR5OiB7IHZhbHVlOiAxLjAgfVxuXHRcdH0sXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmN1YmVfdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuY3ViZV9mcmFnXG5cblx0fSxcblxuXHRlcXVpcmVjdDoge1xuXG5cdFx0dW5pZm9ybXM6IHtcblx0XHRcdHRFcXVpcmVjdDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdH0sXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmVxdWlyZWN0X3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmVxdWlyZWN0X2ZyYWdcblxuXHR9LFxuXG5cdGRpc3RhbmNlUkdCQToge1xuXG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi8gbWVyZ2VVbmlmb3JtcyggW1xuXHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuXHRcdFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLFxuXHRcdFx0e1xuXHRcdFx0XHRyZWZlcmVuY2VQb3NpdGlvbjogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpIH0sXG5cdFx0XHRcdG5lYXJEaXN0YW5jZTogeyB2YWx1ZTogMSB9LFxuXHRcdFx0XHRmYXJEaXN0YW5jZTogeyB2YWx1ZTogMTAwMCB9XG5cdFx0XHR9XG5cdFx0XSApLFxuXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5kaXN0YW5jZVJHQkFfdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuZGlzdGFuY2VSR0JBX2ZyYWdcblxuXHR9LFxuXG5cdHNoYWRvdzoge1xuXG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi8gbWVyZ2VVbmlmb3JtcyggW1xuXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRzLFxuXHRcdFx0VW5pZm9ybXNMaWIuZm9nLFxuXHRcdFx0e1xuXHRcdFx0XHRjb2xvcjogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgQ29sb3IoIDB4MDAwMDAgKSB9LFxuXHRcdFx0XHRvcGFjaXR5OiB7IHZhbHVlOiAxLjAgfVxuXHRcdFx0fSxcblx0XHRdICksXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLnNoYWRvd192ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5zaGFkb3dfZnJhZ1xuXG5cdH1cblxufTtcblxuU2hhZGVyTGliLnBoeXNpY2FsID0ge1xuXG5cdHVuaWZvcm1zOiAvKkBfX1BVUkVfXyovIG1lcmdlVW5pZm9ybXMoIFtcblx0XHRTaGFkZXJMaWIuc3RhbmRhcmQudW5pZm9ybXMsXG5cdFx0e1xuXHRcdFx0Y2xlYXJjb2F0OiB7IHZhbHVlOiAwIH0sXG5cdFx0XHRjbGVhcmNvYXRNYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRcdGNsZWFyY29hdE1hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH0sXG5cdFx0XHRjbGVhcmNvYXROb3JtYWxNYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRcdGNsZWFyY29hdE5vcm1hbE1hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH0sXG5cdFx0XHRjbGVhcmNvYXROb3JtYWxTY2FsZTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMiggMSwgMSApIH0sXG5cdFx0XHRjbGVhcmNvYXRSb3VnaG5lc3M6IHsgdmFsdWU6IDAgfSxcblx0XHRcdGNsZWFyY29hdFJvdWdobmVzc01hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0Y2xlYXJjb2F0Um91Z2huZXNzTWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcblx0XHRcdGRpc3BlcnNpb246IHsgdmFsdWU6IDAgfSxcblx0XHRcdGlyaWRlc2NlbmNlOiB7IHZhbHVlOiAwIH0sXG5cdFx0XHRpcmlkZXNjZW5jZU1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0aXJpZGVzY2VuY2VNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxuXHRcdFx0aXJpZGVzY2VuY2VJT1I6IHsgdmFsdWU6IDEuMyB9LFxuXHRcdFx0aXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtOiB7IHZhbHVlOiAxMDAgfSxcblx0XHRcdGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bTogeyB2YWx1ZTogNDAwIH0sXG5cdFx0XHRpcmlkZXNjZW5jZVRoaWNrbmVzc01hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0aXJpZGVzY2VuY2VUaGlja25lc3NNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxuXHRcdFx0c2hlZW46IHsgdmFsdWU6IDAgfSxcblx0XHRcdHNoZWVuQ29sb3I6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweDAwMDAwMCApIH0sXG5cdFx0XHRzaGVlbkNvbG9yTWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0XHRzaGVlbkNvbG9yTWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcblx0XHRcdHNoZWVuUm91Z2huZXNzOiB7IHZhbHVlOiAxIH0sXG5cdFx0XHRzaGVlblJvdWdobmVzc01hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0c2hlZW5Sb3VnaG5lc3NNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxuXHRcdFx0dHJhbnNtaXNzaW9uOiB7IHZhbHVlOiAwIH0sXG5cdFx0XHR0cmFuc21pc3Npb25NYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRcdHRyYW5zbWlzc2lvbk1hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH0sXG5cdFx0XHR0cmFuc21pc3Npb25TYW1wbGVyU2l6ZTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMigpIH0sXG5cdFx0XHR0cmFuc21pc3Npb25TYW1wbGVyTWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0XHR0aGlja25lc3M6IHsgdmFsdWU6IDAgfSxcblx0XHRcdHRoaWNrbmVzc01hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0dGhpY2tuZXNzTWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcblx0XHRcdGF0dGVudWF0aW9uRGlzdGFuY2U6IHsgdmFsdWU6IDAgfSxcblx0XHRcdGF0dGVudWF0aW9uQ29sb3I6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweDAwMDAwMCApIH0sXG5cdFx0XHRzcGVjdWxhckNvbG9yOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBDb2xvciggMSwgMSwgMSApIH0sXG5cdFx0XHRzcGVjdWxhckNvbG9yTWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0XHRzcGVjdWxhckNvbG9yTWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcblx0XHRcdHNwZWN1bGFySW50ZW5zaXR5OiB7IHZhbHVlOiAxIH0sXG5cdFx0XHRzcGVjdWxhckludGVuc2l0eU1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0c3BlY3VsYXJJbnRlbnNpdHlNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxuXHRcdFx0YW5pc290cm9weVZlY3RvcjogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMigpIH0sXG5cdFx0XHRhbmlzb3Ryb3B5TWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0XHRhbmlzb3Ryb3B5TWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcblx0XHR9XG5cdF0gKSxcblxuXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF92ZXJ0LFxuXHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX2ZyYWdcblxufTtcblxuY29uc3QgX3JnYiA9IHsgcjogMCwgYjogMCwgZzogMCB9O1xuY29uc3QgX2UxJDEgPSAvKkBfX1BVUkVfXyovIG5ldyBFdWxlcigpO1xuY29uc3QgX20xJDEgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5cbmZ1bmN0aW9uIFdlYkdMQmFja2dyb3VuZCggcmVuZGVyZXIsIGN1YmVtYXBzLCBjdWJldXZtYXBzLCBzdGF0ZSwgb2JqZWN0cywgYWxwaGEsIHByZW11bHRpcGxpZWRBbHBoYSApIHtcblxuXHRjb25zdCBjbGVhckNvbG9yID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xuXHRsZXQgY2xlYXJBbHBoYSA9IGFscGhhID09PSB0cnVlID8gMCA6IDE7XG5cblx0bGV0IHBsYW5lTWVzaDtcblx0bGV0IGJveE1lc2g7XG5cblx0bGV0IGN1cnJlbnRCYWNrZ3JvdW5kID0gbnVsbDtcblx0bGV0IGN1cnJlbnRCYWNrZ3JvdW5kVmVyc2lvbiA9IDA7XG5cdGxldCBjdXJyZW50VG9uZW1hcHBpbmcgPSBudWxsO1xuXG5cdGZ1bmN0aW9uIGdldEJhY2tncm91bmQoIHNjZW5lICkge1xuXG5cdFx0bGV0IGJhY2tncm91bmQgPSBzY2VuZS5pc1NjZW5lID09PSB0cnVlID8gc2NlbmUuYmFja2dyb3VuZCA6IG51bGw7XG5cblx0XHRpZiAoIGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGNvbnN0IHVzZVBNUkVNID0gc2NlbmUuYmFja2dyb3VuZEJsdXJyaW5lc3MgPiAwOyAvLyB1c2UgUE1SRU0gaWYgdGhlIHVzZXIgd2FudHMgdG8gYmx1ciB0aGUgYmFja2dyb3VuZFxuXHRcdFx0YmFja2dyb3VuZCA9ICggdXNlUE1SRU0gPyBjdWJldXZtYXBzIDogY3ViZW1hcHMgKS5nZXQoIGJhY2tncm91bmQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBiYWNrZ3JvdW5kO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXIoIHNjZW5lICkge1xuXG5cdFx0bGV0IGZvcmNlQ2xlYXIgPSBmYWxzZTtcblx0XHRjb25zdCBiYWNrZ3JvdW5kID0gZ2V0QmFja2dyb3VuZCggc2NlbmUgKTtcblxuXHRcdGlmICggYmFja2dyb3VuZCA9PT0gbnVsbCApIHtcblxuXHRcdFx0c2V0Q2xlYXIoIGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc0NvbG9yICkge1xuXG5cdFx0XHRzZXRDbGVhciggYmFja2dyb3VuZCwgMSApO1xuXHRcdFx0Zm9yY2VDbGVhciA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRjb25zdCBlbnZpcm9ubWVudEJsZW5kTW9kZSA9IHJlbmRlcmVyLnhyLmdldEVudmlyb25tZW50QmxlbmRNb2RlKCk7XG5cblx0XHRpZiAoIGVudmlyb25tZW50QmxlbmRNb2RlID09PSAnYWRkaXRpdmUnICkge1xuXG5cdFx0XHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldENsZWFyKCAwLCAwLCAwLCAxLCBwcmVtdWx0aXBsaWVkQWxwaGEgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGVudmlyb25tZW50QmxlbmRNb2RlID09PSAnYWxwaGEtYmxlbmQnICkge1xuXG5cdFx0XHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldENsZWFyKCAwLCAwLCAwLCAwLCBwcmVtdWx0aXBsaWVkQWxwaGEgKTtcblxuXHRcdH1cblxuXHRcdGlmICggcmVuZGVyZXIuYXV0b0NsZWFyIHx8IGZvcmNlQ2xlYXIgKSB7XG5cblx0XHRcdC8vIGJ1ZmZlcnMgbWlnaHQgbm90IGJlIHdyaXRhYmxlIHdoaWNoIGlzIHJlcXVpcmVkIHRvIGVuc3VyZSBhIGNvcnJlY3QgY2xlYXJcblxuXHRcdFx0c3RhdGUuYnVmZmVycy5kZXB0aC5zZXRUZXN0KCB0cnVlICk7XG5cdFx0XHRzdGF0ZS5idWZmZXJzLmRlcHRoLnNldE1hc2soIHRydWUgKTtcblx0XHRcdHN0YXRlLmJ1ZmZlcnMuY29sb3Iuc2V0TWFzayggdHJ1ZSApO1xuXG5cdFx0XHRyZW5kZXJlci5jbGVhciggcmVuZGVyZXIuYXV0b0NsZWFyQ29sb3IsIHJlbmRlcmVyLmF1dG9DbGVhckRlcHRoLCByZW5kZXJlci5hdXRvQ2xlYXJTdGVuY2lsICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGFkZFRvUmVuZGVyTGlzdCggcmVuZGVyTGlzdCwgc2NlbmUgKSB7XG5cblx0XHRjb25zdCBiYWNrZ3JvdW5kID0gZ2V0QmFja2dyb3VuZCggc2NlbmUgKTtcblxuXHRcdGlmICggYmFja2dyb3VuZCAmJiAoIGJhY2tncm91bmQuaXNDdWJlVGV4dHVyZSB8fCBiYWNrZ3JvdW5kLm1hcHBpbmcgPT09IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nICkgKSB7XG5cblx0XHRcdGlmICggYm94TWVzaCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGJveE1lc2ggPSBuZXcgTWVzaChcblx0XHRcdFx0XHRuZXcgQm94R2VvbWV0cnkoIDEsIDEsIDEgKSxcblx0XHRcdFx0XHRuZXcgU2hhZGVyTWF0ZXJpYWwoIHtcblx0XHRcdFx0XHRcdG5hbWU6ICdCYWNrZ3JvdW5kQ3ViZU1hdGVyaWFsJyxcblx0XHRcdFx0XHRcdHVuaWZvcm1zOiBjbG9uZVVuaWZvcm1zKCBTaGFkZXJMaWIuYmFja2dyb3VuZEN1YmUudW5pZm9ybXMgKSxcblx0XHRcdFx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyTGliLmJhY2tncm91bmRDdWJlLnZlcnRleFNoYWRlcixcblx0XHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJMaWIuYmFja2dyb3VuZEN1YmUuZnJhZ21lbnRTaGFkZXIsXG5cdFx0XHRcdFx0XHRzaWRlOiBCYWNrU2lkZSxcblx0XHRcdFx0XHRcdGRlcHRoVGVzdDogZmFsc2UsXG5cdFx0XHRcdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcblx0XHRcdFx0XHRcdGZvZzogZmFsc2Vcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRib3hNZXNoLmdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSggJ25vcm1hbCcgKTtcblx0XHRcdFx0Ym94TWVzaC5nZW9tZXRyeS5kZWxldGVBdHRyaWJ1dGUoICd1dicgKTtcblxuXHRcdFx0XHRib3hNZXNoLm9uQmVmb3JlUmVuZGVyID0gZnVuY3Rpb24gKCByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSApIHtcblxuXHRcdFx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weVBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIGFkZCBcImVudk1hcFwiIG1hdGVyaWFsIHByb3BlcnR5IHNvIHRoZSByZW5kZXJlciBjYW4gZXZhbHVhdGUgaXQgbGlrZSBmb3IgYnVpbHQtaW4gbWF0ZXJpYWxzXG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggYm94TWVzaC5tYXRlcmlhbCwgJ2Vudk1hcCcsIHtcblxuXHRcdFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy51bmlmb3Jtcy5lbnZNYXAudmFsdWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdG9iamVjdHMudXBkYXRlKCBib3hNZXNoICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X2UxJDEuY29weSggc2NlbmUuYmFja2dyb3VuZFJvdGF0aW9uICk7XG5cblx0XHRcdC8vIGFjY29tbW9kYXRlIGxlZnQtaGFuZGVkIGZyYW1lXG5cdFx0XHRfZTEkMS54ICo9IC0gMTsgX2UxJDEueSAqPSAtIDE7IF9lMSQxLnogKj0gLSAxO1xuXG5cdFx0XHRpZiAoIGJhY2tncm91bmQuaXNDdWJlVGV4dHVyZSAmJiBiYWNrZ3JvdW5kLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gZW52aXJvbm1lbnQgbWFwcyB3aGljaCBhcmUgbm90IGN1YmUgcmVuZGVyIHRhcmdldHMgb3IgUE1SRU1zIGZvbGxvdyBhIGRpZmZlcmVudCBjb252ZW50aW9uXG5cdFx0XHRcdF9lMSQxLnkgKj0gLSAxO1xuXHRcdFx0XHRfZTEkMS56ICo9IC0gMTtcblxuXHRcdFx0fVxuXG5cdFx0XHRib3hNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLmVudk1hcC52YWx1ZSA9IGJhY2tncm91bmQ7XG5cdFx0XHRib3hNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLmZsaXBFbnZNYXAudmFsdWUgPSAoIGJhY2tncm91bmQuaXNDdWJlVGV4dHVyZSAmJiBiYWNrZ3JvdW5kLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gZmFsc2UgKSA/IC0gMSA6IDE7XG5cdFx0XHRib3hNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLmJhY2tncm91bmRCbHVycmluZXNzLnZhbHVlID0gc2NlbmUuYmFja2dyb3VuZEJsdXJyaW5lc3M7XG5cdFx0XHRib3hNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLmJhY2tncm91bmRJbnRlbnNpdHkudmFsdWUgPSBzY2VuZS5iYWNrZ3JvdW5kSW50ZW5zaXR5O1xuXHRcdFx0Ym94TWVzaC5tYXRlcmlhbC51bmlmb3Jtcy5iYWNrZ3JvdW5kUm90YXRpb24udmFsdWUuc2V0RnJvbU1hdHJpeDQoIF9tMSQxLm1ha2VSb3RhdGlvbkZyb21FdWxlciggX2UxJDEgKSApO1xuXHRcdFx0Ym94TWVzaC5tYXRlcmlhbC50b25lTWFwcGVkID0gQ29sb3JNYW5hZ2VtZW50LmdldFRyYW5zZmVyKCBiYWNrZ3JvdW5kLmNvbG9yU3BhY2UgKSAhPT0gU1JHQlRyYW5zZmVyO1xuXG5cdFx0XHRpZiAoIGN1cnJlbnRCYWNrZ3JvdW5kICE9PSBiYWNrZ3JvdW5kIHx8XG5cdFx0XHRcdGN1cnJlbnRCYWNrZ3JvdW5kVmVyc2lvbiAhPT0gYmFja2dyb3VuZC52ZXJzaW9uIHx8XG5cdFx0XHRcdGN1cnJlbnRUb25lbWFwcGluZyAhPT0gcmVuZGVyZXIudG9uZU1hcHBpbmcgKSB7XG5cblx0XHRcdFx0Ym94TWVzaC5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0Y3VycmVudEJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuXHRcdFx0XHRjdXJyZW50QmFja2dyb3VuZFZlcnNpb24gPSBiYWNrZ3JvdW5kLnZlcnNpb247XG5cdFx0XHRcdGN1cnJlbnRUb25lbWFwcGluZyA9IHJlbmRlcmVyLnRvbmVNYXBwaW5nO1xuXG5cdFx0XHR9XG5cblx0XHRcdGJveE1lc2gubGF5ZXJzLmVuYWJsZUFsbCgpO1xuXG5cdFx0XHQvLyBwdXNoIHRvIHRoZSBwcmUtc29ydGVkIG9wYXF1ZSByZW5kZXIgbGlzdFxuXHRcdFx0cmVuZGVyTGlzdC51bnNoaWZ0KCBib3hNZXNoLCBib3hNZXNoLmdlb21ldHJ5LCBib3hNZXNoLm1hdGVyaWFsLCAwLCAwLCBudWxsICk7XG5cblx0XHR9IGVsc2UgaWYgKCBiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRpZiAoIHBsYW5lTWVzaCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHBsYW5lTWVzaCA9IG5ldyBNZXNoKFxuXHRcdFx0XHRcdG5ldyBQbGFuZUdlb21ldHJ5KCAyLCAyICksXG5cdFx0XHRcdFx0bmV3IFNoYWRlck1hdGVyaWFsKCB7XG5cdFx0XHRcdFx0XHRuYW1lOiAnQmFja2dyb3VuZE1hdGVyaWFsJyxcblx0XHRcdFx0XHRcdHVuaWZvcm1zOiBjbG9uZVVuaWZvcm1zKCBTaGFkZXJMaWIuYmFja2dyb3VuZC51bmlmb3JtcyApLFxuXHRcdFx0XHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJMaWIuYmFja2dyb3VuZC52ZXJ0ZXhTaGFkZXIsXG5cdFx0XHRcdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyTGliLmJhY2tncm91bmQuZnJhZ21lbnRTaGFkZXIsXG5cdFx0XHRcdFx0XHRzaWRlOiBGcm9udFNpZGUsXG5cdFx0XHRcdFx0XHRkZXB0aFRlc3Q6IGZhbHNlLFxuXHRcdFx0XHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRmb2c6IGZhbHNlXG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0cGxhbmVNZXNoLmdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSggJ25vcm1hbCcgKTtcblxuXHRcdFx0XHQvLyBhZGQgXCJtYXBcIiBtYXRlcmlhbCBwcm9wZXJ0eSBzbyB0aGUgcmVuZGVyZXIgY2FuIGV2YWx1YXRlIGl0IGxpa2UgZm9yIGJ1aWx0LWluIG1hdGVyaWFsc1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHBsYW5lTWVzaC5tYXRlcmlhbCwgJ21hcCcsIHtcblxuXHRcdFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy51bmlmb3Jtcy50MkQudmFsdWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdG9iamVjdHMudXBkYXRlKCBwbGFuZU1lc2ggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRwbGFuZU1lc2gubWF0ZXJpYWwudW5pZm9ybXMudDJELnZhbHVlID0gYmFja2dyb3VuZDtcblx0XHRcdHBsYW5lTWVzaC5tYXRlcmlhbC51bmlmb3Jtcy5iYWNrZ3JvdW5kSW50ZW5zaXR5LnZhbHVlID0gc2NlbmUuYmFja2dyb3VuZEludGVuc2l0eTtcblx0XHRcdHBsYW5lTWVzaC5tYXRlcmlhbC50b25lTWFwcGVkID0gQ29sb3JNYW5hZ2VtZW50LmdldFRyYW5zZmVyKCBiYWNrZ3JvdW5kLmNvbG9yU3BhY2UgKSAhPT0gU1JHQlRyYW5zZmVyO1xuXG5cdFx0XHRpZiAoIGJhY2tncm91bmQubWF0cml4QXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRiYWNrZ3JvdW5kLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHBsYW5lTWVzaC5tYXRlcmlhbC51bmlmb3Jtcy51dlRyYW5zZm9ybS52YWx1ZS5jb3B5KCBiYWNrZ3JvdW5kLm1hdHJpeCApO1xuXG5cdFx0XHRpZiAoIGN1cnJlbnRCYWNrZ3JvdW5kICE9PSBiYWNrZ3JvdW5kIHx8XG5cdFx0XHRcdGN1cnJlbnRCYWNrZ3JvdW5kVmVyc2lvbiAhPT0gYmFja2dyb3VuZC52ZXJzaW9uIHx8XG5cdFx0XHRcdGN1cnJlbnRUb25lbWFwcGluZyAhPT0gcmVuZGVyZXIudG9uZU1hcHBpbmcgKSB7XG5cblx0XHRcdFx0cGxhbmVNZXNoLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRjdXJyZW50QmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG5cdFx0XHRcdGN1cnJlbnRCYWNrZ3JvdW5kVmVyc2lvbiA9IGJhY2tncm91bmQudmVyc2lvbjtcblx0XHRcdFx0Y3VycmVudFRvbmVtYXBwaW5nID0gcmVuZGVyZXIudG9uZU1hcHBpbmc7XG5cblx0XHRcdH1cblxuXHRcdFx0cGxhbmVNZXNoLmxheWVycy5lbmFibGVBbGwoKTtcblxuXHRcdFx0Ly8gcHVzaCB0byB0aGUgcHJlLXNvcnRlZCBvcGFxdWUgcmVuZGVyIGxpc3Rcblx0XHRcdHJlbmRlckxpc3QudW5zaGlmdCggcGxhbmVNZXNoLCBwbGFuZU1lc2guZ2VvbWV0cnksIHBsYW5lTWVzaC5tYXRlcmlhbCwgMCwgMCwgbnVsbCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRDbGVhciggY29sb3IsIGFscGhhICkge1xuXG5cdFx0Y29sb3IuZ2V0UkdCKCBfcmdiLCBnZXRVbmxpdFVuaWZvcm1Db2xvclNwYWNlKCByZW5kZXJlciApICk7XG5cblx0XHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldENsZWFyKCBfcmdiLnIsIF9yZ2IuZywgX3JnYi5iLCBhbHBoYSwgcHJlbXVsdGlwbGllZEFscGhhICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cblx0XHRpZiAoIGJveE1lc2ggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ym94TWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0XHRib3hNZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHRcdH1cblxuXHRcdGlmICggcGxhbmVNZXNoICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBsYW5lTWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0XHRwbGFuZU1lc2gubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4ge1xuXG5cdFx0Z2V0Q2xlYXJDb2xvcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gY2xlYXJDb2xvcjtcblxuXHRcdH0sXG5cdFx0c2V0Q2xlYXJDb2xvcjogZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgPSAxICkge1xuXG5cdFx0XHRjbGVhckNvbG9yLnNldCggY29sb3IgKTtcblx0XHRcdGNsZWFyQWxwaGEgPSBhbHBoYTtcblx0XHRcdHNldENsZWFyKCBjbGVhckNvbG9yLCBjbGVhckFscGhhICk7XG5cblx0XHR9LFxuXHRcdGdldENsZWFyQWxwaGE6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIGNsZWFyQWxwaGE7XG5cblx0XHR9LFxuXHRcdHNldENsZWFyQWxwaGE6IGZ1bmN0aW9uICggYWxwaGEgKSB7XG5cblx0XHRcdGNsZWFyQWxwaGEgPSBhbHBoYTtcblx0XHRcdHNldENsZWFyKCBjbGVhckNvbG9yLCBjbGVhckFscGhhICk7XG5cblx0XHR9LFxuXHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdGFkZFRvUmVuZGVyTGlzdDogYWRkVG9SZW5kZXJMaXN0LFxuXHRcdGRpc3Bvc2U6IGRpc3Bvc2VcblxuXHR9O1xuXG59XG5cbmZ1bmN0aW9uIFdlYkdMQmluZGluZ1N0YXRlcyggZ2wsIGF0dHJpYnV0ZXMgKSB7XG5cblx0Y29uc3QgbWF4VmVydGV4QXR0cmlidXRlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTICk7XG5cblx0Y29uc3QgYmluZGluZ1N0YXRlcyA9IHt9O1xuXG5cdGNvbnN0IGRlZmF1bHRTdGF0ZSA9IGNyZWF0ZUJpbmRpbmdTdGF0ZSggbnVsbCApO1xuXHRsZXQgY3VycmVudFN0YXRlID0gZGVmYXVsdFN0YXRlO1xuXHRsZXQgZm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBzZXR1cCggb2JqZWN0LCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIGluZGV4ICkge1xuXG5cdFx0bGV0IHVwZGF0ZUJ1ZmZlcnMgPSBmYWxzZTtcblxuXHRcdGNvbnN0IHN0YXRlID0gZ2V0QmluZGluZ1N0YXRlKCBnZW9tZXRyeSwgcHJvZ3JhbSwgbWF0ZXJpYWwgKTtcblxuXHRcdGlmICggY3VycmVudFN0YXRlICE9PSBzdGF0ZSApIHtcblxuXHRcdFx0Y3VycmVudFN0YXRlID0gc3RhdGU7XG5cdFx0XHRiaW5kVmVydGV4QXJyYXlPYmplY3QoIGN1cnJlbnRTdGF0ZS5vYmplY3QgKTtcblxuXHRcdH1cblxuXHRcdHVwZGF0ZUJ1ZmZlcnMgPSBuZWVkc1VwZGF0ZSggb2JqZWN0LCBnZW9tZXRyeSwgcHJvZ3JhbSwgaW5kZXggKTtcblxuXHRcdGlmICggdXBkYXRlQnVmZmVycyApIHNhdmVDYWNoZSggb2JqZWN0LCBnZW9tZXRyeSwgcHJvZ3JhbSwgaW5kZXggKTtcblxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdGF0dHJpYnV0ZXMudXBkYXRlKCBpbmRleCwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdXBkYXRlQnVmZmVycyB8fCBmb3JjZVVwZGF0ZSApIHtcblxuXHRcdFx0Zm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0c2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBvYmplY3QsIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBhdHRyaWJ1dGVzLmdldCggaW5kZXggKS5idWZmZXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVWZXJ0ZXhBcnJheU9iamVjdCgpIHtcblxuXHRcdHJldHVybiBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBiaW5kVmVydGV4QXJyYXlPYmplY3QoIHZhbyApIHtcblxuXHRcdHJldHVybiBnbC5iaW5kVmVydGV4QXJyYXkoIHZhbyApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBkZWxldGVWZXJ0ZXhBcnJheU9iamVjdCggdmFvICkge1xuXG5cdFx0cmV0dXJuIGdsLmRlbGV0ZVZlcnRleEFycmF5KCB2YW8gKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0QmluZGluZ1N0YXRlKCBnZW9tZXRyeSwgcHJvZ3JhbSwgbWF0ZXJpYWwgKSB7XG5cblx0XHRjb25zdCB3aXJlZnJhbWUgPSAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApO1xuXG5cdFx0bGV0IHByb2dyYW1NYXAgPSBiaW5kaW5nU3RhdGVzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0aWYgKCBwcm9ncmFtTWFwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHByb2dyYW1NYXAgPSB7fTtcblx0XHRcdGJpbmRpbmdTdGF0ZXNbIGdlb21ldHJ5LmlkIF0gPSBwcm9ncmFtTWFwO1xuXG5cdFx0fVxuXG5cdFx0bGV0IHN0YXRlTWFwID0gcHJvZ3JhbU1hcFsgcHJvZ3JhbS5pZCBdO1xuXG5cdFx0aWYgKCBzdGF0ZU1hcCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRzdGF0ZU1hcCA9IHt9O1xuXHRcdFx0cHJvZ3JhbU1hcFsgcHJvZ3JhbS5pZCBdID0gc3RhdGVNYXA7XG5cblx0XHR9XG5cblx0XHRsZXQgc3RhdGUgPSBzdGF0ZU1hcFsgd2lyZWZyYW1lIF07XG5cblx0XHRpZiAoIHN0YXRlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHN0YXRlID0gY3JlYXRlQmluZGluZ1N0YXRlKCBjcmVhdGVWZXJ0ZXhBcnJheU9iamVjdCgpICk7XG5cdFx0XHRzdGF0ZU1hcFsgd2lyZWZyYW1lIF0gPSBzdGF0ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBzdGF0ZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlQmluZGluZ1N0YXRlKCB2YW8gKSB7XG5cblx0XHRjb25zdCBuZXdBdHRyaWJ1dGVzID0gW107XG5cdFx0Y29uc3QgZW5hYmxlZEF0dHJpYnV0ZXMgPSBbXTtcblx0XHRjb25zdCBhdHRyaWJ1dGVEaXZpc29ycyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbWF4VmVydGV4QXR0cmlidXRlczsgaSArKyApIHtcblxuXHRcdFx0bmV3QXR0cmlidXRlc1sgaSBdID0gMDtcblx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXHRcdFx0YXR0cmlidXRlRGl2aXNvcnNbIGkgXSA9IDA7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHQvLyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBvbiBub24tVkFPIHN1cHBvcnQgYnJvd3NlclxuXHRcdFx0Z2VvbWV0cnk6IG51bGwsXG5cdFx0XHRwcm9ncmFtOiBudWxsLFxuXHRcdFx0d2lyZWZyYW1lOiBmYWxzZSxcblxuXHRcdFx0bmV3QXR0cmlidXRlczogbmV3QXR0cmlidXRlcyxcblx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzOiBlbmFibGVkQXR0cmlidXRlcyxcblx0XHRcdGF0dHJpYnV0ZURpdmlzb3JzOiBhdHRyaWJ1dGVEaXZpc29ycyxcblx0XHRcdG9iamVjdDogdmFvLFxuXHRcdFx0YXR0cmlidXRlczoge30sXG5cdFx0XHRpbmRleDogbnVsbFxuXG5cdFx0fTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gbmVlZHNVcGRhdGUoIG9iamVjdCwgZ2VvbWV0cnksIHByb2dyYW0sIGluZGV4ICkge1xuXG5cdFx0Y29uc3QgY2FjaGVkQXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5hdHRyaWJ1dGVzO1xuXHRcdGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cblx0XHRsZXQgYXR0cmlidXRlc051bSA9IDA7XG5cblx0XHRjb25zdCBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBwcm9ncmFtQXR0cmlidXRlcyApIHtcblxuXHRcdFx0Y29uc3QgcHJvZ3JhbUF0dHJpYnV0ZSA9IHByb2dyYW1BdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHRcdGlmICggcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiA+PSAwICkge1xuXG5cdFx0XHRcdGNvbnN0IGNhY2hlZEF0dHJpYnV0ZSA9IGNhY2hlZEF0dHJpYnV0ZXNbIG5hbWUgXTtcblx0XHRcdFx0bGV0IGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeUF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0aWYgKCBuYW1lID09PSAnaW5zdGFuY2VNYXRyaXgnICYmIG9iamVjdC5pbnN0YW5jZU1hdHJpeCApIGdlb21ldHJ5QXR0cmlidXRlID0gb2JqZWN0Lmluc3RhbmNlTWF0cml4O1xuXHRcdFx0XHRcdGlmICggbmFtZSA9PT0gJ2luc3RhbmNlQ29sb3InICYmIG9iamVjdC5pbnN0YW5jZUNvbG9yICkgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBvYmplY3QuaW5zdGFuY2VDb2xvcjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjYWNoZWRBdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCApIHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdGlmICggY2FjaGVkQXR0cmlidXRlLmF0dHJpYnV0ZSAhPT0gZ2VvbWV0cnlBdHRyaWJ1dGUgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlICYmIGNhY2hlZEF0dHJpYnV0ZS5kYXRhICE9PSBnZW9tZXRyeUF0dHJpYnV0ZS5kYXRhICkgcmV0dXJuIHRydWU7XG5cblx0XHRcdFx0YXR0cmlidXRlc051bSArKztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBjdXJyZW50U3RhdGUuYXR0cmlidXRlc051bSAhPT0gYXR0cmlidXRlc051bSApIHJldHVybiB0cnVlO1xuXG5cdFx0aWYgKCBjdXJyZW50U3RhdGUuaW5kZXggIT09IGluZGV4ICkgcmV0dXJuIHRydWU7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNhdmVDYWNoZSggb2JqZWN0LCBnZW9tZXRyeSwgcHJvZ3JhbSwgaW5kZXggKSB7XG5cblx0XHRjb25zdCBjYWNoZSA9IHt9O1xuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXHRcdGxldCBhdHRyaWJ1dGVzTnVtID0gMDtcblxuXHRcdGNvbnN0IHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIHByb2dyYW1BdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBwcm9ncmFtQXR0cmlidXRlID0gcHJvZ3JhbUF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0aWYgKCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uID49IDAgKSB7XG5cblx0XHRcdFx0bGV0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0aWYgKCBuYW1lID09PSAnaW5zdGFuY2VNYXRyaXgnICYmIG9iamVjdC5pbnN0YW5jZU1hdHJpeCApIGF0dHJpYnV0ZSA9IG9iamVjdC5pbnN0YW5jZU1hdHJpeDtcblx0XHRcdFx0XHRpZiAoIG5hbWUgPT09ICdpbnN0YW5jZUNvbG9yJyAmJiBvYmplY3QuaW5zdGFuY2VDb2xvciApIGF0dHJpYnV0ZSA9IG9iamVjdC5pbnN0YW5jZUNvbG9yO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBkYXRhID0ge307XG5cdFx0XHRcdGRhdGEuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuXG5cdFx0XHRcdGlmICggYXR0cmlidXRlICYmIGF0dHJpYnV0ZS5kYXRhICkge1xuXG5cdFx0XHRcdFx0ZGF0YS5kYXRhID0gYXR0cmlidXRlLmRhdGE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhY2hlWyBuYW1lIF0gPSBkYXRhO1xuXG5cdFx0XHRcdGF0dHJpYnV0ZXNOdW0gKys7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGN1cnJlbnRTdGF0ZS5hdHRyaWJ1dGVzID0gY2FjaGU7XG5cdFx0Y3VycmVudFN0YXRlLmF0dHJpYnV0ZXNOdW0gPSBhdHRyaWJ1dGVzTnVtO1xuXG5cdFx0Y3VycmVudFN0YXRlLmluZGV4ID0gaW5kZXg7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGluaXRBdHRyaWJ1dGVzKCkge1xuXG5cdFx0Y29uc3QgbmV3QXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5uZXdBdHRyaWJ1dGVzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG5ld0F0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdG5ld0F0dHJpYnV0ZXNbIGkgXSA9IDA7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXG5cdFx0ZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciggYXR0cmlidXRlLCAwICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSApIHtcblxuXHRcdGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBjdXJyZW50U3RhdGUubmV3QXR0cmlidXRlcztcblx0XHRjb25zdCBlbmFibGVkQXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5lbmFibGVkQXR0cmlidXRlcztcblx0XHRjb25zdCBhdHRyaWJ1dGVEaXZpc29ycyA9IGN1cnJlbnRTdGF0ZS5hdHRyaWJ1dGVEaXZpc29ycztcblxuXHRcdG5ld0F0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcblxuXHRcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID09PSAwICkge1xuXG5cdFx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlICk7XG5cdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBhdHRyaWJ1dGVEaXZpc29yc1sgYXR0cmlidXRlIF0gIT09IG1lc2hQZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoIGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSApO1xuXHRcdFx0YXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdID0gbWVzaFBlckF0dHJpYnV0ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKSB7XG5cblx0XHRjb25zdCBuZXdBdHRyaWJ1dGVzID0gY3VycmVudFN0YXRlLm5ld0F0dHJpYnV0ZXM7XG5cdFx0Y29uc3QgZW5hYmxlZEF0dHJpYnV0ZXMgPSBjdXJyZW50U3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gZW5hYmxlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSAhPT0gbmV3QXR0cmlidXRlc1sgaSBdICkge1xuXG5cdFx0XHRcdGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggaSApO1xuXHRcdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgaSBdID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB2ZXJ0ZXhBdHRyaWJQb2ludGVyKCBpbmRleCwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXQsIGludGVnZXIgKSB7XG5cblx0XHRpZiAoIGludGVnZXIgPT09IHRydWUgKSB7XG5cblx0XHRcdGdsLnZlcnRleEF0dHJpYklQb2ludGVyKCBpbmRleCwgc2l6ZSwgdHlwZSwgc3RyaWRlLCBvZmZzZXQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGluZGV4LCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUsIG9mZnNldCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG9iamVjdCwgbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5ICkge1xuXG5cdFx0aW5pdEF0dHJpYnV0ZXMoKTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cblx0XHRjb25zdCBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG5cdFx0Y29uc3QgbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzID0gbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcztcblxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IHByb2dyYW1BdHRyaWJ1dGUgPSBwcm9ncmFtQXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdFx0XHRpZiAoIHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24gPj0gMCApIHtcblxuXHRcdFx0XHRsZXQgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBnZW9tZXRyeUF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG5hbWUgPT09ICdpbnN0YW5jZU1hdHJpeCcgJiYgb2JqZWN0Lmluc3RhbmNlTWF0cml4ICkgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBvYmplY3QuaW5zdGFuY2VNYXRyaXg7XG5cdFx0XHRcdFx0aWYgKCBuYW1lID09PSAnaW5zdGFuY2VDb2xvcicgJiYgb2JqZWN0Lmluc3RhbmNlQ29sb3IgKSBnZW9tZXRyeUF0dHJpYnV0ZSA9IG9iamVjdC5pbnN0YW5jZUNvbG9yO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBub3JtYWxpemVkID0gZ2VvbWV0cnlBdHRyaWJ1dGUubm9ybWFsaXplZDtcblx0XHRcdFx0XHRjb25zdCBzaXplID0gZ2VvbWV0cnlBdHRyaWJ1dGUuaXRlbVNpemU7XG5cblx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLmdldCggZ2VvbWV0cnlBdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHRcdC8vIFRPRE8gQXR0cmlidXRlIG1heSBub3QgYmUgYXZhaWxhYmxlIG9uIGNvbnRleHQgcmVzdG9yZVxuXG5cdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0Y29uc3QgYnVmZmVyID0gYXR0cmlidXRlLmJ1ZmZlcjtcblx0XHRcdFx0XHRjb25zdCB0eXBlID0gYXR0cmlidXRlLnR5cGU7XG5cdFx0XHRcdFx0Y29uc3QgYnl0ZXNQZXJFbGVtZW50ID0gYXR0cmlidXRlLmJ5dGVzUGVyRWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIGNoZWNrIGZvciBpbnRlZ2VyIGF0dHJpYnV0ZXNcblxuXHRcdFx0XHRcdGNvbnN0IGludGVnZXIgPSAoIHR5cGUgPT09IGdsLklOVCB8fCB0eXBlID09PSBnbC5VTlNJR05FRF9JTlQgfHwgZ2VvbWV0cnlBdHRyaWJ1dGUuZ3B1VHlwZSA9PT0gSW50VHlwZSApO1xuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeUF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBkYXRhID0gZ2VvbWV0cnlBdHRyaWJ1dGUuZGF0YTtcblx0XHRcdFx0XHRcdGNvbnN0IHN0cmlkZSA9IGRhdGEuc3RyaWRlO1xuXHRcdFx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gZ2VvbWV0cnlBdHRyaWJ1dGUub2Zmc2V0O1xuXG5cdFx0XHRcdFx0XHRpZiAoIGRhdGEuaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZTsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24gKyBpLCBkYXRhLm1lc2hQZXJBdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBvYmplY3QuaXNJbnN0YW5jZWRNZXNoICE9PSB0cnVlICYmIGdlb21ldHJ5Ll9tYXhJbnN0YW5jZUNvdW50ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5fbWF4SW5zdGFuY2VDb3VudCA9IGRhdGEubWVzaFBlckF0dHJpYnV0ZSAqIGRhdGEuY291bnQ7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb25TaXplOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uICsgaSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlciApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZTsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuXHRcdFx0XHRcdFx0XHRcdHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24gKyBpLFxuXHRcdFx0XHRcdFx0XHRcdHNpemUgLyBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZSxcblx0XHRcdFx0XHRcdFx0XHR0eXBlLFxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbGl6ZWQsXG5cdFx0XHRcdFx0XHRcdFx0c3RyaWRlICogYnl0ZXNQZXJFbGVtZW50LFxuXHRcdFx0XHRcdFx0XHRcdCggb2Zmc2V0ICsgKCBzaXplIC8gcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemUgKSAqIGkgKSAqIGJ5dGVzUGVyRWxlbWVudCxcblx0XHRcdFx0XHRcdFx0XHRpbnRlZ2VyXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemU7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yKCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uICsgaSwgZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoIG9iamVjdC5pc0luc3RhbmNlZE1lc2ggIT09IHRydWUgJiYgZ2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGdlb21ldHJ5Ll9tYXhJbnN0YW5jZUNvdW50ID0gZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSAqIGdlb21ldHJ5QXR0cmlidXRlLmNvdW50O1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZTsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiArIGkgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemU7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmVydGV4QXR0cmliUG9pbnRlcihcblx0XHRcdFx0XHRcdFx0XHRwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uICsgaSxcblx0XHRcdFx0XHRcdFx0XHRzaXplIC8gcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemUsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZSxcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxpemVkLFxuXHRcdFx0XHRcdFx0XHRcdHNpemUgKiBieXRlc1BlckVsZW1lbnQsXG5cdFx0XHRcdFx0XHRcdFx0KCBzaXplIC8gcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemUgKSAqIGkgKiBieXRlc1BlckVsZW1lbnQsXG5cdFx0XHRcdFx0XHRcdFx0aW50ZWdlclxuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sgbmFtZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRzd2l0Y2ggKCB2YWx1ZS5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdFx0XHRcdGdsLnZlcnRleEF0dHJpYjJmdiggcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliM2Z2KCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uLCB2YWx1ZSApO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgNDpcblx0XHRcdFx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWI0ZnYoIHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWIxZnYoIHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24sIHZhbHVlICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cblx0XHRyZXNldCgpO1xuXG5cdFx0Zm9yICggY29uc3QgZ2VvbWV0cnlJZCBpbiBiaW5kaW5nU3RhdGVzICkge1xuXG5cdFx0XHRjb25zdCBwcm9ncmFtTWFwID0gYmluZGluZ1N0YXRlc1sgZ2VvbWV0cnlJZCBdO1xuXG5cdFx0XHRmb3IgKCBjb25zdCBwcm9ncmFtSWQgaW4gcHJvZ3JhbU1hcCApIHtcblxuXHRcdFx0XHRjb25zdCBzdGF0ZU1hcCA9IHByb2dyYW1NYXBbIHByb2dyYW1JZCBdO1xuXG5cdFx0XHRcdGZvciAoIGNvbnN0IHdpcmVmcmFtZSBpbiBzdGF0ZU1hcCApIHtcblxuXHRcdFx0XHRcdGRlbGV0ZVZlcnRleEFycmF5T2JqZWN0KCBzdGF0ZU1hcFsgd2lyZWZyYW1lIF0ub2JqZWN0ICk7XG5cblx0XHRcdFx0XHRkZWxldGUgc3RhdGVNYXBbIHdpcmVmcmFtZSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgcHJvZ3JhbU1hcFsgcHJvZ3JhbUlkIF07XG5cblx0XHRcdH1cblxuXHRcdFx0ZGVsZXRlIGJpbmRpbmdTdGF0ZXNbIGdlb21ldHJ5SWQgXTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVsZWFzZVN0YXRlc09mR2VvbWV0cnkoIGdlb21ldHJ5ICkge1xuXG5cdFx0aWYgKCBiaW5kaW5nU3RhdGVzWyBnZW9tZXRyeS5pZCBdID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRjb25zdCBwcm9ncmFtTWFwID0gYmluZGluZ1N0YXRlc1sgZ2VvbWV0cnkuaWQgXTtcblxuXHRcdGZvciAoIGNvbnN0IHByb2dyYW1JZCBpbiBwcm9ncmFtTWFwICkge1xuXG5cdFx0XHRjb25zdCBzdGF0ZU1hcCA9IHByb2dyYW1NYXBbIHByb2dyYW1JZCBdO1xuXG5cdFx0XHRmb3IgKCBjb25zdCB3aXJlZnJhbWUgaW4gc3RhdGVNYXAgKSB7XG5cblx0XHRcdFx0ZGVsZXRlVmVydGV4QXJyYXlPYmplY3QoIHN0YXRlTWFwWyB3aXJlZnJhbWUgXS5vYmplY3QgKTtcblxuXHRcdFx0XHRkZWxldGUgc3RhdGVNYXBbIHdpcmVmcmFtZSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRlbGV0ZSBwcm9ncmFtTWFwWyBwcm9ncmFtSWQgXTtcblxuXHRcdH1cblxuXHRcdGRlbGV0ZSBiaW5kaW5nU3RhdGVzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZWxlYXNlU3RhdGVzT2ZQcm9ncmFtKCBwcm9ncmFtICkge1xuXG5cdFx0Zm9yICggY29uc3QgZ2VvbWV0cnlJZCBpbiBiaW5kaW5nU3RhdGVzICkge1xuXG5cdFx0XHRjb25zdCBwcm9ncmFtTWFwID0gYmluZGluZ1N0YXRlc1sgZ2VvbWV0cnlJZCBdO1xuXG5cdFx0XHRpZiAoIHByb2dyYW1NYXBbIHByb2dyYW0uaWQgXSA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XG5cblx0XHRcdGNvbnN0IHN0YXRlTWFwID0gcHJvZ3JhbU1hcFsgcHJvZ3JhbS5pZCBdO1xuXG5cdFx0XHRmb3IgKCBjb25zdCB3aXJlZnJhbWUgaW4gc3RhdGVNYXAgKSB7XG5cblx0XHRcdFx0ZGVsZXRlVmVydGV4QXJyYXlPYmplY3QoIHN0YXRlTWFwWyB3aXJlZnJhbWUgXS5vYmplY3QgKTtcblxuXHRcdFx0XHRkZWxldGUgc3RhdGVNYXBbIHdpcmVmcmFtZSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRlbGV0ZSBwcm9ncmFtTWFwWyBwcm9ncmFtLmlkIF07XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlc2V0KCkge1xuXG5cdFx0cmVzZXREZWZhdWx0U3RhdGUoKTtcblx0XHRmb3JjZVVwZGF0ZSA9IHRydWU7XG5cblx0XHRpZiAoIGN1cnJlbnRTdGF0ZSA9PT0gZGVmYXVsdFN0YXRlICkgcmV0dXJuO1xuXG5cdFx0Y3VycmVudFN0YXRlID0gZGVmYXVsdFN0YXRlO1xuXHRcdGJpbmRWZXJ0ZXhBcnJheU9iamVjdCggY3VycmVudFN0YXRlLm9iamVjdCApO1xuXG5cdH1cblxuXHQvLyBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eVxuXG5cdGZ1bmN0aW9uIHJlc2V0RGVmYXVsdFN0YXRlKCkge1xuXG5cdFx0ZGVmYXVsdFN0YXRlLmdlb21ldHJ5ID0gbnVsbDtcblx0XHRkZWZhdWx0U3RhdGUucHJvZ3JhbSA9IG51bGw7XG5cdFx0ZGVmYXVsdFN0YXRlLndpcmVmcmFtZSA9IGZhbHNlO1xuXG5cdH1cblxuXHRyZXR1cm4ge1xuXG5cdFx0c2V0dXA6IHNldHVwLFxuXHRcdHJlc2V0OiByZXNldCxcblx0XHRyZXNldERlZmF1bHRTdGF0ZTogcmVzZXREZWZhdWx0U3RhdGUsXG5cdFx0ZGlzcG9zZTogZGlzcG9zZSxcblx0XHRyZWxlYXNlU3RhdGVzT2ZHZW9tZXRyeTogcmVsZWFzZVN0YXRlc09mR2VvbWV0cnksXG5cdFx0cmVsZWFzZVN0YXRlc09mUHJvZ3JhbTogcmVsZWFzZVN0YXRlc09mUHJvZ3JhbSxcblxuXHRcdGluaXRBdHRyaWJ1dGVzOiBpbml0QXR0cmlidXRlcyxcblx0XHRlbmFibGVBdHRyaWJ1dGU6IGVuYWJsZUF0dHJpYnV0ZSxcblx0XHRkaXNhYmxlVW51c2VkQXR0cmlidXRlczogZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXNcblxuXHR9O1xuXG59XG5cbmZ1bmN0aW9uIFdlYkdMQnVmZmVyUmVuZGVyZXIoIGdsLCBleHRlbnNpb25zLCBpbmZvICkge1xuXG5cdGxldCBtb2RlO1xuXG5cdGZ1bmN0aW9uIHNldE1vZGUoIHZhbHVlICkge1xuXG5cdFx0bW9kZSA9IHZhbHVlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXIoIHN0YXJ0LCBjb3VudCApIHtcblxuXHRcdGdsLmRyYXdBcnJheXMoIG1vZGUsIHN0YXJ0LCBjb3VudCApO1xuXG5cdFx0aW5mby51cGRhdGUoIGNvdW50LCBtb2RlLCAxICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyggc3RhcnQsIGNvdW50LCBwcmltY291bnQgKSB7XG5cblx0XHRpZiAoIHByaW1jb3VudCA9PT0gMCApIHJldHVybjtcblxuXHRcdGdsLmRyYXdBcnJheXNJbnN0YW5jZWQoIG1vZGUsIHN0YXJ0LCBjb3VudCwgcHJpbWNvdW50ICk7XG5cblx0XHRpbmZvLnVwZGF0ZSggY291bnQsIG1vZGUsIHByaW1jb3VudCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXJNdWx0aURyYXcoIHN0YXJ0cywgY291bnRzLCBkcmF3Q291bnQgKSB7XG5cblx0XHRpZiAoIGRyYXdDb3VudCA9PT0gMCApIHJldHVybjtcblxuXHRcdGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfbXVsdGlfZHJhdycgKTtcblx0XHRleHRlbnNpb24ubXVsdGlEcmF3QXJyYXlzV0VCR0woIG1vZGUsIHN0YXJ0cywgMCwgY291bnRzLCAwLCBkcmF3Q291bnQgKTtcblxuXHRcdGxldCBlbGVtZW50Q291bnQgPSAwO1xuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGRyYXdDb3VudDsgaSArKyApIHtcblxuXHRcdFx0ZWxlbWVudENvdW50ICs9IGNvdW50c1sgaSBdO1xuXG5cdFx0fVxuXG5cdFx0aW5mby51cGRhdGUoIGVsZW1lbnRDb3VudCwgbW9kZSwgMSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXJNdWx0aURyYXdJbnN0YW5jZXMoIHN0YXJ0cywgY291bnRzLCBkcmF3Q291bnQsIHByaW1jb3VudCApIHtcblxuXHRcdGlmICggZHJhd0NvdW50ID09PSAwICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9tdWx0aV9kcmF3JyApO1xuXG5cdFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHN0YXJ0cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0cmVuZGVySW5zdGFuY2VzKCBzdGFydHNbIGkgXSwgY291bnRzWyBpIF0sIHByaW1jb3VudFsgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGV4dGVuc2lvbi5tdWx0aURyYXdBcnJheXNJbnN0YW5jZWRXRUJHTCggbW9kZSwgc3RhcnRzLCAwLCBjb3VudHMsIDAsIHByaW1jb3VudCwgMCwgZHJhd0NvdW50ICk7XG5cblx0XHRcdGxldCBlbGVtZW50Q291bnQgPSAwO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZHJhd0NvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdGVsZW1lbnRDb3VudCArPSBjb3VudHNbIGkgXSAqIHByaW1jb3VudFsgaSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGluZm8udXBkYXRlKCBlbGVtZW50Q291bnQsIG1vZGUsIDEgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly9cblxuXHR0aGlzLnNldE1vZGUgPSBzZXRNb2RlO1xuXHR0aGlzLnJlbmRlciA9IHJlbmRlcjtcblx0dGhpcy5yZW5kZXJJbnN0YW5jZXMgPSByZW5kZXJJbnN0YW5jZXM7XG5cdHRoaXMucmVuZGVyTXVsdGlEcmF3ID0gcmVuZGVyTXVsdGlEcmF3O1xuXHR0aGlzLnJlbmRlck11bHRpRHJhd0luc3RhbmNlcyA9IHJlbmRlck11bHRpRHJhd0luc3RhbmNlcztcblxufVxuXG5mdW5jdGlvbiBXZWJHTENhcGFiaWxpdGllcyggZ2wsIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMsIHV0aWxzICkge1xuXG5cdGxldCBtYXhBbmlzb3Ryb3B5O1xuXG5cdGZ1bmN0aW9uIGdldE1heEFuaXNvdHJvcHkoKSB7XG5cblx0XHRpZiAoIG1heEFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIHJldHVybiBtYXhBbmlzb3Ryb3B5O1xuXG5cdFx0aWYgKCBleHRlbnNpb25zLmhhcyggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Y29uc3QgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG5cblx0XHRcdG1heEFuaXNvdHJvcHkgPSBnbC5nZXRQYXJhbWV0ZXIoIGV4dGVuc2lvbi5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1heEFuaXNvdHJvcHkgPSAwO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1heEFuaXNvdHJvcHk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHRleHR1cmVGb3JtYXRSZWFkYWJsZSggdGV4dHVyZUZvcm1hdCApIHtcblxuXHRcdGlmICggdGV4dHVyZUZvcm1hdCAhPT0gUkdCQUZvcm1hdCAmJiB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlRm9ybWF0ICkgIT09IGdsLmdldFBhcmFtZXRlciggZ2wuSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9GT1JNQVQgKSApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHRleHR1cmVUeXBlUmVhZGFibGUoIHRleHR1cmVUeXBlICkge1xuXG5cdFx0Y29uc3QgaGFsZkZsb2F0U3VwcG9ydGVkQnlFeHQgPSAoIHRleHR1cmVUeXBlID09PSBIYWxmRmxvYXRUeXBlICkgJiYgKCBleHRlbnNpb25zLmhhcyggJ0VYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCcgKSB8fCBleHRlbnNpb25zLmhhcyggJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnICkgKTtcblxuXHRcdGlmICggdGV4dHVyZVR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGUgJiYgdXRpbHMuY29udmVydCggdGV4dHVyZVR5cGUgKSAhPT0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX1RZUEUgKSAmJiAvLyBFZGdlIGFuZCBDaHJvbWUgTWFjIDwgNTIgKCM5NTEzKVxuXHRcdFx0dGV4dHVyZVR5cGUgIT09IEZsb2F0VHlwZSAmJiAhIGhhbGZGbG9hdFN1cHBvcnRlZEJ5RXh0ICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0TWF4UHJlY2lzaW9uKCBwcmVjaXNpb24gKSB7XG5cblx0XHRpZiAoIHByZWNpc2lvbiA9PT0gJ2hpZ2hwJyApIHtcblxuXHRcdFx0aWYgKCBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLlZFUlRFWF9TSEFERVIsIGdsLkhJR0hfRkxPQVQgKS5wcmVjaXNpb24gPiAwICYmXG5cdFx0XHRcdGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0ZMT0FUICkucHJlY2lzaW9uID4gMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gJ2hpZ2hwJztcblxuXHRcdFx0fVxuXG5cdFx0XHRwcmVjaXNpb24gPSAnbWVkaXVtcCc7XG5cblx0XHR9XG5cblx0XHRpZiAoIHByZWNpc2lvbiA9PT0gJ21lZGl1bXAnICkge1xuXG5cdFx0XHRpZiAoIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuVkVSVEVYX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUICkucHJlY2lzaW9uID4gMCAmJlxuXHRcdFx0XHRnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUICkucHJlY2lzaW9uID4gMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gJ21lZGl1bXAnO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gJ2xvd3AnO1xuXG5cdH1cblxuXHRsZXQgcHJlY2lzaW9uID0gcGFyYW1ldGVycy5wcmVjaXNpb24gIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlY2lzaW9uIDogJ2hpZ2hwJztcblx0Y29uc3QgbWF4UHJlY2lzaW9uID0gZ2V0TWF4UHJlY2lzaW9uKCBwcmVjaXNpb24gKTtcblxuXHRpZiAoIG1heFByZWNpc2lvbiAhPT0gcHJlY2lzaW9uICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjonLCBwcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIG1heFByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xuXHRcdHByZWNpc2lvbiA9IG1heFByZWNpc2lvbjtcblxuXHR9XG5cblx0Y29uc3QgbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA9IHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA9PT0gdHJ1ZTtcblx0Y29uc3QgcmV2ZXJzZURlcHRoQnVmZmVyID0gcGFyYW1ldGVycy5yZXZlcnNlRGVwdGhCdWZmZXIgPT09IHRydWUgJiYgZXh0ZW5zaW9ucy5oYXMoICdFWFRfY2xpcF9jb250cm9sJyApO1xuXG5cdGNvbnN0IG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xuXHRjb25zdCBtYXhWZXJ0ZXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG5cdGNvbnN0IG1heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVEVYVFVSRV9TSVpFICk7XG5cdGNvbnN0IG1heEN1YmVtYXBTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFICk7XG5cblx0Y29uc3QgbWF4QXR0cmlidXRlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTICk7XG5cdGNvbnN0IG1heFZlcnRleFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyApO1xuXHRjb25zdCBtYXhWYXJ5aW5ncyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZBUllJTkdfVkVDVE9SUyApO1xuXHRjb25zdCBtYXhGcmFnbWVudFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTICk7XG5cblx0Y29uc3QgdmVydGV4VGV4dHVyZXMgPSBtYXhWZXJ0ZXhUZXh0dXJlcyA+IDA7XG5cblx0Y29uc3QgbWF4U2FtcGxlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1NBTVBMRVMgKTtcblxuXHRyZXR1cm4ge1xuXG5cdFx0aXNXZWJHTDI6IHRydWUsIC8vIGtlZXBpbmcgdGhpcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuXHRcdGdldE1heEFuaXNvdHJvcHk6IGdldE1heEFuaXNvdHJvcHksXG5cdFx0Z2V0TWF4UHJlY2lzaW9uOiBnZXRNYXhQcmVjaXNpb24sXG5cblx0XHR0ZXh0dXJlRm9ybWF0UmVhZGFibGU6IHRleHR1cmVGb3JtYXRSZWFkYWJsZSxcblx0XHR0ZXh0dXJlVHlwZVJlYWRhYmxlOiB0ZXh0dXJlVHlwZVJlYWRhYmxlLFxuXG5cdFx0cHJlY2lzaW9uOiBwcmVjaXNpb24sXG5cdFx0bG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjogbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixcblx0XHRyZXZlcnNlRGVwdGhCdWZmZXI6IHJldmVyc2VEZXB0aEJ1ZmZlcixcblxuXHRcdG1heFRleHR1cmVzOiBtYXhUZXh0dXJlcyxcblx0XHRtYXhWZXJ0ZXhUZXh0dXJlczogbWF4VmVydGV4VGV4dHVyZXMsXG5cdFx0bWF4VGV4dHVyZVNpemU6IG1heFRleHR1cmVTaXplLFxuXHRcdG1heEN1YmVtYXBTaXplOiBtYXhDdWJlbWFwU2l6ZSxcblxuXHRcdG1heEF0dHJpYnV0ZXM6IG1heEF0dHJpYnV0ZXMsXG5cdFx0bWF4VmVydGV4VW5pZm9ybXM6IG1heFZlcnRleFVuaWZvcm1zLFxuXHRcdG1heFZhcnlpbmdzOiBtYXhWYXJ5aW5ncyxcblx0XHRtYXhGcmFnbWVudFVuaWZvcm1zOiBtYXhGcmFnbWVudFVuaWZvcm1zLFxuXG5cdFx0dmVydGV4VGV4dHVyZXM6IHZlcnRleFRleHR1cmVzLFxuXG5cdFx0bWF4U2FtcGxlczogbWF4U2FtcGxlc1xuXG5cdH07XG5cbn1cblxuZnVuY3Rpb24gV2ViR0xDbGlwcGluZyggcHJvcGVydGllcyApIHtcblxuXHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0bGV0IGdsb2JhbFN0YXRlID0gbnVsbCxcblx0XHRudW1HbG9iYWxQbGFuZXMgPSAwLFxuXHRcdGxvY2FsQ2xpcHBpbmdFbmFibGVkID0gZmFsc2UsXG5cdFx0cmVuZGVyaW5nU2hhZG93cyA9IGZhbHNlO1xuXG5cdGNvbnN0IHBsYW5lID0gbmV3IFBsYW5lKCksXG5cdFx0dmlld05vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCksXG5cblx0XHR1bmlmb3JtID0geyB2YWx1ZTogbnVsbCwgbmVlZHNVcGRhdGU6IGZhbHNlIH07XG5cblx0dGhpcy51bmlmb3JtID0gdW5pZm9ybTtcblx0dGhpcy5udW1QbGFuZXMgPSAwO1xuXHR0aGlzLm51bUludGVyc2VjdGlvbiA9IDA7XG5cblx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKCBwbGFuZXMsIGVuYWJsZUxvY2FsQ2xpcHBpbmcgKSB7XG5cblx0XHRjb25zdCBlbmFibGVkID1cblx0XHRcdHBsYW5lcy5sZW5ndGggIT09IDAgfHxcblx0XHRcdGVuYWJsZUxvY2FsQ2xpcHBpbmcgfHxcblx0XHRcdC8vIGVuYWJsZSBzdGF0ZSBvZiBwcmV2aW91cyBmcmFtZSAtIHRoZSBjbGlwcGluZyBjb2RlIGhhcyB0b1xuXHRcdFx0Ly8gcnVuIGFub3RoZXIgZnJhbWUgaW4gb3JkZXIgdG8gcmVzZXQgdGhlIHN0YXRlOlxuXHRcdFx0bnVtR2xvYmFsUGxhbmVzICE9PSAwIHx8XG5cdFx0XHRsb2NhbENsaXBwaW5nRW5hYmxlZDtcblxuXHRcdGxvY2FsQ2xpcHBpbmdFbmFibGVkID0gZW5hYmxlTG9jYWxDbGlwcGluZztcblxuXHRcdG51bUdsb2JhbFBsYW5lcyA9IHBsYW5lcy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gZW5hYmxlZDtcblxuXHR9O1xuXG5cdHRoaXMuYmVnaW5TaGFkb3dzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmVuZGVyaW5nU2hhZG93cyA9IHRydWU7XG5cdFx0cHJvamVjdFBsYW5lcyggbnVsbCApO1xuXG5cdH07XG5cblx0dGhpcy5lbmRTaGFkb3dzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmVuZGVyaW5nU2hhZG93cyA9IGZhbHNlO1xuXG5cdH07XG5cblx0dGhpcy5zZXRHbG9iYWxTdGF0ZSA9IGZ1bmN0aW9uICggcGxhbmVzLCBjYW1lcmEgKSB7XG5cblx0XHRnbG9iYWxTdGF0ZSA9IHByb2plY3RQbGFuZXMoIHBsYW5lcywgY2FtZXJhLCAwICk7XG5cblx0fTtcblxuXHR0aGlzLnNldFN0YXRlID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgY2FtZXJhLCB1c2VDYWNoZSApIHtcblxuXHRcdGNvbnN0IHBsYW5lcyA9IG1hdGVyaWFsLmNsaXBwaW5nUGxhbmVzLFxuXHRcdFx0Y2xpcEludGVyc2VjdGlvbiA9IG1hdGVyaWFsLmNsaXBJbnRlcnNlY3Rpb24sXG5cdFx0XHRjbGlwU2hhZG93cyA9IG1hdGVyaWFsLmNsaXBTaGFkb3dzO1xuXG5cdFx0Y29uc3QgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XG5cblx0XHRpZiAoICEgbG9jYWxDbGlwcGluZ0VuYWJsZWQgfHwgcGxhbmVzID09PSBudWxsIHx8IHBsYW5lcy5sZW5ndGggPT09IDAgfHwgcmVuZGVyaW5nU2hhZG93cyAmJiAhIGNsaXBTaGFkb3dzICkge1xuXG5cdFx0XHQvLyB0aGVyZSdzIG5vIGxvY2FsIGNsaXBwaW5nXG5cblx0XHRcdGlmICggcmVuZGVyaW5nU2hhZG93cyApIHtcblxuXHRcdFx0XHQvLyB0aGVyZSdzIG5vIGdsb2JhbCBjbGlwcGluZ1xuXG5cdFx0XHRcdHByb2plY3RQbGFuZXMoIG51bGwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXNldEdsb2JhbFN0YXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IG5HbG9iYWwgPSByZW5kZXJpbmdTaGFkb3dzID8gMCA6IG51bUdsb2JhbFBsYW5lcyxcblx0XHRcdFx0bEdsb2JhbCA9IG5HbG9iYWwgKiA0O1xuXG5cdFx0XHRsZXQgZHN0QXJyYXkgPSBtYXRlcmlhbFByb3BlcnRpZXMuY2xpcHBpbmdTdGF0ZSB8fCBudWxsO1xuXG5cdFx0XHR1bmlmb3JtLnZhbHVlID0gZHN0QXJyYXk7IC8vIGVuc3VyZSB1bmlxdWUgc3RhdGVcblxuXHRcdFx0ZHN0QXJyYXkgPSBwcm9qZWN0UGxhbmVzKCBwbGFuZXMsIGNhbWVyYSwgbEdsb2JhbCwgdXNlQ2FjaGUgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBsR2xvYmFsOyArKyBpICkge1xuXG5cdFx0XHRcdGRzdEFycmF5WyBpIF0gPSBnbG9iYWxTdGF0ZVsgaSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5jbGlwcGluZ1N0YXRlID0gZHN0QXJyYXk7XG5cdFx0XHR0aGlzLm51bUludGVyc2VjdGlvbiA9IGNsaXBJbnRlcnNlY3Rpb24gPyB0aGlzLm51bVBsYW5lcyA6IDA7XG5cdFx0XHR0aGlzLm51bVBsYW5lcyArPSBuR2xvYmFsO1xuXG5cdFx0fVxuXG5cblx0fTtcblxuXHRmdW5jdGlvbiByZXNldEdsb2JhbFN0YXRlKCkge1xuXG5cdFx0aWYgKCB1bmlmb3JtLnZhbHVlICE9PSBnbG9iYWxTdGF0ZSApIHtcblxuXHRcdFx0dW5pZm9ybS52YWx1ZSA9IGdsb2JhbFN0YXRlO1xuXHRcdFx0dW5pZm9ybS5uZWVkc1VwZGF0ZSA9IG51bUdsb2JhbFBsYW5lcyA+IDA7XG5cblx0XHR9XG5cblx0XHRzY29wZS5udW1QbGFuZXMgPSBudW1HbG9iYWxQbGFuZXM7XG5cdFx0c2NvcGUubnVtSW50ZXJzZWN0aW9uID0gMDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcHJvamVjdFBsYW5lcyggcGxhbmVzLCBjYW1lcmEsIGRzdE9mZnNldCwgc2tpcFRyYW5zZm9ybSApIHtcblxuXHRcdGNvbnN0IG5QbGFuZXMgPSBwbGFuZXMgIT09IG51bGwgPyBwbGFuZXMubGVuZ3RoIDogMDtcblx0XHRsZXQgZHN0QXJyYXkgPSBudWxsO1xuXG5cdFx0aWYgKCBuUGxhbmVzICE9PSAwICkge1xuXG5cdFx0XHRkc3RBcnJheSA9IHVuaWZvcm0udmFsdWU7XG5cblx0XHRcdGlmICggc2tpcFRyYW5zZm9ybSAhPT0gdHJ1ZSB8fCBkc3RBcnJheSA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRjb25zdCBmbGF0U2l6ZSA9IGRzdE9mZnNldCArIG5QbGFuZXMgKiA0LFxuXHRcdFx0XHRcdHZpZXdNYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlO1xuXG5cdFx0XHRcdHZpZXdOb3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCB2aWV3TWF0cml4ICk7XG5cblx0XHRcdFx0aWYgKCBkc3RBcnJheSA9PT0gbnVsbCB8fCBkc3RBcnJheS5sZW5ndGggPCBmbGF0U2l6ZSApIHtcblxuXHRcdFx0XHRcdGRzdEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggZmxhdFNpemUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpNCA9IGRzdE9mZnNldDsgaSAhPT0gblBsYW5lczsgKysgaSwgaTQgKz0gNCApIHtcblxuXHRcdFx0XHRcdHBsYW5lLmNvcHkoIHBsYW5lc1sgaSBdICkuYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4LCB2aWV3Tm9ybWFsTWF0cml4ICk7XG5cblx0XHRcdFx0XHRwbGFuZS5ub3JtYWwudG9BcnJheSggZHN0QXJyYXksIGk0ICk7XG5cdFx0XHRcdFx0ZHN0QXJyYXlbIGk0ICsgMyBdID0gcGxhbmUuY29uc3RhbnQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHVuaWZvcm0udmFsdWUgPSBkc3RBcnJheTtcblx0XHRcdHVuaWZvcm0ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0c2NvcGUubnVtUGxhbmVzID0gblBsYW5lcztcblx0XHRzY29wZS5udW1JbnRlcnNlY3Rpb24gPSAwO1xuXG5cdFx0cmV0dXJuIGRzdEFycmF5O1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBXZWJHTEN1YmVNYXBzKCByZW5kZXJlciApIHtcblxuXHRsZXQgY3ViZW1hcHMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdGZ1bmN0aW9uIG1hcFRleHR1cmVNYXBwaW5nKCB0ZXh0dXJlLCBtYXBwaW5nICkge1xuXG5cdFx0aWYgKCBtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyApIHtcblxuXHRcdFx0dGV4dHVyZS5tYXBwaW5nID0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nO1xuXG5cdFx0fSBlbHNlIGlmICggbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgKSB7XG5cblx0XHRcdHRleHR1cmUubWFwcGluZyA9IEN1YmVSZWZyYWN0aW9uTWFwcGluZztcblxuXHRcdH1cblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXQoIHRleHR1cmUgKSB7XG5cblx0XHRpZiAoIHRleHR1cmUgJiYgdGV4dHVyZS5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGNvbnN0IG1hcHBpbmcgPSB0ZXh0dXJlLm1hcHBpbmc7XG5cblx0XHRcdGlmICggbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgfHwgbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgKSB7XG5cblx0XHRcdFx0aWYgKCBjdWJlbWFwcy5oYXMoIHRleHR1cmUgKSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGN1YmVtYXAgPSBjdWJlbWFwcy5nZXQoIHRleHR1cmUgKS50ZXh0dXJlO1xuXHRcdFx0XHRcdHJldHVybiBtYXBUZXh0dXJlTWFwcGluZyggY3ViZW1hcCwgdGV4dHVyZS5tYXBwaW5nICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnN0IGltYWdlID0gdGV4dHVyZS5pbWFnZTtcblxuXHRcdFx0XHRcdGlmICggaW1hZ2UgJiYgaW1hZ2UuaGVpZ2h0ID4gMCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMQ3ViZVJlbmRlclRhcmdldCggaW1hZ2UuaGVpZ2h0ICk7XG5cdFx0XHRcdFx0XHRyZW5kZXJUYXJnZXQuZnJvbUVxdWlyZWN0YW5ndWxhclRleHR1cmUoIHJlbmRlcmVyLCB0ZXh0dXJlICk7XG5cdFx0XHRcdFx0XHRjdWJlbWFwcy5zZXQoIHRleHR1cmUsIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gbWFwVGV4dHVyZU1hcHBpbmcoIHJlbmRlclRhcmdldC50ZXh0dXJlLCB0ZXh0dXJlLm1hcHBpbmcgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIGltYWdlIG5vdCB5ZXQgcmVhZHkuIHRyeSB0aGUgY29udmVyc2lvbiBuZXh0IGZyYW1lXG5cblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uVGV4dHVyZURpc3Bvc2UoIGV2ZW50ICkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZSA9IGV2ZW50LnRhcmdldDtcblxuXHRcdHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cblx0XHRjb25zdCBjdWJlbWFwID0gY3ViZW1hcHMuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRpZiAoIGN1YmVtYXAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y3ViZW1hcHMuZGVsZXRlKCB0ZXh0dXJlICk7XG5cdFx0XHRjdWJlbWFwLmRpc3Bvc2UoKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcblxuXHRcdGN1YmVtYXBzID0gbmV3IFdlYWtNYXAoKTtcblxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGdldCxcblx0XHRkaXNwb3NlOiBkaXNwb3NlXG5cdH07XG5cbn1cblxuY29uc3QgTE9EX01JTiA9IDQ7XG5cbi8vIFRoZSBzdGFuZGFyZCBkZXZpYXRpb25zIChyYWRpYW5zKSBhc3NvY2lhdGVkIHdpdGggdGhlIGV4dHJhIG1pcHMuIFRoZXNlIGFyZVxuLy8gY2hvc2VuIHRvIGFwcHJveGltYXRlIGEgVHJvd2JyaWRnZS1SZWl0eiBkaXN0cmlidXRpb24gZnVuY3Rpb24gdGltZXMgdGhlXG4vLyBnZW9tZXRyaWMgc2hhZG93aW5nIGZ1bmN0aW9uLiBUaGVzZSBzaWdtYSB2YWx1ZXMgc3F1YXJlZCBtdXN0IG1hdGNoIHRoZVxuLy8gdmFyaWFuY2UgI2RlZmluZXMgaW4gY3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50Lmdsc2wuanMuXG5jb25zdCBFWFRSQV9MT0RfU0lHTUEgPSBbIDAuMTI1LCAwLjIxNSwgMC4zNSwgMC40NDYsIDAuNTI2LCAwLjU4MiBdO1xuXG4vLyBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIGJsdXIgZm9yIGxvb3AuIFNtYWxsZXIgc2lnbWFzIHdpbGwgdXNlIGZld2VyXG4vLyBzYW1wbGVzIGFuZCBleGl0IGVhcmx5LCBidXQgbm90IHJlY29tcGlsZSB0aGUgc2hhZGVyLlxuY29uc3QgTUFYX1NBTVBMRVMgPSAyMDtcblxuY29uc3QgX2ZsYXRDYW1lcmEgPSAvKkBfX1BVUkVfXyovIG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoKTtcbmNvbnN0IF9jbGVhckNvbG9yID0gLypAX19QVVJFX18qLyBuZXcgQ29sb3IoKTtcbmxldCBfb2xkVGFyZ2V0ID0gbnVsbDtcbmxldCBfb2xkQWN0aXZlQ3ViZUZhY2UgPSAwO1xubGV0IF9vbGRBY3RpdmVNaXBtYXBMZXZlbCA9IDA7XG5sZXQgX29sZFhyRW5hYmxlZCA9IGZhbHNlO1xuXG4vLyBHb2xkZW4gUmF0aW9cbmNvbnN0IFBISSA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuY29uc3QgSU5WX1BISSA9IDEgLyBQSEk7XG5cbi8vIFZlcnRpY2VzIG9mIGEgZG9kZWNhaGVkcm9uIChleGNlcHQgdGhlIG9wcG9zaXRlcywgd2hpY2ggcmVwcmVzZW50IHRoZVxuLy8gc2FtZSBheGlzKSwgdXNlZCBhcyBheGlzIGRpcmVjdGlvbnMgZXZlbmx5IHNwcmVhZCBvbiBhIHNwaGVyZS5cbmNvbnN0IF9heGlzRGlyZWN0aW9ucyA9IFtcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggLSBQSEksIElOVl9QSEksIDAgKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggUEhJLCBJTlZfUEhJLCAwICksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIC0gSU5WX1BISSwgMCwgUEhJICksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIElOVl9QSEksIDAsIFBISSApLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAwLCBQSEksIC0gSU5WX1BISSApLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAwLCBQSEksIElOVl9QSEkgKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggLSAxLCAxLCAtIDEgKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggMSwgMSwgLSAxICksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIC0gMSwgMSwgMSApLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAxLCAxLCAxICkgXTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGdlbmVyYXRlcyBhIFByZWZpbHRlcmVkLCBNaXBtYXBwZWQgUmFkaWFuY2UgRW52aXJvbm1lbnQgTWFwXG4gKiAoUE1SRU0pIGZyb20gYSBjdWJlTWFwIGVudmlyb25tZW50IHRleHR1cmUuIFRoaXMgYWxsb3dzIGRpZmZlcmVudCBsZXZlbHMgb2ZcbiAqIGJsdXIgdG8gYmUgcXVpY2tseSBhY2Nlc3NlZCBiYXNlZCBvbiBtYXRlcmlhbCByb3VnaG5lc3MuIEl0IGlzIHBhY2tlZCBpbnRvIGFcbiAqIHNwZWNpYWwgQ3ViZVVWIGZvcm1hdCB0aGF0IGFsbG93cyB1cyB0byBwZXJmb3JtIGN1c3RvbSBpbnRlcnBvbGF0aW9uIHNvIHRoYXRcbiAqIHdlIGNhbiBzdXBwb3J0IG5vbmxpbmVhciBmb3JtYXRzIHN1Y2ggYXMgUkdCRS4gVW5saWtlIGEgdHJhZGl0aW9uYWwgbWlwbWFwXG4gKiBjaGFpbiwgaXQgb25seSBnb2VzIGRvd24gdG8gdGhlIExPRF9NSU4gbGV2ZWwgKGFib3ZlKSwgYW5kIHRoZW4gY3JlYXRlcyBleHRyYVxuICogZXZlbiBtb3JlIGZpbHRlcmVkICdtaXBzJyBhdCB0aGUgc2FtZSBMT0RfTUlOIHJlc29sdXRpb24sIGFzc29jaWF0ZWQgd2l0aFxuICogaGlnaGVyIHJvdWdobmVzcyBsZXZlbHMuIEluIHRoaXMgd2F5IHdlIG1haW50YWluIHJlc29sdXRpb24gdG8gc21vb3RobHlcbiAqIGludGVycG9sYXRlIGRpZmZ1c2UgbGlnaHRpbmcgd2hpbGUgbGltaXRpbmcgc2FtcGxpbmcgY29tcHV0YXRpb24uXG4gKlxuICogUGFwZXI6IEZhc3QsIEFjY3VyYXRlIEltYWdlLUJhc2VkIExpZ2h0aW5nXG4gKiBodHRwczovL2RyaXZlLmdvb2dsZS5jb20vZmlsZS9kLzE1eThyX1VwS2xVOVN2VjRJTGIwQzNxQ1BlY1M4cHZMei92aWV3XG4qL1xuXG5jbGFzcyBQTVJFTUdlbmVyYXRvciB7XG5cblx0Y29uc3RydWN0b3IoIHJlbmRlcmVyICkge1xuXG5cdFx0dGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcblx0XHR0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldCA9IG51bGw7XG5cblx0XHR0aGlzLl9sb2RNYXggPSAwO1xuXHRcdHRoaXMuX2N1YmVTaXplID0gMDtcblx0XHR0aGlzLl9sb2RQbGFuZXMgPSBbXTtcblx0XHR0aGlzLl9zaXplTG9kcyA9IFtdO1xuXHRcdHRoaXMuX3NpZ21hcyA9IFtdO1xuXG5cdFx0dGhpcy5fYmx1ck1hdGVyaWFsID0gbnVsbDtcblx0XHR0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgPSBudWxsO1xuXHRcdHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPSBudWxsO1xuXG5cdFx0dGhpcy5fY29tcGlsZU1hdGVyaWFsKCB0aGlzLl9ibHVyTWF0ZXJpYWwgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhIFBNUkVNIGZyb20gYSBzdXBwbGllZCBTY2VuZSwgd2hpY2ggY2FuIGJlIGZhc3RlciB0aGFuIHVzaW5nIGFuXG5cdCAqIGltYWdlIGlmIG5ldHdvcmtpbmcgYmFuZHdpZHRoIGlzIGxvdy4gT3B0aW9uYWwgc2lnbWEgc3BlY2lmaWVzIGEgYmx1ciByYWRpdXNcblx0ICogaW4gcmFkaWFucyB0byBiZSBhcHBsaWVkIHRvIHRoZSBzY2VuZSBiZWZvcmUgUE1SRU0gZ2VuZXJhdGlvbi4gT3B0aW9uYWwgbmVhclxuXHQgKiBhbmQgZmFyIHBsYW5lcyBlbnN1cmUgdGhlIHNjZW5lIGlzIHJlbmRlcmVkIGluIGl0cyBlbnRpcmV0eSAodGhlIGN1YmVDYW1lcmFcblx0ICogaXMgcGxhY2VkIGF0IHRoZSBvcmlnaW4pLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2lnbWFcblx0ICogQHBhcmFtIHtudW1iZXJ9IG5lYXJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGZhclxuXHQgKiBAcmV0dXJuIHtXZWJHTFJlbmRlclRhcmdldH1cblx0ICovXG5cdGZyb21TY2VuZSggc2NlbmUsIHNpZ21hID0gMCwgbmVhciA9IDAuMSwgZmFyID0gMTAwICkge1xuXG5cdFx0X29sZFRhcmdldCA9IHRoaXMuX3JlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuXHRcdF9vbGRBY3RpdmVDdWJlRmFjZSA9IHRoaXMuX3JlbmRlcmVyLmdldEFjdGl2ZUN1YmVGYWNlKCk7XG5cdFx0X29sZEFjdGl2ZU1pcG1hcExldmVsID0gdGhpcy5fcmVuZGVyZXIuZ2V0QWN0aXZlTWlwbWFwTGV2ZWwoKTtcblx0XHRfb2xkWHJFbmFibGVkID0gdGhpcy5fcmVuZGVyZXIueHIuZW5hYmxlZDtcblxuXHRcdHRoaXMuX3JlbmRlcmVyLnhyLmVuYWJsZWQgPSBmYWxzZTtcblxuXHRcdHRoaXMuX3NldFNpemUoIDI1NiApO1xuXG5cdFx0Y29uc3QgY3ViZVVWUmVuZGVyVGFyZ2V0ID0gdGhpcy5fYWxsb2NhdGVUYXJnZXRzKCk7XG5cdFx0Y3ViZVVWUmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyID0gdHJ1ZTtcblxuXHRcdHRoaXMuX3NjZW5lVG9DdWJlVVYoIHNjZW5lLCBuZWFyLCBmYXIsIGN1YmVVVlJlbmRlclRhcmdldCApO1xuXG5cdFx0aWYgKCBzaWdtYSA+IDAgKSB7XG5cblx0XHRcdHRoaXMuX2JsdXIoIGN1YmVVVlJlbmRlclRhcmdldCwgMCwgMCwgc2lnbWEgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX2FwcGx5UE1SRU0oIGN1YmVVVlJlbmRlclRhcmdldCApO1xuXHRcdHRoaXMuX2NsZWFudXAoIGN1YmVVVlJlbmRlclRhcmdldCApO1xuXG5cdFx0cmV0dXJuIGN1YmVVVlJlbmRlclRhcmdldDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhIFBNUkVNIGZyb20gYW4gZXF1aXJlY3Rhbmd1bGFyIHRleHR1cmUsIHdoaWNoIGNhbiBiZSBlaXRoZXIgTERSXG5cdCAqIG9yIEhEUi4gVGhlIGlkZWFsIGlucHV0IGltYWdlIHNpemUgaXMgMWsgKDEwMjQgeCA1MTIpLFxuXHQgKiBhcyB0aGlzIG1hdGNoZXMgYmVzdCB3aXRoIHRoZSAyNTYgeCAyNTYgY3ViZW1hcCBvdXRwdXQuXG5cdCAqIFRoZSBzbWFsbGVzdCBzdXBwb3J0ZWQgZXF1aXJlY3Rhbmd1bGFyIGltYWdlIHNpemUgaXMgNjQgeCAzMi5cblx0ICpcblx0ICogQHBhcmFtIHtUZXh0dXJlfSBlcXVpcmVjdGFuZ3VsYXJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gW3JlbmRlclRhcmdldD1udWxsXSAtIE9wdGlvbmFsIHJlbmRlciB0YXJnZXQuXG5cdCAqIEByZXR1cm4ge1dlYkdMUmVuZGVyVGFyZ2V0fVxuXHQgKi9cblx0ZnJvbUVxdWlyZWN0YW5ndWxhciggZXF1aXJlY3Rhbmd1bGFyLCByZW5kZXJUYXJnZXQgPSBudWxsICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2Zyb21UZXh0dXJlKCBlcXVpcmVjdGFuZ3VsYXIsIHJlbmRlclRhcmdldCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGVzIGEgUE1SRU0gZnJvbSBhbiBjdWJlbWFwIHRleHR1cmUsIHdoaWNoIGNhbiBiZSBlaXRoZXIgTERSXG5cdCAqIG9yIEhEUi4gVGhlIGlkZWFsIGlucHV0IGN1YmUgc2l6ZSBpcyAyNTYgeCAyNTYsXG5cdCAqIGFzIHRoaXMgbWF0Y2hlcyBiZXN0IHdpdGggdGhlIDI1NiB4IDI1NiBjdWJlbWFwIG91dHB1dC5cblx0ICogVGhlIHNtYWxsZXN0IHN1cHBvcnRlZCBjdWJlIHNpemUgaXMgMTYgeCAxNi5cblx0ICpcblx0ICogQHBhcmFtIHtUZXh0dXJlfSBjdWJlbWFwXG5cdCAqIEBwYXJhbSB7bnVsbH0gW3JlbmRlclRhcmdldD1udWxsXSAtIE9wdGlvbmFsIHJlbmRlciB0YXJnZXQuXG5cdCAqIEByZXR1cm4ge1dlYkdMUmVuZGVyVGFyZ2V0fVxuXHQgKi9cblx0ZnJvbUN1YmVtYXAoIGN1YmVtYXAsIHJlbmRlclRhcmdldCA9IG51bGwgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fZnJvbVRleHR1cmUoIGN1YmVtYXAsIHJlbmRlclRhcmdldCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUHJlLWNvbXBpbGVzIHRoZSBjdWJlbWFwIHNoYWRlci4gWW91IGNhbiBnZXQgZmFzdGVyIHN0YXJ0LXVwIGJ5IGludm9raW5nIHRoaXMgbWV0aG9kIGR1cmluZ1xuXHQgKiB5b3VyIHRleHR1cmUncyBuZXR3b3JrIGZldGNoIGZvciBpbmNyZWFzZWQgY29uY3VycmVuY3kuXG5cdCAqL1xuXHRjb21waWxlQ3ViZW1hcFNoYWRlcigpIHtcblxuXHRcdGlmICggdGhpcy5fY3ViZW1hcE1hdGVyaWFsID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgPSBfZ2V0Q3ViZW1hcE1hdGVyaWFsKCk7XG5cdFx0XHR0aGlzLl9jb21waWxlTWF0ZXJpYWwoIHRoaXMuX2N1YmVtYXBNYXRlcmlhbCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogUHJlLWNvbXBpbGVzIHRoZSBlcXVpcmVjdGFuZ3VsYXIgc2hhZGVyLiBZb3UgY2FuIGdldCBmYXN0ZXIgc3RhcnQtdXAgYnkgaW52b2tpbmcgdGhpcyBtZXRob2QgZHVyaW5nXG5cdCAqIHlvdXIgdGV4dHVyZSdzIG5ldHdvcmsgZmV0Y2ggZm9yIGluY3JlYXNlZCBjb25jdXJyZW5jeS5cblx0ICovXG5cdGNvbXBpbGVFcXVpcmVjdGFuZ3VsYXJTaGFkZXIoKSB7XG5cblx0XHRpZiAoIHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPSBfZ2V0RXF1aXJlY3RNYXRlcmlhbCgpO1xuXHRcdFx0dGhpcy5fY29tcGlsZU1hdGVyaWFsKCB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNwb3NlcyBvZiB0aGUgUE1SRU1HZW5lcmF0b3IncyBpbnRlcm5hbCBtZW1vcnkuIE5vdGUgdGhhdCBQTVJFTUdlbmVyYXRvciBpcyBhIHN0YXRpYyBjbGFzcyxcblx0ICogc28geW91IHNob3VsZCBub3QgbmVlZCBtb3JlIHRoYW4gb25lIFBNUkVNR2VuZXJhdG9yIG9iamVjdC4gSWYgeW91IGRvLCBjYWxsaW5nIGRpc3Bvc2UoKSBvblxuXHQgKiBvbmUgb2YgdGhlbSB3aWxsIGNhdXNlIGFueSBvdGhlcnMgdG8gYWxzbyBiZWNvbWUgdW51c2FibGUuXG5cdCAqL1xuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5fZGlzcG9zZSgpO1xuXG5cdFx0aWYgKCB0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgIT09IG51bGwgKSB0aGlzLl9jdWJlbWFwTWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdGlmICggdGhpcy5fZXF1aXJlY3RNYXRlcmlhbCAhPT0gbnVsbCApIHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH1cblxuXHQvLyBwcml2YXRlIGludGVyZmFjZVxuXG5cdF9zZXRTaXplKCBjdWJlU2l6ZSApIHtcblxuXHRcdHRoaXMuX2xvZE1heCA9IE1hdGguZmxvb3IoIE1hdGgubG9nMiggY3ViZVNpemUgKSApO1xuXHRcdHRoaXMuX2N1YmVTaXplID0gTWF0aC5wb3coIDIsIHRoaXMuX2xvZE1heCApO1xuXG5cdH1cblxuXHRfZGlzcG9zZSgpIHtcblxuXHRcdGlmICggdGhpcy5fYmx1ck1hdGVyaWFsICE9PSBudWxsICkgdGhpcy5fYmx1ck1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHRcdGlmICggdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQgIT09IG51bGwgKSB0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldC5kaXNwb3NlKCk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLl9sb2RQbGFuZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLl9sb2RQbGFuZXNbIGkgXS5kaXNwb3NlKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdF9jbGVhbnVwKCBvdXRwdXRUYXJnZXQgKSB7XG5cblx0XHR0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIF9vbGRUYXJnZXQsIF9vbGRBY3RpdmVDdWJlRmFjZSwgX29sZEFjdGl2ZU1pcG1hcExldmVsICk7XG5cdFx0dGhpcy5fcmVuZGVyZXIueHIuZW5hYmxlZCA9IF9vbGRYckVuYWJsZWQ7XG5cblx0XHRvdXRwdXRUYXJnZXQuc2Npc3NvclRlc3QgPSBmYWxzZTtcblx0XHRfc2V0Vmlld3BvcnQoIG91dHB1dFRhcmdldCwgMCwgMCwgb3V0cHV0VGFyZ2V0LndpZHRoLCBvdXRwdXRUYXJnZXQuaGVpZ2h0ICk7XG5cblx0fVxuXG5cdF9mcm9tVGV4dHVyZSggdGV4dHVyZSwgcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0aWYgKCB0ZXh0dXJlLm1hcHBpbmcgPT09IEN1YmVSZWZsZWN0aW9uTWFwcGluZyB8fCB0ZXh0dXJlLm1hcHBpbmcgPT09IEN1YmVSZWZyYWN0aW9uTWFwcGluZyApIHtcblxuXHRcdFx0dGhpcy5fc2V0U2l6ZSggdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDAgPyAxNiA6ICggdGV4dHVyZS5pbWFnZVsgMCBdLndpZHRoIHx8IHRleHR1cmUuaW1hZ2VbIDAgXS5pbWFnZS53aWR0aCApICk7XG5cblx0XHR9IGVsc2UgeyAvLyBFcXVpcmVjdGFuZ3VsYXJcblxuXHRcdFx0dGhpcy5fc2V0U2l6ZSggdGV4dHVyZS5pbWFnZS53aWR0aCAvIDQgKTtcblxuXHRcdH1cblxuXHRcdF9vbGRUYXJnZXQgPSB0aGlzLl9yZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblx0XHRfb2xkQWN0aXZlQ3ViZUZhY2UgPSB0aGlzLl9yZW5kZXJlci5nZXRBY3RpdmVDdWJlRmFjZSgpO1xuXHRcdF9vbGRBY3RpdmVNaXBtYXBMZXZlbCA9IHRoaXMuX3JlbmRlcmVyLmdldEFjdGl2ZU1pcG1hcExldmVsKCk7XG5cdFx0X29sZFhyRW5hYmxlZCA9IHRoaXMuX3JlbmRlcmVyLnhyLmVuYWJsZWQ7XG5cblx0XHR0aGlzLl9yZW5kZXJlci54ci5lbmFibGVkID0gZmFsc2U7XG5cblx0XHRjb25zdCBjdWJlVVZSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQgfHwgdGhpcy5fYWxsb2NhdGVUYXJnZXRzKCk7XG5cdFx0dGhpcy5fdGV4dHVyZVRvQ3ViZVVWKCB0ZXh0dXJlLCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcblx0XHR0aGlzLl9hcHBseVBNUkVNKCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcblx0XHR0aGlzLl9jbGVhbnVwKCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcblxuXHRcdHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XG5cblx0fVxuXG5cdF9hbGxvY2F0ZVRhcmdldHMoKSB7XG5cblx0XHRjb25zdCB3aWR0aCA9IDMgKiBNYXRoLm1heCggdGhpcy5fY3ViZVNpemUsIDE2ICogNyApO1xuXHRcdGNvbnN0IGhlaWdodCA9IDQgKiB0aGlzLl9jdWJlU2l6ZTtcblxuXHRcdGNvbnN0IHBhcmFtcyA9IHtcblx0XHRcdG1hZ0ZpbHRlcjogTGluZWFyRmlsdGVyLFxuXHRcdFx0bWluRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXG5cdFx0XHRnZW5lcmF0ZU1pcG1hcHM6IGZhbHNlLFxuXHRcdFx0dHlwZTogSGFsZkZsb2F0VHlwZSxcblx0XHRcdGZvcm1hdDogUkdCQUZvcm1hdCxcblx0XHRcdGNvbG9yU3BhY2U6IExpbmVhclNSR0JDb2xvclNwYWNlLFxuXHRcdFx0ZGVwdGhCdWZmZXI6IGZhbHNlXG5cdFx0fTtcblxuXHRcdGNvbnN0IGN1YmVVVlJlbmRlclRhcmdldCA9IF9jcmVhdGVSZW5kZXJUYXJnZXQoIHdpZHRoLCBoZWlnaHQsIHBhcmFtcyApO1xuXG5cdFx0aWYgKCB0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldCA9PT0gbnVsbCB8fCB0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldC53aWR0aCAhPT0gd2lkdGggfHwgdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQuaGVpZ2h0ICE9PSBoZWlnaHQgKSB7XG5cblx0XHRcdGlmICggdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5fZGlzcG9zZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ID0gX2NyZWF0ZVJlbmRlclRhcmdldCggd2lkdGgsIGhlaWdodCwgcGFyYW1zICk7XG5cblx0XHRcdGNvbnN0IHsgX2xvZE1heCB9ID0gdGhpcztcblx0XHRcdCggeyBzaXplTG9kczogdGhpcy5fc2l6ZUxvZHMsIGxvZFBsYW5lczogdGhpcy5fbG9kUGxhbmVzLCBzaWdtYXM6IHRoaXMuX3NpZ21hcyB9ID0gX2NyZWF0ZVBsYW5lcyggX2xvZE1heCApICk7XG5cblx0XHRcdHRoaXMuX2JsdXJNYXRlcmlhbCA9IF9nZXRCbHVyU2hhZGVyKCBfbG9kTWF4LCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY3ViZVVWUmVuZGVyVGFyZ2V0O1xuXG5cdH1cblxuXHRfY29tcGlsZU1hdGVyaWFsKCBtYXRlcmlhbCApIHtcblxuXHRcdGNvbnN0IHRtcE1lc2ggPSBuZXcgTWVzaCggdGhpcy5fbG9kUGxhbmVzWyAwIF0sIG1hdGVyaWFsICk7XG5cdFx0dGhpcy5fcmVuZGVyZXIuY29tcGlsZSggdG1wTWVzaCwgX2ZsYXRDYW1lcmEgKTtcblxuXHR9XG5cblx0X3NjZW5lVG9DdWJlVVYoIHNjZW5lLCBuZWFyLCBmYXIsIGN1YmVVVlJlbmRlclRhcmdldCApIHtcblxuXHRcdGNvbnN0IGZvdiA9IDkwO1xuXHRcdGNvbnN0IGFzcGVjdCA9IDE7XG5cdFx0Y29uc3QgY3ViZUNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHRcdGNvbnN0IHVwU2lnbiA9IFsgMSwgLSAxLCAxLCAxLCAxLCAxIF07XG5cdFx0Y29uc3QgZm9yd2FyZFNpZ24gPSBbIDEsIDEsIDEsIC0gMSwgLSAxLCAtIDEgXTtcblx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuXG5cdFx0Y29uc3Qgb3JpZ2luYWxBdXRvQ2xlYXIgPSByZW5kZXJlci5hdXRvQ2xlYXI7XG5cdFx0Y29uc3QgdG9uZU1hcHBpbmcgPSByZW5kZXJlci50b25lTWFwcGluZztcblx0XHRyZW5kZXJlci5nZXRDbGVhckNvbG9yKCBfY2xlYXJDb2xvciApO1xuXG5cdFx0cmVuZGVyZXIudG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xuXHRcdHJlbmRlcmVyLmF1dG9DbGVhciA9IGZhbHNlO1xuXG5cdFx0Y29uc3QgYmFja2dyb3VuZE1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7XG5cdFx0XHRuYW1lOiAnUE1SRU0uQmFja2dyb3VuZCcsXG5cdFx0XHRzaWRlOiBCYWNrU2lkZSxcblx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZSxcblx0XHR9ICk7XG5cblx0XHRjb25zdCBiYWNrZ3JvdW5kQm94ID0gbmV3IE1lc2goIG5ldyBCb3hHZW9tZXRyeSgpLCBiYWNrZ3JvdW5kTWF0ZXJpYWwgKTtcblxuXHRcdGxldCB1c2VTb2xpZENvbG9yID0gZmFsc2U7XG5cdFx0Y29uc3QgYmFja2dyb3VuZCA9IHNjZW5lLmJhY2tncm91bmQ7XG5cblx0XHRpZiAoIGJhY2tncm91bmQgKSB7XG5cblx0XHRcdGlmICggYmFja2dyb3VuZC5pc0NvbG9yICkge1xuXG5cdFx0XHRcdGJhY2tncm91bmRNYXRlcmlhbC5jb2xvci5jb3B5KCBiYWNrZ3JvdW5kICk7XG5cdFx0XHRcdHNjZW5lLmJhY2tncm91bmQgPSBudWxsO1xuXHRcdFx0XHR1c2VTb2xpZENvbG9yID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0YmFja2dyb3VuZE1hdGVyaWFsLmNvbG9yLmNvcHkoIF9jbGVhckNvbG9yICk7XG5cdFx0XHR1c2VTb2xpZENvbG9yID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGNvbCA9IGkgJSAzO1xuXG5cdFx0XHRpZiAoIGNvbCA9PT0gMCApIHtcblxuXHRcdFx0XHRjdWJlQ2FtZXJhLnVwLnNldCggMCwgdXBTaWduWyBpIF0sIDAgKTtcblx0XHRcdFx0Y3ViZUNhbWVyYS5sb29rQXQoIGZvcndhcmRTaWduWyBpIF0sIDAsIDAgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggY29sID09PSAxICkge1xuXG5cdFx0XHRcdGN1YmVDYW1lcmEudXAuc2V0KCAwLCAwLCB1cFNpZ25bIGkgXSApO1xuXHRcdFx0XHRjdWJlQ2FtZXJhLmxvb2tBdCggMCwgZm9yd2FyZFNpZ25bIGkgXSwgMCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGN1YmVDYW1lcmEudXAuc2V0KCAwLCB1cFNpZ25bIGkgXSwgMCApO1xuXHRcdFx0XHRjdWJlQ2FtZXJhLmxvb2tBdCggMCwgMCwgZm9yd2FyZFNpZ25bIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNpemUgPSB0aGlzLl9jdWJlU2l6ZTtcblxuXHRcdFx0X3NldFZpZXdwb3J0KCBjdWJlVVZSZW5kZXJUYXJnZXQsIGNvbCAqIHNpemUsIGkgPiAyID8gc2l6ZSA6IDAsIHNpemUsIHNpemUgKTtcblxuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0aWYgKCB1c2VTb2xpZENvbG9yICkge1xuXG5cdFx0XHRcdHJlbmRlcmVyLnJlbmRlciggYmFja2dyb3VuZEJveCwgY3ViZUNhbWVyYSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGN1YmVDYW1lcmEgKTtcblxuXHRcdH1cblxuXHRcdGJhY2tncm91bmRCb3guZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdGJhY2tncm91bmRCb3gubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdFx0cmVuZGVyZXIudG9uZU1hcHBpbmcgPSB0b25lTWFwcGluZztcblx0XHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBvcmlnaW5hbEF1dG9DbGVhcjtcblx0XHRzY2VuZS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcblxuXHR9XG5cblx0X3RleHR1cmVUb0N1YmVVViggdGV4dHVyZSwgY3ViZVVWUmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcblxuXHRcdGNvbnN0IGlzQ3ViZVRleHR1cmUgPSAoIHRleHR1cmUubWFwcGluZyA9PT0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nIHx8IHRleHR1cmUubWFwcGluZyA9PT0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nICk7XG5cblx0XHRpZiAoIGlzQ3ViZVRleHR1cmUgKSB7XG5cblx0XHRcdGlmICggdGhpcy5fY3ViZW1hcE1hdGVyaWFsID09PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA9IF9nZXRDdWJlbWFwTWF0ZXJpYWwoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jdWJlbWFwTWF0ZXJpYWwudW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZSA9ICggdGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPT09IGZhbHNlICkgPyAtIDEgOiAxO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsID09PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPSBfZ2V0RXF1aXJlY3RNYXRlcmlhbCgpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zdCBtYXRlcmlhbCA9IGlzQ3ViZVRleHR1cmUgPyB0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgOiB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsO1xuXHRcdGNvbnN0IG1lc2ggPSBuZXcgTWVzaCggdGhpcy5fbG9kUGxhbmVzWyAwIF0sIG1hdGVyaWFsICk7XG5cblx0XHRjb25zdCB1bmlmb3JtcyA9IG1hdGVyaWFsLnVuaWZvcm1zO1xuXG5cdFx0dW5pZm9ybXNbICdlbnZNYXAnIF0udmFsdWUgPSB0ZXh0dXJlO1xuXG5cdFx0Y29uc3Qgc2l6ZSA9IHRoaXMuX2N1YmVTaXplO1xuXG5cdFx0X3NldFZpZXdwb3J0KCBjdWJlVVZSZW5kZXJUYXJnZXQsIDAsIDAsIDMgKiBzaXplLCAyICogc2l6ZSApO1xuXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcblx0XHRyZW5kZXJlci5yZW5kZXIoIG1lc2gsIF9mbGF0Q2FtZXJhICk7XG5cblx0fVxuXG5cdF9hcHBseVBNUkVNKCBjdWJlVVZSZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuXHRcdGNvbnN0IGF1dG9DbGVhciA9IHJlbmRlcmVyLmF1dG9DbGVhcjtcblx0XHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBmYWxzZTtcblx0XHRjb25zdCBuID0gdGhpcy5fbG9kUGxhbmVzLmxlbmd0aDtcblxuXHRcdGZvciAoIGxldCBpID0gMTsgaSA8IG47IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHNpZ21hID0gTWF0aC5zcXJ0KCB0aGlzLl9zaWdtYXNbIGkgXSAqIHRoaXMuX3NpZ21hc1sgaSBdIC0gdGhpcy5fc2lnbWFzWyBpIC0gMSBdICogdGhpcy5fc2lnbWFzWyBpIC0gMSBdICk7XG5cblx0XHRcdGNvbnN0IHBvbGVBeGlzID0gX2F4aXNEaXJlY3Rpb25zWyAoIG4gLSBpIC0gMSApICUgX2F4aXNEaXJlY3Rpb25zLmxlbmd0aCBdO1xuXG5cdFx0XHR0aGlzLl9ibHVyKCBjdWJlVVZSZW5kZXJUYXJnZXQsIGkgLSAxLCBpLCBzaWdtYSwgcG9sZUF4aXMgKTtcblxuXHRcdH1cblxuXHRcdHJlbmRlcmVyLmF1dG9DbGVhciA9IGF1dG9DbGVhcjtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRoaXMgaXMgYSB0d28tcGFzcyBHYXVzc2lhbiBibHVyIGZvciBhIGN1YmVtYXAuIE5vcm1hbGx5IHRoaXMgaXMgZG9uZVxuXHQgKiB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHksIGJ1dCB0aGlzIGJyZWFrcyBkb3duIG9uIGEgY3ViZS4gSGVyZSB3ZSBhcHBseVxuXHQgKiB0aGUgYmx1ciBsYXRpdHVkaW5hbGx5IChhcm91bmQgdGhlIHBvbGVzKSwgYW5kIHRoZW4gbG9uZ2l0dWRpbmFsbHkgKHRvd2FyZHNcblx0ICogdGhlIHBvbGVzKSB0byBhcHByb3hpbWF0ZSB0aGUgb3J0aG9nb25hbGx5LXNlcGFyYWJsZSBibHVyLiBJdCBpcyBsZWFzdFxuXHQgKiBhY2N1cmF0ZSBhdCB0aGUgcG9sZXMsIGJ1dCBzdGlsbCBkb2VzIGEgZGVjZW50IGpvYi5cblx0ICpcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gY3ViZVVWUmVuZGVyVGFyZ2V0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsb2RJblxuXHQgKiBAcGFyYW0ge251bWJlcn0gbG9kT3V0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzaWdtYVxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IFtwb2xlQXhpc11cblx0ICovXG5cdF9ibHVyKCBjdWJlVVZSZW5kZXJUYXJnZXQsIGxvZEluLCBsb2RPdXQsIHNpZ21hLCBwb2xlQXhpcyApIHtcblxuXHRcdGNvbnN0IHBpbmdQb25nUmVuZGVyVGFyZ2V0ID0gdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQ7XG5cblx0XHR0aGlzLl9oYWxmQmx1cihcblx0XHRcdGN1YmVVVlJlbmRlclRhcmdldCxcblx0XHRcdHBpbmdQb25nUmVuZGVyVGFyZ2V0LFxuXHRcdFx0bG9kSW4sXG5cdFx0XHRsb2RPdXQsXG5cdFx0XHRzaWdtYSxcblx0XHRcdCdsYXRpdHVkaW5hbCcsXG5cdFx0XHRwb2xlQXhpcyApO1xuXG5cdFx0dGhpcy5faGFsZkJsdXIoXG5cdFx0XHRwaW5nUG9uZ1JlbmRlclRhcmdldCxcblx0XHRcdGN1YmVVVlJlbmRlclRhcmdldCxcblx0XHRcdGxvZE91dCxcblx0XHRcdGxvZE91dCxcblx0XHRcdHNpZ21hLFxuXHRcdFx0J2xvbmdpdHVkaW5hbCcsXG5cdFx0XHRwb2xlQXhpcyApO1xuXG5cdH1cblxuXHRfaGFsZkJsdXIoIHRhcmdldEluLCB0YXJnZXRPdXQsIGxvZEluLCBsb2RPdXQsIHNpZ21hUmFkaWFucywgZGlyZWN0aW9uLCBwb2xlQXhpcyApIHtcblxuXHRcdGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG5cdFx0Y29uc3QgYmx1ck1hdGVyaWFsID0gdGhpcy5fYmx1ck1hdGVyaWFsO1xuXG5cdFx0aWYgKCBkaXJlY3Rpb24gIT09ICdsYXRpdHVkaW5hbCcgJiYgZGlyZWN0aW9uICE9PSAnbG9uZ2l0dWRpbmFsJyApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0J2JsdXIgZGlyZWN0aW9uIG11c3QgYmUgZWl0aGVyIGxhdGl0dWRpbmFsIG9yIGxvbmdpdHVkaW5hbCEnICk7XG5cblx0XHR9XG5cblx0XHQvLyBOdW1iZXIgb2Ygc3RhbmRhcmQgZGV2aWF0aW9ucyBhdCB3aGljaCB0byBjdXQgb2ZmIHRoZSBkaXNjcmV0ZSBhcHByb3hpbWF0aW9uLlxuXHRcdGNvbnN0IFNUQU5EQVJEX0RFVklBVElPTlMgPSAzO1xuXG5cdFx0Y29uc3QgYmx1ck1lc2ggPSBuZXcgTWVzaCggdGhpcy5fbG9kUGxhbmVzWyBsb2RPdXQgXSwgYmx1ck1hdGVyaWFsICk7XG5cdFx0Y29uc3QgYmx1clVuaWZvcm1zID0gYmx1ck1hdGVyaWFsLnVuaWZvcm1zO1xuXG5cdFx0Y29uc3QgcGl4ZWxzID0gdGhpcy5fc2l6ZUxvZHNbIGxvZEluIF0gLSAxO1xuXHRcdGNvbnN0IHJhZGlhbnNQZXJQaXhlbCA9IGlzRmluaXRlKCBzaWdtYVJhZGlhbnMgKSA/IE1hdGguUEkgLyAoIDIgKiBwaXhlbHMgKSA6IDIgKiBNYXRoLlBJIC8gKCAyICogTUFYX1NBTVBMRVMgLSAxICk7XG5cdFx0Y29uc3Qgc2lnbWFQaXhlbHMgPSBzaWdtYVJhZGlhbnMgLyByYWRpYW5zUGVyUGl4ZWw7XG5cdFx0Y29uc3Qgc2FtcGxlcyA9IGlzRmluaXRlKCBzaWdtYVJhZGlhbnMgKSA/IDEgKyBNYXRoLmZsb29yKCBTVEFOREFSRF9ERVZJQVRJT05TICogc2lnbWFQaXhlbHMgKSA6IE1BWF9TQU1QTEVTO1xuXG5cdFx0aWYgKCBzYW1wbGVzID4gTUFYX1NBTVBMRVMgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggYHNpZ21hUmFkaWFucywgJHtcblx0XHRcdFx0c2lnbWFSYWRpYW5zfSwgaXMgdG9vIGxhcmdlIGFuZCB3aWxsIGNsaXAsIGFzIGl0IHJlcXVlc3RlZCAke1xuXHRcdFx0XHRzYW1wbGVzfSBzYW1wbGVzIHdoZW4gdGhlIG1heGltdW0gaXMgc2V0IHRvICR7TUFYX1NBTVBMRVN9YCApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgd2VpZ2h0cyA9IFtdO1xuXHRcdGxldCBzdW0gPSAwO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgTUFYX1NBTVBMRVM7ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IHggPSBpIC8gc2lnbWFQaXhlbHM7XG5cdFx0XHRjb25zdCB3ZWlnaHQgPSBNYXRoLmV4cCggLSB4ICogeCAvIDIgKTtcblx0XHRcdHdlaWdodHMucHVzaCggd2VpZ2h0ICk7XG5cblx0XHRcdGlmICggaSA9PT0gMCApIHtcblxuXHRcdFx0XHRzdW0gKz0gd2VpZ2h0O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBpIDwgc2FtcGxlcyApIHtcblxuXHRcdFx0XHRzdW0gKz0gMiAqIHdlaWdodDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgd2VpZ2h0cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHdlaWdodHNbIGkgXSA9IHdlaWdodHNbIGkgXSAvIHN1bTtcblxuXHRcdH1cblxuXHRcdGJsdXJVbmlmb3Jtc1sgJ2Vudk1hcCcgXS52YWx1ZSA9IHRhcmdldEluLnRleHR1cmU7XG5cdFx0Ymx1clVuaWZvcm1zWyAnc2FtcGxlcycgXS52YWx1ZSA9IHNhbXBsZXM7XG5cdFx0Ymx1clVuaWZvcm1zWyAnd2VpZ2h0cycgXS52YWx1ZSA9IHdlaWdodHM7XG5cdFx0Ymx1clVuaWZvcm1zWyAnbGF0aXR1ZGluYWwnIF0udmFsdWUgPSBkaXJlY3Rpb24gPT09ICdsYXRpdHVkaW5hbCc7XG5cblx0XHRpZiAoIHBvbGVBeGlzICkge1xuXG5cdFx0XHRibHVyVW5pZm9ybXNbICdwb2xlQXhpcycgXS52YWx1ZSA9IHBvbGVBeGlzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgeyBfbG9kTWF4IH0gPSB0aGlzO1xuXHRcdGJsdXJVbmlmb3Jtc1sgJ2RUaGV0YScgXS52YWx1ZSA9IHJhZGlhbnNQZXJQaXhlbDtcblx0XHRibHVyVW5pZm9ybXNbICdtaXBJbnQnIF0udmFsdWUgPSBfbG9kTWF4IC0gbG9kSW47XG5cblx0XHRjb25zdCBvdXRwdXRTaXplID0gdGhpcy5fc2l6ZUxvZHNbIGxvZE91dCBdO1xuXHRcdGNvbnN0IHggPSAzICogb3V0cHV0U2l6ZSAqICggbG9kT3V0ID4gX2xvZE1heCAtIExPRF9NSU4gPyBsb2RPdXQgLSBfbG9kTWF4ICsgTE9EX01JTiA6IDAgKTtcblx0XHRjb25zdCB5ID0gNCAqICggdGhpcy5fY3ViZVNpemUgLSBvdXRwdXRTaXplICk7XG5cblx0XHRfc2V0Vmlld3BvcnQoIHRhcmdldE91dCwgeCwgeSwgMyAqIG91dHB1dFNpemUsIDIgKiBvdXRwdXRTaXplICk7XG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCB0YXJnZXRPdXQgKTtcblx0XHRyZW5kZXJlci5yZW5kZXIoIGJsdXJNZXNoLCBfZmxhdENhbWVyYSApO1xuXG5cdH1cblxufVxuXG5cblxuZnVuY3Rpb24gX2NyZWF0ZVBsYW5lcyggbG9kTWF4ICkge1xuXG5cdGNvbnN0IGxvZFBsYW5lcyA9IFtdO1xuXHRjb25zdCBzaXplTG9kcyA9IFtdO1xuXHRjb25zdCBzaWdtYXMgPSBbXTtcblxuXHRsZXQgbG9kID0gbG9kTWF4O1xuXG5cdGNvbnN0IHRvdGFsTG9kcyA9IGxvZE1heCAtIExPRF9NSU4gKyAxICsgRVhUUkFfTE9EX1NJR01BLmxlbmd0aDtcblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0b3RhbExvZHM7IGkgKysgKSB7XG5cblx0XHRjb25zdCBzaXplTG9kID0gTWF0aC5wb3coIDIsIGxvZCApO1xuXHRcdHNpemVMb2RzLnB1c2goIHNpemVMb2QgKTtcblx0XHRsZXQgc2lnbWEgPSAxLjAgLyBzaXplTG9kO1xuXG5cdFx0aWYgKCBpID4gbG9kTWF4IC0gTE9EX01JTiApIHtcblxuXHRcdFx0c2lnbWEgPSBFWFRSQV9MT0RfU0lHTUFbIGkgLSBsb2RNYXggKyBMT0RfTUlOIC0gMSBdO1xuXG5cdFx0fSBlbHNlIGlmICggaSA9PT0gMCApIHtcblxuXHRcdFx0c2lnbWEgPSAwO1xuXG5cdFx0fVxuXG5cdFx0c2lnbWFzLnB1c2goIHNpZ21hICk7XG5cblx0XHRjb25zdCB0ZXhlbFNpemUgPSAxLjAgLyAoIHNpemVMb2QgLSAyICk7XG5cdFx0Y29uc3QgbWluID0gLSB0ZXhlbFNpemU7XG5cdFx0Y29uc3QgbWF4ID0gMSArIHRleGVsU2l6ZTtcblx0XHRjb25zdCB1djEgPSBbIG1pbiwgbWluLCBtYXgsIG1pbiwgbWF4LCBtYXgsIG1pbiwgbWluLCBtYXgsIG1heCwgbWluLCBtYXggXTtcblxuXHRcdGNvbnN0IGN1YmVGYWNlcyA9IDY7XG5cdFx0Y29uc3QgdmVydGljZXMgPSA2O1xuXHRcdGNvbnN0IHBvc2l0aW9uU2l6ZSA9IDM7XG5cdFx0Y29uc3QgdXZTaXplID0gMjtcblx0XHRjb25zdCBmYWNlSW5kZXhTaXplID0gMTtcblxuXHRcdGNvbnN0IHBvc2l0aW9uID0gbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb25TaXplICogdmVydGljZXMgKiBjdWJlRmFjZXMgKTtcblx0XHRjb25zdCB1diA9IG5ldyBGbG9hdDMyQXJyYXkoIHV2U2l6ZSAqIHZlcnRpY2VzICogY3ViZUZhY2VzICk7XG5cdFx0Y29uc3QgZmFjZUluZGV4ID0gbmV3IEZsb2F0MzJBcnJheSggZmFjZUluZGV4U2l6ZSAqIHZlcnRpY2VzICogY3ViZUZhY2VzICk7XG5cblx0XHRmb3IgKCBsZXQgZmFjZSA9IDA7IGZhY2UgPCBjdWJlRmFjZXM7IGZhY2UgKysgKSB7XG5cblx0XHRcdGNvbnN0IHggPSAoIGZhY2UgJSAzICkgKiAyIC8gMyAtIDE7XG5cdFx0XHRjb25zdCB5ID0gZmFjZSA+IDIgPyAwIDogLSAxO1xuXHRcdFx0Y29uc3QgY29vcmRpbmF0ZXMgPSBbXG5cdFx0XHRcdHgsIHksIDAsXG5cdFx0XHRcdHggKyAyIC8gMywgeSwgMCxcblx0XHRcdFx0eCArIDIgLyAzLCB5ICsgMSwgMCxcblx0XHRcdFx0eCwgeSwgMCxcblx0XHRcdFx0eCArIDIgLyAzLCB5ICsgMSwgMCxcblx0XHRcdFx0eCwgeSArIDEsIDBcblx0XHRcdF07XG5cdFx0XHRwb3NpdGlvbi5zZXQoIGNvb3JkaW5hdGVzLCBwb3NpdGlvblNpemUgKiB2ZXJ0aWNlcyAqIGZhY2UgKTtcblx0XHRcdHV2LnNldCggdXYxLCB1dlNpemUgKiB2ZXJ0aWNlcyAqIGZhY2UgKTtcblx0XHRcdGNvbnN0IGZpbGwgPSBbIGZhY2UsIGZhY2UsIGZhY2UsIGZhY2UsIGZhY2UsIGZhY2UgXTtcblx0XHRcdGZhY2VJbmRleC5zZXQoIGZpbGwsIGZhY2VJbmRleFNpemUgKiB2ZXJ0aWNlcyAqIGZhY2UgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBsYW5lcyA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdHBsYW5lcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBwb3NpdGlvblNpemUgKSApO1xuXHRcdHBsYW5lcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHV2LCB1dlNpemUgKSApO1xuXHRcdHBsYW5lcy5zZXRBdHRyaWJ1dGUoICdmYWNlSW5kZXgnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBmYWNlSW5kZXgsIGZhY2VJbmRleFNpemUgKSApO1xuXHRcdGxvZFBsYW5lcy5wdXNoKCBwbGFuZXMgKTtcblxuXHRcdGlmICggbG9kID4gTE9EX01JTiApIHtcblxuXHRcdFx0bG9kIC0tO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4geyBsb2RQbGFuZXMsIHNpemVMb2RzLCBzaWdtYXMgfTtcblxufVxuXG5mdW5jdGlvbiBfY3JlYXRlUmVuZGVyVGFyZ2V0KCB3aWR0aCwgaGVpZ2h0LCBwYXJhbXMgKSB7XG5cblx0Y29uc3QgY3ViZVVWUmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KCB3aWR0aCwgaGVpZ2h0LCBwYXJhbXMgKTtcblx0Y3ViZVVWUmVuZGVyVGFyZ2V0LnRleHR1cmUubWFwcGluZyA9IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nO1xuXHRjdWJlVVZSZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gJ1BNUkVNLmN1YmVVdic7XG5cdGN1YmVVVlJlbmRlclRhcmdldC5zY2lzc29yVGVzdCA9IHRydWU7XG5cdHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XG5cbn1cblxuZnVuY3Rpb24gX3NldFZpZXdwb3J0KCB0YXJnZXQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0dGFyZ2V0LnZpZXdwb3J0LnNldCggeCwgeSwgd2lkdGgsIGhlaWdodCApO1xuXHR0YXJnZXQuc2Npc3Nvci5zZXQoIHgsIHksIHdpZHRoLCBoZWlnaHQgKTtcblxufVxuXG5mdW5jdGlvbiBfZ2V0Qmx1clNoYWRlciggbG9kTWF4LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdGNvbnN0IHdlaWdodHMgPSBuZXcgRmxvYXQzMkFycmF5KCBNQVhfU0FNUExFUyApO1xuXHRjb25zdCBwb2xlQXhpcyA9IG5ldyBWZWN0b3IzKCAwLCAxLCAwICk7XG5cdGNvbnN0IHNoYWRlck1hdGVyaWFsID0gbmV3IFNoYWRlck1hdGVyaWFsKCB7XG5cblx0XHRuYW1lOiAnU3BoZXJpY2FsR2F1c3NpYW5CbHVyJyxcblxuXHRcdGRlZmluZXM6IHtcblx0XHRcdCduJzogTUFYX1NBTVBMRVMsXG5cdFx0XHQnQ1VCRVVWX1RFWEVMX1dJRFRIJzogMS4wIC8gd2lkdGgsXG5cdFx0XHQnQ1VCRVVWX1RFWEVMX0hFSUdIVCc6IDEuMCAvIGhlaWdodCxcblx0XHRcdCdDVUJFVVZfTUFYX01JUCc6IGAke2xvZE1heH0uMGAsXG5cdFx0fSxcblxuXHRcdHVuaWZvcm1zOiB7XG5cdFx0XHQnZW52TWFwJzogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0J3NhbXBsZXMnOiB7IHZhbHVlOiAxIH0sXG5cdFx0XHQnd2VpZ2h0cyc6IHsgdmFsdWU6IHdlaWdodHMgfSxcblx0XHRcdCdsYXRpdHVkaW5hbCc6IHsgdmFsdWU6IGZhbHNlIH0sXG5cdFx0XHQnZFRoZXRhJzogeyB2YWx1ZTogMCB9LFxuXHRcdFx0J21pcEludCc6IHsgdmFsdWU6IDAgfSxcblx0XHRcdCdwb2xlQXhpcyc6IHsgdmFsdWU6IHBvbGVBeGlzIH1cblx0XHR9LFxuXG5cdFx0dmVydGV4U2hhZGVyOiBfZ2V0Q29tbW9uVmVydGV4U2hhZGVyKCksXG5cblx0XHRmcmFnbWVudFNoYWRlcjogLyogZ2xzbCAqL2BcblxuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cdFx0XHRwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG5cblx0XHRcdHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xuXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XG5cdFx0XHR1bmlmb3JtIGludCBzYW1wbGVzO1xuXHRcdFx0dW5pZm9ybSBmbG9hdCB3ZWlnaHRzWyBuIF07XG5cdFx0XHR1bmlmb3JtIGJvb2wgbGF0aXR1ZGluYWw7XG5cdFx0XHR1bmlmb3JtIGZsb2F0IGRUaGV0YTtcblx0XHRcdHVuaWZvcm0gZmxvYXQgbWlwSW50O1xuXHRcdFx0dW5pZm9ybSB2ZWMzIHBvbGVBeGlzO1xuXG5cdFx0XHQjZGVmaW5lIEVOVk1BUF9UWVBFX0NVQkVfVVZcblx0XHRcdCNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XG5cblx0XHRcdHZlYzMgZ2V0U2FtcGxlKCBmbG9hdCB0aGV0YSwgdmVjMyBheGlzICkge1xuXG5cdFx0XHRcdGZsb2F0IGNvc1RoZXRhID0gY29zKCB0aGV0YSApO1xuXHRcdFx0XHQvLyBSb2RyaWd1ZXMnIGF4aXMtYW5nbGUgcm90YXRpb25cblx0XHRcdFx0dmVjMyBzYW1wbGVEaXJlY3Rpb24gPSB2T3V0cHV0RGlyZWN0aW9uICogY29zVGhldGFcblx0XHRcdFx0XHQrIGNyb3NzKCBheGlzLCB2T3V0cHV0RGlyZWN0aW9uICkgKiBzaW4oIHRoZXRhIClcblx0XHRcdFx0XHQrIGF4aXMgKiBkb3QoIGF4aXMsIHZPdXRwdXREaXJlY3Rpb24gKSAqICggMS4wIC0gY29zVGhldGEgKTtcblxuXHRcdFx0XHRyZXR1cm4gYmlsaW5lYXJDdWJlVVYoIGVudk1hcCwgc2FtcGxlRGlyZWN0aW9uLCBtaXBJbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2b2lkIG1haW4oKSB7XG5cblx0XHRcdFx0dmVjMyBheGlzID0gbGF0aXR1ZGluYWwgPyBwb2xlQXhpcyA6IGNyb3NzKCBwb2xlQXhpcywgdk91dHB1dERpcmVjdGlvbiApO1xuXG5cdFx0XHRcdGlmICggYWxsKCBlcXVhbCggYXhpcywgdmVjMyggMC4wICkgKSApICkge1xuXG5cdFx0XHRcdFx0YXhpcyA9IHZlYzMoIHZPdXRwdXREaXJlY3Rpb24ueiwgMC4wLCAtIHZPdXRwdXREaXJlY3Rpb24ueCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRheGlzID0gbm9ybWFsaXplKCBheGlzICk7XG5cblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7XG5cdFx0XHRcdGdsX0ZyYWdDb2xvci5yZ2IgKz0gd2VpZ2h0c1sgMCBdICogZ2V0U2FtcGxlKCAwLjAsIGF4aXMgKTtcblxuXHRcdFx0XHRmb3IgKCBpbnQgaSA9IDE7IGkgPCBuOyBpKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGkgPj0gc2FtcGxlcyApIHtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmbG9hdCB0aGV0YSA9IGRUaGV0YSAqIGZsb2F0KCBpICk7XG5cdFx0XHRcdFx0Z2xfRnJhZ0NvbG9yLnJnYiArPSB3ZWlnaHRzWyBpIF0gKiBnZXRTYW1wbGUoIC0xLjAgKiB0aGV0YSwgYXhpcyApO1xuXHRcdFx0XHRcdGdsX0ZyYWdDb2xvci5yZ2IgKz0gd2VpZ2h0c1sgaSBdICogZ2V0U2FtcGxlKCB0aGV0YSwgYXhpcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdGAsXG5cblx0XHRibGVuZGluZzogTm9CbGVuZGluZyxcblx0XHRkZXB0aFRlc3Q6IGZhbHNlLFxuXHRcdGRlcHRoV3JpdGU6IGZhbHNlXG5cblx0fSApO1xuXG5cdHJldHVybiBzaGFkZXJNYXRlcmlhbDtcblxufVxuXG5mdW5jdGlvbiBfZ2V0RXF1aXJlY3RNYXRlcmlhbCgpIHtcblxuXHRyZXR1cm4gbmV3IFNoYWRlck1hdGVyaWFsKCB7XG5cblx0XHRuYW1lOiAnRXF1aXJlY3Rhbmd1bGFyVG9DdWJlVVYnLFxuXG5cdFx0dW5pZm9ybXM6IHtcblx0XHRcdCdlbnZNYXAnOiB7IHZhbHVlOiBudWxsIH1cblx0XHR9LFxuXG5cdFx0dmVydGV4U2hhZGVyOiBfZ2V0Q29tbW9uVmVydGV4U2hhZGVyKCksXG5cblx0XHRmcmFnbWVudFNoYWRlcjogLyogZ2xzbCAqL2BcblxuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cdFx0XHRwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG5cblx0XHRcdHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xuXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XG5cblx0XHRcdCNpbmNsdWRlIDxjb21tb24+XG5cblx0XHRcdHZvaWQgbWFpbigpIHtcblxuXHRcdFx0XHR2ZWMzIG91dHB1dERpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdk91dHB1dERpcmVjdGlvbiApO1xuXHRcdFx0XHR2ZWMyIHV2ID0gZXF1aXJlY3RVdiggb3V0cHV0RGlyZWN0aW9uICk7XG5cblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdGV4dHVyZTJEICggZW52TWFwLCB1diApLnJnYiwgMS4wICk7XG5cblx0XHRcdH1cblx0XHRgLFxuXG5cdFx0YmxlbmRpbmc6IE5vQmxlbmRpbmcsXG5cdFx0ZGVwdGhUZXN0OiBmYWxzZSxcblx0XHRkZXB0aFdyaXRlOiBmYWxzZVxuXG5cdH0gKTtcblxufVxuXG5mdW5jdGlvbiBfZ2V0Q3ViZW1hcE1hdGVyaWFsKCkge1xuXG5cdHJldHVybiBuZXcgU2hhZGVyTWF0ZXJpYWwoIHtcblxuXHRcdG5hbWU6ICdDdWJlbWFwVG9DdWJlVVYnLFxuXG5cdFx0dW5pZm9ybXM6IHtcblx0XHRcdCdlbnZNYXAnOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0XHQnZmxpcEVudk1hcCc6IHsgdmFsdWU6IC0gMSB9XG5cdFx0fSxcblxuXHRcdHZlcnRleFNoYWRlcjogX2dldENvbW1vblZlcnRleFNoYWRlcigpLFxuXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IC8qIGdsc2wgKi9gXG5cblx0XHRcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgaW50O1xuXG5cdFx0XHR1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7XG5cblx0XHRcdHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xuXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcblxuXHRcdFx0dm9pZCBtYWluKCkge1xuXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHZlYzMoIGZsaXBFbnZNYXAgKiB2T3V0cHV0RGlyZWN0aW9uLngsIHZPdXRwdXREaXJlY3Rpb24ueXogKSApO1xuXG5cdFx0XHR9XG5cdFx0YCxcblxuXHRcdGJsZW5kaW5nOiBOb0JsZW5kaW5nLFxuXHRcdGRlcHRoVGVzdDogZmFsc2UsXG5cdFx0ZGVwdGhXcml0ZTogZmFsc2VcblxuXHR9ICk7XG5cbn1cblxuZnVuY3Rpb24gX2dldENvbW1vblZlcnRleFNoYWRlcigpIHtcblxuXHRyZXR1cm4gLyogZ2xzbCAqL2BcblxuXHRcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXHRcdHByZWNpc2lvbiBtZWRpdW1wIGludDtcblxuXHRcdGF0dHJpYnV0ZSBmbG9hdCBmYWNlSW5kZXg7XG5cblx0XHR2YXJ5aW5nIHZlYzMgdk91dHB1dERpcmVjdGlvbjtcblxuXHRcdC8vIFJIIGNvb3JkaW5hdGUgc3lzdGVtOyBQTVJFTSBmYWNlLWluZGV4aW5nIGNvbnZlbnRpb25cblx0XHR2ZWMzIGdldERpcmVjdGlvbiggdmVjMiB1diwgZmxvYXQgZmFjZSApIHtcblxuXHRcdFx0dXYgPSAyLjAgKiB1diAtIDEuMDtcblxuXHRcdFx0dmVjMyBkaXJlY3Rpb24gPSB2ZWMzKCB1diwgMS4wICk7XG5cblx0XHRcdGlmICggZmFjZSA9PSAwLjAgKSB7XG5cblx0XHRcdFx0ZGlyZWN0aW9uID0gZGlyZWN0aW9uLnp5eDsgLy8gKCAxLCB2LCB1ICkgcG9zIHhcblxuXHRcdFx0fSBlbHNlIGlmICggZmFjZSA9PSAxLjAgKSB7XG5cblx0XHRcdFx0ZGlyZWN0aW9uID0gZGlyZWN0aW9uLnh6eTtcblx0XHRcdFx0ZGlyZWN0aW9uLnh6ICo9IC0xLjA7IC8vICggLXUsIDEsIC12ICkgcG9zIHlcblxuXHRcdFx0fSBlbHNlIGlmICggZmFjZSA9PSAyLjAgKSB7XG5cblx0XHRcdFx0ZGlyZWN0aW9uLnggKj0gLTEuMDsgLy8gKCAtdSwgdiwgMSApIHBvcyB6XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMy4wICkge1xuXG5cdFx0XHRcdGRpcmVjdGlvbiA9IGRpcmVjdGlvbi56eXg7XG5cdFx0XHRcdGRpcmVjdGlvbi54eiAqPSAtMS4wOyAvLyAoIC0xLCB2LCAtdSApIG5lZyB4XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgPT0gNC4wICkge1xuXG5cdFx0XHRcdGRpcmVjdGlvbiA9IGRpcmVjdGlvbi54enk7XG5cdFx0XHRcdGRpcmVjdGlvbi54eSAqPSAtMS4wOyAvLyAoIC11LCAtMSwgdiApIG5lZyB5XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgPT0gNS4wICkge1xuXG5cdFx0XHRcdGRpcmVjdGlvbi56ICo9IC0xLjA7IC8vICggdSwgdiwgLTEgKSBuZWcgelxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkaXJlY3Rpb247XG5cblx0XHR9XG5cblx0XHR2b2lkIG1haW4oKSB7XG5cblx0XHRcdHZPdXRwdXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oIHV2LCBmYWNlSW5kZXggKTtcblx0XHRcdGdsX1Bvc2l0aW9uID0gdmVjNCggcG9zaXRpb24sIDEuMCApO1xuXG5cdFx0fVxuXHRgO1xuXG59XG5cbmZ1bmN0aW9uIFdlYkdMQ3ViZVVWTWFwcyggcmVuZGVyZXIgKSB7XG5cblx0bGV0IGN1YmVVVm1hcHMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdGxldCBwbXJlbUdlbmVyYXRvciA9IG51bGw7XG5cblx0ZnVuY3Rpb24gZ2V0KCB0ZXh0dXJlICkge1xuXG5cdFx0aWYgKCB0ZXh0dXJlICYmIHRleHR1cmUuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRjb25zdCBtYXBwaW5nID0gdGV4dHVyZS5tYXBwaW5nO1xuXG5cdFx0XHRjb25zdCBpc0VxdWlyZWN0TWFwID0gKCBtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyB8fCBtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyApO1xuXHRcdFx0Y29uc3QgaXNDdWJlTWFwID0gKCBtYXBwaW5nID09PSBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgfHwgbWFwcGluZyA9PT0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nICk7XG5cblx0XHRcdC8vIGVxdWlyZWN0L2N1YmUgbWFwIHRvIGN1YmVVViBjb252ZXJzaW9uXG5cblx0XHRcdGlmICggaXNFcXVpcmVjdE1hcCB8fCBpc0N1YmVNYXAgKSB7XG5cblx0XHRcdFx0bGV0IHJlbmRlclRhcmdldCA9IGN1YmVVVm1hcHMuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRcdFx0Y29uc3QgY3VycmVudFBNUkVNVmVyc2lvbiA9IHJlbmRlclRhcmdldCAhPT0gdW5kZWZpbmVkID8gcmVuZGVyVGFyZ2V0LnRleHR1cmUucG1yZW1WZXJzaW9uIDogMDtcblxuXHRcdFx0XHRpZiAoIHRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlICYmIHRleHR1cmUucG1yZW1WZXJzaW9uICE9PSBjdXJyZW50UE1SRU1WZXJzaW9uICkge1xuXG5cdFx0XHRcdFx0aWYgKCBwbXJlbUdlbmVyYXRvciA9PT0gbnVsbCApIHBtcmVtR2VuZXJhdG9yID0gbmV3IFBNUkVNR2VuZXJhdG9yKCByZW5kZXJlciApO1xuXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0ID0gaXNFcXVpcmVjdE1hcCA/IHBtcmVtR2VuZXJhdG9yLmZyb21FcXVpcmVjdGFuZ3VsYXIoIHRleHR1cmUsIHJlbmRlclRhcmdldCApIDogcG1yZW1HZW5lcmF0b3IuZnJvbUN1YmVtYXAoIHRleHR1cmUsIHJlbmRlclRhcmdldCApO1xuXHRcdFx0XHRcdHJlbmRlclRhcmdldC50ZXh0dXJlLnBtcmVtVmVyc2lvbiA9IHRleHR1cmUucG1yZW1WZXJzaW9uO1xuXG5cdFx0XHRcdFx0Y3ViZVVWbWFwcy5zZXQoIHRleHR1cmUsIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHJlbmRlclRhcmdldC50ZXh0dXJlO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XG5cblx0XHRcdFx0XHRcdGlmICggKCBpc0VxdWlyZWN0TWFwICYmIGltYWdlICYmIGltYWdlLmhlaWdodCA+IDAgKSB8fCAoIGlzQ3ViZU1hcCAmJiBpbWFnZSAmJiBpc0N1YmVUZXh0dXJlQ29tcGxldGUoIGltYWdlICkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHBtcmVtR2VuZXJhdG9yID09PSBudWxsICkgcG1yZW1HZW5lcmF0b3IgPSBuZXcgUE1SRU1HZW5lcmF0b3IoIHJlbmRlcmVyICk7XG5cblx0XHRcdFx0XHRcdFx0cmVuZGVyVGFyZ2V0ID0gaXNFcXVpcmVjdE1hcCA/IHBtcmVtR2VuZXJhdG9yLmZyb21FcXVpcmVjdGFuZ3VsYXIoIHRleHR1cmUgKSA6IHBtcmVtR2VuZXJhdG9yLmZyb21DdWJlbWFwKCB0ZXh0dXJlICk7XG5cdFx0XHRcdFx0XHRcdHJlbmRlclRhcmdldC50ZXh0dXJlLnBtcmVtVmVyc2lvbiA9IHRleHR1cmUucG1yZW1WZXJzaW9uO1xuXG5cdFx0XHRcdFx0XHRcdGN1YmVVVm1hcHMuc2V0KCB0ZXh0dXJlLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiByZW5kZXJUYXJnZXQudGV4dHVyZTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpbWFnZSBub3QgeWV0IHJlYWR5LiB0cnkgdGhlIGNvbnZlcnNpb24gbmV4dCBmcmFtZVxuXG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaXNDdWJlVGV4dHVyZUNvbXBsZXRlKCBpbWFnZSApIHtcblxuXHRcdGxldCBjb3VudCA9IDA7XG5cdFx0Y29uc3QgbGVuZ3RoID0gNjtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0aWYgKCBpbWFnZVsgaSBdICE9PSB1bmRlZmluZWQgKSBjb3VudCArKztcblxuXHRcdH1cblxuXHRcdHJldHVybiBjb3VudCA9PT0gbGVuZ3RoO1xuXG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uVGV4dHVyZURpc3Bvc2UoIGV2ZW50ICkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZSA9IGV2ZW50LnRhcmdldDtcblxuXHRcdHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cblx0XHRjb25zdCBjdWJlbWFwVVYgPSBjdWJlVVZtYXBzLmdldCggdGV4dHVyZSApO1xuXG5cdFx0aWYgKCBjdWJlbWFwVVYgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y3ViZVVWbWFwcy5kZWxldGUoIHRleHR1cmUgKTtcblx0XHRcdGN1YmVtYXBVVi5kaXNwb3NlKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cblx0XHRjdWJlVVZtYXBzID0gbmV3IFdlYWtNYXAoKTtcblxuXHRcdGlmICggcG1yZW1HZW5lcmF0b3IgIT09IG51bGwgKSB7XG5cblx0XHRcdHBtcmVtR2VuZXJhdG9yLmRpc3Bvc2UoKTtcblx0XHRcdHBtcmVtR2VuZXJhdG9yID0gbnVsbDtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGdldCxcblx0XHRkaXNwb3NlOiBkaXNwb3NlXG5cdH07XG5cbn1cblxuZnVuY3Rpb24gV2ViR0xFeHRlbnNpb25zKCBnbCApIHtcblxuXHRjb25zdCBleHRlbnNpb25zID0ge307XG5cblx0ZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKCBuYW1lICkge1xuXG5cdFx0aWYgKCBleHRlbnNpb25zWyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cmV0dXJuIGV4dGVuc2lvbnNbIG5hbWUgXTtcblxuXHRcdH1cblxuXHRcdGxldCBleHRlbnNpb247XG5cblx0XHRzd2l0Y2ggKCBuYW1lICkge1xuXG5cdFx0XHRjYXNlICdXRUJHTF9kZXB0aF90ZXh0dXJlJzpcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVwdGhfdGV4dHVyZScgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfZGVwdGhfdGV4dHVyZScgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfZGVwdGhfdGV4dHVyZScgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyc6XG5cdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Yyc6XG5cdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ01PWl9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnOlxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggbmFtZSApO1xuXG5cdFx0fVxuXG5cdFx0ZXh0ZW5zaW9uc1sgbmFtZSBdID0gZXh0ZW5zaW9uO1xuXG5cdFx0cmV0dXJuIGV4dGVuc2lvbjtcblxuXHR9XG5cblx0cmV0dXJuIHtcblxuXHRcdGhhczogZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdFx0XHRyZXR1cm4gZ2V0RXh0ZW5zaW9uKCBuYW1lICkgIT09IG51bGw7XG5cblx0XHR9LFxuXG5cdFx0aW5pdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRnZXRFeHRlbnNpb24oICdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JyApO1xuXHRcdFx0Z2V0RXh0ZW5zaW9uKCAnV0VCR0xfY2xpcF9jdWxsX2Rpc3RhbmNlJyApO1xuXHRcdFx0Z2V0RXh0ZW5zaW9uKCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApO1xuXHRcdFx0Z2V0RXh0ZW5zaW9uKCAnRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0JyApO1xuXHRcdFx0Z2V0RXh0ZW5zaW9uKCAnV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlJyApO1xuXHRcdFx0Z2V0RXh0ZW5zaW9uKCAnV0VCR0xfcmVuZGVyX3NoYXJlZF9leHBvbmVudCcgKTtcblxuXHRcdH0sXG5cblx0XHRnZXQ6IGZ1bmN0aW9uICggbmFtZSApIHtcblxuXHRcdFx0Y29uc3QgZXh0ZW5zaW9uID0gZ2V0RXh0ZW5zaW9uKCBuYW1lICk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG5cdFx0XHRcdHdhcm5PbmNlKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIG5hbWUgKyAnIGV4dGVuc2lvbiBub3Qgc3VwcG9ydGVkLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXh0ZW5zaW9uO1xuXG5cdFx0fVxuXG5cdH07XG5cbn1cblxuZnVuY3Rpb24gV2ViR0xHZW9tZXRyaWVzKCBnbCwgYXR0cmlidXRlcywgaW5mbywgYmluZGluZ1N0YXRlcyApIHtcblxuXHRjb25zdCBnZW9tZXRyaWVzID0ge307XG5cdGNvbnN0IHdpcmVmcmFtZUF0dHJpYnV0ZXMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdGZ1bmN0aW9uIG9uR2VvbWV0cnlEaXNwb3NlKCBldmVudCApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0aWYgKCBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0YXR0cmlidXRlcy5yZW1vdmUoIGdlb21ldHJ5LmluZGV4ICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGF0dHJpYnV0ZXMucmVtb3ZlKCBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBuYW1lIF0gKTtcblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcblxuXHRcdGRlbGV0ZSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0Y29uc3QgYXR0cmlidXRlID0gd2lyZWZyYW1lQXR0cmlidXRlcy5nZXQoIGdlb21ldHJ5ICk7XG5cblx0XHRpZiAoIGF0dHJpYnV0ZSApIHtcblxuXHRcdFx0YXR0cmlidXRlcy5yZW1vdmUoIGF0dHJpYnV0ZSApO1xuXHRcdFx0d2lyZWZyYW1lQXR0cmlidXRlcy5kZWxldGUoIGdlb21ldHJ5ICk7XG5cblx0XHR9XG5cblx0XHRiaW5kaW5nU3RhdGVzLnJlbGVhc2VTdGF0ZXNPZkdlb21ldHJ5KCBnZW9tZXRyeSApO1xuXG5cdFx0aWYgKCBnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID09PSB0cnVlICkge1xuXG5cdFx0XHRkZWxldGUgZ2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQ7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0aW5mby5tZW1vcnkuZ2VvbWV0cmllcyAtLTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0KCBvYmplY3QsIGdlb21ldHJ5ICkge1xuXG5cdFx0aWYgKCBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdID09PSB0cnVlICkgcmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0Z2VvbWV0cnkuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSApO1xuXG5cdFx0Z2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXSA9IHRydWU7XG5cblx0XHRpbmZvLm1lbW9yeS5nZW9tZXRyaWVzICsrO1xuXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGUoIGdlb21ldHJ5ICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnlBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblxuXHRcdC8vIFVwZGF0aW5nIGluZGV4IGJ1ZmZlciBpbiBWQU8gbm93LiBTZWUgV2ViR0xCaW5kaW5nU3RhdGVzLlxuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBnZW9tZXRyeUF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGF0dHJpYnV0ZXMudXBkYXRlKCBnZW9tZXRyeUF0dHJpYnV0ZXNbIG5hbWUgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZVdpcmVmcmFtZUF0dHJpYnV0ZSggZ2VvbWV0cnkgKSB7XG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cblx0XHRjb25zdCBnZW9tZXRyeUluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0Y29uc3QgZ2VvbWV0cnlQb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0bGV0IHZlcnNpb24gPSAwO1xuXG5cdFx0aWYgKCBnZW9tZXRyeUluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCBhcnJheSA9IGdlb21ldHJ5SW5kZXguYXJyYXk7XG5cdFx0XHR2ZXJzaW9uID0gZ2VvbWV0cnlJbmRleC52ZXJzaW9uO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0Y29uc3QgYSA9IGFycmF5WyBpICsgMCBdO1xuXHRcdFx0XHRjb25zdCBiID0gYXJyYXlbIGkgKyAxIF07XG5cdFx0XHRcdGNvbnN0IGMgPSBhcnJheVsgaSArIDIgXTtcblxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGIsIGMsIGMsIGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggZ2VvbWV0cnlQb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBhcnJheSA9IGdlb21ldHJ5UG9zaXRpb24uYXJyYXk7XG5cdFx0XHR2ZXJzaW9uID0gZ2VvbWV0cnlQb3NpdGlvbi52ZXJzaW9uO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSAoIGFycmF5Lmxlbmd0aCAvIDMgKSAtIDE7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0Y29uc3QgYSA9IGkgKyAwO1xuXHRcdFx0XHRjb25zdCBiID0gaSArIDE7XG5cdFx0XHRcdGNvbnN0IGMgPSBpICsgMjtcblxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGIsIGMsIGMsIGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYXR0cmlidXRlID0gbmV3ICggYXJyYXlOZWVkc1VpbnQzMiggaW5kaWNlcyApID8gVWludDMyQnVmZmVyQXR0cmlidXRlIDogVWludDE2QnVmZmVyQXR0cmlidXRlICkoIGluZGljZXMsIDEgKTtcblx0XHRhdHRyaWJ1dGUudmVyc2lvbiA9IHZlcnNpb247XG5cblx0XHQvLyBVcGRhdGluZyBpbmRleCBidWZmZXIgaW4gVkFPIG5vdy4gU2VlIFdlYkdMQmluZGluZ1N0YXRlc1xuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IHByZXZpb3VzQXR0cmlidXRlID0gd2lyZWZyYW1lQXR0cmlidXRlcy5nZXQoIGdlb21ldHJ5ICk7XG5cblx0XHRpZiAoIHByZXZpb3VzQXR0cmlidXRlICkgYXR0cmlidXRlcy5yZW1vdmUoIHByZXZpb3VzQXR0cmlidXRlICk7XG5cblx0XHQvL1xuXG5cdFx0d2lyZWZyYW1lQXR0cmlidXRlcy5zZXQoIGdlb21ldHJ5LCBhdHRyaWJ1dGUgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0V2lyZWZyYW1lQXR0cmlidXRlKCBnZW9tZXRyeSApIHtcblxuXHRcdGNvbnN0IGN1cnJlbnRBdHRyaWJ1dGUgPSB3aXJlZnJhbWVBdHRyaWJ1dGVzLmdldCggZ2VvbWV0cnkgKTtcblxuXHRcdGlmICggY3VycmVudEF0dHJpYnV0ZSApIHtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnlJbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5SW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Ly8gaWYgdGhlIGF0dHJpYnV0ZSBpcyBvYnNvbGV0ZSwgY3JlYXRlIGEgbmV3IG9uZVxuXG5cdFx0XHRcdGlmICggY3VycmVudEF0dHJpYnV0ZS52ZXJzaW9uIDwgZ2VvbWV0cnlJbmRleC52ZXJzaW9uICkge1xuXG5cdFx0XHRcdFx0dXBkYXRlV2lyZWZyYW1lQXR0cmlidXRlKCBnZW9tZXRyeSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dXBkYXRlV2lyZWZyYW1lQXR0cmlidXRlKCBnZW9tZXRyeSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHdpcmVmcmFtZUF0dHJpYnV0ZXMuZ2V0KCBnZW9tZXRyeSApO1xuXG5cdH1cblxuXHRyZXR1cm4ge1xuXG5cdFx0Z2V0OiBnZXQsXG5cdFx0dXBkYXRlOiB1cGRhdGUsXG5cblx0XHRnZXRXaXJlZnJhbWVBdHRyaWJ1dGU6IGdldFdpcmVmcmFtZUF0dHJpYnV0ZVxuXG5cdH07XG5cbn1cblxuZnVuY3Rpb24gV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIoIGdsLCBleHRlbnNpb25zLCBpbmZvICkge1xuXG5cdGxldCBtb2RlO1xuXG5cdGZ1bmN0aW9uIHNldE1vZGUoIHZhbHVlICkge1xuXG5cdFx0bW9kZSA9IHZhbHVlO1xuXG5cdH1cblxuXHRsZXQgdHlwZSwgYnl0ZXNQZXJFbGVtZW50O1xuXG5cdGZ1bmN0aW9uIHNldEluZGV4KCB2YWx1ZSApIHtcblxuXHRcdHR5cGUgPSB2YWx1ZS50eXBlO1xuXHRcdGJ5dGVzUGVyRWxlbWVudCA9IHZhbHVlLmJ5dGVzUGVyRWxlbWVudDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XG5cblx0XHRnbC5kcmF3RWxlbWVudHMoIG1vZGUsIGNvdW50LCB0eXBlLCBzdGFydCAqIGJ5dGVzUGVyRWxlbWVudCApO1xuXG5cdFx0aW5mby51cGRhdGUoIGNvdW50LCBtb2RlLCAxICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyggc3RhcnQsIGNvdW50LCBwcmltY291bnQgKSB7XG5cblx0XHRpZiAoIHByaW1jb3VudCA9PT0gMCApIHJldHVybjtcblxuXHRcdGdsLmRyYXdFbGVtZW50c0luc3RhbmNlZCggbW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogYnl0ZXNQZXJFbGVtZW50LCBwcmltY291bnQgKTtcblxuXHRcdGluZm8udXBkYXRlKCBjb3VudCwgbW9kZSwgcHJpbWNvdW50ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlck11bHRpRHJhdyggc3RhcnRzLCBjb3VudHMsIGRyYXdDb3VudCApIHtcblxuXHRcdGlmICggZHJhd0NvdW50ID09PSAwICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9tdWx0aV9kcmF3JyApO1xuXHRcdGV4dGVuc2lvbi5tdWx0aURyYXdFbGVtZW50c1dFQkdMKCBtb2RlLCBjb3VudHMsIDAsIHR5cGUsIHN0YXJ0cywgMCwgZHJhd0NvdW50ICk7XG5cblx0XHRsZXQgZWxlbWVudENvdW50ID0gMDtcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBkcmF3Q291bnQ7IGkgKysgKSB7XG5cblx0XHRcdGVsZW1lbnRDb3VudCArPSBjb3VudHNbIGkgXTtcblxuXHRcdH1cblxuXHRcdGluZm8udXBkYXRlKCBlbGVtZW50Q291bnQsIG1vZGUsIDEgKTtcblxuXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXJNdWx0aURyYXdJbnN0YW5jZXMoIHN0YXJ0cywgY291bnRzLCBkcmF3Q291bnQsIHByaW1jb3VudCApIHtcblxuXHRcdGlmICggZHJhd0NvdW50ID09PSAwICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9tdWx0aV9kcmF3JyApO1xuXG5cdFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHN0YXJ0cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0cmVuZGVySW5zdGFuY2VzKCBzdGFydHNbIGkgXSAvIGJ5dGVzUGVyRWxlbWVudCwgY291bnRzWyBpIF0sIHByaW1jb3VudFsgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGV4dGVuc2lvbi5tdWx0aURyYXdFbGVtZW50c0luc3RhbmNlZFdFQkdMKCBtb2RlLCBjb3VudHMsIDAsIHR5cGUsIHN0YXJ0cywgMCwgcHJpbWNvdW50LCAwLCBkcmF3Q291bnQgKTtcblxuXHRcdFx0bGV0IGVsZW1lbnRDb3VudCA9IDA7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBkcmF3Q291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0ZWxlbWVudENvdW50ICs9IGNvdW50c1sgaSBdICogcHJpbWNvdW50WyBpIF07XG5cblx0XHRcdH1cblxuXHRcdFx0aW5mby51cGRhdGUoIGVsZW1lbnRDb3VudCwgbW9kZSwgMSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvL1xuXG5cdHRoaXMuc2V0TW9kZSA9IHNldE1vZGU7XG5cdHRoaXMuc2V0SW5kZXggPSBzZXRJbmRleDtcblx0dGhpcy5yZW5kZXIgPSByZW5kZXI7XG5cdHRoaXMucmVuZGVySW5zdGFuY2VzID0gcmVuZGVySW5zdGFuY2VzO1xuXHR0aGlzLnJlbmRlck11bHRpRHJhdyA9IHJlbmRlck11bHRpRHJhdztcblx0dGhpcy5yZW5kZXJNdWx0aURyYXdJbnN0YW5jZXMgPSByZW5kZXJNdWx0aURyYXdJbnN0YW5jZXM7XG5cbn1cblxuZnVuY3Rpb24gV2ViR0xJbmZvKCBnbCApIHtcblxuXHRjb25zdCBtZW1vcnkgPSB7XG5cdFx0Z2VvbWV0cmllczogMCxcblx0XHR0ZXh0dXJlczogMFxuXHR9O1xuXG5cdGNvbnN0IHJlbmRlciA9IHtcblx0XHRmcmFtZTogMCxcblx0XHRjYWxsczogMCxcblx0XHR0cmlhbmdsZXM6IDAsXG5cdFx0cG9pbnRzOiAwLFxuXHRcdGxpbmVzOiAwXG5cdH07XG5cblx0ZnVuY3Rpb24gdXBkYXRlKCBjb3VudCwgbW9kZSwgaW5zdGFuY2VDb3VudCApIHtcblxuXHRcdHJlbmRlci5jYWxscyArKztcblxuXHRcdHN3aXRjaCAoIG1vZGUgKSB7XG5cblx0XHRcdGNhc2UgZ2wuVFJJQU5HTEVTOlxuXHRcdFx0XHRyZW5kZXIudHJpYW5nbGVzICs9IGluc3RhbmNlQ291bnQgKiAoIGNvdW50IC8gMyApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBnbC5MSU5FUzpcblx0XHRcdFx0cmVuZGVyLmxpbmVzICs9IGluc3RhbmNlQ291bnQgKiAoIGNvdW50IC8gMiApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBnbC5MSU5FX1NUUklQOlxuXHRcdFx0XHRyZW5kZXIubGluZXMgKz0gaW5zdGFuY2VDb3VudCAqICggY291bnQgLSAxICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIGdsLkxJTkVfTE9PUDpcblx0XHRcdFx0cmVuZGVyLmxpbmVzICs9IGluc3RhbmNlQ291bnQgKiBjb3VudDtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgZ2wuUE9JTlRTOlxuXHRcdFx0XHRyZW5kZXIucG9pbnRzICs9IGluc3RhbmNlQ291bnQgKiBjb3VudDtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTEluZm86IFVua25vd24gZHJhdyBtb2RlOicsIG1vZGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlc2V0KCkge1xuXG5cdFx0cmVuZGVyLmNhbGxzID0gMDtcblx0XHRyZW5kZXIudHJpYW5nbGVzID0gMDtcblx0XHRyZW5kZXIucG9pbnRzID0gMDtcblx0XHRyZW5kZXIubGluZXMgPSAwO1xuXG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdG1lbW9yeTogbWVtb3J5LFxuXHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdHByb2dyYW1zOiBudWxsLFxuXHRcdGF1dG9SZXNldDogdHJ1ZSxcblx0XHRyZXNldDogcmVzZXQsXG5cdFx0dXBkYXRlOiB1cGRhdGVcblx0fTtcblxufVxuXG5mdW5jdGlvbiBXZWJHTE1vcnBodGFyZ2V0cyggZ2wsIGNhcGFiaWxpdGllcywgdGV4dHVyZXMgKSB7XG5cblx0Y29uc3QgbW9ycGhUZXh0dXJlcyA9IG5ldyBXZWFrTWFwKCk7XG5cdGNvbnN0IG1vcnBoID0gbmV3IFZlY3RvcjQoKTtcblxuXHRmdW5jdGlvbiB1cGRhdGUoIG9iamVjdCwgZ2VvbWV0cnksIHByb2dyYW0gKSB7XG5cblx0XHRjb25zdCBvYmplY3RJbmZsdWVuY2VzID0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuXHRcdC8vIHRoZSBmb2xsb3dpbmcgZW5jb2RlcyBtb3JwaCB0YXJnZXRzIGludG8gYW4gYXJyYXkgb2YgZGF0YSB0ZXh0dXJlcy4gRWFjaCBsYXllciByZXByZXNlbnRzIGEgc2luZ2xlIG1vcnBoIHRhcmdldC5cblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uIHx8IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgfHwgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLmNvbG9yO1xuXHRcdGNvbnN0IG1vcnBoVGFyZ2V0c0NvdW50ID0gKCBtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkgPyBtb3JwaEF0dHJpYnV0ZS5sZW5ndGggOiAwO1xuXG5cdFx0bGV0IGVudHJ5ID0gbW9ycGhUZXh0dXJlcy5nZXQoIGdlb21ldHJ5ICk7XG5cblx0XHRpZiAoIGVudHJ5ID09PSB1bmRlZmluZWQgfHwgZW50cnkuY291bnQgIT09IG1vcnBoVGFyZ2V0c0NvdW50ICkge1xuXG5cdFx0XHRpZiAoIGVudHJ5ICE9PSB1bmRlZmluZWQgKSBlbnRyeS50ZXh0dXJlLmRpc3Bvc2UoKTtcblxuXHRcdFx0Y29uc3QgaGFzTW9ycGhQb3NpdGlvbiA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkO1xuXHRcdFx0Y29uc3QgaGFzTW9ycGhOb3JtYWxzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCAhPT0gdW5kZWZpbmVkO1xuXHRcdFx0Y29uc3QgaGFzTW9ycGhDb2xvcnMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZDtcblxuXHRcdFx0Y29uc3QgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uIHx8IFtdO1xuXHRcdFx0Y29uc3QgbW9ycGhOb3JtYWxzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCB8fCBbXTtcblx0XHRcdGNvbnN0IG1vcnBoQ29sb3JzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLmNvbG9yIHx8IFtdO1xuXG5cdFx0XHRsZXQgdmVydGV4RGF0YUNvdW50ID0gMDtcblxuXHRcdFx0aWYgKCBoYXNNb3JwaFBvc2l0aW9uID09PSB0cnVlICkgdmVydGV4RGF0YUNvdW50ID0gMTtcblx0XHRcdGlmICggaGFzTW9ycGhOb3JtYWxzID09PSB0cnVlICkgdmVydGV4RGF0YUNvdW50ID0gMjtcblx0XHRcdGlmICggaGFzTW9ycGhDb2xvcnMgPT09IHRydWUgKSB2ZXJ0ZXhEYXRhQ291bnQgPSAzO1xuXG5cdFx0XHRsZXQgd2lkdGggPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50ICogdmVydGV4RGF0YUNvdW50O1xuXHRcdFx0bGV0IGhlaWdodCA9IDE7XG5cblx0XHRcdGlmICggd2lkdGggPiBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZVNpemUgKSB7XG5cblx0XHRcdFx0aGVpZ2h0ID0gTWF0aC5jZWlsKCB3aWR0aCAvIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZSApO1xuXHRcdFx0XHR3aWR0aCA9IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KCB3aWR0aCAqIGhlaWdodCAqIDQgKiBtb3JwaFRhcmdldHNDb3VudCApO1xuXG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gbmV3IERhdGFBcnJheVRleHR1cmUoIGJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgbW9ycGhUYXJnZXRzQ291bnQgKTtcblx0XHRcdHRleHR1cmUudHlwZSA9IEZsb2F0VHlwZTtcblx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHQvLyBmaWxsIGJ1ZmZlclxuXG5cdFx0XHRjb25zdCB2ZXJ0ZXhEYXRhU3RyaWRlID0gdmVydGV4RGF0YUNvdW50ICogNDtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbW9ycGhUYXJnZXRzQ291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGkgXTtcblx0XHRcdFx0Y29uc3QgbW9ycGhOb3JtYWwgPSBtb3JwaE5vcm1hbHNbIGkgXTtcblx0XHRcdFx0Y29uc3QgbW9ycGhDb2xvciA9IG1vcnBoQ29sb3JzWyBpIF07XG5cblx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gd2lkdGggKiBoZWlnaHQgKiA0ICogaTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBtb3JwaFRhcmdldC5jb3VudDsgaiArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHN0cmlkZSA9IGogKiB2ZXJ0ZXhEYXRhU3RyaWRlO1xuXG5cdFx0XHRcdFx0aWYgKCBoYXNNb3JwaFBvc2l0aW9uID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRtb3JwaC5mcm9tQnVmZmVyQXR0cmlidXRlKCBtb3JwaFRhcmdldCwgaiApO1xuXG5cdFx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDAgXSA9IG1vcnBoLng7XG5cdFx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDEgXSA9IG1vcnBoLnk7XG5cdFx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDIgXSA9IG1vcnBoLno7XG5cdFx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDMgXSA9IDA7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGhhc01vcnBoTm9ybWFscyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0bW9ycGguZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhOb3JtYWwsIGogKTtcblxuXHRcdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyA0IF0gPSBtb3JwaC54O1xuXHRcdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyA1IF0gPSBtb3JwaC55O1xuXHRcdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyA2IF0gPSBtb3JwaC56O1xuXHRcdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyA3IF0gPSAwO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBoYXNNb3JwaENvbG9ycyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0bW9ycGguZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhDb2xvciwgaiApO1xuXG5cdFx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDggXSA9IG1vcnBoLng7XG5cdFx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDkgXSA9IG1vcnBoLnk7XG5cdFx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDEwIF0gPSBtb3JwaC56O1xuXHRcdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyAxMSBdID0gKCBtb3JwaENvbG9yLml0ZW1TaXplID09PSA0ICkgPyBtb3JwaC53IDogMTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0ZW50cnkgPSB7XG5cdFx0XHRcdGNvdW50OiBtb3JwaFRhcmdldHNDb3VudCxcblx0XHRcdFx0dGV4dHVyZTogdGV4dHVyZSxcblx0XHRcdFx0c2l6ZTogbmV3IFZlY3RvcjIoIHdpZHRoLCBoZWlnaHQgKVxuXHRcdFx0fTtcblxuXHRcdFx0bW9ycGhUZXh0dXJlcy5zZXQoIGdlb21ldHJ5LCBlbnRyeSApO1xuXG5cdFx0XHRmdW5jdGlvbiBkaXNwb3NlVGV4dHVyZSgpIHtcblxuXHRcdFx0XHR0ZXh0dXJlLmRpc3Bvc2UoKTtcblxuXHRcdFx0XHRtb3JwaFRleHR1cmVzLmRlbGV0ZSggZ2VvbWV0cnkgKTtcblxuXHRcdFx0XHRnZW9tZXRyeS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIGRpc3Bvc2VUZXh0dXJlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBkaXNwb3NlVGV4dHVyZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblx0XHRpZiAoIG9iamVjdC5pc0luc3RhbmNlZE1lc2ggPT09IHRydWUgJiYgb2JqZWN0Lm1vcnBoVGV4dHVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0cHJvZ3JhbS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKCBnbCwgJ21vcnBoVGV4dHVyZScsIG9iamVjdC5tb3JwaFRleHR1cmUsIHRleHR1cmVzICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRsZXQgbW9ycGhJbmZsdWVuY2VzU3VtID0gMDtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgb2JqZWN0SW5mbHVlbmNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0bW9ycGhJbmZsdWVuY2VzU3VtICs9IG9iamVjdEluZmx1ZW5jZXNbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtb3JwaEJhc2VJbmZsdWVuY2UgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA/IDEgOiAxIC0gbW9ycGhJbmZsdWVuY2VzU3VtO1xuXG5cblx0XHRcdHByb2dyYW0uZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZSggZ2wsICdtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2UnLCBtb3JwaEJhc2VJbmZsdWVuY2UgKTtcblx0XHRcdHByb2dyYW0uZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZSggZ2wsICdtb3JwaFRhcmdldEluZmx1ZW5jZXMnLCBvYmplY3RJbmZsdWVuY2VzICk7XG5cblx0XHR9XG5cblx0XHRwcm9ncmFtLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoIGdsLCAnbW9ycGhUYXJnZXRzVGV4dHVyZScsIGVudHJ5LnRleHR1cmUsIHRleHR1cmVzICk7XG5cdFx0cHJvZ3JhbS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKCBnbCwgJ21vcnBoVGFyZ2V0c1RleHR1cmVTaXplJywgZW50cnkuc2l6ZSApO1xuXG5cdH1cblxuXHRyZXR1cm4ge1xuXG5cdFx0dXBkYXRlOiB1cGRhdGVcblxuXHR9O1xuXG59XG5cbmZ1bmN0aW9uIFdlYkdMT2JqZWN0cyggZ2wsIGdlb21ldHJpZXMsIGF0dHJpYnV0ZXMsIGluZm8gKSB7XG5cblx0bGV0IHVwZGF0ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cblx0ZnVuY3Rpb24gdXBkYXRlKCBvYmplY3QgKSB7XG5cblx0XHRjb25zdCBmcmFtZSA9IGluZm8ucmVuZGVyLmZyYW1lO1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyaWVzLmdldCggb2JqZWN0LCBnZW9tZXRyeSApO1xuXG5cdFx0Ly8gVXBkYXRlIG9uY2UgcGVyIGZyYW1lXG5cblx0XHRpZiAoIHVwZGF0ZU1hcC5nZXQoIGJ1ZmZlcmdlb21ldHJ5ICkgIT09IGZyYW1lICkge1xuXG5cdFx0XHRnZW9tZXRyaWVzLnVwZGF0ZSggYnVmZmVyZ2VvbWV0cnkgKTtcblxuXHRcdFx0dXBkYXRlTWFwLnNldCggYnVmZmVyZ2VvbWV0cnksIGZyYW1lICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9iamVjdC5pc0luc3RhbmNlZE1lc2ggKSB7XG5cblx0XHRcdGlmICggb2JqZWN0Lmhhc0V2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25JbnN0YW5jZWRNZXNoRGlzcG9zZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRvYmplY3QuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkluc3RhbmNlZE1lc2hEaXNwb3NlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB1cGRhdGVNYXAuZ2V0KCBvYmplY3QgKSAhPT0gZnJhbWUgKSB7XG5cblx0XHRcdFx0YXR0cmlidXRlcy51cGRhdGUoIG9iamVjdC5pbnN0YW5jZU1hdHJpeCwgZ2wuQVJSQVlfQlVGRkVSICk7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QuaW5zdGFuY2VDb2xvciAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdGF0dHJpYnV0ZXMudXBkYXRlKCBvYmplY3QuaW5zdGFuY2VDb2xvciwgZ2wuQVJSQVlfQlVGRkVSICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHVwZGF0ZU1hcC5zZXQoIG9iamVjdCwgZnJhbWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QuaXNTa2lubmVkTWVzaCApIHtcblxuXHRcdFx0Y29uc3Qgc2tlbGV0b24gPSBvYmplY3Quc2tlbGV0b247XG5cblx0XHRcdGlmICggdXBkYXRlTWFwLmdldCggc2tlbGV0b24gKSAhPT0gZnJhbWUgKSB7XG5cblx0XHRcdFx0c2tlbGV0b24udXBkYXRlKCk7XG5cblx0XHRcdFx0dXBkYXRlTWFwLnNldCggc2tlbGV0b24sIGZyYW1lICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBidWZmZXJnZW9tZXRyeTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcblxuXHRcdHVwZGF0ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uSW5zdGFuY2VkTWVzaERpc3Bvc2UoIGV2ZW50ICkge1xuXG5cdFx0Y29uc3QgaW5zdGFuY2VkTWVzaCA9IGV2ZW50LnRhcmdldDtcblxuXHRcdGluc3RhbmNlZE1lc2gucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkluc3RhbmNlZE1lc2hEaXNwb3NlICk7XG5cblx0XHRhdHRyaWJ1dGVzLnJlbW92ZSggaW5zdGFuY2VkTWVzaC5pbnN0YW5jZU1hdHJpeCApO1xuXG5cdFx0aWYgKCBpbnN0YW5jZWRNZXNoLmluc3RhbmNlQ29sb3IgIT09IG51bGwgKSBhdHRyaWJ1dGVzLnJlbW92ZSggaW5zdGFuY2VkTWVzaC5pbnN0YW5jZUNvbG9yICk7XG5cblx0fVxuXG5cdHJldHVybiB7XG5cblx0XHR1cGRhdGU6IHVwZGF0ZSxcblx0XHRkaXNwb3NlOiBkaXNwb3NlXG5cblx0fTtcblxufVxuXG4vKipcbiAqIFVuaWZvcm1zIG9mIGEgcHJvZ3JhbS5cbiAqIFRob3NlIGZvcm0gYSB0cmVlIHN0cnVjdHVyZSB3aXRoIGEgc3BlY2lhbCB0b3AtbGV2ZWwgY29udGFpbmVyIGZvciB0aGUgcm9vdCxcbiAqIHdoaWNoIHlvdSBnZXQgYnkgY2FsbGluZyAnbmV3IFdlYkdMVW5pZm9ybXMoIGdsLCBwcm9ncmFtICknLlxuICpcbiAqXG4gKiBQcm9wZXJ0aWVzIG9mIGlubmVyIG5vZGVzIGluY2x1ZGluZyB0aGUgdG9wLWxldmVsIGNvbnRhaW5lcjpcbiAqXG4gKiAuc2VxIC0gYXJyYXkgb2YgbmVzdGVkIHVuaWZvcm1zXG4gKiAubWFwIC0gbmVzdGVkIHVuaWZvcm1zIGJ5IG5hbWVcbiAqXG4gKlxuICogTWV0aG9kcyBvZiBhbGwgbm9kZXMgZXhjZXB0IHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyOlxuICpcbiAqIC5zZXRWYWx1ZSggZ2wsIHZhbHVlLCBbdGV4dHVyZXNdIClcbiAqXG4gKiBcdFx0dXBsb2FkcyBhIHVuaWZvcm0gdmFsdWUocylcbiAqICBcdHRoZSAndGV4dHVyZXMnIHBhcmFtZXRlciBpcyBuZWVkZWQgZm9yIHNhbXBsZXIgdW5pZm9ybXNcbiAqXG4gKlxuICogU3RhdGljIG1ldGhvZHMgb2YgdGhlIHRvcC1sZXZlbCBjb250YWluZXIgKHRleHR1cmVzIGZhY3Rvcml6YXRpb25zKTpcbiAqXG4gKiAudXBsb2FkKCBnbCwgc2VxLCB2YWx1ZXMsIHRleHR1cmVzIClcbiAqXG4gKiBcdFx0c2V0cyB1bmlmb3JtcyBpbiAnc2VxJyB0byAndmFsdWVzW2lkXS52YWx1ZSdcbiAqXG4gKiAuc2VxV2l0aFZhbHVlKCBzZXEsIHZhbHVlcyApIDogZmlsdGVyZWRTZXFcbiAqXG4gKiBcdFx0ZmlsdGVycyAnc2VxJyBlbnRyaWVzIHdpdGggY29ycmVzcG9uZGluZyBlbnRyeSBpbiB2YWx1ZXNcbiAqXG4gKlxuICogTWV0aG9kcyBvZiB0aGUgdG9wLWxldmVsIGNvbnRhaW5lciAodGV4dHVyZXMgZmFjdG9yaXphdGlvbnMpOlxuICpcbiAqIC5zZXRWYWx1ZSggZ2wsIG5hbWUsIHZhbHVlLCB0ZXh0dXJlcyApXG4gKlxuICogXHRcdHNldHMgdW5pZm9ybSB3aXRoICBuYW1lICduYW1lJyB0byAndmFsdWUnXG4gKlxuICogLnNldE9wdGlvbmFsKCBnbCwgb2JqLCBwcm9wIClcbiAqXG4gKiBcdFx0bGlrZSAuc2V0IGZvciBhbiBvcHRpb25hbCBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0XG4gKlxuICovXG5cblxuY29uc3QgZW1wdHlUZXh0dXJlID0gLypAX19QVVJFX18qLyBuZXcgVGV4dHVyZSgpO1xuXG5jb25zdCBlbXB0eVNoYWRvd1RleHR1cmUgPSAvKkBfX1BVUkVfXyovIG5ldyBEZXB0aFRleHR1cmUoIDEsIDEgKTtcblxuY29uc3QgZW1wdHlBcnJheVRleHR1cmUgPSAvKkBfX1BVUkVfXyovIG5ldyBEYXRhQXJyYXlUZXh0dXJlKCk7XG5jb25zdCBlbXB0eTNkVGV4dHVyZSA9IC8qQF9fUFVSRV9fKi8gbmV3IERhdGEzRFRleHR1cmUoKTtcbmNvbnN0IGVtcHR5Q3ViZVRleHR1cmUgPSAvKkBfX1BVUkVfXyovIG5ldyBDdWJlVGV4dHVyZSgpO1xuXG4vLyAtLS0gVXRpbGl0aWVzIC0tLVxuXG4vLyBBcnJheSBDYWNoZXMgKHByb3ZpZGUgdHlwZWQgYXJyYXlzIGZvciB0ZW1wb3JhcnkgYnkgc2l6ZSlcblxuY29uc3QgYXJyYXlDYWNoZUYzMiA9IFtdO1xuY29uc3QgYXJyYXlDYWNoZUkzMiA9IFtdO1xuXG4vLyBGbG9hdDMyQXJyYXkgY2FjaGVzIHVzZWQgZm9yIHVwbG9hZGluZyBNYXRyaXggdW5pZm9ybXNcblxuY29uc3QgbWF0NGFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKTtcbmNvbnN0IG1hdDNhcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDkgKTtcbmNvbnN0IG1hdDJhcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDQgKTtcblxuLy8gRmxhdHRlbmluZyBmb3IgYXJyYXlzIG9mIHZlY3RvcnMgYW5kIG1hdHJpY2VzXG5cbmZ1bmN0aW9uIGZsYXR0ZW4oIGFycmF5LCBuQmxvY2tzLCBibG9ja1NpemUgKSB7XG5cblx0Y29uc3QgZmlyc3RFbGVtID0gYXJyYXlbIDAgXTtcblxuXHRpZiAoIGZpcnN0RWxlbSA8PSAwIHx8IGZpcnN0RWxlbSA+IDAgKSByZXR1cm4gYXJyYXk7XG5cdC8vIHVub3B0aW1pemVkOiAhIGlzTmFOKCBmaXJzdEVsZW0gKVxuXHQvLyBzZWUgaHR0cDovL2phY2tzb25kdW5zdGFuLmNvbS9hcnRpY2xlcy85ODNcblxuXHRjb25zdCBuID0gbkJsb2NrcyAqIGJsb2NrU2l6ZTtcblx0bGV0IHIgPSBhcnJheUNhY2hlRjMyWyBuIF07XG5cblx0aWYgKCByID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRyID0gbmV3IEZsb2F0MzJBcnJheSggbiApO1xuXHRcdGFycmF5Q2FjaGVGMzJbIG4gXSA9IHI7XG5cblx0fVxuXG5cdGlmICggbkJsb2NrcyAhPT0gMCApIHtcblxuXHRcdGZpcnN0RWxlbS50b0FycmF5KCByLCAwICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDEsIG9mZnNldCA9IDA7IGkgIT09IG5CbG9ja3M7ICsrIGkgKSB7XG5cblx0XHRcdG9mZnNldCArPSBibG9ja1NpemU7XG5cdFx0XHRhcnJheVsgaSBdLnRvQXJyYXkoIHIsIG9mZnNldCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gcjtcblxufVxuXG5mdW5jdGlvbiBhcnJheXNFcXVhbCggYSwgYiApIHtcblxuXHRpZiAoIGEubGVuZ3RoICE9PSBiLmxlbmd0aCApIHJldHVybiBmYWxzZTtcblxuXHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRpZiAoIGFbIGkgXSAhPT0gYlsgaSBdICkgcmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcblxufVxuXG5mdW5jdGlvbiBjb3B5QXJyYXkoIGEsIGIgKSB7XG5cblx0Zm9yICggbGV0IGkgPSAwLCBsID0gYi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0YVsgaSBdID0gYlsgaSBdO1xuXG5cdH1cblxufVxuXG4vLyBUZXh0dXJlIHVuaXQgYWxsb2NhdGlvblxuXG5mdW5jdGlvbiBhbGxvY1RleFVuaXRzKCB0ZXh0dXJlcywgbiApIHtcblxuXHRsZXQgciA9IGFycmF5Q2FjaGVJMzJbIG4gXTtcblxuXHRpZiAoIHIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdHIgPSBuZXcgSW50MzJBcnJheSggbiApO1xuXHRcdGFycmF5Q2FjaGVJMzJbIG4gXSA9IHI7XG5cblx0fVxuXG5cdGZvciAoIGxldCBpID0gMDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdHJbIGkgXSA9IHRleHR1cmVzLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtcblxuXHR9XG5cblx0cmV0dXJuIHI7XG5cbn1cblxuLy8gLS0tIFNldHRlcnMgLS0tXG5cbi8vIE5vdGU6IERlZmluaW5nIHRoZXNlIG1ldGhvZHMgZXh0ZXJuYWxseSwgYmVjYXVzZSB0aGV5IGNvbWUgaW4gYSBidW5jaFxuLy8gYW5kIHRoaXMgd2F5IHRoZWlyIG5hbWVzIG1pbmlmeS5cblxuLy8gU2luZ2xlIHNjYWxhclxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYxZiggZ2wsIHYgKSB7XG5cblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG5cdGlmICggY2FjaGVbIDAgXSA9PT0gdiApIHJldHVybjtcblxuXHRnbC51bmlmb3JtMWYoIHRoaXMuYWRkciwgdiApO1xuXG5cdGNhY2hlWyAwIF0gPSB2O1xuXG59XG5cbi8vIFNpbmdsZSBmbG9hdCB2ZWN0b3IgKGZyb20gZmxhdCBhcnJheSBvciBUSFJFRS5WZWN0b3JOKVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYyZiggZ2wsIHYgKSB7XG5cblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG5cdGlmICggdi54ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRpZiAoIGNhY2hlWyAwIF0gIT09IHYueCB8fCBjYWNoZVsgMSBdICE9PSB2LnkgKSB7XG5cblx0XHRcdGdsLnVuaWZvcm0yZiggdGhpcy5hZGRyLCB2LngsIHYueSApO1xuXG5cdFx0XHRjYWNoZVsgMCBdID0gdi54O1xuXHRcdFx0Y2FjaGVbIDEgXSA9IHYueTtcblxuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0aWYgKCBhcnJheXNFcXVhbCggY2FjaGUsIHYgKSApIHJldHVybjtcblxuXHRcdGdsLnVuaWZvcm0yZnYoIHRoaXMuYWRkciwgdiApO1xuXG5cdFx0Y29weUFycmF5KCBjYWNoZSwgdiApO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYzZiggZ2wsIHYgKSB7XG5cblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG5cdGlmICggdi54ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRpZiAoIGNhY2hlWyAwIF0gIT09IHYueCB8fCBjYWNoZVsgMSBdICE9PSB2LnkgfHwgY2FjaGVbIDIgXSAhPT0gdi56ICkge1xuXG5cdFx0XHRnbC51bmlmb3JtM2YoIHRoaXMuYWRkciwgdi54LCB2LnksIHYueiApO1xuXG5cdFx0XHRjYWNoZVsgMCBdID0gdi54O1xuXHRcdFx0Y2FjaGVbIDEgXSA9IHYueTtcblx0XHRcdGNhY2hlWyAyIF0gPSB2Lno7XG5cblx0XHR9XG5cblx0fSBlbHNlIGlmICggdi5yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRpZiAoIGNhY2hlWyAwIF0gIT09IHYuciB8fCBjYWNoZVsgMSBdICE9PSB2LmcgfHwgY2FjaGVbIDIgXSAhPT0gdi5iICkge1xuXG5cdFx0XHRnbC51bmlmb3JtM2YoIHRoaXMuYWRkciwgdi5yLCB2LmcsIHYuYiApO1xuXG5cdFx0XHRjYWNoZVsgMCBdID0gdi5yO1xuXHRcdFx0Y2FjaGVbIDEgXSA9IHYuZztcblx0XHRcdGNhY2hlWyAyIF0gPSB2LmI7XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdGlmICggYXJyYXlzRXF1YWwoIGNhY2hlLCB2ICkgKSByZXR1cm47XG5cblx0XHRnbC51bmlmb3JtM2Z2KCB0aGlzLmFkZHIsIHYgKTtcblxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHYgKTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVWNGYoIGdsLCB2ICkge1xuXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblxuXHRpZiAoIHYueCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0aWYgKCBjYWNoZVsgMCBdICE9PSB2LnggfHwgY2FjaGVbIDEgXSAhPT0gdi55IHx8IGNhY2hlWyAyIF0gIT09IHYueiB8fCBjYWNoZVsgMyBdICE9PSB2LncgKSB7XG5cblx0XHRcdGdsLnVuaWZvcm00ZiggdGhpcy5hZGRyLCB2LngsIHYueSwgdi56LCB2LncgKTtcblxuXHRcdFx0Y2FjaGVbIDAgXSA9IHYueDtcblx0XHRcdGNhY2hlWyAxIF0gPSB2Lnk7XG5cdFx0XHRjYWNoZVsgMiBdID0gdi56O1xuXHRcdFx0Y2FjaGVbIDMgXSA9IHYudztcblxuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0aWYgKCBhcnJheXNFcXVhbCggY2FjaGUsIHYgKSApIHJldHVybjtcblxuXHRcdGdsLnVuaWZvcm00ZnYoIHRoaXMuYWRkciwgdiApO1xuXG5cdFx0Y29weUFycmF5KCBjYWNoZSwgdiApO1xuXG5cdH1cblxufVxuXG4vLyBTaW5nbGUgbWF0cml4IChmcm9tIGZsYXQgYXJyYXkgb3IgVEhSRUUuTWF0cml4TilcblxuZnVuY3Rpb24gc2V0VmFsdWVNMiggZ2wsIHYgKSB7XG5cblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRjb25zdCBlbGVtZW50cyA9IHYuZWxlbWVudHM7XG5cblx0aWYgKCBlbGVtZW50cyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0aWYgKCBhcnJheXNFcXVhbCggY2FjaGUsIHYgKSApIHJldHVybjtcblxuXHRcdGdsLnVuaWZvcm1NYXRyaXgyZnYoIHRoaXMuYWRkciwgZmFsc2UsIHYgKTtcblxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHYgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0aWYgKCBhcnJheXNFcXVhbCggY2FjaGUsIGVsZW1lbnRzICkgKSByZXR1cm47XG5cblx0XHRtYXQyYXJyYXkuc2V0KCBlbGVtZW50cyApO1xuXG5cdFx0Z2wudW5pZm9ybU1hdHJpeDJmdiggdGhpcy5hZGRyLCBmYWxzZSwgbWF0MmFycmF5ICk7XG5cblx0XHRjb3B5QXJyYXkoIGNhY2hlLCBlbGVtZW50cyApO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZU0zKCBnbCwgdiApIHtcblxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdGNvbnN0IGVsZW1lbnRzID0gdi5lbGVtZW50cztcblxuXHRpZiAoIGVsZW1lbnRzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRpZiAoIGFycmF5c0VxdWFsKCBjYWNoZSwgdiApICkgcmV0dXJuO1xuXG5cdFx0Z2wudW5pZm9ybU1hdHJpeDNmdiggdGhpcy5hZGRyLCBmYWxzZSwgdiApO1xuXG5cdFx0Y29weUFycmF5KCBjYWNoZSwgdiApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRpZiAoIGFycmF5c0VxdWFsKCBjYWNoZSwgZWxlbWVudHMgKSApIHJldHVybjtcblxuXHRcdG1hdDNhcnJheS5zZXQoIGVsZW1lbnRzICk7XG5cblx0XHRnbC51bmlmb3JtTWF0cml4M2Z2KCB0aGlzLmFkZHIsIGZhbHNlLCBtYXQzYXJyYXkgKTtcblxuXHRcdGNvcHlBcnJheSggY2FjaGUsIGVsZW1lbnRzICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlTTQoIGdsLCB2ICkge1xuXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0Y29uc3QgZWxlbWVudHMgPSB2LmVsZW1lbnRzO1xuXG5cdGlmICggZWxlbWVudHMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGlmICggYXJyYXlzRXF1YWwoIGNhY2hlLCB2ICkgKSByZXR1cm47XG5cblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KCB0aGlzLmFkZHIsIGZhbHNlLCB2ICk7XG5cblx0XHRjb3B5QXJyYXkoIGNhY2hlLCB2ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdGlmICggYXJyYXlzRXF1YWwoIGNhY2hlLCBlbGVtZW50cyApICkgcmV0dXJuO1xuXG5cdFx0bWF0NGFycmF5LnNldCggZWxlbWVudHMgKTtcblxuXHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHRoaXMuYWRkciwgZmFsc2UsIG1hdDRhcnJheSApO1xuXG5cdFx0Y29weUFycmF5KCBjYWNoZSwgZWxlbWVudHMgKTtcblxuXHR9XG5cbn1cblxuLy8gU2luZ2xlIGludGVnZXIgLyBib29sZWFuXG5cbmZ1bmN0aW9uIHNldFZhbHVlVjFpKCBnbCwgdiApIHtcblxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cblx0aWYgKCBjYWNoZVsgMCBdID09PSB2ICkgcmV0dXJuO1xuXG5cdGdsLnVuaWZvcm0xaSggdGhpcy5hZGRyLCB2ICk7XG5cblx0Y2FjaGVbIDAgXSA9IHY7XG5cbn1cblxuLy8gU2luZ2xlIGludGVnZXIgLyBib29sZWFuIHZlY3RvciAoZnJvbSBmbGF0IGFycmF5IG9yIFRIUkVFLlZlY3Rvck4pXG5cbmZ1bmN0aW9uIHNldFZhbHVlVjJpKCBnbCwgdiApIHtcblxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cblx0aWYgKCB2LnggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGlmICggY2FjaGVbIDAgXSAhPT0gdi54IHx8IGNhY2hlWyAxIF0gIT09IHYueSApIHtcblxuXHRcdFx0Z2wudW5pZm9ybTJpKCB0aGlzLmFkZHIsIHYueCwgdi55ICk7XG5cblx0XHRcdGNhY2hlWyAwIF0gPSB2Lng7XG5cdFx0XHRjYWNoZVsgMSBdID0gdi55O1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRpZiAoIGFycmF5c0VxdWFsKCBjYWNoZSwgdiApICkgcmV0dXJuO1xuXG5cdFx0Z2wudW5pZm9ybTJpdiggdGhpcy5hZGRyLCB2ICk7XG5cblx0XHRjb3B5QXJyYXkoIGNhY2hlLCB2ICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlVjNpKCBnbCwgdiApIHtcblxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cblx0aWYgKCB2LnggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGlmICggY2FjaGVbIDAgXSAhPT0gdi54IHx8IGNhY2hlWyAxIF0gIT09IHYueSB8fCBjYWNoZVsgMiBdICE9PSB2LnogKSB7XG5cblx0XHRcdGdsLnVuaWZvcm0zaSggdGhpcy5hZGRyLCB2LngsIHYueSwgdi56ICk7XG5cblx0XHRcdGNhY2hlWyAwIF0gPSB2Lng7XG5cdFx0XHRjYWNoZVsgMSBdID0gdi55O1xuXHRcdFx0Y2FjaGVbIDIgXSA9IHYuejtcblxuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0aWYgKCBhcnJheXNFcXVhbCggY2FjaGUsIHYgKSApIHJldHVybjtcblxuXHRcdGdsLnVuaWZvcm0zaXYoIHRoaXMuYWRkciwgdiApO1xuXG5cdFx0Y29weUFycmF5KCBjYWNoZSwgdiApO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVY0aSggZ2wsIHYgKSB7XG5cblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG5cdGlmICggdi54ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRpZiAoIGNhY2hlWyAwIF0gIT09IHYueCB8fCBjYWNoZVsgMSBdICE9PSB2LnkgfHwgY2FjaGVbIDIgXSAhPT0gdi56IHx8IGNhY2hlWyAzIF0gIT09IHYudyApIHtcblxuXHRcdFx0Z2wudW5pZm9ybTRpKCB0aGlzLmFkZHIsIHYueCwgdi55LCB2LnosIHYudyApO1xuXG5cdFx0XHRjYWNoZVsgMCBdID0gdi54O1xuXHRcdFx0Y2FjaGVbIDEgXSA9IHYueTtcblx0XHRcdGNhY2hlWyAyIF0gPSB2Lno7XG5cdFx0XHRjYWNoZVsgMyBdID0gdi53O1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRpZiAoIGFycmF5c0VxdWFsKCBjYWNoZSwgdiApICkgcmV0dXJuO1xuXG5cdFx0Z2wudW5pZm9ybTRpdiggdGhpcy5hZGRyLCB2ICk7XG5cblx0XHRjb3B5QXJyYXkoIGNhY2hlLCB2ICk7XG5cblx0fVxuXG59XG5cbi8vIFNpbmdsZSB1bnNpZ25lZCBpbnRlZ2VyXG5cbmZ1bmN0aW9uIHNldFZhbHVlVjF1aSggZ2wsIHYgKSB7XG5cblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG5cdGlmICggY2FjaGVbIDAgXSA9PT0gdiApIHJldHVybjtcblxuXHRnbC51bmlmb3JtMXVpKCB0aGlzLmFkZHIsIHYgKTtcblxuXHRjYWNoZVsgMCBdID0gdjtcblxufVxuXG4vLyBTaW5nbGUgdW5zaWduZWQgaW50ZWdlciB2ZWN0b3IgKGZyb20gZmxhdCBhcnJheSBvciBUSFJFRS5WZWN0b3JOKVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYydWkoIGdsLCB2ICkge1xuXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblxuXHRpZiAoIHYueCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0aWYgKCBjYWNoZVsgMCBdICE9PSB2LnggfHwgY2FjaGVbIDEgXSAhPT0gdi55ICkge1xuXG5cdFx0XHRnbC51bmlmb3JtMnVpKCB0aGlzLmFkZHIsIHYueCwgdi55ICk7XG5cblx0XHRcdGNhY2hlWyAwIF0gPSB2Lng7XG5cdFx0XHRjYWNoZVsgMSBdID0gdi55O1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRpZiAoIGFycmF5c0VxdWFsKCBjYWNoZSwgdiApICkgcmV0dXJuO1xuXG5cdFx0Z2wudW5pZm9ybTJ1aXYoIHRoaXMuYWRkciwgdiApO1xuXG5cdFx0Y29weUFycmF5KCBjYWNoZSwgdiApO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYzdWkoIGdsLCB2ICkge1xuXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblxuXHRpZiAoIHYueCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0aWYgKCBjYWNoZVsgMCBdICE9PSB2LnggfHwgY2FjaGVbIDEgXSAhPT0gdi55IHx8IGNhY2hlWyAyIF0gIT09IHYueiApIHtcblxuXHRcdFx0Z2wudW5pZm9ybTN1aSggdGhpcy5hZGRyLCB2LngsIHYueSwgdi56ICk7XG5cblx0XHRcdGNhY2hlWyAwIF0gPSB2Lng7XG5cdFx0XHRjYWNoZVsgMSBdID0gdi55O1xuXHRcdFx0Y2FjaGVbIDIgXSA9IHYuejtcblxuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0aWYgKCBhcnJheXNFcXVhbCggY2FjaGUsIHYgKSApIHJldHVybjtcblxuXHRcdGdsLnVuaWZvcm0zdWl2KCB0aGlzLmFkZHIsIHYgKTtcblxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHYgKTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVWNHVpKCBnbCwgdiApIHtcblxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cblx0aWYgKCB2LnggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGlmICggY2FjaGVbIDAgXSAhPT0gdi54IHx8IGNhY2hlWyAxIF0gIT09IHYueSB8fCBjYWNoZVsgMiBdICE9PSB2LnogfHwgY2FjaGVbIDMgXSAhPT0gdi53ICkge1xuXG5cdFx0XHRnbC51bmlmb3JtNHVpKCB0aGlzLmFkZHIsIHYueCwgdi55LCB2LnosIHYudyApO1xuXG5cdFx0XHRjYWNoZVsgMCBdID0gdi54O1xuXHRcdFx0Y2FjaGVbIDEgXSA9IHYueTtcblx0XHRcdGNhY2hlWyAyIF0gPSB2Lno7XG5cdFx0XHRjYWNoZVsgMyBdID0gdi53O1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRpZiAoIGFycmF5c0VxdWFsKCBjYWNoZSwgdiApICkgcmV0dXJuO1xuXG5cdFx0Z2wudW5pZm9ybTR1aXYoIHRoaXMuYWRkciwgdiApO1xuXG5cdFx0Y29weUFycmF5KCBjYWNoZSwgdiApO1xuXG5cdH1cblxufVxuXG5cbi8vIFNpbmdsZSB0ZXh0dXJlICgyRCAvIEN1YmUpXG5cbmZ1bmN0aW9uIHNldFZhbHVlVDEoIGdsLCB2LCB0ZXh0dXJlcyApIHtcblxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdGNvbnN0IHVuaXQgPSB0ZXh0dXJlcy5hbGxvY2F0ZVRleHR1cmVVbml0KCk7XG5cblx0aWYgKCBjYWNoZVsgMCBdICE9PSB1bml0ICkge1xuXG5cdFx0Z2wudW5pZm9ybTFpKCB0aGlzLmFkZHIsIHVuaXQgKTtcblx0XHRjYWNoZVsgMCBdID0gdW5pdDtcblxuXHR9XG5cblx0bGV0IGVtcHR5VGV4dHVyZTJEO1xuXG5cdGlmICggdGhpcy50eXBlID09PSBnbC5TQU1QTEVSXzJEX1NIQURPVyApIHtcblxuXHRcdGVtcHR5U2hhZG93VGV4dHVyZS5jb21wYXJlRnVuY3Rpb24gPSBMZXNzRXF1YWxDb21wYXJlOyAvLyAjMjg2NzBcblx0XHRlbXB0eVRleHR1cmUyRCA9IGVtcHR5U2hhZG93VGV4dHVyZTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0ZW1wdHlUZXh0dXJlMkQgPSBlbXB0eVRleHR1cmU7XG5cblx0fVxuXG5cdHRleHR1cmVzLnNldFRleHR1cmUyRCggdiB8fCBlbXB0eVRleHR1cmUyRCwgdW5pdCApO1xuXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlVDNEMSggZ2wsIHYsIHRleHR1cmVzICkge1xuXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0Y29uc3QgdW5pdCA9IHRleHR1cmVzLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtcblxuXHRpZiAoIGNhY2hlWyAwIF0gIT09IHVuaXQgKSB7XG5cblx0XHRnbC51bmlmb3JtMWkoIHRoaXMuYWRkciwgdW5pdCApO1xuXHRcdGNhY2hlWyAwIF0gPSB1bml0O1xuXG5cdH1cblxuXHR0ZXh0dXJlcy5zZXRUZXh0dXJlM0QoIHYgfHwgZW1wdHkzZFRleHR1cmUsIHVuaXQgKTtcblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVQ2KCBnbCwgdiwgdGV4dHVyZXMgKSB7XG5cblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRjb25zdCB1bml0ID0gdGV4dHVyZXMuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO1xuXG5cdGlmICggY2FjaGVbIDAgXSAhPT0gdW5pdCApIHtcblxuXHRcdGdsLnVuaWZvcm0xaSggdGhpcy5hZGRyLCB1bml0ICk7XG5cdFx0Y2FjaGVbIDAgXSA9IHVuaXQ7XG5cblx0fVxuXG5cdHRleHR1cmVzLnNldFRleHR1cmVDdWJlKCB2IHx8IGVtcHR5Q3ViZVRleHR1cmUsIHVuaXQgKTtcblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVQyREFycmF5MSggZ2wsIHYsIHRleHR1cmVzICkge1xuXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0Y29uc3QgdW5pdCA9IHRleHR1cmVzLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtcblxuXHRpZiAoIGNhY2hlWyAwIF0gIT09IHVuaXQgKSB7XG5cblx0XHRnbC51bmlmb3JtMWkoIHRoaXMuYWRkciwgdW5pdCApO1xuXHRcdGNhY2hlWyAwIF0gPSB1bml0O1xuXG5cdH1cblxuXHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkRBcnJheSggdiB8fCBlbXB0eUFycmF5VGV4dHVyZSwgdW5pdCApO1xuXG59XG5cbi8vIEhlbHBlciB0byBwaWNrIHRoZSByaWdodCBzZXR0ZXIgZm9yIHRoZSBzaW5ndWxhciBjYXNlXG5cbmZ1bmN0aW9uIGdldFNpbmd1bGFyU2V0dGVyKCB0eXBlICkge1xuXG5cdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRjYXNlIDB4MTQwNjogcmV0dXJuIHNldFZhbHVlVjFmOyAvLyBGTE9BVFxuXHRcdGNhc2UgMHg4YjUwOiByZXR1cm4gc2V0VmFsdWVWMmY7IC8vIF9WRUMyXG5cdFx0Y2FzZSAweDhiNTE6IHJldHVybiBzZXRWYWx1ZVYzZjsgLy8gX1ZFQzNcblx0XHRjYXNlIDB4OGI1MjogcmV0dXJuIHNldFZhbHVlVjRmOyAvLyBfVkVDNFxuXG5cdFx0Y2FzZSAweDhiNWE6IHJldHVybiBzZXRWYWx1ZU0yOyAvLyBfTUFUMlxuXHRcdGNhc2UgMHg4YjViOiByZXR1cm4gc2V0VmFsdWVNMzsgLy8gX01BVDNcblx0XHRjYXNlIDB4OGI1YzogcmV0dXJuIHNldFZhbHVlTTQ7IC8vIF9NQVQ0XG5cblx0XHRjYXNlIDB4MTQwNDogY2FzZSAweDhiNTY6IHJldHVybiBzZXRWYWx1ZVYxaTsgLy8gSU5ULCBCT09MXG5cdFx0Y2FzZSAweDhiNTM6IGNhc2UgMHg4YjU3OiByZXR1cm4gc2V0VmFsdWVWMmk7IC8vIF9WRUMyXG5cdFx0Y2FzZSAweDhiNTQ6IGNhc2UgMHg4YjU4OiByZXR1cm4gc2V0VmFsdWVWM2k7IC8vIF9WRUMzXG5cdFx0Y2FzZSAweDhiNTU6IGNhc2UgMHg4YjU5OiByZXR1cm4gc2V0VmFsdWVWNGk7IC8vIF9WRUM0XG5cblx0XHRjYXNlIDB4MTQwNTogcmV0dXJuIHNldFZhbHVlVjF1aTsgLy8gVUlOVFxuXHRcdGNhc2UgMHg4ZGM2OiByZXR1cm4gc2V0VmFsdWVWMnVpOyAvLyBfVkVDMlxuXHRcdGNhc2UgMHg4ZGM3OiByZXR1cm4gc2V0VmFsdWVWM3VpOyAvLyBfVkVDM1xuXHRcdGNhc2UgMHg4ZGM4OiByZXR1cm4gc2V0VmFsdWVWNHVpOyAvLyBfVkVDNFxuXG5cdFx0Y2FzZSAweDhiNWU6IC8vIFNBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGQ2NjogLy8gU0FNUExFUl9FWFRFUk5BTF9PRVNcblx0XHRjYXNlIDB4OGRjYTogLy8gSU5UX1NBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGRkMjogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGI2MjogLy8gU0FNUExFUl8yRF9TSEFET1dcblx0XHRcdHJldHVybiBzZXRWYWx1ZVQxO1xuXG5cdFx0Y2FzZSAweDhiNWY6IC8vIFNBTVBMRVJfM0Rcblx0XHRjYXNlIDB4OGRjYjogLy8gSU5UX1NBTVBMRVJfM0Rcblx0XHRjYXNlIDB4OGRkMzogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfM0Rcblx0XHRcdHJldHVybiBzZXRWYWx1ZVQzRDE7XG5cblx0XHRjYXNlIDB4OGI2MDogLy8gU0FNUExFUl9DVUJFXG5cdFx0Y2FzZSAweDhkY2M6IC8vIElOVF9TQU1QTEVSX0NVQkVcblx0XHRjYXNlIDB4OGRkNDogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfQ1VCRVxuXHRcdGNhc2UgMHg4ZGM1OiAvLyBTQU1QTEVSX0NVQkVfU0hBRE9XXG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVUNjtcblxuXHRcdGNhc2UgMHg4ZGMxOiAvLyBTQU1QTEVSXzJEX0FSUkFZXG5cdFx0Y2FzZSAweDhkY2Y6IC8vIElOVF9TQU1QTEVSXzJEX0FSUkFZXG5cdFx0Y2FzZSAweDhkZDc6IC8vIFVOU0lHTkVEX0lOVF9TQU1QTEVSXzJEX0FSUkFZXG5cdFx0Y2FzZSAweDhkYzQ6IC8vIFNBTVBMRVJfMkRfQVJSQVlfU0hBRE9XXG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVUMkRBcnJheTE7XG5cblx0fVxuXG59XG5cblxuLy8gQXJyYXkgb2Ygc2NhbGFyc1xuXG5mdW5jdGlvbiBzZXRWYWx1ZVYxZkFycmF5KCBnbCwgdiApIHtcblxuXHRnbC51bmlmb3JtMWZ2KCB0aGlzLmFkZHIsIHYgKTtcblxufVxuXG4vLyBBcnJheSBvZiB2ZWN0b3JzIChmcm9tIGZsYXQgYXJyYXkgb3IgYXJyYXkgb2YgVEhSRUUuVmVjdG9yTilcblxuZnVuY3Rpb24gc2V0VmFsdWVWMmZBcnJheSggZ2wsIHYgKSB7XG5cblx0Y29uc3QgZGF0YSA9IGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgMiApO1xuXG5cdGdsLnVuaWZvcm0yZnYoIHRoaXMuYWRkciwgZGF0YSApO1xuXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlVjNmQXJyYXkoIGdsLCB2ICkge1xuXG5cdGNvbnN0IGRhdGEgPSBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDMgKTtcblxuXHRnbC51bmlmb3JtM2Z2KCB0aGlzLmFkZHIsIGRhdGEgKTtcblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVY0ZkFycmF5KCBnbCwgdiApIHtcblxuXHRjb25zdCBkYXRhID0gZmxhdHRlbiggdiwgdGhpcy5zaXplLCA0ICk7XG5cblx0Z2wudW5pZm9ybTRmdiggdGhpcy5hZGRyLCBkYXRhICk7XG5cbn1cblxuLy8gQXJyYXkgb2YgbWF0cmljZXMgKGZyb20gZmxhdCBhcnJheSBvciBhcnJheSBvZiBUSFJFRS5NYXRyaXhOKVxuXG5mdW5jdGlvbiBzZXRWYWx1ZU0yQXJyYXkoIGdsLCB2ICkge1xuXG5cdGNvbnN0IGRhdGEgPSBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDQgKTtcblxuXHRnbC51bmlmb3JtTWF0cml4MmZ2KCB0aGlzLmFkZHIsIGZhbHNlLCBkYXRhICk7XG5cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVNM0FycmF5KCBnbCwgdiApIHtcblxuXHRjb25zdCBkYXRhID0gZmxhdHRlbiggdiwgdGhpcy5zaXplLCA5ICk7XG5cblx0Z2wudW5pZm9ybU1hdHJpeDNmdiggdGhpcy5hZGRyLCBmYWxzZSwgZGF0YSApO1xuXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlTTRBcnJheSggZ2wsIHYgKSB7XG5cblx0Y29uc3QgZGF0YSA9IGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgMTYgKTtcblxuXHRnbC51bmlmb3JtTWF0cml4NGZ2KCB0aGlzLmFkZHIsIGZhbHNlLCBkYXRhICk7XG5cbn1cblxuLy8gQXJyYXkgb2YgaW50ZWdlciAvIGJvb2xlYW5cblxuZnVuY3Rpb24gc2V0VmFsdWVWMWlBcnJheSggZ2wsIHYgKSB7XG5cblx0Z2wudW5pZm9ybTFpdiggdGhpcy5hZGRyLCB2ICk7XG5cbn1cblxuLy8gQXJyYXkgb2YgaW50ZWdlciAvIGJvb2xlYW4gdmVjdG9ycyAoZnJvbSBmbGF0IGFycmF5KVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYyaUFycmF5KCBnbCwgdiApIHtcblxuXHRnbC51bmlmb3JtMml2KCB0aGlzLmFkZHIsIHYgKTtcblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYzaUFycmF5KCBnbCwgdiApIHtcblxuXHRnbC51bmlmb3JtM2l2KCB0aGlzLmFkZHIsIHYgKTtcblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVY0aUFycmF5KCBnbCwgdiApIHtcblxuXHRnbC51bmlmb3JtNGl2KCB0aGlzLmFkZHIsIHYgKTtcblxufVxuXG4vLyBBcnJheSBvZiB1bnNpZ25lZCBpbnRlZ2VyXG5cbmZ1bmN0aW9uIHNldFZhbHVlVjF1aUFycmF5KCBnbCwgdiApIHtcblxuXHRnbC51bmlmb3JtMXVpdiggdGhpcy5hZGRyLCB2ICk7XG5cbn1cblxuLy8gQXJyYXkgb2YgdW5zaWduZWQgaW50ZWdlciB2ZWN0b3JzIChmcm9tIGZsYXQgYXJyYXkpXG5cbmZ1bmN0aW9uIHNldFZhbHVlVjJ1aUFycmF5KCBnbCwgdiApIHtcblxuXHRnbC51bmlmb3JtMnVpdiggdGhpcy5hZGRyLCB2ICk7XG5cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVWM3VpQXJyYXkoIGdsLCB2ICkge1xuXG5cdGdsLnVuaWZvcm0zdWl2KCB0aGlzLmFkZHIsIHYgKTtcblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVY0dWlBcnJheSggZ2wsIHYgKSB7XG5cblx0Z2wudW5pZm9ybTR1aXYoIHRoaXMuYWRkciwgdiApO1xuXG59XG5cblxuLy8gQXJyYXkgb2YgdGV4dHVyZXMgKDJEIC8gM0QgLyBDdWJlIC8gMkRBcnJheSlcblxuZnVuY3Rpb24gc2V0VmFsdWVUMUFycmF5KCBnbCwgdiwgdGV4dHVyZXMgKSB7XG5cblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG5cdGNvbnN0IG4gPSB2Lmxlbmd0aDtcblxuXHRjb25zdCB1bml0cyA9IGFsbG9jVGV4VW5pdHMoIHRleHR1cmVzLCBuICk7XG5cblx0aWYgKCAhIGFycmF5c0VxdWFsKCBjYWNoZSwgdW5pdHMgKSApIHtcblxuXHRcdGdsLnVuaWZvcm0xaXYoIHRoaXMuYWRkciwgdW5pdHMgKTtcblxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHVuaXRzICk7XG5cblx0fVxuXG5cdGZvciAoIGxldCBpID0gMDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdHRleHR1cmVzLnNldFRleHR1cmUyRCggdlsgaSBdIHx8IGVtcHR5VGV4dHVyZSwgdW5pdHNbIGkgXSApO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVQzREFycmF5KCBnbCwgdiwgdGV4dHVyZXMgKSB7XG5cblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG5cdGNvbnN0IG4gPSB2Lmxlbmd0aDtcblxuXHRjb25zdCB1bml0cyA9IGFsbG9jVGV4VW5pdHMoIHRleHR1cmVzLCBuICk7XG5cblx0aWYgKCAhIGFycmF5c0VxdWFsKCBjYWNoZSwgdW5pdHMgKSApIHtcblxuXHRcdGdsLnVuaWZvcm0xaXYoIHRoaXMuYWRkciwgdW5pdHMgKTtcblxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHVuaXRzICk7XG5cblx0fVxuXG5cdGZvciAoIGxldCBpID0gMDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdHRleHR1cmVzLnNldFRleHR1cmUzRCggdlsgaSBdIHx8IGVtcHR5M2RUZXh0dXJlLCB1bml0c1sgaSBdICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlVDZBcnJheSggZ2wsIHYsIHRleHR1cmVzICkge1xuXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblxuXHRjb25zdCBuID0gdi5sZW5ndGg7XG5cblx0Y29uc3QgdW5pdHMgPSBhbGxvY1RleFVuaXRzKCB0ZXh0dXJlcywgbiApO1xuXG5cdGlmICggISBhcnJheXNFcXVhbCggY2FjaGUsIHVuaXRzICkgKSB7XG5cblx0XHRnbC51bmlmb3JtMWl2KCB0aGlzLmFkZHIsIHVuaXRzICk7XG5cblx0XHRjb3B5QXJyYXkoIGNhY2hlLCB1bml0cyApO1xuXG5cdH1cblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlQ3ViZSggdlsgaSBdIHx8IGVtcHR5Q3ViZVRleHR1cmUsIHVuaXRzWyBpIF0gKTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVUMkRBcnJheUFycmF5KCBnbCwgdiwgdGV4dHVyZXMgKSB7XG5cblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG5cdGNvbnN0IG4gPSB2Lmxlbmd0aDtcblxuXHRjb25zdCB1bml0cyA9IGFsbG9jVGV4VW5pdHMoIHRleHR1cmVzLCBuICk7XG5cblx0aWYgKCAhIGFycmF5c0VxdWFsKCBjYWNoZSwgdW5pdHMgKSApIHtcblxuXHRcdGdsLnVuaWZvcm0xaXYoIHRoaXMuYWRkciwgdW5pdHMgKTtcblxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHVuaXRzICk7XG5cblx0fVxuXG5cdGZvciAoIGxldCBpID0gMDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdHRleHR1cmVzLnNldFRleHR1cmUyREFycmF5KCB2WyBpIF0gfHwgZW1wdHlBcnJheVRleHR1cmUsIHVuaXRzWyBpIF0gKTtcblxuXHR9XG5cbn1cblxuXG4vLyBIZWxwZXIgdG8gcGljayB0aGUgcmlnaHQgc2V0dGVyIGZvciBhIHB1cmUgKGJvdHRvbS1sZXZlbCkgYXJyYXlcblxuZnVuY3Rpb24gZ2V0UHVyZUFycmF5U2V0dGVyKCB0eXBlICkge1xuXG5cdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRjYXNlIDB4MTQwNjogcmV0dXJuIHNldFZhbHVlVjFmQXJyYXk7IC8vIEZMT0FUXG5cdFx0Y2FzZSAweDhiNTA6IHJldHVybiBzZXRWYWx1ZVYyZkFycmF5OyAvLyBfVkVDMlxuXHRcdGNhc2UgMHg4YjUxOiByZXR1cm4gc2V0VmFsdWVWM2ZBcnJheTsgLy8gX1ZFQzNcblx0XHRjYXNlIDB4OGI1MjogcmV0dXJuIHNldFZhbHVlVjRmQXJyYXk7IC8vIF9WRUM0XG5cblx0XHRjYXNlIDB4OGI1YTogcmV0dXJuIHNldFZhbHVlTTJBcnJheTsgLy8gX01BVDJcblx0XHRjYXNlIDB4OGI1YjogcmV0dXJuIHNldFZhbHVlTTNBcnJheTsgLy8gX01BVDNcblx0XHRjYXNlIDB4OGI1YzogcmV0dXJuIHNldFZhbHVlTTRBcnJheTsgLy8gX01BVDRcblxuXHRcdGNhc2UgMHgxNDA0OiBjYXNlIDB4OGI1NjogcmV0dXJuIHNldFZhbHVlVjFpQXJyYXk7IC8vIElOVCwgQk9PTFxuXHRcdGNhc2UgMHg4YjUzOiBjYXNlIDB4OGI1NzogcmV0dXJuIHNldFZhbHVlVjJpQXJyYXk7IC8vIF9WRUMyXG5cdFx0Y2FzZSAweDhiNTQ6IGNhc2UgMHg4YjU4OiByZXR1cm4gc2V0VmFsdWVWM2lBcnJheTsgLy8gX1ZFQzNcblx0XHRjYXNlIDB4OGI1NTogY2FzZSAweDhiNTk6IHJldHVybiBzZXRWYWx1ZVY0aUFycmF5OyAvLyBfVkVDNFxuXG5cdFx0Y2FzZSAweDE0MDU6IHJldHVybiBzZXRWYWx1ZVYxdWlBcnJheTsgLy8gVUlOVFxuXHRcdGNhc2UgMHg4ZGM2OiByZXR1cm4gc2V0VmFsdWVWMnVpQXJyYXk7IC8vIF9WRUMyXG5cdFx0Y2FzZSAweDhkYzc6IHJldHVybiBzZXRWYWx1ZVYzdWlBcnJheTsgLy8gX1ZFQzNcblx0XHRjYXNlIDB4OGRjODogcmV0dXJuIHNldFZhbHVlVjR1aUFycmF5OyAvLyBfVkVDNFxuXG5cdFx0Y2FzZSAweDhiNWU6IC8vIFNBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGQ2NjogLy8gU0FNUExFUl9FWFRFUk5BTF9PRVNcblx0XHRjYXNlIDB4OGRjYTogLy8gSU5UX1NBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGRkMjogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGI2MjogLy8gU0FNUExFUl8yRF9TSEFET1dcblx0XHRcdHJldHVybiBzZXRWYWx1ZVQxQXJyYXk7XG5cblx0XHRjYXNlIDB4OGI1ZjogLy8gU0FNUExFUl8zRFxuXHRcdGNhc2UgMHg4ZGNiOiAvLyBJTlRfU0FNUExFUl8zRFxuXHRcdGNhc2UgMHg4ZGQzOiAvLyBVTlNJR05FRF9JTlRfU0FNUExFUl8zRFxuXHRcdFx0cmV0dXJuIHNldFZhbHVlVDNEQXJyYXk7XG5cblx0XHRjYXNlIDB4OGI2MDogLy8gU0FNUExFUl9DVUJFXG5cdFx0Y2FzZSAweDhkY2M6IC8vIElOVF9TQU1QTEVSX0NVQkVcblx0XHRjYXNlIDB4OGRkNDogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfQ1VCRVxuXHRcdGNhc2UgMHg4ZGM1OiAvLyBTQU1QTEVSX0NVQkVfU0hBRE9XXG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVUNkFycmF5O1xuXG5cdFx0Y2FzZSAweDhkYzE6IC8vIFNBTVBMRVJfMkRfQVJSQVlcblx0XHRjYXNlIDB4OGRjZjogLy8gSU5UX1NBTVBMRVJfMkRfQVJSQVlcblx0XHRjYXNlIDB4OGRkNzogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfMkRfQVJSQVlcblx0XHRjYXNlIDB4OGRjNDogLy8gU0FNUExFUl8yRF9BUlJBWV9TSEFET1dcblx0XHRcdHJldHVybiBzZXRWYWx1ZVQyREFycmF5QXJyYXk7XG5cblx0fVxuXG59XG5cbi8vIC0tLSBVbmlmb3JtIENsYXNzZXMgLS0tXG5cbmNsYXNzIFNpbmdsZVVuaWZvcm0ge1xuXG5cdGNvbnN0cnVjdG9yKCBpZCwgYWN0aXZlSW5mbywgYWRkciApIHtcblxuXHRcdHRoaXMuaWQgPSBpZDtcblx0XHR0aGlzLmFkZHIgPSBhZGRyO1xuXHRcdHRoaXMuY2FjaGUgPSBbXTtcblx0XHR0aGlzLnR5cGUgPSBhY3RpdmVJbmZvLnR5cGU7XG5cdFx0dGhpcy5zZXRWYWx1ZSA9IGdldFNpbmd1bGFyU2V0dGVyKCBhY3RpdmVJbmZvLnR5cGUgKTtcblxuXHRcdC8vIHRoaXMucGF0aCA9IGFjdGl2ZUluZm8ubmFtZTsgLy8gREVCVUdcblxuXHR9XG5cbn1cblxuY2xhc3MgUHVyZUFycmF5VW5pZm9ybSB7XG5cblx0Y29uc3RydWN0b3IoIGlkLCBhY3RpdmVJbmZvLCBhZGRyICkge1xuXG5cdFx0dGhpcy5pZCA9IGlkO1xuXHRcdHRoaXMuYWRkciA9IGFkZHI7XG5cdFx0dGhpcy5jYWNoZSA9IFtdO1xuXHRcdHRoaXMudHlwZSA9IGFjdGl2ZUluZm8udHlwZTtcblx0XHR0aGlzLnNpemUgPSBhY3RpdmVJbmZvLnNpemU7XG5cdFx0dGhpcy5zZXRWYWx1ZSA9IGdldFB1cmVBcnJheVNldHRlciggYWN0aXZlSW5mby50eXBlICk7XG5cblx0XHQvLyB0aGlzLnBhdGggPSBhY3RpdmVJbmZvLm5hbWU7IC8vIERFQlVHXG5cblx0fVxuXG59XG5cbmNsYXNzIFN0cnVjdHVyZWRVbmlmb3JtIHtcblxuXHRjb25zdHJ1Y3RvciggaWQgKSB7XG5cblx0XHR0aGlzLmlkID0gaWQ7XG5cblx0XHR0aGlzLnNlcSA9IFtdO1xuXHRcdHRoaXMubWFwID0ge307XG5cblx0fVxuXG5cdHNldFZhbHVlKCBnbCwgdmFsdWUsIHRleHR1cmVzICkge1xuXG5cdFx0Y29uc3Qgc2VxID0gdGhpcy5zZXE7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCB1ID0gc2VxWyBpIF07XG5cdFx0XHR1LnNldFZhbHVlKCBnbCwgdmFsdWVbIHUuaWQgXSwgdGV4dHVyZXMgKTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuLy8gLS0tIFRvcC1sZXZlbCAtLS1cblxuLy8gUGFyc2VyIC0gYnVpbGRzIHVwIHRoZSBwcm9wZXJ0eSB0cmVlIGZyb20gdGhlIHBhdGggc3RyaW5nc1xuXG5jb25zdCBSZVBhdGhQYXJ0ID0gLyhcXHcrKShcXF0pPyhcXFt8XFwuKT8vZztcblxuLy8gZXh0cmFjdHNcbi8vIFx0LSB0aGUgaWRlbnRpZmllciAobWVtYmVyIG5hbWUgb3IgYXJyYXkgaW5kZXgpXG4vLyAgLSBmb2xsb3dlZCBieSBhbiBvcHRpb25hbCByaWdodCBicmFja2V0IChmb3VuZCB3aGVuIGFycmF5IGluZGV4KVxuLy8gIC0gZm9sbG93ZWQgYnkgYW4gb3B0aW9uYWwgbGVmdCBicmFja2V0IG9yIGRvdCAodHlwZSBvZiBzdWJzY3JpcHQpXG4vL1xuLy8gTm90ZTogVGhlc2UgcG9ydGlvbnMgY2FuIGJlIHJlYWQgaW4gYSBub24tb3ZlcmxhcHBpbmcgZmFzaGlvbiBhbmRcbi8vIGFsbG93IHN0cmFpZ2h0Zm9yd2FyZCBwYXJzaW5nIG9mIHRoZSBoaWVyYXJjaHkgdGhhdCBXZWJHTCBlbmNvZGVzXG4vLyBpbiB0aGUgdW5pZm9ybSBuYW1lcy5cblxuZnVuY3Rpb24gYWRkVW5pZm9ybSggY29udGFpbmVyLCB1bmlmb3JtT2JqZWN0ICkge1xuXG5cdGNvbnRhaW5lci5zZXEucHVzaCggdW5pZm9ybU9iamVjdCApO1xuXHRjb250YWluZXIubWFwWyB1bmlmb3JtT2JqZWN0LmlkIF0gPSB1bmlmb3JtT2JqZWN0O1xuXG59XG5cbmZ1bmN0aW9uIHBhcnNlVW5pZm9ybSggYWN0aXZlSW5mbywgYWRkciwgY29udGFpbmVyICkge1xuXG5cdGNvbnN0IHBhdGggPSBhY3RpdmVJbmZvLm5hbWUsXG5cdFx0cGF0aExlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG5cdC8vIHJlc2V0IFJlZ0V4cCBvYmplY3QsIGJlY2F1c2Ugb2YgdGhlIGVhcmx5IGV4aXQgb2YgYSBwcmV2aW91cyBydW5cblx0UmVQYXRoUGFydC5sYXN0SW5kZXggPSAwO1xuXG5cdHdoaWxlICggdHJ1ZSApIHtcblxuXHRcdGNvbnN0IG1hdGNoID0gUmVQYXRoUGFydC5leGVjKCBwYXRoICksXG5cdFx0XHRtYXRjaEVuZCA9IFJlUGF0aFBhcnQubGFzdEluZGV4O1xuXG5cdFx0bGV0IGlkID0gbWF0Y2hbIDEgXTtcblx0XHRjb25zdCBpZElzSW5kZXggPSBtYXRjaFsgMiBdID09PSAnXScsXG5cdFx0XHRzdWJzY3JpcHQgPSBtYXRjaFsgMyBdO1xuXG5cdFx0aWYgKCBpZElzSW5kZXggKSBpZCA9IGlkIHwgMDsgLy8gY29udmVydCB0byBpbnRlZ2VyXG5cblx0XHRpZiAoIHN1YnNjcmlwdCA9PT0gdW5kZWZpbmVkIHx8IHN1YnNjcmlwdCA9PT0gJ1snICYmIG1hdGNoRW5kICsgMiA9PT0gcGF0aExlbmd0aCApIHtcblxuXHRcdFx0Ly8gYmFyZSBuYW1lIG9yIFwicHVyZVwiIGJvdHRvbS1sZXZlbCBhcnJheSBcIlswXVwiIHN1ZmZpeFxuXG5cdFx0XHRhZGRVbmlmb3JtKCBjb250YWluZXIsIHN1YnNjcmlwdCA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0bmV3IFNpbmdsZVVuaWZvcm0oIGlkLCBhY3RpdmVJbmZvLCBhZGRyICkgOlxuXHRcdFx0XHRuZXcgUHVyZUFycmF5VW5pZm9ybSggaWQsIGFjdGl2ZUluZm8sIGFkZHIgKSApO1xuXG5cdFx0XHRicmVhaztcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIHN0ZXAgaW50byBpbm5lciBub2RlIC8gY3JlYXRlIGl0IGluIGNhc2UgaXQgZG9lc24ndCBleGlzdFxuXG5cdFx0XHRjb25zdCBtYXAgPSBjb250YWluZXIubWFwO1xuXHRcdFx0bGV0IG5leHQgPSBtYXBbIGlkIF07XG5cblx0XHRcdGlmICggbmV4dCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG5leHQgPSBuZXcgU3RydWN0dXJlZFVuaWZvcm0oIGlkICk7XG5cdFx0XHRcdGFkZFVuaWZvcm0oIGNvbnRhaW5lciwgbmV4dCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnRhaW5lciA9IG5leHQ7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbi8vIFJvb3QgQ29udGFpbmVyXG5cbmNsYXNzIFdlYkdMVW5pZm9ybXMge1xuXG5cdGNvbnN0cnVjdG9yKCBnbCwgcHJvZ3JhbSApIHtcblxuXHRcdHRoaXMuc2VxID0gW107XG5cdFx0dGhpcy5tYXAgPSB7fTtcblxuXHRcdGNvbnN0IG4gPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG47ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IGluZm8gPSBnbC5nZXRBY3RpdmVVbmlmb3JtKCBwcm9ncmFtLCBpICksXG5cdFx0XHRcdGFkZHIgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIGluZm8ubmFtZSApO1xuXG5cdFx0XHRwYXJzZVVuaWZvcm0oIGluZm8sIGFkZHIsIHRoaXMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0c2V0VmFsdWUoIGdsLCBuYW1lLCB2YWx1ZSwgdGV4dHVyZXMgKSB7XG5cblx0XHRjb25zdCB1ID0gdGhpcy5tYXBbIG5hbWUgXTtcblxuXHRcdGlmICggdSAhPT0gdW5kZWZpbmVkICkgdS5zZXRWYWx1ZSggZ2wsIHZhbHVlLCB0ZXh0dXJlcyApO1xuXG5cdH1cblxuXHRzZXRPcHRpb25hbCggZ2wsIG9iamVjdCwgbmFtZSApIHtcblxuXHRcdGNvbnN0IHYgPSBvYmplY3RbIG5hbWUgXTtcblxuXHRcdGlmICggdiAhPT0gdW5kZWZpbmVkICkgdGhpcy5zZXRWYWx1ZSggZ2wsIG5hbWUsIHYgKTtcblxuXHR9XG5cblx0c3RhdGljIHVwbG9hZCggZ2wsIHNlcSwgdmFsdWVzLCB0ZXh0dXJlcyApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IHNlcS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IHUgPSBzZXFbIGkgXSxcblx0XHRcdFx0diA9IHZhbHVlc1sgdS5pZCBdO1xuXG5cdFx0XHRpZiAoIHYubmVlZHNVcGRhdGUgIT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIG5vdGU6IGFsd2F5cyB1cGRhdGluZyB3aGVuIC5uZWVkc1VwZGF0ZSBpcyB1bmRlZmluZWRcblx0XHRcdFx0dS5zZXRWYWx1ZSggZ2wsIHYudmFsdWUsIHRleHR1cmVzICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0c3RhdGljIHNlcVdpdGhWYWx1ZSggc2VxLCB2YWx1ZXMgKSB7XG5cblx0XHRjb25zdCByID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCB1ID0gc2VxWyBpIF07XG5cdFx0XHRpZiAoIHUuaWQgaW4gdmFsdWVzICkgci5wdXNoKCB1ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcjtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gV2ViR0xTaGFkZXIoIGdsLCB0eXBlLCBzdHJpbmcgKSB7XG5cblx0Y29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCB0eXBlICk7XG5cblx0Z2wuc2hhZGVyU291cmNlKCBzaGFkZXIsIHN0cmluZyApO1xuXHRnbC5jb21waWxlU2hhZGVyKCBzaGFkZXIgKTtcblxuXHRyZXR1cm4gc2hhZGVyO1xuXG59XG5cbi8vIEZyb20gaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvZXh0ZW5zaW9ucy9LSFJfcGFyYWxsZWxfc2hhZGVyX2NvbXBpbGUvXG5jb25zdCBDT01QTEVUSU9OX1NUQVRVU19LSFIgPSAweDkxQjE7XG5cbmxldCBwcm9ncmFtSWRDb3VudCA9IDA7XG5cbmZ1bmN0aW9uIGhhbmRsZVNvdXJjZSggc3RyaW5nLCBlcnJvckxpbmUgKSB7XG5cblx0Y29uc3QgbGluZXMgPSBzdHJpbmcuc3BsaXQoICdcXG4nICk7XG5cdGNvbnN0IGxpbmVzMiA9IFtdO1xuXG5cdGNvbnN0IGZyb20gPSBNYXRoLm1heCggZXJyb3JMaW5lIC0gNiwgMCApO1xuXHRjb25zdCB0byA9IE1hdGgubWluKCBlcnJvckxpbmUgKyA2LCBsaW5lcy5sZW5ndGggKTtcblxuXHRmb3IgKCBsZXQgaSA9IGZyb207IGkgPCB0bzsgaSArKyApIHtcblxuXHRcdGNvbnN0IGxpbmUgPSBpICsgMTtcblx0XHRsaW5lczIucHVzaCggYCR7bGluZSA9PT0gZXJyb3JMaW5lID8gJz4nIDogJyAnfSAke2xpbmV9OiAke2xpbmVzWyBpIF19YCApO1xuXG5cdH1cblxuXHRyZXR1cm4gbGluZXMyLmpvaW4oICdcXG4nICk7XG5cbn1cblxuY29uc3QgX20wID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpO1xuXG5mdW5jdGlvbiBnZXRFbmNvZGluZ0NvbXBvbmVudHMoIGNvbG9yU3BhY2UgKSB7XG5cblx0Q29sb3JNYW5hZ2VtZW50Ll9nZXRNYXRyaXgoIF9tMCwgQ29sb3JNYW5hZ2VtZW50LndvcmtpbmdDb2xvclNwYWNlLCBjb2xvclNwYWNlICk7XG5cblx0Y29uc3QgZW5jb2RpbmdNYXRyaXggPSBgbWF0MyggJHsgX20wLmVsZW1lbnRzLm1hcCggKCB2ICkgPT4gdi50b0ZpeGVkKCA0ICkgKSB9IClgO1xuXG5cdHN3aXRjaCAoIENvbG9yTWFuYWdlbWVudC5nZXRUcmFuc2ZlciggY29sb3JTcGFjZSApICkge1xuXG5cdFx0Y2FzZSBMaW5lYXJUcmFuc2Zlcjpcblx0XHRcdHJldHVybiBbIGVuY29kaW5nTWF0cml4LCAnTGluZWFyVHJhbnNmZXJPRVRGJyBdO1xuXG5cdFx0Y2FzZSBTUkdCVHJhbnNmZXI6XG5cdFx0XHRyZXR1cm4gWyBlbmNvZGluZ01hdHJpeCwgJ3NSR0JUcmFuc2Zlck9FVEYnIF07XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiBVbnN1cHBvcnRlZCBjb2xvciBzcGFjZTogJywgY29sb3JTcGFjZSApO1xuXHRcdFx0cmV0dXJuIFsgZW5jb2RpbmdNYXRyaXgsICdMaW5lYXJUcmFuc2Zlck9FVEYnIF07XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIGdldFNoYWRlckVycm9ycyggZ2wsIHNoYWRlciwgdHlwZSApIHtcblxuXHRjb25zdCBzdGF0dXMgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoIHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMgKTtcblx0Y29uc3QgZXJyb3JzID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICkudHJpbSgpO1xuXG5cdGlmICggc3RhdHVzICYmIGVycm9ycyA9PT0gJycgKSByZXR1cm4gJyc7XG5cblx0Y29uc3QgZXJyb3JNYXRjaGVzID0gL0VSUk9SOiAwOihcXGQrKS8uZXhlYyggZXJyb3JzICk7XG5cdGlmICggZXJyb3JNYXRjaGVzICkge1xuXG5cdFx0Ly8gLS1lbmFibGUtcHJpdmlsZWdlZC13ZWJnbC1leHRlbnNpb25cblx0XHQvLyBjb25zb2xlLmxvZyggJyoqJyArIHR5cGUgKyAnKionLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIHNoYWRlciApICk7XG5cblx0XHRjb25zdCBlcnJvckxpbmUgPSBwYXJzZUludCggZXJyb3JNYXRjaGVzWyAxIF0gKTtcblx0XHRyZXR1cm4gdHlwZS50b1VwcGVyQ2FzZSgpICsgJ1xcblxcbicgKyBlcnJvcnMgKyAnXFxuXFxuJyArIGhhbmRsZVNvdXJjZSggZ2wuZ2V0U2hhZGVyU291cmNlKCBzaGFkZXIgKSwgZXJyb3JMaW5lICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdHJldHVybiBlcnJvcnM7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIGdldFRleGVsRW5jb2RpbmdGdW5jdGlvbiggZnVuY3Rpb25OYW1lLCBjb2xvclNwYWNlICkge1xuXG5cdGNvbnN0IGNvbXBvbmVudHMgPSBnZXRFbmNvZGluZ0NvbXBvbmVudHMoIGNvbG9yU3BhY2UgKTtcblxuXHRyZXR1cm4gW1xuXG5cdFx0YHZlYzQgJHtmdW5jdGlvbk5hbWV9KCB2ZWM0IHZhbHVlICkge2AsXG5cblx0XHRgXHRyZXR1cm4gJHtjb21wb25lbnRzWyAxIF19KCB2ZWM0KCB2YWx1ZS5yZ2IgKiAke2NvbXBvbmVudHNbIDAgXX0sIHZhbHVlLmEgKSApO2AsXG5cblx0XHQnfScsXG5cblx0XS5qb2luKCAnXFxuJyApO1xuXG59XG5cbmZ1bmN0aW9uIGdldFRvbmVNYXBwaW5nRnVuY3Rpb24oIGZ1bmN0aW9uTmFtZSwgdG9uZU1hcHBpbmcgKSB7XG5cblx0bGV0IHRvbmVNYXBwaW5nTmFtZTtcblxuXHRzd2l0Y2ggKCB0b25lTWFwcGluZyApIHtcblxuXHRcdGNhc2UgTGluZWFyVG9uZU1hcHBpbmc6XG5cdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnTGluZWFyJztcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBSZWluaGFyZFRvbmVNYXBwaW5nOlxuXHRcdFx0dG9uZU1hcHBpbmdOYW1lID0gJ1JlaW5oYXJkJztcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBDaW5lb25Ub25lTWFwcGluZzpcblx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9ICdDaW5lb24nO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIEFDRVNGaWxtaWNUb25lTWFwcGluZzpcblx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9ICdBQ0VTRmlsbWljJztcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBBZ1hUb25lTWFwcGluZzpcblx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9ICdBZ1gnO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIE5ldXRyYWxUb25lTWFwcGluZzpcblx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9ICdOZXV0cmFsJztcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBDdXN0b21Ub25lTWFwcGluZzpcblx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9ICdDdXN0b20nO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiBVbnN1cHBvcnRlZCB0b25lTWFwcGluZzonLCB0b25lTWFwcGluZyApO1xuXHRcdFx0dG9uZU1hcHBpbmdOYW1lID0gJ0xpbmVhcic7XG5cblx0fVxuXG5cdHJldHVybiAndmVjMyAnICsgZnVuY3Rpb25OYW1lICsgJyggdmVjMyBjb2xvciApIHsgcmV0dXJuICcgKyB0b25lTWFwcGluZ05hbWUgKyAnVG9uZU1hcHBpbmcoIGNvbG9yICk7IH0nO1xuXG59XG5cbmNvbnN0IF92MCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuZnVuY3Rpb24gZ2V0THVtaW5hbmNlRnVuY3Rpb24oKSB7XG5cblx0Q29sb3JNYW5hZ2VtZW50LmdldEx1bWluYW5jZUNvZWZmaWNpZW50cyggX3YwICk7XG5cblx0Y29uc3QgciA9IF92MC54LnRvRml4ZWQoIDQgKTtcblx0Y29uc3QgZyA9IF92MC55LnRvRml4ZWQoIDQgKTtcblx0Y29uc3QgYiA9IF92MC56LnRvRml4ZWQoIDQgKTtcblxuXHRyZXR1cm4gW1xuXG5cdFx0J2Zsb2F0IGx1bWluYW5jZSggY29uc3QgaW4gdmVjMyByZ2IgKSB7JyxcblxuXHRcdGBcdGNvbnN0IHZlYzMgd2VpZ2h0cyA9IHZlYzMoICR7IHIgfSwgJHsgZyB9LCAkeyBiIH0gKTtgLFxuXG5cdFx0J1x0cmV0dXJuIGRvdCggd2VpZ2h0cywgcmdiICk7JyxcblxuXHRcdCd9J1xuXG5cdF0uam9pbiggJ1xcbicgKTtcblxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVZlcnRleEV4dGVuc2lvbnMoIHBhcmFtZXRlcnMgKSB7XG5cblx0Y29uc3QgY2h1bmtzID0gW1xuXHRcdHBhcmFtZXRlcnMuZXh0ZW5zaW9uQ2xpcEN1bGxEaXN0YW5jZSA/ICcjZXh0ZW5zaW9uIEdMX0FOR0xFX2NsaXBfY3VsbF9kaXN0YW5jZSA6IHJlcXVpcmUnIDogJycsXG5cdFx0cGFyYW1ldGVycy5leHRlbnNpb25NdWx0aURyYXcgPyAnI2V4dGVuc2lvbiBHTF9BTkdMRV9tdWx0aV9kcmF3IDogcmVxdWlyZScgOiAnJyxcblx0XTtcblxuXHRyZXR1cm4gY2h1bmtzLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcblxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZURlZmluZXMoIGRlZmluZXMgKSB7XG5cblx0Y29uc3QgY2h1bmtzID0gW107XG5cblx0Zm9yICggY29uc3QgbmFtZSBpbiBkZWZpbmVzICkge1xuXG5cdFx0Y29uc3QgdmFsdWUgPSBkZWZpbmVzWyBuYW1lIF07XG5cblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIGNvbnRpbnVlO1xuXG5cdFx0Y2h1bmtzLnB1c2goICcjZGVmaW5lICcgKyBuYW1lICsgJyAnICsgdmFsdWUgKTtcblxuXHR9XG5cblx0cmV0dXJuIGNodW5rcy5qb2luKCAnXFxuJyApO1xuXG59XG5cbmZ1bmN0aW9uIGZldGNoQXR0cmlidXRlTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSApIHtcblxuXHRjb25zdCBhdHRyaWJ1dGVzID0ge307XG5cblx0Y29uc3QgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkFDVElWRV9BVFRSSUJVVEVTICk7XG5cblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbjsgaSArKyApIHtcblxuXHRcdGNvbnN0IGluZm8gPSBnbC5nZXRBY3RpdmVBdHRyaWIoIHByb2dyYW0sIGkgKTtcblx0XHRjb25zdCBuYW1lID0gaW5mby5uYW1lO1xuXG5cdFx0bGV0IGxvY2F0aW9uU2l6ZSA9IDE7XG5cdFx0aWYgKCBpbmZvLnR5cGUgPT09IGdsLkZMT0FUX01BVDIgKSBsb2NhdGlvblNpemUgPSAyO1xuXHRcdGlmICggaW5mby50eXBlID09PSBnbC5GTE9BVF9NQVQzICkgbG9jYXRpb25TaXplID0gMztcblx0XHRpZiAoIGluZm8udHlwZSA9PT0gZ2wuRkxPQVRfTUFUNCApIGxvY2F0aW9uU2l6ZSA9IDQ7XG5cblx0XHQvLyBjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUHJvZ3JhbTogQUNUSVZFIFZFUlRFWCBBVFRSSUJVVEU6JywgbmFtZSwgaSApO1xuXG5cdFx0YXR0cmlidXRlc1sgbmFtZSBdID0ge1xuXHRcdFx0dHlwZTogaW5mby50eXBlLFxuXHRcdFx0bG9jYXRpb246IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCBuYW1lICksXG5cdFx0XHRsb2NhdGlvblNpemU6IGxvY2F0aW9uU2l6ZVxuXHRcdH07XG5cblx0fVxuXG5cdHJldHVybiBhdHRyaWJ1dGVzO1xuXG59XG5cbmZ1bmN0aW9uIGZpbHRlckVtcHR5TGluZSggc3RyaW5nICkge1xuXG5cdHJldHVybiBzdHJpbmcgIT09ICcnO1xuXG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VMaWdodE51bXMoIHN0cmluZywgcGFyYW1ldGVycyApIHtcblxuXHRjb25zdCBudW1TcG90TGlnaHRDb29yZHMgPSBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodFNoYWRvd3MgKyBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodE1hcHMgLSBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcztcblxuXHRyZXR1cm4gc3RyaW5nXG5cdFx0LnJlcGxhY2UoIC9OVU1fRElSX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bURpckxpZ2h0cyApXG5cdFx0LnJlcGxhY2UoIC9OVU1fU1BPVF9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1TcG90TGlnaHRzIClcblx0XHQucmVwbGFjZSggL05VTV9TUE9UX0xJR0hUX01BUFMvZywgcGFyYW1ldGVycy5udW1TcG90TGlnaHRNYXBzIClcblx0XHQucmVwbGFjZSggL05VTV9TUE9UX0xJR0hUX0NPT1JEUy9nLCBudW1TcG90TGlnaHRDb29yZHMgKVxuXHRcdC5yZXBsYWNlKCAvTlVNX1JFQ1RfQVJFQV9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1SZWN0QXJlYUxpZ2h0cyApXG5cdFx0LnJlcGxhY2UoIC9OVU1fUE9JTlRfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtUG9pbnRMaWdodHMgKVxuXHRcdC5yZXBsYWNlKCAvTlVNX0hFTUlfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtSGVtaUxpZ2h0cyApXG5cdFx0LnJlcGxhY2UoIC9OVU1fRElSX0xJR0hUX1NIQURPV1MvZywgcGFyYW1ldGVycy5udW1EaXJMaWdodFNoYWRvd3MgKVxuXHRcdC5yZXBsYWNlKCAvTlVNX1NQT1RfTElHSFRfU0hBRE9XU19XSVRIX01BUFMvZywgcGFyYW1ldGVycy5udW1TcG90TGlnaHRTaGFkb3dzV2l0aE1hcHMgKVxuXHRcdC5yZXBsYWNlKCAvTlVNX1NQT1RfTElHSFRfU0hBRE9XUy9nLCBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodFNoYWRvd3MgKVxuXHRcdC5yZXBsYWNlKCAvTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MvZywgcGFyYW1ldGVycy5udW1Qb2ludExpZ2h0U2hhZG93cyApO1xuXG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VDbGlwcGluZ1BsYW5lTnVtcyggc3RyaW5nLCBwYXJhbWV0ZXJzICkge1xuXG5cdHJldHVybiBzdHJpbmdcblx0XHQucmVwbGFjZSggL05VTV9DTElQUElOR19QTEFORVMvZywgcGFyYW1ldGVycy5udW1DbGlwcGluZ1BsYW5lcyApXG5cdFx0LnJlcGxhY2UoIC9VTklPTl9DTElQUElOR19QTEFORVMvZywgKCBwYXJhbWV0ZXJzLm51bUNsaXBwaW5nUGxhbmVzIC0gcGFyYW1ldGVycy5udW1DbGlwSW50ZXJzZWN0aW9uICkgKTtcblxufVxuXG4vLyBSZXNvbHZlIEluY2x1ZGVzXG5cbmNvbnN0IGluY2x1ZGVQYXR0ZXJuID0gL15bIFxcdF0qI2luY2x1ZGUgKzwoW1xcd1xcZC4vXSspPi9nbTtcblxuZnVuY3Rpb24gcmVzb2x2ZUluY2x1ZGVzKCBzdHJpbmcgKSB7XG5cblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBpbmNsdWRlUGF0dGVybiwgaW5jbHVkZVJlcGxhY2VyICk7XG5cbn1cblxuY29uc3Qgc2hhZGVyQ2h1bmtNYXAgPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIGluY2x1ZGVSZXBsYWNlciggbWF0Y2gsIGluY2x1ZGUgKSB7XG5cblx0bGV0IHN0cmluZyA9IFNoYWRlckNodW5rWyBpbmNsdWRlIF07XG5cblx0aWYgKCBzdHJpbmcgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGNvbnN0IG5ld0luY2x1ZGUgPSBzaGFkZXJDaHVua01hcC5nZXQoIGluY2x1ZGUgKTtcblxuXHRcdGlmICggbmV3SW5jbHVkZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRzdHJpbmcgPSBTaGFkZXJDaHVua1sgbmV3SW5jbHVkZSBdO1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogU2hhZGVyIGNodW5rIFwiJXNcIiBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgXCIlc1wiIGluc3RlYWQuJywgaW5jbHVkZSwgbmV3SW5jbHVkZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ2FuIG5vdCByZXNvbHZlICNpbmNsdWRlIDwnICsgaW5jbHVkZSArICc+JyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gcmVzb2x2ZUluY2x1ZGVzKCBzdHJpbmcgKTtcblxufVxuXG4vLyBVbnJvbGwgTG9vcHNcblxuY29uc3QgdW5yb2xsTG9vcFBhdHRlcm4gPSAvI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxccytmb3JcXHMqXFwoXFxzKmludFxccytpXFxzKj1cXHMqKFxcZCspXFxzKjtcXHMqaVxccyo8XFxzKihcXGQrKVxccyo7XFxzKmlcXHMqXFwrXFwrXFxzKlxcKVxccyp7KFtcXHNcXFNdKz8pfVxccysjcHJhZ21hIHVucm9sbF9sb29wX2VuZC9nO1xuXG5mdW5jdGlvbiB1bnJvbGxMb29wcyggc3RyaW5nICkge1xuXG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSggdW5yb2xsTG9vcFBhdHRlcm4sIGxvb3BSZXBsYWNlciApO1xuXG59XG5cbmZ1bmN0aW9uIGxvb3BSZXBsYWNlciggbWF0Y2gsIHN0YXJ0LCBlbmQsIHNuaXBwZXQgKSB7XG5cblx0bGV0IHN0cmluZyA9ICcnO1xuXG5cdGZvciAoIGxldCBpID0gcGFyc2VJbnQoIHN0YXJ0ICk7IGkgPCBwYXJzZUludCggZW5kICk7IGkgKysgKSB7XG5cblx0XHRzdHJpbmcgKz0gc25pcHBldFxuXHRcdFx0LnJlcGxhY2UoIC9cXFtcXHMqaVxccypcXF0vZywgJ1sgJyArIGkgKyAnIF0nIClcblx0XHRcdC5yZXBsYWNlKCAvVU5ST0xMRURfTE9PUF9JTkRFWC9nLCBpICk7XG5cblx0fVxuXG5cdHJldHVybiBzdHJpbmc7XG5cbn1cblxuLy9cblxuZnVuY3Rpb24gZ2VuZXJhdGVQcmVjaXNpb24oIHBhcmFtZXRlcnMgKSB7XG5cblx0bGV0IHByZWNpc2lvbnN0cmluZyA9IGBwcmVjaXNpb24gJHtwYXJhbWV0ZXJzLnByZWNpc2lvbn0gZmxvYXQ7XG5cdHByZWNpc2lvbiAke3BhcmFtZXRlcnMucHJlY2lzaW9ufSBpbnQ7XG5cdHByZWNpc2lvbiAke3BhcmFtZXRlcnMucHJlY2lzaW9ufSBzYW1wbGVyMkQ7XG5cdHByZWNpc2lvbiAke3BhcmFtZXRlcnMucHJlY2lzaW9ufSBzYW1wbGVyQ3ViZTtcblx0cHJlY2lzaW9uICR7cGFyYW1ldGVycy5wcmVjaXNpb259IHNhbXBsZXIzRDtcblx0cHJlY2lzaW9uICR7cGFyYW1ldGVycy5wcmVjaXNpb259IHNhbXBsZXIyREFycmF5O1xuXHRwcmVjaXNpb24gJHtwYXJhbWV0ZXJzLnByZWNpc2lvbn0gc2FtcGxlcjJEU2hhZG93O1xuXHRwcmVjaXNpb24gJHtwYXJhbWV0ZXJzLnByZWNpc2lvbn0gc2FtcGxlckN1YmVTaGFkb3c7XG5cdHByZWNpc2lvbiAke3BhcmFtZXRlcnMucHJlY2lzaW9ufSBzYW1wbGVyMkRBcnJheVNoYWRvdztcblx0cHJlY2lzaW9uICR7cGFyYW1ldGVycy5wcmVjaXNpb259IGlzYW1wbGVyMkQ7XG5cdHByZWNpc2lvbiAke3BhcmFtZXRlcnMucHJlY2lzaW9ufSBpc2FtcGxlcjNEO1xuXHRwcmVjaXNpb24gJHtwYXJhbWV0ZXJzLnByZWNpc2lvbn0gaXNhbXBsZXJDdWJlO1xuXHRwcmVjaXNpb24gJHtwYXJhbWV0ZXJzLnByZWNpc2lvbn0gaXNhbXBsZXIyREFycmF5O1xuXHRwcmVjaXNpb24gJHtwYXJhbWV0ZXJzLnByZWNpc2lvbn0gdXNhbXBsZXIyRDtcblx0cHJlY2lzaW9uICR7cGFyYW1ldGVycy5wcmVjaXNpb259IHVzYW1wbGVyM0Q7XG5cdHByZWNpc2lvbiAke3BhcmFtZXRlcnMucHJlY2lzaW9ufSB1c2FtcGxlckN1YmU7XG5cdHByZWNpc2lvbiAke3BhcmFtZXRlcnMucHJlY2lzaW9ufSB1c2FtcGxlcjJEQXJyYXk7XG5cdGA7XG5cblx0aWYgKCBwYXJhbWV0ZXJzLnByZWNpc2lvbiA9PT0gJ2hpZ2hwJyApIHtcblxuXHRcdHByZWNpc2lvbnN0cmluZyArPSAnXFxuI2RlZmluZSBISUdIX1BSRUNJU0lPTic7XG5cblx0fSBlbHNlIGlmICggcGFyYW1ldGVycy5wcmVjaXNpb24gPT09ICdtZWRpdW1wJyApIHtcblxuXHRcdHByZWNpc2lvbnN0cmluZyArPSAnXFxuI2RlZmluZSBNRURJVU1fUFJFQ0lTSU9OJztcblxuXHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnByZWNpc2lvbiA9PT0gJ2xvd3AnICkge1xuXG5cdFx0cHJlY2lzaW9uc3RyaW5nICs9ICdcXG4jZGVmaW5lIExPV19QUkVDSVNJT04nO1xuXG5cdH1cblxuXHRyZXR1cm4gcHJlY2lzaW9uc3RyaW5nO1xuXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU2hhZG93TWFwVHlwZURlZmluZSggcGFyYW1ldGVycyApIHtcblxuXHRsZXQgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9CQVNJQyc7XG5cblx0aWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFBDRlNoYWRvd01hcCApIHtcblxuXHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGJztcblxuXHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFBDRlNvZnRTaGFkb3dNYXAgKSB7XG5cblx0XHRzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX1BDRl9TT0ZUJztcblxuXHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFZTTVNoYWRvd01hcCApIHtcblxuXHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfVlNNJztcblxuXHR9XG5cblx0cmV0dXJuIHNoYWRvd01hcFR5cGVEZWZpbmU7XG5cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVFbnZNYXBUeXBlRGVmaW5lKCBwYXJhbWV0ZXJzICkge1xuXG5cdGxldCBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xuXG5cdGlmICggcGFyYW1ldGVycy5lbnZNYXAgKSB7XG5cblx0XHRzd2l0Y2ggKCBwYXJhbWV0ZXJzLmVudk1hcE1vZGUgKSB7XG5cblx0XHRcdGNhc2UgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nOlxuXHRcdFx0Y2FzZSBDdWJlUmVmcmFjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nOlxuXHRcdFx0XHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkVfVVYnO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIGVudk1hcFR5cGVEZWZpbmU7XG5cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVFbnZNYXBNb2RlRGVmaW5lKCBwYXJhbWV0ZXJzICkge1xuXG5cdGxldCBlbnZNYXBNb2RlRGVmaW5lID0gJ0VOVk1BUF9NT0RFX1JFRkxFQ1RJT04nO1xuXG5cdGlmICggcGFyYW1ldGVycy5lbnZNYXAgKSB7XG5cblx0XHRzd2l0Y2ggKCBwYXJhbWV0ZXJzLmVudk1hcE1vZGUgKSB7XG5cblx0XHRcdGNhc2UgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOlxuXG5cdFx0XHRcdGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGUkFDVElPTic7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gZW52TWFwTW9kZURlZmluZTtcblxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUVudk1hcEJsZW5kaW5nRGVmaW5lKCBwYXJhbWV0ZXJzICkge1xuXG5cdGxldCBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTk9ORSc7XG5cblx0aWYgKCBwYXJhbWV0ZXJzLmVudk1hcCApIHtcblxuXHRcdHN3aXRjaCAoIHBhcmFtZXRlcnMuY29tYmluZSApIHtcblxuXHRcdFx0Y2FzZSBNdWx0aXBseU9wZXJhdGlvbjpcblx0XHRcdFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZJztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgTWl4T3BlcmF0aW9uOlxuXHRcdFx0XHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTUlYJztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgQWRkT3BlcmF0aW9uOlxuXHRcdFx0XHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfQUREJztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiBlbnZNYXBCbGVuZGluZ0RlZmluZTtcblxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUN1YmVVVlNpemUoIHBhcmFtZXRlcnMgKSB7XG5cblx0Y29uc3QgaW1hZ2VIZWlnaHQgPSBwYXJhbWV0ZXJzLmVudk1hcEN1YmVVVkhlaWdodDtcblxuXHRpZiAoIGltYWdlSGVpZ2h0ID09PSBudWxsICkgcmV0dXJuIG51bGw7XG5cblx0Y29uc3QgbWF4TWlwID0gTWF0aC5sb2cyKCBpbWFnZUhlaWdodCApIC0gMjtcblxuXHRjb25zdCB0ZXhlbEhlaWdodCA9IDEuMCAvIGltYWdlSGVpZ2h0O1xuXG5cdGNvbnN0IHRleGVsV2lkdGggPSAxLjAgLyAoIDMgKiBNYXRoLm1heCggTWF0aC5wb3coIDIsIG1heE1pcCApLCA3ICogMTYgKSApO1xuXG5cdHJldHVybiB7IHRleGVsV2lkdGgsIHRleGVsSGVpZ2h0LCBtYXhNaXAgfTtcblxufVxuXG5mdW5jdGlvbiBXZWJHTFByb2dyYW0oIHJlbmRlcmVyLCBjYWNoZUtleSwgcGFyYW1ldGVycywgYmluZGluZ1N0YXRlcyApIHtcblxuXHQvLyBUT0RPIFNlbmQgdGhpcyBldmVudCB0byBUaHJlZS5qcyBEZXZUb29sc1xuXHQvLyBjb25zb2xlLmxvZyggJ1dlYkdMUHJvZ3JhbScsIGNhY2hlS2V5ICk7XG5cblx0Y29uc3QgZ2wgPSByZW5kZXJlci5nZXRDb250ZXh0KCk7XG5cblx0Y29uc3QgZGVmaW5lcyA9IHBhcmFtZXRlcnMuZGVmaW5lcztcblxuXHRsZXQgdmVydGV4U2hhZGVyID0gcGFyYW1ldGVycy52ZXJ0ZXhTaGFkZXI7XG5cdGxldCBmcmFnbWVudFNoYWRlciA9IHBhcmFtZXRlcnMuZnJhZ21lbnRTaGFkZXI7XG5cblx0Y29uc3Qgc2hhZG93TWFwVHlwZURlZmluZSA9IGdlbmVyYXRlU2hhZG93TWFwVHlwZURlZmluZSggcGFyYW1ldGVycyApO1xuXHRjb25zdCBlbnZNYXBUeXBlRGVmaW5lID0gZ2VuZXJhdGVFbnZNYXBUeXBlRGVmaW5lKCBwYXJhbWV0ZXJzICk7XG5cdGNvbnN0IGVudk1hcE1vZGVEZWZpbmUgPSBnZW5lcmF0ZUVudk1hcE1vZGVEZWZpbmUoIHBhcmFtZXRlcnMgKTtcblx0Y29uc3QgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSBnZW5lcmF0ZUVudk1hcEJsZW5kaW5nRGVmaW5lKCBwYXJhbWV0ZXJzICk7XG5cdGNvbnN0IGVudk1hcEN1YmVVVlNpemUgPSBnZW5lcmF0ZUN1YmVVVlNpemUoIHBhcmFtZXRlcnMgKTtcblxuXHRjb25zdCBjdXN0b21WZXJ0ZXhFeHRlbnNpb25zID0gZ2VuZXJhdGVWZXJ0ZXhFeHRlbnNpb25zKCBwYXJhbWV0ZXJzICk7XG5cblx0Y29uc3QgY3VzdG9tRGVmaW5lcyA9IGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApO1xuXG5cdGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cblx0bGV0IHByZWZpeFZlcnRleCwgcHJlZml4RnJhZ21lbnQ7XG5cdGxldCB2ZXJzaW9uU3RyaW5nID0gcGFyYW1ldGVycy5nbHNsVmVyc2lvbiA/ICcjdmVyc2lvbiAnICsgcGFyYW1ldGVycy5nbHNsVmVyc2lvbiArICdcXG4nIDogJyc7XG5cblx0aWYgKCBwYXJhbWV0ZXJzLmlzUmF3U2hhZGVyTWF0ZXJpYWwgKSB7XG5cblx0XHRwcmVmaXhWZXJ0ZXggPSBbXG5cblx0XHRcdCcjZGVmaW5lIFNIQURFUl9UWVBFICcgKyBwYXJhbWV0ZXJzLnNoYWRlclR5cGUsXG5cdFx0XHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgcGFyYW1ldGVycy5zaGFkZXJOYW1lLFxuXG5cdFx0XHRjdXN0b21EZWZpbmVzXG5cblx0XHRdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcblxuXHRcdGlmICggcHJlZml4VmVydGV4Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdHByZWZpeFZlcnRleCArPSAnXFxuJztcblxuXHRcdH1cblxuXHRcdHByZWZpeEZyYWdtZW50ID0gW1xuXG5cdFx0XHQnI2RlZmluZSBTSEFERVJfVFlQRSAnICsgcGFyYW1ldGVycy5zaGFkZXJUeXBlLFxuXHRcdFx0JyNkZWZpbmUgU0hBREVSX05BTUUgJyArIHBhcmFtZXRlcnMuc2hhZGVyTmFtZSxcblxuXHRcdFx0Y3VzdG9tRGVmaW5lc1xuXG5cdFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XG5cblx0XHRpZiAoIHByZWZpeEZyYWdtZW50Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdHByZWZpeEZyYWdtZW50ICs9ICdcXG4nO1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRwcmVmaXhWZXJ0ZXggPSBbXG5cblx0XHRcdGdlbmVyYXRlUHJlY2lzaW9uKCBwYXJhbWV0ZXJzICksXG5cblx0XHRcdCcjZGVmaW5lIFNIQURFUl9UWVBFICcgKyBwYXJhbWV0ZXJzLnNoYWRlclR5cGUsXG5cdFx0XHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgcGFyYW1ldGVycy5zaGFkZXJOYW1lLFxuXG5cdFx0XHRjdXN0b21EZWZpbmVzLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmV4dGVuc2lvbkNsaXBDdWxsRGlzdGFuY2UgPyAnI2RlZmluZSBVU0VfQ0xJUF9ESVNUQU5DRScgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuYmF0Y2hpbmcgPyAnI2RlZmluZSBVU0VfQkFUQ0hJTkcnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmJhdGNoaW5nQ29sb3IgPyAnI2RlZmluZSBVU0VfQkFUQ0hJTkdfQ09MT1InIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmluc3RhbmNpbmcgPyAnI2RlZmluZSBVU0VfSU5TVEFOQ0lORycgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuaW5zdGFuY2luZ0NvbG9yID8gJyNkZWZpbmUgVVNFX0lOU1RBTkNJTkdfQ09MT1InIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmluc3RhbmNpbmdNb3JwaCA/ICcjZGVmaW5lIFVTRV9JTlNUQU5DSU5HX01PUlBIJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyA/ICcjZGVmaW5lIFVTRV9GT0cnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZ0V4cDIgPyAnI2RlZmluZSBGT0dfRVhQMicgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMubm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX05PUk1BTE1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMubm9ybWFsTWFwT2JqZWN0U3BhY2UgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQX09CSkVDVFNQQUNFJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXBUYW5nZW50U3BhY2UgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQX1RBTkdFTlRTUEFDRScgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwID8gJyNkZWZpbmUgVVNFX0RJU1BMQUNFTUVOVE1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuYW5pc290cm9weSA/ICcjZGVmaW5lIFVTRV9BTklTT1RST1BZJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5hbmlzb3Ryb3B5TWFwID8gJyNkZWZpbmUgVVNFX0FOSVNPVFJPUFlNQVAnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuY2xlYXJjb2F0TWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVE1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuY2xlYXJjb2F0Um91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmNsZWFyY29hdE5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmlyaWRlc2NlbmNlTWFwID8gJyNkZWZpbmUgVVNFX0lSSURFU0NFTkNFTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCA/ICcjZGVmaW5lIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVAnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyQ29sb3JNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJfQ09MT1JNQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFySW50ZW5zaXR5TWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSX0lOVEVOU0lUWU1BUCcgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5yb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5tZXRhbG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuYWxwaGFIYXNoID8gJyNkZWZpbmUgVVNFX0FMUEhBSEFTSCcgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy50cmFuc21pc3Npb24gPyAnI2RlZmluZSBVU0VfVFJBTlNNSVNTSU9OJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy50cmFuc21pc3Npb25NYXAgPyAnI2RlZmluZSBVU0VfVFJBTlNNSVNTSU9OTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy50aGlja25lc3NNYXAgPyAnI2RlZmluZSBVU0VfVEhJQ0tORVNTTUFQJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnNoZWVuQ29sb3JNYXAgPyAnI2RlZmluZSBVU0VfU0hFRU5fQ09MT1JNQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnNoZWVuUm91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX1NIRUVOX1JPVUdITkVTU01BUCcgOiAnJyxcblxuXHRcdFx0Ly9cblxuXHRcdFx0cGFyYW1ldGVycy5tYXBVdiA/ICcjZGVmaW5lIE1BUF9VViAnICsgcGFyYW1ldGVycy5tYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5hbHBoYU1hcFV2ID8gJyNkZWZpbmUgQUxQSEFNQVBfVVYgJyArIHBhcmFtZXRlcnMuYWxwaGFNYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5saWdodE1hcFV2ID8gJyNkZWZpbmUgTElHSFRNQVBfVVYgJyArIHBhcmFtZXRlcnMubGlnaHRNYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5hb01hcFV2ID8gJyNkZWZpbmUgQU9NQVBfVVYgJyArIHBhcmFtZXRlcnMuYW9NYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZU1hcFV2ID8gJyNkZWZpbmUgRU1JU1NJVkVNQVBfVVYgJyArIHBhcmFtZXRlcnMuZW1pc3NpdmVNYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5idW1wTWFwVXYgPyAnI2RlZmluZSBCVU1QTUFQX1VWICcgKyBwYXJhbWV0ZXJzLmJ1bXBNYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXBVdiA/ICcjZGVmaW5lIE5PUk1BTE1BUF9VViAnICsgcGFyYW1ldGVycy5ub3JtYWxNYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5kaXNwbGFjZW1lbnRNYXBVdiA/ICcjZGVmaW5lIERJU1BMQUNFTUVOVE1BUF9VViAnICsgcGFyYW1ldGVycy5kaXNwbGFjZW1lbnRNYXBVdiA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLm1ldGFsbmVzc01hcFV2ID8gJyNkZWZpbmUgTUVUQUxORVNTTUFQX1VWICcgKyBwYXJhbWV0ZXJzLm1ldGFsbmVzc01hcFV2IDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnJvdWdobmVzc01hcFV2ID8gJyNkZWZpbmUgUk9VR0hORVNTTUFQX1VWICcgKyBwYXJhbWV0ZXJzLnJvdWdobmVzc01hcFV2IDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuYW5pc290cm9weU1hcFV2ID8gJyNkZWZpbmUgQU5JU09UUk9QWU1BUF9VViAnICsgcGFyYW1ldGVycy5hbmlzb3Ryb3B5TWFwVXYgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5jbGVhcmNvYXRNYXBVdiA/ICcjZGVmaW5lIENMRUFSQ09BVE1BUF9VViAnICsgcGFyYW1ldGVycy5jbGVhcmNvYXRNYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5jbGVhcmNvYXROb3JtYWxNYXBVdiA/ICcjZGVmaW5lIENMRUFSQ09BVF9OT1JNQUxNQVBfVVYgJyArIHBhcmFtZXRlcnMuY2xlYXJjb2F0Tm9ybWFsTWFwVXYgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuY2xlYXJjb2F0Um91Z2huZXNzTWFwVXYgPyAnI2RlZmluZSBDTEVBUkNPQVRfUk9VR0hORVNTTUFQX1VWICcgKyBwYXJhbWV0ZXJzLmNsZWFyY29hdFJvdWdobmVzc01hcFV2IDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuaXJpZGVzY2VuY2VNYXBVdiA/ICcjZGVmaW5lIElSSURFU0NFTkNFTUFQX1VWICcgKyBwYXJhbWV0ZXJzLmlyaWRlc2NlbmNlTWFwVXYgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdiA/ICcjZGVmaW5lIElSSURFU0NFTkNFX1RISUNLTkVTU01BUF9VViAnICsgcGFyYW1ldGVycy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcFV2IDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuc2hlZW5Db2xvck1hcFV2ID8gJyNkZWZpbmUgU0hFRU5fQ09MT1JNQVBfVVYgJyArIHBhcmFtZXRlcnMuc2hlZW5Db2xvck1hcFV2IDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnNoZWVuUm91Z2huZXNzTWFwVXYgPyAnI2RlZmluZSBTSEVFTl9ST1VHSE5FU1NNQVBfVVYgJyArIHBhcmFtZXRlcnMuc2hlZW5Sb3VnaG5lc3NNYXBVdiA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwVXYgPyAnI2RlZmluZSBTUEVDVUxBUk1BUF9VViAnICsgcGFyYW1ldGVycy5zcGVjdWxhck1hcFV2IDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyQ29sb3JNYXBVdiA/ICcjZGVmaW5lIFNQRUNVTEFSX0NPTE9STUFQX1VWICcgKyBwYXJhbWV0ZXJzLnNwZWN1bGFyQ29sb3JNYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhckludGVuc2l0eU1hcFV2ID8gJyNkZWZpbmUgU1BFQ1VMQVJfSU5URU5TSVRZTUFQX1VWICcgKyBwYXJhbWV0ZXJzLnNwZWN1bGFySW50ZW5zaXR5TWFwVXYgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy50cmFuc21pc3Npb25NYXBVdiA/ICcjZGVmaW5lIFRSQU5TTUlTU0lPTk1BUF9VViAnICsgcGFyYW1ldGVycy50cmFuc21pc3Npb25NYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy50aGlja25lc3NNYXBVdiA/ICcjZGVmaW5lIFRISUNLTkVTU01BUF9VViAnICsgcGFyYW1ldGVycy50aGlja25lc3NNYXBVdiA6ICcnLFxuXG5cdFx0XHQvL1xuXG5cdFx0XHRwYXJhbWV0ZXJzLnZlcnRleFRhbmdlbnRzICYmIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPT09IGZhbHNlID8gJyNkZWZpbmUgVVNFX1RBTkdFTlQnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyA/ICcjZGVmaW5lIFVTRV9DT0xPUicgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMudmVydGV4QWxwaGFzID8gJyNkZWZpbmUgVVNFX0NPTE9SX0FMUEhBJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhVdjFzID8gJyNkZWZpbmUgVVNFX1VWMScgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMudmVydGV4VXYycyA/ICcjZGVmaW5lIFVTRV9VVjInIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnZlcnRleFV2M3MgPyAnI2RlZmluZSBVU0VfVVYzJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnBvaW50c1V2cyA/ICcjZGVmaW5lIFVTRV9QT0lOVFNfVVYnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCcgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5za2lubmluZyA/ICcjZGVmaW5lIFVTRV9TS0lOTklORycgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPyAnI2RlZmluZSBVU0VfTU9SUEhUQVJHRVRTJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5tb3JwaE5vcm1hbHMgJiYgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA9PT0gZmFsc2UgPyAnI2RlZmluZSBVU0VfTU9SUEhOT1JNQUxTJyA6ICcnLFxuXHRcdFx0KCBwYXJhbWV0ZXJzLm1vcnBoQ29sb3JzICkgPyAnI2RlZmluZSBVU0VfTU9SUEhDT0xPUlMnIDogJycsXG5cdFx0XHQoIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzQ291bnQgPiAwICkgPyAnI2RlZmluZSBNT1JQSFRBUkdFVFNfVEVYVFVSRV9TVFJJREUgJyArIHBhcmFtZXRlcnMubW9ycGhUZXh0dXJlU3RyaWRlIDogJycsXG5cdFx0XHQoIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzQ291bnQgPiAwICkgPyAnI2RlZmluZSBNT1JQSFRBUkdFVFNfQ09VTlQgJyArIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzQ291bnQgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyAnI2RlZmluZSBET1VCTEVfU0lERUQnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnNpemVBdHRlbnVhdGlvbiA/ICcjZGVmaW5lIFVTRV9TSVpFQVRURU5VQVRJT04nIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMubnVtTGlnaHRQcm9iZXMgPiAwID8gJyNkZWZpbmUgVVNFX0xJR0hUX1BST0JFUycgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5yZXZlcnNlRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfUkVWRVJTRURFUFRIQlVGJyA6ICcnLFxuXG5cdFx0XHQndW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4OycsXG5cdFx0XHQndW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDsnLFxuXHRcdFx0J3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXG5cdFx0XHQndW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7Jyxcblx0XHRcdCd1bmlmb3JtIG1hdDMgbm9ybWFsTWF0cml4OycsXG5cdFx0XHQndW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOycsXG5cdFx0XHQndW5pZm9ybSBib29sIGlzT3J0aG9ncmFwaGljOycsXG5cblx0XHRcdCcjaWZkZWYgVVNFX0lOU1RBTkNJTkcnLFxuXG5cdFx0XHQnXHRhdHRyaWJ1dGUgbWF0NCBpbnN0YW5jZU1hdHJpeDsnLFxuXG5cdFx0XHQnI2VuZGlmJyxcblxuXHRcdFx0JyNpZmRlZiBVU0VfSU5TVEFOQ0lOR19DT0xPUicsXG5cblx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlQ29sb3I7JyxcblxuXHRcdFx0JyNlbmRpZicsXG5cblx0XHRcdCcjaWZkZWYgVVNFX0lOU1RBTkNJTkdfTU9SUEgnLFxuXG5cdFx0XHQnXHR1bmlmb3JtIHNhbXBsZXIyRCBtb3JwaFRleHR1cmU7JyxcblxuXHRcdFx0JyNlbmRpZicsXG5cblx0XHRcdCdhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjsnLFxuXHRcdFx0J2F0dHJpYnV0ZSB2ZWMzIG5vcm1hbDsnLFxuXHRcdFx0J2F0dHJpYnV0ZSB2ZWMyIHV2OycsXG5cblx0XHRcdCcjaWZkZWYgVVNFX1VWMScsXG5cblx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMyIHV2MTsnLFxuXG5cdFx0XHQnI2VuZGlmJyxcblxuXHRcdFx0JyNpZmRlZiBVU0VfVVYyJyxcblxuXHRcdFx0J1x0YXR0cmlidXRlIHZlYzIgdXYyOycsXG5cblx0XHRcdCcjZW5kaWYnLFxuXG5cdFx0XHQnI2lmZGVmIFVTRV9VVjMnLFxuXG5cdFx0XHQnXHRhdHRyaWJ1dGUgdmVjMiB1djM7JyxcblxuXHRcdFx0JyNlbmRpZicsXG5cblx0XHRcdCcjaWZkZWYgVVNFX1RBTkdFTlQnLFxuXG5cdFx0XHQnXHRhdHRyaWJ1dGUgdmVjNCB0YW5nZW50OycsXG5cblx0XHRcdCcjZW5kaWYnLFxuXG5cdFx0XHQnI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApJyxcblxuXHRcdFx0J1x0YXR0cmlidXRlIHZlYzQgY29sb3I7JyxcblxuXHRcdFx0JyNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApJyxcblxuXHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgY29sb3I7JyxcblxuXHRcdFx0JyNlbmRpZicsXG5cblx0XHRcdCcjaWZkZWYgVVNFX1NLSU5OSU5HJyxcblxuXHRcdFx0J1x0YXR0cmlidXRlIHZlYzQgc2tpbkluZGV4OycsXG5cdFx0XHQnXHRhdHRyaWJ1dGUgdmVjNCBza2luV2VpZ2h0OycsXG5cblx0XHRcdCcjZW5kaWYnLFxuXG5cdFx0XHQnXFxuJ1xuXG5cdFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XG5cblx0XHRwcmVmaXhGcmFnbWVudCA9IFtcblxuXHRcdFx0Z2VuZXJhdGVQcmVjaXNpb24oIHBhcmFtZXRlcnMgKSxcblxuXHRcdFx0JyNkZWZpbmUgU0hBREVSX1RZUEUgJyArIHBhcmFtZXRlcnMuc2hhZGVyVHlwZSxcblx0XHRcdCcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBwYXJhbWV0ZXJzLnNoYWRlck5hbWUsXG5cblx0XHRcdGN1c3RvbURlZmluZXMsXG5cblx0XHRcdHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nID8gJyNkZWZpbmUgVVNFX0ZPRycgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nRXhwMiA/ICcjZGVmaW5lIEZPR19FWFAyJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmFscGhhVG9Db3ZlcmFnZSA/ICcjZGVmaW5lIEFMUEhBX1RPX0NPVkVSQUdFJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5tYXRjYXAgPyAnI2RlZmluZSBVU0VfTUFUQ0FQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwVHlwZURlZmluZSA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwQmxlbmRpbmdEZWZpbmUgOiAnJyxcblx0XHRcdGVudk1hcEN1YmVVVlNpemUgPyAnI2RlZmluZSBDVUJFVVZfVEVYRUxfV0lEVEggJyArIGVudk1hcEN1YmVVVlNpemUudGV4ZWxXaWR0aCA6ICcnLFxuXHRcdFx0ZW52TWFwQ3ViZVVWU2l6ZSA/ICcjZGVmaW5lIENVQkVVVl9URVhFTF9IRUlHSFQgJyArIGVudk1hcEN1YmVVVlNpemUudGV4ZWxIZWlnaHQgOiAnJyxcblx0XHRcdGVudk1hcEN1YmVVVlNpemUgPyAnI2RlZmluZSBDVUJFVVZfTUFYX01JUCAnICsgZW52TWFwQ3ViZVVWU2l6ZS5tYXhNaXAgKyAnLjAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5hb01hcCA/ICcjZGVmaW5lIFVTRV9BT01BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuYnVtcE1hcCA/ICcjZGVmaW5lIFVTRV9CVU1QTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXBPYmplY3RTcGFjZSA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVBfT0JKRUNUU1BBQ0UnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcFRhbmdlbnRTcGFjZSA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZU1hcCA/ICcjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUCcgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5hbmlzb3Ryb3B5ID8gJyNkZWZpbmUgVVNFX0FOSVNPVFJPUFknIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmFuaXNvdHJvcHlNYXAgPyAnI2RlZmluZSBVU0VfQU5JU09UUk9QWU1BUCcgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5jbGVhcmNvYXQgPyAnI2RlZmluZSBVU0VfQ0xFQVJDT0FUJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5jbGVhcmNvYXRNYXAgPyAnI2RlZmluZSBVU0VfQ0xFQVJDT0FUTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuY2xlYXJjb2F0Tm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuZGlzcGVyc2lvbiA/ICcjZGVmaW5lIFVTRV9ESVNQRVJTSU9OJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmlyaWRlc2NlbmNlID8gJyNkZWZpbmUgVVNFX0lSSURFU0NFTkNFJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5pcmlkZXNjZW5jZU1hcCA/ICcjZGVmaW5lIFVTRV9JUklERVNDRU5DRU1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgPyAnI2RlZmluZSBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhckNvbG9yTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSX0NPTE9STUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhckludGVuc2l0eU1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUl9JTlRFTlNJVFlNQVAnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMucm91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX1JPVUdITkVTU01BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwID8gJyNkZWZpbmUgVVNFX01FVEFMTkVTU01BUCcgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuYWxwaGFUZXN0ID8gJyNkZWZpbmUgVVNFX0FMUEhBVEVTVCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuYWxwaGFIYXNoID8gJyNkZWZpbmUgVVNFX0FMUEhBSEFTSCcgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5zaGVlbiA/ICcjZGVmaW5lIFVTRV9TSEVFTicgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuc2hlZW5Db2xvck1hcCA/ICcjZGVmaW5lIFVTRV9TSEVFTl9DT0xPUk1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuc2hlZW5Sb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfU0hFRU5fUk9VR0hORVNTTUFQJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnRyYW5zbWlzc2lvbiA/ICcjZGVmaW5lIFVTRV9UUkFOU01JU1NJT04nIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnRyYW5zbWlzc2lvbk1hcCA/ICcjZGVmaW5lIFVTRV9UUkFOU01JU1NJT05NQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnRoaWNrbmVzc01hcCA/ICcjZGVmaW5lIFVTRV9USElDS05FU1NNQVAnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMudmVydGV4VGFuZ2VudHMgJiYgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA9PT0gZmFsc2UgPyAnI2RlZmluZSBVU0VfVEFOR0VOVCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzIHx8IHBhcmFtZXRlcnMuaW5zdGFuY2luZ0NvbG9yIHx8IHBhcmFtZXRlcnMuYmF0Y2hpbmdDb2xvciA/ICcjZGVmaW5lIFVTRV9DT0xPUicgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMudmVydGV4QWxwaGFzID8gJyNkZWZpbmUgVVNFX0NPTE9SX0FMUEhBJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhVdjFzID8gJyNkZWZpbmUgVVNFX1VWMScgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMudmVydGV4VXYycyA/ICcjZGVmaW5lIFVTRV9VVjInIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnZlcnRleFV2M3MgPyAnI2RlZmluZSBVU0VfVVYzJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnBvaW50c1V2cyA/ICcjZGVmaW5lIFVTRV9QT0lOVFNfVVYnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuZ3JhZGllbnRNYXAgPyAnI2RlZmluZSBVU0VfR1JBRElFTlRNQVAnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCcgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuZmxpcFNpZGVkID8gJyNkZWZpbmUgRkxJUF9TSURFRCcgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgVVNFX1NIQURPV01BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhID8gJyNkZWZpbmUgUFJFTVVMVElQTElFRF9BTFBIQScgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5udW1MaWdodFByb2JlcyA+IDAgPyAnI2RlZmluZSBVU0VfTElHSFRfUFJPQkVTJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmRlY29kZVZpZGVvVGV4dHVyZSA/ICcjZGVmaW5lIERFQ09ERV9WSURFT19URVhUVVJFJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5kZWNvZGVWaWRlb1RleHR1cmVFbWlzc2l2ZSA/ICcjZGVmaW5lIERFQ09ERV9WSURFT19URVhUVVJFX0VNSVNTSVZFJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnJldmVyc2VEZXB0aEJ1ZmZlciA/ICcjZGVmaW5lIFVTRV9SRVZFUlNFREVQVEhCVUYnIDogJycsXG5cblx0XHRcdCd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLFxuXHRcdFx0J3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxuXHRcdFx0J3VuaWZvcm0gYm9vbCBpc09ydGhvZ3JhcGhpYzsnLFxuXG5cdFx0XHQoIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgIT09IE5vVG9uZU1hcHBpbmcgKSA/ICcjZGVmaW5lIFRPTkVfTUFQUElORycgOiAnJyxcblx0XHRcdCggcGFyYW1ldGVycy50b25lTWFwcGluZyAhPT0gTm9Ub25lTWFwcGluZyApID8gU2hhZGVyQ2h1bmtbICd0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50JyBdIDogJycsIC8vIHRoaXMgY29kZSBpcyByZXF1aXJlZCBoZXJlIGJlY2F1c2UgaXQgaXMgdXNlZCBieSB0aGUgdG9uZU1hcHBpbmcoKSBmdW5jdGlvbiBkZWZpbmVkIGJlbG93XG5cdFx0XHQoIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgIT09IE5vVG9uZU1hcHBpbmcgKSA/IGdldFRvbmVNYXBwaW5nRnVuY3Rpb24oICd0b25lTWFwcGluZycsIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgKSA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmRpdGhlcmluZyA/ICcjZGVmaW5lIERJVEhFUklORycgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMub3BhcXVlID8gJyNkZWZpbmUgT1BBUVVFJyA6ICcnLFxuXG5cdFx0XHRTaGFkZXJDaHVua1sgJ2NvbG9yc3BhY2VfcGFyc19mcmFnbWVudCcgXSwgLy8gdGhpcyBjb2RlIGlzIHJlcXVpcmVkIGhlcmUgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IHRoZSB2YXJpb3VzIGVuY29kaW5nL2RlY29kaW5nIGZ1bmN0aW9uIGRlZmluZWQgYmVsb3dcblx0XHRcdGdldFRleGVsRW5jb2RpbmdGdW5jdGlvbiggJ2xpbmVhclRvT3V0cHV0VGV4ZWwnLCBwYXJhbWV0ZXJzLm91dHB1dENvbG9yU3BhY2UgKSxcblx0XHRcdGdldEx1bWluYW5jZUZ1bmN0aW9uKCksXG5cblx0XHRcdHBhcmFtZXRlcnMudXNlRGVwdGhQYWNraW5nID8gJyNkZWZpbmUgREVQVEhfUEFDS0lORyAnICsgcGFyYW1ldGVycy5kZXB0aFBhY2tpbmcgOiAnJyxcblxuXHRcdFx0J1xcbidcblxuXHRcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xuXG5cdH1cblxuXHR2ZXJ0ZXhTaGFkZXIgPSByZXNvbHZlSW5jbHVkZXMoIHZlcnRleFNoYWRlciApO1xuXHR2ZXJ0ZXhTaGFkZXIgPSByZXBsYWNlTGlnaHROdW1zKCB2ZXJ0ZXhTaGFkZXIsIHBhcmFtZXRlcnMgKTtcblx0dmVydGV4U2hhZGVyID0gcmVwbGFjZUNsaXBwaW5nUGxhbmVOdW1zKCB2ZXJ0ZXhTaGFkZXIsIHBhcmFtZXRlcnMgKTtcblxuXHRmcmFnbWVudFNoYWRlciA9IHJlc29sdmVJbmNsdWRlcyggZnJhZ21lbnRTaGFkZXIgKTtcblx0ZnJhZ21lbnRTaGFkZXIgPSByZXBsYWNlTGlnaHROdW1zKCBmcmFnbWVudFNoYWRlciwgcGFyYW1ldGVycyApO1xuXHRmcmFnbWVudFNoYWRlciA9IHJlcGxhY2VDbGlwcGluZ1BsYW5lTnVtcyggZnJhZ21lbnRTaGFkZXIsIHBhcmFtZXRlcnMgKTtcblxuXHR2ZXJ0ZXhTaGFkZXIgPSB1bnJvbGxMb29wcyggdmVydGV4U2hhZGVyICk7XG5cdGZyYWdtZW50U2hhZGVyID0gdW5yb2xsTG9vcHMoIGZyYWdtZW50U2hhZGVyICk7XG5cblx0aWYgKCBwYXJhbWV0ZXJzLmlzUmF3U2hhZGVyTWF0ZXJpYWwgIT09IHRydWUgKSB7XG5cblx0XHQvLyBHTFNMIDMuMCBjb252ZXJzaW9uIGZvciBidWlsdC1pbiBtYXRlcmlhbHMgYW5kIFNoYWRlck1hdGVyaWFsXG5cblx0XHR2ZXJzaW9uU3RyaW5nID0gJyN2ZXJzaW9uIDMwMCBlc1xcbic7XG5cblx0XHRwcmVmaXhWZXJ0ZXggPSBbXG5cdFx0XHRjdXN0b21WZXJ0ZXhFeHRlbnNpb25zLFxuXHRcdFx0JyNkZWZpbmUgYXR0cmlidXRlIGluJyxcblx0XHRcdCcjZGVmaW5lIHZhcnlpbmcgb3V0Jyxcblx0XHRcdCcjZGVmaW5lIHRleHR1cmUyRCB0ZXh0dXJlJ1xuXHRcdF0uam9pbiggJ1xcbicgKSArICdcXG4nICsgcHJlZml4VmVydGV4O1xuXG5cdFx0cHJlZml4RnJhZ21lbnQgPSBbXG5cdFx0XHQnI2RlZmluZSB2YXJ5aW5nIGluJyxcblx0XHRcdCggcGFyYW1ldGVycy5nbHNsVmVyc2lvbiA9PT0gR0xTTDMgKSA/ICcnIDogJ2xheW91dChsb2NhdGlvbiA9IDApIG91dCBoaWdocCB2ZWM0IHBjX2ZyYWdDb2xvcjsnLFxuXHRcdFx0KCBwYXJhbWV0ZXJzLmdsc2xWZXJzaW9uID09PSBHTFNMMyApID8gJycgOiAnI2RlZmluZSBnbF9GcmFnQ29sb3IgcGNfZnJhZ0NvbG9yJyxcblx0XHRcdCcjZGVmaW5lIGdsX0ZyYWdEZXB0aEVYVCBnbF9GcmFnRGVwdGgnLFxuXHRcdFx0JyNkZWZpbmUgdGV4dHVyZTJEIHRleHR1cmUnLFxuXHRcdFx0JyNkZWZpbmUgdGV4dHVyZUN1YmUgdGV4dHVyZScsXG5cdFx0XHQnI2RlZmluZSB0ZXh0dXJlMkRQcm9qIHRleHR1cmVQcm9qJyxcblx0XHRcdCcjZGVmaW5lIHRleHR1cmUyRExvZEVYVCB0ZXh0dXJlTG9kJyxcblx0XHRcdCcjZGVmaW5lIHRleHR1cmUyRFByb2pMb2RFWFQgdGV4dHVyZVByb2pMb2QnLFxuXHRcdFx0JyNkZWZpbmUgdGV4dHVyZUN1YmVMb2RFWFQgdGV4dHVyZUxvZCcsXG5cdFx0XHQnI2RlZmluZSB0ZXh0dXJlMkRHcmFkRVhUIHRleHR1cmVHcmFkJyxcblx0XHRcdCcjZGVmaW5lIHRleHR1cmUyRFByb2pHcmFkRVhUIHRleHR1cmVQcm9qR3JhZCcsXG5cdFx0XHQnI2RlZmluZSB0ZXh0dXJlQ3ViZUdyYWRFWFQgdGV4dHVyZUdyYWQnXG5cdFx0XS5qb2luKCAnXFxuJyApICsgJ1xcbicgKyBwcmVmaXhGcmFnbWVudDtcblxuXHR9XG5cblx0Y29uc3QgdmVydGV4R2xzbCA9IHZlcnNpb25TdHJpbmcgKyBwcmVmaXhWZXJ0ZXggKyB2ZXJ0ZXhTaGFkZXI7XG5cdGNvbnN0IGZyYWdtZW50R2xzbCA9IHZlcnNpb25TdHJpbmcgKyBwcmVmaXhGcmFnbWVudCArIGZyYWdtZW50U2hhZGVyO1xuXG5cdC8vIGNvbnNvbGUubG9nKCAnKlZFUlRFWConLCB2ZXJ0ZXhHbHNsICk7XG5cdC8vIGNvbnNvbGUubG9nKCAnKkZSQUdNRU5UKicsIGZyYWdtZW50R2xzbCApO1xuXG5cdGNvbnN0IGdsVmVydGV4U2hhZGVyID0gV2ViR0xTaGFkZXIoIGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhHbHNsICk7XG5cdGNvbnN0IGdsRnJhZ21lbnRTaGFkZXIgPSBXZWJHTFNoYWRlciggZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRHbHNsICk7XG5cblx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbFZlcnRleFNoYWRlciApO1xuXHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuXHQvLyBGb3JjZSBhIHBhcnRpY3VsYXIgYXR0cmlidXRlIHRvIGluZGV4IDAuXG5cblx0aWYgKCBwYXJhbWV0ZXJzLmluZGV4MEF0dHJpYnV0ZU5hbWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGdsLmJpbmRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgMCwgcGFyYW1ldGVycy5pbmRleDBBdHRyaWJ1dGVOYW1lICk7XG5cblx0fSBlbHNlIGlmICggcGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPT09IHRydWUgKSB7XG5cblx0XHQvLyBwcm9ncmFtcyB3aXRoIG1vcnBoVGFyZ2V0cyBkaXNwbGFjZSBwb3NpdGlvbiBvdXQgb2YgYXR0cmlidXRlIDBcblx0XHRnbC5iaW5kQXR0cmliTG9jYXRpb24oIHByb2dyYW0sIDAsICdwb3NpdGlvbicgKTtcblxuXHR9XG5cblx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblxuXHRmdW5jdGlvbiBvbkZpcnN0VXNlKCBzZWxmICkge1xuXG5cdFx0Ly8gY2hlY2sgZm9yIGxpbmsgZXJyb3JzXG5cdFx0aWYgKCByZW5kZXJlci5kZWJ1Zy5jaGVja1NoYWRlckVycm9ycyApIHtcblxuXHRcdFx0Y29uc3QgcHJvZ3JhbUxvZyA9IGdsLmdldFByb2dyYW1JbmZvTG9nKCBwcm9ncmFtICkudHJpbSgpO1xuXHRcdFx0Y29uc3QgdmVydGV4TG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggZ2xWZXJ0ZXhTaGFkZXIgKS50cmltKCk7XG5cdFx0XHRjb25zdCBmcmFnbWVudExvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coIGdsRnJhZ21lbnRTaGFkZXIgKS50cmltKCk7XG5cblx0XHRcdGxldCBydW5uYWJsZSA9IHRydWU7XG5cdFx0XHRsZXQgaGF2ZURpYWdub3N0aWNzID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRydW5uYWJsZSA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmICggdHlwZW9mIHJlbmRlcmVyLmRlYnVnLm9uU2hhZGVyRXJyb3IgPT09ICdmdW5jdGlvbicgKSB7XG5cblx0XHRcdFx0XHRyZW5kZXJlci5kZWJ1Zy5vblNoYWRlckVycm9yKCBnbCwgcHJvZ3JhbSwgZ2xWZXJ0ZXhTaGFkZXIsIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gZGVmYXVsdCBlcnJvciByZXBvcnRpbmdcblxuXHRcdFx0XHRcdGNvbnN0IHZlcnRleEVycm9ycyA9IGdldFNoYWRlckVycm9ycyggZ2wsIGdsVmVydGV4U2hhZGVyLCAndmVydGV4JyApO1xuXHRcdFx0XHRcdGNvbnN0IGZyYWdtZW50RXJyb3JzID0gZ2V0U2hhZGVyRXJyb3JzKCBnbCwgZ2xGcmFnbWVudFNoYWRlciwgJ2ZyYWdtZW50JyApO1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0XHRcdCdUSFJFRS5XZWJHTFByb2dyYW06IFNoYWRlciBFcnJvciAnICsgZ2wuZ2V0RXJyb3IoKSArICcgLSAnICtcblx0XHRcdFx0XHRcdCdWQUxJREFURV9TVEFUVVMgJyArIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUyApICsgJ1xcblxcbicgK1xuXHRcdFx0XHRcdFx0J01hdGVyaWFsIE5hbWU6ICcgKyBzZWxmLm5hbWUgKyAnXFxuJyArXG5cdFx0XHRcdFx0XHQnTWF0ZXJpYWwgVHlwZTogJyArIHNlbGYudHlwZSArICdcXG5cXG4nICtcblx0XHRcdFx0XHRcdCdQcm9ncmFtIEluZm8gTG9nOiAnICsgcHJvZ3JhbUxvZyArICdcXG4nICtcblx0XHRcdFx0XHRcdHZlcnRleEVycm9ycyArICdcXG4nICtcblx0XHRcdFx0XHRcdGZyYWdtZW50RXJyb3JzXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIHByb2dyYW1Mb2cgIT09ICcnICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogUHJvZ3JhbSBJbmZvIExvZzonLCBwcm9ncmFtTG9nICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHZlcnRleExvZyA9PT0gJycgfHwgZnJhZ21lbnRMb2cgPT09ICcnICkge1xuXG5cdFx0XHRcdGhhdmVEaWFnbm9zdGljcyA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGF2ZURpYWdub3N0aWNzICkge1xuXG5cdFx0XHRcdHNlbGYuZGlhZ25vc3RpY3MgPSB7XG5cblx0XHRcdFx0XHRydW5uYWJsZTogcnVubmFibGUsXG5cblx0XHRcdFx0XHRwcm9ncmFtTG9nOiBwcm9ncmFtTG9nLFxuXG5cdFx0XHRcdFx0dmVydGV4U2hhZGVyOiB7XG5cblx0XHRcdFx0XHRcdGxvZzogdmVydGV4TG9nLFxuXHRcdFx0XHRcdFx0cHJlZml4OiBwcmVmaXhWZXJ0ZXhcblxuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRmcmFnbWVudFNoYWRlcjoge1xuXG5cdFx0XHRcdFx0XHRsb2c6IGZyYWdtZW50TG9nLFxuXHRcdFx0XHRcdFx0cHJlZml4OiBwcmVmaXhGcmFnbWVudFxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIENsZWFuIHVwXG5cblx0XHQvLyBDcmFzaGVzIGluIGlPUzkgYW5kIGlPUzEwLiAjMTg0MDJcblx0XHQvLyBnbC5kZXRhY2hTaGFkZXIoIHByb2dyYW0sIGdsVmVydGV4U2hhZGVyICk7XG5cdFx0Ly8gZ2wuZGV0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbEZyYWdtZW50U2hhZGVyICk7XG5cblx0XHRnbC5kZWxldGVTaGFkZXIoIGdsVmVydGV4U2hhZGVyICk7XG5cdFx0Z2wuZGVsZXRlU2hhZGVyKCBnbEZyYWdtZW50U2hhZGVyICk7XG5cblx0XHRjYWNoZWRVbmlmb3JtcyA9IG5ldyBXZWJHTFVuaWZvcm1zKCBnbCwgcHJvZ3JhbSApO1xuXHRcdGNhY2hlZEF0dHJpYnV0ZXMgPSBmZXRjaEF0dHJpYnV0ZUxvY2F0aW9ucyggZ2wsIHByb2dyYW0gKTtcblxuXHR9XG5cblx0Ly8gc2V0IHVwIGNhY2hpbmcgZm9yIHVuaWZvcm0gbG9jYXRpb25zXG5cblx0bGV0IGNhY2hlZFVuaWZvcm1zO1xuXG5cdHRoaXMuZ2V0VW5pZm9ybXMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIGNhY2hlZFVuaWZvcm1zID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFBvcHVsYXRlcyBjYWNoZWRVbmlmb3JtcyBhbmQgY2FjaGVkQXR0cmlidXRlc1xuXHRcdFx0b25GaXJzdFVzZSggdGhpcyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNhY2hlZFVuaWZvcm1zO1xuXG5cdH07XG5cblx0Ly8gc2V0IHVwIGNhY2hpbmcgZm9yIGF0dHJpYnV0ZSBsb2NhdGlvbnNcblxuXHRsZXQgY2FjaGVkQXR0cmlidXRlcztcblxuXHR0aGlzLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIGNhY2hlZEF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gUG9wdWxhdGVzIGNhY2hlZEF0dHJpYnV0ZXMgYW5kIGNhY2hlZFVuaWZvcm1zXG5cdFx0XHRvbkZpcnN0VXNlKCB0aGlzICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY2FjaGVkQXR0cmlidXRlcztcblxuXHR9O1xuXG5cdC8vIGluZGljYXRlIHdoZW4gdGhlIHByb2dyYW0gaXMgcmVhZHkgdG8gYmUgdXNlZC4gaWYgdGhlIEtIUl9wYXJhbGxlbF9zaGFkZXJfY29tcGlsZSBleHRlbnNpb24gaXNuJ3Qgc3VwcG9ydGVkLFxuXHQvLyBmbGFnIHRoZSBwcm9ncmFtIGFzIHJlYWR5IGltbWVkaWF0ZWx5LiBJdCBtYXkgY2F1c2UgYSBzdGFsbCB3aGVuIGl0J3MgZmlyc3QgdXNlZC5cblxuXHRsZXQgcHJvZ3JhbVJlYWR5ID0gKCBwYXJhbWV0ZXJzLnJlbmRlcmVyRXh0ZW5zaW9uUGFyYWxsZWxTaGFkZXJDb21waWxlID09PSBmYWxzZSApO1xuXG5cdHRoaXMuaXNSZWFkeSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGlmICggcHJvZ3JhbVJlYWR5ID09PSBmYWxzZSApIHtcblxuXHRcdFx0cHJvZ3JhbVJlYWR5ID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgQ09NUExFVElPTl9TVEFUVVNfS0hSICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcHJvZ3JhbVJlYWR5O1xuXG5cdH07XG5cblx0Ly8gZnJlZSByZXNvdXJjZVxuXG5cdHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGJpbmRpbmdTdGF0ZXMucmVsZWFzZVN0YXRlc09mUHJvZ3JhbSggdGhpcyApO1xuXG5cdFx0Z2wuZGVsZXRlUHJvZ3JhbSggcHJvZ3JhbSApO1xuXHRcdHRoaXMucHJvZ3JhbSA9IHVuZGVmaW5lZDtcblxuXHR9O1xuXG5cdC8vXG5cblx0dGhpcy50eXBlID0gcGFyYW1ldGVycy5zaGFkZXJUeXBlO1xuXHR0aGlzLm5hbWUgPSBwYXJhbWV0ZXJzLnNoYWRlck5hbWU7XG5cdHRoaXMuaWQgPSBwcm9ncmFtSWRDb3VudCArKztcblx0dGhpcy5jYWNoZUtleSA9IGNhY2hlS2V5O1xuXHR0aGlzLnVzZWRUaW1lcyA9IDE7XG5cdHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG5cdHRoaXMudmVydGV4U2hhZGVyID0gZ2xWZXJ0ZXhTaGFkZXI7XG5cdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBnbEZyYWdtZW50U2hhZGVyO1xuXG5cdHJldHVybiB0aGlzO1xuXG59XG5cbmxldCBfaWQgPSAwO1xuXG5jbGFzcyBXZWJHTFNoYWRlckNhY2hlIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMuc2hhZGVyQ2FjaGUgPSBuZXcgTWFwKCk7XG5cdFx0dGhpcy5tYXRlcmlhbENhY2hlID0gbmV3IE1hcCgpO1xuXG5cdH1cblxuXHR1cGRhdGUoIG1hdGVyaWFsICkge1xuXG5cdFx0Y29uc3QgdmVydGV4U2hhZGVyID0gbWF0ZXJpYWwudmVydGV4U2hhZGVyO1xuXHRcdGNvbnN0IGZyYWdtZW50U2hhZGVyID0gbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXI7XG5cblx0XHRjb25zdCB2ZXJ0ZXhTaGFkZXJTdGFnZSA9IHRoaXMuX2dldFNoYWRlclN0YWdlKCB2ZXJ0ZXhTaGFkZXIgKTtcblx0XHRjb25zdCBmcmFnbWVudFNoYWRlclN0YWdlID0gdGhpcy5fZ2V0U2hhZGVyU3RhZ2UoIGZyYWdtZW50U2hhZGVyICk7XG5cblx0XHRjb25zdCBtYXRlcmlhbFNoYWRlcnMgPSB0aGlzLl9nZXRTaGFkZXJDYWNoZUZvck1hdGVyaWFsKCBtYXRlcmlhbCApO1xuXG5cdFx0aWYgKCBtYXRlcmlhbFNoYWRlcnMuaGFzKCB2ZXJ0ZXhTaGFkZXJTdGFnZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0bWF0ZXJpYWxTaGFkZXJzLmFkZCggdmVydGV4U2hhZGVyU3RhZ2UgKTtcblx0XHRcdHZlcnRleFNoYWRlclN0YWdlLnVzZWRUaW1lcyArKztcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWxTaGFkZXJzLmhhcyggZnJhZ21lbnRTaGFkZXJTdGFnZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0bWF0ZXJpYWxTaGFkZXJzLmFkZCggZnJhZ21lbnRTaGFkZXJTdGFnZSApO1xuXHRcdFx0ZnJhZ21lbnRTaGFkZXJTdGFnZS51c2VkVGltZXMgKys7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmVtb3ZlKCBtYXRlcmlhbCApIHtcblxuXHRcdGNvbnN0IG1hdGVyaWFsU2hhZGVycyA9IHRoaXMubWF0ZXJpYWxDYWNoZS5nZXQoIG1hdGVyaWFsICk7XG5cblx0XHRmb3IgKCBjb25zdCBzaGFkZXJTdGFnZSBvZiBtYXRlcmlhbFNoYWRlcnMgKSB7XG5cblx0XHRcdHNoYWRlclN0YWdlLnVzZWRUaW1lcyAtLTtcblxuXHRcdFx0aWYgKCBzaGFkZXJTdGFnZS51c2VkVGltZXMgPT09IDAgKSB0aGlzLnNoYWRlckNhY2hlLmRlbGV0ZSggc2hhZGVyU3RhZ2UuY29kZSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5tYXRlcmlhbENhY2hlLmRlbGV0ZSggbWF0ZXJpYWwgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRWZXJ0ZXhTaGFkZXJJRCggbWF0ZXJpYWwgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fZ2V0U2hhZGVyU3RhZ2UoIG1hdGVyaWFsLnZlcnRleFNoYWRlciApLmlkO1xuXG5cdH1cblxuXHRnZXRGcmFnbWVudFNoYWRlcklEKCBtYXRlcmlhbCApIHtcblxuXHRcdHJldHVybiB0aGlzLl9nZXRTaGFkZXJTdGFnZSggbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgKS5pZDtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuc2hhZGVyQ2FjaGUuY2xlYXIoKTtcblx0XHR0aGlzLm1hdGVyaWFsQ2FjaGUuY2xlYXIoKTtcblxuXHR9XG5cblx0X2dldFNoYWRlckNhY2hlRm9yTWF0ZXJpYWwoIG1hdGVyaWFsICkge1xuXG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLm1hdGVyaWFsQ2FjaGU7XG5cdFx0bGV0IHNldCA9IGNhY2hlLmdldCggbWF0ZXJpYWwgKTtcblxuXHRcdGlmICggc2V0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHNldCA9IG5ldyBTZXQoKTtcblx0XHRcdGNhY2hlLnNldCggbWF0ZXJpYWwsIHNldCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNldDtcblxuXHR9XG5cblx0X2dldFNoYWRlclN0YWdlKCBjb2RlICkge1xuXG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLnNoYWRlckNhY2hlO1xuXHRcdGxldCBzdGFnZSA9IGNhY2hlLmdldCggY29kZSApO1xuXG5cdFx0aWYgKCBzdGFnZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRzdGFnZSA9IG5ldyBXZWJHTFNoYWRlclN0YWdlKCBjb2RlICk7XG5cdFx0XHRjYWNoZS5zZXQoIGNvZGUsIHN0YWdlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gc3RhZ2U7XG5cblx0fVxuXG59XG5cbmNsYXNzIFdlYkdMU2hhZGVyU3RhZ2Uge1xuXG5cdGNvbnN0cnVjdG9yKCBjb2RlICkge1xuXG5cdFx0dGhpcy5pZCA9IF9pZCArKztcblxuXHRcdHRoaXMuY29kZSA9IGNvZGU7XG5cdFx0dGhpcy51c2VkVGltZXMgPSAwO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBXZWJHTFByb2dyYW1zKCByZW5kZXJlciwgY3ViZW1hcHMsIGN1YmV1dm1hcHMsIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcywgYmluZGluZ1N0YXRlcywgY2xpcHBpbmcgKSB7XG5cblx0Y29uc3QgX3Byb2dyYW1MYXllcnMgPSBuZXcgTGF5ZXJzKCk7XG5cdGNvbnN0IF9jdXN0b21TaGFkZXJzID0gbmV3IFdlYkdMU2hhZGVyQ2FjaGUoKTtcblx0Y29uc3QgX2FjdGl2ZUNoYW5uZWxzID0gbmV3IFNldCgpO1xuXHRjb25zdCBwcm9ncmFtcyA9IFtdO1xuXG5cdGNvbnN0IGxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSBjYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjtcblx0Y29uc3QgU1VQUE9SVFNfVkVSVEVYX1RFWFRVUkVTID0gY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzO1xuXG5cdGxldCBwcmVjaXNpb24gPSBjYXBhYmlsaXRpZXMucHJlY2lzaW9uO1xuXG5cdGNvbnN0IHNoYWRlcklEcyA9IHtcblx0XHRNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcblx0XHRNZXNoRGlzdGFuY2VNYXRlcmlhbDogJ2Rpc3RhbmNlUkdCQScsXG5cdFx0TWVzaE5vcm1hbE1hdGVyaWFsOiAnbm9ybWFsJyxcblx0XHRNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcblx0XHRNZXNoTGFtYmVydE1hdGVyaWFsOiAnbGFtYmVydCcsXG5cdFx0TWVzaFBob25nTWF0ZXJpYWw6ICdwaG9uZycsXG5cdFx0TWVzaFRvb25NYXRlcmlhbDogJ3Rvb24nLFxuXHRcdE1lc2hTdGFuZGFyZE1hdGVyaWFsOiAncGh5c2ljYWwnLFxuXHRcdE1lc2hQaHlzaWNhbE1hdGVyaWFsOiAncGh5c2ljYWwnLFxuXHRcdE1lc2hNYXRjYXBNYXRlcmlhbDogJ21hdGNhcCcsXG5cdFx0TGluZUJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXG5cdFx0TGluZURhc2hlZE1hdGVyaWFsOiAnZGFzaGVkJyxcblx0XHRQb2ludHNNYXRlcmlhbDogJ3BvaW50cycsXG5cdFx0U2hhZG93TWF0ZXJpYWw6ICdzaGFkb3cnLFxuXHRcdFNwcml0ZU1hdGVyaWFsOiAnc3ByaXRlJ1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGdldENoYW5uZWwoIHZhbHVlICkge1xuXG5cdFx0X2FjdGl2ZUNoYW5uZWxzLmFkZCggdmFsdWUgKTtcblxuXHRcdGlmICggdmFsdWUgPT09IDAgKSByZXR1cm4gJ3V2JztcblxuXHRcdHJldHVybiBgdXYkeyB2YWx1ZSB9YDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UGFyYW1ldGVycyggbWF0ZXJpYWwsIGxpZ2h0cywgc2hhZG93cywgc2NlbmUsIG9iamVjdCApIHtcblxuXHRcdGNvbnN0IGZvZyA9IHNjZW5lLmZvZztcblx0XHRjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblx0XHRjb25zdCBlbnZpcm9ubWVudCA9IG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPyBzY2VuZS5lbnZpcm9ubWVudCA6IG51bGw7XG5cblx0XHRjb25zdCBlbnZNYXAgPSAoIG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPyBjdWJldXZtYXBzIDogY3ViZW1hcHMgKS5nZXQoIG1hdGVyaWFsLmVudk1hcCB8fCBlbnZpcm9ubWVudCApO1xuXHRcdGNvbnN0IGVudk1hcEN1YmVVVkhlaWdodCA9ICggISEgZW52TWFwICkgJiYgKCBlbnZNYXAubWFwcGluZyA9PT0gQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcgKSA/IGVudk1hcC5pbWFnZS5oZWlnaHQgOiBudWxsO1xuXG5cdFx0Y29uc3Qgc2hhZGVySUQgPSBzaGFkZXJJRHNbIG1hdGVyaWFsLnR5cGUgXTtcblxuXHRcdC8vIGhldXJpc3RpY3MgdG8gY3JlYXRlIHNoYWRlciBwYXJhbWV0ZXJzIGFjY29yZGluZyB0byBsaWdodHMgaW4gdGhlIHNjZW5lXG5cdFx0Ly8gKG5vdCB0byBibG93IG92ZXIgbWF4TGlnaHRzIGJ1ZGdldClcblxuXHRcdGlmICggbWF0ZXJpYWwucHJlY2lzaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRwcmVjaXNpb24gPSBjYXBhYmlsaXRpZXMuZ2V0TWF4UHJlY2lzaW9uKCBtYXRlcmlhbC5wcmVjaXNpb24gKTtcblxuXHRcdFx0aWYgKCBwcmVjaXNpb24gIT09IG1hdGVyaWFsLnByZWNpc2lvbiApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW0uZ2V0UGFyYW1ldGVyczonLCBtYXRlcmlhbC5wcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIHByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gfHwgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCB8fCBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3I7XG5cdFx0Y29uc3QgbW9ycGhUYXJnZXRzQ291bnQgPSAoIG1vcnBoQXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSA/IG1vcnBoQXR0cmlidXRlLmxlbmd0aCA6IDA7XG5cblx0XHRsZXQgbW9ycGhUZXh0dXJlU3RyaWRlID0gMDtcblxuXHRcdGlmICggZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSBtb3JwaFRleHR1cmVTdHJpZGUgPSAxO1xuXHRcdGlmICggZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCAhPT0gdW5kZWZpbmVkICkgbW9ycGhUZXh0dXJlU3RyaWRlID0gMjtcblx0XHRpZiAoIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkICkgbW9ycGhUZXh0dXJlU3RyaWRlID0gMztcblxuXHRcdC8vXG5cblx0XHRsZXQgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcjtcblx0XHRsZXQgY3VzdG9tVmVydGV4U2hhZGVySUQsIGN1c3RvbUZyYWdtZW50U2hhZGVySUQ7XG5cblx0XHRpZiAoIHNoYWRlcklEICkge1xuXG5cdFx0XHRjb25zdCBzaGFkZXIgPSBTaGFkZXJMaWJbIHNoYWRlcklEIF07XG5cblx0XHRcdHZlcnRleFNoYWRlciA9IHNoYWRlci52ZXJ0ZXhTaGFkZXI7XG5cdFx0XHRmcmFnbWVudFNoYWRlciA9IHNoYWRlci5mcmFnbWVudFNoYWRlcjtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHZlcnRleFNoYWRlciA9IG1hdGVyaWFsLnZlcnRleFNoYWRlcjtcblx0XHRcdGZyYWdtZW50U2hhZGVyID0gbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXI7XG5cblx0XHRcdF9jdXN0b21TaGFkZXJzLnVwZGF0ZSggbWF0ZXJpYWwgKTtcblxuXHRcdFx0Y3VzdG9tVmVydGV4U2hhZGVySUQgPSBfY3VzdG9tU2hhZGVycy5nZXRWZXJ0ZXhTaGFkZXJJRCggbWF0ZXJpYWwgKTtcblx0XHRcdGN1c3RvbUZyYWdtZW50U2hhZGVySUQgPSBfY3VzdG9tU2hhZGVycy5nZXRGcmFnbWVudFNoYWRlcklEKCBtYXRlcmlhbCApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuXHRcdGNvbnN0IHJldmVyc2VEZXB0aEJ1ZmZlciA9IHJlbmRlcmVyLnN0YXRlLmJ1ZmZlcnMuZGVwdGguZ2V0UmV2ZXJzZWQoKTtcblxuXHRcdGNvbnN0IElTX0lOU1RBTkNFRE1FU0ggPSBvYmplY3QuaXNJbnN0YW5jZWRNZXNoID09PSB0cnVlO1xuXHRcdGNvbnN0IElTX0JBVENIRURNRVNIID0gb2JqZWN0LmlzQmF0Y2hlZE1lc2ggPT09IHRydWU7XG5cblx0XHRjb25zdCBIQVNfTUFQID0gISEgbWF0ZXJpYWwubWFwO1xuXHRcdGNvbnN0IEhBU19NQVRDQVAgPSAhISBtYXRlcmlhbC5tYXRjYXA7XG5cdFx0Y29uc3QgSEFTX0VOVk1BUCA9ICEhIGVudk1hcDtcblx0XHRjb25zdCBIQVNfQU9NQVAgPSAhISBtYXRlcmlhbC5hb01hcDtcblx0XHRjb25zdCBIQVNfTElHSFRNQVAgPSAhISBtYXRlcmlhbC5saWdodE1hcDtcblx0XHRjb25zdCBIQVNfQlVNUE1BUCA9ICEhIG1hdGVyaWFsLmJ1bXBNYXA7XG5cdFx0Y29uc3QgSEFTX05PUk1BTE1BUCA9ICEhIG1hdGVyaWFsLm5vcm1hbE1hcDtcblx0XHRjb25zdCBIQVNfRElTUExBQ0VNRU5UTUFQID0gISEgbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xuXHRcdGNvbnN0IEhBU19FTUlTU0lWRU1BUCA9ICEhIG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xuXG5cdFx0Y29uc3QgSEFTX01FVEFMTkVTU01BUCA9ICEhIG1hdGVyaWFsLm1ldGFsbmVzc01hcDtcblx0XHRjb25zdCBIQVNfUk9VR0hORVNTTUFQID0gISEgbWF0ZXJpYWwucm91Z2huZXNzTWFwO1xuXG5cdFx0Y29uc3QgSEFTX0FOSVNPVFJPUFkgPSBtYXRlcmlhbC5hbmlzb3Ryb3B5ID4gMDtcblx0XHRjb25zdCBIQVNfQ0xFQVJDT0FUID0gbWF0ZXJpYWwuY2xlYXJjb2F0ID4gMDtcblx0XHRjb25zdCBIQVNfRElTUEVSU0lPTiA9IG1hdGVyaWFsLmRpc3BlcnNpb24gPiAwO1xuXHRcdGNvbnN0IEhBU19JUklERVNDRU5DRSA9IG1hdGVyaWFsLmlyaWRlc2NlbmNlID4gMDtcblx0XHRjb25zdCBIQVNfU0hFRU4gPSBtYXRlcmlhbC5zaGVlbiA+IDA7XG5cdFx0Y29uc3QgSEFTX1RSQU5TTUlTU0lPTiA9IG1hdGVyaWFsLnRyYW5zbWlzc2lvbiA+IDA7XG5cblx0XHRjb25zdCBIQVNfQU5JU09UUk9QWU1BUCA9IEhBU19BTklTT1RST1BZICYmICEhIG1hdGVyaWFsLmFuaXNvdHJvcHlNYXA7XG5cblx0XHRjb25zdCBIQVNfQ0xFQVJDT0FUTUFQID0gSEFTX0NMRUFSQ09BVCAmJiAhISBtYXRlcmlhbC5jbGVhcmNvYXRNYXA7XG5cdFx0Y29uc3QgSEFTX0NMRUFSQ09BVF9OT1JNQUxNQVAgPSBIQVNfQ0xFQVJDT0FUICYmICEhIG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcDtcblx0XHRjb25zdCBIQVNfQ0xFQVJDT0FUX1JPVUdITkVTU01BUCA9IEhBU19DTEVBUkNPQVQgJiYgISEgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzTWFwO1xuXG5cdFx0Y29uc3QgSEFTX0lSSURFU0NFTkNFTUFQID0gSEFTX0lSSURFU0NFTkNFICYmICEhIG1hdGVyaWFsLmlyaWRlc2NlbmNlTWFwO1xuXHRcdGNvbnN0IEhBU19JUklERVNDRU5DRV9USElDS05FU1NNQVAgPSBIQVNfSVJJREVTQ0VOQ0UgJiYgISEgbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3NNYXA7XG5cblx0XHRjb25zdCBIQVNfU0hFRU5fQ09MT1JNQVAgPSBIQVNfU0hFRU4gJiYgISEgbWF0ZXJpYWwuc2hlZW5Db2xvck1hcDtcblx0XHRjb25zdCBIQVNfU0hFRU5fUk9VR0hORVNTTUFQID0gSEFTX1NIRUVOICYmICEhIG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzTWFwO1xuXG5cdFx0Y29uc3QgSEFTX1NQRUNVTEFSTUFQID0gISEgbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XG5cdFx0Y29uc3QgSEFTX1NQRUNVTEFSX0NPTE9STUFQID0gISEgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvck1hcDtcblx0XHRjb25zdCBIQVNfU1BFQ1VMQVJfSU5URU5TSVRZTUFQID0gISEgbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHlNYXA7XG5cblx0XHRjb25zdCBIQVNfVFJBTlNNSVNTSU9OTUFQID0gSEFTX1RSQU5TTUlTU0lPTiAmJiAhISBtYXRlcmlhbC50cmFuc21pc3Npb25NYXA7XG5cdFx0Y29uc3QgSEFTX1RISUNLTkVTU01BUCA9IEhBU19UUkFOU01JU1NJT04gJiYgISEgbWF0ZXJpYWwudGhpY2tuZXNzTWFwO1xuXG5cdFx0Y29uc3QgSEFTX0dSQURJRU5UTUFQID0gISEgbWF0ZXJpYWwuZ3JhZGllbnRNYXA7XG5cblx0XHRjb25zdCBIQVNfQUxQSEFNQVAgPSAhISBtYXRlcmlhbC5hbHBoYU1hcDtcblxuXHRcdGNvbnN0IEhBU19BTFBIQVRFU1QgPSBtYXRlcmlhbC5hbHBoYVRlc3QgPiAwO1xuXG5cdFx0Y29uc3QgSEFTX0FMUEhBSEFTSCA9ICEhIG1hdGVyaWFsLmFscGhhSGFzaDtcblxuXHRcdGNvbnN0IEhBU19FWFRFTlNJT05TID0gISEgbWF0ZXJpYWwuZXh0ZW5zaW9ucztcblxuXHRcdGxldCB0b25lTWFwcGluZyA9IE5vVG9uZU1hcHBpbmc7XG5cblx0XHRpZiAoIG1hdGVyaWFsLnRvbmVNYXBwZWQgKSB7XG5cblx0XHRcdGlmICggY3VycmVudFJlbmRlclRhcmdldCA9PT0gbnVsbCB8fCBjdXJyZW50UmVuZGVyVGFyZ2V0LmlzWFJSZW5kZXJUYXJnZXQgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0dG9uZU1hcHBpbmcgPSByZW5kZXJlci50b25lTWFwcGluZztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcGFyYW1ldGVycyA9IHtcblxuXHRcdFx0c2hhZGVySUQ6IHNoYWRlcklELFxuXHRcdFx0c2hhZGVyVHlwZTogbWF0ZXJpYWwudHlwZSxcblx0XHRcdHNoYWRlck5hbWU6IG1hdGVyaWFsLm5hbWUsXG5cblx0XHRcdHZlcnRleFNoYWRlcjogdmVydGV4U2hhZGVyLFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50U2hhZGVyLFxuXHRcdFx0ZGVmaW5lczogbWF0ZXJpYWwuZGVmaW5lcyxcblxuXHRcdFx0Y3VzdG9tVmVydGV4U2hhZGVySUQ6IGN1c3RvbVZlcnRleFNoYWRlcklELFxuXHRcdFx0Y3VzdG9tRnJhZ21lbnRTaGFkZXJJRDogY3VzdG9tRnJhZ21lbnRTaGFkZXJJRCxcblxuXHRcdFx0aXNSYXdTaGFkZXJNYXRlcmlhbDogbWF0ZXJpYWwuaXNSYXdTaGFkZXJNYXRlcmlhbCA9PT0gdHJ1ZSxcblx0XHRcdGdsc2xWZXJzaW9uOiBtYXRlcmlhbC5nbHNsVmVyc2lvbixcblxuXHRcdFx0cHJlY2lzaW9uOiBwcmVjaXNpb24sXG5cblx0XHRcdGJhdGNoaW5nOiBJU19CQVRDSEVETUVTSCxcblx0XHRcdGJhdGNoaW5nQ29sb3I6IElTX0JBVENIRURNRVNIICYmIG9iamVjdC5fY29sb3JzVGV4dHVyZSAhPT0gbnVsbCxcblx0XHRcdGluc3RhbmNpbmc6IElTX0lOU1RBTkNFRE1FU0gsXG5cdFx0XHRpbnN0YW5jaW5nQ29sb3I6IElTX0lOU1RBTkNFRE1FU0ggJiYgb2JqZWN0Lmluc3RhbmNlQ29sb3IgIT09IG51bGwsXG5cdFx0XHRpbnN0YW5jaW5nTW9ycGg6IElTX0lOU1RBTkNFRE1FU0ggJiYgb2JqZWN0Lm1vcnBoVGV4dHVyZSAhPT0gbnVsbCxcblxuXHRcdFx0c3VwcG9ydHNWZXJ0ZXhUZXh0dXJlczogU1VQUE9SVFNfVkVSVEVYX1RFWFRVUkVTLFxuXHRcdFx0b3V0cHV0Q29sb3JTcGFjZTogKCBjdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsICkgPyByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlIDogKCBjdXJyZW50UmVuZGVyVGFyZ2V0LmlzWFJSZW5kZXJUYXJnZXQgPT09IHRydWUgPyBjdXJyZW50UmVuZGVyVGFyZ2V0LnRleHR1cmUuY29sb3JTcGFjZSA6IExpbmVhclNSR0JDb2xvclNwYWNlICksXG5cdFx0XHRhbHBoYVRvQ292ZXJhZ2U6ICEhIG1hdGVyaWFsLmFscGhhVG9Db3ZlcmFnZSxcblxuXHRcdFx0bWFwOiBIQVNfTUFQLFxuXHRcdFx0bWF0Y2FwOiBIQVNfTUFUQ0FQLFxuXHRcdFx0ZW52TWFwOiBIQVNfRU5WTUFQLFxuXHRcdFx0ZW52TWFwTW9kZTogSEFTX0VOVk1BUCAmJiBlbnZNYXAubWFwcGluZyxcblx0XHRcdGVudk1hcEN1YmVVVkhlaWdodDogZW52TWFwQ3ViZVVWSGVpZ2h0LFxuXHRcdFx0YW9NYXA6IEhBU19BT01BUCxcblx0XHRcdGxpZ2h0TWFwOiBIQVNfTElHSFRNQVAsXG5cdFx0XHRidW1wTWFwOiBIQVNfQlVNUE1BUCxcblx0XHRcdG5vcm1hbE1hcDogSEFTX05PUk1BTE1BUCxcblx0XHRcdGRpc3BsYWNlbWVudE1hcDogU1VQUE9SVFNfVkVSVEVYX1RFWFRVUkVTICYmIEhBU19ESVNQTEFDRU1FTlRNQVAsXG5cdFx0XHRlbWlzc2l2ZU1hcDogSEFTX0VNSVNTSVZFTUFQLFxuXG5cdFx0XHRub3JtYWxNYXBPYmplY3RTcGFjZTogSEFTX05PUk1BTE1BUCAmJiBtYXRlcmlhbC5ub3JtYWxNYXBUeXBlID09PSBPYmplY3RTcGFjZU5vcm1hbE1hcCxcblx0XHRcdG5vcm1hbE1hcFRhbmdlbnRTcGFjZTogSEFTX05PUk1BTE1BUCAmJiBtYXRlcmlhbC5ub3JtYWxNYXBUeXBlID09PSBUYW5nZW50U3BhY2VOb3JtYWxNYXAsXG5cblx0XHRcdG1ldGFsbmVzc01hcDogSEFTX01FVEFMTkVTU01BUCxcblx0XHRcdHJvdWdobmVzc01hcDogSEFTX1JPVUdITkVTU01BUCxcblxuXHRcdFx0YW5pc290cm9weTogSEFTX0FOSVNPVFJPUFksXG5cdFx0XHRhbmlzb3Ryb3B5TWFwOiBIQVNfQU5JU09UUk9QWU1BUCxcblxuXHRcdFx0Y2xlYXJjb2F0OiBIQVNfQ0xFQVJDT0FULFxuXHRcdFx0Y2xlYXJjb2F0TWFwOiBIQVNfQ0xFQVJDT0FUTUFQLFxuXHRcdFx0Y2xlYXJjb2F0Tm9ybWFsTWFwOiBIQVNfQ0xFQVJDT0FUX05PUk1BTE1BUCxcblx0XHRcdGNsZWFyY29hdFJvdWdobmVzc01hcDogSEFTX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAsXG5cblx0XHRcdGRpc3BlcnNpb246IEhBU19ESVNQRVJTSU9OLFxuXG5cdFx0XHRpcmlkZXNjZW5jZTogSEFTX0lSSURFU0NFTkNFLFxuXHRcdFx0aXJpZGVzY2VuY2VNYXA6IEhBU19JUklERVNDRU5DRU1BUCxcblx0XHRcdGlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwOiBIQVNfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQLFxuXG5cdFx0XHRzaGVlbjogSEFTX1NIRUVOLFxuXHRcdFx0c2hlZW5Db2xvck1hcDogSEFTX1NIRUVOX0NPTE9STUFQLFxuXHRcdFx0c2hlZW5Sb3VnaG5lc3NNYXA6IEhBU19TSEVFTl9ST1VHSE5FU1NNQVAsXG5cblx0XHRcdHNwZWN1bGFyTWFwOiBIQVNfU1BFQ1VMQVJNQVAsXG5cdFx0XHRzcGVjdWxhckNvbG9yTWFwOiBIQVNfU1BFQ1VMQVJfQ09MT1JNQVAsXG5cdFx0XHRzcGVjdWxhckludGVuc2l0eU1hcDogSEFTX1NQRUNVTEFSX0lOVEVOU0lUWU1BUCxcblxuXHRcdFx0dHJhbnNtaXNzaW9uOiBIQVNfVFJBTlNNSVNTSU9OLFxuXHRcdFx0dHJhbnNtaXNzaW9uTWFwOiBIQVNfVFJBTlNNSVNTSU9OTUFQLFxuXHRcdFx0dGhpY2tuZXNzTWFwOiBIQVNfVEhJQ0tORVNTTUFQLFxuXG5cdFx0XHRncmFkaWVudE1hcDogSEFTX0dSQURJRU5UTUFQLFxuXG5cdFx0XHRvcGFxdWU6IG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSBmYWxzZSAmJiBtYXRlcmlhbC5ibGVuZGluZyA9PT0gTm9ybWFsQmxlbmRpbmcgJiYgbWF0ZXJpYWwuYWxwaGFUb0NvdmVyYWdlID09PSBmYWxzZSxcblxuXHRcdFx0YWxwaGFNYXA6IEhBU19BTFBIQU1BUCxcblx0XHRcdGFscGhhVGVzdDogSEFTX0FMUEhBVEVTVCxcblx0XHRcdGFscGhhSGFzaDogSEFTX0FMUEhBSEFTSCxcblxuXHRcdFx0Y29tYmluZTogbWF0ZXJpYWwuY29tYmluZSxcblxuXHRcdFx0Ly9cblxuXHRcdFx0bWFwVXY6IEhBU19NQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwubWFwLmNoYW5uZWwgKSxcblx0XHRcdGFvTWFwVXY6IEhBU19BT01BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5hb01hcC5jaGFubmVsICksXG5cdFx0XHRsaWdodE1hcFV2OiBIQVNfTElHSFRNQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwubGlnaHRNYXAuY2hhbm5lbCApLFxuXHRcdFx0YnVtcE1hcFV2OiBIQVNfQlVNUE1BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5idW1wTWFwLmNoYW5uZWwgKSxcblx0XHRcdG5vcm1hbE1hcFV2OiBIQVNfTk9STUFMTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLm5vcm1hbE1hcC5jaGFubmVsICksXG5cdFx0XHRkaXNwbGFjZW1lbnRNYXBVdjogSEFTX0RJU1BMQUNFTUVOVE1BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAuY2hhbm5lbCApLFxuXHRcdFx0ZW1pc3NpdmVNYXBVdjogSEFTX0VNSVNTSVZFTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLmVtaXNzaXZlTWFwLmNoYW5uZWwgKSxcblxuXHRcdFx0bWV0YWxuZXNzTWFwVXY6IEhBU19NRVRBTE5FU1NNQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwubWV0YWxuZXNzTWFwLmNoYW5uZWwgKSxcblx0XHRcdHJvdWdobmVzc01hcFV2OiBIQVNfUk9VR0hORVNTTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLnJvdWdobmVzc01hcC5jaGFubmVsICksXG5cblx0XHRcdGFuaXNvdHJvcHlNYXBVdjogSEFTX0FOSVNPVFJPUFlNQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwuYW5pc290cm9weU1hcC5jaGFubmVsICksXG5cblx0XHRcdGNsZWFyY29hdE1hcFV2OiBIQVNfQ0xFQVJDT0FUTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLmNsZWFyY29hdE1hcC5jaGFubmVsICksXG5cdFx0XHRjbGVhcmNvYXROb3JtYWxNYXBVdjogSEFTX0NMRUFSQ09BVF9OT1JNQUxNQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsTWFwLmNoYW5uZWwgKSxcblx0XHRcdGNsZWFyY29hdFJvdWdobmVzc01hcFV2OiBIQVNfQ0xFQVJDT0FUX1JPVUdITkVTU01BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXAuY2hhbm5lbCApLFxuXG5cdFx0XHRpcmlkZXNjZW5jZU1hcFV2OiBIQVNfSVJJREVTQ0VOQ0VNQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwuaXJpZGVzY2VuY2VNYXAuY2hhbm5lbCApLFxuXHRcdFx0aXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdjogSEFTX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcC5jaGFubmVsICksXG5cblx0XHRcdHNoZWVuQ29sb3JNYXBVdjogSEFTX1NIRUVOX0NPTE9STUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLnNoZWVuQ29sb3JNYXAuY2hhbm5lbCApLFxuXHRcdFx0c2hlZW5Sb3VnaG5lc3NNYXBVdjogSEFTX1NIRUVOX1JPVUdITkVTU01BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5zaGVlblJvdWdobmVzc01hcC5jaGFubmVsICksXG5cblx0XHRcdHNwZWN1bGFyTWFwVXY6IEhBU19TUEVDVUxBUk1BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5zcGVjdWxhck1hcC5jaGFubmVsICksXG5cdFx0XHRzcGVjdWxhckNvbG9yTWFwVXY6IEhBU19TUEVDVUxBUl9DT0xPUk1BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwLmNoYW5uZWwgKSxcblx0XHRcdHNwZWN1bGFySW50ZW5zaXR5TWFwVXY6IEhBU19TUEVDVUxBUl9JTlRFTlNJVFlNQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHlNYXAuY2hhbm5lbCApLFxuXG5cdFx0XHR0cmFuc21pc3Npb25NYXBVdjogSEFTX1RSQU5TTUlTU0lPTk1BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC50cmFuc21pc3Npb25NYXAuY2hhbm5lbCApLFxuXHRcdFx0dGhpY2tuZXNzTWFwVXY6IEhBU19USElDS05FU1NNQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwudGhpY2tuZXNzTWFwLmNoYW5uZWwgKSxcblxuXHRcdFx0YWxwaGFNYXBVdjogSEFTX0FMUEhBTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLmFscGhhTWFwLmNoYW5uZWwgKSxcblxuXHRcdFx0Ly9cblxuXHRcdFx0dmVydGV4VGFuZ2VudHM6ICEhIGdlb21ldHJ5LmF0dHJpYnV0ZXMudGFuZ2VudCAmJiAoIEhBU19OT1JNQUxNQVAgfHwgSEFTX0FOSVNPVFJPUFkgKSxcblx0XHRcdHZlcnRleENvbG9yczogbWF0ZXJpYWwudmVydGV4Q29sb3JzLFxuXHRcdFx0dmVydGV4QWxwaGFzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPT09IHRydWUgJiYgISEgZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvciAmJiBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLml0ZW1TaXplID09PSA0LFxuXG5cdFx0XHRwb2ludHNVdnM6IG9iamVjdC5pc1BvaW50cyA9PT0gdHJ1ZSAmJiAhISBnZW9tZXRyeS5hdHRyaWJ1dGVzLnV2ICYmICggSEFTX01BUCB8fCBIQVNfQUxQSEFNQVAgKSxcblxuXHRcdFx0Zm9nOiAhISBmb2csXG5cdFx0XHR1c2VGb2c6IG1hdGVyaWFsLmZvZyA9PT0gdHJ1ZSxcblx0XHRcdGZvZ0V4cDI6ICggISEgZm9nICYmIGZvZy5pc0ZvZ0V4cDIgKSxcblxuXHRcdFx0ZmxhdFNoYWRpbmc6IG1hdGVyaWFsLmZsYXRTaGFkaW5nID09PSB0cnVlLFxuXG5cdFx0XHRzaXplQXR0ZW51YXRpb246IG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9PT0gdHJ1ZSxcblx0XHRcdGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6IGxvZ2FyaXRobWljRGVwdGhCdWZmZXIsXG5cdFx0XHRyZXZlcnNlRGVwdGhCdWZmZXI6IHJldmVyc2VEZXB0aEJ1ZmZlcixcblxuXHRcdFx0c2tpbm5pbmc6IG9iamVjdC5pc1NraW5uZWRNZXNoID09PSB0cnVlLFxuXG5cdFx0XHRtb3JwaFRhcmdldHM6IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkLFxuXHRcdFx0bW9ycGhOb3JtYWxzOiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQsXG5cdFx0XHRtb3JwaENvbG9yczogZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQsXG5cdFx0XHRtb3JwaFRhcmdldHNDb3VudDogbW9ycGhUYXJnZXRzQ291bnQsXG5cdFx0XHRtb3JwaFRleHR1cmVTdHJpZGU6IG1vcnBoVGV4dHVyZVN0cmlkZSxcblxuXHRcdFx0bnVtRGlyTGlnaHRzOiBsaWdodHMuZGlyZWN0aW9uYWwubGVuZ3RoLFxuXHRcdFx0bnVtUG9pbnRMaWdodHM6IGxpZ2h0cy5wb2ludC5sZW5ndGgsXG5cdFx0XHRudW1TcG90TGlnaHRzOiBsaWdodHMuc3BvdC5sZW5ndGgsXG5cdFx0XHRudW1TcG90TGlnaHRNYXBzOiBsaWdodHMuc3BvdExpZ2h0TWFwLmxlbmd0aCxcblx0XHRcdG51bVJlY3RBcmVhTGlnaHRzOiBsaWdodHMucmVjdEFyZWEubGVuZ3RoLFxuXHRcdFx0bnVtSGVtaUxpZ2h0czogbGlnaHRzLmhlbWkubGVuZ3RoLFxuXG5cdFx0XHRudW1EaXJMaWdodFNoYWRvd3M6IGxpZ2h0cy5kaXJlY3Rpb25hbFNoYWRvd01hcC5sZW5ndGgsXG5cdFx0XHRudW1Qb2ludExpZ2h0U2hhZG93czogbGlnaHRzLnBvaW50U2hhZG93TWFwLmxlbmd0aCxcblx0XHRcdG51bVNwb3RMaWdodFNoYWRvd3M6IGxpZ2h0cy5zcG90U2hhZG93TWFwLmxlbmd0aCxcblx0XHRcdG51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwczogbGlnaHRzLm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcyxcblxuXHRcdFx0bnVtTGlnaHRQcm9iZXM6IGxpZ2h0cy5udW1MaWdodFByb2JlcyxcblxuXHRcdFx0bnVtQ2xpcHBpbmdQbGFuZXM6IGNsaXBwaW5nLm51bVBsYW5lcyxcblx0XHRcdG51bUNsaXBJbnRlcnNlY3Rpb246IGNsaXBwaW5nLm51bUludGVyc2VjdGlvbixcblxuXHRcdFx0ZGl0aGVyaW5nOiBtYXRlcmlhbC5kaXRoZXJpbmcsXG5cblx0XHRcdHNoYWRvd01hcEVuYWJsZWQ6IHJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkICYmIHNoYWRvd3MubGVuZ3RoID4gMCxcblx0XHRcdHNoYWRvd01hcFR5cGU6IHJlbmRlcmVyLnNoYWRvd01hcC50eXBlLFxuXG5cdFx0XHR0b25lTWFwcGluZzogdG9uZU1hcHBpbmcsXG5cblx0XHRcdGRlY29kZVZpZGVvVGV4dHVyZTogSEFTX01BUCAmJiAoIG1hdGVyaWFsLm1hcC5pc1ZpZGVvVGV4dHVyZSA9PT0gdHJ1ZSApICYmICggQ29sb3JNYW5hZ2VtZW50LmdldFRyYW5zZmVyKCBtYXRlcmlhbC5tYXAuY29sb3JTcGFjZSApID09PSBTUkdCVHJhbnNmZXIgKSxcblx0XHRcdGRlY29kZVZpZGVvVGV4dHVyZUVtaXNzaXZlOiBIQVNfRU1JU1NJVkVNQVAgJiYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcC5pc1ZpZGVvVGV4dHVyZSA9PT0gdHJ1ZSApICYmICggQ29sb3JNYW5hZ2VtZW50LmdldFRyYW5zZmVyKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcC5jb2xvclNwYWNlICkgPT09IFNSR0JUcmFuc2ZlciApLFxuXG5cdFx0XHRwcmVtdWx0aXBsaWVkQWxwaGE6IG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSxcblxuXHRcdFx0ZG91YmxlU2lkZWQ6IG1hdGVyaWFsLnNpZGUgPT09IERvdWJsZVNpZGUsXG5cdFx0XHRmbGlwU2lkZWQ6IG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlLFxuXG5cdFx0XHR1c2VEZXB0aFBhY2tpbmc6IG1hdGVyaWFsLmRlcHRoUGFja2luZyA+PSAwLFxuXHRcdFx0ZGVwdGhQYWNraW5nOiBtYXRlcmlhbC5kZXB0aFBhY2tpbmcgfHwgMCxcblxuXHRcdFx0aW5kZXgwQXR0cmlidXRlTmFtZTogbWF0ZXJpYWwuaW5kZXgwQXR0cmlidXRlTmFtZSxcblxuXHRcdFx0ZXh0ZW5zaW9uQ2xpcEN1bGxEaXN0YW5jZTogSEFTX0VYVEVOU0lPTlMgJiYgbWF0ZXJpYWwuZXh0ZW5zaW9ucy5jbGlwQ3VsbERpc3RhbmNlID09PSB0cnVlICYmIGV4dGVuc2lvbnMuaGFzKCAnV0VCR0xfY2xpcF9jdWxsX2Rpc3RhbmNlJyApLFxuXHRcdFx0ZXh0ZW5zaW9uTXVsdGlEcmF3OiAoIEhBU19FWFRFTlNJT05TICYmIG1hdGVyaWFsLmV4dGVuc2lvbnMubXVsdGlEcmF3ID09PSB0cnVlIHx8IElTX0JBVENIRURNRVNIICkgJiYgZXh0ZW5zaW9ucy5oYXMoICdXRUJHTF9tdWx0aV9kcmF3JyApLFxuXG5cdFx0XHRyZW5kZXJlckV4dGVuc2lvblBhcmFsbGVsU2hhZGVyQ29tcGlsZTogZXh0ZW5zaW9ucy5oYXMoICdLSFJfcGFyYWxsZWxfc2hhZGVyX2NvbXBpbGUnICksXG5cblx0XHRcdGN1c3RvbVByb2dyYW1DYWNoZUtleTogbWF0ZXJpYWwuY3VzdG9tUHJvZ3JhbUNhY2hlS2V5KClcblxuXHRcdH07XG5cblx0XHQvLyB0aGUgdXNhZ2Ugb2YgZ2V0Q2hhbm5lbCgpIGRldGVybWluZXMgdGhlIGFjdGl2ZSB0ZXh0dXJlIGNoYW5uZWxzIGZvciB0aGlzIHNoYWRlclxuXG5cdFx0cGFyYW1ldGVycy52ZXJ0ZXhVdjFzID0gX2FjdGl2ZUNoYW5uZWxzLmhhcyggMSApO1xuXHRcdHBhcmFtZXRlcnMudmVydGV4VXYycyA9IF9hY3RpdmVDaGFubmVscy5oYXMoIDIgKTtcblx0XHRwYXJhbWV0ZXJzLnZlcnRleFV2M3MgPSBfYWN0aXZlQ2hhbm5lbHMuaGFzKCAzICk7XG5cblx0XHRfYWN0aXZlQ2hhbm5lbHMuY2xlYXIoKTtcblxuXHRcdHJldHVybiBwYXJhbWV0ZXJzO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRQcm9ncmFtQ2FjaGVLZXkoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRjb25zdCBhcnJheSA9IFtdO1xuXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnNoYWRlcklEICkge1xuXG5cdFx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnNoYWRlcklEICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmN1c3RvbVZlcnRleFNoYWRlcklEICk7XG5cdFx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmN1c3RvbUZyYWdtZW50U2hhZGVySUQgKTtcblxuXHRcdH1cblxuXHRcdGlmICggcGFyYW1ldGVycy5kZWZpbmVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gcGFyYW1ldGVycy5kZWZpbmVzICkge1xuXG5cdFx0XHRcdGFycmF5LnB1c2goIG5hbWUgKTtcblx0XHRcdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5kZWZpbmVzWyBuYW1lIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmlzUmF3U2hhZGVyTWF0ZXJpYWwgPT09IGZhbHNlICkge1xuXG5cdFx0XHRnZXRQcm9ncmFtQ2FjaGVLZXlQYXJhbWV0ZXJzKCBhcnJheSwgcGFyYW1ldGVycyApO1xuXHRcdFx0Z2V0UHJvZ3JhbUNhY2hlS2V5Qm9vbGVhbnMoIGFycmF5LCBwYXJhbWV0ZXJzICk7XG5cdFx0XHRhcnJheS5wdXNoKCByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlICk7XG5cblx0XHR9XG5cblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmN1c3RvbVByb2dyYW1DYWNoZUtleSApO1xuXG5cdFx0cmV0dXJuIGFycmF5LmpvaW4oKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UHJvZ3JhbUNhY2hlS2V5UGFyYW1ldGVycyggYXJyYXksIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnByZWNpc2lvbiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMub3V0cHV0Q29sb3JTcGFjZSApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuZW52TWFwTW9kZSApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuZW52TWFwQ3ViZVVWSGVpZ2h0ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5tYXBVdiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuYWxwaGFNYXBVdiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubGlnaHRNYXBVdiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuYW9NYXBVdiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuYnVtcE1hcFV2ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5ub3JtYWxNYXBVdiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwVXYgKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwVXYgKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLm1ldGFsbmVzc01hcFV2ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5yb3VnaG5lc3NNYXBVdiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuYW5pc290cm9weU1hcFV2ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5jbGVhcmNvYXRNYXBVdiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuY2xlYXJjb2F0Tm9ybWFsTWFwVXYgKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmNsZWFyY29hdFJvdWdobmVzc01hcFV2ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5pcmlkZXNjZW5jZU1hcFV2ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcFV2ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5zaGVlbkNvbG9yTWFwVXYgKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnNoZWVuUm91Z2huZXNzTWFwVXYgKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwVXYgKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnNwZWN1bGFyQ29sb3JNYXBVdiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuc3BlY3VsYXJJbnRlbnNpdHlNYXBVdiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMudHJhbnNtaXNzaW9uTWFwVXYgKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnRoaWNrbmVzc01hcFV2ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5jb21iaW5lICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5mb2dFeHAyICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5zaXplQXR0ZW51YXRpb24gKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0c0NvdW50ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5tb3JwaEF0dHJpYnV0ZUNvdW50ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5udW1EaXJMaWdodHMgKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLm51bVBvaW50TGlnaHRzICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5udW1TcG90TGlnaHRzICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5udW1TcG90TGlnaHRNYXBzICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5udW1IZW1pTGlnaHRzICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5udW1SZWN0QXJlYUxpZ2h0cyApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubnVtRGlyTGlnaHRTaGFkb3dzICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5udW1Qb2ludExpZ2h0U2hhZG93cyApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0U2hhZG93cyApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0U2hhZG93c1dpdGhNYXBzICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5udW1MaWdodFByb2JlcyApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLm51bUNsaXBwaW5nUGxhbmVzICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5udW1DbGlwSW50ZXJzZWN0aW9uICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5kZXB0aFBhY2tpbmcgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UHJvZ3JhbUNhY2hlS2V5Qm9vbGVhbnMoIGFycmF5LCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0X3Byb2dyYW1MYXllcnMuZGlzYWJsZUFsbCgpO1xuXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAwICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmluc3RhbmNpbmcgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAxICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmluc3RhbmNpbmdDb2xvciApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDIgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMuaW5zdGFuY2luZ01vcnBoIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMyApO1xuXHRcdGlmICggcGFyYW1ldGVycy5tYXRjYXAgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCA0ICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmVudk1hcCApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDUgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMubm9ybWFsTWFwT2JqZWN0U3BhY2UgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCA2ICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLm5vcm1hbE1hcFRhbmdlbnRTcGFjZSApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDcgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMuY2xlYXJjb2F0IClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggOCApO1xuXHRcdGlmICggcGFyYW1ldGVycy5pcmlkZXNjZW5jZSApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDkgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMuYWxwaGFUZXN0IClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTAgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMudmVydGV4Q29sb3JzIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTEgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMudmVydGV4QWxwaGFzIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTIgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMudmVydGV4VXYxcyApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDEzICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnZlcnRleFV2MnMgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAxNCApO1xuXHRcdGlmICggcGFyYW1ldGVycy52ZXJ0ZXhVdjNzIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTUgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMudmVydGV4VGFuZ2VudHMgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAxNiApO1xuXHRcdGlmICggcGFyYW1ldGVycy5hbmlzb3Ryb3B5IClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTcgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMuYWxwaGFIYXNoIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTggKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMuYmF0Y2hpbmcgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAxOSApO1xuXHRcdGlmICggcGFyYW1ldGVycy5kaXNwZXJzaW9uIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMjAgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMuYmF0Y2hpbmdDb2xvciApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDIxICk7XG5cblx0XHRhcnJheS5wdXNoKCBfcHJvZ3JhbUxheWVycy5tYXNrICk7XG5cdFx0X3Byb2dyYW1MYXllcnMuZGlzYWJsZUFsbCgpO1xuXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmZvZyApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDAgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMudXNlRm9nIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMSApO1xuXHRcdGlmICggcGFyYW1ldGVycy5mbGF0U2hhZGluZyApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDIgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDMgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMucmV2ZXJzZURlcHRoQnVmZmVyIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggNCApO1xuXHRcdGlmICggcGFyYW1ldGVycy5za2lubmluZyApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDUgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggNiApO1xuXHRcdGlmICggcGFyYW1ldGVycy5tb3JwaE5vcm1hbHMgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCA3ICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLm1vcnBoQ29sb3JzIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggOCApO1xuXHRcdGlmICggcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCA5ICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAxMCApO1xuXHRcdGlmICggcGFyYW1ldGVycy5kb3VibGVTaWRlZCApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDExICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmZsaXBTaWRlZCApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDEyICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnVzZURlcHRoUGFja2luZyApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDEzICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmRpdGhlcmluZyApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDE0ICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnRyYW5zbWlzc2lvbiApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDE1ICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnNoZWVuIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTYgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMub3BhcXVlIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTcgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMucG9pbnRzVXZzIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTggKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMuZGVjb2RlVmlkZW9UZXh0dXJlIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTkgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMuZGVjb2RlVmlkZW9UZXh0dXJlRW1pc3NpdmUgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAyMCApO1xuXHRcdGlmICggcGFyYW1ldGVycy5hbHBoYVRvQ292ZXJhZ2UgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAyMSApO1xuXG5cdFx0YXJyYXkucHVzaCggX3Byb2dyYW1MYXllcnMubWFzayApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRVbmlmb3JtcyggbWF0ZXJpYWwgKSB7XG5cblx0XHRjb25zdCBzaGFkZXJJRCA9IHNoYWRlcklEc1sgbWF0ZXJpYWwudHlwZSBdO1xuXHRcdGxldCB1bmlmb3JtcztcblxuXHRcdGlmICggc2hhZGVySUQgKSB7XG5cblx0XHRcdGNvbnN0IHNoYWRlciA9IFNoYWRlckxpYlsgc2hhZGVySUQgXTtcblx0XHRcdHVuaWZvcm1zID0gVW5pZm9ybXNVdGlscy5jbG9uZSggc2hhZGVyLnVuaWZvcm1zICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR1bmlmb3JtcyA9IG1hdGVyaWFsLnVuaWZvcm1zO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVuaWZvcm1zO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBhY3F1aXJlUHJvZ3JhbSggcGFyYW1ldGVycywgY2FjaGVLZXkgKSB7XG5cblx0XHRsZXQgcHJvZ3JhbTtcblxuXHRcdC8vIENoZWNrIGlmIGNvZGUgaGFzIGJlZW4gYWxyZWFkeSBjb21waWxlZFxuXHRcdGZvciAoIGxldCBwID0gMCwgcGwgPSBwcm9ncmFtcy5sZW5ndGg7IHAgPCBwbDsgcCArKyApIHtcblxuXHRcdFx0Y29uc3QgcHJlZXhpc3RpbmdQcm9ncmFtID0gcHJvZ3JhbXNbIHAgXTtcblxuXHRcdFx0aWYgKCBwcmVleGlzdGluZ1Byb2dyYW0uY2FjaGVLZXkgPT09IGNhY2hlS2V5ICkge1xuXG5cdFx0XHRcdHByb2dyYW0gPSBwcmVleGlzdGluZ1Byb2dyYW07XG5cdFx0XHRcdCsrIHByb2dyYW0udXNlZFRpbWVzO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cHJvZ3JhbSA9IG5ldyBXZWJHTFByb2dyYW0oIHJlbmRlcmVyLCBjYWNoZUtleSwgcGFyYW1ldGVycywgYmluZGluZ1N0YXRlcyApO1xuXHRcdFx0cHJvZ3JhbXMucHVzaCggcHJvZ3JhbSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByb2dyYW07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbGVhc2VQcm9ncmFtKCBwcm9ncmFtICkge1xuXG5cdFx0aWYgKCAtLSBwcm9ncmFtLnVzZWRUaW1lcyA9PT0gMCApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGZyb20gdW5vcmRlcmVkIHNldFxuXHRcdFx0Y29uc3QgaSA9IHByb2dyYW1zLmluZGV4T2YoIHByb2dyYW0gKTtcblx0XHRcdHByb2dyYW1zWyBpIF0gPSBwcm9ncmFtc1sgcHJvZ3JhbXMubGVuZ3RoIC0gMSBdO1xuXHRcdFx0cHJvZ3JhbXMucG9wKCk7XG5cblx0XHRcdC8vIEZyZWUgV2ViR0wgcmVzb3VyY2VzXG5cdFx0XHRwcm9ncmFtLmRlc3Ryb3koKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVsZWFzZVNoYWRlckNhY2hlKCBtYXRlcmlhbCApIHtcblxuXHRcdF9jdXN0b21TaGFkZXJzLnJlbW92ZSggbWF0ZXJpYWwgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcblxuXHRcdF9jdXN0b21TaGFkZXJzLmRpc3Bvc2UoKTtcblxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRnZXRQYXJhbWV0ZXJzOiBnZXRQYXJhbWV0ZXJzLFxuXHRcdGdldFByb2dyYW1DYWNoZUtleTogZ2V0UHJvZ3JhbUNhY2hlS2V5LFxuXHRcdGdldFVuaWZvcm1zOiBnZXRVbmlmb3Jtcyxcblx0XHRhY3F1aXJlUHJvZ3JhbTogYWNxdWlyZVByb2dyYW0sXG5cdFx0cmVsZWFzZVByb2dyYW06IHJlbGVhc2VQcm9ncmFtLFxuXHRcdHJlbGVhc2VTaGFkZXJDYWNoZTogcmVsZWFzZVNoYWRlckNhY2hlLFxuXHRcdC8vIEV4cG9zZWQgZm9yIHJlc291cmNlIG1vbml0b3JpbmcgJiBlcnJvciBmZWVkYmFjayB2aWEgcmVuZGVyZXIuaW5mbzpcblx0XHRwcm9ncmFtczogcHJvZ3JhbXMsXG5cdFx0ZGlzcG9zZTogZGlzcG9zZVxuXHR9O1xuXG59XG5cbmZ1bmN0aW9uIFdlYkdMUHJvcGVydGllcygpIHtcblxuXHRsZXQgcHJvcGVydGllcyA9IG5ldyBXZWFrTWFwKCk7XG5cblx0ZnVuY3Rpb24gaGFzKCBvYmplY3QgKSB7XG5cblx0XHRyZXR1cm4gcHJvcGVydGllcy5oYXMoIG9iamVjdCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXQoIG9iamVjdCApIHtcblxuXHRcdGxldCBtYXAgPSBwcm9wZXJ0aWVzLmdldCggb2JqZWN0ICk7XG5cblx0XHRpZiAoIG1hcCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtYXAgPSB7fTtcblx0XHRcdHByb3BlcnRpZXMuc2V0KCBvYmplY3QsIG1hcCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hcDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVtb3ZlKCBvYmplY3QgKSB7XG5cblx0XHRwcm9wZXJ0aWVzLmRlbGV0ZSggb2JqZWN0ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZSggb2JqZWN0LCBrZXksIHZhbHVlICkge1xuXG5cdFx0cHJvcGVydGllcy5nZXQoIG9iamVjdCApWyBrZXkgXSA9IHZhbHVlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBkaXNwb3NlKCkge1xuXG5cdFx0cHJvcGVydGllcyA9IG5ldyBXZWFrTWFwKCk7XG5cblx0fVxuXG5cdHJldHVybiB7XG5cdFx0aGFzOiBoYXMsXG5cdFx0Z2V0OiBnZXQsXG5cdFx0cmVtb3ZlOiByZW1vdmUsXG5cdFx0dXBkYXRlOiB1cGRhdGUsXG5cdFx0ZGlzcG9zZTogZGlzcG9zZVxuXHR9O1xuXG59XG5cbmZ1bmN0aW9uIHBhaW50ZXJTb3J0U3RhYmxlKCBhLCBiICkge1xuXG5cdGlmICggYS5ncm91cE9yZGVyICE9PSBiLmdyb3VwT3JkZXIgKSB7XG5cblx0XHRyZXR1cm4gYS5ncm91cE9yZGVyIC0gYi5ncm91cE9yZGVyO1xuXG5cdH0gZWxzZSBpZiAoIGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIgKSB7XG5cblx0XHRyZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XG5cblx0fSBlbHNlIGlmICggYS5tYXRlcmlhbC5pZCAhPT0gYi5tYXRlcmlhbC5pZCApIHtcblxuXHRcdHJldHVybiBhLm1hdGVyaWFsLmlkIC0gYi5tYXRlcmlhbC5pZDtcblxuXHR9IGVsc2UgaWYgKCBhLnogIT09IGIueiApIHtcblxuXHRcdHJldHVybiBhLnogLSBiLno7XG5cblx0fSBlbHNlIHtcblxuXHRcdHJldHVybiBhLmlkIC0gYi5pZDtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlKCBhLCBiICkge1xuXG5cdGlmICggYS5ncm91cE9yZGVyICE9PSBiLmdyb3VwT3JkZXIgKSB7XG5cblx0XHRyZXR1cm4gYS5ncm91cE9yZGVyIC0gYi5ncm91cE9yZGVyO1xuXG5cdH0gZWxzZSBpZiAoIGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIgKSB7XG5cblx0XHRyZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XG5cblx0fSBlbHNlIGlmICggYS56ICE9PSBiLnogKSB7XG5cblx0XHRyZXR1cm4gYi56IC0gYS56O1xuXG5cdH0gZWxzZSB7XG5cblx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XG5cblx0fVxuXG59XG5cblxuZnVuY3Rpb24gV2ViR0xSZW5kZXJMaXN0KCkge1xuXG5cdGNvbnN0IHJlbmRlckl0ZW1zID0gW107XG5cdGxldCByZW5kZXJJdGVtc0luZGV4ID0gMDtcblxuXHRjb25zdCBvcGFxdWUgPSBbXTtcblx0Y29uc3QgdHJhbnNtaXNzaXZlID0gW107XG5cdGNvbnN0IHRyYW5zcGFyZW50ID0gW107XG5cblx0ZnVuY3Rpb24gaW5pdCgpIHtcblxuXHRcdHJlbmRlckl0ZW1zSW5kZXggPSAwO1xuXG5cdFx0b3BhcXVlLmxlbmd0aCA9IDA7XG5cdFx0dHJhbnNtaXNzaXZlLmxlbmd0aCA9IDA7XG5cdFx0dHJhbnNwYXJlbnQubGVuZ3RoID0gMDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0TmV4dFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCApIHtcblxuXHRcdGxldCByZW5kZXJJdGVtID0gcmVuZGVySXRlbXNbIHJlbmRlckl0ZW1zSW5kZXggXTtcblxuXHRcdGlmICggcmVuZGVySXRlbSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZW5kZXJJdGVtID0ge1xuXHRcdFx0XHRpZDogb2JqZWN0LmlkLFxuXHRcdFx0XHRvYmplY3Q6IG9iamVjdCxcblx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5LFxuXHRcdFx0XHRtYXRlcmlhbDogbWF0ZXJpYWwsXG5cdFx0XHRcdGdyb3VwT3JkZXI6IGdyb3VwT3JkZXIsXG5cdFx0XHRcdHJlbmRlck9yZGVyOiBvYmplY3QucmVuZGVyT3JkZXIsXG5cdFx0XHRcdHo6IHosXG5cdFx0XHRcdGdyb3VwOiBncm91cFxuXHRcdFx0fTtcblxuXHRcdFx0cmVuZGVySXRlbXNbIHJlbmRlckl0ZW1zSW5kZXggXSA9IHJlbmRlckl0ZW07XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZW5kZXJJdGVtLmlkID0gb2JqZWN0LmlkO1xuXHRcdFx0cmVuZGVySXRlbS5vYmplY3QgPSBvYmplY3Q7XG5cdFx0XHRyZW5kZXJJdGVtLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cdFx0XHRyZW5kZXJJdGVtLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cdFx0XHRyZW5kZXJJdGVtLmdyb3VwT3JkZXIgPSBncm91cE9yZGVyO1xuXHRcdFx0cmVuZGVySXRlbS5yZW5kZXJPcmRlciA9IG9iamVjdC5yZW5kZXJPcmRlcjtcblx0XHRcdHJlbmRlckl0ZW0ueiA9IHo7XG5cdFx0XHRyZW5kZXJJdGVtLmdyb3VwID0gZ3JvdXA7XG5cblx0XHR9XG5cblx0XHRyZW5kZXJJdGVtc0luZGV4ICsrO1xuXG5cdFx0cmV0dXJuIHJlbmRlckl0ZW07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHB1c2goIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCApIHtcblxuXHRcdGNvbnN0IHJlbmRlckl0ZW0gPSBnZXROZXh0UmVuZGVySXRlbSggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwT3JkZXIsIHosIGdyb3VwICk7XG5cblx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zbWlzc2lvbiA+IDAuMCApIHtcblxuXHRcdFx0dHJhbnNtaXNzaXZlLnB1c2goIHJlbmRlckl0ZW0gKTtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlICkge1xuXG5cdFx0XHR0cmFuc3BhcmVudC5wdXNoKCByZW5kZXJJdGVtICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRvcGFxdWUucHVzaCggcmVuZGVySXRlbSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB1bnNoaWZ0KCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgeiwgZ3JvdXAgKSB7XG5cblx0XHRjb25zdCByZW5kZXJJdGVtID0gZ2V0TmV4dFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCApO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC50cmFuc21pc3Npb24gPiAwLjAgKSB7XG5cblx0XHRcdHRyYW5zbWlzc2l2ZS51bnNoaWZ0KCByZW5kZXJJdGVtICk7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dHJhbnNwYXJlbnQudW5zaGlmdCggcmVuZGVySXRlbSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0b3BhcXVlLnVuc2hpZnQoIHJlbmRlckl0ZW0gKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc29ydCggY3VzdG9tT3BhcXVlU29ydCwgY3VzdG9tVHJhbnNwYXJlbnRTb3J0ICkge1xuXG5cdFx0aWYgKCBvcGFxdWUubGVuZ3RoID4gMSApIG9wYXF1ZS5zb3J0KCBjdXN0b21PcGFxdWVTb3J0IHx8IHBhaW50ZXJTb3J0U3RhYmxlICk7XG5cdFx0aWYgKCB0cmFuc21pc3NpdmUubGVuZ3RoID4gMSApIHRyYW5zbWlzc2l2ZS5zb3J0KCBjdXN0b21UcmFuc3BhcmVudFNvcnQgfHwgcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlICk7XG5cdFx0aWYgKCB0cmFuc3BhcmVudC5sZW5ndGggPiAxICkgdHJhbnNwYXJlbnQuc29ydCggY3VzdG9tVHJhbnNwYXJlbnRTb3J0IHx8IHJldmVyc2VQYWludGVyU29ydFN0YWJsZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBmaW5pc2goKSB7XG5cblx0XHQvLyBDbGVhciByZWZlcmVuY2VzIGZyb20gaW5hY3RpdmUgcmVuZGVySXRlbXMgaW4gdGhlIGxpc3RcblxuXHRcdGZvciAoIGxldCBpID0gcmVuZGVySXRlbXNJbmRleCwgaWwgPSByZW5kZXJJdGVtcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcmVuZGVySXRlbSA9IHJlbmRlckl0ZW1zWyBpIF07XG5cblx0XHRcdGlmICggcmVuZGVySXRlbS5pZCA9PT0gbnVsbCApIGJyZWFrO1xuXG5cdFx0XHRyZW5kZXJJdGVtLmlkID0gbnVsbDtcblx0XHRcdHJlbmRlckl0ZW0ub2JqZWN0ID0gbnVsbDtcblx0XHRcdHJlbmRlckl0ZW0uZ2VvbWV0cnkgPSBudWxsO1xuXHRcdFx0cmVuZGVySXRlbS5tYXRlcmlhbCA9IG51bGw7XG5cdFx0XHRyZW5kZXJJdGVtLmdyb3VwID0gbnVsbDtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHtcblxuXHRcdG9wYXF1ZTogb3BhcXVlLFxuXHRcdHRyYW5zbWlzc2l2ZTogdHJhbnNtaXNzaXZlLFxuXHRcdHRyYW5zcGFyZW50OiB0cmFuc3BhcmVudCxcblxuXHRcdGluaXQ6IGluaXQsXG5cdFx0cHVzaDogcHVzaCxcblx0XHR1bnNoaWZ0OiB1bnNoaWZ0LFxuXHRcdGZpbmlzaDogZmluaXNoLFxuXG5cdFx0c29ydDogc29ydFxuXHR9O1xuXG59XG5cbmZ1bmN0aW9uIFdlYkdMUmVuZGVyTGlzdHMoKSB7XG5cblx0bGV0IGxpc3RzID0gbmV3IFdlYWtNYXAoKTtcblxuXHRmdW5jdGlvbiBnZXQoIHNjZW5lLCByZW5kZXJDYWxsRGVwdGggKSB7XG5cblx0XHRjb25zdCBsaXN0QXJyYXkgPSBsaXN0cy5nZXQoIHNjZW5lICk7XG5cdFx0bGV0IGxpc3Q7XG5cblx0XHRpZiAoIGxpc3RBcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRsaXN0ID0gbmV3IFdlYkdMUmVuZGVyTGlzdCgpO1xuXHRcdFx0bGlzdHMuc2V0KCBzY2VuZSwgWyBsaXN0IF0gKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggcmVuZGVyQ2FsbERlcHRoID49IGxpc3RBcnJheS5sZW5ndGggKSB7XG5cblx0XHRcdFx0bGlzdCA9IG5ldyBXZWJHTFJlbmRlckxpc3QoKTtcblx0XHRcdFx0bGlzdEFycmF5LnB1c2goIGxpc3QgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRsaXN0ID0gbGlzdEFycmF5WyByZW5kZXJDYWxsRGVwdGggXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxpc3Q7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cblx0XHRsaXN0cyA9IG5ldyBXZWFrTWFwKCk7XG5cblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBnZXQsXG5cdFx0ZGlzcG9zZTogZGlzcG9zZVxuXHR9O1xuXG59XG5cbmZ1bmN0aW9uIFVuaWZvcm1zQ2FjaGUoKSB7XG5cblx0Y29uc3QgbGlnaHRzID0ge307XG5cblx0cmV0dXJuIHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCBsaWdodCApIHtcblxuXHRcdFx0aWYgKCBsaWdodHNbIGxpZ2h0LmlkIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gbGlnaHRzWyBsaWdodC5pZCBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxldCB1bmlmb3JtcztcblxuXHRcdFx0c3dpdGNoICggbGlnaHQudHlwZSApIHtcblxuXHRcdFx0XHRjYXNlICdEaXJlY3Rpb25hbExpZ2h0Jzpcblx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRcdGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdGNvbG9yOiBuZXcgQ29sb3IoKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnU3BvdExpZ2h0Jzpcblx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0ZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0Y29sb3I6IG5ldyBDb2xvcigpLFxuXHRcdFx0XHRcdFx0ZGlzdGFuY2U6IDAsXG5cdFx0XHRcdFx0XHRjb25lQ29zOiAwLFxuXHRcdFx0XHRcdFx0cGVudW1icmFDb3M6IDAsXG5cdFx0XHRcdFx0XHRkZWNheTogMFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnUG9pbnRMaWdodCc6XG5cdFx0XHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdGNvbG9yOiBuZXcgQ29sb3IoKSxcblx0XHRcdFx0XHRcdGRpc3RhbmNlOiAwLFxuXHRcdFx0XHRcdFx0ZGVjYXk6IDBcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0hlbWlzcGhlcmVMaWdodCc6XG5cdFx0XHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRza3lDb2xvcjogbmV3IENvbG9yKCksXG5cdFx0XHRcdFx0XHRncm91bmRDb2xvcjogbmV3IENvbG9yKClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1JlY3RBcmVhTGlnaHQnOlxuXHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdFx0Y29sb3I6IG5ldyBDb2xvcigpLFxuXHRcdFx0XHRcdFx0cG9zaXRpb246IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRoYWxmV2lkdGg6IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRoYWxmSGVpZ2h0OiBuZXcgVmVjdG9yMygpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRsaWdodHNbIGxpZ2h0LmlkIF0gPSB1bmlmb3JtcztcblxuXHRcdFx0cmV0dXJuIHVuaWZvcm1zO1xuXG5cdFx0fVxuXG5cdH07XG5cbn1cblxuZnVuY3Rpb24gU2hhZG93VW5pZm9ybXNDYWNoZSgpIHtcblxuXHRjb25zdCBsaWdodHMgPSB7fTtcblxuXHRyZXR1cm4ge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoIGxpZ2h0ICkge1xuXG5cdFx0XHRpZiAoIGxpZ2h0c1sgbGlnaHQuaWQgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiBsaWdodHNbIGxpZ2h0LmlkIF07XG5cblx0XHRcdH1cblxuXHRcdFx0bGV0IHVuaWZvcm1zO1xuXG5cdFx0XHRzd2l0Y2ggKCBsaWdodC50eXBlICkge1xuXG5cdFx0XHRcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuXHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdFx0c2hhZG93SW50ZW5zaXR5OiAxLFxuXHRcdFx0XHRcdFx0c2hhZG93QmlhczogMCxcblx0XHRcdFx0XHRcdHNoYWRvd05vcm1hbEJpYXM6IDAsXG5cdFx0XHRcdFx0XHRzaGFkb3dSYWRpdXM6IDEsXG5cdFx0XHRcdFx0XHRzaGFkb3dNYXBTaXplOiBuZXcgVmVjdG9yMigpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdTcG90TGlnaHQnOlxuXHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdFx0c2hhZG93SW50ZW5zaXR5OiAxLFxuXHRcdFx0XHRcdFx0c2hhZG93QmlhczogMCxcblx0XHRcdFx0XHRcdHNoYWRvd05vcm1hbEJpYXM6IDAsXG5cdFx0XHRcdFx0XHRzaGFkb3dSYWRpdXM6IDEsXG5cdFx0XHRcdFx0XHRzaGFkb3dNYXBTaXplOiBuZXcgVmVjdG9yMigpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdQb2ludExpZ2h0Jzpcblx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRcdHNoYWRvd0ludGVuc2l0eTogMSxcblx0XHRcdFx0XHRcdHNoYWRvd0JpYXM6IDAsXG5cdFx0XHRcdFx0XHRzaGFkb3dOb3JtYWxCaWFzOiAwLFxuXHRcdFx0XHRcdFx0c2hhZG93UmFkaXVzOiAxLFxuXHRcdFx0XHRcdFx0c2hhZG93TWFwU2l6ZTogbmV3IFZlY3RvcjIoKSxcblx0XHRcdFx0XHRcdHNoYWRvd0NhbWVyYU5lYXI6IDEsXG5cdFx0XHRcdFx0XHRzaGFkb3dDYW1lcmFGYXI6IDEwMDBcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdC8vIFRPRE8gKGFiZWxuYXRpb24pOiBzZXQgUmVjdEFyZWFMaWdodCBzaGFkb3cgdW5pZm9ybXNcblxuXHRcdFx0fVxuXG5cdFx0XHRsaWdodHNbIGxpZ2h0LmlkIF0gPSB1bmlmb3JtcztcblxuXHRcdFx0cmV0dXJuIHVuaWZvcm1zO1xuXG5cdFx0fVxuXG5cdH07XG5cbn1cblxuXG5cbmxldCBuZXh0VmVyc2lvbiA9IDA7XG5cbmZ1bmN0aW9uIHNoYWRvd0Nhc3RpbmdBbmRUZXh0dXJpbmdMaWdodHNGaXJzdCggbGlnaHRBLCBsaWdodEIgKSB7XG5cblx0cmV0dXJuICggbGlnaHRCLmNhc3RTaGFkb3cgPyAyIDogMCApIC0gKCBsaWdodEEuY2FzdFNoYWRvdyA/IDIgOiAwICkgKyAoIGxpZ2h0Qi5tYXAgPyAxIDogMCApIC0gKCBsaWdodEEubWFwID8gMSA6IDAgKTtcblxufVxuXG5mdW5jdGlvbiBXZWJHTExpZ2h0cyggZXh0ZW5zaW9ucyApIHtcblxuXHRjb25zdCBjYWNoZSA9IG5ldyBVbmlmb3Jtc0NhY2hlKCk7XG5cblx0Y29uc3Qgc2hhZG93Q2FjaGUgPSBTaGFkb3dVbmlmb3Jtc0NhY2hlKCk7XG5cblx0Y29uc3Qgc3RhdGUgPSB7XG5cblx0XHR2ZXJzaW9uOiAwLFxuXG5cdFx0aGFzaDoge1xuXHRcdFx0ZGlyZWN0aW9uYWxMZW5ndGg6IC0gMSxcblx0XHRcdHBvaW50TGVuZ3RoOiAtIDEsXG5cdFx0XHRzcG90TGVuZ3RoOiAtIDEsXG5cdFx0XHRyZWN0QXJlYUxlbmd0aDogLSAxLFxuXHRcdFx0aGVtaUxlbmd0aDogLSAxLFxuXG5cdFx0XHRudW1EaXJlY3Rpb25hbFNoYWRvd3M6IC0gMSxcblx0XHRcdG51bVBvaW50U2hhZG93czogLSAxLFxuXHRcdFx0bnVtU3BvdFNoYWRvd3M6IC0gMSxcblx0XHRcdG51bVNwb3RNYXBzOiAtIDEsXG5cblx0XHRcdG51bUxpZ2h0UHJvYmVzOiAtIDFcblx0XHR9LFxuXG5cdFx0YW1iaWVudDogWyAwLCAwLCAwIF0sXG5cdFx0cHJvYmU6IFtdLFxuXHRcdGRpcmVjdGlvbmFsOiBbXSxcblx0XHRkaXJlY3Rpb25hbFNoYWRvdzogW10sXG5cdFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXA6IFtdLFxuXHRcdGRpcmVjdGlvbmFsU2hhZG93TWF0cml4OiBbXSxcblx0XHRzcG90OiBbXSxcblx0XHRzcG90TGlnaHRNYXA6IFtdLFxuXHRcdHNwb3RTaGFkb3c6IFtdLFxuXHRcdHNwb3RTaGFkb3dNYXA6IFtdLFxuXHRcdHNwb3RMaWdodE1hdHJpeDogW10sXG5cdFx0cmVjdEFyZWE6IFtdLFxuXHRcdHJlY3RBcmVhTFRDMTogbnVsbCxcblx0XHRyZWN0QXJlYUxUQzI6IG51bGwsXG5cdFx0cG9pbnQ6IFtdLFxuXHRcdHBvaW50U2hhZG93OiBbXSxcblx0XHRwb2ludFNoYWRvd01hcDogW10sXG5cdFx0cG9pbnRTaGFkb3dNYXRyaXg6IFtdLFxuXHRcdGhlbWk6IFtdLFxuXHRcdG51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwczogMCxcblx0XHRudW1MaWdodFByb2JlczogMFxuXG5cdH07XG5cblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHN0YXRlLnByb2JlLnB1c2goIG5ldyBWZWN0b3IzKCkgKTtcblxuXHRjb25zdCB2ZWN0b3IzID0gbmV3IFZlY3RvcjMoKTtcblx0Y29uc3QgbWF0cml4NCA9IG5ldyBNYXRyaXg0KCk7XG5cdGNvbnN0IG1hdHJpeDQyID0gbmV3IE1hdHJpeDQoKTtcblxuXHRmdW5jdGlvbiBzZXR1cCggbGlnaHRzICkge1xuXG5cdFx0bGV0IHIgPSAwLCBnID0gMCwgYiA9IDA7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkgc3RhdGUucHJvYmVbIGkgXS5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdGxldCBkaXJlY3Rpb25hbExlbmd0aCA9IDA7XG5cdFx0bGV0IHBvaW50TGVuZ3RoID0gMDtcblx0XHRsZXQgc3BvdExlbmd0aCA9IDA7XG5cdFx0bGV0IHJlY3RBcmVhTGVuZ3RoID0gMDtcblx0XHRsZXQgaGVtaUxlbmd0aCA9IDA7XG5cblx0XHRsZXQgbnVtRGlyZWN0aW9uYWxTaGFkb3dzID0gMDtcblx0XHRsZXQgbnVtUG9pbnRTaGFkb3dzID0gMDtcblx0XHRsZXQgbnVtU3BvdFNoYWRvd3MgPSAwO1xuXHRcdGxldCBudW1TcG90TWFwcyA9IDA7XG5cdFx0bGV0IG51bVNwb3RTaGFkb3dzV2l0aE1hcHMgPSAwO1xuXG5cdFx0bGV0IG51bUxpZ2h0UHJvYmVzID0gMDtcblxuXHRcdC8vIG9yZGVyaW5nIDogW3NoYWRvdyBjYXN0aW5nICsgbWFwIHRleHR1cmluZywgbWFwIHRleHR1cmluZywgc2hhZG93IGNhc3RpbmcsIG5vbmUgXVxuXHRcdGxpZ2h0cy5zb3J0KCBzaGFkb3dDYXN0aW5nQW5kVGV4dHVyaW5nTGlnaHRzRmlyc3QgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBsaWdodCA9IGxpZ2h0c1sgaSBdO1xuXG5cdFx0XHRjb25zdCBjb2xvciA9IGxpZ2h0LmNvbG9yO1xuXHRcdFx0Y29uc3QgaW50ZW5zaXR5ID0gbGlnaHQuaW50ZW5zaXR5O1xuXHRcdFx0Y29uc3QgZGlzdGFuY2UgPSBsaWdodC5kaXN0YW5jZTtcblxuXHRcdFx0Y29uc3Qgc2hhZG93TWFwID0gKCBsaWdodC5zaGFkb3cgJiYgbGlnaHQuc2hhZG93Lm1hcCApID8gbGlnaHQuc2hhZG93Lm1hcC50ZXh0dXJlIDogbnVsbDtcblxuXHRcdFx0aWYgKCBsaWdodC5pc0FtYmllbnRMaWdodCApIHtcblxuXHRcdFx0XHRyICs9IGNvbG9yLnIgKiBpbnRlbnNpdHk7XG5cdFx0XHRcdGcgKz0gY29sb3IuZyAqIGludGVuc2l0eTtcblx0XHRcdFx0YiArPSBjb2xvci5iICogaW50ZW5zaXR5O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodC5pc0xpZ2h0UHJvYmUgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgOTsgaiArKyApIHtcblxuXHRcdFx0XHRcdHN0YXRlLnByb2JlWyBqIF0uYWRkU2NhbGVkVmVjdG9yKCBsaWdodC5zaC5jb2VmZmljaWVudHNbIGogXSwgaW50ZW5zaXR5ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG51bUxpZ2h0UHJvYmVzICsrO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodC5pc0RpcmVjdGlvbmFsTGlnaHQgKSB7XG5cblx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBjYWNoZS5nZXQoIGxpZ2h0ICk7XG5cblx0XHRcdFx0dW5pZm9ybXMuY29sb3IuY29weSggbGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggbGlnaHQuaW50ZW5zaXR5ICk7XG5cblx0XHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xuXG5cdFx0XHRcdFx0Y29uc3Qgc2hhZG93VW5pZm9ybXMgPSBzaGFkb3dDYWNoZS5nZXQoIGxpZ2h0ICk7XG5cblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dJbnRlbnNpdHkgPSBzaGFkb3cuaW50ZW5zaXR5O1xuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd0JpYXMgPSBzaGFkb3cuYmlhcztcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dOb3JtYWxCaWFzID0gc2hhZG93Lm5vcm1hbEJpYXM7XG5cdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93UmFkaXVzID0gc2hhZG93LnJhZGl1cztcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gc2hhZG93Lm1hcFNpemU7XG5cblx0XHRcdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd1sgZGlyZWN0aW9uYWxMZW5ndGggXSA9IHNoYWRvd1VuaWZvcm1zO1xuXHRcdFx0XHRcdHN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWFwWyBkaXJlY3Rpb25hbExlbmd0aCBdID0gc2hhZG93TWFwO1xuXHRcdFx0XHRcdHN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBkaXJlY3Rpb25hbExlbmd0aCBdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcblxuXHRcdFx0XHRcdG51bURpcmVjdGlvbmFsU2hhZG93cyArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3RhdGUuZGlyZWN0aW9uYWxbIGRpcmVjdGlvbmFsTGVuZ3RoIF0gPSB1bmlmb3JtcztcblxuXHRcdFx0XHRkaXJlY3Rpb25hbExlbmd0aCArKztcblxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNTcG90TGlnaHQgKSB7XG5cblx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBjYWNoZS5nZXQoIGxpZ2h0ICk7XG5cblx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdHVuaWZvcm1zLmNvbG9yLmNvcHkoIGNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuXG5cdFx0XHRcdHVuaWZvcm1zLmNvbmVDb3MgPSBNYXRoLmNvcyggbGlnaHQuYW5nbGUgKTtcblx0XHRcdFx0dW5pZm9ybXMucGVudW1icmFDb3MgPSBNYXRoLmNvcyggbGlnaHQuYW5nbGUgKiAoIDEgLSBsaWdodC5wZW51bWJyYSApICk7XG5cdFx0XHRcdHVuaWZvcm1zLmRlY2F5ID0gbGlnaHQuZGVjYXk7XG5cblx0XHRcdFx0c3RhdGUuc3BvdFsgc3BvdExlbmd0aCBdID0gdW5pZm9ybXM7XG5cblx0XHRcdFx0Y29uc3Qgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xuXG5cdFx0XHRcdGlmICggbGlnaHQubWFwICkge1xuXG5cdFx0XHRcdFx0c3RhdGUuc3BvdExpZ2h0TWFwWyBudW1TcG90TWFwcyBdID0gbGlnaHQubWFwO1xuXHRcdFx0XHRcdG51bVNwb3RNYXBzICsrO1xuXG5cdFx0XHRcdFx0Ly8gbWFrZSBzdXJlIHRoZSBsaWdodE1hdHJpeCBpcyB1cCB0byBkYXRlXG5cdFx0XHRcdFx0Ly8gVE9ETyA6IGRvIGl0IGlmIHJlcXVpcmVkIG9ubHlcblx0XHRcdFx0XHRzaGFkb3cudXBkYXRlTWF0cmljZXMoIGxpZ2h0ICk7XG5cblx0XHRcdFx0XHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgKSBudW1TcG90U2hhZG93c1dpdGhNYXBzICsrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdGF0ZS5zcG90TGlnaHRNYXRyaXhbIHNwb3RMZW5ndGggXSA9IHNoYWRvdy5tYXRyaXg7XG5cblx0XHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgc2hhZG93VW5pZm9ybXMgPSBzaGFkb3dDYWNoZS5nZXQoIGxpZ2h0ICk7XG5cblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dJbnRlbnNpdHkgPSBzaGFkb3cuaW50ZW5zaXR5O1xuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd0JpYXMgPSBzaGFkb3cuYmlhcztcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dOb3JtYWxCaWFzID0gc2hhZG93Lm5vcm1hbEJpYXM7XG5cdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93UmFkaXVzID0gc2hhZG93LnJhZGl1cztcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gc2hhZG93Lm1hcFNpemU7XG5cblx0XHRcdFx0XHRzdGF0ZS5zcG90U2hhZG93WyBzcG90TGVuZ3RoIF0gPSBzaGFkb3dVbmlmb3Jtcztcblx0XHRcdFx0XHRzdGF0ZS5zcG90U2hhZG93TWFwWyBzcG90TGVuZ3RoIF0gPSBzaGFkb3dNYXA7XG5cblx0XHRcdFx0XHRudW1TcG90U2hhZG93cyArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3BvdExlbmd0aCArKztcblxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNSZWN0QXJlYUxpZ2h0ICkge1xuXG5cdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gY2FjaGUuZ2V0KCBsaWdodCApO1xuXG5cdFx0XHRcdHVuaWZvcm1zLmNvbG9yLmNvcHkoIGNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xuXG5cdFx0XHRcdHVuaWZvcm1zLmhhbGZXaWR0aC5zZXQoIGxpZ2h0LndpZHRoICogMC41LCAwLjAsIDAuMCApO1xuXHRcdFx0XHR1bmlmb3Jtcy5oYWxmSGVpZ2h0LnNldCggMC4wLCBsaWdodC5oZWlnaHQgKiAwLjUsIDAuMCApO1xuXG5cdFx0XHRcdHN0YXRlLnJlY3RBcmVhWyByZWN0QXJlYUxlbmd0aCBdID0gdW5pZm9ybXM7XG5cblx0XHRcdFx0cmVjdEFyZWFMZW5ndGggKys7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzUG9pbnRMaWdodCApIHtcblxuXHRcdFx0XHRjb25zdCB1bmlmb3JtcyA9IGNhY2hlLmdldCggbGlnaHQgKTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5jb2xvci5jb3B5KCBsaWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCBsaWdodC5pbnRlbnNpdHkgKTtcblx0XHRcdFx0dW5pZm9ybXMuZGlzdGFuY2UgPSBsaWdodC5kaXN0YW5jZTtcblx0XHRcdFx0dW5pZm9ybXMuZGVjYXkgPSBsaWdodC5kZWNheTtcblxuXHRcdFx0XHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XG5cblx0XHRcdFx0XHRjb25zdCBzaGFkb3dVbmlmb3JtcyA9IHNoYWRvd0NhY2hlLmdldCggbGlnaHQgKTtcblxuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd0ludGVuc2l0eSA9IHNoYWRvdy5pbnRlbnNpdHk7XG5cdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93QmlhcyA9IHNoYWRvdy5iaWFzO1xuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd05vcm1hbEJpYXMgPSBzaGFkb3cubm9ybWFsQmlhcztcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dSYWRpdXMgPSBzaGFkb3cucmFkaXVzO1xuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd01hcFNpemUgPSBzaGFkb3cubWFwU2l6ZTtcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dDYW1lcmFOZWFyID0gc2hhZG93LmNhbWVyYS5uZWFyO1xuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd0NhbWVyYUZhciA9IHNoYWRvdy5jYW1lcmEuZmFyO1xuXG5cdFx0XHRcdFx0c3RhdGUucG9pbnRTaGFkb3dbIHBvaW50TGVuZ3RoIF0gPSBzaGFkb3dVbmlmb3Jtcztcblx0XHRcdFx0XHRzdGF0ZS5wb2ludFNoYWRvd01hcFsgcG9pbnRMZW5ndGggXSA9IHNoYWRvd01hcDtcblx0XHRcdFx0XHRzdGF0ZS5wb2ludFNoYWRvd01hdHJpeFsgcG9pbnRMZW5ndGggXSA9IGxpZ2h0LnNoYWRvdy5tYXRyaXg7XG5cblx0XHRcdFx0XHRudW1Qb2ludFNoYWRvd3MgKys7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN0YXRlLnBvaW50WyBwb2ludExlbmd0aCBdID0gdW5pZm9ybXM7XG5cblx0XHRcdFx0cG9pbnRMZW5ndGggKys7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzSGVtaXNwaGVyZUxpZ2h0ICkge1xuXG5cdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gY2FjaGUuZ2V0KCBsaWdodCApO1xuXG5cdFx0XHRcdHVuaWZvcm1zLnNreUNvbG9yLmNvcHkoIGxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xuXHRcdFx0XHR1bmlmb3Jtcy5ncm91bmRDb2xvci5jb3B5KCBsaWdodC5ncm91bmRDb2xvciApLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgKTtcblxuXHRcdFx0XHRzdGF0ZS5oZW1pWyBoZW1pTGVuZ3RoIF0gPSB1bmlmb3JtcztcblxuXHRcdFx0XHRoZW1pTGVuZ3RoICsrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHJlY3RBcmVhTGVuZ3RoID4gMCApIHtcblxuXHRcdFx0aWYgKCBleHRlbnNpb25zLmhhcyggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRzdGF0ZS5yZWN0QXJlYUxUQzEgPSBVbmlmb3Jtc0xpYi5MVENfRkxPQVRfMTtcblx0XHRcdFx0c3RhdGUucmVjdEFyZWFMVEMyID0gVW5pZm9ybXNMaWIuTFRDX0ZMT0FUXzI7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0c3RhdGUucmVjdEFyZWFMVEMxID0gVW5pZm9ybXNMaWIuTFRDX0hBTEZfMTtcblx0XHRcdFx0c3RhdGUucmVjdEFyZWFMVEMyID0gVW5pZm9ybXNMaWIuTFRDX0hBTEZfMjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0c3RhdGUuYW1iaWVudFsgMCBdID0gcjtcblx0XHRzdGF0ZS5hbWJpZW50WyAxIF0gPSBnO1xuXHRcdHN0YXRlLmFtYmllbnRbIDIgXSA9IGI7XG5cblx0XHRjb25zdCBoYXNoID0gc3RhdGUuaGFzaDtcblxuXHRcdGlmICggaGFzaC5kaXJlY3Rpb25hbExlbmd0aCAhPT0gZGlyZWN0aW9uYWxMZW5ndGggfHxcblx0XHRcdGhhc2gucG9pbnRMZW5ndGggIT09IHBvaW50TGVuZ3RoIHx8XG5cdFx0XHRoYXNoLnNwb3RMZW5ndGggIT09IHNwb3RMZW5ndGggfHxcblx0XHRcdGhhc2gucmVjdEFyZWFMZW5ndGggIT09IHJlY3RBcmVhTGVuZ3RoIHx8XG5cdFx0XHRoYXNoLmhlbWlMZW5ndGggIT09IGhlbWlMZW5ndGggfHxcblx0XHRcdGhhc2gubnVtRGlyZWN0aW9uYWxTaGFkb3dzICE9PSBudW1EaXJlY3Rpb25hbFNoYWRvd3MgfHxcblx0XHRcdGhhc2gubnVtUG9pbnRTaGFkb3dzICE9PSBudW1Qb2ludFNoYWRvd3MgfHxcblx0XHRcdGhhc2gubnVtU3BvdFNoYWRvd3MgIT09IG51bVNwb3RTaGFkb3dzIHx8XG5cdFx0XHRoYXNoLm51bVNwb3RNYXBzICE9PSBudW1TcG90TWFwcyB8fFxuXHRcdFx0aGFzaC5udW1MaWdodFByb2JlcyAhPT0gbnVtTGlnaHRQcm9iZXMgKSB7XG5cblx0XHRcdHN0YXRlLmRpcmVjdGlvbmFsLmxlbmd0aCA9IGRpcmVjdGlvbmFsTGVuZ3RoO1xuXHRcdFx0c3RhdGUuc3BvdC5sZW5ndGggPSBzcG90TGVuZ3RoO1xuXHRcdFx0c3RhdGUucmVjdEFyZWEubGVuZ3RoID0gcmVjdEFyZWFMZW5ndGg7XG5cdFx0XHRzdGF0ZS5wb2ludC5sZW5ndGggPSBwb2ludExlbmd0aDtcblx0XHRcdHN0YXRlLmhlbWkubGVuZ3RoID0gaGVtaUxlbmd0aDtcblxuXHRcdFx0c3RhdGUuZGlyZWN0aW9uYWxTaGFkb3cubGVuZ3RoID0gbnVtRGlyZWN0aW9uYWxTaGFkb3dzO1xuXHRcdFx0c3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXAubGVuZ3RoID0gbnVtRGlyZWN0aW9uYWxTaGFkb3dzO1xuXHRcdFx0c3RhdGUucG9pbnRTaGFkb3cubGVuZ3RoID0gbnVtUG9pbnRTaGFkb3dzO1xuXHRcdFx0c3RhdGUucG9pbnRTaGFkb3dNYXAubGVuZ3RoID0gbnVtUG9pbnRTaGFkb3dzO1xuXHRcdFx0c3RhdGUuc3BvdFNoYWRvdy5sZW5ndGggPSBudW1TcG90U2hhZG93cztcblx0XHRcdHN0YXRlLnNwb3RTaGFkb3dNYXAubGVuZ3RoID0gbnVtU3BvdFNoYWRvd3M7XG5cdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeC5sZW5ndGggPSBudW1EaXJlY3Rpb25hbFNoYWRvd3M7XG5cdFx0XHRzdGF0ZS5wb2ludFNoYWRvd01hdHJpeC5sZW5ndGggPSBudW1Qb2ludFNoYWRvd3M7XG5cdFx0XHRzdGF0ZS5zcG90TGlnaHRNYXRyaXgubGVuZ3RoID0gbnVtU3BvdFNoYWRvd3MgKyBudW1TcG90TWFwcyAtIG51bVNwb3RTaGFkb3dzV2l0aE1hcHM7XG5cdFx0XHRzdGF0ZS5zcG90TGlnaHRNYXAubGVuZ3RoID0gbnVtU3BvdE1hcHM7XG5cdFx0XHRzdGF0ZS5udW1TcG90TGlnaHRTaGFkb3dzV2l0aE1hcHMgPSBudW1TcG90U2hhZG93c1dpdGhNYXBzO1xuXHRcdFx0c3RhdGUubnVtTGlnaHRQcm9iZXMgPSBudW1MaWdodFByb2JlcztcblxuXHRcdFx0aGFzaC5kaXJlY3Rpb25hbExlbmd0aCA9IGRpcmVjdGlvbmFsTGVuZ3RoO1xuXHRcdFx0aGFzaC5wb2ludExlbmd0aCA9IHBvaW50TGVuZ3RoO1xuXHRcdFx0aGFzaC5zcG90TGVuZ3RoID0gc3BvdExlbmd0aDtcblx0XHRcdGhhc2gucmVjdEFyZWFMZW5ndGggPSByZWN0QXJlYUxlbmd0aDtcblx0XHRcdGhhc2guaGVtaUxlbmd0aCA9IGhlbWlMZW5ndGg7XG5cblx0XHRcdGhhc2gubnVtRGlyZWN0aW9uYWxTaGFkb3dzID0gbnVtRGlyZWN0aW9uYWxTaGFkb3dzO1xuXHRcdFx0aGFzaC5udW1Qb2ludFNoYWRvd3MgPSBudW1Qb2ludFNoYWRvd3M7XG5cdFx0XHRoYXNoLm51bVNwb3RTaGFkb3dzID0gbnVtU3BvdFNoYWRvd3M7XG5cdFx0XHRoYXNoLm51bVNwb3RNYXBzID0gbnVtU3BvdE1hcHM7XG5cblx0XHRcdGhhc2gubnVtTGlnaHRQcm9iZXMgPSBudW1MaWdodFByb2JlcztcblxuXHRcdFx0c3RhdGUudmVyc2lvbiA9IG5leHRWZXJzaW9uICsrO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXR1cFZpZXcoIGxpZ2h0cywgY2FtZXJhICkge1xuXG5cdFx0bGV0IGRpcmVjdGlvbmFsTGVuZ3RoID0gMDtcblx0XHRsZXQgcG9pbnRMZW5ndGggPSAwO1xuXHRcdGxldCBzcG90TGVuZ3RoID0gMDtcblx0XHRsZXQgcmVjdEFyZWFMZW5ndGggPSAwO1xuXHRcdGxldCBoZW1pTGVuZ3RoID0gMDtcblxuXHRcdGNvbnN0IHZpZXdNYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbGlnaHRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGxpZ2h0ID0gbGlnaHRzWyBpIF07XG5cblx0XHRcdGlmICggbGlnaHQuaXNEaXJlY3Rpb25hbExpZ2h0ICkge1xuXG5cdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gc3RhdGUuZGlyZWN0aW9uYWxbIGRpcmVjdGlvbmFsTGVuZ3RoIF07XG5cblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0dmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24uc3ViKCB2ZWN0b3IzICk7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcblxuXHRcdFx0XHRkaXJlY3Rpb25hbExlbmd0aCArKztcblxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNTcG90TGlnaHQgKSB7XG5cblx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBzdGF0ZS5zcG90WyBzcG90TGVuZ3RoIF07XG5cblx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXggKTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHR2ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zdWIoIHZlY3RvcjMgKTtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xuXG5cdFx0XHRcdHNwb3RMZW5ndGggKys7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzUmVjdEFyZWFMaWdodCApIHtcblxuXHRcdFx0XHRjb25zdCB1bmlmb3JtcyA9IHN0YXRlLnJlY3RBcmVhWyByZWN0QXJlYUxlbmd0aCBdO1xuXG5cdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4ICk7XG5cblx0XHRcdFx0Ly8gZXh0cmFjdCBsb2NhbCByb3RhdGlvbiBvZiBsaWdodCB0byBkZXJpdmUgd2lkdGgvaGVpZ2h0IGhhbGYgdmVjdG9yc1xuXHRcdFx0XHRtYXRyaXg0Mi5pZGVudGl0eSgpO1xuXHRcdFx0XHRtYXRyaXg0LmNvcHkoIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdG1hdHJpeDQucHJlbXVsdGlwbHkoIHZpZXdNYXRyaXggKTtcblx0XHRcdFx0bWF0cml4NDIuZXh0cmFjdFJvdGF0aW9uKCBtYXRyaXg0ICk7XG5cblx0XHRcdFx0dW5pZm9ybXMuaGFsZldpZHRoLnNldCggbGlnaHQud2lkdGggKiAwLjUsIDAuMCwgMC4wICk7XG5cdFx0XHRcdHVuaWZvcm1zLmhhbGZIZWlnaHQuc2V0KCAwLjAsIGxpZ2h0LmhlaWdodCAqIDAuNSwgMC4wICk7XG5cblx0XHRcdFx0dW5pZm9ybXMuaGFsZldpZHRoLmFwcGx5TWF0cml4NCggbWF0cml4NDIgKTtcblx0XHRcdFx0dW5pZm9ybXMuaGFsZkhlaWdodC5hcHBseU1hdHJpeDQoIG1hdHJpeDQyICk7XG5cblx0XHRcdFx0cmVjdEFyZWFMZW5ndGggKys7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzUG9pbnRMaWdodCApIHtcblxuXHRcdFx0XHRjb25zdCB1bmlmb3JtcyA9IHN0YXRlLnBvaW50WyBwb2ludExlbmd0aCBdO1xuXG5cdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4ICk7XG5cblx0XHRcdFx0cG9pbnRMZW5ndGggKys7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzSGVtaXNwaGVyZUxpZ2h0ICkge1xuXG5cdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gc3RhdGUuaGVtaVsgaGVtaUxlbmd0aCBdO1xuXG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcblxuXHRcdFx0XHRoZW1pTGVuZ3RoICsrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c2V0dXA6IHNldHVwLFxuXHRcdHNldHVwVmlldzogc2V0dXBWaWV3LFxuXHRcdHN0YXRlOiBzdGF0ZVxuXHR9O1xuXG59XG5cbmZ1bmN0aW9uIFdlYkdMUmVuZGVyU3RhdGUoIGV4dGVuc2lvbnMgKSB7XG5cblx0Y29uc3QgbGlnaHRzID0gbmV3IFdlYkdMTGlnaHRzKCBleHRlbnNpb25zICk7XG5cblx0Y29uc3QgbGlnaHRzQXJyYXkgPSBbXTtcblx0Y29uc3Qgc2hhZG93c0FycmF5ID0gW107XG5cblx0ZnVuY3Rpb24gaW5pdCggY2FtZXJhICkge1xuXG5cdFx0c3RhdGUuY2FtZXJhID0gY2FtZXJhO1xuXG5cdFx0bGlnaHRzQXJyYXkubGVuZ3RoID0gMDtcblx0XHRzaGFkb3dzQXJyYXkubGVuZ3RoID0gMDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcHVzaExpZ2h0KCBsaWdodCApIHtcblxuXHRcdGxpZ2h0c0FycmF5LnB1c2goIGxpZ2h0ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHB1c2hTaGFkb3coIHNoYWRvd0xpZ2h0ICkge1xuXG5cdFx0c2hhZG93c0FycmF5LnB1c2goIHNoYWRvd0xpZ2h0ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldHVwTGlnaHRzKCkge1xuXG5cdFx0bGlnaHRzLnNldHVwKCBsaWdodHNBcnJheSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXR1cExpZ2h0c1ZpZXcoIGNhbWVyYSApIHtcblxuXHRcdGxpZ2h0cy5zZXR1cFZpZXcoIGxpZ2h0c0FycmF5LCBjYW1lcmEgKTtcblxuXHR9XG5cblx0Y29uc3Qgc3RhdGUgPSB7XG5cdFx0bGlnaHRzQXJyYXk6IGxpZ2h0c0FycmF5LFxuXHRcdHNoYWRvd3NBcnJheTogc2hhZG93c0FycmF5LFxuXG5cdFx0Y2FtZXJhOiBudWxsLFxuXG5cdFx0bGlnaHRzOiBsaWdodHMsXG5cblx0XHR0cmFuc21pc3Npb25SZW5kZXJUYXJnZXQ6IHt9XG5cdH07XG5cblx0cmV0dXJuIHtcblx0XHRpbml0OiBpbml0LFxuXHRcdHN0YXRlOiBzdGF0ZSxcblx0XHRzZXR1cExpZ2h0czogc2V0dXBMaWdodHMsXG5cdFx0c2V0dXBMaWdodHNWaWV3OiBzZXR1cExpZ2h0c1ZpZXcsXG5cblx0XHRwdXNoTGlnaHQ6IHB1c2hMaWdodCxcblx0XHRwdXNoU2hhZG93OiBwdXNoU2hhZG93XG5cdH07XG5cbn1cblxuZnVuY3Rpb24gV2ViR0xSZW5kZXJTdGF0ZXMoIGV4dGVuc2lvbnMgKSB7XG5cblx0bGV0IHJlbmRlclN0YXRlcyA9IG5ldyBXZWFrTWFwKCk7XG5cblx0ZnVuY3Rpb24gZ2V0KCBzY2VuZSwgcmVuZGVyQ2FsbERlcHRoID0gMCApIHtcblxuXHRcdGNvbnN0IHJlbmRlclN0YXRlQXJyYXkgPSByZW5kZXJTdGF0ZXMuZ2V0KCBzY2VuZSApO1xuXHRcdGxldCByZW5kZXJTdGF0ZTtcblxuXHRcdGlmICggcmVuZGVyU3RhdGVBcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZW5kZXJTdGF0ZSA9IG5ldyBXZWJHTFJlbmRlclN0YXRlKCBleHRlbnNpb25zICk7XG5cdFx0XHRyZW5kZXJTdGF0ZXMuc2V0KCBzY2VuZSwgWyByZW5kZXJTdGF0ZSBdICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIHJlbmRlckNhbGxEZXB0aCA+PSByZW5kZXJTdGF0ZUFycmF5Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRyZW5kZXJTdGF0ZSA9IG5ldyBXZWJHTFJlbmRlclN0YXRlKCBleHRlbnNpb25zICk7XG5cdFx0XHRcdHJlbmRlclN0YXRlQXJyYXkucHVzaCggcmVuZGVyU3RhdGUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlQXJyYXlbIHJlbmRlckNhbGxEZXB0aCBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVuZGVyU3RhdGU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cblx0XHRyZW5kZXJTdGF0ZXMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGdldDogZ2V0LFxuXHRcdGRpc3Bvc2U6IGRpc3Bvc2Vcblx0fTtcblxufVxuXG5jb25zdCB2ZXJ0ZXggPSBcInZvaWQgbWFpbigpIHtcXG5cXHRnbF9Qb3NpdGlvbiA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG59XCI7XG5cbmNvbnN0IGZyYWdtZW50ID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCBzaGFkb3dfcGFzcztcXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG51bmlmb3JtIGZsb2F0IHJhZGl1cztcXG4jaW5jbHVkZSA8cGFja2luZz5cXG52b2lkIG1haW4oKSB7XFxuXFx0Y29uc3QgZmxvYXQgc2FtcGxlcyA9IGZsb2F0KCBWU01fU0FNUExFUyApO1xcblxcdGZsb2F0IG1lYW4gPSAwLjA7XFxuXFx0ZmxvYXQgc3F1YXJlZF9tZWFuID0gMC4wO1xcblxcdGZsb2F0IHV2U3RyaWRlID0gc2FtcGxlcyA8PSAxLjAgPyAwLjAgOiAyLjAgLyAoIHNhbXBsZXMgLSAxLjAgKTtcXG5cXHRmbG9hdCB1dlN0YXJ0ID0gc2FtcGxlcyA8PSAxLjAgPyAwLjAgOiAtIDEuMDtcXG5cXHRmb3IgKCBmbG9hdCBpID0gMC4wOyBpIDwgc2FtcGxlczsgaSArKyApIHtcXG5cXHRcXHRmbG9hdCB1dk9mZnNldCA9IHV2U3RhcnQgKyBpICogdXZTdHJpZGU7XFxuXFx0XFx0I2lmZGVmIEhPUklaT05UQUxfUEFTU1xcblxcdFxcdFxcdHZlYzIgZGlzdHJpYnV0aW9uID0gdW5wYWNrUkdCQVRvMkhhbGYoIHRleHR1cmUyRCggc2hhZG93X3Bhc3MsICggZ2xfRnJhZ0Nvb3JkLnh5ICsgdmVjMiggdXZPZmZzZXQsIDAuMCApICogcmFkaXVzICkgLyByZXNvbHV0aW9uICkgKTtcXG5cXHRcXHRcXHRtZWFuICs9IGRpc3RyaWJ1dGlvbi54O1xcblxcdFxcdFxcdHNxdWFyZWRfbWVhbiArPSBkaXN0cmlidXRpb24ueSAqIGRpc3RyaWJ1dGlvbi55ICsgZGlzdHJpYnV0aW9uLnggKiBkaXN0cmlidXRpb24ueDtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdGZsb2F0IGRlcHRoID0gdW5wYWNrUkdCQVRvRGVwdGgoIHRleHR1cmUyRCggc2hhZG93X3Bhc3MsICggZ2xfRnJhZ0Nvb3JkLnh5ICsgdmVjMiggMC4wLCB1dk9mZnNldCApICogcmFkaXVzICkgLyByZXNvbHV0aW9uICkgKTtcXG5cXHRcXHRcXHRtZWFuICs9IGRlcHRoO1xcblxcdFxcdFxcdHNxdWFyZWRfbWVhbiArPSBkZXB0aCAqIGRlcHRoO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG5cXHRtZWFuID0gbWVhbiAvIHNhbXBsZXM7XFxuXFx0c3F1YXJlZF9tZWFuID0gc3F1YXJlZF9tZWFuIC8gc2FtcGxlcztcXG5cXHRmbG9hdCBzdGRfZGV2ID0gc3FydCggc3F1YXJlZF9tZWFuIC0gbWVhbiAqIG1lYW4gKTtcXG5cXHRnbF9GcmFnQ29sb3IgPSBwYWNrMkhhbGZUb1JHQkEoIHZlYzIoIG1lYW4sIHN0ZF9kZXYgKSApO1xcbn1cIjtcblxuZnVuY3Rpb24gV2ViR0xTaGFkb3dNYXAoIHJlbmRlcmVyLCBvYmplY3RzLCBjYXBhYmlsaXRpZXMgKSB7XG5cblx0bGV0IF9mcnVzdHVtID0gbmV3IEZydXN0dW0oKTtcblxuXHRjb25zdCBfc2hhZG93TWFwU2l6ZSA9IG5ldyBWZWN0b3IyKCksXG5cdFx0X3ZpZXdwb3J0U2l6ZSA9IG5ldyBWZWN0b3IyKCksXG5cblx0XHRfdmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpLFxuXG5cdFx0X2RlcHRoTWF0ZXJpYWwgPSBuZXcgTWVzaERlcHRoTWF0ZXJpYWwoIHsgZGVwdGhQYWNraW5nOiBSR0JBRGVwdGhQYWNraW5nIH0gKSxcblx0XHRfZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBNZXNoRGlzdGFuY2VNYXRlcmlhbCgpLFxuXG5cdFx0X21hdGVyaWFsQ2FjaGUgPSB7fSxcblxuXHRcdF9tYXhUZXh0dXJlU2l6ZSA9IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZTtcblxuXHRjb25zdCBzaGFkb3dTaWRlID0geyBbIEZyb250U2lkZSBdOiBCYWNrU2lkZSwgWyBCYWNrU2lkZSBdOiBGcm9udFNpZGUsIFsgRG91YmxlU2lkZSBdOiBEb3VibGVTaWRlIH07XG5cblx0Y29uc3Qgc2hhZG93TWF0ZXJpYWxWZXJ0aWNhbCA9IG5ldyBTaGFkZXJNYXRlcmlhbCgge1xuXHRcdGRlZmluZXM6IHtcblx0XHRcdFZTTV9TQU1QTEVTOiA4XG5cdFx0fSxcblx0XHR1bmlmb3Jtczoge1xuXHRcdFx0c2hhZG93X3Bhc3M6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRcdHJlc29sdXRpb246IHsgdmFsdWU6IG5ldyBWZWN0b3IyKCkgfSxcblx0XHRcdHJhZGl1czogeyB2YWx1ZTogNC4wIH1cblx0XHR9LFxuXG5cdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50XG5cblx0fSApO1xuXG5cdGNvbnN0IHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbCA9IHNoYWRvd01hdGVyaWFsVmVydGljYWwuY2xvbmUoKTtcblx0c2hhZG93TWF0ZXJpYWxIb3Jpem9udGFsLmRlZmluZXMuSE9SSVpPTlRBTF9QQVNTID0gMTtcblxuXHRjb25zdCBmdWxsU2NyZWVuVHJpID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdGZ1bGxTY3JlZW5Ucmkuc2V0QXR0cmlidXRlKFxuXHRcdCdwb3NpdGlvbicsXG5cdFx0bmV3IEJ1ZmZlckF0dHJpYnV0ZShcblx0XHRcdG5ldyBGbG9hdDMyQXJyYXkoIFsgLSAxLCAtIDEsIDAuNSwgMywgLSAxLCAwLjUsIC0gMSwgMywgMC41IF0gKSxcblx0XHRcdDNcblx0XHQpXG5cdCk7XG5cblx0Y29uc3QgZnVsbFNjcmVlbk1lc2ggPSBuZXcgTWVzaCggZnVsbFNjcmVlblRyaSwgc2hhZG93TWF0ZXJpYWxWZXJ0aWNhbCApO1xuXG5cdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuXHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuXHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0dGhpcy50eXBlID0gUENGU2hhZG93TWFwO1xuXHRsZXQgX3ByZXZpb3VzVHlwZSA9IHRoaXMudHlwZTtcblxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggbGlnaHRzLCBzY2VuZSwgY2FtZXJhICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblx0XHRpZiAoIHNjb3BlLmF1dG9VcGRhdGUgPT09IGZhbHNlICYmIHNjb3BlLm5lZWRzVXBkYXRlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGlmICggbGlnaHRzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuXHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblx0XHRjb25zdCBhY3RpdmVDdWJlRmFjZSA9IHJlbmRlcmVyLmdldEFjdGl2ZUN1YmVGYWNlKCk7XG5cdFx0Y29uc3QgYWN0aXZlTWlwbWFwTGV2ZWwgPSByZW5kZXJlci5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpO1xuXG5cdFx0Y29uc3QgX3N0YXRlID0gcmVuZGVyZXIuc3RhdGU7XG5cblx0XHQvLyBTZXQgR0wgc3RhdGUgZm9yIGRlcHRoIG1hcC5cblx0XHRfc3RhdGUuc2V0QmxlbmRpbmcoIE5vQmxlbmRpbmcgKTtcblx0XHRfc3RhdGUuYnVmZmVycy5jb2xvci5zZXRDbGVhciggMSwgMSwgMSwgMSApO1xuXHRcdF9zdGF0ZS5idWZmZXJzLmRlcHRoLnNldFRlc3QoIHRydWUgKTtcblx0XHRfc3RhdGUuc2V0U2Npc3NvclRlc3QoIGZhbHNlICk7XG5cblx0XHQvLyBjaGVjayBmb3Igc2hhZG93IG1hcCB0eXBlIGNoYW5nZXNcblxuXHRcdGNvbnN0IHRvVlNNID0gKCBfcHJldmlvdXNUeXBlICE9PSBWU01TaGFkb3dNYXAgJiYgdGhpcy50eXBlID09PSBWU01TaGFkb3dNYXAgKTtcblx0XHRjb25zdCBmcm9tVlNNID0gKCBfcHJldmlvdXNUeXBlID09PSBWU01TaGFkb3dNYXAgJiYgdGhpcy50eXBlICE9PSBWU01TaGFkb3dNYXAgKTtcblxuXHRcdC8vIHJlbmRlciBkZXB0aCBtYXBcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBsaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGxpZ2h0ID0gbGlnaHRzWyBpIF07XG5cdFx0XHRjb25zdCBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XG5cblx0XHRcdGlmICggc2hhZG93ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xTaGFkb3dNYXA6JywgbGlnaHQsICdoYXMgbm8gc2hhZG93LicgKTtcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzaGFkb3cuYXV0b1VwZGF0ZSA9PT0gZmFsc2UgJiYgc2hhZG93Lm5lZWRzVXBkYXRlID09PSBmYWxzZSApIGNvbnRpbnVlO1xuXG5cdFx0XHRfc2hhZG93TWFwU2l6ZS5jb3B5KCBzaGFkb3cubWFwU2l6ZSApO1xuXG5cdFx0XHRjb25zdCBzaGFkb3dGcmFtZUV4dGVudHMgPSBzaGFkb3cuZ2V0RnJhbWVFeHRlbnRzKCk7XG5cblx0XHRcdF9zaGFkb3dNYXBTaXplLm11bHRpcGx5KCBzaGFkb3dGcmFtZUV4dGVudHMgKTtcblxuXHRcdFx0X3ZpZXdwb3J0U2l6ZS5jb3B5KCBzaGFkb3cubWFwU2l6ZSApO1xuXG5cdFx0XHRpZiAoIF9zaGFkb3dNYXBTaXplLnggPiBfbWF4VGV4dHVyZVNpemUgfHwgX3NoYWRvd01hcFNpemUueSA+IF9tYXhUZXh0dXJlU2l6ZSApIHtcblxuXHRcdFx0XHRpZiAoIF9zaGFkb3dNYXBTaXplLnggPiBfbWF4VGV4dHVyZVNpemUgKSB7XG5cblx0XHRcdFx0XHRfdmlld3BvcnRTaXplLnggPSBNYXRoLmZsb29yKCBfbWF4VGV4dHVyZVNpemUgLyBzaGFkb3dGcmFtZUV4dGVudHMueCApO1xuXHRcdFx0XHRcdF9zaGFkb3dNYXBTaXplLnggPSBfdmlld3BvcnRTaXplLnggKiBzaGFkb3dGcmFtZUV4dGVudHMueDtcblx0XHRcdFx0XHRzaGFkb3cubWFwU2l6ZS54ID0gX3ZpZXdwb3J0U2l6ZS54O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIF9zaGFkb3dNYXBTaXplLnkgPiBfbWF4VGV4dHVyZVNpemUgKSB7XG5cblx0XHRcdFx0XHRfdmlld3BvcnRTaXplLnkgPSBNYXRoLmZsb29yKCBfbWF4VGV4dHVyZVNpemUgLyBzaGFkb3dGcmFtZUV4dGVudHMueSApO1xuXHRcdFx0XHRcdF9zaGFkb3dNYXBTaXplLnkgPSBfdmlld3BvcnRTaXplLnkgKiBzaGFkb3dGcmFtZUV4dGVudHMueTtcblx0XHRcdFx0XHRzaGFkb3cubWFwU2l6ZS55ID0gX3ZpZXdwb3J0U2l6ZS55O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNoYWRvdy5tYXAgPT09IG51bGwgfHwgdG9WU00gPT09IHRydWUgfHwgZnJvbVZTTSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRjb25zdCBwYXJzID0gKCB0aGlzLnR5cGUgIT09IFZTTVNoYWRvd01hcCApID8geyBtaW5GaWx0ZXI6IE5lYXJlc3RGaWx0ZXIsIG1hZ0ZpbHRlcjogTmVhcmVzdEZpbHRlciB9IDoge307XG5cblx0XHRcdFx0aWYgKCBzaGFkb3cubWFwICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0c2hhZG93Lm1hcC5kaXNwb3NlKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNoYWRvdy5tYXAgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQoIF9zaGFkb3dNYXBTaXplLngsIF9zaGFkb3dNYXBTaXplLnksIHBhcnMgKTtcblx0XHRcdFx0c2hhZG93Lm1hcC50ZXh0dXJlLm5hbWUgPSBsaWdodC5uYW1lICsgJy5zaGFkb3dNYXAnO1xuXG5cdFx0XHRcdHNoYWRvdy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggc2hhZG93Lm1hcCApO1xuXHRcdFx0cmVuZGVyZXIuY2xlYXIoKTtcblxuXHRcdFx0Y29uc3Qgdmlld3BvcnRDb3VudCA9IHNoYWRvdy5nZXRWaWV3cG9ydENvdW50KCk7XG5cblx0XHRcdGZvciAoIGxldCB2cCA9IDA7IHZwIDwgdmlld3BvcnRDb3VudDsgdnAgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgdmlld3BvcnQgPSBzaGFkb3cuZ2V0Vmlld3BvcnQoIHZwICk7XG5cblx0XHRcdFx0X3ZpZXdwb3J0LnNldChcblx0XHRcdFx0XHRfdmlld3BvcnRTaXplLnggKiB2aWV3cG9ydC54LFxuXHRcdFx0XHRcdF92aWV3cG9ydFNpemUueSAqIHZpZXdwb3J0LnksXG5cdFx0XHRcdFx0X3ZpZXdwb3J0U2l6ZS54ICogdmlld3BvcnQueixcblx0XHRcdFx0XHRfdmlld3BvcnRTaXplLnkgKiB2aWV3cG9ydC53XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0X3N0YXRlLnZpZXdwb3J0KCBfdmlld3BvcnQgKTtcblxuXHRcdFx0XHRzaGFkb3cudXBkYXRlTWF0cmljZXMoIGxpZ2h0LCB2cCApO1xuXG5cdFx0XHRcdF9mcnVzdHVtID0gc2hhZG93LmdldEZydXN0dW0oKTtcblxuXHRcdFx0XHRyZW5kZXJPYmplY3QoIHNjZW5lLCBjYW1lcmEsIHNoYWRvdy5jYW1lcmEsIGxpZ2h0LCB0aGlzLnR5cGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBkbyBibHVyIHBhc3MgZm9yIFZTTVxuXG5cdFx0XHRpZiAoIHNoYWRvdy5pc1BvaW50TGlnaHRTaGFkb3cgIT09IHRydWUgJiYgdGhpcy50eXBlID09PSBWU01TaGFkb3dNYXAgKSB7XG5cblx0XHRcdFx0VlNNUGFzcyggc2hhZG93LCBjYW1lcmEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzaGFkb3cubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdF9wcmV2aW91c1R5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRzY29wZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBjdXJyZW50UmVuZGVyVGFyZ2V0LCBhY3RpdmVDdWJlRmFjZSwgYWN0aXZlTWlwbWFwTGV2ZWwgKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIFZTTVBhc3MoIHNoYWRvdywgY2FtZXJhICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBvYmplY3RzLnVwZGF0ZSggZnVsbFNjcmVlbk1lc2ggKTtcblxuXHRcdGlmICggc2hhZG93TWF0ZXJpYWxWZXJ0aWNhbC5kZWZpbmVzLlZTTV9TQU1QTEVTICE9PSBzaGFkb3cuYmx1clNhbXBsZXMgKSB7XG5cblx0XHRcdHNoYWRvd01hdGVyaWFsVmVydGljYWwuZGVmaW5lcy5WU01fU0FNUExFUyA9IHNoYWRvdy5ibHVyU2FtcGxlcztcblx0XHRcdHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbC5kZWZpbmVzLlZTTV9TQU1QTEVTID0gc2hhZG93LmJsdXJTYW1wbGVzO1xuXG5cdFx0XHRzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRpZiAoIHNoYWRvdy5tYXBQYXNzID09PSBudWxsICkge1xuXG5cdFx0XHRzaGFkb3cubWFwUGFzcyA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCggX3NoYWRvd01hcFNpemUueCwgX3NoYWRvd01hcFNpemUueSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdmVydGljYWwgcGFzc1xuXG5cdFx0c2hhZG93TWF0ZXJpYWxWZXJ0aWNhbC51bmlmb3Jtcy5zaGFkb3dfcGFzcy52YWx1ZSA9IHNoYWRvdy5tYXAudGV4dHVyZTtcblx0XHRzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUgPSBzaGFkb3cubWFwU2l6ZTtcblx0XHRzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHNoYWRvdy5yYWRpdXM7XG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBzaGFkb3cubWFwUGFzcyApO1xuXHRcdHJlbmRlcmVyLmNsZWFyKCk7XG5cdFx0cmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBjYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLCBmdWxsU2NyZWVuTWVzaCwgbnVsbCApO1xuXG5cdFx0Ly8gaG9yaXpvbnRhbCBwYXNzXG5cblx0XHRzaGFkb3dNYXRlcmlhbEhvcml6b250YWwudW5pZm9ybXMuc2hhZG93X3Bhc3MudmFsdWUgPSBzaGFkb3cubWFwUGFzcy50ZXh0dXJlO1xuXHRcdHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbC51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlID0gc2hhZG93Lm1hcFNpemU7XG5cdFx0c2hhZG93TWF0ZXJpYWxIb3Jpem9udGFsLnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHNoYWRvdy5yYWRpdXM7XG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBzaGFkb3cubWFwICk7XG5cdFx0cmVuZGVyZXIuY2xlYXIoKTtcblx0XHRyZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIGNhbWVyYSwgbnVsbCwgZ2VvbWV0cnksIHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbCwgZnVsbFNjcmVlbk1lc2gsIG51bGwgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBtYXRlcmlhbCwgbGlnaHQsIHR5cGUgKSB7XG5cblx0XHRsZXQgcmVzdWx0ID0gbnVsbDtcblxuXHRcdGNvbnN0IGN1c3RvbU1hdGVyaWFsID0gKCBsaWdodC5pc1BvaW50TGlnaHQgPT09IHRydWUgKSA/IG9iamVjdC5jdXN0b21EaXN0YW5jZU1hdGVyaWFsIDogb2JqZWN0LmN1c3RvbURlcHRoTWF0ZXJpYWw7XG5cblx0XHRpZiAoIGN1c3RvbU1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJlc3VsdCA9IGN1c3RvbU1hdGVyaWFsO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmVzdWx0ID0gKCBsaWdodC5pc1BvaW50TGlnaHQgPT09IHRydWUgKSA/IF9kaXN0YW5jZU1hdGVyaWFsIDogX2RlcHRoTWF0ZXJpYWw7XG5cblx0XHRcdGlmICggKCByZW5kZXJlci5sb2NhbENsaXBwaW5nRW5hYmxlZCAmJiBtYXRlcmlhbC5jbGlwU2hhZG93cyA9PT0gdHJ1ZSAmJiBBcnJheS5pc0FycmF5KCBtYXRlcmlhbC5jbGlwcGluZ1BsYW5lcyApICYmIG1hdGVyaWFsLmNsaXBwaW5nUGxhbmVzLmxlbmd0aCAhPT0gMCApIHx8XG5cdFx0XHRcdCggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICYmIG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlICE9PSAwICkgfHxcblx0XHRcdFx0KCBtYXRlcmlhbC5hbHBoYU1hcCAmJiBtYXRlcmlhbC5hbHBoYVRlc3QgPiAwICkgfHxcblx0XHRcdFx0KCBtYXRlcmlhbC5tYXAgJiYgbWF0ZXJpYWwuYWxwaGFUZXN0ID4gMCApICkge1xuXG5cdFx0XHRcdC8vIGluIHRoaXMgY2FzZSB3ZSBuZWVkIGEgdW5pcXVlIG1hdGVyaWFsIGluc3RhbmNlIHJlZmxlY3RpbmcgdGhlXG5cdFx0XHRcdC8vIGFwcHJvcHJpYXRlIHN0YXRlXG5cblx0XHRcdFx0Y29uc3Qga2V5QSA9IHJlc3VsdC51dWlkLCBrZXlCID0gbWF0ZXJpYWwudXVpZDtcblxuXHRcdFx0XHRsZXQgbWF0ZXJpYWxzRm9yVmFyaWFudCA9IF9tYXRlcmlhbENhY2hlWyBrZXlBIF07XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbHNGb3JWYXJpYW50ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbHNGb3JWYXJpYW50ID0ge307XG5cdFx0XHRcdFx0X21hdGVyaWFsQ2FjaGVbIGtleUEgXSA9IG1hdGVyaWFsc0ZvclZhcmlhbnQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBjYWNoZWRNYXRlcmlhbCA9IG1hdGVyaWFsc0ZvclZhcmlhbnRbIGtleUIgXTtcblxuXHRcdFx0XHRpZiAoIGNhY2hlZE1hdGVyaWFsID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjYWNoZWRNYXRlcmlhbCA9IHJlc3VsdC5jbG9uZSgpO1xuXHRcdFx0XHRcdG1hdGVyaWFsc0ZvclZhcmlhbnRbIGtleUIgXSA9IGNhY2hlZE1hdGVyaWFsO1xuXHRcdFx0XHRcdG1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ID0gY2FjaGVkTWF0ZXJpYWw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJlc3VsdC52aXNpYmxlID0gbWF0ZXJpYWwudmlzaWJsZTtcblx0XHRyZXN1bHQud2lyZWZyYW1lID0gbWF0ZXJpYWwud2lyZWZyYW1lO1xuXG5cdFx0aWYgKCB0eXBlID09PSBWU01TaGFkb3dNYXAgKSB7XG5cblx0XHRcdHJlc3VsdC5zaWRlID0gKCBtYXRlcmlhbC5zaGFkb3dTaWRlICE9PSBudWxsICkgPyBtYXRlcmlhbC5zaGFkb3dTaWRlIDogbWF0ZXJpYWwuc2lkZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJlc3VsdC5zaWRlID0gKCBtYXRlcmlhbC5zaGFkb3dTaWRlICE9PSBudWxsICkgPyBtYXRlcmlhbC5zaGFkb3dTaWRlIDogc2hhZG93U2lkZVsgbWF0ZXJpYWwuc2lkZSBdO1xuXG5cdFx0fVxuXG5cdFx0cmVzdWx0LmFscGhhTWFwID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cdFx0cmVzdWx0LmFscGhhVGVzdCA9IG1hdGVyaWFsLmFscGhhVGVzdDtcblx0XHRyZXN1bHQubWFwID0gbWF0ZXJpYWwubWFwO1xuXG5cdFx0cmVzdWx0LmNsaXBTaGFkb3dzID0gbWF0ZXJpYWwuY2xpcFNoYWRvd3M7XG5cdFx0cmVzdWx0LmNsaXBwaW5nUGxhbmVzID0gbWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXM7XG5cdFx0cmVzdWx0LmNsaXBJbnRlcnNlY3Rpb24gPSBtYXRlcmlhbC5jbGlwSW50ZXJzZWN0aW9uO1xuXG5cdFx0cmVzdWx0LmRpc3BsYWNlbWVudE1hcCA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblx0XHRyZXN1bHQuZGlzcGxhY2VtZW50U2NhbGUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRyZXN1bHQuZGlzcGxhY2VtZW50QmlhcyA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHRyZXN1bHQud2lyZWZyYW1lTGluZXdpZHRoID0gbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdHJlc3VsdC5saW5ld2lkdGggPSBtYXRlcmlhbC5saW5ld2lkdGg7XG5cblx0XHRpZiAoIGxpZ2h0LmlzUG9pbnRMaWdodCA9PT0gdHJ1ZSAmJiByZXN1bHQuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Y29uc3QgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcmVuZGVyZXIucHJvcGVydGllcy5nZXQoIHJlc3VsdCApO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0ID0gbGlnaHQ7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXJPYmplY3QoIG9iamVjdCwgY2FtZXJhLCBzaGFkb3dDYW1lcmEsIGxpZ2h0LCB0eXBlICkge1xuXG5cdFx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRjb25zdCB2aXNpYmxlID0gb2JqZWN0LmxheWVycy50ZXN0KCBjYW1lcmEubGF5ZXJzICk7XG5cblx0XHRpZiAoIHZpc2libGUgJiYgKCBvYmplY3QuaXNNZXNoIHx8IG9iamVjdC5pc0xpbmUgfHwgb2JqZWN0LmlzUG9pbnRzICkgKSB7XG5cblx0XHRcdGlmICggKCBvYmplY3QuY2FzdFNoYWRvdyB8fCAoIG9iamVjdC5yZWNlaXZlU2hhZG93ICYmIHR5cGUgPT09IFZTTVNoYWRvd01hcCApICkgJiYgKCAhIG9iamVjdC5mcnVzdHVtQ3VsbGVkIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApICkgKSB7XG5cblx0XHRcdFx0b2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRjb25zdCBnZW9tZXRyeSA9IG9iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcblx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBtYXRlcmlhbCApICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGsgPSAwLCBrbCA9IGdyb3Vwcy5sZW5ndGg7IGsgPCBrbDsgayArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGsgXTtcblx0XHRcdFx0XHRcdGNvbnN0IGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFsgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGdyb3VwTWF0ZXJpYWwgJiYgZ3JvdXBNYXRlcmlhbC52aXNpYmxlICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGRlcHRoTWF0ZXJpYWwgPSBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIGdyb3VwTWF0ZXJpYWwsIGxpZ2h0LCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0b2JqZWN0Lm9uQmVmb3JlU2hhZG93KCByZW5kZXJlciwgb2JqZWN0LCBjYW1lcmEsIHNoYWRvd0NhbWVyYSwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIGdyb3VwICk7XG5cblx0XHRcdFx0XHRcdFx0cmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICk7XG5cblx0XHRcdFx0XHRcdFx0b2JqZWN0Lm9uQWZ0ZXJTaGFkb3coIHJlbmRlcmVyLCBvYmplY3QsIGNhbWVyYSwgc2hhZG93Q2FtZXJhLCBnZW9tZXRyeSwgZGVwdGhNYXRlcmlhbCwgZ3JvdXAgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnZpc2libGUgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBkZXB0aE1hdGVyaWFsID0gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBtYXRlcmlhbCwgbGlnaHQsIHR5cGUgKTtcblxuXHRcdFx0XHRcdG9iamVjdC5vbkJlZm9yZVNoYWRvdyggcmVuZGVyZXIsIG9iamVjdCwgY2FtZXJhLCBzaGFkb3dDYW1lcmEsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBudWxsICk7XG5cblx0XHRcdFx0XHRyZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIHNoYWRvd0NhbWVyYSwgbnVsbCwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIG9iamVjdCwgbnVsbCApO1xuXG5cdFx0XHRcdFx0b2JqZWN0Lm9uQWZ0ZXJTaGFkb3coIHJlbmRlcmVyLCBvYmplY3QsIGNhbWVyYSwgc2hhZG93Q2FtZXJhLCBnZW9tZXRyeSwgZGVwdGhNYXRlcmlhbCwgbnVsbCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRyZW5kZXJPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSwgc2hhZG93Q2FtZXJhLCBsaWdodCwgdHlwZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBvbk1hdGVyaWFsRGlzcG9zZSggZXZlbnQgKSB7XG5cblx0XHRjb25zdCBtYXRlcmlhbCA9IGV2ZW50LnRhcmdldDtcblxuXHRcdG1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcblxuXHRcdC8vIG1ha2Ugc3VyZSB0byByZW1vdmUgdGhlIHVuaXF1ZSBkaXN0YW5jZS9kZXB0aCBtYXRlcmlhbHMgdXNlZCBmb3Igc2hhZG93IG1hcCByZW5kZXJpbmdcblxuXHRcdGZvciAoIGNvbnN0IGlkIGluIF9tYXRlcmlhbENhY2hlICkge1xuXG5cdFx0XHRjb25zdCBjYWNoZSA9IF9tYXRlcmlhbENhY2hlWyBpZCBdO1xuXG5cdFx0XHRjb25zdCB1dWlkID0gZXZlbnQudGFyZ2V0LnV1aWQ7XG5cblx0XHRcdGlmICggdXVpZCBpbiBjYWNoZSApIHtcblxuXHRcdFx0XHRjb25zdCBzaGFkb3dNYXRlcmlhbCA9IGNhY2hlWyB1dWlkIF07XG5cdFx0XHRcdHNoYWRvd01hdGVyaWFsLmRpc3Bvc2UoKTtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyB1dWlkIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cbn1cblxuY29uc3QgcmV2ZXJzZWRGdW5jcyA9IHtcblx0WyBOZXZlckRlcHRoIF06IEFsd2F5c0RlcHRoLFxuXHRbIExlc3NEZXB0aCBdOiBHcmVhdGVyRGVwdGgsXG5cdFsgRXF1YWxEZXB0aCBdOiBOb3RFcXVhbERlcHRoLFxuXHRbIExlc3NFcXVhbERlcHRoIF06IEdyZWF0ZXJFcXVhbERlcHRoLFxuXG5cdFsgQWx3YXlzRGVwdGggXTogTmV2ZXJEZXB0aCxcblx0WyBHcmVhdGVyRGVwdGggXTogTGVzc0RlcHRoLFxuXHRbIE5vdEVxdWFsRGVwdGggXTogRXF1YWxEZXB0aCxcblx0WyBHcmVhdGVyRXF1YWxEZXB0aCBdOiBMZXNzRXF1YWxEZXB0aCxcbn07XG5cbmZ1bmN0aW9uIFdlYkdMU3RhdGUoIGdsLCBleHRlbnNpb25zICkge1xuXG5cdGZ1bmN0aW9uIENvbG9yQnVmZmVyKCkge1xuXG5cdFx0bGV0IGxvY2tlZCA9IGZhbHNlO1xuXG5cdFx0Y29uc3QgY29sb3IgPSBuZXcgVmVjdG9yNCgpO1xuXHRcdGxldCBjdXJyZW50Q29sb3JNYXNrID0gbnVsbDtcblx0XHRjb25zdCBjdXJyZW50Q29sb3JDbGVhciA9IG5ldyBWZWN0b3I0KCAwLCAwLCAwLCAwICk7XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHRzZXRNYXNrOiBmdW5jdGlvbiAoIGNvbG9yTWFzayApIHtcblxuXHRcdFx0XHRpZiAoIGN1cnJlbnRDb2xvck1hc2sgIT09IGNvbG9yTWFzayAmJiAhIGxvY2tlZCApIHtcblxuXHRcdFx0XHRcdGdsLmNvbG9yTWFzayggY29sb3JNYXNrLCBjb2xvck1hc2ssIGNvbG9yTWFzaywgY29sb3JNYXNrICk7XG5cdFx0XHRcdFx0Y3VycmVudENvbG9yTWFzayA9IGNvbG9yTWFzaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldExvY2tlZDogZnVuY3Rpb24gKCBsb2NrICkge1xuXG5cdFx0XHRcdGxvY2tlZCA9IGxvY2s7XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldENsZWFyOiBmdW5jdGlvbiAoIHIsIGcsIGIsIGEsIHByZW11bHRpcGxpZWRBbHBoYSApIHtcblxuXHRcdFx0XHRpZiAoIHByZW11bHRpcGxpZWRBbHBoYSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHIgKj0gYTsgZyAqPSBhOyBiICo9IGE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbG9yLnNldCggciwgZywgYiwgYSApO1xuXG5cdFx0XHRcdGlmICggY3VycmVudENvbG9yQ2xlYXIuZXF1YWxzKCBjb2xvciApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGdsLmNsZWFyQ29sb3IoIHIsIGcsIGIsIGEgKTtcblx0XHRcdFx0XHRjdXJyZW50Q29sb3JDbGVhci5jb3B5KCBjb2xvciApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdFx0cmVzZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRsb2NrZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRjdXJyZW50Q29sb3JNYXNrID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudENvbG9yQ2xlYXIuc2V0KCAtIDEsIDAsIDAsIDAgKTsgLy8gc2V0IHRvIGludmFsaWQgc3RhdGVcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gRGVwdGhCdWZmZXIoKSB7XG5cblx0XHRsZXQgbG9ja2VkID0gZmFsc2U7XG5cdFx0bGV0IHJldmVyc2VkID0gZmFsc2U7XG5cblx0XHRsZXQgY3VycmVudERlcHRoTWFzayA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnREZXB0aEZ1bmMgPSBudWxsO1xuXHRcdGxldCBjdXJyZW50RGVwdGhDbGVhciA9IG51bGw7XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHRzZXRSZXZlcnNlZDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0XHRpZiAoIHJldmVyc2VkICE9PSB2YWx1ZSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGV4dCA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2NsaXBfY29udHJvbCcgKTtcblxuXHRcdFx0XHRcdGlmICggcmV2ZXJzZWQgKSB7XG5cblx0XHRcdFx0XHRcdGV4dC5jbGlwQ29udHJvbEVYVCggZXh0LkxPV0VSX0xFRlRfRVhULCBleHQuWkVST19UT19PTkVfRVhUICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRleHQuY2xpcENvbnRyb2xFWFQoIGV4dC5MT1dFUl9MRUZUX0VYVCwgZXh0Lk5FR0FUSVZFX09ORV9UT19PTkVfRVhUICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCBvbGREZXB0aCA9IGN1cnJlbnREZXB0aENsZWFyO1xuXHRcdFx0XHRcdGN1cnJlbnREZXB0aENsZWFyID0gbnVsbDtcblx0XHRcdFx0XHR0aGlzLnNldENsZWFyKCBvbGREZXB0aCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXZlcnNlZCA9IHZhbHVlO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRnZXRSZXZlcnNlZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHJldHVybiByZXZlcnNlZDtcblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0VGVzdDogZnVuY3Rpb24gKCBkZXB0aFRlc3QgKSB7XG5cblx0XHRcdFx0aWYgKCBkZXB0aFRlc3QgKSB7XG5cblx0XHRcdFx0XHRlbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0TWFzazogZnVuY3Rpb24gKCBkZXB0aE1hc2sgKSB7XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50RGVwdGhNYXNrICE9PSBkZXB0aE1hc2sgJiYgISBsb2NrZWQgKSB7XG5cblx0XHRcdFx0XHRnbC5kZXB0aE1hc2soIGRlcHRoTWFzayApO1xuXHRcdFx0XHRcdGN1cnJlbnREZXB0aE1hc2sgPSBkZXB0aE1hc2s7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LFxuXG5cdFx0XHRzZXRGdW5jOiBmdW5jdGlvbiAoIGRlcHRoRnVuYyApIHtcblxuXHRcdFx0XHRpZiAoIHJldmVyc2VkICkgZGVwdGhGdW5jID0gcmV2ZXJzZWRGdW5jc1sgZGVwdGhGdW5jIF07XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50RGVwdGhGdW5jICE9PSBkZXB0aEZ1bmMgKSB7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBkZXB0aEZ1bmMgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgTmV2ZXJEZXB0aDpcblxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLk5FVkVSICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIEFsd2F5c0RlcHRoOlxuXG5cdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuQUxXQVlTICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIExlc3NEZXB0aDpcblxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFU1MgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgTGVzc0VxdWFsRGVwdGg6XG5cblx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgRXF1YWxEZXB0aDpcblxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkVRVUFMICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIEdyZWF0ZXJFcXVhbERlcHRoOlxuXG5cdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuR0VRVUFMICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIEdyZWF0ZXJEZXB0aDpcblxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkdSRUFURVIgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgTm90RXF1YWxEZXB0aDpcblxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLk5PVEVRVUFMICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjdXJyZW50RGVwdGhGdW5jID0gZGVwdGhGdW5jO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0TG9ja2VkOiBmdW5jdGlvbiAoIGxvY2sgKSB7XG5cblx0XHRcdFx0bG9ja2VkID0gbG9jaztcblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0Q2xlYXI6IGZ1bmN0aW9uICggZGVwdGggKSB7XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50RGVwdGhDbGVhciAhPT0gZGVwdGggKSB7XG5cblx0XHRcdFx0XHRpZiAoIHJldmVyc2VkICkge1xuXG5cdFx0XHRcdFx0XHRkZXB0aCA9IDEgLSBkZXB0aDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGdsLmNsZWFyRGVwdGgoIGRlcHRoICk7XG5cdFx0XHRcdFx0Y3VycmVudERlcHRoQ2xlYXIgPSBkZXB0aDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHRcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0bG9ja2VkID0gZmFsc2U7XG5cblx0XHRcdFx0Y3VycmVudERlcHRoTWFzayA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnREZXB0aEZ1bmMgPSBudWxsO1xuXHRcdFx0XHRjdXJyZW50RGVwdGhDbGVhciA9IG51bGw7XG5cdFx0XHRcdHJldmVyc2VkID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIFN0ZW5jaWxCdWZmZXIoKSB7XG5cblx0XHRsZXQgbG9ja2VkID0gZmFsc2U7XG5cblx0XHRsZXQgY3VycmVudFN0ZW5jaWxNYXNrID0gbnVsbDtcblx0XHRsZXQgY3VycmVudFN0ZW5jaWxGdW5jID0gbnVsbDtcblx0XHRsZXQgY3VycmVudFN0ZW5jaWxSZWYgPSBudWxsO1xuXHRcdGxldCBjdXJyZW50U3RlbmNpbEZ1bmNNYXNrID0gbnVsbDtcblx0XHRsZXQgY3VycmVudFN0ZW5jaWxGYWlsID0gbnVsbDtcblx0XHRsZXQgY3VycmVudFN0ZW5jaWxaRmFpbCA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBudWxsO1xuXHRcdGxldCBjdXJyZW50U3RlbmNpbENsZWFyID0gbnVsbDtcblxuXHRcdHJldHVybiB7XG5cblx0XHRcdHNldFRlc3Q6IGZ1bmN0aW9uICggc3RlbmNpbFRlc3QgKSB7XG5cblx0XHRcdFx0aWYgKCAhIGxvY2tlZCApIHtcblxuXHRcdFx0XHRcdGlmICggc3RlbmNpbFRlc3QgKSB7XG5cblx0XHRcdFx0XHRcdGVuYWJsZSggZ2wuU1RFTkNJTF9URVNUICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRkaXNhYmxlKCBnbC5TVEVOQ0lMX1RFU1QgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldE1hc2s6IGZ1bmN0aW9uICggc3RlbmNpbE1hc2sgKSB7XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50U3RlbmNpbE1hc2sgIT09IHN0ZW5jaWxNYXNrICYmICEgbG9ja2VkICkge1xuXG5cdFx0XHRcdFx0Z2wuc3RlbmNpbE1hc2soIHN0ZW5jaWxNYXNrICk7XG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxNYXNrID0gc3RlbmNpbE1hc2s7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LFxuXG5cdFx0XHRzZXRGdW5jOiBmdW5jdGlvbiAoIHN0ZW5jaWxGdW5jLCBzdGVuY2lsUmVmLCBzdGVuY2lsTWFzayApIHtcblxuXHRcdFx0XHRpZiAoIGN1cnJlbnRTdGVuY2lsRnVuYyAhPT0gc3RlbmNpbEZ1bmMgfHxcblx0XHRcdFx0ICAgICBjdXJyZW50U3RlbmNpbFJlZiAhPT0gc3RlbmNpbFJlZiB8fFxuXHRcdFx0XHQgICAgIGN1cnJlbnRTdGVuY2lsRnVuY01hc2sgIT09IHN0ZW5jaWxNYXNrICkge1xuXG5cdFx0XHRcdFx0Z2wuc3RlbmNpbEZ1bmMoIHN0ZW5jaWxGdW5jLCBzdGVuY2lsUmVmLCBzdGVuY2lsTWFzayApO1xuXG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGdW5jID0gc3RlbmNpbEZ1bmM7XG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxSZWYgPSBzdGVuY2lsUmVmO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuY01hc2sgPSBzdGVuY2lsTWFzaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldE9wOiBmdW5jdGlvbiAoIHN0ZW5jaWxGYWlsLCBzdGVuY2lsWkZhaWwsIHN0ZW5jaWxaUGFzcyApIHtcblxuXHRcdFx0XHRpZiAoIGN1cnJlbnRTdGVuY2lsRmFpbCAhPT0gc3RlbmNpbEZhaWwgfHxcblx0XHRcdFx0ICAgICBjdXJyZW50U3RlbmNpbFpGYWlsICE9PSBzdGVuY2lsWkZhaWwgfHxcblx0XHRcdFx0ICAgICBjdXJyZW50U3RlbmNpbFpQYXNzICE9PSBzdGVuY2lsWlBhc3MgKSB7XG5cblx0XHRcdFx0XHRnbC5zdGVuY2lsT3AoIHN0ZW5jaWxGYWlsLCBzdGVuY2lsWkZhaWwsIHN0ZW5jaWxaUGFzcyApO1xuXG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGYWlsID0gc3RlbmNpbEZhaWw7XG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxaRmFpbCA9IHN0ZW5jaWxaRmFpbDtcblx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbFpQYXNzID0gc3RlbmNpbFpQYXNzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0TG9ja2VkOiBmdW5jdGlvbiAoIGxvY2sgKSB7XG5cblx0XHRcdFx0bG9ja2VkID0gbG9jaztcblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0Q2xlYXI6IGZ1bmN0aW9uICggc3RlbmNpbCApIHtcblxuXHRcdFx0XHRpZiAoIGN1cnJlbnRTdGVuY2lsQ2xlYXIgIT09IHN0ZW5jaWwgKSB7XG5cblx0XHRcdFx0XHRnbC5jbGVhclN0ZW5jaWwoIHN0ZW5jaWwgKTtcblx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbENsZWFyID0gc3RlbmNpbDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHRcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0bG9ja2VkID0gZmFsc2U7XG5cblx0XHRcdFx0Y3VycmVudFN0ZW5jaWxNYXNrID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGdW5jID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudFN0ZW5jaWxSZWYgPSBudWxsO1xuXHRcdFx0XHRjdXJyZW50U3RlbmNpbEZ1bmNNYXNrID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGYWlsID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudFN0ZW5jaWxaRmFpbCA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBudWxsO1xuXHRcdFx0XHRjdXJyZW50U3RlbmNpbENsZWFyID0gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHR9XG5cblx0Ly9cblxuXHRjb25zdCBjb2xvckJ1ZmZlciA9IG5ldyBDb2xvckJ1ZmZlcigpO1xuXHRjb25zdCBkZXB0aEJ1ZmZlciA9IG5ldyBEZXB0aEJ1ZmZlcigpO1xuXHRjb25zdCBzdGVuY2lsQnVmZmVyID0gbmV3IFN0ZW5jaWxCdWZmZXIoKTtcblxuXHRjb25zdCB1Ym9CaW5kaW5ncyA9IG5ldyBXZWFrTWFwKCk7XG5cdGNvbnN0IHVib1Byb2dyYW1NYXAgPSBuZXcgV2Vha01hcCgpO1xuXG5cdGxldCBlbmFibGVkQ2FwYWJpbGl0aWVzID0ge307XG5cblx0bGV0IGN1cnJlbnRCb3VuZEZyYW1lYnVmZmVycyA9IHt9O1xuXHRsZXQgY3VycmVudERyYXdidWZmZXJzID0gbmV3IFdlYWtNYXAoKTtcblx0bGV0IGRlZmF1bHREcmF3YnVmZmVycyA9IFtdO1xuXG5cdGxldCBjdXJyZW50UHJvZ3JhbSA9IG51bGw7XG5cblx0bGV0IGN1cnJlbnRCbGVuZGluZ0VuYWJsZWQgPSBmYWxzZTtcblx0bGV0IGN1cnJlbnRCbGVuZGluZyA9IG51bGw7XG5cdGxldCBjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XG5cdGxldCBjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xuXHRsZXQgY3VycmVudEJsZW5kRHN0ID0gbnVsbDtcblx0bGV0IGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuXHRsZXQgY3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xuXHRsZXQgY3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xuXHRsZXQgY3VycmVudEJsZW5kQ29sb3IgPSBuZXcgQ29sb3IoIDAsIDAsIDAgKTtcblx0bGV0IGN1cnJlbnRCbGVuZEFscGhhID0gMDtcblx0bGV0IGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSA9IGZhbHNlO1xuXG5cdGxldCBjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcblx0bGV0IGN1cnJlbnRDdWxsRmFjZSA9IG51bGw7XG5cblx0bGV0IGN1cnJlbnRMaW5lV2lkdGggPSBudWxsO1xuXG5cdGxldCBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IG51bGw7XG5cdGxldCBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gbnVsbDtcblxuXHRjb25zdCBtYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcblxuXHRsZXQgbGluZVdpZHRoQXZhaWxhYmxlID0gZmFsc2U7XG5cdGxldCB2ZXJzaW9uID0gMDtcblx0Y29uc3QgZ2xWZXJzaW9uID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5WRVJTSU9OICk7XG5cblx0aWYgKCBnbFZlcnNpb24uaW5kZXhPZiggJ1dlYkdMJyApICE9PSAtIDEgKSB7XG5cblx0XHR2ZXJzaW9uID0gcGFyc2VGbG9hdCggL15XZWJHTCAoXFxkKS8uZXhlYyggZ2xWZXJzaW9uIClbIDEgXSApO1xuXHRcdGxpbmVXaWR0aEF2YWlsYWJsZSA9ICggdmVyc2lvbiA+PSAxLjAgKTtcblxuXHR9IGVsc2UgaWYgKCBnbFZlcnNpb24uaW5kZXhPZiggJ09wZW5HTCBFUycgKSAhPT0gLSAxICkge1xuXG5cdFx0dmVyc2lvbiA9IHBhcnNlRmxvYXQoIC9eT3BlbkdMIEVTIChcXGQpLy5leGVjKCBnbFZlcnNpb24gKVsgMSBdICk7XG5cdFx0bGluZVdpZHRoQXZhaWxhYmxlID0gKCB2ZXJzaW9uID49IDIuMCApO1xuXG5cdH1cblxuXHRsZXQgY3VycmVudFRleHR1cmVTbG90ID0gbnVsbDtcblx0bGV0IGN1cnJlbnRCb3VuZFRleHR1cmVzID0ge307XG5cblx0Y29uc3Qgc2Npc3NvclBhcmFtID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5TQ0lTU09SX0JPWCApO1xuXHRjb25zdCB2aWV3cG9ydFBhcmFtID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5WSUVXUE9SVCApO1xuXG5cdGNvbnN0IGN1cnJlbnRTY2lzc29yID0gbmV3IFZlY3RvcjQoKS5mcm9tQXJyYXkoIHNjaXNzb3JQYXJhbSApO1xuXHRjb25zdCBjdXJyZW50Vmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpLmZyb21BcnJheSggdmlld3BvcnRQYXJhbSApO1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUoIHR5cGUsIHRhcmdldCwgY291bnQsIGRpbWVuc2lvbnMgKSB7XG5cblx0XHRjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoIDQgKTsgLy8gNCBpcyByZXF1aXJlZCB0byBtYXRjaCBkZWZhdWx0IHVucGFjayBhbGlnbm1lbnQgb2YgNC5cblx0XHRjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG5cdFx0Z2wuYmluZFRleHR1cmUoIHR5cGUsIHRleHR1cmUgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCB0eXBlLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCB0eXBlLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNvdW50OyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09IGdsLlRFWFRVUkVfM0QgfHwgdHlwZSA9PT0gZ2wuVEVYVFVSRV8yRF9BUlJBWSApIHtcblxuXHRcdFx0XHRnbC50ZXhJbWFnZTNEKCB0YXJnZXQsIDAsIGdsLlJHQkEsIDEsIDEsIGRpbWVuc2lvbnMsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRhdGEgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRnbC50ZXhJbWFnZTJEKCB0YXJnZXQgKyBpLCAwLCBnbC5SR0JBLCAxLCAxLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkYXRhICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH1cblxuXHRjb25zdCBlbXB0eVRleHR1cmVzID0ge307XG5cdGVtcHR5VGV4dHVyZXNbIGdsLlRFWFRVUkVfMkQgXSA9IGNyZWF0ZVRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfMkQsIDEgKTtcblx0ZW1wdHlUZXh0dXJlc1sgZ2wuVEVYVFVSRV9DVUJFX01BUCBdID0gY3JlYXRlVGV4dHVyZSggZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLCA2ICk7XG5cdGVtcHR5VGV4dHVyZXNbIGdsLlRFWFRVUkVfMkRfQVJSQVkgXSA9IGNyZWF0ZVRleHR1cmUoIGdsLlRFWFRVUkVfMkRfQVJSQVksIGdsLlRFWFRVUkVfMkRfQVJSQVksIDEsIDEgKTtcblx0ZW1wdHlUZXh0dXJlc1sgZ2wuVEVYVFVSRV8zRCBdID0gY3JlYXRlVGV4dHVyZSggZ2wuVEVYVFVSRV8zRCwgZ2wuVEVYVFVSRV8zRCwgMSwgMSApO1xuXG5cdC8vIGluaXRcblxuXHRjb2xvckJ1ZmZlci5zZXRDbGVhciggMCwgMCwgMCwgMSApO1xuXHRkZXB0aEJ1ZmZlci5zZXRDbGVhciggMSApO1xuXHRzdGVuY2lsQnVmZmVyLnNldENsZWFyKCAwICk7XG5cblx0ZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cdGRlcHRoQnVmZmVyLnNldEZ1bmMoIExlc3NFcXVhbERlcHRoICk7XG5cblx0c2V0RmxpcFNpZGVkKCBmYWxzZSApO1xuXHRzZXRDdWxsRmFjZSggQ3VsbEZhY2VCYWNrICk7XG5cdGVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG5cblx0c2V0QmxlbmRpbmcoIE5vQmxlbmRpbmcgKTtcblxuXHQvL1xuXG5cdGZ1bmN0aW9uIGVuYWJsZSggaWQgKSB7XG5cblx0XHRpZiAoIGVuYWJsZWRDYXBhYmlsaXRpZXNbIGlkIF0gIT09IHRydWUgKSB7XG5cblx0XHRcdGdsLmVuYWJsZSggaWQgKTtcblx0XHRcdGVuYWJsZWRDYXBhYmlsaXRpZXNbIGlkIF0gPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBkaXNhYmxlKCBpZCApIHtcblxuXHRcdGlmICggZW5hYmxlZENhcGFiaWxpdGllc1sgaWQgXSAhPT0gZmFsc2UgKSB7XG5cblx0XHRcdGdsLmRpc2FibGUoIGlkICk7XG5cdFx0XHRlbmFibGVkQ2FwYWJpbGl0aWVzWyBpZCBdID0gZmFsc2U7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGJpbmRGcmFtZWJ1ZmZlciggdGFyZ2V0LCBmcmFtZWJ1ZmZlciApIHtcblxuXHRcdGlmICggY3VycmVudEJvdW5kRnJhbWVidWZmZXJzWyB0YXJnZXQgXSAhPT0gZnJhbWVidWZmZXIgKSB7XG5cblx0XHRcdGdsLmJpbmRGcmFtZWJ1ZmZlciggdGFyZ2V0LCBmcmFtZWJ1ZmZlciApO1xuXG5cdFx0XHRjdXJyZW50Qm91bmRGcmFtZWJ1ZmZlcnNbIHRhcmdldCBdID0gZnJhbWVidWZmZXI7XG5cblx0XHRcdC8vIGdsLkRSQVdfRlJBTUVCVUZGRVIgaXMgZXF1aXZhbGVudCB0byBnbC5GUkFNRUJVRkZFUlxuXG5cdFx0XHRpZiAoIHRhcmdldCA9PT0gZ2wuRFJBV19GUkFNRUJVRkZFUiApIHtcblxuXHRcdFx0XHRjdXJyZW50Qm91bmRGcmFtZWJ1ZmZlcnNbIGdsLkZSQU1FQlVGRkVSIF0gPSBmcmFtZWJ1ZmZlcjtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRhcmdldCA9PT0gZ2wuRlJBTUVCVUZGRVIgKSB7XG5cblx0XHRcdFx0Y3VycmVudEJvdW5kRnJhbWVidWZmZXJzWyBnbC5EUkFXX0ZSQU1FQlVGRkVSIF0gPSBmcmFtZWJ1ZmZlcjtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZHJhd0J1ZmZlcnMoIHJlbmRlclRhcmdldCwgZnJhbWVidWZmZXIgKSB7XG5cblx0XHRsZXQgZHJhd0J1ZmZlcnMgPSBkZWZhdWx0RHJhd2J1ZmZlcnM7XG5cblx0XHRsZXQgbmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdGlmICggcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0XHRkcmF3QnVmZmVycyA9IGN1cnJlbnREcmF3YnVmZmVycy5nZXQoIGZyYW1lYnVmZmVyICk7XG5cblx0XHRcdGlmICggZHJhd0J1ZmZlcnMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRkcmF3QnVmZmVycyA9IFtdO1xuXHRcdFx0XHRjdXJyZW50RHJhd2J1ZmZlcnMuc2V0KCBmcmFtZWJ1ZmZlciwgZHJhd0J1ZmZlcnMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0ZXh0dXJlcyA9IHJlbmRlclRhcmdldC50ZXh0dXJlcztcblxuXHRcdFx0aWYgKCBkcmF3QnVmZmVycy5sZW5ndGggIT09IHRleHR1cmVzLmxlbmd0aCB8fCBkcmF3QnVmZmVyc1sgMCBdICE9PSBnbC5DT0xPUl9BVFRBQ0hNRU5UMCApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGV4dHVyZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRkcmF3QnVmZmVyc1sgaSBdID0gZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkcmF3QnVmZmVycy5sZW5ndGggPSB0ZXh0dXJlcy5sZW5ndGg7XG5cblx0XHRcdFx0bmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIGRyYXdCdWZmZXJzWyAwIF0gIT09IGdsLkJBQ0sgKSB7XG5cblx0XHRcdFx0ZHJhd0J1ZmZlcnNbIDAgXSA9IGdsLkJBQ0s7XG5cblx0XHRcdFx0bmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRnbC5kcmF3QnVmZmVycyggZHJhd0J1ZmZlcnMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gdXNlUHJvZ3JhbSggcHJvZ3JhbSApIHtcblxuXHRcdGlmICggY3VycmVudFByb2dyYW0gIT09IHByb2dyYW0gKSB7XG5cblx0XHRcdGdsLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcblxuXHRcdFx0Y3VycmVudFByb2dyYW0gPSBwcm9ncmFtO1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9XG5cblx0Y29uc3QgZXF1YXRpb25Ub0dMID0ge1xuXHRcdFsgQWRkRXF1YXRpb24gXTogZ2wuRlVOQ19BREQsXG5cdFx0WyBTdWJ0cmFjdEVxdWF0aW9uIF06IGdsLkZVTkNfU1VCVFJBQ1QsXG5cdFx0WyBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbiBdOiBnbC5GVU5DX1JFVkVSU0VfU1VCVFJBQ1Rcblx0fTtcblxuXHRlcXVhdGlvblRvR0xbIE1pbkVxdWF0aW9uIF0gPSBnbC5NSU47XG5cdGVxdWF0aW9uVG9HTFsgTWF4RXF1YXRpb24gXSA9IGdsLk1BWDtcblxuXHRjb25zdCBmYWN0b3JUb0dMID0ge1xuXHRcdFsgWmVyb0ZhY3RvciBdOiBnbC5aRVJPLFxuXHRcdFsgT25lRmFjdG9yIF06IGdsLk9ORSxcblx0XHRbIFNyY0NvbG9yRmFjdG9yIF06IGdsLlNSQ19DT0xPUixcblx0XHRbIFNyY0FscGhhRmFjdG9yIF06IGdsLlNSQ19BTFBIQSxcblx0XHRbIFNyY0FscGhhU2F0dXJhdGVGYWN0b3IgXTogZ2wuU1JDX0FMUEhBX1NBVFVSQVRFLFxuXHRcdFsgRHN0Q29sb3JGYWN0b3IgXTogZ2wuRFNUX0NPTE9SLFxuXHRcdFsgRHN0QWxwaGFGYWN0b3IgXTogZ2wuRFNUX0FMUEhBLFxuXHRcdFsgT25lTWludXNTcmNDb2xvckZhY3RvciBdOiBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLFxuXHRcdFsgT25lTWludXNTcmNBbHBoYUZhY3RvciBdOiBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLFxuXHRcdFsgT25lTWludXNEc3RDb2xvckZhY3RvciBdOiBnbC5PTkVfTUlOVVNfRFNUX0NPTE9SLFxuXHRcdFsgT25lTWludXNEc3RBbHBoYUZhY3RvciBdOiBnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLFxuXHRcdFsgQ29uc3RhbnRDb2xvckZhY3RvciBdOiBnbC5DT05TVEFOVF9DT0xPUixcblx0XHRbIE9uZU1pbnVzQ29uc3RhbnRDb2xvckZhY3RvciBdOiBnbC5PTkVfTUlOVVNfQ09OU1RBTlRfQ09MT1IsXG5cdFx0WyBDb25zdGFudEFscGhhRmFjdG9yIF06IGdsLkNPTlNUQU5UX0FMUEhBLFxuXHRcdFsgT25lTWludXNDb25zdGFudEFscGhhRmFjdG9yIF06IGdsLk9ORV9NSU5VU19DT05TVEFOVF9BTFBIQVxuXHR9O1xuXG5cdGZ1bmN0aW9uIHNldEJsZW5kaW5nKCBibGVuZGluZywgYmxlbmRFcXVhdGlvbiwgYmxlbmRTcmMsIGJsZW5kRHN0LCBibGVuZEVxdWF0aW9uQWxwaGEsIGJsZW5kU3JjQWxwaGEsIGJsZW5kRHN0QWxwaGEsIGJsZW5kQ29sb3IsIGJsZW5kQWxwaGEsIHByZW11bHRpcGxpZWRBbHBoYSApIHtcblxuXHRcdGlmICggYmxlbmRpbmcgPT09IE5vQmxlbmRpbmcgKSB7XG5cblx0XHRcdGlmICggY3VycmVudEJsZW5kaW5nRW5hYmxlZCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRkaXNhYmxlKCBnbC5CTEVORCApO1xuXHRcdFx0XHRjdXJyZW50QmxlbmRpbmdFbmFibGVkID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBjdXJyZW50QmxlbmRpbmdFbmFibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0ZW5hYmxlKCBnbC5CTEVORCApO1xuXHRcdFx0Y3VycmVudEJsZW5kaW5nRW5hYmxlZCA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRpZiAoIGJsZW5kaW5nICE9PSBDdXN0b21CbGVuZGluZyApIHtcblxuXHRcdFx0aWYgKCBibGVuZGluZyAhPT0gY3VycmVudEJsZW5kaW5nIHx8IHByZW11bHRpcGxpZWRBbHBoYSAhPT0gY3VycmVudFByZW11bHRpcGxlZEFscGhhICkge1xuXG5cdFx0XHRcdGlmICggY3VycmVudEJsZW5kRXF1YXRpb24gIT09IEFkZEVxdWF0aW9uIHx8IGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgIT09IEFkZEVxdWF0aW9uICkge1xuXG5cdFx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcblxuXHRcdFx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gQWRkRXF1YXRpb247XG5cdFx0XHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IEFkZEVxdWF0aW9uO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHByZW11bHRpcGxpZWRBbHBoYSApIHtcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGJsZW5kaW5nICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlIE5vcm1hbEJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgQWRkaXRpdmVCbGVuZGluZzpcblx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5PTkUsIGdsLk9ORSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBTdWJ0cmFjdGl2ZUJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiwgZ2wuWkVSTywgZ2wuT05FICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIE11bHRpcGx5QmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5aRVJPLCBnbC5TUkNfQ09MT1IsIGdsLlpFUk8sIGdsLlNSQ19BTFBIQSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU3RhdGU6IEludmFsaWQgYmxlbmRpbmc6ICcsIGJsZW5kaW5nICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBibGVuZGluZyApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSBOb3JtYWxCbGVuZGluZzpcblx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIEFkZGl0aXZlQmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgU3VidHJhY3RpdmVCbGVuZGluZzpcblx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IsIGdsLlpFUk8sIGdsLk9ORSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBNdWx0aXBseUJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlpFUk8sIGdsLlNSQ19DT0xPUiApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU3RhdGU6IEludmFsaWQgYmxlbmRpbmc6ICcsIGJsZW5kaW5nICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xuXHRcdFx0XHRjdXJyZW50QmxlbmREc3QgPSBudWxsO1xuXHRcdFx0XHRjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudEJsZW5kQ29sb3Iuc2V0KCAwLCAwLCAwICk7XG5cdFx0XHRcdGN1cnJlbnRCbGVuZEFscGhhID0gMDtcblxuXHRcdFx0XHRjdXJyZW50QmxlbmRpbmcgPSBibGVuZGluZztcblx0XHRcdFx0Y3VycmVudFByZW11bHRpcGxlZEFscGhhID0gcHJlbXVsdGlwbGllZEFscGhhO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdC8vIGN1c3RvbSBibGVuZGluZ1xuXG5cdFx0YmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhIHx8IGJsZW5kRXF1YXRpb247XG5cdFx0YmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGEgfHwgYmxlbmRTcmM7XG5cdFx0YmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGEgfHwgYmxlbmREc3Q7XG5cblx0XHRpZiAoIGJsZW5kRXF1YXRpb24gIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uIHx8IGJsZW5kRXF1YXRpb25BbHBoYSAhPT0gY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSApIHtcblxuXHRcdFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBlcXVhdGlvblRvR0xbIGJsZW5kRXF1YXRpb24gXSwgZXF1YXRpb25Ub0dMWyBibGVuZEVxdWF0aW9uQWxwaGEgXSApO1xuXG5cdFx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbiA9IGJsZW5kRXF1YXRpb247XG5cdFx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBibGVuZFNyYyAhPT0gY3VycmVudEJsZW5kU3JjIHx8IGJsZW5kRHN0ICE9PSBjdXJyZW50QmxlbmREc3QgfHwgYmxlbmRTcmNBbHBoYSAhPT0gY3VycmVudEJsZW5kU3JjQWxwaGEgfHwgYmxlbmREc3RBbHBoYSAhPT0gY3VycmVudEJsZW5kRHN0QWxwaGEgKSB7XG5cblx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBmYWN0b3JUb0dMWyBibGVuZFNyYyBdLCBmYWN0b3JUb0dMWyBibGVuZERzdCBdLCBmYWN0b3JUb0dMWyBibGVuZFNyY0FscGhhIF0sIGZhY3RvclRvR0xbIGJsZW5kRHN0QWxwaGEgXSApO1xuXG5cdFx0XHRjdXJyZW50QmxlbmRTcmMgPSBibGVuZFNyYztcblx0XHRcdGN1cnJlbnRCbGVuZERzdCA9IGJsZW5kRHN0O1xuXHRcdFx0Y3VycmVudEJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhO1xuXHRcdFx0Y3VycmVudEJsZW5kRHN0QWxwaGEgPSBibGVuZERzdEFscGhhO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBibGVuZENvbG9yLmVxdWFscyggY3VycmVudEJsZW5kQ29sb3IgKSA9PT0gZmFsc2UgfHwgYmxlbmRBbHBoYSAhPT0gY3VycmVudEJsZW5kQWxwaGEgKSB7XG5cblx0XHRcdGdsLmJsZW5kQ29sb3IoIGJsZW5kQ29sb3IuciwgYmxlbmRDb2xvci5nLCBibGVuZENvbG9yLmIsIGJsZW5kQWxwaGEgKTtcblxuXHRcdFx0Y3VycmVudEJsZW5kQ29sb3IuY29weSggYmxlbmRDb2xvciApO1xuXHRcdFx0Y3VycmVudEJsZW5kQWxwaGEgPSBibGVuZEFscGhhO1xuXG5cdFx0fVxuXG5cdFx0Y3VycmVudEJsZW5kaW5nID0gYmxlbmRpbmc7XG5cdFx0Y3VycmVudFByZW11bHRpcGxlZEFscGhhID0gZmFsc2U7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldE1hdGVyaWFsKCBtYXRlcmlhbCwgZnJvbnRGYWNlQ1cgKSB7XG5cblx0XHRtYXRlcmlhbC5zaWRlID09PSBEb3VibGVTaWRlXG5cdFx0XHQ/IGRpc2FibGUoIGdsLkNVTExfRkFDRSApXG5cdFx0XHQ6IGVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG5cblx0XHRsZXQgZmxpcFNpZGVkID0gKCBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSApO1xuXHRcdGlmICggZnJvbnRGYWNlQ1cgKSBmbGlwU2lkZWQgPSAhIGZsaXBTaWRlZDtcblxuXHRcdHNldEZsaXBTaWRlZCggZmxpcFNpZGVkICk7XG5cblx0XHQoIG1hdGVyaWFsLmJsZW5kaW5nID09PSBOb3JtYWxCbGVuZGluZyAmJiBtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gZmFsc2UgKVxuXHRcdFx0PyBzZXRCbGVuZGluZyggTm9CbGVuZGluZyApXG5cdFx0XHQ6IHNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0LCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uQWxwaGEsIG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEsIG1hdGVyaWFsLmJsZW5kRHN0QWxwaGEsIG1hdGVyaWFsLmJsZW5kQ29sb3IsIG1hdGVyaWFsLmJsZW5kQWxwaGEsIG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSApO1xuXG5cdFx0ZGVwdGhCdWZmZXIuc2V0RnVuYyggbWF0ZXJpYWwuZGVwdGhGdW5jICk7XG5cdFx0ZGVwdGhCdWZmZXIuc2V0VGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XG5cdFx0ZGVwdGhCdWZmZXIuc2V0TWFzayggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xuXHRcdGNvbG9yQnVmZmVyLnNldE1hc2soIG1hdGVyaWFsLmNvbG9yV3JpdGUgKTtcblxuXHRcdGNvbnN0IHN0ZW5jaWxXcml0ZSA9IG1hdGVyaWFsLnN0ZW5jaWxXcml0ZTtcblx0XHRzdGVuY2lsQnVmZmVyLnNldFRlc3QoIHN0ZW5jaWxXcml0ZSApO1xuXHRcdGlmICggc3RlbmNpbFdyaXRlICkge1xuXG5cdFx0XHRzdGVuY2lsQnVmZmVyLnNldE1hc2soIG1hdGVyaWFsLnN0ZW5jaWxXcml0ZU1hc2sgKTtcblx0XHRcdHN0ZW5jaWxCdWZmZXIuc2V0RnVuYyggbWF0ZXJpYWwuc3RlbmNpbEZ1bmMsIG1hdGVyaWFsLnN0ZW5jaWxSZWYsIG1hdGVyaWFsLnN0ZW5jaWxGdW5jTWFzayApO1xuXHRcdFx0c3RlbmNpbEJ1ZmZlci5zZXRPcCggbWF0ZXJpYWwuc3RlbmNpbEZhaWwsIG1hdGVyaWFsLnN0ZW5jaWxaRmFpbCwgbWF0ZXJpYWwuc3RlbmNpbFpQYXNzICk7XG5cblx0XHR9XG5cblx0XHRzZXRQb2x5Z29uT2Zmc2V0KCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0LCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgKTtcblxuXHRcdG1hdGVyaWFsLmFscGhhVG9Db3ZlcmFnZSA9PT0gdHJ1ZVxuXHRcdFx0PyBlbmFibGUoIGdsLlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSApXG5cdFx0XHQ6IGRpc2FibGUoIGdsLlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSApO1xuXG5cdH1cblxuXHQvL1xuXG5cdGZ1bmN0aW9uIHNldEZsaXBTaWRlZCggZmxpcFNpZGVkICkge1xuXG5cdFx0aWYgKCBjdXJyZW50RmxpcFNpZGVkICE9PSBmbGlwU2lkZWQgKSB7XG5cblx0XHRcdGlmICggZmxpcFNpZGVkICkge1xuXG5cdFx0XHRcdGdsLmZyb250RmFjZSggZ2wuQ1cgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRnbC5mcm9udEZhY2UoIGdsLkNDVyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGN1cnJlbnRGbGlwU2lkZWQgPSBmbGlwU2lkZWQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldEN1bGxGYWNlKCBjdWxsRmFjZSApIHtcblxuXHRcdGlmICggY3VsbEZhY2UgIT09IEN1bGxGYWNlTm9uZSApIHtcblxuXHRcdFx0ZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblxuXHRcdFx0aWYgKCBjdWxsRmFjZSAhPT0gY3VycmVudEN1bGxGYWNlICkge1xuXG5cdFx0XHRcdGlmICggY3VsbEZhY2UgPT09IEN1bGxGYWNlQmFjayApIHtcblxuXHRcdFx0XHRcdGdsLmN1bGxGYWNlKCBnbC5CQUNLICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggY3VsbEZhY2UgPT09IEN1bGxGYWNlRnJvbnQgKSB7XG5cblx0XHRcdFx0XHRnbC5jdWxsRmFjZSggZ2wuRlJPTlQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Z2wuY3VsbEZhY2UoIGdsLkZST05UX0FORF9CQUNLICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRkaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblxuXHRcdH1cblxuXHRcdGN1cnJlbnRDdWxsRmFjZSA9IGN1bGxGYWNlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRMaW5lV2lkdGgoIHdpZHRoICkge1xuXG5cdFx0aWYgKCB3aWR0aCAhPT0gY3VycmVudExpbmVXaWR0aCApIHtcblxuXHRcdFx0aWYgKCBsaW5lV2lkdGhBdmFpbGFibGUgKSBnbC5saW5lV2lkdGgoIHdpZHRoICk7XG5cblx0XHRcdGN1cnJlbnRMaW5lV2lkdGggPSB3aWR0aDtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0UG9seWdvbk9mZnNldCggcG9seWdvbk9mZnNldCwgZmFjdG9yLCB1bml0cyApIHtcblxuXHRcdGlmICggcG9seWdvbk9mZnNldCApIHtcblxuXHRcdFx0ZW5hYmxlKCBnbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XG5cblx0XHRcdGlmICggY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgIT09IGZhY3RvciB8fCBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzICE9PSB1bml0cyApIHtcblxuXHRcdFx0XHRnbC5wb2x5Z29uT2Zmc2V0KCBmYWN0b3IsIHVuaXRzICk7XG5cblx0XHRcdFx0Y3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBmYWN0b3I7XG5cdFx0XHRcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSB1bml0cztcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0ZGlzYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRTY2lzc29yVGVzdCggc2Npc3NvclRlc3QgKSB7XG5cblx0XHRpZiAoIHNjaXNzb3JUZXN0ICkge1xuXG5cdFx0XHRlbmFibGUoIGdsLlNDSVNTT1JfVEVTVCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0ZGlzYWJsZSggZ2wuU0NJU1NPUl9URVNUICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIHRleHR1cmVcblxuXHRmdW5jdGlvbiBhY3RpdmVUZXh0dXJlKCB3ZWJnbFNsb3QgKSB7XG5cblx0XHRpZiAoIHdlYmdsU2xvdCA9PT0gdW5kZWZpbmVkICkgd2ViZ2xTbG90ID0gZ2wuVEVYVFVSRTAgKyBtYXhUZXh0dXJlcyAtIDE7XG5cblx0XHRpZiAoIGN1cnJlbnRUZXh0dXJlU2xvdCAhPT0gd2ViZ2xTbG90ICkge1xuXG5cdFx0XHRnbC5hY3RpdmVUZXh0dXJlKCB3ZWJnbFNsb3QgKTtcblx0XHRcdGN1cnJlbnRUZXh0dXJlU2xvdCA9IHdlYmdsU2xvdDtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gYmluZFRleHR1cmUoIHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlLCB3ZWJnbFNsb3QgKSB7XG5cblx0XHRpZiAoIHdlYmdsU2xvdCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIGN1cnJlbnRUZXh0dXJlU2xvdCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHR3ZWJnbFNsb3QgPSBnbC5URVhUVVJFMCArIG1heFRleHR1cmVzIC0gMTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR3ZWJnbFNsb3QgPSBjdXJyZW50VGV4dHVyZVNsb3Q7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGxldCBib3VuZFRleHR1cmUgPSBjdXJyZW50Qm91bmRUZXh0dXJlc1sgd2ViZ2xTbG90IF07XG5cblx0XHRpZiAoIGJvdW5kVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRib3VuZFRleHR1cmUgPSB7IHR5cGU6IHVuZGVmaW5lZCwgdGV4dHVyZTogdW5kZWZpbmVkIH07XG5cdFx0XHRjdXJyZW50Qm91bmRUZXh0dXJlc1sgd2ViZ2xTbG90IF0gPSBib3VuZFRleHR1cmU7XG5cblx0XHR9XG5cblx0XHRpZiAoIGJvdW5kVGV4dHVyZS50eXBlICE9PSB3ZWJnbFR5cGUgfHwgYm91bmRUZXh0dXJlLnRleHR1cmUgIT09IHdlYmdsVGV4dHVyZSApIHtcblxuXHRcdFx0aWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgIT09IHdlYmdsU2xvdCApIHtcblxuXHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKCB3ZWJnbFNsb3QgKTtcblx0XHRcdFx0Y3VycmVudFRleHR1cmVTbG90ID0gd2ViZ2xTbG90O1xuXG5cdFx0XHR9XG5cblx0XHRcdGdsLmJpbmRUZXh0dXJlKCB3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSB8fCBlbXB0eVRleHR1cmVzWyB3ZWJnbFR5cGUgXSApO1xuXG5cdFx0XHRib3VuZFRleHR1cmUudHlwZSA9IHdlYmdsVHlwZTtcblx0XHRcdGJvdW5kVGV4dHVyZS50ZXh0dXJlID0gd2ViZ2xUZXh0dXJlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB1bmJpbmRUZXh0dXJlKCkge1xuXG5cdFx0Y29uc3QgYm91bmRUZXh0dXJlID0gY3VycmVudEJvdW5kVGV4dHVyZXNbIGN1cnJlbnRUZXh0dXJlU2xvdCBdO1xuXG5cdFx0aWYgKCBib3VuZFRleHR1cmUgIT09IHVuZGVmaW5lZCAmJiBib3VuZFRleHR1cmUudHlwZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRnbC5iaW5kVGV4dHVyZSggYm91bmRUZXh0dXJlLnR5cGUsIG51bGwgKTtcblxuXHRcdFx0Ym91bmRUZXh0dXJlLnR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0XHRib3VuZFRleHR1cmUudGV4dHVyZSA9IHVuZGVmaW5lZDtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gY29tcHJlc3NlZFRleEltYWdlMkQoKSB7XG5cblx0XHR0cnkge1xuXG5cdFx0XHRnbC5jb21wcmVzc2VkVGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvciApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBjb21wcmVzc2VkVGV4SW1hZ2UzRCgpIHtcblxuXHRcdHRyeSB7XG5cblx0XHRcdGdsLmNvbXByZXNzZWRUZXhJbWFnZTNELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XG5cblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHRleFN1YkltYWdlMkQoKSB7XG5cblx0XHR0cnkge1xuXG5cdFx0XHRnbC50ZXhTdWJJbWFnZTJELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XG5cblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHRleFN1YkltYWdlM0QoKSB7XG5cblx0XHR0cnkge1xuXG5cdFx0XHRnbC50ZXhTdWJJbWFnZTNELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XG5cblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKCkge1xuXG5cdFx0dHJ5IHtcblxuXHRcdFx0Z2wuY29tcHJlc3NlZFRleFN1YkltYWdlMkQuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcblxuXHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gY29tcHJlc3NlZFRleFN1YkltYWdlM0QoKSB7XG5cblx0XHR0cnkge1xuXG5cdFx0XHRnbC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UzRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvciApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB0ZXhTdG9yYWdlMkQoKSB7XG5cblx0XHR0cnkge1xuXG5cdFx0XHRnbC50ZXhTdG9yYWdlMkQuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcblxuXHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gdGV4U3RvcmFnZTNEKCkge1xuXG5cdFx0dHJ5IHtcblxuXHRcdFx0Z2wudGV4U3RvcmFnZTNELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XG5cblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHRleEltYWdlMkQoKSB7XG5cblx0XHR0cnkge1xuXG5cdFx0XHRnbC50ZXhJbWFnZTJELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XG5cblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHRleEltYWdlM0QoKSB7XG5cblx0XHR0cnkge1xuXG5cdFx0XHRnbC50ZXhJbWFnZTNELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XG5cblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vXG5cblx0ZnVuY3Rpb24gc2Npc3Nvciggc2Npc3NvciApIHtcblxuXHRcdGlmICggY3VycmVudFNjaXNzb3IuZXF1YWxzKCBzY2lzc29yICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRnbC5zY2lzc29yKCBzY2lzc29yLngsIHNjaXNzb3IueSwgc2Npc3Nvci56LCBzY2lzc29yLncgKTtcblx0XHRcdGN1cnJlbnRTY2lzc29yLmNvcHkoIHNjaXNzb3IgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gdmlld3BvcnQoIHZpZXdwb3J0ICkge1xuXG5cdFx0aWYgKCBjdXJyZW50Vmlld3BvcnQuZXF1YWxzKCB2aWV3cG9ydCApID09PSBmYWxzZSApIHtcblxuXHRcdFx0Z2wudmlld3BvcnQoIHZpZXdwb3J0LngsIHZpZXdwb3J0LnksIHZpZXdwb3J0LnosIHZpZXdwb3J0LncgKTtcblx0XHRcdGN1cnJlbnRWaWV3cG9ydC5jb3B5KCB2aWV3cG9ydCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVVQk9NYXBwaW5nKCB1bmlmb3Jtc0dyb3VwLCBwcm9ncmFtICkge1xuXG5cdFx0bGV0IG1hcHBpbmcgPSB1Ym9Qcm9ncmFtTWFwLmdldCggcHJvZ3JhbSApO1xuXG5cdFx0aWYgKCBtYXBwaW5nID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hcHBpbmcgPSBuZXcgV2Vha01hcCgpO1xuXG5cdFx0XHR1Ym9Qcm9ncmFtTWFwLnNldCggcHJvZ3JhbSwgbWFwcGluZyApO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGJsb2NrSW5kZXggPSBtYXBwaW5nLmdldCggdW5pZm9ybXNHcm91cCApO1xuXG5cdFx0aWYgKCBibG9ja0luZGV4ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGJsb2NrSW5kZXggPSBnbC5nZXRVbmlmb3JtQmxvY2tJbmRleCggcHJvZ3JhbSwgdW5pZm9ybXNHcm91cC5uYW1lICk7XG5cblx0XHRcdG1hcHBpbmcuc2V0KCB1bmlmb3Jtc0dyb3VwLCBibG9ja0luZGV4ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHVuaWZvcm1CbG9ja0JpbmRpbmcoIHVuaWZvcm1zR3JvdXAsIHByb2dyYW0gKSB7XG5cblx0XHRjb25zdCBtYXBwaW5nID0gdWJvUHJvZ3JhbU1hcC5nZXQoIHByb2dyYW0gKTtcblx0XHRjb25zdCBibG9ja0luZGV4ID0gbWFwcGluZy5nZXQoIHVuaWZvcm1zR3JvdXAgKTtcblxuXHRcdGlmICggdWJvQmluZGluZ3MuZ2V0KCBwcm9ncmFtICkgIT09IGJsb2NrSW5kZXggKSB7XG5cblx0XHRcdC8vIGJpbmQgc2hhZGVyIHNwZWNpZmljIGJsb2NrIGluZGV4IHRvIGdsb2JhbCBibG9jayBwb2ludFxuXHRcdFx0Z2wudW5pZm9ybUJsb2NrQmluZGluZyggcHJvZ3JhbSwgYmxvY2tJbmRleCwgdW5pZm9ybXNHcm91cC5fX2JpbmRpbmdQb2ludEluZGV4ICk7XG5cblx0XHRcdHVib0JpbmRpbmdzLnNldCggcHJvZ3JhbSwgYmxvY2tJbmRleCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvL1xuXG5cdGZ1bmN0aW9uIHJlc2V0KCkge1xuXG5cdFx0Ly8gcmVzZXQgc3RhdGVcblxuXHRcdGdsLmRpc2FibGUoIGdsLkJMRU5EICk7XG5cdFx0Z2wuZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG5cdFx0Z2wuZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXHRcdGdsLmRpc2FibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcblx0XHRnbC5kaXNhYmxlKCBnbC5TQ0lTU09SX1RFU1QgKTtcblx0XHRnbC5kaXNhYmxlKCBnbC5TVEVOQ0lMX1RFU1QgKTtcblx0XHRnbC5kaXNhYmxlKCBnbC5TQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0UgKTtcblxuXHRcdGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XG5cdFx0Z2wuYmxlbmRGdW5jKCBnbC5PTkUsIGdsLlpFUk8gKTtcblx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuT05FLCBnbC5aRVJPLCBnbC5PTkUsIGdsLlpFUk8gKTtcblx0XHRnbC5ibGVuZENvbG9yKCAwLCAwLCAwLCAwICk7XG5cblx0XHRnbC5jb2xvck1hc2soIHRydWUsIHRydWUsIHRydWUsIHRydWUgKTtcblx0XHRnbC5jbGVhckNvbG9yKCAwLCAwLCAwLCAwICk7XG5cblx0XHRnbC5kZXB0aE1hc2soIHRydWUgKTtcblx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFU1MgKTtcblxuXHRcdGRlcHRoQnVmZmVyLnNldFJldmVyc2VkKCBmYWxzZSApO1xuXG5cdFx0Z2wuY2xlYXJEZXB0aCggMSApO1xuXG5cdFx0Z2wuc3RlbmNpbE1hc2soIDB4ZmZmZmZmZmYgKTtcblx0XHRnbC5zdGVuY2lsRnVuYyggZ2wuQUxXQVlTLCAwLCAweGZmZmZmZmZmICk7XG5cdFx0Z2wuc3RlbmNpbE9wKCBnbC5LRUVQLCBnbC5LRUVQLCBnbC5LRUVQICk7XG5cdFx0Z2wuY2xlYXJTdGVuY2lsKCAwICk7XG5cblx0XHRnbC5jdWxsRmFjZSggZ2wuQkFDSyApO1xuXHRcdGdsLmZyb250RmFjZSggZ2wuQ0NXICk7XG5cblx0XHRnbC5wb2x5Z29uT2Zmc2V0KCAwLCAwICk7XG5cblx0XHRnbC5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRFJBV19GUkFNRUJVRkZFUiwgbnVsbCApO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuUkVBRF9GUkFNRUJVRkZFUiwgbnVsbCApO1xuXG5cdFx0Z2wudXNlUHJvZ3JhbSggbnVsbCApO1xuXG5cdFx0Z2wubGluZVdpZHRoKCAxICk7XG5cblx0XHRnbC5zY2lzc29yKCAwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQgKTtcblx0XHRnbC52aWV3cG9ydCggMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0ICk7XG5cblx0XHQvLyByZXNldCBpbnRlcm5hbHNcblxuXHRcdGVuYWJsZWRDYXBhYmlsaXRpZXMgPSB7fTtcblxuXHRcdGN1cnJlbnRUZXh0dXJlU2xvdCA9IG51bGw7XG5cdFx0Y3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcblxuXHRcdGN1cnJlbnRCb3VuZEZyYW1lYnVmZmVycyA9IHt9O1xuXHRcdGN1cnJlbnREcmF3YnVmZmVycyA9IG5ldyBXZWFrTWFwKCk7XG5cdFx0ZGVmYXVsdERyYXdidWZmZXJzID0gW107XG5cblx0XHRjdXJyZW50UHJvZ3JhbSA9IG51bGw7XG5cblx0XHRjdXJyZW50QmxlbmRpbmdFbmFibGVkID0gZmFsc2U7XG5cdFx0Y3VycmVudEJsZW5kaW5nID0gbnVsbDtcblx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XG5cdFx0Y3VycmVudEJsZW5kU3JjID0gbnVsbDtcblx0XHRjdXJyZW50QmxlbmREc3QgPSBudWxsO1xuXHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuXHRcdGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcblx0XHRjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XG5cdFx0Y3VycmVudEJsZW5kQ29sb3IgPSBuZXcgQ29sb3IoIDAsIDAsIDAgKTtcblx0XHRjdXJyZW50QmxlbmRBbHBoYSA9IDA7XG5cdFx0Y3VycmVudFByZW11bHRpcGxlZEFscGhhID0gZmFsc2U7XG5cblx0XHRjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcblx0XHRjdXJyZW50Q3VsbEZhY2UgPSBudWxsO1xuXG5cdFx0Y3VycmVudExpbmVXaWR0aCA9IG51bGw7XG5cblx0XHRjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IG51bGw7XG5cdFx0Y3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IG51bGw7XG5cblx0XHRjdXJyZW50U2Npc3Nvci5zZXQoIDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCApO1xuXHRcdGN1cnJlbnRWaWV3cG9ydC5zZXQoIDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCApO1xuXG5cdFx0Y29sb3JCdWZmZXIucmVzZXQoKTtcblx0XHRkZXB0aEJ1ZmZlci5yZXNldCgpO1xuXHRcdHN0ZW5jaWxCdWZmZXIucmVzZXQoKTtcblxuXHR9XG5cblx0cmV0dXJuIHtcblxuXHRcdGJ1ZmZlcnM6IHtcblx0XHRcdGNvbG9yOiBjb2xvckJ1ZmZlcixcblx0XHRcdGRlcHRoOiBkZXB0aEJ1ZmZlcixcblx0XHRcdHN0ZW5jaWw6IHN0ZW5jaWxCdWZmZXJcblx0XHR9LFxuXG5cdFx0ZW5hYmxlOiBlbmFibGUsXG5cdFx0ZGlzYWJsZTogZGlzYWJsZSxcblxuXHRcdGJpbmRGcmFtZWJ1ZmZlcjogYmluZEZyYW1lYnVmZmVyLFxuXHRcdGRyYXdCdWZmZXJzOiBkcmF3QnVmZmVycyxcblxuXHRcdHVzZVByb2dyYW06IHVzZVByb2dyYW0sXG5cblx0XHRzZXRCbGVuZGluZzogc2V0QmxlbmRpbmcsXG5cdFx0c2V0TWF0ZXJpYWw6IHNldE1hdGVyaWFsLFxuXG5cdFx0c2V0RmxpcFNpZGVkOiBzZXRGbGlwU2lkZWQsXG5cdFx0c2V0Q3VsbEZhY2U6IHNldEN1bGxGYWNlLFxuXG5cdFx0c2V0TGluZVdpZHRoOiBzZXRMaW5lV2lkdGgsXG5cdFx0c2V0UG9seWdvbk9mZnNldDogc2V0UG9seWdvbk9mZnNldCxcblxuXHRcdHNldFNjaXNzb3JUZXN0OiBzZXRTY2lzc29yVGVzdCxcblxuXHRcdGFjdGl2ZVRleHR1cmU6IGFjdGl2ZVRleHR1cmUsXG5cdFx0YmluZFRleHR1cmU6IGJpbmRUZXh0dXJlLFxuXHRcdHVuYmluZFRleHR1cmU6IHVuYmluZFRleHR1cmUsXG5cdFx0Y29tcHJlc3NlZFRleEltYWdlMkQ6IGNvbXByZXNzZWRUZXhJbWFnZTJELFxuXHRcdGNvbXByZXNzZWRUZXhJbWFnZTNEOiBjb21wcmVzc2VkVGV4SW1hZ2UzRCxcblx0XHR0ZXhJbWFnZTJEOiB0ZXhJbWFnZTJELFxuXHRcdHRleEltYWdlM0Q6IHRleEltYWdlM0QsXG5cblx0XHR1cGRhdGVVQk9NYXBwaW5nOiB1cGRhdGVVQk9NYXBwaW5nLFxuXHRcdHVuaWZvcm1CbG9ja0JpbmRpbmc6IHVuaWZvcm1CbG9ja0JpbmRpbmcsXG5cblx0XHR0ZXhTdG9yYWdlMkQ6IHRleFN0b3JhZ2UyRCxcblx0XHR0ZXhTdG9yYWdlM0Q6IHRleFN0b3JhZ2UzRCxcblx0XHR0ZXhTdWJJbWFnZTJEOiB0ZXhTdWJJbWFnZTJELFxuXHRcdHRleFN1YkltYWdlM0Q6IHRleFN1YkltYWdlM0QsXG5cdFx0Y29tcHJlc3NlZFRleFN1YkltYWdlMkQ6IGNvbXByZXNzZWRUZXhTdWJJbWFnZTJELFxuXHRcdGNvbXByZXNzZWRUZXhTdWJJbWFnZTNEOiBjb21wcmVzc2VkVGV4U3ViSW1hZ2UzRCxcblxuXHRcdHNjaXNzb3I6IHNjaXNzb3IsXG5cdFx0dmlld3BvcnQ6IHZpZXdwb3J0LFxuXG5cdFx0cmVzZXQ6IHJlc2V0XG5cblx0fTtcblxufVxuXG5mdW5jdGlvbiBXZWJHTFRleHR1cmVzKCBfZ2wsIGV4dGVuc2lvbnMsIHN0YXRlLCBwcm9wZXJ0aWVzLCBjYXBhYmlsaXRpZXMsIHV0aWxzLCBpbmZvICkge1xuXG5cdGNvbnN0IG11bHRpc2FtcGxlZFJUVEV4dCA9IGV4dGVuc2lvbnMuaGFzKCAnV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlJyApID8gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUnICkgOiBudWxsO1xuXHRjb25zdCBzdXBwb3J0c0ludmFsaWRhdGVGcmFtZWJ1ZmZlciA9IHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gZmFsc2UgOiAvT2N1bHVzQnJvd3Nlci9nLnRlc3QoIG5hdmlnYXRvci51c2VyQWdlbnQgKTtcblxuXHRjb25zdCBfaW1hZ2VEaW1lbnNpb25zID0gbmV3IFZlY3RvcjIoKTtcblx0Y29uc3QgX3ZpZGVvVGV4dHVyZXMgPSBuZXcgV2Vha01hcCgpO1xuXHRsZXQgX2NhbnZhcztcblxuXHRjb25zdCBfc291cmNlcyA9IG5ldyBXZWFrTWFwKCk7IC8vIG1hcHMgV2ViZ2xUZXh0dXJlIG9iamVjdHMgdG8gaW5zdGFuY2VzIG9mIFNvdXJjZVxuXG5cdC8vIGNvcmRvdmEgaU9TIChhcyBvZiA1LjApIHN0aWxsIHVzZXMgVUlXZWJWaWV3LCB3aGljaCBwcm92aWRlcyBPZmZzY3JlZW5DYW52YXMsXG5cdC8vIGFsc28gT2Zmc2NyZWVuQ2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiKSwgYnV0IG5vdCBPZmZzY3JlZW5DYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpIVxuXHQvLyBTb21lIGltcGxlbWVudGF0aW9ucyBtYXkgb25seSBpbXBsZW1lbnQgT2Zmc2NyZWVuQ2FudmFzIHBhcnRpYWxseSAoZS5nLiBsYWNraW5nIDJkKS5cblxuXHRsZXQgdXNlT2Zmc2NyZWVuQ2FudmFzID0gZmFsc2U7XG5cblx0dHJ5IHtcblxuXHRcdHVzZU9mZnNjcmVlbkNhbnZhcyA9IHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuXHRcdFx0JiYgKCBuZXcgT2Zmc2NyZWVuQ2FudmFzKCAxLCAxICkuZ2V0Q29udGV4dCggJzJkJyApICkgIT09IG51bGw7XG5cblx0fSBjYXRjaCAoIGVyciApIHtcblxuXHRcdC8vIElnbm9yZSBhbnkgZXJyb3JzXG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyggd2lkdGgsIGhlaWdodCApIHtcblxuXHRcdC8vIFVzZSBPZmZzY3JlZW5DYW52YXMgd2hlbiBhdmFpbGFibGUuIFNwZWNpYWxseSBuZWVkZWQgaW4gd2ViIHdvcmtlcnNcblxuXHRcdHJldHVybiB1c2VPZmZzY3JlZW5DYW52YXMgP1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcblx0XHRcdG5ldyBPZmZzY3JlZW5DYW52YXMoIHdpZHRoLCBoZWlnaHQgKSA6IGNyZWF0ZUVsZW1lbnROUyggJ2NhbnZhcycgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVzaXplSW1hZ2UoIGltYWdlLCBuZWVkc05ld0NhbnZhcywgbWF4U2l6ZSApIHtcblxuXHRcdGxldCBzY2FsZSA9IDE7XG5cblx0XHRjb25zdCBkaW1lbnNpb25zID0gZ2V0RGltZW5zaW9ucyggaW1hZ2UgKTtcblxuXHRcdC8vIGhhbmRsZSBjYXNlIGlmIHRleHR1cmUgZXhjZWVkcyBtYXggc2l6ZVxuXG5cdFx0aWYgKCBkaW1lbnNpb25zLndpZHRoID4gbWF4U2l6ZSB8fCBkaW1lbnNpb25zLmhlaWdodCA+IG1heFNpemUgKSB7XG5cblx0XHRcdHNjYWxlID0gbWF4U2l6ZSAvIE1hdGgubWF4KCBkaW1lbnNpb25zLndpZHRoLCBkaW1lbnNpb25zLmhlaWdodCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gb25seSBwZXJmb3JtIHJlc2l6ZSBpZiBuZWNlc3NhcnlcblxuXHRcdGlmICggc2NhbGUgPCAxICkge1xuXG5cdFx0XHQvLyBvbmx5IHBlcmZvcm0gcmVzaXplIGZvciBjZXJ0YWluIGltYWdlIHR5cGVzXG5cblx0XHRcdGlmICggKCB0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ICkgfHxcblx0XHRcdFx0KCB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgKSB8fFxuXHRcdFx0XHQoIHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCApIHx8XG5cdFx0XHRcdCggdHlwZW9mIFZpZGVvRnJhbWUgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgVmlkZW9GcmFtZSApICkge1xuXG5cdFx0XHRcdGNvbnN0IHdpZHRoID0gTWF0aC5mbG9vciggc2NhbGUgKiBkaW1lbnNpb25zLndpZHRoICk7XG5cdFx0XHRcdGNvbnN0IGhlaWdodCA9IE1hdGguZmxvb3IoIHNjYWxlICogZGltZW5zaW9ucy5oZWlnaHQgKTtcblxuXHRcdFx0XHRpZiAoIF9jYW52YXMgPT09IHVuZGVmaW5lZCApIF9jYW52YXMgPSBjcmVhdGVDYW52YXMoIHdpZHRoLCBoZWlnaHQgKTtcblxuXHRcdFx0XHQvLyBjdWJlIHRleHR1cmVzIGNhbid0IHJldXNlIHRoZSBzYW1lIGNhbnZhc1xuXG5cdFx0XHRcdGNvbnN0IGNhbnZhcyA9IG5lZWRzTmV3Q2FudmFzID8gY3JlYXRlQ2FudmFzKCB3aWR0aCwgaGVpZ2h0ICkgOiBfY2FudmFzO1xuXG5cdFx0XHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0XHRcdGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdFx0XHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGhhcyBiZWVuIHJlc2l6ZWQgZnJvbSAoJyArIGRpbWVuc2lvbnMud2lkdGggKyAneCcgKyBkaW1lbnNpb25zLmhlaWdodCArICcpIHRvICgnICsgd2lkdGggKyAneCcgKyBoZWlnaHQgKyAnKS4nICk7XG5cblx0XHRcdFx0cmV0dXJuIGNhbnZhcztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoICdkYXRhJyBpbiBpbWFnZSApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IEltYWdlIGluIERhdGFUZXh0dXJlIGlzIHRvbyBiaWcgKCcgKyBkaW1lbnNpb25zLndpZHRoICsgJ3gnICsgZGltZW5zaW9ucy5oZWlnaHQgKyAnKS4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBpbWFnZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGltYWdlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUgKSB7XG5cblx0XHRyZXR1cm4gdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlTWlwbWFwKCB0YXJnZXQgKSB7XG5cblx0XHRfZ2wuZ2VuZXJhdGVNaXBtYXAoIHRhcmdldCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRUYXJnZXRUeXBlKCB0ZXh0dXJlICkge1xuXG5cdFx0aWYgKCB0ZXh0dXJlLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ICkgcmV0dXJuIF9nbC5URVhUVVJFX0NVQkVfTUFQO1xuXHRcdGlmICggdGV4dHVyZS5pc1dlYkdMM0RSZW5kZXJUYXJnZXQgKSByZXR1cm4gX2dsLlRFWFRVUkVfM0Q7XG5cdFx0aWYgKCB0ZXh0dXJlLmlzV2ViR0xBcnJheVJlbmRlclRhcmdldCB8fCB0ZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSApIHJldHVybiBfZ2wuVEVYVFVSRV8yRF9BUlJBWTtcblx0XHRyZXR1cm4gX2dsLlRFWFRVUkVfMkQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEludGVybmFsRm9ybWF0KCBpbnRlcm5hbEZvcm1hdE5hbWUsIGdsRm9ybWF0LCBnbFR5cGUsIGNvbG9yU3BhY2UsIGZvcmNlTGluZWFyVHJhbnNmZXIgPSBmYWxzZSApIHtcblxuXHRcdGlmICggaW50ZXJuYWxGb3JtYXROYW1lICE9PSBudWxsICkge1xuXG5cdFx0XHRpZiAoIF9nbFsgaW50ZXJuYWxGb3JtYXROYW1lIF0gIT09IHVuZGVmaW5lZCApIHJldHVybiBfZ2xbIGludGVybmFsRm9ybWF0TmFtZSBdO1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIHVzZSBub24tZXhpc3RpbmcgV2ViR0wgaW50ZXJuYWwgZm9ybWF0IFxcJycgKyBpbnRlcm5hbEZvcm1hdE5hbWUgKyAnXFwnJyApO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGludGVybmFsRm9ybWF0ID0gZ2xGb3JtYXQ7XG5cblx0XHRpZiAoIGdsRm9ybWF0ID09PSBfZ2wuUkVEICkge1xuXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLkZMT0FUICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUjMyRjtcblx0XHRcdGlmICggZ2xUeXBlID09PSBfZ2wuSEFMRl9GTE9BVCApIGludGVybmFsRm9ybWF0ID0gX2dsLlIxNkY7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLlVOU0lHTkVEX0JZVEUgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SODtcblxuXHRcdH1cblxuXHRcdGlmICggZ2xGb3JtYXQgPT09IF9nbC5SRURfSU5URUdFUiApIHtcblxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5VTlNJR05FRF9CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUjhVSTtcblx0XHRcdGlmICggZ2xUeXBlID09PSBfZ2wuVU5TSUdORURfU0hPUlQgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SMTZVSTtcblx0XHRcdGlmICggZ2xUeXBlID09PSBfZ2wuVU5TSUdORURfSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUjMyVUk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLkJZVEUgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SOEk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLlNIT1JUICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUjE2STtcblx0XHRcdGlmICggZ2xUeXBlID09PSBfZ2wuSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUjMySTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2xGb3JtYXQgPT09IF9nbC5SRyApIHtcblxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5GTE9BVCApIGludGVybmFsRm9ybWF0ID0gX2dsLlJHMzJGO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5IQUxGX0ZMT0FUICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkcxNkY7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLlVOU0lHTkVEX0JZVEUgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SRzg7XG5cblx0XHR9XG5cblx0XHRpZiAoIGdsRm9ybWF0ID09PSBfZ2wuUkdfSU5URUdFUiApIHtcblxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5VTlNJR05FRF9CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkc4VUk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLlVOU0lHTkVEX1NIT1JUICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkcxNlVJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5VTlNJR05FRF9JTlQgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SRzMyVUk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLkJZVEUgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SRzhJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5TSE9SVCApIGludGVybmFsRm9ybWF0ID0gX2dsLlJHMTZJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5JTlQgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SRzMySTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2xGb3JtYXQgPT09IF9nbC5SR0JfSU5URUdFUiApIHtcblxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5VTlNJR05FRF9CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkdCOFVJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5VTlNJR05FRF9TSE9SVCApIGludGVybmFsRm9ybWF0ID0gX2dsLlJHQjE2VUk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLlVOU0lHTkVEX0lOVCApIGludGVybmFsRm9ybWF0ID0gX2dsLlJHQjMyVUk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLkJZVEUgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SR0I4STtcblx0XHRcdGlmICggZ2xUeXBlID09PSBfZ2wuU0hPUlQgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SR0IxNkk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLklOVCApIGludGVybmFsRm9ybWF0ID0gX2dsLlJHQjMySTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2xGb3JtYXQgPT09IF9nbC5SR0JBX0lOVEVHRVIgKSB7XG5cblx0XHRcdGlmICggZ2xUeXBlID09PSBfZ2wuVU5TSUdORURfQllURSApIGludGVybmFsRm9ybWF0ID0gX2dsLlJHQkE4VUk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLlVOU0lHTkVEX1NIT1JUICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkdCQTE2VUk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLlVOU0lHTkVEX0lOVCApIGludGVybmFsRm9ybWF0ID0gX2dsLlJHQkEzMlVJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkdCQThJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5TSE9SVCApIGludGVybmFsRm9ybWF0ID0gX2dsLlJHQkExNkk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLklOVCApIGludGVybmFsRm9ybWF0ID0gX2dsLlJHQkEzMkk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGdsRm9ybWF0ID09PSBfZ2wuUkdCICkge1xuXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLlVOU0lHTkVEX0lOVF81XzlfOV85X1JFViApIGludGVybmFsRm9ybWF0ID0gX2dsLlJHQjlfRTU7XG5cblx0XHR9XG5cblx0XHRpZiAoIGdsRm9ybWF0ID09PSBfZ2wuUkdCQSApIHtcblxuXHRcdFx0Y29uc3QgdHJhbnNmZXIgPSBmb3JjZUxpbmVhclRyYW5zZmVyID8gTGluZWFyVHJhbnNmZXIgOiBDb2xvck1hbmFnZW1lbnQuZ2V0VHJhbnNmZXIoIGNvbG9yU3BhY2UgKTtcblxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5GTE9BVCApIGludGVybmFsRm9ybWF0ID0gX2dsLlJHQkEzMkY7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLkhBTEZfRkxPQVQgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SR0JBMTZGO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5VTlNJR05FRF9CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSAoIHRyYW5zZmVyID09PSBTUkdCVHJhbnNmZXIgKSA/IF9nbC5TUkdCOF9BTFBIQTggOiBfZ2wuUkdCQTg7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SR0JBNDtcblx0XHRcdGlmICggZ2xUeXBlID09PSBfZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMSApIGludGVybmFsRm9ybWF0ID0gX2dsLlJHQjVfQTE7XG5cblx0XHR9XG5cblx0XHRpZiAoIGludGVybmFsRm9ybWF0ID09PSBfZ2wuUjE2RiB8fCBpbnRlcm5hbEZvcm1hdCA9PT0gX2dsLlIzMkYgfHxcblx0XHRcdGludGVybmFsRm9ybWF0ID09PSBfZ2wuUkcxNkYgfHwgaW50ZXJuYWxGb3JtYXQgPT09IF9nbC5SRzMyRiB8fFxuXHRcdFx0aW50ZXJuYWxGb3JtYXQgPT09IF9nbC5SR0JBMTZGIHx8IGludGVybmFsRm9ybWF0ID09PSBfZ2wuUkdCQTMyRiApIHtcblxuXHRcdFx0ZXh0ZW5zaW9ucy5nZXQoICdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGludGVybmFsRm9ybWF0O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRJbnRlcm5hbERlcHRoRm9ybWF0KCB1c2VTdGVuY2lsLCBkZXB0aFR5cGUgKSB7XG5cblx0XHRsZXQgZ2xJbnRlcm5hbEZvcm1hdDtcblx0XHRpZiAoIHVzZVN0ZW5jaWwgKSB7XG5cblx0XHRcdGlmICggZGVwdGhUeXBlID09PSBudWxsIHx8IGRlcHRoVHlwZSA9PT0gVW5zaWduZWRJbnRUeXBlIHx8IGRlcHRoVHlwZSA9PT0gVW5zaWduZWRJbnQyNDhUeXBlICkge1xuXG5cdFx0XHRcdGdsSW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEgyNF9TVEVOQ0lMODtcblxuXHRcdFx0fSBlbHNlIGlmICggZGVwdGhUeXBlID09PSBGbG9hdFR5cGUgKSB7XG5cblx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSDMyRl9TVEVOQ0lMODtcblxuXHRcdFx0fSBlbHNlIGlmICggZGVwdGhUeXBlID09PSBVbnNpZ25lZFNob3J0VHlwZSApIHtcblxuXHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIMjRfU1RFTkNJTDg7XG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ0RlcHRoVGV4dHVyZTogMTYgYml0IGRlcHRoIGF0dGFjaG1lbnQgaXMgbm90IHN1cHBvcnRlZCB3aXRoIHN0ZW5jaWwuIFVzaW5nIDI0LWJpdCBhdHRhY2htZW50LicgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCBkZXB0aFR5cGUgPT09IG51bGwgfHwgZGVwdGhUeXBlID09PSBVbnNpZ25lZEludFR5cGUgfHwgZGVwdGhUeXBlID09PSBVbnNpZ25lZEludDI0OFR5cGUgKSB7XG5cblx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQyNDtcblxuXHRcdFx0fSBlbHNlIGlmICggZGVwdGhUeXBlID09PSBGbG9hdFR5cGUgKSB7XG5cblx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQzMkY7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGRlcHRoVHlwZSA9PT0gVW5zaWduZWRTaG9ydFR5cGUgKSB7XG5cblx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQxNjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdsSW50ZXJuYWxGb3JtYXQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldE1pcExldmVscyggdGV4dHVyZSwgaW1hZ2UgKSB7XG5cblx0XHRpZiAoIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSApID09PSB0cnVlIHx8ICggdGV4dHVyZS5pc0ZyYW1lYnVmZmVyVGV4dHVyZSAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTGluZWFyRmlsdGVyICkgKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLmxvZzIoIE1hdGgubWF4KCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICkgKSArIDE7XG5cblx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLm1pcG1hcHMgIT09IHVuZGVmaW5lZCAmJiB0ZXh0dXJlLm1pcG1hcHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0Ly8gdXNlci1kZWZpbmVkIG1pcG1hcHNcblxuXHRcdFx0cmV0dXJuIHRleHR1cmUubWlwbWFwcy5sZW5ndGg7XG5cblx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgJiYgQXJyYXkuaXNBcnJheSggdGV4dHVyZS5pbWFnZSApICkge1xuXG5cdFx0XHRyZXR1cm4gaW1hZ2UubWlwbWFwcy5sZW5ndGg7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyB0ZXh0dXJlIHdpdGhvdXQgbWlwbWFwcyAob25seSBiYXNlIGxldmVsKVxuXG5cdFx0XHRyZXR1cm4gMTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBvblRleHR1cmVEaXNwb3NlKCBldmVudCApIHtcblxuXHRcdGNvbnN0IHRleHR1cmUgPSBldmVudC50YXJnZXQ7XG5cblx0XHR0ZXh0dXJlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG5cdFx0ZGVhbGxvY2F0ZVRleHR1cmUoIHRleHR1cmUgKTtcblxuXHRcdGlmICggdGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSApIHtcblxuXHRcdFx0X3ZpZGVvVGV4dHVyZXMuZGVsZXRlKCB0ZXh0dXJlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSggZXZlbnQgKSB7XG5cblx0XHRjb25zdCByZW5kZXJUYXJnZXQgPSBldmVudC50YXJnZXQ7XG5cblx0XHRyZW5kZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblJlbmRlclRhcmdldERpc3Bvc2UgKTtcblxuXHRcdGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xuXG5cdH1cblxuXHQvL1xuXG5cdGZ1bmN0aW9uIGRlYWxsb2NhdGVUZXh0dXJlKCB0ZXh0dXJlICkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xuXG5cdFx0aWYgKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0Ly8gY2hlY2sgaWYgaXQncyBuZWNlc3NhcnkgdG8gcmVtb3ZlIHRoZSBXZWJHTFRleHR1cmUgb2JqZWN0XG5cblx0XHRjb25zdCBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZTtcblx0XHRjb25zdCB3ZWJnbFRleHR1cmVzID0gX3NvdXJjZXMuZ2V0KCBzb3VyY2UgKTtcblxuXHRcdGlmICggd2ViZ2xUZXh0dXJlcyApIHtcblxuXHRcdFx0Y29uc3Qgd2ViZ2xUZXh0dXJlID0gd2ViZ2xUZXh0dXJlc1sgdGV4dHVyZVByb3BlcnRpZXMuX19jYWNoZUtleSBdO1xuXHRcdFx0d2ViZ2xUZXh0dXJlLnVzZWRUaW1lcyAtLTtcblxuXHRcdFx0Ly8gdGhlIFdlYkdMVGV4dHVyZSBvYmplY3QgaXMgbm90IHVzZWQgYW55bW9yZSwgcmVtb3ZlIGl0XG5cblx0XHRcdGlmICggd2ViZ2xUZXh0dXJlLnVzZWRUaW1lcyA9PT0gMCApIHtcblxuXHRcdFx0XHRkZWxldGVUZXh0dXJlKCB0ZXh0dXJlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVtb3ZlIHRoZSB3ZWFrIG1hcCBlbnRyeSBpZiBubyBXZWJHTFRleHR1cmUgdXNlcyB0aGUgc291cmNlIGFueW1vcmVcblxuXHRcdFx0aWYgKCBPYmplY3Qua2V5cyggd2ViZ2xUZXh0dXJlcyApLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRfc291cmNlcy5kZWxldGUoIHNvdXJjZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRwcm9wZXJ0aWVzLnJlbW92ZSggdGV4dHVyZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBkZWxldGVUZXh0dXJlKCB0ZXh0dXJlICkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xuXHRcdF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuXG5cdFx0Y29uc3Qgc291cmNlID0gdGV4dHVyZS5zb3VyY2U7XG5cdFx0Y29uc3Qgd2ViZ2xUZXh0dXJlcyA9IF9zb3VyY2VzLmdldCggc291cmNlICk7XG5cdFx0ZGVsZXRlIHdlYmdsVGV4dHVyZXNbIHRleHR1cmVQcm9wZXJ0aWVzLl9fY2FjaGVLZXkgXTtcblxuXHRcdGluZm8ubWVtb3J5LnRleHR1cmVzIC0tO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRjb25zdCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICkge1xuXG5cdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmRpc3Bvc2UoKTtcblxuXHRcdFx0cHJvcGVydGllcy5yZW1vdmUoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgKTtcblxuXHRcdH1cblxuXHRcdGlmICggcmVuZGVyVGFyZ2V0LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApICkge1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGxldmVsID0gMDsgbGV2ZWwgPCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdLmxlbmd0aDsgbGV2ZWwgKysgKSBfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF1bIGxldmVsIF0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0X2dsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgKSBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlclsgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgKSApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyLmxlbmd0aDsgbGV2ZWwgKysgKSBfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBsZXZlbCBdICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2dsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgKSBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciApO1xuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciApIF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIgKTtcblxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlciApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlci5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyWyBpIF0gKSBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlclsgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIgKSBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aFJlbmRlcmJ1ZmZlciApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdGV4dHVyZXMgPSByZW5kZXJUYXJnZXQudGV4dHVyZXM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGV4dHVyZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGF0dGFjaG1lbnRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmVzWyBpIF0gKTtcblxuXHRcdFx0aWYgKCBhdHRhY2htZW50UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApIHtcblxuXHRcdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggYXR0YWNobWVudFByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuXHRcdFx0XHRpbmZvLm1lbW9yeS50ZXh0dXJlcyAtLTtcblxuXHRcdFx0fVxuXG5cdFx0XHRwcm9wZXJ0aWVzLnJlbW92ZSggdGV4dHVyZXNbIGkgXSApO1xuXG5cdFx0fVxuXG5cdFx0cHJvcGVydGllcy5yZW1vdmUoIHJlbmRlclRhcmdldCApO1xuXG5cdH1cblxuXHQvL1xuXG5cdGxldCB0ZXh0dXJlVW5pdHMgPSAwO1xuXG5cdGZ1bmN0aW9uIHJlc2V0VGV4dHVyZVVuaXRzKCkge1xuXG5cdFx0dGV4dHVyZVVuaXRzID0gMDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gYWxsb2NhdGVUZXh0dXJlVW5pdCgpIHtcblxuXHRcdGNvbnN0IHRleHR1cmVVbml0ID0gdGV4dHVyZVVuaXRzO1xuXG5cdFx0aWYgKCB0ZXh0dXJlVW5pdCA+PSBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZXMgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMVGV4dHVyZXM6IFRyeWluZyB0byB1c2UgJyArIHRleHR1cmVVbml0ICsgJyB0ZXh0dXJlIHVuaXRzIHdoaWxlIHRoaXMgR1BVIHN1cHBvcnRzIG9ubHkgJyArIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApO1xuXG5cdFx0fVxuXG5cdFx0dGV4dHVyZVVuaXRzICs9IDE7XG5cblx0XHRyZXR1cm4gdGV4dHVyZVVuaXQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFRleHR1cmVDYWNoZUtleSggdGV4dHVyZSApIHtcblxuXHRcdGNvbnN0IGFycmF5ID0gW107XG5cblx0XHRhcnJheS5wdXNoKCB0ZXh0dXJlLndyYXBTICk7XG5cdFx0YXJyYXkucHVzaCggdGV4dHVyZS53cmFwVCApO1xuXHRcdGFycmF5LnB1c2goIHRleHR1cmUud3JhcFIgfHwgMCApO1xuXHRcdGFycmF5LnB1c2goIHRleHR1cmUubWFnRmlsdGVyICk7XG5cdFx0YXJyYXkucHVzaCggdGV4dHVyZS5taW5GaWx0ZXIgKTtcblx0XHRhcnJheS5wdXNoKCB0ZXh0dXJlLmFuaXNvdHJvcHkgKTtcblx0XHRhcnJheS5wdXNoKCB0ZXh0dXJlLmludGVybmFsRm9ybWF0ICk7XG5cdFx0YXJyYXkucHVzaCggdGV4dHVyZS5mb3JtYXQgKTtcblx0XHRhcnJheS5wdXNoKCB0ZXh0dXJlLnR5cGUgKTtcblx0XHRhcnJheS5wdXNoKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyApO1xuXHRcdGFycmF5LnB1c2goIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSApO1xuXHRcdGFycmF5LnB1c2goIHRleHR1cmUuZmxpcFkgKTtcblx0XHRhcnJheS5wdXNoKCB0ZXh0dXJlLnVucGFja0FsaWdubWVudCApO1xuXHRcdGFycmF5LnB1c2goIHRleHR1cmUuY29sb3JTcGFjZSApO1xuXG5cdFx0cmV0dXJuIGFycmF5LmpvaW4oKTtcblxuXHR9XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBzZXRUZXh0dXJlMkQoIHRleHR1cmUsIHNsb3QgKSB7XG5cblx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRpZiAoIHRleHR1cmUuaXNWaWRlb1RleHR1cmUgKSB1cGRhdGVWaWRlb1RleHR1cmUoIHRleHR1cmUgKTtcblxuXHRcdGlmICggdGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPT09IGZhbHNlICYmIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XG5cblx0XHRcdGNvbnN0IGltYWdlID0gdGV4dHVyZS5pbWFnZTtcblxuXHRcdFx0aWYgKCBpbWFnZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBubyBpbWFnZSBkYXRhIGZvdW5kLicgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggaW1hZ2UuY29tcGxldGUgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIGluY29tcGxldGUnICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dXBsb2FkVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlLCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldFRleHR1cmUyREFycmF5KCB0ZXh0dXJlLCBzbG90ICkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xuXG5cdFx0aWYgKCB0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uICkge1xuXG5cdFx0XHR1cGxvYWRUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJEX0FSUkFZLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRUZXh0dXJlM0QoIHRleHR1cmUsIHNsb3QgKSB7XG5cblx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XG5cblx0XHRcdHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfM0QsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlLCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldFRleHR1cmVDdWJlKCB0ZXh0dXJlLCBzbG90ICkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xuXG5cdFx0aWYgKCB0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uICkge1xuXG5cdFx0XHR1cGxvYWRDdWJlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcblxuXHR9XG5cblx0Y29uc3Qgd3JhcHBpbmdUb0dMID0ge1xuXHRcdFsgUmVwZWF0V3JhcHBpbmcgXTogX2dsLlJFUEVBVCxcblx0XHRbIENsYW1wVG9FZGdlV3JhcHBpbmcgXTogX2dsLkNMQU1QX1RPX0VER0UsXG5cdFx0WyBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nIF06IF9nbC5NSVJST1JFRF9SRVBFQVRcblx0fTtcblxuXHRjb25zdCBmaWx0ZXJUb0dMID0ge1xuXHRcdFsgTmVhcmVzdEZpbHRlciBdOiBfZ2wuTkVBUkVTVCxcblx0XHRbIE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyIF06IF9nbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNULFxuXHRcdFsgTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciBdOiBfZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSLFxuXG5cdFx0WyBMaW5lYXJGaWx0ZXIgXTogX2dsLkxJTkVBUixcblx0XHRbIExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIgXTogX2dsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCxcblx0XHRbIExpbmVhck1pcG1hcExpbmVhckZpbHRlciBdOiBfZ2wuTElORUFSX01JUE1BUF9MSU5FQVJcblx0fTtcblxuXHRjb25zdCBjb21wYXJlVG9HTCA9IHtcblx0XHRbIE5ldmVyQ29tcGFyZSBdOiBfZ2wuTkVWRVIsXG5cdFx0WyBBbHdheXNDb21wYXJlIF06IF9nbC5BTFdBWVMsXG5cdFx0WyBMZXNzQ29tcGFyZSBdOiBfZ2wuTEVTUyxcblx0XHRbIExlc3NFcXVhbENvbXBhcmUgXTogX2dsLkxFUVVBTCxcblx0XHRbIEVxdWFsQ29tcGFyZSBdOiBfZ2wuRVFVQUwsXG5cdFx0WyBHcmVhdGVyRXF1YWxDb21wYXJlIF06IF9nbC5HRVFVQUwsXG5cdFx0WyBHcmVhdGVyQ29tcGFyZSBdOiBfZ2wuR1JFQVRFUixcblx0XHRbIE5vdEVxdWFsQ29tcGFyZSBdOiBfZ2wuTk9URVFVQUxcblx0fTtcblxuXHRmdW5jdGlvbiBzZXRUZXh0dXJlUGFyYW1ldGVycyggdGV4dHVyZVR5cGUsIHRleHR1cmUgKSB7XG5cblx0XHRpZiAoIHRleHR1cmUudHlwZSA9PT0gRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuaGFzKCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApID09PSBmYWxzZSAmJlxuXHRcdFx0KCB0ZXh0dXJlLm1hZ0ZpbHRlciA9PT0gTGluZWFyRmlsdGVyIHx8IHRleHR1cmUubWFnRmlsdGVyID09PSBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyIHx8IHRleHR1cmUubWFnRmlsdGVyID09PSBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyIHx8IHRleHR1cmUubWFnRmlsdGVyID09PSBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIgfHxcblx0XHRcdHRleHR1cmUubWluRmlsdGVyID09PSBMaW5lYXJGaWx0ZXIgfHwgdGV4dHVyZS5taW5GaWx0ZXIgPT09IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIgfHwgdGV4dHVyZS5taW5GaWx0ZXIgPT09IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIgfHwgdGV4dHVyZS5taW5GaWx0ZXIgPT09IExpbmVhck1pcG1hcExpbmVhckZpbHRlciApICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBVbmFibGUgdG8gdXNlIGxpbmVhciBmaWx0ZXJpbmcgd2l0aCBmbG9hdGluZyBwb2ludCB0ZXh0dXJlcy4gT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2UuJyApO1xuXG5cdFx0fVxuXG5cdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIHdyYXBwaW5nVG9HTFsgdGV4dHVyZS53cmFwUyBdICk7XG5cdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIHdyYXBwaW5nVG9HTFsgdGV4dHVyZS53cmFwVCBdICk7XG5cblx0XHRpZiAoIHRleHR1cmVUeXBlID09PSBfZ2wuVEVYVFVSRV8zRCB8fCB0ZXh0dXJlVHlwZSA9PT0gX2dsLlRFWFRVUkVfMkRfQVJSQVkgKSB7XG5cblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9SLCB3cmFwcGluZ1RvR0xbIHRleHR1cmUud3JhcFIgXSApO1xuXG5cdFx0fVxuXG5cdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJUb0dMWyB0ZXh0dXJlLm1hZ0ZpbHRlciBdICk7XG5cdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJUb0dMWyB0ZXh0dXJlLm1pbkZpbHRlciBdICk7XG5cblx0XHRpZiAoIHRleHR1cmUuY29tcGFyZUZ1bmN0aW9uICkge1xuXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX0NPTVBBUkVfTU9ERSwgX2dsLkNPTVBBUkVfUkVGX1RPX1RFWFRVUkUgKTtcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfQ09NUEFSRV9GVU5DLCBjb21wYXJlVG9HTFsgdGV4dHVyZS5jb21wYXJlRnVuY3Rpb24gXSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb25zLmhhcyggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlLm1hZ0ZpbHRlciA9PT0gTmVhcmVzdEZpbHRlciApIHJldHVybjtcblx0XHRcdGlmICggdGV4dHVyZS5taW5GaWx0ZXIgIT09IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IExpbmVhck1pcG1hcExpbmVhckZpbHRlciApIHJldHVybjtcblx0XHRcdGlmICggdGV4dHVyZS50eXBlID09PSBGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5oYXMoICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInICkgPT09IGZhbHNlICkgcmV0dXJuOyAvLyB2ZXJpZnkgZXh0ZW5zaW9uXG5cblx0XHRcdGlmICggdGV4dHVyZS5hbmlzb3Ryb3B5ID4gMSB8fCBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fY3VycmVudEFuaXNvdHJvcHkgKSB7XG5cblx0XHRcdFx0Y29uc3QgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJmKCB0ZXh0dXJlVHlwZSwgZXh0ZW5zaW9uLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBNYXRoLm1pbiggdGV4dHVyZS5hbmlzb3Ryb3B5LCBjYXBhYmlsaXRpZXMuZ2V0TWF4QW5pc290cm9weSgpICkgKTtcblx0XHRcdFx0cHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX2N1cnJlbnRBbmlzb3Ryb3B5ID0gdGV4dHVyZS5hbmlzb3Ryb3B5O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGluaXRUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSApIHtcblxuXHRcdGxldCBmb3JjZVVwbG9hZCA9IGZhbHNlO1xuXG5cdFx0aWYgKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9IHRydWU7XG5cblx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cblx0XHR9XG5cblx0XHQvLyBjcmVhdGUgU291cmNlIDwtPiBXZWJHTFRleHR1cmVzIG1hcHBpbmcgaWYgbmVjZXNzYXJ5XG5cblx0XHRjb25zdCBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZTtcblx0XHRsZXQgd2ViZ2xUZXh0dXJlcyA9IF9zb3VyY2VzLmdldCggc291cmNlICk7XG5cblx0XHRpZiAoIHdlYmdsVGV4dHVyZXMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0d2ViZ2xUZXh0dXJlcyA9IHt9O1xuXHRcdFx0X3NvdXJjZXMuc2V0KCBzb3VyY2UsIHdlYmdsVGV4dHVyZXMgKTtcblxuXHRcdH1cblxuXHRcdC8vIGNoZWNrIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBXZWJHTFRleHR1cmUgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gdGV4dHVyZSBwYXJhbWV0ZXJzXG5cblx0XHRjb25zdCB0ZXh0dXJlQ2FjaGVLZXkgPSBnZXRUZXh0dXJlQ2FjaGVLZXkoIHRleHR1cmUgKTtcblxuXHRcdGlmICggdGV4dHVyZUNhY2hlS2V5ICE9PSB0ZXh0dXJlUHJvcGVydGllcy5fX2NhY2hlS2V5ICkge1xuXG5cdFx0XHQvLyBpZiBub3QsIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBXZWJHTFRleHR1cmVcblxuXHRcdFx0aWYgKCB3ZWJnbFRleHR1cmVzWyB0ZXh0dXJlQ2FjaGVLZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIGNyZWF0ZSBuZXcgZW50cnlcblxuXHRcdFx0XHR3ZWJnbFRleHR1cmVzWyB0ZXh0dXJlQ2FjaGVLZXkgXSA9IHtcblx0XHRcdFx0XHR0ZXh0dXJlOiBfZ2wuY3JlYXRlVGV4dHVyZSgpLFxuXHRcdFx0XHRcdHVzZWRUaW1lczogMFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGluZm8ubWVtb3J5LnRleHR1cmVzICsrO1xuXG5cdFx0XHRcdC8vIHdoZW4gYSBuZXcgaW5zdGFuY2Ugb2YgV2ViR0xUZXh0dXJlIHdhcyBjcmVhdGVkLCBhIHRleHR1cmUgdXBsb2FkIGlzIHJlcXVpcmVkXG5cdFx0XHRcdC8vIGV2ZW4gaWYgdGhlIGltYWdlIGNvbnRlbnRzIGFyZSBpZGVudGljYWxcblxuXHRcdFx0XHRmb3JjZVVwbG9hZCA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0d2ViZ2xUZXh0dXJlc1sgdGV4dHVyZUNhY2hlS2V5IF0udXNlZFRpbWVzICsrO1xuXG5cdFx0XHQvLyBldmVyeSB0aW1lIHRoZSB0ZXh0dXJlIGNhY2hlIGtleSBjaGFuZ2VzLCBpdCdzIG5lY2Vzc2FyeSB0byBjaGVjayBpZiBhbiBpbnN0YW5jZSBvZlxuXHRcdFx0Ly8gV2ViR0xUZXh0dXJlIGNhbiBiZSBkZWxldGVkIGluIG9yZGVyIHRvIGF2b2lkIGEgbWVtb3J5IGxlYWsuXG5cblx0XHRcdGNvbnN0IHdlYmdsVGV4dHVyZSA9IHdlYmdsVGV4dHVyZXNbIHRleHR1cmVQcm9wZXJ0aWVzLl9fY2FjaGVLZXkgXTtcblxuXHRcdFx0aWYgKCB3ZWJnbFRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR3ZWJnbFRleHR1cmVzWyB0ZXh0dXJlUHJvcGVydGllcy5fX2NhY2hlS2V5IF0udXNlZFRpbWVzIC0tO1xuXG5cdFx0XHRcdGlmICggd2ViZ2xUZXh0dXJlLnVzZWRUaW1lcyA9PT0gMCApIHtcblxuXHRcdFx0XHRcdGRlbGV0ZVRleHR1cmUoIHRleHR1cmUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gc3RvcmUgcmVmZXJlbmNlcyB0byBjYWNoZSBrZXkgYW5kIFdlYkdMVGV4dHVyZSBvYmplY3RcblxuXHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX19jYWNoZUtleSA9IHRleHR1cmVDYWNoZUtleTtcblx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gd2ViZ2xUZXh0dXJlc1sgdGV4dHVyZUNhY2hlS2V5IF0udGV4dHVyZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmb3JjZVVwbG9hZDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gdXBsb2FkVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QgKSB7XG5cblx0XHRsZXQgdGV4dHVyZVR5cGUgPSBfZ2wuVEVYVFVSRV8yRDtcblxuXHRcdGlmICggdGV4dHVyZS5pc0RhdGFBcnJheVRleHR1cmUgfHwgdGV4dHVyZS5pc0NvbXByZXNzZWRBcnJheVRleHR1cmUgKSB0ZXh0dXJlVHlwZSA9IF9nbC5URVhUVVJFXzJEX0FSUkFZO1xuXHRcdGlmICggdGV4dHVyZS5pc0RhdGEzRFRleHR1cmUgKSB0ZXh0dXJlVHlwZSA9IF9nbC5URVhUVVJFXzNEO1xuXG5cdFx0Y29uc3QgZm9yY2VVcGxvYWQgPSBpbml0VGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUgKTtcblx0XHRjb25zdCBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZTtcblxuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCB0ZXh0dXJlVHlwZSwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcblxuXHRcdGNvbnN0IHNvdXJjZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggc291cmNlICk7XG5cblx0XHRpZiAoIHNvdXJjZS52ZXJzaW9uICE9PSBzb3VyY2VQcm9wZXJ0aWVzLl9fdmVyc2lvbiB8fCBmb3JjZVVwbG9hZCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuXG5cdFx0XHRjb25zdCB3b3JraW5nUHJpbWFyaWVzID0gQ29sb3JNYW5hZ2VtZW50LmdldFByaW1hcmllcyggQ29sb3JNYW5hZ2VtZW50LndvcmtpbmdDb2xvclNwYWNlICk7XG5cdFx0XHRjb25zdCB0ZXh0dXJlUHJpbWFyaWVzID0gdGV4dHVyZS5jb2xvclNwYWNlID09PSBOb0NvbG9yU3BhY2UgPyBudWxsIDogQ29sb3JNYW5hZ2VtZW50LmdldFByaW1hcmllcyggdGV4dHVyZS5jb2xvclNwYWNlICk7XG5cdFx0XHRjb25zdCB1bnBhY2tDb252ZXJzaW9uID0gdGV4dHVyZS5jb2xvclNwYWNlID09PSBOb0NvbG9yU3BhY2UgfHwgd29ya2luZ1ByaW1hcmllcyA9PT0gdGV4dHVyZVByaW1hcmllcyA/IF9nbC5OT05FIDogX2dsLkJST1dTRVJfREVGQVVMVF9XRUJHTDtcblxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSApO1xuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgKTtcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19BTElHTk1FTlQsIHRleHR1cmUudW5wYWNrQWxpZ25tZW50ICk7XG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMLCB1bnBhY2tDb252ZXJzaW9uICk7XG5cblx0XHRcdGxldCBpbWFnZSA9IHJlc2l6ZUltYWdlKCB0ZXh0dXJlLmltYWdlLCBmYWxzZSwgY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplICk7XG5cdFx0XHRpbWFnZSA9IHZlcmlmeUNvbG9yU3BhY2UoIHRleHR1cmUsIGltYWdlICk7XG5cblx0XHRcdGNvbnN0IGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCggdGV4dHVyZS5mb3JtYXQsIHRleHR1cmUuY29sb3JTcGFjZSApO1xuXG5cdFx0XHRjb25zdCBnbFR5cGUgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLnR5cGUgKTtcblx0XHRcdGxldCBnbEludGVybmFsRm9ybWF0ID0gZ2V0SW50ZXJuYWxGb3JtYXQoIHRleHR1cmUuaW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIHRleHR1cmUuY29sb3JTcGFjZSwgdGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSApO1xuXG5cdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggdGV4dHVyZVR5cGUsIHRleHR1cmUgKTtcblxuXHRcdFx0bGV0IG1pcG1hcDtcblx0XHRcdGNvbnN0IG1pcG1hcHMgPSB0ZXh0dXJlLm1pcG1hcHM7XG5cblx0XHRcdGNvbnN0IHVzZVRleFN0b3JhZ2UgPSAoIHRleHR1cmUuaXNWaWRlb1RleHR1cmUgIT09IHRydWUgKTtcblx0XHRcdGNvbnN0IGFsbG9jYXRlTWVtb3J5ID0gKCBzb3VyY2VQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9PT0gdW5kZWZpbmVkICkgfHwgKCBmb3JjZVVwbG9hZCA9PT0gdHJ1ZSApO1xuXHRcdFx0Y29uc3QgZGF0YVJlYWR5ID0gc291cmNlLmRhdGFSZWFkeTtcblx0XHRcdGNvbnN0IGxldmVscyA9IGdldE1pcExldmVscyggdGV4dHVyZSwgaW1hZ2UgKTtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlLmlzRGVwdGhUZXh0dXJlICkge1xuXG5cdFx0XHRcdGdsSW50ZXJuYWxGb3JtYXQgPSBnZXRJbnRlcm5hbERlcHRoRm9ybWF0KCB0ZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0LCB0ZXh0dXJlLnR5cGUgKTtcblxuXHRcdFx0XHQvL1xuXG5cdFx0XHRcdGlmICggYWxsb2NhdGVNZW1vcnkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XG5cblx0XHRcdFx0XHRcdHN0YXRlLnRleFN0b3JhZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDEsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzRGF0YVRleHR1cmUgKSB7XG5cblx0XHRcdFx0Ly8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcblx0XHRcdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXG5cdFx0XHRcdC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xuXG5cdFx0XHRcdGlmICggbWlwbWFwcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICYmIGFsbG9jYXRlTWVtb3J5ICkge1xuXG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlMkQoIF9nbC5URVhUVVJFXzJELCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcHNbIDAgXS53aWR0aCwgbWlwbWFwc1sgMCBdLmhlaWdodCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggZGF0YVJlYWR5ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIDAsIDAsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGFsbG9jYXRlTWVtb3J5ICkge1xuXG5cdFx0XHRcdFx0XHRcdHN0YXRlLnRleFN0b3JhZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGxldmVscywgZ2xJbnRlcm5hbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICggZGF0YVJlYWR5ICkge1xuXG5cdFx0XHRcdFx0XHRcdHN0YXRlLnRleFN1YkltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgKSB7XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSAmJiBhbGxvY2F0ZU1lbW9yeSApIHtcblxuXHRcdFx0XHRcdFx0c3RhdGUudGV4U3RvcmFnZTNEKCBfZ2wuVEVYVFVSRV8yRF9BUlJBWSwgbGV2ZWxzLCBnbEludGVybmFsRm9ybWF0LCBtaXBtYXBzWyAwIF0ud2lkdGgsIG1pcG1hcHNbIDAgXS5oZWlnaHQsIGltYWdlLmRlcHRoICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBSR0JBRm9ybWF0ICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggZ2xGb3JtYXQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGF0YVJlYWR5ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdGV4dHVyZS5sYXllclVwZGF0ZXMuc2l6ZSA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBsYXllckJ5dGVMZW5ndGggPSBnZXRCeXRlTGVuZ3RoKCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIHRleHR1cmUuZm9ybWF0LCB0ZXh0dXJlLnR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZvciAoIGNvbnN0IGxheWVySW5kZXggb2YgdGV4dHVyZS5sYXllclVwZGF0ZXMgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGxheWVyRGF0YSA9IG1pcG1hcC5kYXRhLnN1YmFycmF5KFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsYXllckluZGV4ICogbGF5ZXJCeXRlTGVuZ3RoIC8gbWlwbWFwLmRhdGEuQllURVNfUEVSX0VMRU1FTlQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCggbGF5ZXJJbmRleCArIDEgKSAqIGxheWVyQnl0ZUxlbmd0aCAvIG1pcG1hcC5kYXRhLkJZVEVTX1BFUl9FTEVNRU5UXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUuY29tcHJlc3NlZFRleFN1YkltYWdlM0QoIF9nbC5URVhUVVJFXzJEX0FSUkFZLCBpLCAwLCAwLCBsYXllckluZGV4LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDEsIGdsRm9ybWF0LCBsYXllckRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRleHR1cmUuY2xlYXJMYXllclVwZGF0ZXMoKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUuY29tcHJlc3NlZFRleFN1YkltYWdlM0QoIF9nbC5URVhUVVJFXzJEX0FSUkFZLCBpLCAwLCAwLCAwLCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIGltYWdlLmRlcHRoLCBnbEZvcm1hdCwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlLmNvbXByZXNzZWRUZXhJbWFnZTNEKCBfZ2wuVEVYVFVSRV8yRF9BUlJBWSwgaSwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCBpbWFnZS5kZXB0aCwgMCwgbWlwbWFwLmRhdGEsIDAsIDAgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnVwbG9hZFRleHR1cmUoKScgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBkYXRhUmVhZHkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleFN1YkltYWdlM0QoIF9nbC5URVhUVVJFXzJEX0FSUkFZLCBpLCAwLCAwLCAwLCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIGltYWdlLmRlcHRoLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTNEKCBfZ2wuVEVYVFVSRV8yRF9BUlJBWSwgaSwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCBpbWFnZS5kZXB0aCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICYmIGFsbG9jYXRlTWVtb3J5ICkge1xuXG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlMkQoIF9nbC5URVhUVVJFXzJELCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcHNbIDAgXS53aWR0aCwgbWlwbWFwc1sgMCBdLmhlaWdodCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gUkdCQUZvcm1hdCApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGdsRm9ybWF0ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRhdGFSZWFkeSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIDAsIDAsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgZ2xGb3JtYXQsIG1pcG1hcC5kYXRhICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAudXBsb2FkVGV4dHVyZSgpJyApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGRhdGFSZWFkeSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIDAsIDAsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNEYXRhQXJyYXlUZXh0dXJlICkge1xuXG5cdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSApIHtcblxuXHRcdFx0XHRcdGlmICggYWxsb2NhdGVNZW1vcnkgKSB7XG5cblx0XHRcdFx0XHRcdHN0YXRlLnRleFN0b3JhZ2UzRCggX2dsLlRFWFRVUkVfMkRfQVJSQVksIGxldmVscywgZ2xJbnRlcm5hbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgaW1hZ2UuZGVwdGggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggZGF0YVJlYWR5ICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRleHR1cmUubGF5ZXJVcGRhdGVzLnNpemUgPiAwICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGxheWVyQnl0ZUxlbmd0aCA9IGdldEJ5dGVMZW5ndGgoIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIHRleHR1cmUuZm9ybWF0LCB0ZXh0dXJlLnR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb25zdCBsYXllckluZGV4IG9mIHRleHR1cmUubGF5ZXJVcGRhdGVzICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgbGF5ZXJEYXRhID0gaW1hZ2UuZGF0YS5zdWJhcnJheShcblx0XHRcdFx0XHRcdFx0XHRcdGxheWVySW5kZXggKiBsYXllckJ5dGVMZW5ndGggLyBpbWFnZS5kYXRhLkJZVEVTX1BFUl9FTEVNRU5ULFxuXHRcdFx0XHRcdFx0XHRcdFx0KCBsYXllckluZGV4ICsgMSApICogbGF5ZXJCeXRlTGVuZ3RoIC8gaW1hZ2UuZGF0YS5CWVRFU19QRVJfRUxFTUVOVFxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UzRCggX2dsLlRFWFRVUkVfMkRfQVJSQVksIDAsIDAsIDAsIGxheWVySW5kZXgsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDEsIGdsRm9ybWF0LCBnbFR5cGUsIGxheWVyRGF0YSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLmNsZWFyTGF5ZXJVcGRhdGVzKCk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UzRCggX2dsLlRFWFRVUkVfMkRfQVJSQVksIDAsIDAsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGltYWdlLmRlcHRoLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UzRCggX2dsLlRFWFRVUkVfMkRfQVJSQVksIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGltYWdlLmRlcHRoLCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzRGF0YTNEVGV4dHVyZSApIHtcblxuXHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGFsbG9jYXRlTWVtb3J5ICkge1xuXG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlM0QoIF9nbC5URVhUVVJFXzNELCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGltYWdlLmRlcHRoICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGRhdGFSZWFkeSApIHtcblxuXHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UzRCggX2dsLlRFWFRVUkVfM0QsIDAsIDAsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGltYWdlLmRlcHRoLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlM0QoIF9nbC5URVhUVVJFXzNELCAwLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCBpbWFnZS5kZXB0aCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0ZyYW1lYnVmZmVyVGV4dHVyZSApIHtcblxuXHRcdFx0XHRpZiAoIGFsbG9jYXRlTWVtb3J5ICkge1xuXG5cdFx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICkge1xuXG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlMkQoIF9nbC5URVhUVVJFXzJELCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGxldCB3aWR0aCA9IGltYWdlLndpZHRoLCBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGxldmVsczsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xJbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xuXG5cdFx0XHRcdFx0XHRcdHdpZHRoID4+PSAxO1xuXHRcdFx0XHRcdFx0XHRoZWlnaHQgPj49IDE7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gcmVndWxhciBUZXh0dXJlIChpbWFnZSwgdmlkZW8sIGNhbnZhcylcblxuXHRcdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxuXHRcdFx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcblx0XHRcdFx0Ly8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXG5cblx0XHRcdFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgJiYgYWxsb2NhdGVNZW1vcnkgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGRpbWVuc2lvbnMgPSBnZXREaW1lbnNpb25zKCBtaXBtYXBzWyAwIF0gKTtcblxuXHRcdFx0XHRcdFx0c3RhdGUudGV4U3RvcmFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgbGV2ZWxzLCBnbEludGVybmFsRm9ybWF0LCBkaW1lbnNpb25zLndpZHRoLCBkaW1lbnNpb25zLmhlaWdodCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggZGF0YVJlYWR5ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIDAsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcCApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xJbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBhbGxvY2F0ZU1lbW9yeSApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBkaW1lbnNpb25zID0gZ2V0RGltZW5zaW9ucyggaW1hZ2UgKTtcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlMkQoIF9nbC5URVhUVVJFXzJELCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBkYXRhUmVhZHkgKSB7XG5cblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSApICkge1xuXG5cdFx0XHRcdGdlbmVyYXRlTWlwbWFwKCB0ZXh0dXJlVHlwZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNvdXJjZVByb3BlcnRpZXMuX192ZXJzaW9uID0gc291cmNlLnZlcnNpb247XG5cblx0XHRcdGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoIHRleHR1cmUgKTtcblxuXHRcdH1cblxuXHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcblxuXHR9XG5cblx0ZnVuY3Rpb24gdXBsb2FkQ3ViZVRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICkge1xuXG5cdFx0aWYgKCB0ZXh0dXJlLmltYWdlLmxlbmd0aCAhPT0gNiApIHJldHVybjtcblxuXHRcdGNvbnN0IGZvcmNlVXBsb2FkID0gaW5pdFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlICk7XG5cdFx0Y29uc3Qgc291cmNlID0gdGV4dHVyZS5zb3VyY2U7XG5cblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlLCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG5cblx0XHRjb25zdCBzb3VyY2VQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHNvdXJjZSApO1xuXG5cdFx0aWYgKCBzb3VyY2UudmVyc2lvbiAhPT0gc291cmNlUHJvcGVydGllcy5fX3ZlcnNpb24gfHwgZm9yY2VVcGxvYWQgPT09IHRydWUgKSB7XG5cblx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcblxuXHRcdFx0Y29uc3Qgd29ya2luZ1ByaW1hcmllcyA9IENvbG9yTWFuYWdlbWVudC5nZXRQcmltYXJpZXMoIENvbG9yTWFuYWdlbWVudC53b3JraW5nQ29sb3JTcGFjZSApO1xuXHRcdFx0Y29uc3QgdGV4dHVyZVByaW1hcmllcyA9IHRleHR1cmUuY29sb3JTcGFjZSA9PT0gTm9Db2xvclNwYWNlID8gbnVsbCA6IENvbG9yTWFuYWdlbWVudC5nZXRQcmltYXJpZXMoIHRleHR1cmUuY29sb3JTcGFjZSApO1xuXHRcdFx0Y29uc3QgdW5wYWNrQ29udmVyc2lvbiA9IHRleHR1cmUuY29sb3JTcGFjZSA9PT0gTm9Db2xvclNwYWNlIHx8IHdvcmtpbmdQcmltYXJpZXMgPT09IHRleHR1cmVQcmltYXJpZXMgPyBfZ2wuTk9ORSA6IF9nbC5CUk9XU0VSX0RFRkFVTFRfV0VCR0w7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBseUFscGhhICk7XG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfQUxJR05NRU5ULCB0ZXh0dXJlLnVucGFja0FsaWdubWVudCApO1xuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCwgdW5wYWNrQ29udmVyc2lvbiApO1xuXG5cdFx0XHRjb25zdCBpc0NvbXByZXNzZWQgPSAoIHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSB8fCB0ZXh0dXJlLmltYWdlWyAwIF0uaXNDb21wcmVzc2VkVGV4dHVyZSApO1xuXHRcdFx0Y29uc3QgaXNEYXRhVGV4dHVyZSA9ICggdGV4dHVyZS5pbWFnZVsgMCBdICYmIHRleHR1cmUuaW1hZ2VbIDAgXS5pc0RhdGFUZXh0dXJlICk7XG5cblx0XHRcdGNvbnN0IGN1YmVJbWFnZSA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggISBpc0NvbXByZXNzZWQgJiYgISBpc0RhdGFUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0Y3ViZUltYWdlWyBpIF0gPSByZXNpemVJbWFnZSggdGV4dHVyZS5pbWFnZVsgaSBdLCB0cnVlLCBjYXBhYmlsaXRpZXMubWF4Q3ViZW1hcFNpemUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y3ViZUltYWdlWyBpIF0gPSBpc0RhdGFUZXh0dXJlID8gdGV4dHVyZS5pbWFnZVsgaSBdLmltYWdlIDogdGV4dHVyZS5pbWFnZVsgaSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdWJlSW1hZ2VbIGkgXSA9IHZlcmlmeUNvbG9yU3BhY2UoIHRleHR1cmUsIGN1YmVJbWFnZVsgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaW1hZ2UgPSBjdWJlSW1hZ2VbIDAgXSxcblx0XHRcdFx0Z2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLmZvcm1hdCwgdGV4dHVyZS5jb2xvclNwYWNlICksXG5cdFx0XHRcdGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUudHlwZSApLFxuXHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gZ2V0SW50ZXJuYWxGb3JtYXQoIHRleHR1cmUuaW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIHRleHR1cmUuY29sb3JTcGFjZSApO1xuXG5cdFx0XHRjb25zdCB1c2VUZXhTdG9yYWdlID0gKCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlICE9PSB0cnVlICk7XG5cdFx0XHRjb25zdCBhbGxvY2F0ZU1lbW9yeSA9ICggc291cmNlUHJvcGVydGllcy5fX3ZlcnNpb24gPT09IHVuZGVmaW5lZCApIHx8ICggZm9yY2VVcGxvYWQgPT09IHRydWUgKTtcblx0XHRcdGNvbnN0IGRhdGFSZWFkeSA9IHNvdXJjZS5kYXRhUmVhZHk7XG5cdFx0XHRsZXQgbGV2ZWxzID0gZ2V0TWlwTGV2ZWxzKCB0ZXh0dXJlLCBpbWFnZSApO1xuXG5cdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUgKTtcblxuXHRcdFx0bGV0IG1pcG1hcHM7XG5cblx0XHRcdGlmICggaXNDb21wcmVzc2VkICkge1xuXG5cdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSAmJiBhbGxvY2F0ZU1lbW9yeSApIHtcblxuXHRcdFx0XHRcdHN0YXRlLnRleFN0b3JhZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIGxldmVscywgZ2xJbnRlcm5hbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdFx0bWlwbWFwcyA9IGN1YmVJbWFnZVsgaSBdLm1pcG1hcHM7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBtaXBtYXBzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgbWlwbWFwID0gbWlwbWFwc1sgaiBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBSR0JBRm9ybWF0ICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggZ2xGb3JtYXQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGF0YVJlYWR5ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgMCwgMCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCBnbEZvcm1hdCwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEludGVybmFsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC5zZXRUZXh0dXJlQ3ViZSgpJyApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGRhdGFSZWFkeSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIDAsIDAsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bWlwbWFwcyA9IHRleHR1cmUubWlwbWFwcztcblxuXHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgJiYgYWxsb2NhdGVNZW1vcnkgKSB7XG5cblx0XHRcdFx0XHQvLyBUT0RPOiBVbmlmb3JtbHkgaGFuZGxlIG1pcG1hcCBkZWZpbml0aW9uc1xuXHRcdFx0XHRcdC8vIE5vcm1hbCB0ZXh0dXJlcyBhbmQgY29tcHJlc3NlZCBjdWJlIHRleHR1cmVzIGRlZmluZSBiYXNlIGxldmVsICsgbWlwcyB3aXRoIHRoZWlyIG1pcG1hcCBhcnJheVxuXHRcdFx0XHRcdC8vIFVuY29tcHJlc3NlZCBjdWJlIHRleHR1cmVzIHVzZSB0aGVpciBtaXBtYXAgYXJyYXkgb25seSBmb3IgbWlwcyAobm8gYmFzZSBsZXZlbClcblxuXHRcdFx0XHRcdGlmICggbWlwbWFwcy5sZW5ndGggPiAwICkgbGV2ZWxzICsrO1xuXG5cdFx0XHRcdFx0Y29uc3QgZGltZW5zaW9ucyA9IGdldERpbWVuc2lvbnMoIGN1YmVJbWFnZVsgMCBdICk7XG5cblx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGlzRGF0YVRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGRhdGFSZWFkeSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleFN1YkltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCAwLCAwLCBjdWJlSW1hZ2VbIGkgXS53aWR0aCwgY3ViZUltYWdlWyBpIF0uaGVpZ2h0LCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXS5kYXRhICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEludGVybmFsRm9ybWF0LCBjdWJlSW1hZ2VbIGkgXS53aWR0aCwgY3ViZUltYWdlWyBpIF0uaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXS5kYXRhICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgbWlwbWFwcy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgbWlwbWFwID0gbWlwbWFwc1sgaiBdO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBtaXBtYXBJbWFnZSA9IG1pcG1hcC5pbWFnZVsgaSBdLmltYWdlO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggZGF0YVJlYWR5ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiArIDEsIDAsIDAsIG1pcG1hcEltYWdlLndpZHRoLCBtaXBtYXBJbWFnZS5oZWlnaHQsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcEltYWdlLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGogKyAxLCBnbEludGVybmFsRm9ybWF0LCBtaXBtYXBJbWFnZS53aWR0aCwgbWlwbWFwSW1hZ2UuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXBJbWFnZS5kYXRhICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBkYXRhUmVhZHkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgMCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVsgaSBdICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgbWlwbWFwcy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgbWlwbWFwID0gbWlwbWFwc1sgaiBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggZGF0YVJlYWR5ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiArIDEsIDAsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5pbWFnZVsgaSBdICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqICsgMSwgZ2xJbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmltYWdlWyBpIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUgKSApIHtcblxuXHRcdFx0XHQvLyBXZSBhc3N1bWUgaW1hZ2VzIGZvciBjdWJlIG1hcCBoYXZlIHRoZSBzYW1lIHNpemUuXG5cdFx0XHRcdGdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNvdXJjZVByb3BlcnRpZXMuX192ZXJzaW9uID0gc291cmNlLnZlcnNpb247XG5cblx0XHRcdGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoIHRleHR1cmUgKTtcblxuXHRcdH1cblxuXHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcblxuXHR9XG5cblx0Ly8gUmVuZGVyIHRhcmdldHNcblxuXHQvLyBTZXR1cCBzdG9yYWdlIGZvciB0YXJnZXQgdGV4dHVyZSBhbmQgYmluZCBpdCB0byBjb3JyZWN0IGZyYW1lYnVmZmVyXG5cdGZ1bmN0aW9uIHNldHVwRnJhbWVCdWZmZXJUZXh0dXJlKCBmcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCB0ZXh0dXJlLCBhdHRhY2htZW50LCB0ZXh0dXJlVGFyZ2V0LCBsZXZlbCApIHtcblxuXHRcdGNvbnN0IGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCggdGV4dHVyZS5mb3JtYXQsIHRleHR1cmUuY29sb3JTcGFjZSApO1xuXHRcdGNvbnN0IGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUudHlwZSApO1xuXHRcdGNvbnN0IGdsSW50ZXJuYWxGb3JtYXQgPSBnZXRJbnRlcm5hbEZvcm1hdCggdGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgdGV4dHVyZS5jb2xvclNwYWNlICk7XG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3JlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcblxuXHRcdGlmICggISByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9faGFzRXh0ZXJuYWxUZXh0dXJlcyApIHtcblxuXHRcdFx0Y29uc3Qgd2lkdGggPSBNYXRoLm1heCggMSwgcmVuZGVyVGFyZ2V0LndpZHRoID4+IGxldmVsICk7XG5cdFx0XHRjb25zdCBoZWlnaHQgPSBNYXRoLm1heCggMSwgcmVuZGVyVGFyZ2V0LmhlaWdodCA+PiBsZXZlbCApO1xuXG5cdFx0XHRpZiAoIHRleHR1cmVUYXJnZXQgPT09IF9nbC5URVhUVVJFXzNEIHx8IHRleHR1cmVUYXJnZXQgPT09IF9nbC5URVhUVVJFXzJEX0FSUkFZICkge1xuXG5cdFx0XHRcdHN0YXRlLnRleEltYWdlM0QoIHRleHR1cmVUYXJnZXQsIGxldmVsLCBnbEludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCByZW5kZXJUYXJnZXQuZGVwdGgsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCB0ZXh0dXJlVGFyZ2V0LCBsZXZlbCwgZ2xJbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcblxuXHRcdGlmICggdXNlTXVsdGlzYW1wbGVkUlRUKCByZW5kZXJUYXJnZXQgKSApIHtcblxuXHRcdFx0bXVsdGlzYW1wbGVkUlRURXh0LmZyYW1lYnVmZmVyVGV4dHVyZTJETXVsdGlzYW1wbGVFWFQoIF9nbC5GUkFNRUJVRkZFUiwgYXR0YWNobWVudCwgdGV4dHVyZVRhcmdldCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIDAsIGdldFJlbmRlclRhcmdldFNhbXBsZXMoIHJlbmRlclRhcmdldCApICk7XG5cblx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlVGFyZ2V0ID09PSBfZ2wuVEVYVFVSRV8yRCB8fCAoIHRleHR1cmVUYXJnZXQgPj0gX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCAmJiB0ZXh0dXJlVGFyZ2V0IDw9IF9nbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1ogKSApIHsgLy8gc2VlICMyNDc1M1xuXG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgYXR0YWNobWVudCwgdGV4dHVyZVRhcmdldCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIGxldmVsICk7XG5cblx0XHR9XG5cblx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXG5cdH1cblxuXHQvLyBTZXR1cCBzdG9yYWdlIGZvciBpbnRlcm5hbCBkZXB0aC9zdGVuY2lsIGJ1ZmZlcnMgYW5kIGJpbmQgdG8gY29ycmVjdCBmcmFtZWJ1ZmZlclxuXHRmdW5jdGlvbiBzZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UoIHJlbmRlcmJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBpc011bHRpc2FtcGxlICkge1xuXG5cdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgKSB7XG5cblx0XHRcdC8vIHJldHJpZXZlIHRoZSBkZXB0aCBhdHRhY2htZW50IHR5cGVzXG5cdFx0XHRjb25zdCBkZXB0aFRleHR1cmUgPSByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlO1xuXHRcdFx0Y29uc3QgZGVwdGhUeXBlID0gZGVwdGhUZXh0dXJlICYmIGRlcHRoVGV4dHVyZS5pc0RlcHRoVGV4dHVyZSA/IGRlcHRoVGV4dHVyZS50eXBlIDogbnVsbDtcblx0XHRcdGNvbnN0IGdsSW50ZXJuYWxGb3JtYXQgPSBnZXRJbnRlcm5hbERlcHRoRm9ybWF0KCByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciwgZGVwdGhUeXBlICk7XG5cdFx0XHRjb25zdCBnbEF0dGFjaG1lbnRUeXBlID0gcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgPyBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UIDogX2dsLkRFUFRIX0FUVEFDSE1FTlQ7XG5cblx0XHRcdC8vIHNldCB1cCB0aGUgYXR0YWNobWVudFxuXHRcdFx0Y29uc3Qgc2FtcGxlcyA9IGdldFJlbmRlclRhcmdldFNhbXBsZXMoIHJlbmRlclRhcmdldCApO1xuXHRcdFx0Y29uc3QgaXNVc2VNdWx0aXNhbXBsZWRSVFQgPSB1c2VNdWx0aXNhbXBsZWRSVFQoIHJlbmRlclRhcmdldCApO1xuXHRcdFx0aWYgKCBpc1VzZU11bHRpc2FtcGxlZFJUVCApIHtcblxuXHRcdFx0XHRtdWx0aXNhbXBsZWRSVFRFeHQucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlRVhUKCBfZ2wuUkVOREVSQlVGRkVSLCBzYW1wbGVzLCBnbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggaXNNdWx0aXNhbXBsZSApIHtcblxuXHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKCBfZ2wuUkVOREVSQlVGRkVSLCBzYW1wbGVzLCBnbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGdsQXR0YWNobWVudFR5cGUsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3QgdGV4dHVyZXMgPSByZW5kZXJUYXJnZXQudGV4dHVyZXM7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlID0gdGV4dHVyZXNbIGkgXTtcblxuXHRcdFx0XHRjb25zdCBnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUuZm9ybWF0LCB0ZXh0dXJlLmNvbG9yU3BhY2UgKTtcblx0XHRcdFx0Y29uc3QgZ2xUeXBlID0gdXRpbHMuY29udmVydCggdGV4dHVyZS50eXBlICk7XG5cdFx0XHRcdGNvbnN0IGdsSW50ZXJuYWxGb3JtYXQgPSBnZXRJbnRlcm5hbEZvcm1hdCggdGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgdGV4dHVyZS5jb2xvclNwYWNlICk7XG5cdFx0XHRcdGNvbnN0IHNhbXBsZXMgPSBnZXRSZW5kZXJUYXJnZXRTYW1wbGVzKCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0XHRpZiAoIGlzTXVsdGlzYW1wbGUgJiYgdXNlTXVsdGlzYW1wbGVkUlRUKCByZW5kZXJUYXJnZXQgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKCBfZ2wuUkVOREVSQlVGRkVSLCBzYW1wbGVzLCBnbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB1c2VNdWx0aXNhbXBsZWRSVFQoIHJlbmRlclRhcmdldCApICkge1xuXG5cdFx0XHRcdFx0bXVsdGlzYW1wbGVkUlRURXh0LnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZUVYVCggX2dsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBnbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdF9nbC5iaW5kUmVuZGVyYnVmZmVyKCBfZ2wuUkVOREVSQlVGRkVSLCBudWxsICk7XG5cblx0fVxuXG5cdC8vIFNldHVwIHJlc291cmNlcyBmb3IgYSBEZXB0aCBUZXh0dXJlIGZvciBhIEZCTyAobmVlZHMgYW4gZXh0ZW5zaW9uKVxuXHRmdW5jdGlvbiBzZXR1cERlcHRoVGV4dHVyZSggZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCApIHtcblxuXHRcdGNvbnN0IGlzQ3ViZSA9ICggcmVuZGVyVGFyZ2V0ICYmIHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCApO1xuXHRcdGlmICggaXNDdWJlICkgdGhyb3cgbmV3IEVycm9yKCAnRGVwdGggVGV4dHVyZSB3aXRoIGN1YmUgcmVuZGVyIHRhcmdldHMgaXMgbm90IHN1cHBvcnRlZCcgKTtcblxuXHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuXG5cdFx0aWYgKCAhICggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSAmJiByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmlzRGVwdGhUZXh0dXJlICkgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ3JlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBUSFJFRS5EZXB0aFRleHR1cmUnICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICk7XG5cdFx0dGV4dHVyZVByb3BlcnRpZXMuX19yZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG5cblx0XHQvLyB1cGxvYWQgYW4gZW1wdHkgZGVwdGggdGV4dHVyZSB3aXRoIGZyYW1lYnVmZmVyIHNpemVcblx0XHRpZiAoICEgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgfHxcblx0XHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS53aWR0aCAhPT0gcmVuZGVyVGFyZ2V0LndpZHRoIHx8XG5cdFx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaW1hZ2UuaGVpZ2h0ICE9PSByZW5kZXJUYXJnZXQuaGVpZ2h0ICkge1xuXG5cdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoID0gcmVuZGVyVGFyZ2V0LndpZHRoO1xuXHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xuXHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRzZXRUZXh0dXJlMkQoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUsIDAgKTtcblxuXHRcdGNvbnN0IHdlYmdsRGVwdGhUZXh0dXJlID0gdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmU7XG5cdFx0Y29uc3Qgc2FtcGxlcyA9IGdldFJlbmRlclRhcmdldFNhbXBsZXMoIHJlbmRlclRhcmdldCApO1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhGb3JtYXQgKSB7XG5cblx0XHRcdGlmICggdXNlTXVsdGlzYW1wbGVkUlRUKCByZW5kZXJUYXJnZXQgKSApIHtcblxuXHRcdFx0XHRtdWx0aXNhbXBsZWRSVFRFeHQuZnJhbWVidWZmZXJUZXh0dXJlMkRNdWx0aXNhbXBsZUVYVCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlRFWFRVUkVfMkQsIHdlYmdsRGVwdGhUZXh0dXJlLCAwLCBzYW1wbGVzICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xEZXB0aFRleHR1cmUsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5mb3JtYXQgPT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHtcblxuXHRcdFx0aWYgKCB1c2VNdWx0aXNhbXBsZWRSVFQoIHJlbmRlclRhcmdldCApICkge1xuXG5cdFx0XHRcdG11bHRpc2FtcGxlZFJUVEV4dC5mcmFtZWJ1ZmZlclRleHR1cmUyRE11bHRpc2FtcGxlRVhUKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5URVhUVVJFXzJELCB3ZWJnbERlcHRoVGV4dHVyZSwgMCwgc2FtcGxlcyApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xEZXB0aFRleHR1cmUsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVW5rbm93biBkZXB0aFRleHR1cmUgZm9ybWF0JyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBTZXR1cCBHTCByZXNvdXJjZXMgZm9yIGEgbm9uLXRleHR1cmUgZGVwdGggYnVmZmVyXG5cdGZ1bmN0aW9uIHNldHVwRGVwdGhSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdGNvbnN0IHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cdFx0Y29uc3QgaXNDdWJlID0gKCByZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQgPT09IHRydWUgKTtcblxuXHRcdC8vIGlmIHRoZSBib3VuZCBkZXB0aCB0ZXh0dXJlIGhhcyBjaGFuZ2VkXG5cdFx0aWYgKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fYm91bmREZXB0aFRleHR1cmUgIT09IHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgKSB7XG5cblx0XHRcdC8vIGZpcmUgdGhlIGRpc3Bvc2UgZXZlbnQgdG8gZ2V0IHJpZCBvZiBzdG9yZWQgc3RhdGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcmV2aW91c2x5IGJvdW5kIGRlcHRoIGJ1ZmZlclxuXHRcdFx0Y29uc3QgZGVwdGhUZXh0dXJlID0gcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZTtcblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX2RlcHRoRGlzcG9zZUNhbGxiYWNrICkge1xuXG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX19kZXB0aERpc3Bvc2VDYWxsYmFjaygpO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHNldCB1cCBkaXNwb3NlIGxpc3RlbmVycyB0byB0cmFjayB3aGVuIHRoZSBjdXJyZW50bHkgYXR0YWNoZWQgYnVmZmVyIGlzIGltcGxpY2l0bHkgdW5ib3VuZFxuXHRcdFx0aWYgKCBkZXB0aFRleHR1cmUgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGlzcG9zZUV2ZW50ID0gKCkgPT4ge1xuXG5cdFx0XHRcdFx0ZGVsZXRlIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX19ib3VuZERlcHRoVGV4dHVyZTtcblx0XHRcdFx0XHRkZWxldGUgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX2RlcHRoRGlzcG9zZUNhbGxiYWNrO1xuXHRcdFx0XHRcdGRlcHRoVGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIGRpc3Bvc2VFdmVudCApO1xuXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0ZGVwdGhUZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgZGlzcG9zZUV2ZW50ICk7XG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX19kZXB0aERpc3Bvc2VDYWxsYmFjayA9IGRpc3Bvc2VFdmVudDtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fYm91bmREZXB0aFRleHR1cmUgPSBkZXB0aFRleHR1cmU7XG5cblx0XHR9XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgJiYgISByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fYXV0b0FsbG9jYXRlRGVwdGhCdWZmZXIgKSB7XG5cblx0XHRcdGlmICggaXNDdWJlICkgdGhyb3cgbmV3IEVycm9yKCAndGFyZ2V0LmRlcHRoVGV4dHVyZSBub3Qgc3VwcG9ydGVkIGluIEN1YmUgcmVuZGVyIHRhcmdldHMnICk7XG5cblx0XHRcdHNldHVwRGVwdGhUZXh0dXJlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIGlzQ3ViZSApIHtcblxuXHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlclsgaSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0XHRcdFx0XHRzZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyWyBpIF0sIHJlbmRlclRhcmdldCwgZmFsc2UgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIGF0dGFjaCBidWZmZXIgaWYgaXQncyBiZWVuIGNyZWF0ZWQgYWxyZWFkeVxuXHRcdFx0XHRcdFx0Y29uc3QgZ2xBdHRhY2htZW50VHlwZSA9IHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID8gX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCA6IF9nbC5ERVBUSF9BVFRBQ0hNRU5UO1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVuZGVyYnVmZmVyID0gcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXJbIGkgXTtcblx0XHRcdFx0XHRcdF9nbC5iaW5kUmVuZGVyYnVmZmVyKCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcblx0XHRcdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBnbEF0dGFjaG1lbnRUeXBlLCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyICk7XG5cblx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0XHRcdFx0c2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBmYWxzZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBhdHRhY2ggYnVmZmVyIGlmIGl0J3MgYmVlbiBjcmVhdGVkIGFscmVhZHlcblx0XHRcdFx0XHRjb25zdCBnbEF0dGFjaG1lbnRUeXBlID0gcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgPyBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UIDogX2dsLkRFUFRIX0FUVEFDSE1FTlQ7XG5cdFx0XHRcdFx0Y29uc3QgcmVuZGVyYnVmZmVyID0gcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXI7XG5cdFx0XHRcdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXHRcdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBnbEF0dGFjaG1lbnRUeXBlLCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBudWxsICk7XG5cblx0fVxuXG5cdC8vIHJlYmluZCBmcmFtZWJ1ZmZlciB3aXRoIGV4dGVybmFsIHRleHR1cmVzXG5cdGZ1bmN0aW9uIHJlYmluZFRleHR1cmVzKCByZW5kZXJUYXJnZXQsIGNvbG9yVGV4dHVyZSwgZGVwdGhUZXh0dXJlICkge1xuXG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdGlmICggY29sb3JUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHNldHVwRnJhbWVCdWZmZXJUZXh0dXJlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCByZW5kZXJUYXJnZXQudGV4dHVyZSwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV8yRCwgMCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBkZXB0aFRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0c2V0dXBEZXB0aFJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIFNldCB1cCBHTCByZXNvdXJjZXMgZm9yIHRoZSByZW5kZXIgdGFyZ2V0XG5cdGZ1bmN0aW9uIHNldHVwUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRjb25zdCB0ZXh0dXJlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cblx0XHRjb25zdCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXHRcdGNvbnN0IHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcblxuXHRcdHJlbmRlclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xuXG5cdFx0Y29uc3QgdGV4dHVyZXMgPSByZW5kZXJUYXJnZXQudGV4dHVyZXM7XG5cblx0XHRjb25zdCBpc0N1YmUgPSAoIHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCA9PT0gdHJ1ZSApO1xuXHRcdGNvbnN0IGlzTXVsdGlwbGVSZW5kZXJUYXJnZXRzID0gKCB0ZXh0dXJlcy5sZW5ndGggPiAxICk7XG5cblx0XHRpZiAoICEgaXNNdWx0aXBsZVJlbmRlclRhcmdldHMgKSB7XG5cblx0XHRcdGlmICggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uID0gdGV4dHVyZS52ZXJzaW9uO1xuXHRcdFx0aW5mby5tZW1vcnkudGV4dHVyZXMgKys7XG5cblx0XHR9XG5cblx0XHQvLyBTZXR1cCBmcmFtZWJ1ZmZlclxuXG5cdFx0aWYgKCBpc0N1YmUgKSB7XG5cblx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLm1pcG1hcHMgJiYgdGV4dHVyZS5taXBtYXBzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdID0gW107XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHRleHR1cmUubWlwbWFwcy5sZW5ndGg7IGxldmVsICsrICkge1xuXG5cdFx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdWyBsZXZlbCBdID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggdGV4dHVyZS5taXBtYXBzICYmIHRleHR1cmUubWlwbWFwcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID0gW107XG5cblx0XHRcdFx0Zm9yICggbGV0IGxldmVsID0gMDsgbGV2ZWwgPCB0ZXh0dXJlLm1pcG1hcHMubGVuZ3RoOyBsZXZlbCArKyApIHtcblxuXHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBsZXZlbCBdID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc011bHRpcGxlUmVuZGVyVGFyZ2V0cyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGV4dHVyZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBhdHRhY2htZW50UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlc1sgaSBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGF0dGFjaG1lbnRQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGF0dGFjaG1lbnRQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcblxuXHRcdFx0XHRcdFx0aW5mby5tZW1vcnkudGV4dHVyZXMgKys7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggKCByZW5kZXJUYXJnZXQuc2FtcGxlcyA+IDAgKSAmJiB1c2VNdWx0aXNhbXBsZWRSVFQoIHJlbmRlclRhcmdldCApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlciA9IFtdO1xuXG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciApO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHRleHR1cmUgPSB0ZXh0dXJlc1sgaSBdO1xuXHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cblx0XHRcdFx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbIGkgXSApO1xuXG5cdFx0XHRcdFx0Y29uc3QgZ2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLmZvcm1hdCwgdGV4dHVyZS5jb2xvclNwYWNlICk7XG5cdFx0XHRcdFx0Y29uc3QgZ2xUeXBlID0gdXRpbHMuY29udmVydCggdGV4dHVyZS50eXBlICk7XG5cdFx0XHRcdFx0Y29uc3QgZ2xJbnRlcm5hbEZvcm1hdCA9IGdldEludGVybmFsRm9ybWF0KCB0ZXh0dXJlLmludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCB0ZXh0dXJlLmNvbG9yU3BhY2UsIHJlbmRlclRhcmdldC5pc1hSUmVuZGVyVGFyZ2V0ID09PSB0cnVlICk7XG5cdFx0XHRcdFx0Y29uc3Qgc2FtcGxlcyA9IGdldFJlbmRlclRhcmdldFNhbXBsZXMoIHJlbmRlclRhcmdldCApO1xuXHRcdFx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoIF9nbC5SRU5ERVJCVUZGRVIsIHNhbXBsZXMsIGdsSW50ZXJuYWxGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xuXG5cdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyWyBpIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIG51bGwgKTtcblxuXHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoUmVuZGVyYnVmZmVyID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXHRcdFx0XHRcdHNldHVwUmVuZGVyQnVmZmVyU3RvcmFnZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCwgdHJ1ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBTZXR1cCBjb2xvciBidWZmZXJcblxuXHRcdGlmICggaXNDdWJlICkge1xuXG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG5cdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIHRleHR1cmUubWlwbWFwcyAmJiB0ZXh0dXJlLm1pcG1hcHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBsZXZlbCA9IDA7IGxldmVsIDwgdGV4dHVyZS5taXBtYXBzLmxlbmd0aDsgbGV2ZWwgKysgKSB7XG5cblx0XHRcdFx0XHRcdHNldHVwRnJhbWVCdWZmZXJUZXh0dXJlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdWyBsZXZlbCBdLCByZW5kZXJUYXJnZXQsIHRleHR1cmUsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGxldmVsICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHNldHVwRnJhbWVCdWZmZXJUZXh0dXJlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQsIHRleHR1cmUsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUgKSApIHtcblxuXHRcdFx0XHRnZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG5cblx0XHR9IGVsc2UgaWYgKCBpc011bHRpcGxlUmVuZGVyVGFyZ2V0cyApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHRleHR1cmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGF0dGFjaG1lbnQgPSB0ZXh0dXJlc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBhdHRhY2htZW50UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBhdHRhY2htZW50ICk7XG5cblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBhdHRhY2htZW50UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIGF0dGFjaG1lbnQgKTtcblx0XHRcdFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIGF0dGFjaG1lbnQsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIF9nbC5URVhUVVJFXzJELCAwICk7XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIGF0dGFjaG1lbnQgKSApIHtcblxuXHRcdFx0XHRcdGdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRsZXQgZ2xUZXh0dXJlVHlwZSA9IF9nbC5URVhUVVJFXzJEO1xuXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldC5pc1dlYkdMM0RSZW5kZXJUYXJnZXQgfHwgcmVuZGVyVGFyZ2V0LmlzV2ViR0xBcnJheVJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0XHRnbFRleHR1cmVUeXBlID0gcmVuZGVyVGFyZ2V0LmlzV2ViR0wzRFJlbmRlclRhcmdldCA/IF9nbC5URVhUVVJFXzNEIDogX2dsLlRFWFRVUkVfMkRfQVJSQVk7XG5cblx0XHRcdH1cblxuXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsVGV4dHVyZVR5cGUsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG5cdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggZ2xUZXh0dXJlVHlwZSwgdGV4dHVyZSApO1xuXG5cdFx0XHRpZiAoIHRleHR1cmUubWlwbWFwcyAmJiB0ZXh0dXJlLm1pcG1hcHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHRleHR1cmUubWlwbWFwcy5sZW5ndGg7IGxldmVsICsrICkge1xuXG5cdFx0XHRcdFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBsZXZlbCBdLCByZW5kZXJUYXJnZXQsIHRleHR1cmUsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2xUZXh0dXJlVHlwZSwgbGV2ZWwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIHRleHR1cmUsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2xUZXh0dXJlVHlwZSwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlICkgKSB7XG5cblx0XHRcdFx0Z2VuZXJhdGVNaXBtYXAoIGdsVGV4dHVyZVR5cGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG5cblx0XHR9XG5cblx0XHQvLyBTZXR1cCBkZXB0aCBhbmQgc3RlbmNpbCBidWZmZXJzXG5cblx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciApIHtcblxuXHRcdFx0c2V0dXBEZXB0aFJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZXMgPSByZW5kZXJUYXJnZXQudGV4dHVyZXM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGV4dHVyZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHRleHR1cmUgPSB0ZXh0dXJlc1sgaSBdO1xuXG5cdFx0XHRpZiAoIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSApICkge1xuXG5cdFx0XHRcdGNvbnN0IHRhcmdldFR5cGUgPSBnZXRUYXJnZXRUeXBlKCByZW5kZXJUYXJnZXQgKTtcblx0XHRcdFx0Y29uc3Qgd2ViZ2xUZXh0dXJlID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZTtcblxuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggdGFyZ2V0VHlwZSwgd2ViZ2xUZXh0dXJlICk7XG5cdFx0XHRcdGdlbmVyYXRlTWlwbWFwKCB0YXJnZXRUeXBlICk7XG5cdFx0XHRcdHN0YXRlLnVuYmluZFRleHR1cmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCBpbnZhbGlkYXRpb25BcnJheVJlYWQgPSBbXTtcblx0Y29uc3QgaW52YWxpZGF0aW9uQXJyYXlEcmF3ID0gW107XG5cblx0ZnVuY3Rpb24gdXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdGlmICggcmVuZGVyVGFyZ2V0LnNhbXBsZXMgPiAwICkge1xuXG5cdFx0XHRpZiAoIHVzZU11bHRpc2FtcGxlZFJUVCggcmVuZGVyVGFyZ2V0ICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGNvbnN0IHRleHR1cmVzID0gcmVuZGVyVGFyZ2V0LnRleHR1cmVzO1xuXHRcdFx0XHRjb25zdCB3aWR0aCA9IHJlbmRlclRhcmdldC53aWR0aDtcblx0XHRcdFx0Y29uc3QgaGVpZ2h0ID0gcmVuZGVyVGFyZ2V0LmhlaWdodDtcblx0XHRcdFx0bGV0IG1hc2sgPSBfZ2wuQ09MT1JfQlVGRkVSX0JJVDtcblx0XHRcdFx0Y29uc3QgZGVwdGhTdHlsZSA9IHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID8gX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCA6IF9nbC5ERVBUSF9BVFRBQ0hNRU5UO1xuXHRcdFx0XHRjb25zdCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXHRcdFx0XHRjb25zdCBpc011bHRpcGxlUmVuZGVyVGFyZ2V0cyA9ICggdGV4dHVyZXMubGVuZ3RoID4gMSApO1xuXG5cdFx0XHRcdC8vIElmIE1SVCB3ZSBuZWVkIHRvIHJlbW92ZSBGQk8gYXR0YWNobWVudHNcblx0XHRcdFx0aWYgKCBpc011bHRpcGxlUmVuZGVyVGFyZ2V0cyApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyICk7XG5cdFx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSwgX2dsLlJFTkRFUkJVRkZFUiwgbnVsbCApO1xuXG5cdFx0XHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgKTtcblx0XHRcdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkRSQVdfRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIF9nbC5URVhUVVJFXzJELCBudWxsLCAwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLlJFQURfRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyICk7XG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkRSQVdfRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyICk7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGV4dHVyZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXQucmVzb2x2ZURlcHRoQnVmZmVyICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciApIG1hc2sgfD0gX2dsLkRFUFRIX0JVRkZFUl9CSVQ7XG5cblx0XHRcdFx0XHRcdC8vIHJlc29sdmluZyBzdGVuY2lsIGlzIHNsb3cgd2l0aCBhIEQzRCBiYWNrZW5kLiBkaXNhYmxlIGl0IGZvciBhbGwgdHJhbnNtaXNzaW9uIHJlbmRlciB0YXJnZXRzIChzZWUgIzI3Nzk5KVxuXG5cdFx0XHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICYmIHJlbmRlclRhcmdldC5yZXNvbHZlU3RlbmNpbEJ1ZmZlciApIG1hc2sgfD0gX2dsLlNURU5DSUxfQlVGRkVSX0JJVDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggaXNNdWx0aXBsZVJlbmRlclRhcmdldHMgKSB7XG5cblx0XHRcdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLlJFQURfRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbIGkgXSApO1xuXG5cdFx0XHRcdFx0XHRjb25zdCB3ZWJnbFRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZXNbIGkgXSApLl9fd2ViZ2xUZXh0dXJlO1xuXHRcdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRFJBV19GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xUZXh0dXJlLCAwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfZ2wuYmxpdEZyYW1lYnVmZmVyKCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCBtYXNrLCBfZ2wuTkVBUkVTVCApO1xuXG5cdFx0XHRcdFx0aWYgKCBzdXBwb3J0c0ludmFsaWRhdGVGcmFtZWJ1ZmZlciA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0aW52YWxpZGF0aW9uQXJyYXlSZWFkLmxlbmd0aCA9IDA7XG5cdFx0XHRcdFx0XHRpbnZhbGlkYXRpb25BcnJheURyYXcubGVuZ3RoID0gMDtcblxuXHRcdFx0XHRcdFx0aW52YWxpZGF0aW9uQXJyYXlSZWFkLnB1c2goIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnJlc29sdmVEZXB0aEJ1ZmZlciA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0aW52YWxpZGF0aW9uQXJyYXlSZWFkLnB1c2goIGRlcHRoU3R5bGUgKTtcblx0XHRcdFx0XHRcdFx0aW52YWxpZGF0aW9uQXJyYXlEcmF3LnB1c2goIGRlcHRoU3R5bGUgKTtcblxuXHRcdFx0XHRcdFx0XHRfZ2wuaW52YWxpZGF0ZUZyYW1lYnVmZmVyKCBfZ2wuRFJBV19GUkFNRUJVRkZFUiwgaW52YWxpZGF0aW9uQXJyYXlEcmF3ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0X2dsLmludmFsaWRhdGVGcmFtZWJ1ZmZlciggX2dsLlJFQURfRlJBTUVCVUZGRVIsIGludmFsaWRhdGlvbkFycmF5UmVhZCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5SRUFEX0ZSQU1FQlVGRkVSLCBudWxsICk7XG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkRSQVdfRlJBTUVCVUZGRVIsIG51bGwgKTtcblxuXHRcdFx0XHQvLyBJZiBNUlQgc2luY2UgcHJlLWJsaXQgd2UgcmVtb3ZlZCB0aGUgRkJPIHdlIG5lZWQgdG8gcmVjb25zdHJ1Y3QgdGhlIGF0dGFjaG1lbnRzXG5cdFx0XHRcdGlmICggaXNNdWx0aXBsZVJlbmRlclRhcmdldHMgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciApO1xuXHRcdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyWyBpIF0gKTtcblxuXHRcdFx0XHRcdFx0Y29uc3Qgd2ViZ2xUZXh0dXJlID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmVzWyBpIF0gKS5fX3dlYmdsVGV4dHVyZTtcblxuXHRcdFx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyICk7XG5cdFx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xUZXh0dXJlLCAwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkRSQVdfRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnJlc29sdmVEZXB0aEJ1ZmZlciA9PT0gZmFsc2UgJiYgc3VwcG9ydHNJbnZhbGlkYXRlRnJhbWVidWZmZXIgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBkZXB0aFN0eWxlID0gcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgPyBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UIDogX2dsLkRFUFRIX0FUVEFDSE1FTlQ7XG5cblx0XHRcdFx0XHRfZ2wuaW52YWxpZGF0ZUZyYW1lYnVmZmVyKCBfZ2wuRFJBV19GUkFNRUJVRkZFUiwgWyBkZXB0aFN0eWxlIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UmVuZGVyVGFyZ2V0U2FtcGxlcyggcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIE1hdGgubWluKCBjYXBhYmlsaXRpZXMubWF4U2FtcGxlcywgcmVuZGVyVGFyZ2V0LnNhbXBsZXMgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gdXNlTXVsdGlzYW1wbGVkUlRUKCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRjb25zdCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXG5cdFx0cmV0dXJuIHJlbmRlclRhcmdldC5zYW1wbGVzID4gMCAmJiBleHRlbnNpb25zLmhhcyggJ1dFQkdMX211bHRpc2FtcGxlZF9yZW5kZXJfdG9fdGV4dHVyZScgKSA9PT0gdHJ1ZSAmJiByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fdXNlUmVuZGVyVG9UZXh0dXJlICE9PSBmYWxzZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlVmlkZW9UZXh0dXJlKCB0ZXh0dXJlICkge1xuXG5cdFx0Y29uc3QgZnJhbWUgPSBpbmZvLnJlbmRlci5mcmFtZTtcblxuXHRcdC8vIENoZWNrIHRoZSBsYXN0IGZyYW1lIHdlIHVwZGF0ZWQgdGhlIFZpZGVvVGV4dHVyZVxuXG5cdFx0aWYgKCBfdmlkZW9UZXh0dXJlcy5nZXQoIHRleHR1cmUgKSAhPT0gZnJhbWUgKSB7XG5cblx0XHRcdF92aWRlb1RleHR1cmVzLnNldCggdGV4dHVyZSwgZnJhbWUgKTtcblx0XHRcdHRleHR1cmUudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHZlcmlmeUNvbG9yU3BhY2UoIHRleHR1cmUsIGltYWdlICkge1xuXG5cdFx0Y29uc3QgY29sb3JTcGFjZSA9IHRleHR1cmUuY29sb3JTcGFjZTtcblx0XHRjb25zdCBmb3JtYXQgPSB0ZXh0dXJlLmZvcm1hdDtcblx0XHRjb25zdCB0eXBlID0gdGV4dHVyZS50eXBlO1xuXG5cdFx0aWYgKCB0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgPT09IHRydWUgfHwgdGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSA9PT0gdHJ1ZSApIHJldHVybiBpbWFnZTtcblxuXHRcdGlmICggY29sb3JTcGFjZSAhPT0gTGluZWFyU1JHQkNvbG9yU3BhY2UgJiYgY29sb3JTcGFjZSAhPT0gTm9Db2xvclNwYWNlICkge1xuXG5cdFx0XHQvLyBzUkdCXG5cblx0XHRcdGlmICggQ29sb3JNYW5hZ2VtZW50LmdldFRyYW5zZmVyKCBjb2xvclNwYWNlICkgPT09IFNSR0JUcmFuc2ZlciApIHtcblxuXHRcdFx0XHQvLyBpbiBXZWJHTCAyIHVuY29tcHJlc3NlZCB0ZXh0dXJlcyBjYW4gb25seSBiZSBzUkdCIGVuY29kZWQgaWYgdGhleSBoYXZlIHRoZSBSR0JBOCBmb3JtYXRcblxuXHRcdFx0XHRpZiAoIGZvcm1hdCAhPT0gUkdCQUZvcm1hdCB8fCB0eXBlICE9PSBVbnNpZ25lZEJ5dGVUeXBlICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xUZXh0dXJlczogc1JHQiBlbmNvZGVkIHRleHR1cmVzIGhhdmUgdG8gdXNlIFJHQkFGb3JtYXQgYW5kIFVuc2lnbmVkQnl0ZVR5cGUuJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xUZXh0dXJlczogVW5zdXBwb3J0ZWQgdGV4dHVyZSBjb2xvciBzcGFjZTonLCBjb2xvclNwYWNlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBpbWFnZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyggaW1hZ2UgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgKSB7XG5cblx0XHRcdC8vIGlmIGludHJpbnNpYyBkYXRhIGFyZSBub3QgYXZhaWxhYmxlLCBmYWxsYmFjayB0byB3aWR0aC9oZWlnaHRcblxuXHRcdFx0X2ltYWdlRGltZW5zaW9ucy53aWR0aCA9IGltYWdlLm5hdHVyYWxXaWR0aCB8fCBpbWFnZS53aWR0aDtcblx0XHRcdF9pbWFnZURpbWVuc2lvbnMuaGVpZ2h0ID0gaW1hZ2UubmF0dXJhbEhlaWdodCB8fCBpbWFnZS5oZWlnaHQ7XG5cblx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgVmlkZW9GcmFtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBWaWRlb0ZyYW1lICkge1xuXG5cdFx0XHRfaW1hZ2VEaW1lbnNpb25zLndpZHRoID0gaW1hZ2UuZGlzcGxheVdpZHRoO1xuXHRcdFx0X2ltYWdlRGltZW5zaW9ucy5oZWlnaHQgPSBpbWFnZS5kaXNwbGF5SGVpZ2h0O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X2ltYWdlRGltZW5zaW9ucy53aWR0aCA9IGltYWdlLndpZHRoO1xuXHRcdFx0X2ltYWdlRGltZW5zaW9ucy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gX2ltYWdlRGltZW5zaW9ucztcblxuXHR9XG5cblx0Ly9cblxuXHR0aGlzLmFsbG9jYXRlVGV4dHVyZVVuaXQgPSBhbGxvY2F0ZVRleHR1cmVVbml0O1xuXHR0aGlzLnJlc2V0VGV4dHVyZVVuaXRzID0gcmVzZXRUZXh0dXJlVW5pdHM7XG5cblx0dGhpcy5zZXRUZXh0dXJlMkQgPSBzZXRUZXh0dXJlMkQ7XG5cdHRoaXMuc2V0VGV4dHVyZTJEQXJyYXkgPSBzZXRUZXh0dXJlMkRBcnJheTtcblx0dGhpcy5zZXRUZXh0dXJlM0QgPSBzZXRUZXh0dXJlM0Q7XG5cdHRoaXMuc2V0VGV4dHVyZUN1YmUgPSBzZXRUZXh0dXJlQ3ViZTtcblx0dGhpcy5yZWJpbmRUZXh0dXJlcyA9IHJlYmluZFRleHR1cmVzO1xuXHR0aGlzLnNldHVwUmVuZGVyVGFyZ2V0ID0gc2V0dXBSZW5kZXJUYXJnZXQ7XG5cdHRoaXMudXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwID0gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwO1xuXHR0aGlzLnVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0ID0gdXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQ7XG5cdHRoaXMuc2V0dXBEZXB0aFJlbmRlcmJ1ZmZlciA9IHNldHVwRGVwdGhSZW5kZXJidWZmZXI7XG5cdHRoaXMuc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUgPSBzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZTtcblx0dGhpcy51c2VNdWx0aXNhbXBsZWRSVFQgPSB1c2VNdWx0aXNhbXBsZWRSVFQ7XG5cbn1cblxuZnVuY3Rpb24gV2ViR0xVdGlscyggZ2wsIGV4dGVuc2lvbnMgKSB7XG5cblx0ZnVuY3Rpb24gY29udmVydCggcCwgY29sb3JTcGFjZSA9IE5vQ29sb3JTcGFjZSApIHtcblxuXHRcdGxldCBleHRlbnNpb247XG5cblx0XHRjb25zdCB0cmFuc2ZlciA9IENvbG9yTWFuYWdlbWVudC5nZXRUcmFuc2ZlciggY29sb3JTcGFjZSApO1xuXG5cdFx0aWYgKCBwID09PSBVbnNpZ25lZEJ5dGVUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0aWYgKCBwID09PSBVbnNpZ25lZFNob3J0NDQ0NFR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNDtcblx0XHRpZiAoIHAgPT09IFVuc2lnbmVkU2hvcnQ1NTUxVHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9TSE9SVF81XzVfNV8xO1xuXHRcdGlmICggcCA9PT0gVW5zaWduZWRJbnQ1OTk5VHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9JTlRfNV85XzlfOV9SRVY7XG5cblx0XHRpZiAoIHAgPT09IEJ5dGVUeXBlICkgcmV0dXJuIGdsLkJZVEU7XG5cdFx0aWYgKCBwID09PSBTaG9ydFR5cGUgKSByZXR1cm4gZ2wuU0hPUlQ7XG5cdFx0aWYgKCBwID09PSBVbnNpZ25lZFNob3J0VHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9TSE9SVDtcblx0XHRpZiAoIHAgPT09IEludFR5cGUgKSByZXR1cm4gZ2wuSU5UO1xuXHRcdGlmICggcCA9PT0gVW5zaWduZWRJbnRUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX0lOVDtcblx0XHRpZiAoIHAgPT09IEZsb2F0VHlwZSApIHJldHVybiBnbC5GTE9BVDtcblx0XHRpZiAoIHAgPT09IEhhbGZGbG9hdFR5cGUgKSByZXR1cm4gZ2wuSEFMRl9GTE9BVDtcblxuXHRcdGlmICggcCA9PT0gQWxwaGFGb3JtYXQgKSByZXR1cm4gZ2wuQUxQSEE7XG5cdFx0aWYgKCBwID09PSBSR0JGb3JtYXQgKSByZXR1cm4gZ2wuUkdCO1xuXHRcdGlmICggcCA9PT0gUkdCQUZvcm1hdCApIHJldHVybiBnbC5SR0JBO1xuXHRcdGlmICggcCA9PT0gTHVtaW5hbmNlRm9ybWF0ICkgcmV0dXJuIGdsLkxVTUlOQU5DRTtcblx0XHRpZiAoIHAgPT09IEx1bWluYW5jZUFscGhhRm9ybWF0ICkgcmV0dXJuIGdsLkxVTUlOQU5DRV9BTFBIQTtcblx0XHRpZiAoIHAgPT09IERlcHRoRm9ybWF0ICkgcmV0dXJuIGdsLkRFUFRIX0NPTVBPTkVOVDtcblx0XHRpZiAoIHAgPT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHJldHVybiBnbC5ERVBUSF9TVEVOQ0lMO1xuXG5cdFx0Ly8gV2ViR0wyIGZvcm1hdHMuXG5cblx0XHRpZiAoIHAgPT09IFJlZEZvcm1hdCApIHJldHVybiBnbC5SRUQ7XG5cdFx0aWYgKCBwID09PSBSZWRJbnRlZ2VyRm9ybWF0ICkgcmV0dXJuIGdsLlJFRF9JTlRFR0VSO1xuXHRcdGlmICggcCA9PT0gUkdGb3JtYXQgKSByZXR1cm4gZ2wuUkc7XG5cdFx0aWYgKCBwID09PSBSR0ludGVnZXJGb3JtYXQgKSByZXR1cm4gZ2wuUkdfSU5URUdFUjtcblx0XHRpZiAoIHAgPT09IFJHQkFJbnRlZ2VyRm9ybWF0ICkgcmV0dXJuIGdsLlJHQkFfSU5URUdFUjtcblxuXHRcdC8vIFMzVENcblxuXHRcdGlmICggcCA9PT0gUkdCX1MzVENfRFhUMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9TM1RDX0RYVDFfRm9ybWF0IHx8IHAgPT09IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCB8fCBwID09PSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSB7XG5cblx0XHRcdGlmICggdHJhbnNmZXIgPT09IFNSR0JUcmFuc2ZlciApIHtcblxuXHRcdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjX3NyZ2InICk7XG5cblx0XHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHAgPT09IFJHQl9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0JfUzNUQ19EWFQxX0VYVDtcblx0XHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUMV9FWFQ7XG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUM19Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDNfRVhUO1xuXHRcdFx0XHRcdGlmICggcCA9PT0gUkdCQV9TM1RDX0RYVDVfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQ1X0VYVDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XG5cblx0XHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHAgPT09IFJHQl9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO1xuXHRcdFx0XHRcdGlmICggcCA9PT0gUkdCQV9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVDtcblx0XHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQ7XG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIFBWUlRDXG5cblx0XHRpZiAoIHAgPT09IFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0IHx8IHAgPT09IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0IHx8IHAgPT09IFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCB8fCBwID09PSBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSB7XG5cblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xuXG5cdFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRpZiAoIHAgPT09IFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HO1xuXHRcdFx0XHRpZiAoIHAgPT09IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HO1xuXHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUc7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNRztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gRVRDXG5cblx0XHRpZiAoIHAgPT09IFJHQl9FVEMxX0Zvcm1hdCB8fCBwID09PSBSR0JfRVRDMl9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9FVEMyX0VBQ19Gb3JtYXQgKSB7XG5cblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YycgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0aWYgKCBwID09PSBSR0JfRVRDMV9Gb3JtYXQgfHwgcCA9PT0gUkdCX0VUQzJfRm9ybWF0ICkgcmV0dXJuICggdHJhbnNmZXIgPT09IFNSR0JUcmFuc2ZlciApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfRVRDMiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQjhfRVRDMjtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0VUQzJfRUFDX0Zvcm1hdCApIHJldHVybiAoIHRyYW5zZmVyID09PSBTUkdCVHJhbnNmZXIgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9FVEMyX0VBQyA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkE4X0VUQzJfRUFDO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBBU1RDXG5cblx0XHRpZiAoIHAgPT09IFJHQkFfQVNUQ180eDRfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ181eDRfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ181eDVfRm9ybWF0IHx8XG5cdFx0XHRwID09PSBSR0JBX0FTVENfNng1X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfNng2X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfOHg1X0Zvcm1hdCB8fFxuXHRcdFx0cCA9PT0gUkdCQV9BU1RDXzh4Nl9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzh4OF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEweDVfRm9ybWF0IHx8XG5cdFx0XHRwID09PSBSR0JBX0FTVENfMTB4Nl9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEweDhfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ18xMHgxMF9Gb3JtYXQgfHxcblx0XHRcdHAgPT09IFJHQkFfQVNUQ18xMngxMF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdCApIHtcblxuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXN0YycgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfNHg0X0Zvcm1hdCApIHJldHVybiAoIHRyYW5zZmVyID09PSBTUkdCVHJhbnNmZXIgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzR4NF9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfNHg0X0tIUjtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfNXg0X0Zvcm1hdCApIHJldHVybiAoIHRyYW5zZmVyID09PSBTUkdCVHJhbnNmZXIgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzV4NF9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfNXg0X0tIUjtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfNXg1X0Zvcm1hdCApIHJldHVybiAoIHRyYW5zZmVyID09PSBTUkdCVHJhbnNmZXIgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzV4NV9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfNXg1X0tIUjtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfNng1X0Zvcm1hdCApIHJldHVybiAoIHRyYW5zZmVyID09PSBTUkdCVHJhbnNmZXIgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzZ4NV9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfNng1X0tIUjtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfNng2X0Zvcm1hdCApIHJldHVybiAoIHRyYW5zZmVyID09PSBTUkdCVHJhbnNmZXIgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzZ4Nl9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfNng2X0tIUjtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfOHg1X0Zvcm1hdCApIHJldHVybiAoIHRyYW5zZmVyID09PSBTUkdCVHJhbnNmZXIgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzh4NV9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfOHg1X0tIUjtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfOHg2X0Zvcm1hdCApIHJldHVybiAoIHRyYW5zZmVyID09PSBTUkdCVHJhbnNmZXIgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzh4Nl9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfOHg2X0tIUjtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfOHg4X0Zvcm1hdCApIHJldHVybiAoIHRyYW5zZmVyID09PSBTUkdCVHJhbnNmZXIgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzh4OF9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfOHg4X0tIUjtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfMTB4NV9Gb3JtYXQgKSByZXR1cm4gKCB0cmFuc2ZlciA9PT0gU1JHQlRyYW5zZmVyICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMHg1X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMHg1X0tIUjtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfMTB4Nl9Gb3JtYXQgKSByZXR1cm4gKCB0cmFuc2ZlciA9PT0gU1JHQlRyYW5zZmVyICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMHg2X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMHg2X0tIUjtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfMTB4OF9Gb3JtYXQgKSByZXR1cm4gKCB0cmFuc2ZlciA9PT0gU1JHQlRyYW5zZmVyICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMHg4X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMHg4X0tIUjtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfMTB4MTBfRm9ybWF0ICkgcmV0dXJuICggdHJhbnNmZXIgPT09IFNSR0JUcmFuc2ZlciApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4MTBfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEweDEwX0tIUjtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfMTJ4MTBfRm9ybWF0ICkgcmV0dXJuICggdHJhbnNmZXIgPT09IFNSR0JUcmFuc2ZlciApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTJ4MTBfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEyeDEwX0tIUjtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfMTJ4MTJfRm9ybWF0ICkgcmV0dXJuICggdHJhbnNmZXIgPT09IFNSR0JUcmFuc2ZlciApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTJ4MTJfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEyeDEyX0tIUjtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gQlBUQ1xuXG5cdFx0aWYgKCBwID09PSBSR0JBX0JQVENfRm9ybWF0IHx8IHAgPT09IFJHQl9CUFRDX1NJR05FRF9Gb3JtYXQgfHwgcCA9PT0gUkdCX0JQVENfVU5TSUdORURfRm9ybWF0ICkge1xuXG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2NvbXByZXNzaW9uX2JwdGMnICk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9CUFRDX0Zvcm1hdCApIHJldHVybiAoIHRyYW5zZmVyID09PSBTUkdCVHJhbnNmZXIgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0JfQUxQSEFfQlBUQ19VTk9STV9FWFQgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0JQVENfVU5PUk1fRVhUO1xuXHRcdFx0XHRpZiAoIHAgPT09IFJHQl9CUFRDX1NJR05FRF9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX0JQVENfU0lHTkVEX0ZMT0FUX0VYVDtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JfQlBUQ19VTlNJR05FRF9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX0JQVENfVU5TSUdORURfRkxPQVRfRVhUO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBSR1RDXG5cblx0XHRpZiAoIHAgPT09IFJFRF9SR1RDMV9Gb3JtYXQgfHwgcCA9PT0gU0lHTkVEX1JFRF9SR1RDMV9Gb3JtYXQgfHwgcCA9PT0gUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCB8fCBwID09PSBTSUdORURfUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCApIHtcblxuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9jb21wcmVzc2lvbl9yZ3RjJyApO1xuXG5cdFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfQlBUQ19Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkVEX1JHVEMxX0VYVDtcblx0XHRcdFx0aWYgKCBwID09PSBTSUdORURfUkVEX1JHVEMxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9TSUdORURfUkVEX1JHVEMxX0VYVDtcblx0XHRcdFx0aWYgKCBwID09PSBSRURfR1JFRU5fUkdUQzJfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JFRF9HUkVFTl9SR1RDMl9FWFQ7XG5cdFx0XHRcdGlmICggcCA9PT0gU0lHTkVEX1JFRF9HUkVFTl9SR1RDMl9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU0lHTkVEX1JFRF9HUkVFTl9SR1RDMl9FWFQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHAgPT09IFVuc2lnbmVkSW50MjQ4VHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9JTlRfMjRfODtcblxuXHRcdC8vIGlmIFwicFwiIGNhbid0IGJlIHJlc29sdmVkLCBhc3N1bWUgdGhlIHVzZXIgZGVmaW5lcyBhIFdlYkdMIGNvbnN0YW50IGFzIGEgc3RyaW5nIChmYWxsYmFjay93b3JrYXJvdW5kIGZvciBwYWNrZWQgUkdCIGZvcm1hdHMpXG5cblx0XHRyZXR1cm4gKCBnbFsgcCBdICE9PSB1bmRlZmluZWQgKSA/IGdsWyBwIF0gOiBudWxsO1xuXG5cdH1cblxuXHRyZXR1cm4geyBjb252ZXJ0OiBjb252ZXJ0IH07XG5cbn1cblxuY29uc3QgX21vdmVFdmVudCA9IHsgdHlwZTogJ21vdmUnIH07XG5cbmNsYXNzIFdlYlhSQ29udHJvbGxlciB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHR0aGlzLl90YXJnZXRSYXkgPSBudWxsO1xuXHRcdHRoaXMuX2dyaXAgPSBudWxsO1xuXHRcdHRoaXMuX2hhbmQgPSBudWxsO1xuXG5cdH1cblxuXHRnZXRIYW5kU3BhY2UoKSB7XG5cblx0XHRpZiAoIHRoaXMuX2hhbmQgPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX2hhbmQgPSBuZXcgR3JvdXAoKTtcblx0XHRcdHRoaXMuX2hhbmQubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5faGFuZC52aXNpYmxlID0gZmFsc2U7XG5cblx0XHRcdHRoaXMuX2hhbmQuam9pbnRzID0ge307XG5cdFx0XHR0aGlzLl9oYW5kLmlucHV0U3RhdGUgPSB7IHBpbmNoaW5nOiBmYWxzZSB9O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX2hhbmQ7XG5cblx0fVxuXG5cdGdldFRhcmdldFJheVNwYWNlKCkge1xuXG5cdFx0aWYgKCB0aGlzLl90YXJnZXRSYXkgPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX3RhcmdldFJheSA9IG5ldyBHcm91cCgpO1xuXHRcdFx0dGhpcy5fdGFyZ2V0UmF5Lm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3RhcmdldFJheS52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHR0aGlzLl90YXJnZXRSYXkuaGFzTGluZWFyVmVsb2NpdHkgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3RhcmdldFJheS5saW5lYXJWZWxvY2l0eSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR0aGlzLl90YXJnZXRSYXkuaGFzQW5ndWxhclZlbG9jaXR5ID0gZmFsc2U7XG5cdFx0XHR0aGlzLl90YXJnZXRSYXkuYW5ndWxhclZlbG9jaXR5ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl90YXJnZXRSYXk7XG5cblx0fVxuXG5cdGdldEdyaXBTcGFjZSgpIHtcblxuXHRcdGlmICggdGhpcy5fZ3JpcCA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5fZ3JpcCA9IG5ldyBHcm91cCgpO1xuXHRcdFx0dGhpcy5fZ3JpcC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9ncmlwLnZpc2libGUgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2dyaXAuaGFzTGluZWFyVmVsb2NpdHkgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2dyaXAubGluZWFyVmVsb2NpdHkgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dGhpcy5fZ3JpcC5oYXNBbmd1bGFyVmVsb2NpdHkgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2dyaXAuYW5ndWxhclZlbG9jaXR5ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl9ncmlwO1xuXG5cdH1cblxuXHRkaXNwYXRjaEV2ZW50KCBldmVudCApIHtcblxuXHRcdGlmICggdGhpcy5fdGFyZ2V0UmF5ICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLl90YXJnZXRSYXkuZGlzcGF0Y2hFdmVudCggZXZlbnQgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5fZ3JpcCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5fZ3JpcC5kaXNwYXRjaEV2ZW50KCBldmVudCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9oYW5kICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLl9oYW5kLmRpc3BhdGNoRXZlbnQoIGV2ZW50ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29ubmVjdCggaW5wdXRTb3VyY2UgKSB7XG5cblx0XHRpZiAoIGlucHV0U291cmNlICYmIGlucHV0U291cmNlLmhhbmQgKSB7XG5cblx0XHRcdGNvbnN0IGhhbmQgPSB0aGlzLl9oYW5kO1xuXG5cdFx0XHRpZiAoIGhhbmQgKSB7XG5cblx0XHRcdFx0Zm9yICggY29uc3QgaW5wdXRqb2ludCBvZiBpbnB1dFNvdXJjZS5oYW5kLnZhbHVlcygpICkge1xuXG5cdFx0XHRcdFx0Ly8gSW5pdGlhbGl6ZSBoYW5kIHdpdGggam9pbnRzIHdoZW4gY29ubmVjdGVkXG5cdFx0XHRcdFx0dGhpcy5fZ2V0SGFuZEpvaW50KCBoYW5kLCBpbnB1dGpvaW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Nvbm5lY3RlZCcsIGRhdGE6IGlucHV0U291cmNlIH0gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXNjb25uZWN0KCBpbnB1dFNvdXJjZSApIHtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzY29ubmVjdGVkJywgZGF0YTogaW5wdXRTb3VyY2UgfSApO1xuXG5cdFx0aWYgKCB0aGlzLl90YXJnZXRSYXkgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX3RhcmdldFJheS52aXNpYmxlID0gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX2dyaXAgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX2dyaXAudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9oYW5kICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLl9oYW5kLnZpc2libGUgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR1cGRhdGUoIGlucHV0U291cmNlLCBmcmFtZSwgcmVmZXJlbmNlU3BhY2UgKSB7XG5cblx0XHRsZXQgaW5wdXRQb3NlID0gbnVsbDtcblx0XHRsZXQgZ3JpcFBvc2UgPSBudWxsO1xuXHRcdGxldCBoYW5kUG9zZSA9IG51bGw7XG5cblx0XHRjb25zdCB0YXJnZXRSYXkgPSB0aGlzLl90YXJnZXRSYXk7XG5cdFx0Y29uc3QgZ3JpcCA9IHRoaXMuX2dyaXA7XG5cdFx0Y29uc3QgaGFuZCA9IHRoaXMuX2hhbmQ7XG5cblx0XHRpZiAoIGlucHV0U291cmNlICYmIGZyYW1lLnNlc3Npb24udmlzaWJpbGl0eVN0YXRlICE9PSAndmlzaWJsZS1ibHVycmVkJyApIHtcblxuXHRcdFx0aWYgKCBoYW5kICYmIGlucHV0U291cmNlLmhhbmQgKSB7XG5cblx0XHRcdFx0aGFuZFBvc2UgPSB0cnVlO1xuXG5cdFx0XHRcdGZvciAoIGNvbnN0IGlucHV0am9pbnQgb2YgaW5wdXRTb3VyY2UuaGFuZC52YWx1ZXMoKSApIHtcblxuXHRcdFx0XHRcdC8vIFVwZGF0ZSB0aGUgam9pbnRzIGdyb3VwcyB3aXRoIHRoZSBYUkpvaW50IHBvc2VzXG5cdFx0XHRcdFx0Y29uc3Qgam9pbnRQb3NlID0gZnJhbWUuZ2V0Sm9pbnRQb3NlKCBpbnB1dGpvaW50LCByZWZlcmVuY2VTcGFjZSApO1xuXG5cdFx0XHRcdFx0Ly8gVGhlIHRyYW5zZm9ybSBvZiB0aGlzIGpvaW50IHdpbGwgYmUgdXBkYXRlZCB3aXRoIHRoZSBqb2ludCBwb3NlIG9uIGVhY2ggZnJhbWVcblx0XHRcdFx0XHRjb25zdCBqb2ludCA9IHRoaXMuX2dldEhhbmRKb2ludCggaGFuZCwgaW5wdXRqb2ludCApO1xuXG5cdFx0XHRcdFx0aWYgKCBqb2ludFBvc2UgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdGpvaW50Lm1hdHJpeC5mcm9tQXJyYXkoIGpvaW50UG9zZS50cmFuc2Zvcm0ubWF0cml4ICk7XG5cdFx0XHRcdFx0XHRqb2ludC5tYXRyaXguZGVjb21wb3NlKCBqb2ludC5wb3NpdGlvbiwgam9pbnQucm90YXRpb24sIGpvaW50LnNjYWxlICk7XG5cdFx0XHRcdFx0XHRqb2ludC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGpvaW50LmpvaW50UmFkaXVzID0gam9pbnRQb3NlLnJhZGl1cztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGpvaW50LnZpc2libGUgPSBqb2ludFBvc2UgIT09IG51bGw7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEN1c3RvbSBldmVudHNcblxuXHRcdFx0XHQvLyBDaGVjayBwaW5jaHpcblx0XHRcdFx0Y29uc3QgaW5kZXhUaXAgPSBoYW5kLmpvaW50c1sgJ2luZGV4LWZpbmdlci10aXAnIF07XG5cdFx0XHRcdGNvbnN0IHRodW1iVGlwID0gaGFuZC5qb2ludHNbICd0aHVtYi10aXAnIF07XG5cdFx0XHRcdGNvbnN0IGRpc3RhbmNlID0gaW5kZXhUaXAucG9zaXRpb24uZGlzdGFuY2VUbyggdGh1bWJUaXAucG9zaXRpb24gKTtcblxuXHRcdFx0XHRjb25zdCBkaXN0YW5jZVRvUGluY2ggPSAwLjAyO1xuXHRcdFx0XHRjb25zdCB0aHJlc2hvbGQgPSAwLjAwNTtcblxuXHRcdFx0XHRpZiAoIGhhbmQuaW5wdXRTdGF0ZS5waW5jaGluZyAmJiBkaXN0YW5jZSA+IGRpc3RhbmNlVG9QaW5jaCArIHRocmVzaG9sZCApIHtcblxuXHRcdFx0XHRcdGhhbmQuaW5wdXRTdGF0ZS5waW5jaGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudCgge1xuXHRcdFx0XHRcdFx0dHlwZTogJ3BpbmNoZW5kJyxcblx0XHRcdFx0XHRcdGhhbmRlZG5lc3M6IGlucHV0U291cmNlLmhhbmRlZG5lc3MsXG5cdFx0XHRcdFx0XHR0YXJnZXQ6IHRoaXNcblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggISBoYW5kLmlucHV0U3RhdGUucGluY2hpbmcgJiYgZGlzdGFuY2UgPD0gZGlzdGFuY2VUb1BpbmNoIC0gdGhyZXNob2xkICkge1xuXG5cdFx0XHRcdFx0aGFuZC5pbnB1dFN0YXRlLnBpbmNoaW5nID0gdHJ1ZTtcblx0XHRcdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHtcblx0XHRcdFx0XHRcdHR5cGU6ICdwaW5jaHN0YXJ0Jyxcblx0XHRcdFx0XHRcdGhhbmRlZG5lc3M6IGlucHV0U291cmNlLmhhbmRlZG5lc3MsXG5cdFx0XHRcdFx0XHR0YXJnZXQ6IHRoaXNcblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggZ3JpcCAhPT0gbnVsbCAmJiBpbnB1dFNvdXJjZS5ncmlwU3BhY2UgKSB7XG5cblx0XHRcdFx0XHRncmlwUG9zZSA9IGZyYW1lLmdldFBvc2UoIGlucHV0U291cmNlLmdyaXBTcGFjZSwgcmVmZXJlbmNlU3BhY2UgKTtcblxuXHRcdFx0XHRcdGlmICggZ3JpcFBvc2UgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdGdyaXAubWF0cml4LmZyb21BcnJheSggZ3JpcFBvc2UudHJhbnNmb3JtLm1hdHJpeCApO1xuXHRcdFx0XHRcdFx0Z3JpcC5tYXRyaXguZGVjb21wb3NlKCBncmlwLnBvc2l0aW9uLCBncmlwLnJvdGF0aW9uLCBncmlwLnNjYWxlICk7XG5cdFx0XHRcdFx0XHRncmlwLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGdyaXBQb3NlLmxpbmVhclZlbG9jaXR5ICkge1xuXG5cdFx0XHRcdFx0XHRcdGdyaXAuaGFzTGluZWFyVmVsb2NpdHkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRncmlwLmxpbmVhclZlbG9jaXR5LmNvcHkoIGdyaXBQb3NlLmxpbmVhclZlbG9jaXR5ICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Z3JpcC5oYXNMaW5lYXJWZWxvY2l0eSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICggZ3JpcFBvc2UuYW5ndWxhclZlbG9jaXR5ICkge1xuXG5cdFx0XHRcdFx0XHRcdGdyaXAuaGFzQW5ndWxhclZlbG9jaXR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0Z3JpcC5hbmd1bGFyVmVsb2NpdHkuY29weSggZ3JpcFBvc2UuYW5ndWxhclZlbG9jaXR5ICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Z3JpcC5oYXNBbmd1bGFyVmVsb2NpdHkgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRhcmdldFJheSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRpbnB1dFBvc2UgPSBmcmFtZS5nZXRQb3NlKCBpbnB1dFNvdXJjZS50YXJnZXRSYXlTcGFjZSwgcmVmZXJlbmNlU3BhY2UgKTtcblxuXHRcdFx0XHQvLyBTb21lIHJ1bnRpbWVzIChuYW1lbHkgVml2ZSBDb3Ntb3Mgd2l0aCBWaXZlIE9wZW5YUiBSdW50aW1lKSBoYXZlIG9ubHkgZ3JpcCBzcGFjZSBhbmQgcmF5IHNwYWNlIGlzIGVxdWFsIHRvIGl0XG5cdFx0XHRcdGlmICggaW5wdXRQb3NlID09PSBudWxsICYmIGdyaXBQb3NlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0aW5wdXRQb3NlID0gZ3JpcFBvc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaW5wdXRQb3NlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0dGFyZ2V0UmF5Lm1hdHJpeC5mcm9tQXJyYXkoIGlucHV0UG9zZS50cmFuc2Zvcm0ubWF0cml4ICk7XG5cdFx0XHRcdFx0dGFyZ2V0UmF5Lm1hdHJpeC5kZWNvbXBvc2UoIHRhcmdldFJheS5wb3NpdGlvbiwgdGFyZ2V0UmF5LnJvdGF0aW9uLCB0YXJnZXRSYXkuc2NhbGUgKTtcblx0XHRcdFx0XHR0YXJnZXRSYXkubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRpZiAoIGlucHV0UG9zZS5saW5lYXJWZWxvY2l0eSApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0UmF5Lmhhc0xpbmVhclZlbG9jaXR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHRhcmdldFJheS5saW5lYXJWZWxvY2l0eS5jb3B5KCBpbnB1dFBvc2UubGluZWFyVmVsb2NpdHkgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRhcmdldFJheS5oYXNMaW5lYXJWZWxvY2l0eSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBpbnB1dFBvc2UuYW5ndWxhclZlbG9jaXR5ICkge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXRSYXkuaGFzQW5ndWxhclZlbG9jaXR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHRhcmdldFJheS5hbmd1bGFyVmVsb2NpdHkuY29weSggaW5wdXRQb3NlLmFuZ3VsYXJWZWxvY2l0eSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0UmF5Lmhhc0FuZ3VsYXJWZWxvY2l0eSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCBfbW92ZUV2ZW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdH1cblxuXHRcdGlmICggdGFyZ2V0UmF5ICE9PSBudWxsICkge1xuXG5cdFx0XHR0YXJnZXRSYXkudmlzaWJsZSA9ICggaW5wdXRQb3NlICE9PSBudWxsICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGdyaXAgIT09IG51bGwgKSB7XG5cblx0XHRcdGdyaXAudmlzaWJsZSA9ICggZ3JpcFBvc2UgIT09IG51bGwgKTtcblxuXHRcdH1cblxuXHRcdGlmICggaGFuZCAhPT0gbnVsbCApIHtcblxuXHRcdFx0aGFuZC52aXNpYmxlID0gKCBoYW5kUG9zZSAhPT0gbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vIHByaXZhdGUgbWV0aG9kXG5cblx0X2dldEhhbmRKb2ludCggaGFuZCwgaW5wdXRqb2ludCApIHtcblxuXHRcdGlmICggaGFuZC5qb2ludHNbIGlucHV0am9pbnQuam9pbnROYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3Qgam9pbnQgPSBuZXcgR3JvdXAoKTtcblx0XHRcdGpvaW50Lm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHRcdGpvaW50LnZpc2libGUgPSBmYWxzZTtcblx0XHRcdGhhbmQuam9pbnRzWyBpbnB1dGpvaW50LmpvaW50TmFtZSBdID0gam9pbnQ7XG5cblx0XHRcdGhhbmQuYWRkKCBqb2ludCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmQuam9pbnRzWyBpbnB1dGpvaW50LmpvaW50TmFtZSBdO1xuXG5cdH1cblxufVxuXG5jb25zdCBfb2NjbHVzaW9uX3ZlcnRleCA9IGBcbnZvaWQgbWFpbigpIHtcblxuXHRnbF9Qb3NpdGlvbiA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcblxufWA7XG5cbmNvbnN0IF9vY2NsdXNpb25fZnJhZ21lbnQgPSBgXG51bmlmb3JtIHNhbXBsZXIyREFycmF5IGRlcHRoQ29sb3I7XG51bmlmb3JtIGZsb2F0IGRlcHRoV2lkdGg7XG51bmlmb3JtIGZsb2F0IGRlcHRoSGVpZ2h0O1xuXG52b2lkIG1haW4oKSB7XG5cblx0dmVjMiBjb29yZCA9IHZlYzIoIGdsX0ZyYWdDb29yZC54IC8gZGVwdGhXaWR0aCwgZ2xfRnJhZ0Nvb3JkLnkgLyBkZXB0aEhlaWdodCApO1xuXG5cdGlmICggY29vcmQueCA+PSAxLjAgKSB7XG5cblx0XHRnbF9GcmFnRGVwdGggPSB0ZXh0dXJlKCBkZXB0aENvbG9yLCB2ZWMzKCBjb29yZC54IC0gMS4wLCBjb29yZC55LCAxICkgKS5yO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRnbF9GcmFnRGVwdGggPSB0ZXh0dXJlKCBkZXB0aENvbG9yLCB2ZWMzKCBjb29yZC54LCBjb29yZC55LCAwICkgKS5yO1xuXG5cdH1cblxufWA7XG5cbmNsYXNzIFdlYlhSRGVwdGhTZW5zaW5nIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMudGV4dHVyZSA9IG51bGw7XG5cdFx0dGhpcy5tZXNoID0gbnVsbDtcblxuXHRcdHRoaXMuZGVwdGhOZWFyID0gMDtcblx0XHR0aGlzLmRlcHRoRmFyID0gMDtcblxuXHR9XG5cblx0aW5pdCggcmVuZGVyZXIsIGRlcHRoRGF0YSwgcmVuZGVyU3RhdGUgKSB7XG5cblx0XHRpZiAoIHRoaXMudGV4dHVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XG5cblx0XHRcdGNvbnN0IHRleFByb3BzID0gcmVuZGVyZXIucHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcblx0XHRcdHRleFByb3BzLl9fd2ViZ2xUZXh0dXJlID0gZGVwdGhEYXRhLnRleHR1cmU7XG5cblx0XHRcdGlmICggKCBkZXB0aERhdGEuZGVwdGhOZWFyICE9PSByZW5kZXJTdGF0ZS5kZXB0aE5lYXIgKSB8fCAoIGRlcHRoRGF0YS5kZXB0aEZhciAhPT0gcmVuZGVyU3RhdGUuZGVwdGhGYXIgKSApIHtcblxuXHRcdFx0XHR0aGlzLmRlcHRoTmVhciA9IGRlcHRoRGF0YS5kZXB0aE5lYXI7XG5cdFx0XHRcdHRoaXMuZGVwdGhGYXIgPSBkZXB0aERhdGEuZGVwdGhGYXI7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcblxuXHRcdH1cblxuXHR9XG5cblx0Z2V0TWVzaCggY2FtZXJhWFIgKSB7XG5cblx0XHRpZiAoIHRoaXMudGV4dHVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCB0aGlzLm1lc2ggPT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc3Qgdmlld3BvcnQgPSBjYW1lcmFYUi5jYW1lcmFzWyAwIF0udmlld3BvcnQ7XG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IFNoYWRlck1hdGVyaWFsKCB7XG5cdFx0XHRcdFx0dmVydGV4U2hhZGVyOiBfb2NjbHVzaW9uX3ZlcnRleCxcblx0XHRcdFx0XHRmcmFnbWVudFNoYWRlcjogX29jY2x1c2lvbl9mcmFnbWVudCxcblx0XHRcdFx0XHR1bmlmb3Jtczoge1xuXHRcdFx0XHRcdFx0ZGVwdGhDb2xvcjogeyB2YWx1ZTogdGhpcy50ZXh0dXJlIH0sXG5cdFx0XHRcdFx0XHRkZXB0aFdpZHRoOiB7IHZhbHVlOiB2aWV3cG9ydC56IH0sXG5cdFx0XHRcdFx0XHRkZXB0aEhlaWdodDogeyB2YWx1ZTogdmlld3BvcnQudyB9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0dGhpcy5tZXNoID0gbmV3IE1lc2goIG5ldyBQbGFuZUdlb21ldHJ5KCAyMCwgMjAgKSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubWVzaDtcblxuXHR9XG5cblx0cmVzZXQoKSB7XG5cblx0XHR0aGlzLnRleHR1cmUgPSBudWxsO1xuXHRcdHRoaXMubWVzaCA9IG51bGw7XG5cblx0fVxuXG5cdGdldERlcHRoVGV4dHVyZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnRleHR1cmU7XG5cblx0fVxuXG59XG5cbmNsYXNzIFdlYlhSTWFuYWdlciBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IoIHJlbmRlcmVyLCBnbCApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRsZXQgc2Vzc2lvbiA9IG51bGw7XG5cblx0XHRsZXQgZnJhbWVidWZmZXJTY2FsZUZhY3RvciA9IDEuMDtcblxuXHRcdGxldCByZWZlcmVuY2VTcGFjZSA9IG51bGw7XG5cdFx0bGV0IHJlZmVyZW5jZVNwYWNlVHlwZSA9ICdsb2NhbC1mbG9vcic7XG5cdFx0Ly8gU2V0IGRlZmF1bHQgZm92ZWF0aW9uIHRvIG1heGltdW0uXG5cdFx0bGV0IGZvdmVhdGlvbiA9IDEuMDtcblx0XHRsZXQgY3VzdG9tUmVmZXJlbmNlU3BhY2UgPSBudWxsO1xuXG5cdFx0bGV0IHBvc2UgPSBudWxsO1xuXHRcdGxldCBnbEJpbmRpbmcgPSBudWxsO1xuXHRcdGxldCBnbFByb2pMYXllciA9IG51bGw7XG5cdFx0bGV0IGdsQmFzZUxheWVyID0gbnVsbDtcblx0XHRsZXQgeHJGcmFtZSA9IG51bGw7XG5cblx0XHRjb25zdCBkZXB0aFNlbnNpbmcgPSBuZXcgV2ViWFJEZXB0aFNlbnNpbmcoKTtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKTtcblxuXHRcdGxldCBpbml0aWFsUmVuZGVyVGFyZ2V0ID0gbnVsbDtcblx0XHRsZXQgbmV3UmVuZGVyVGFyZ2V0ID0gbnVsbDtcblxuXHRcdGNvbnN0IGNvbnRyb2xsZXJzID0gW107XG5cdFx0Y29uc3QgY29udHJvbGxlcklucHV0U291cmNlcyA9IFtdO1xuXG5cdFx0Y29uc3QgY3VycmVudFNpemUgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGxldCBjdXJyZW50UGl4ZWxSYXRpbyA9IG51bGw7XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgY2FtZXJhTCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xuXHRcdGNhbWVyYUwudmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpO1xuXG5cdFx0Y29uc3QgY2FtZXJhUiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xuXHRcdGNhbWVyYVIudmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpO1xuXG5cdFx0Y29uc3QgY2FtZXJhcyA9IFsgY2FtZXJhTCwgY2FtZXJhUiBdO1xuXG5cdFx0Y29uc3QgY2FtZXJhWFIgPSBuZXcgQXJyYXlDYW1lcmEoKTtcblxuXHRcdGxldCBfY3VycmVudERlcHRoTmVhciA9IG51bGw7XG5cdFx0bGV0IF9jdXJyZW50RGVwdGhGYXIgPSBudWxsO1xuXG5cdFx0Ly9cblxuXHRcdHRoaXMuY2FtZXJhQXV0b1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XG5cblx0XHR0aGlzLmlzUHJlc2VudGluZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdFx0bGV0IGNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1sgaW5kZXggXTtcblxuXHRcdFx0aWYgKCBjb250cm9sbGVyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29udHJvbGxlciA9IG5ldyBXZWJYUkNvbnRyb2xsZXIoKTtcblx0XHRcdFx0Y29udHJvbGxlcnNbIGluZGV4IF0gPSBjb250cm9sbGVyO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb250cm9sbGVyLmdldFRhcmdldFJheVNwYWNlKCk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRDb250cm9sbGVyR3JpcCA9IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRcdGxldCBjb250cm9sbGVyID0gY29udHJvbGxlcnNbIGluZGV4IF07XG5cblx0XHRcdGlmICggY29udHJvbGxlciA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnRyb2xsZXIgPSBuZXcgV2ViWFJDb250cm9sbGVyKCk7XG5cdFx0XHRcdGNvbnRyb2xsZXJzWyBpbmRleCBdID0gY29udHJvbGxlcjtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY29udHJvbGxlci5nZXRHcmlwU3BhY2UoKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldEhhbmQgPSBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0XHRsZXQgY29udHJvbGxlciA9IGNvbnRyb2xsZXJzWyBpbmRleCBdO1xuXG5cdFx0XHRpZiAoIGNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb250cm9sbGVyID0gbmV3IFdlYlhSQ29udHJvbGxlcigpO1xuXHRcdFx0XHRjb250cm9sbGVyc1sgaW5kZXggXSA9IGNvbnRyb2xsZXI7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNvbnRyb2xsZXIuZ2V0SGFuZFNwYWNlKCk7XG5cblx0XHR9O1xuXG5cdFx0Ly9cblxuXHRcdGZ1bmN0aW9uIG9uU2Vzc2lvbkV2ZW50KCBldmVudCApIHtcblxuXHRcdFx0Y29uc3QgY29udHJvbGxlckluZGV4ID0gY29udHJvbGxlcklucHV0U291cmNlcy5pbmRleE9mKCBldmVudC5pbnB1dFNvdXJjZSApO1xuXG5cdFx0XHRpZiAoIGNvbnRyb2xsZXJJbmRleCA9PT0gLSAxICkge1xuXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjb250cm9sbGVyID0gY29udHJvbGxlcnNbIGNvbnRyb2xsZXJJbmRleCBdO1xuXG5cdFx0XHRpZiAoIGNvbnRyb2xsZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb250cm9sbGVyLnVwZGF0ZSggZXZlbnQuaW5wdXRTb3VyY2UsIGV2ZW50LmZyYW1lLCBjdXN0b21SZWZlcmVuY2VTcGFjZSB8fCByZWZlcmVuY2VTcGFjZSApO1xuXHRcdFx0XHRjb250cm9sbGVyLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogZXZlbnQudHlwZSwgZGF0YTogZXZlbnQuaW5wdXRTb3VyY2UgfSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblNlc3Npb25FbmQoKSB7XG5cblx0XHRcdHNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3NlbGVjdCcsIG9uU2Vzc2lvbkV2ZW50ICk7XG5cdFx0XHRzZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdzZWxlY3RzdGFydCcsIG9uU2Vzc2lvbkV2ZW50ICk7XG5cdFx0XHRzZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdzZWxlY3RlbmQnLCBvblNlc3Npb25FdmVudCApO1xuXHRcdFx0c2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKCAnc3F1ZWV6ZScsIG9uU2Vzc2lvbkV2ZW50ICk7XG5cdFx0XHRzZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdzcXVlZXplc3RhcnQnLCBvblNlc3Npb25FdmVudCApO1xuXHRcdFx0c2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKCAnc3F1ZWV6ZWVuZCcsIG9uU2Vzc2lvbkV2ZW50ICk7XG5cdFx0XHRzZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdlbmQnLCBvblNlc3Npb25FbmQgKTtcblx0XHRcdHNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2lucHV0c291cmNlc2NoYW5nZScsIG9uSW5wdXRTb3VyY2VzQ2hhbmdlICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNvbnRyb2xsZXJzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbnB1dFNvdXJjZSA9IGNvbnRyb2xsZXJJbnB1dFNvdXJjZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGlucHV0U291cmNlID09PSBudWxsICkgY29udGludWU7XG5cblx0XHRcdFx0Y29udHJvbGxlcklucHV0U291cmNlc1sgaSBdID0gbnVsbDtcblxuXHRcdFx0XHRjb250cm9sbGVyc1sgaSBdLmRpc2Nvbm5lY3QoIGlucHV0U291cmNlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X2N1cnJlbnREZXB0aE5lYXIgPSBudWxsO1xuXHRcdFx0X2N1cnJlbnREZXB0aEZhciA9IG51bGw7XG5cblx0XHRcdGRlcHRoU2Vuc2luZy5yZXNldCgpO1xuXG5cdFx0XHQvLyByZXN0b3JlIGZyYW1lYnVmZmVyL3JlbmRlcmluZyBzdGF0ZVxuXG5cdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIGluaXRpYWxSZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0Z2xCYXNlTGF5ZXIgPSBudWxsO1xuXHRcdFx0Z2xQcm9qTGF5ZXIgPSBudWxsO1xuXHRcdFx0Z2xCaW5kaW5nID0gbnVsbDtcblx0XHRcdHNlc3Npb24gPSBudWxsO1xuXHRcdFx0bmV3UmVuZGVyVGFyZ2V0ID0gbnVsbDtcblxuXHRcdFx0Ly9cblxuXHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcblxuXHRcdFx0c2NvcGUuaXNQcmVzZW50aW5nID0gZmFsc2U7XG5cblx0XHRcdHJlbmRlcmVyLnNldFBpeGVsUmF0aW8oIGN1cnJlbnRQaXhlbFJhdGlvICk7XG5cdFx0XHRyZW5kZXJlci5zZXRTaXplKCBjdXJyZW50U2l6ZS53aWR0aCwgY3VycmVudFNpemUuaGVpZ2h0LCBmYWxzZSApO1xuXG5cdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdzZXNzaW9uZW5kJyB9ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnNldEZyYW1lYnVmZmVyU2NhbGVGYWN0b3IgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRmcmFtZWJ1ZmZlclNjYWxlRmFjdG9yID0gdmFsdWU7XG5cblx0XHRcdGlmICggc2NvcGUuaXNQcmVzZW50aW5nID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYlhSTWFuYWdlcjogQ2Fubm90IGNoYW5nZSBmcmFtZWJ1ZmZlciBzY2FsZSB3aGlsZSBwcmVzZW50aW5nLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0UmVmZXJlbmNlU3BhY2VUeXBlID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0cmVmZXJlbmNlU3BhY2VUeXBlID0gdmFsdWU7XG5cblx0XHRcdGlmICggc2NvcGUuaXNQcmVzZW50aW5nID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYlhSTWFuYWdlcjogQ2Fubm90IGNoYW5nZSByZWZlcmVuY2Ugc3BhY2UgdHlwZSB3aGlsZSBwcmVzZW50aW5nLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0UmVmZXJlbmNlU3BhY2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBjdXN0b21SZWZlcmVuY2VTcGFjZSB8fCByZWZlcmVuY2VTcGFjZTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNldFJlZmVyZW5jZVNwYWNlID0gZnVuY3Rpb24gKCBzcGFjZSApIHtcblxuXHRcdFx0Y3VzdG9tUmVmZXJlbmNlU3BhY2UgPSBzcGFjZTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldEJhc2VMYXllciA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIGdsUHJvakxheWVyICE9PSBudWxsID8gZ2xQcm9qTGF5ZXIgOiBnbEJhc2VMYXllcjtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldEJpbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBnbEJpbmRpbmc7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRGcmFtZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHhyRnJhbWU7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRTZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gc2Vzc2lvbjtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNldFNlc3Npb24gPSBhc3luYyBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRzZXNzaW9uID0gdmFsdWU7XG5cblx0XHRcdGlmICggc2Vzc2lvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRpbml0aWFsUmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cblx0XHRcdFx0c2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCAnc2VsZWN0Jywgb25TZXNzaW9uRXZlbnQgKTtcblx0XHRcdFx0c2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCAnc2VsZWN0c3RhcnQnLCBvblNlc3Npb25FdmVudCApO1xuXHRcdFx0XHRzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoICdzZWxlY3RlbmQnLCBvblNlc3Npb25FdmVudCApO1xuXHRcdFx0XHRzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoICdzcXVlZXplJywgb25TZXNzaW9uRXZlbnQgKTtcblx0XHRcdFx0c2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCAnc3F1ZWV6ZXN0YXJ0Jywgb25TZXNzaW9uRXZlbnQgKTtcblx0XHRcdFx0c2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCAnc3F1ZWV6ZWVuZCcsIG9uU2Vzc2lvbkV2ZW50ICk7XG5cdFx0XHRcdHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lciggJ2VuZCcsIG9uU2Vzc2lvbkVuZCApO1xuXHRcdFx0XHRzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoICdpbnB1dHNvdXJjZXNjaGFuZ2UnLCBvbklucHV0U291cmNlc0NoYW5nZSApO1xuXG5cdFx0XHRcdGlmICggYXR0cmlidXRlcy54ckNvbXBhdGlibGUgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRhd2FpdCBnbC5tYWtlWFJDb21wYXRpYmxlKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN1cnJlbnRQaXhlbFJhdGlvID0gcmVuZGVyZXIuZ2V0UGl4ZWxSYXRpbygpO1xuXHRcdFx0XHRyZW5kZXJlci5nZXRTaXplKCBjdXJyZW50U2l6ZSApO1xuXG5cdFx0XHRcdGNvbnN0IHVzZUxheWVycyA9IHNlc3Npb24uZW5hYmxlZEZlYXR1cmVzICE9PSB1bmRlZmluZWQgJiYgc2Vzc2lvbi5lbmFibGVkRmVhdHVyZXMuaW5jbHVkZXMoICdsYXllcnMnICk7XG5cblx0XHRcdFx0aWYgKCAhIHVzZUxheWVycyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGxheWVySW5pdCA9IHtcblx0XHRcdFx0XHRcdGFudGlhbGlhczogYXR0cmlidXRlcy5hbnRpYWxpYXMsXG5cdFx0XHRcdFx0XHRhbHBoYTogdHJ1ZSxcblx0XHRcdFx0XHRcdGRlcHRoOiBhdHRyaWJ1dGVzLmRlcHRoLFxuXHRcdFx0XHRcdFx0c3RlbmNpbDogYXR0cmlidXRlcy5zdGVuY2lsLFxuXHRcdFx0XHRcdFx0ZnJhbWVidWZmZXJTY2FsZUZhY3RvcjogZnJhbWVidWZmZXJTY2FsZUZhY3RvclxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRnbEJhc2VMYXllciA9IG5ldyBYUldlYkdMTGF5ZXIoIHNlc3Npb24sIGdsLCBsYXllckluaXQgKTtcblxuXHRcdFx0XHRcdHNlc3Npb24udXBkYXRlUmVuZGVyU3RhdGUoIHsgYmFzZUxheWVyOiBnbEJhc2VMYXllciB9ICk7XG5cblx0XHRcdFx0XHRyZW5kZXJlci5zZXRQaXhlbFJhdGlvKCAxICk7XG5cdFx0XHRcdFx0cmVuZGVyZXIuc2V0U2l6ZSggZ2xCYXNlTGF5ZXIuZnJhbWVidWZmZXJXaWR0aCwgZ2xCYXNlTGF5ZXIuZnJhbWVidWZmZXJIZWlnaHQsIGZhbHNlICk7XG5cblx0XHRcdFx0XHRuZXdSZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQoXG5cdFx0XHRcdFx0XHRnbEJhc2VMYXllci5mcmFtZWJ1ZmZlcldpZHRoLFxuXHRcdFx0XHRcdFx0Z2xCYXNlTGF5ZXIuZnJhbWVidWZmZXJIZWlnaHQsXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGZvcm1hdDogUkdCQUZvcm1hdCxcblx0XHRcdFx0XHRcdFx0dHlwZTogVW5zaWduZWRCeXRlVHlwZSxcblx0XHRcdFx0XHRcdFx0Y29sb3JTcGFjZTogcmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZSxcblx0XHRcdFx0XHRcdFx0c3RlbmNpbEJ1ZmZlcjogYXR0cmlidXRlcy5zdGVuY2lsXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0bGV0IGRlcHRoRm9ybWF0ID0gbnVsbDtcblx0XHRcdFx0XHRsZXQgZGVwdGhUeXBlID0gbnVsbDtcblx0XHRcdFx0XHRsZXQgZ2xEZXB0aEZvcm1hdCA9IG51bGw7XG5cblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMuZGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdGdsRGVwdGhGb3JtYXQgPSBhdHRyaWJ1dGVzLnN0ZW5jaWwgPyBnbC5ERVBUSDI0X1NURU5DSUw4IDogZ2wuREVQVEhfQ09NUE9ORU5UMjQ7XG5cdFx0XHRcdFx0XHRkZXB0aEZvcm1hdCA9IGF0dHJpYnV0ZXMuc3RlbmNpbCA/IERlcHRoU3RlbmNpbEZvcm1hdCA6IERlcHRoRm9ybWF0O1xuXHRcdFx0XHRcdFx0ZGVwdGhUeXBlID0gYXR0cmlidXRlcy5zdGVuY2lsID8gVW5zaWduZWRJbnQyNDhUeXBlIDogVW5zaWduZWRJbnRUeXBlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3QgcHJvamVjdGlvbmxheWVySW5pdCA9IHtcblx0XHRcdFx0XHRcdGNvbG9yRm9ybWF0OiBnbC5SR0JBOCxcblx0XHRcdFx0XHRcdGRlcHRoRm9ybWF0OiBnbERlcHRoRm9ybWF0LFxuXHRcdFx0XHRcdFx0c2NhbGVGYWN0b3I6IGZyYW1lYnVmZmVyU2NhbGVGYWN0b3Jcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Z2xCaW5kaW5nID0gbmV3IFhSV2ViR0xCaW5kaW5nKCBzZXNzaW9uLCBnbCApO1xuXG5cdFx0XHRcdFx0Z2xQcm9qTGF5ZXIgPSBnbEJpbmRpbmcuY3JlYXRlUHJvamVjdGlvbkxheWVyKCBwcm9qZWN0aW9ubGF5ZXJJbml0ICk7XG5cblx0XHRcdFx0XHRzZXNzaW9uLnVwZGF0ZVJlbmRlclN0YXRlKCB7IGxheWVyczogWyBnbFByb2pMYXllciBdIH0gKTtcblxuXHRcdFx0XHRcdHJlbmRlcmVyLnNldFBpeGVsUmF0aW8oIDEgKTtcblx0XHRcdFx0XHRyZW5kZXJlci5zZXRTaXplKCBnbFByb2pMYXllci50ZXh0dXJlV2lkdGgsIGdsUHJvakxheWVyLnRleHR1cmVIZWlnaHQsIGZhbHNlICk7XG5cblx0XHRcdFx0XHRuZXdSZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQoXG5cdFx0XHRcdFx0XHRnbFByb2pMYXllci50ZXh0dXJlV2lkdGgsXG5cdFx0XHRcdFx0XHRnbFByb2pMYXllci50ZXh0dXJlSGVpZ2h0LFxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRmb3JtYXQ6IFJHQkFGb3JtYXQsXG5cdFx0XHRcdFx0XHRcdHR5cGU6IFVuc2lnbmVkQnl0ZVR5cGUsXG5cdFx0XHRcdFx0XHRcdGRlcHRoVGV4dHVyZTogbmV3IERlcHRoVGV4dHVyZSggZ2xQcm9qTGF5ZXIudGV4dHVyZVdpZHRoLCBnbFByb2pMYXllci50ZXh0dXJlSGVpZ2h0LCBkZXB0aFR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlcHRoRm9ybWF0ICksXG5cdFx0XHRcdFx0XHRcdHN0ZW5jaWxCdWZmZXI6IGF0dHJpYnV0ZXMuc3RlbmNpbCxcblx0XHRcdFx0XHRcdFx0Y29sb3JTcGFjZTogcmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZSxcblx0XHRcdFx0XHRcdFx0c2FtcGxlczogYXR0cmlidXRlcy5hbnRpYWxpYXMgPyA0IDogMCxcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZURlcHRoQnVmZmVyOiAoIGdsUHJvakxheWVyLmlnbm9yZURlcHRoVmFsdWVzID09PSBmYWxzZSApXG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG5ld1JlbmRlclRhcmdldC5pc1hSUmVuZGVyVGFyZ2V0ID0gdHJ1ZTsgLy8gVE9ETyBSZW1vdmUgdGhpcyB3aGVuIHBvc3NpYmxlLCBzZWUgIzIzMjc4XG5cblx0XHRcdFx0dGhpcy5zZXRGb3ZlYXRpb24oIGZvdmVhdGlvbiApO1xuXG5cdFx0XHRcdGN1c3RvbVJlZmVyZW5jZVNwYWNlID0gbnVsbDtcblx0XHRcdFx0cmVmZXJlbmNlU3BhY2UgPSBhd2FpdCBzZXNzaW9uLnJlcXVlc3RSZWZlcmVuY2VTcGFjZSggcmVmZXJlbmNlU3BhY2VUeXBlICk7XG5cblx0XHRcdFx0YW5pbWF0aW9uLnNldENvbnRleHQoIHNlc3Npb24gKTtcblx0XHRcdFx0YW5pbWF0aW9uLnN0YXJ0KCk7XG5cblx0XHRcdFx0c2NvcGUuaXNQcmVzZW50aW5nID0gdHJ1ZTtcblxuXHRcdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdzZXNzaW9uc3RhcnQnIH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0RW52aXJvbm1lbnRCbGVuZE1vZGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGlmICggc2Vzc2lvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRyZXR1cm4gc2Vzc2lvbi5lbnZpcm9ubWVudEJsZW5kTW9kZTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0RGVwdGhUZXh0dXJlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gZGVwdGhTZW5zaW5nLmdldERlcHRoVGV4dHVyZSgpO1xuXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIG9uSW5wdXRTb3VyY2VzQ2hhbmdlKCBldmVudCApIHtcblxuXHRcdFx0Ly8gTm90aWZ5IGRpc2Nvbm5lY3RlZFxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBldmVudC5yZW1vdmVkLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbnB1dFNvdXJjZSA9IGV2ZW50LnJlbW92ZWRbIGkgXTtcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBjb250cm9sbGVySW5wdXRTb3VyY2VzLmluZGV4T2YoIGlucHV0U291cmNlICk7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA+PSAwICkge1xuXG5cdFx0XHRcdFx0Y29udHJvbGxlcklucHV0U291cmNlc1sgaW5kZXggXSA9IG51bGw7XG5cdFx0XHRcdFx0Y29udHJvbGxlcnNbIGluZGV4IF0uZGlzY29ubmVjdCggaW5wdXRTb3VyY2UgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gTm90aWZ5IGNvbm5lY3RlZFxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBldmVudC5hZGRlZC5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW5wdXRTb3VyY2UgPSBldmVudC5hZGRlZFsgaSBdO1xuXG5cdFx0XHRcdGxldCBjb250cm9sbGVySW5kZXggPSBjb250cm9sbGVySW5wdXRTb3VyY2VzLmluZGV4T2YoIGlucHV0U291cmNlICk7XG5cblx0XHRcdFx0aWYgKCBjb250cm9sbGVySW5kZXggPT09IC0gMSApIHtcblxuXHRcdFx0XHRcdC8vIEFzc2lnbiBpbnB1dCBzb3VyY2UgYSBjb250cm9sbGVyIHRoYXQgY3VycmVudGx5IGhhcyBubyBpbnB1dCBzb3VyY2VcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNvbnRyb2xsZXJzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBpID49IGNvbnRyb2xsZXJJbnB1dFNvdXJjZXMubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2xsZXJJbnB1dFNvdXJjZXMucHVzaCggaW5wdXRTb3VyY2UgKTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbGxlckluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRyb2xsZXJJbnB1dFNvdXJjZXNbIGkgXSA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRjb250cm9sbGVySW5wdXRTb3VyY2VzWyBpIF0gPSBpbnB1dFNvdXJjZTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbGxlckluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIElmIGFsbCBjb250cm9sbGVycyBkbyBjdXJyZW50bHkgcmVjZWl2ZSBpbnB1dCB3ZSBpZ25vcmUgbmV3IG9uZXNcblxuXHRcdFx0XHRcdGlmICggY29udHJvbGxlckluZGV4ID09PSAtIDEgKSBicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgY29udHJvbGxlciA9IGNvbnRyb2xsZXJzWyBjb250cm9sbGVySW5kZXggXTtcblxuXHRcdFx0XHRpZiAoIGNvbnRyb2xsZXIgKSB7XG5cblx0XHRcdFx0XHRjb250cm9sbGVyLmNvbm5lY3QoIGlucHV0U291cmNlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgY2FtZXJhTFBvcyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgY2FtZXJhUlBvcyA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHQvKipcblx0XHQgKiBBc3N1bWVzIDIgY2FtZXJhcyB0aGF0IGFyZSBwYXJhbGxlbCBhbmQgc2hhcmUgYW4gWC1heGlzLCBhbmQgdGhhdFxuXHRcdCAqIHRoZSBjYW1lcmFzJyBwcm9qZWN0aW9uIGFuZCB3b3JsZCBtYXRyaWNlcyBoYXZlIGFscmVhZHkgYmVlbiBzZXQuXG5cdFx0ICogQW5kIHRoYXQgbmVhciBhbmQgZmFyIHBsYW5lcyBhcmUgaWRlbnRpY2FsIGZvciBib3RoIGNhbWVyYXMuXG5cdFx0ICogVmlzdWFsaXphdGlvbiBvZiB0aGlzIHRlY2huaXF1ZTogaHR0cHM6Ly9jb21wdXRlcmdyYXBoaWNzLnN0YWNrZXhjaGFuZ2UuY29tL2EvNDc2NVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtBcnJheUNhbWVyYX0gY2FtZXJhIC0gVGhlIGNhbWVyYSB0byB1cGRhdGUuXG5cdFx0ICogQHBhcmFtIHtQZXJzcGVjdGl2ZUNhbWVyYX0gY2FtZXJhTCAtIFRoZSBsZWZ0IGNhbWVyYS5cblx0XHQgKiBAcGFyYW0ge1BlcnNwZWN0aXZlQ2FtZXJhfSBjYW1lcmFSIC0gVGhlIHJpZ2h0IGNhbWVyYS5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBzZXRQcm9qZWN0aW9uRnJvbVVuaW9uKCBjYW1lcmEsIGNhbWVyYUwsIGNhbWVyYVIgKSB7XG5cblx0XHRcdGNhbWVyYUxQb3Muc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmFMLm1hdHJpeFdvcmxkICk7XG5cdFx0XHRjYW1lcmFSUG9zLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhUi5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRjb25zdCBpcGQgPSBjYW1lcmFMUG9zLmRpc3RhbmNlVG8oIGNhbWVyYVJQb3MgKTtcblxuXHRcdFx0Y29uc3QgcHJvakwgPSBjYW1lcmFMLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHM7XG5cdFx0XHRjb25zdCBwcm9qUiA9IGNhbWVyYVIucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cztcblxuXHRcdFx0Ly8gVlIgc3lzdGVtcyB3aWxsIGhhdmUgaWRlbnRpY2FsIGZhciBhbmQgbmVhciBwbGFuZXMsIGFuZFxuXHRcdFx0Ly8gbW9zdCBsaWtlbHkgaWRlbnRpY2FsIHRvcCBhbmQgYm90dG9tIGZydXN0dW0gZXh0ZW50cy5cblx0XHRcdC8vIFVzZSB0aGUgbGVmdCBjYW1lcmEgZm9yIHRoZXNlIHZhbHVlcy5cblx0XHRcdGNvbnN0IG5lYXIgPSBwcm9qTFsgMTQgXSAvICggcHJvakxbIDEwIF0gLSAxICk7XG5cdFx0XHRjb25zdCBmYXIgPSBwcm9qTFsgMTQgXSAvICggcHJvakxbIDEwIF0gKyAxICk7XG5cdFx0XHRjb25zdCB0b3BGb3YgPSAoIHByb2pMWyA5IF0gKyAxICkgLyBwcm9qTFsgNSBdO1xuXHRcdFx0Y29uc3QgYm90dG9tRm92ID0gKCBwcm9qTFsgOSBdIC0gMSApIC8gcHJvakxbIDUgXTtcblxuXHRcdFx0Y29uc3QgbGVmdEZvdiA9ICggcHJvakxbIDggXSAtIDEgKSAvIHByb2pMWyAwIF07XG5cdFx0XHRjb25zdCByaWdodEZvdiA9ICggcHJvalJbIDggXSArIDEgKSAvIHByb2pSWyAwIF07XG5cdFx0XHRjb25zdCBsZWZ0ID0gbmVhciAqIGxlZnRGb3Y7XG5cdFx0XHRjb25zdCByaWdodCA9IG5lYXIgKiByaWdodEZvdjtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHRoZSBuZXcgY2FtZXJhJ3MgcG9zaXRpb24gb2Zmc2V0IGZyb20gdGhlXG5cdFx0XHQvLyBsZWZ0IGNhbWVyYS4geE9mZnNldCBzaG91bGQgYmUgcm91Z2hseSBoYWxmIGBpcGRgLlxuXHRcdFx0Y29uc3Qgek9mZnNldCA9IGlwZCAvICggLSBsZWZ0Rm92ICsgcmlnaHRGb3YgKTtcblx0XHRcdGNvbnN0IHhPZmZzZXQgPSB6T2Zmc2V0ICogLSBsZWZ0Rm92O1xuXG5cdFx0XHQvLyBUT0RPOiBCZXR0ZXIgd2F5IHRvIGFwcGx5IHRoaXMgb2Zmc2V0P1xuXHRcdFx0Y2FtZXJhTC5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIGNhbWVyYS5wb3NpdGlvbiwgY2FtZXJhLnF1YXRlcm5pb24sIGNhbWVyYS5zY2FsZSApO1xuXHRcdFx0Y2FtZXJhLnRyYW5zbGF0ZVgoIHhPZmZzZXQgKTtcblx0XHRcdGNhbWVyYS50cmFuc2xhdGVaKCB6T2Zmc2V0ICk7XG5cdFx0XHRjYW1lcmEubWF0cml4V29ybGQuY29tcG9zZSggY2FtZXJhLnBvc2l0aW9uLCBjYW1lcmEucXVhdGVybmlvbiwgY2FtZXJhLnNjYWxlICk7XG5cdFx0XHRjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZCApLmludmVydCgpO1xuXG5cdFx0XHQvLyBDaGVjayBpZiB0aGUgcHJvamVjdGlvbiB1c2VzIGFuIGluZmluaXRlIGZhciBwbGFuZS5cblx0XHRcdGlmICggcHJvakxbIDEwIF0gPT09IC0gMS4wICkge1xuXG5cdFx0XHRcdC8vIFVzZSB0aGUgcHJvamVjdGlvbiBtYXRyaXggZnJvbSB0aGUgbGVmdCBleWUuXG5cdFx0XHRcdC8vIFRoZSBjYW1lcmEgb2Zmc2V0IGlzIHN1ZmZpY2llbnQgdG8gaW5jbHVkZSB0aGUgdmlldyB2b2x1bWVzXG5cdFx0XHRcdC8vIG9mIGJvdGggZXllcyAoYXNzdW1pbmcgc3ltbWV0cmljIHByb2plY3Rpb25zKS5cblx0XHRcdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXguY29weSggY2FtZXJhTC5wcm9qZWN0aW9uTWF0cml4ICk7XG5cdFx0XHRcdGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KCBjYW1lcmFMLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRmluZCB0aGUgdW5pb24gb2YgdGhlIGZydXN0dW0gdmFsdWVzIG9mIHRoZSBjYW1lcmFzIGFuZCBzY2FsZVxuXHRcdFx0XHQvLyB0aGUgdmFsdWVzIHNvIHRoYXQgdGhlIG5lYXIgcGxhbmUncyBwb3NpdGlvbiBkb2VzIG5vdCBjaGFuZ2UgaW4gd29ybGQgc3BhY2UsXG5cdFx0XHRcdC8vIGFsdGhvdWdoIG11c3Qgbm93IGJlIHJlbGF0aXZlIHRvIHRoZSBuZXcgdW5pb24gY2FtZXJhLlxuXHRcdFx0XHRjb25zdCBuZWFyMiA9IG5lYXIgKyB6T2Zmc2V0O1xuXHRcdFx0XHRjb25zdCBmYXIyID0gZmFyICsgek9mZnNldDtcblx0XHRcdFx0Y29uc3QgbGVmdDIgPSBsZWZ0IC0geE9mZnNldDtcblx0XHRcdFx0Y29uc3QgcmlnaHQyID0gcmlnaHQgKyAoIGlwZCAtIHhPZmZzZXQgKTtcblx0XHRcdFx0Y29uc3QgdG9wMiA9IHRvcEZvdiAqIGZhciAvIGZhcjIgKiBuZWFyMjtcblx0XHRcdFx0Y29uc3QgYm90dG9tMiA9IGJvdHRvbUZvdiAqIGZhciAvIGZhcjIgKiBuZWFyMjtcblxuXHRcdFx0XHRjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUoIGxlZnQyLCByaWdodDIsIHRvcDIsIGJvdHRvbTIsIG5lYXIyLCBmYXIyICk7XG5cdFx0XHRcdGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApLmludmVydCgpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVDYW1lcmEoIGNhbWVyYSwgcGFyZW50ICkge1xuXG5cdFx0XHRpZiAoIHBhcmVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRjYW1lcmEubWF0cml4V29ybGQuY29weSggY2FtZXJhLm1hdHJpeCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNhbWVyYS5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCBwYXJlbnQubWF0cml4V29ybGQsIGNhbWVyYS5tYXRyaXggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZCApLmludmVydCgpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy51cGRhdGVDYW1lcmEgPSBmdW5jdGlvbiAoIGNhbWVyYSApIHtcblxuXHRcdFx0aWYgKCBzZXNzaW9uID09PSBudWxsICkgcmV0dXJuO1xuXG5cdFx0XHRsZXQgZGVwdGhOZWFyID0gY2FtZXJhLm5lYXI7XG5cdFx0XHRsZXQgZGVwdGhGYXIgPSBjYW1lcmEuZmFyO1xuXG5cdFx0XHRpZiAoIGRlcHRoU2Vuc2luZy50ZXh0dXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGlmICggZGVwdGhTZW5zaW5nLmRlcHRoTmVhciA+IDAgKSBkZXB0aE5lYXIgPSBkZXB0aFNlbnNpbmcuZGVwdGhOZWFyO1xuXHRcdFx0XHRpZiAoIGRlcHRoU2Vuc2luZy5kZXB0aEZhciA+IDAgKSBkZXB0aEZhciA9IGRlcHRoU2Vuc2luZy5kZXB0aEZhcjtcblxuXHRcdFx0fVxuXG5cdFx0XHRjYW1lcmFYUi5uZWFyID0gY2FtZXJhUi5uZWFyID0gY2FtZXJhTC5uZWFyID0gZGVwdGhOZWFyO1xuXHRcdFx0Y2FtZXJhWFIuZmFyID0gY2FtZXJhUi5mYXIgPSBjYW1lcmFMLmZhciA9IGRlcHRoRmFyO1xuXG5cdFx0XHRpZiAoIF9jdXJyZW50RGVwdGhOZWFyICE9PSBjYW1lcmFYUi5uZWFyIHx8IF9jdXJyZW50RGVwdGhGYXIgIT09IGNhbWVyYVhSLmZhciApIHtcblxuXHRcdFx0XHQvLyBOb3RlIHRoYXQgdGhlIG5ldyByZW5kZXJTdGF0ZSB3b24ndCBhcHBseSB1bnRpbCB0aGUgbmV4dCBmcmFtZS4gU2VlICMxODMyMFxuXG5cdFx0XHRcdHNlc3Npb24udXBkYXRlUmVuZGVyU3RhdGUoIHtcblx0XHRcdFx0XHRkZXB0aE5lYXI6IGNhbWVyYVhSLm5lYXIsXG5cdFx0XHRcdFx0ZGVwdGhGYXI6IGNhbWVyYVhSLmZhclxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0X2N1cnJlbnREZXB0aE5lYXIgPSBjYW1lcmFYUi5uZWFyO1xuXHRcdFx0XHRfY3VycmVudERlcHRoRmFyID0gY2FtZXJhWFIuZmFyO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNhbWVyYUwubGF5ZXJzLm1hc2sgPSBjYW1lcmEubGF5ZXJzLm1hc2sgfCAwYjAxMDtcblx0XHRcdGNhbWVyYVIubGF5ZXJzLm1hc2sgPSBjYW1lcmEubGF5ZXJzLm1hc2sgfCAwYjEwMDtcblx0XHRcdGNhbWVyYVhSLmxheWVycy5tYXNrID0gY2FtZXJhTC5sYXllcnMubWFzayB8IGNhbWVyYVIubGF5ZXJzLm1hc2s7XG5cblx0XHRcdGNvbnN0IHBhcmVudCA9IGNhbWVyYS5wYXJlbnQ7XG5cdFx0XHRjb25zdCBjYW1lcmFzID0gY2FtZXJhWFIuY2FtZXJhcztcblxuXHRcdFx0dXBkYXRlQ2FtZXJhKCBjYW1lcmFYUiwgcGFyZW50ICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNhbWVyYXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHVwZGF0ZUNhbWVyYSggY2FtZXJhc1sgaSBdLCBwYXJlbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyB1cGRhdGUgcHJvamVjdGlvbiBtYXRyaXggZm9yIHByb3BlciB2aWV3IGZydXN0dW0gY3VsbGluZ1xuXG5cdFx0XHRpZiAoIGNhbWVyYXMubGVuZ3RoID09PSAyICkge1xuXG5cdFx0XHRcdHNldFByb2plY3Rpb25Gcm9tVW5pb24oIGNhbWVyYVhSLCBjYW1lcmFMLCBjYW1lcmFSICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gYXNzdW1lIHNpbmdsZSBjYW1lcmEgc2V0dXAgKEFSKVxuXG5cdFx0XHRcdGNhbWVyYVhSLnByb2plY3Rpb25NYXRyaXguY29weSggY2FtZXJhTC5wcm9qZWN0aW9uTWF0cml4ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gdXBkYXRlIHVzZXIgY2FtZXJhIGFuZCBpdHMgY2hpbGRyZW5cblxuXHRcdFx0dXBkYXRlVXNlckNhbWVyYSggY2FtZXJhLCBjYW1lcmFYUiwgcGFyZW50ICk7XG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlVXNlckNhbWVyYSggY2FtZXJhLCBjYW1lcmFYUiwgcGFyZW50ICkge1xuXG5cdFx0XHRpZiAoIHBhcmVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRjYW1lcmEubWF0cml4LmNvcHkoIGNhbWVyYVhSLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y2FtZXJhLm1hdHJpeC5jb3B5KCBwYXJlbnQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0Y2FtZXJhLm1hdHJpeC5pbnZlcnQoKTtcblx0XHRcdFx0Y2FtZXJhLm1hdHJpeC5tdWx0aXBseSggY2FtZXJhWFIubWF0cml4V29ybGQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjYW1lcmEubWF0cml4LmRlY29tcG9zZSggY2FtZXJhLnBvc2l0aW9uLCBjYW1lcmEucXVhdGVybmlvbiwgY2FtZXJhLnNjYWxlICk7XG5cdFx0XHRjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXguY29weSggY2FtZXJhWFIucHJvamVjdGlvbk1hdHJpeCApO1xuXHRcdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkoIGNhbWVyYVhSLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlICk7XG5cblx0XHRcdGlmICggY2FtZXJhLmlzUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cblx0XHRcdFx0Y2FtZXJhLmZvdiA9IFJBRDJERUcgKiAyICogTWF0aC5hdGFuKCAxIC8gY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDUgXSApO1xuXHRcdFx0XHRjYW1lcmEuem9vbSA9IDE7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuZ2V0Q2FtZXJhID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gY2FtZXJhWFI7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRGb3ZlYXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGlmICggZ2xQcm9qTGF5ZXIgPT09IG51bGwgJiYgZ2xCYXNlTGF5ZXIgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm92ZWF0aW9uO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0Rm92ZWF0aW9uID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0Ly8gMCA9IG5vIGZvdmVhdGlvbiA9IGZ1bGwgcmVzb2x1dGlvblxuXHRcdFx0Ly8gMSA9IG1heGltdW0gZm92ZWF0aW9uID0gdGhlIGVkZ2VzIHJlbmRlciBhdCBsb3dlciByZXNvbHV0aW9uXG5cblx0XHRcdGZvdmVhdGlvbiA9IHZhbHVlO1xuXG5cdFx0XHRpZiAoIGdsUHJvakxheWVyICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGdsUHJvakxheWVyLmZpeGVkRm92ZWF0aW9uID0gdmFsdWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnbEJhc2VMYXllciAhPT0gbnVsbCAmJiBnbEJhc2VMYXllci5maXhlZEZvdmVhdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGdsQmFzZUxheWVyLmZpeGVkRm92ZWF0aW9uID0gdmFsdWU7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHR0aGlzLmhhc0RlcHRoU2Vuc2luZyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIGRlcHRoU2Vuc2luZy50ZXh0dXJlICE9PSBudWxsO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0RGVwdGhTZW5zaW5nTWVzaCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIGRlcHRoU2Vuc2luZy5nZXRNZXNoKCBjYW1lcmFYUiApO1xuXG5cdFx0fTtcblxuXHRcdC8vIEFuaW1hdGlvbiBMb29wXG5cblx0XHRsZXQgb25BbmltYXRpb25GcmFtZUNhbGxiYWNrID0gbnVsbDtcblxuXHRcdGZ1bmN0aW9uIG9uQW5pbWF0aW9uRnJhbWUoIHRpbWUsIGZyYW1lICkge1xuXG5cdFx0XHRwb3NlID0gZnJhbWUuZ2V0Vmlld2VyUG9zZSggY3VzdG9tUmVmZXJlbmNlU3BhY2UgfHwgcmVmZXJlbmNlU3BhY2UgKTtcblx0XHRcdHhyRnJhbWUgPSBmcmFtZTtcblxuXHRcdFx0aWYgKCBwb3NlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGNvbnN0IHZpZXdzID0gcG9zZS52aWV3cztcblxuXHRcdFx0XHRpZiAoIGdsQmFzZUxheWVyICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0RnJhbWVidWZmZXIoIG5ld1JlbmRlclRhcmdldCwgZ2xCYXNlTGF5ZXIuZnJhbWVidWZmZXIgKTtcblx0XHRcdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIG5ld1JlbmRlclRhcmdldCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZXQgY2FtZXJhWFJOZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIGNoZWNrIGlmIGl0J3MgbmVjZXNzYXJ5IHRvIHJlYnVpbGQgY2FtZXJhWFIncyBjYW1lcmEgbGlzdFxuXG5cdFx0XHRcdGlmICggdmlld3MubGVuZ3RoICE9PSBjYW1lcmFYUi5jYW1lcmFzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdGNhbWVyYVhSLmNhbWVyYXMubGVuZ3RoID0gMDtcblx0XHRcdFx0XHRjYW1lcmFYUk5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdmlld3MubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdmlldyA9IHZpZXdzWyBpIF07XG5cblx0XHRcdFx0XHRsZXQgdmlld3BvcnQgPSBudWxsO1xuXG5cdFx0XHRcdFx0aWYgKCBnbEJhc2VMYXllciAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0dmlld3BvcnQgPSBnbEJhc2VMYXllci5nZXRWaWV3cG9ydCggdmlldyApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgZ2xTdWJJbWFnZSA9IGdsQmluZGluZy5nZXRWaWV3U3ViSW1hZ2UoIGdsUHJvakxheWVyLCB2aWV3ICk7XG5cdFx0XHRcdFx0XHR2aWV3cG9ydCA9IGdsU3ViSW1hZ2Uudmlld3BvcnQ7XG5cblx0XHRcdFx0XHRcdC8vIEZvciBzaWRlLWJ5LXNpZGUgcHJvamVjdGlvbiwgd2Ugb25seSBwcm9kdWNlIGEgc2luZ2xlIHRleHR1cmUgZm9yIGJvdGggZXllcy5cblx0XHRcdFx0XHRcdGlmICggaSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXRUZXh0dXJlcyhcblx0XHRcdFx0XHRcdFx0XHRuZXdSZW5kZXJUYXJnZXQsXG5cdFx0XHRcdFx0XHRcdFx0Z2xTdWJJbWFnZS5jb2xvclRleHR1cmUsXG5cdFx0XHRcdFx0XHRcdFx0Z2xQcm9qTGF5ZXIuaWdub3JlRGVwdGhWYWx1ZXMgPyB1bmRlZmluZWQgOiBnbFN1YkltYWdlLmRlcHRoU3RlbmNpbFRleHR1cmUgKTtcblxuXHRcdFx0XHRcdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIG5ld1JlbmRlclRhcmdldCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsZXQgY2FtZXJhID0gY2FtZXJhc1sgaSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBjYW1lcmEgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Y2FtZXJhID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cdFx0XHRcdFx0XHRjYW1lcmEubGF5ZXJzLmVuYWJsZSggaSApO1xuXHRcdFx0XHRcdFx0Y2FtZXJhLnZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoKTtcblx0XHRcdFx0XHRcdGNhbWVyYXNbIGkgXSA9IGNhbWVyYTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhbWVyYS5tYXRyaXguZnJvbUFycmF5KCB2aWV3LnRyYW5zZm9ybS5tYXRyaXggKTtcblx0XHRcdFx0XHRjYW1lcmEubWF0cml4LmRlY29tcG9zZSggY2FtZXJhLnBvc2l0aW9uLCBjYW1lcmEucXVhdGVybmlvbiwgY2FtZXJhLnNjYWxlICk7XG5cdFx0XHRcdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXguZnJvbUFycmF5KCB2aWV3LnByb2plY3Rpb25NYXRyaXggKTtcblx0XHRcdFx0XHRjYW1lcmEucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weSggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKS5pbnZlcnQoKTtcblx0XHRcdFx0XHRjYW1lcmEudmlld3BvcnQuc2V0KCB2aWV3cG9ydC54LCB2aWV3cG9ydC55LCB2aWV3cG9ydC53aWR0aCwgdmlld3BvcnQuaGVpZ2h0ICk7XG5cblx0XHRcdFx0XHRpZiAoIGkgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdGNhbWVyYVhSLm1hdHJpeC5jb3B5KCBjYW1lcmEubWF0cml4ICk7XG5cdFx0XHRcdFx0XHRjYW1lcmFYUi5tYXRyaXguZGVjb21wb3NlKCBjYW1lcmFYUi5wb3NpdGlvbiwgY2FtZXJhWFIucXVhdGVybmlvbiwgY2FtZXJhWFIuc2NhbGUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggY2FtZXJhWFJOZWVkc1VwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FtZXJhWFIuY2FtZXJhcy5wdXNoKCBjYW1lcmEgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9cblxuXHRcdFx0XHRjb25zdCBlbmFibGVkRmVhdHVyZXMgPSBzZXNzaW9uLmVuYWJsZWRGZWF0dXJlcztcblxuXHRcdFx0XHRpZiAoIGVuYWJsZWRGZWF0dXJlcyAmJiBlbmFibGVkRmVhdHVyZXMuaW5jbHVkZXMoICdkZXB0aC1zZW5zaW5nJyApICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZGVwdGhEYXRhID0gZ2xCaW5kaW5nLmdldERlcHRoSW5mb3JtYXRpb24oIHZpZXdzWyAwIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZGVwdGhEYXRhICYmIGRlcHRoRGF0YS5pc1ZhbGlkICYmIGRlcHRoRGF0YS50ZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0XHRkZXB0aFNlbnNpbmcuaW5pdCggcmVuZGVyZXIsIGRlcHRoRGF0YSwgc2Vzc2lvbi5yZW5kZXJTdGF0ZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvL1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjb250cm9sbGVycy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW5wdXRTb3VyY2UgPSBjb250cm9sbGVySW5wdXRTb3VyY2VzWyBpIF07XG5cdFx0XHRcdGNvbnN0IGNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggaW5wdXRTb3VyY2UgIT09IG51bGwgJiYgY29udHJvbGxlciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y29udHJvbGxlci51cGRhdGUoIGlucHV0U291cmNlLCBmcmFtZSwgY3VzdG9tUmVmZXJlbmNlU3BhY2UgfHwgcmVmZXJlbmNlU3BhY2UgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2sgKSBvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2soIHRpbWUsIGZyYW1lICk7XG5cblx0XHRcdGlmICggZnJhbWUuZGV0ZWN0ZWRQbGFuZXMgKSB7XG5cblx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAncGxhbmVzZGV0ZWN0ZWQnLCBkYXRhOiBmcmFtZSB9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0eHJGcmFtZSA9IG51bGw7XG5cblx0XHR9XG5cblx0XHRjb25zdCBhbmltYXRpb24gPSBuZXcgV2ViR0xBbmltYXRpb24oKTtcblxuXHRcdGFuaW1hdGlvbi5zZXRBbmltYXRpb25Mb29wKCBvbkFuaW1hdGlvbkZyYW1lICk7XG5cblx0XHR0aGlzLnNldEFuaW1hdGlvbkxvb3AgPSBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0XHRvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdH07XG5cblx0XHR0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuXHR9XG5cbn1cblxuY29uc3QgX2UxID0gLypAX19QVVJFX18qLyBuZXcgRXVsZXIoKTtcbmNvbnN0IF9tMSA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcblxuZnVuY3Rpb24gV2ViR0xNYXRlcmlhbHMoIHJlbmRlcmVyLCBwcm9wZXJ0aWVzICkge1xuXG5cdGZ1bmN0aW9uIHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXAsIHVuaWZvcm0gKSB7XG5cblx0XHRpZiAoIG1hcC5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRtYXAudXBkYXRlTWF0cml4KCk7XG5cblx0XHR9XG5cblx0XHR1bmlmb3JtLnZhbHVlLmNvcHkoIG1hcC5tYXRyaXggKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVmcmVzaEZvZ1VuaWZvcm1zKCB1bmlmb3JtcywgZm9nICkge1xuXG5cdFx0Zm9nLmNvbG9yLmdldFJHQiggdW5pZm9ybXMuZm9nQ29sb3IudmFsdWUsIGdldFVubGl0VW5pZm9ybUNvbG9yU3BhY2UoIHJlbmRlcmVyICkgKTtcblxuXHRcdGlmICggZm9nLmlzRm9nICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5mb2dOZWFyLnZhbHVlID0gZm9nLm5lYXI7XG5cdFx0XHR1bmlmb3Jtcy5mb2dGYXIudmFsdWUgPSBmb2cuZmFyO1xuXG5cdFx0fSBlbHNlIGlmICggZm9nLmlzRm9nRXhwMiApIHtcblxuXHRcdFx0dW5pZm9ybXMuZm9nRGVuc2l0eS52YWx1ZSA9IGZvZy5kZW5zaXR5O1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoTWF0ZXJpYWxVbmlmb3JtcyggdW5pZm9ybXMsIG1hdGVyaWFsLCBwaXhlbFJhdGlvLCBoZWlnaHQsIHRyYW5zbWlzc2lvblJlbmRlclRhcmdldCApIHtcblxuXHRcdGlmICggbWF0ZXJpYWwuaXNNZXNoQmFzaWNNYXRlcmlhbCApIHtcblxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaExhbWJlcnRNYXRlcmlhbCApIHtcblxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaFRvb25NYXRlcmlhbCApIHtcblxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcblx0XHRcdHJlZnJlc2hVbmlmb3Jtc1Rvb24oIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCApIHtcblxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcblx0XHRcdHJlZnJlc2hVbmlmb3Jtc1Bob25nKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCggdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuaXNNZXNoUGh5c2ljYWxNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQaHlzaWNhbCggdW5pZm9ybXMsIG1hdGVyaWFsLCB0cmFuc21pc3Npb25SZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoTWF0Y2FwTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNNYXRjYXAoIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoRGVwdGhNYXRlcmlhbCApIHtcblxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaERpc3RhbmNlTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNEaXN0YW5jZSggdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hOb3JtYWxNYXRlcmlhbCApIHtcblxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTGluZUJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHJlZnJlc2hVbmlmb3Jtc0xpbmUoIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlzTGluZURhc2hlZE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0Rhc2goIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc1BvaW50c01hdGVyaWFsICkge1xuXG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNQb2ludHMoIHVuaWZvcm1zLCBtYXRlcmlhbCwgcGl4ZWxSYXRpbywgaGVpZ2h0ICk7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc1Nwcml0ZU1hdGVyaWFsICkge1xuXG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNTcHJpdGVzKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzU2hhZG93TWF0ZXJpYWwgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmNvbG9yLnZhbHVlLmNvcHkoIG1hdGVyaWFsLmNvbG9yICk7XG5cdFx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgKSB7XG5cblx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zTmVlZFVwZGF0ZSA9IGZhbHNlOyAvLyAjMTU1ODFcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuXHRcdGlmICggbWF0ZXJpYWwuY29sb3IgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmUgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLmVtaXNzaXZlICkubXVsdGlwbHlTY2FsYXIoIG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xuXG5cdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwubWFwLCB1bmlmb3Jtcy5tYXBUcmFuc2Zvcm0gKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuYWxwaGFNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmFscGhhTWFwLnZhbHVlID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5hbHBoYU1hcCwgdW5pZm9ybXMuYWxwaGFNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMuYnVtcE1hcC52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBNYXA7XG5cblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5idW1wTWFwLCB1bmlmb3Jtcy5idW1wTWFwVHJhbnNmb3JtICk7XG5cblx0XHRcdHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBTY2FsZTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgKj0gLSAxO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuXG5cdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwubm9ybWFsTWFwLCB1bmlmb3Jtcy5ub3JtYWxNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdFx0dW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weSggbWF0ZXJpYWwubm9ybWFsU2NhbGUgKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5uZWdhdGUoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblxuXHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCwgdW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwVHJhbnNmb3JtICk7XG5cblx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCwgdW5pZm9ybXMuZW1pc3NpdmVNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLnNwZWN1bGFyTWFwLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XG5cblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5zcGVjdWxhck1hcCwgdW5pZm9ybXMuc3BlY3VsYXJNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuYWxwaGFUZXN0ID4gMCApIHtcblxuXHRcdFx0dW5pZm9ybXMuYWxwaGFUZXN0LnZhbHVlID0gbWF0ZXJpYWwuYWxwaGFUZXN0O1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XG5cblx0XHRjb25zdCBlbnZNYXAgPSBtYXRlcmlhbFByb3BlcnRpZXMuZW52TWFwO1xuXHRcdGNvbnN0IGVudk1hcFJvdGF0aW9uID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLmVudk1hcFJvdGF0aW9uO1xuXG5cdFx0aWYgKCBlbnZNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmVudk1hcC52YWx1ZSA9IGVudk1hcDtcblxuXHRcdFx0X2UxLmNvcHkoIGVudk1hcFJvdGF0aW9uICk7XG5cblx0XHRcdC8vIGFjY29tbW9kYXRlIGxlZnQtaGFuZGVkIGZyYW1lXG5cdFx0XHRfZTEueCAqPSAtIDE7IF9lMS55ICo9IC0gMTsgX2UxLnogKj0gLSAxO1xuXG5cdFx0XHRpZiAoIGVudk1hcC5pc0N1YmVUZXh0dXJlICYmIGVudk1hcC5pc1JlbmRlclRhcmdldFRleHR1cmUgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIGVudmlyb25tZW50IG1hcHMgd2hpY2ggYXJlIG5vdCBjdWJlIHJlbmRlciB0YXJnZXRzIG9yIFBNUkVNcyBmb2xsb3cgYSBkaWZmZXJlbnQgY29udmVudGlvblxuXHRcdFx0XHRfZTEueSAqPSAtIDE7XG5cdFx0XHRcdF9lMS56ICo9IC0gMTtcblxuXHRcdFx0fVxuXG5cdFx0XHR1bmlmb3Jtcy5lbnZNYXBSb3RhdGlvbi52YWx1ZS5zZXRGcm9tTWF0cml4NCggX20xLm1ha2VSb3RhdGlvbkZyb21FdWxlciggX2UxICkgKTtcblxuXHRcdFx0dW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZSA9ICggZW52TWFwLmlzQ3ViZVRleHR1cmUgJiYgZW52TWFwLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gZmFsc2UgKSA/IC0gMSA6IDE7XG5cblx0XHRcdHVuaWZvcm1zLnJlZmxlY3Rpdml0eS52YWx1ZSA9IG1hdGVyaWFsLnJlZmxlY3Rpdml0eTtcblx0XHRcdHVuaWZvcm1zLmlvci52YWx1ZSA9IG1hdGVyaWFsLmlvcjtcblx0XHRcdHVuaWZvcm1zLnJlZnJhY3Rpb25SYXRpby52YWx1ZSA9IG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbztcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwubGlnaHRNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmxpZ2h0TWFwLnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXA7XG5cdFx0XHR1bmlmb3Jtcy5saWdodE1hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG5cdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwubGlnaHRNYXAsIHVuaWZvcm1zLmxpZ2h0TWFwVHJhbnNmb3JtICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmFvTWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5hb01hcC52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwO1xuXHRcdFx0dW5pZm9ybXMuYW9NYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5hb01hcEludGVuc2l0eTtcblxuXHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLmFvTWFwLCB1bmlmb3Jtcy5hb01hcFRyYW5zZm9ybSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMaW5lKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLmNvbG9yICk7XG5cdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cblx0XHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xuXG5cdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwubWFwLCB1bmlmb3Jtcy5tYXBUcmFuc2Zvcm0gKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRGFzaCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG5cdFx0dW5pZm9ybXMuZGFzaFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZTtcblx0XHR1bmlmb3Jtcy50b3RhbFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZSArIG1hdGVyaWFsLmdhcFNpemU7XG5cdFx0dW5pZm9ybXMuc2NhbGUudmFsdWUgPSBtYXRlcmlhbC5zY2FsZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUG9pbnRzKCB1bmlmb3JtcywgbWF0ZXJpYWwsIHBpeGVsUmF0aW8sIGhlaWdodCApIHtcblxuXHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblx0XHR1bmlmb3Jtcy5zaXplLnZhbHVlID0gbWF0ZXJpYWwuc2l6ZSAqIHBpeGVsUmF0aW87XG5cdFx0dW5pZm9ybXMuc2NhbGUudmFsdWUgPSBoZWlnaHQgKiAwLjU7XG5cblx0XHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xuXG5cdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwubWFwLCB1bmlmb3Jtcy51dlRyYW5zZm9ybSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5hbHBoYU1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMuYWxwaGFNYXAudmFsdWUgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblxuXHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLmFscGhhTWFwLCB1bmlmb3Jtcy5hbHBoYU1hcFRyYW5zZm9ybSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5hbHBoYVRlc3QgPiAwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5hbHBoYVRlc3QudmFsdWUgPSBtYXRlcmlhbC5hbHBoYVRlc3Q7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1Nwcml0ZXMoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblx0XHR1bmlmb3Jtcy5yb3RhdGlvbi52YWx1ZSA9IG1hdGVyaWFsLnJvdGF0aW9uO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5tYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcblxuXHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLm1hcCwgdW5pZm9ybXMubWFwVHJhbnNmb3JtICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmFscGhhTWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xuXG5cdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwuYWxwaGFNYXAsIHVuaWZvcm1zLmFscGhhTWFwVHJhbnNmb3JtICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmFscGhhVGVzdCA+IDAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmFscGhhVGVzdC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhVGVzdDtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGhvbmcoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlLmNvcHkoIG1hdGVyaWFsLnNwZWN1bGFyICk7XG5cdFx0dW5pZm9ybXMuc2hpbmluZXNzLnZhbHVlID0gTWF0aC5tYXgoIG1hdGVyaWFsLnNoaW5pbmVzcywgMWUtNCApOyAvLyB0byBwcmV2ZW50IHBvdyggMC4wLCAwLjAgKVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNUb29uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHRpZiAoIG1hdGVyaWFsLmdyYWRpZW50TWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5ncmFkaWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmdyYWRpZW50TWFwO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG5cdFx0dW5pZm9ybXMubWV0YWxuZXNzLnZhbHVlID0gbWF0ZXJpYWwubWV0YWxuZXNzO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5tZXRhbG5lc3NNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLm1ldGFsbmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLm1ldGFsbmVzc01hcDtcblxuXHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLm1ldGFsbmVzc01hcCwgdW5pZm9ybXMubWV0YWxuZXNzTWFwVHJhbnNmb3JtICk7XG5cblx0XHR9XG5cblx0XHR1bmlmb3Jtcy5yb3VnaG5lc3MudmFsdWUgPSBtYXRlcmlhbC5yb3VnaG5lc3M7XG5cblx0XHRpZiAoIG1hdGVyaWFsLnJvdWdobmVzc01hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMucm91Z2huZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwucm91Z2huZXNzTWFwO1xuXG5cdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwucm91Z2huZXNzTWFwLCB1bmlmb3Jtcy5yb3VnaG5lc3NNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuZW52TWFwICkge1xuXG5cdFx0XHQvL3VuaWZvcm1zLmVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcDsgLy8gcGFydCBvZiB1bmlmb3JtcyBjb21tb25cblxuXHRcdFx0dW5pZm9ybXMuZW52TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwSW50ZW5zaXR5O1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaHlzaWNhbCggdW5pZm9ybXMsIG1hdGVyaWFsLCB0cmFuc21pc3Npb25SZW5kZXJUYXJnZXQgKSB7XG5cblx0XHR1bmlmb3Jtcy5pb3IudmFsdWUgPSBtYXRlcmlhbC5pb3I7IC8vIGFsc28gcGFydCBvZiB1bmlmb3JtcyBjb21tb25cblxuXHRcdGlmICggbWF0ZXJpYWwuc2hlZW4gPiAwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5zaGVlbkNvbG9yLnZhbHVlLmNvcHkoIG1hdGVyaWFsLnNoZWVuQ29sb3IgKS5tdWx0aXBseVNjYWxhciggbWF0ZXJpYWwuc2hlZW4gKTtcblxuXHRcdFx0dW5pZm9ybXMuc2hlZW5Sb3VnaG5lc3MudmFsdWUgPSBtYXRlcmlhbC5zaGVlblJvdWdobmVzcztcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5zaGVlbkNvbG9yTWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLnNoZWVuQ29sb3JNYXAudmFsdWUgPSBtYXRlcmlhbC5zaGVlbkNvbG9yTWFwO1xuXG5cdFx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5zaGVlbkNvbG9yTWFwLCB1bmlmb3Jtcy5zaGVlbkNvbG9yTWFwVHJhbnNmb3JtICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5zaGVlblJvdWdobmVzc01hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5zaGVlblJvdWdobmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzTWFwO1xuXG5cdFx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5zaGVlblJvdWdobmVzc01hcCwgdW5pZm9ybXMuc2hlZW5Sb3VnaG5lc3NNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5jbGVhcmNvYXQgPiAwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5jbGVhcmNvYXQudmFsdWUgPSBtYXRlcmlhbC5jbGVhcmNvYXQ7XG5cdFx0XHR1bmlmb3Jtcy5jbGVhcmNvYXRSb3VnaG5lc3MudmFsdWUgPSBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3M7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuY2xlYXJjb2F0TWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLmNsZWFyY29hdE1hcC52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyY29hdE1hcDtcblxuXHRcdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwuY2xlYXJjb2F0TWFwLCB1bmlmb3Jtcy5jbGVhcmNvYXRNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzc01hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXA7XG5cblx0XHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzc01hcCwgdW5pZm9ybXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwVHJhbnNmb3JtICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXAgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXMuY2xlYXJjb2F0Tm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsTWFwO1xuXG5cdFx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXAsIHVuaWZvcm1zLmNsZWFyY29hdE5vcm1hbE1hcFRyYW5zZm9ybSApO1xuXG5cdFx0XHRcdHVuaWZvcm1zLmNsZWFyY29hdE5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlICk7XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLmNsZWFyY29hdE5vcm1hbFNjYWxlLnZhbHVlLm5lZ2F0ZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5kaXNwZXJzaW9uID4gMCApIHtcblxuXHRcdFx0dW5pZm9ybXMuZGlzcGVyc2lvbi52YWx1ZSA9IG1hdGVyaWFsLmRpc3BlcnNpb247XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmlyaWRlc2NlbmNlID4gMCApIHtcblxuXHRcdFx0dW5pZm9ybXMuaXJpZGVzY2VuY2UudmFsdWUgPSBtYXRlcmlhbC5pcmlkZXNjZW5jZTtcblx0XHRcdHVuaWZvcm1zLmlyaWRlc2NlbmNlSU9SLnZhbHVlID0gbWF0ZXJpYWwuaXJpZGVzY2VuY2VJT1I7XG5cdFx0XHR1bmlmb3Jtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0udmFsdWUgPSBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlWyAwIF07XG5cdFx0XHR1bmlmb3Jtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW0udmFsdWUgPSBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlWyAxIF07XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuaXJpZGVzY2VuY2VNYXAgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXMuaXJpZGVzY2VuY2VNYXAudmFsdWUgPSBtYXRlcmlhbC5pcmlkZXNjZW5jZU1hcDtcblxuXHRcdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwuaXJpZGVzY2VuY2VNYXAsIHVuaWZvcm1zLmlyaWRlc2NlbmNlTWFwVHJhbnNmb3JtICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwO1xuXG5cdFx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCwgdW5pZm9ybXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC50cmFuc21pc3Npb24gPiAwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy50cmFuc21pc3Npb24udmFsdWUgPSBtYXRlcmlhbC50cmFuc21pc3Npb247XG5cdFx0XHR1bmlmb3Jtcy50cmFuc21pc3Npb25TYW1wbGVyTWFwLnZhbHVlID0gdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cdFx0XHR1bmlmb3Jtcy50cmFuc21pc3Npb25TYW1wbGVyU2l6ZS52YWx1ZS5zZXQoIHRyYW5zbWlzc2lvblJlbmRlclRhcmdldC53aWR0aCwgdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0LmhlaWdodCApO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy50cmFuc21pc3Npb25NYXAudmFsdWUgPSBtYXRlcmlhbC50cmFuc21pc3Npb25NYXA7XG5cblx0XHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcCwgdW5pZm9ybXMudHJhbnNtaXNzaW9uTWFwVHJhbnNmb3JtICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dW5pZm9ybXMudGhpY2tuZXNzLnZhbHVlID0gbWF0ZXJpYWwudGhpY2tuZXNzO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnRoaWNrbmVzc01hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy50aGlja25lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC50aGlja25lc3NNYXA7XG5cblx0XHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLnRoaWNrbmVzc01hcCwgdW5pZm9ybXMudGhpY2tuZXNzTWFwVHJhbnNmb3JtICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dW5pZm9ybXMuYXR0ZW51YXRpb25EaXN0YW5jZS52YWx1ZSA9IG1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2U7XG5cdFx0XHR1bmlmb3Jtcy5hdHRlbnVhdGlvbkNvbG9yLnZhbHVlLmNvcHkoIG1hdGVyaWFsLmF0dGVudWF0aW9uQ29sb3IgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuYW5pc290cm9weSA+IDAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmFuaXNvdHJvcHlWZWN0b3IudmFsdWUuc2V0KCBtYXRlcmlhbC5hbmlzb3Ryb3B5ICogTWF0aC5jb3MoIG1hdGVyaWFsLmFuaXNvdHJvcHlSb3RhdGlvbiApLCBtYXRlcmlhbC5hbmlzb3Ryb3B5ICogTWF0aC5zaW4oIG1hdGVyaWFsLmFuaXNvdHJvcHlSb3RhdGlvbiApICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuYW5pc290cm9weU1hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5hbmlzb3Ryb3B5TWFwLnZhbHVlID0gbWF0ZXJpYWwuYW5pc290cm9weU1hcDtcblxuXHRcdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwuYW5pc290cm9weU1hcCwgdW5pZm9ybXMuYW5pc290cm9weU1hcFRyYW5zZm9ybSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR1bmlmb3Jtcy5zcGVjdWxhckludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5O1xuXHRcdHVuaWZvcm1zLnNwZWN1bGFyQ29sb3IudmFsdWUuY29weSggbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciApO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5zcGVjdWxhckNvbG9yTWFwLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJDb2xvck1hcDtcblxuXHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3JNYXAsIHVuaWZvcm1zLnNwZWN1bGFyQ29sb3JNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHlNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLnNwZWN1bGFySW50ZW5zaXR5TWFwLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHlNYXA7XG5cblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eU1hcCwgdW5pZm9ybXMuc3BlY3VsYXJJbnRlbnNpdHlNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTWF0Y2FwKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHRpZiAoIG1hdGVyaWFsLm1hdGNhcCApIHtcblxuXHRcdFx0dW5pZm9ybXMubWF0Y2FwLnZhbHVlID0gbWF0ZXJpYWwubWF0Y2FwO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNEaXN0YW5jZSggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG5cdFx0Y29uc3QgbGlnaHQgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKS5saWdodDtcblxuXHRcdHVuaWZvcm1zLnJlZmVyZW5jZVBvc2l0aW9uLnZhbHVlLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblx0XHR1bmlmb3Jtcy5uZWFyRGlzdGFuY2UudmFsdWUgPSBsaWdodC5zaGFkb3cuY2FtZXJhLm5lYXI7XG5cdFx0dW5pZm9ybXMuZmFyRGlzdGFuY2UudmFsdWUgPSBsaWdodC5zaGFkb3cuY2FtZXJhLmZhcjtcblxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRyZWZyZXNoRm9nVW5pZm9ybXM6IHJlZnJlc2hGb2dVbmlmb3Jtcyxcblx0XHRyZWZyZXNoTWF0ZXJpYWxVbmlmb3JtczogcmVmcmVzaE1hdGVyaWFsVW5pZm9ybXNcblx0fTtcblxufVxuXG5mdW5jdGlvbiBXZWJHTFVuaWZvcm1zR3JvdXBzKCBnbCwgaW5mbywgY2FwYWJpbGl0aWVzLCBzdGF0ZSApIHtcblxuXHRsZXQgYnVmZmVycyA9IHt9O1xuXHRsZXQgdXBkYXRlTGlzdCA9IHt9O1xuXHRsZXQgYWxsb2NhdGVkQmluZGluZ1BvaW50cyA9IFtdO1xuXG5cdGNvbnN0IG1heEJpbmRpbmdQb2ludHMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9VTklGT1JNX0JVRkZFUl9CSU5ESU5HUyApOyAvLyBiaW5kaW5nIHBvaW50cyBhcmUgZ2xvYmFsIHdoZXJlYXMgYmxvY2sgaW5kaWNlcyBhcmUgcGVyIHNoYWRlciBwcm9ncmFtXG5cblx0ZnVuY3Rpb24gYmluZCggdW5pZm9ybXNHcm91cCwgcHJvZ3JhbSApIHtcblxuXHRcdGNvbnN0IHdlYmdsUHJvZ3JhbSA9IHByb2dyYW0ucHJvZ3JhbTtcblx0XHRzdGF0ZS51bmlmb3JtQmxvY2tCaW5kaW5nKCB1bmlmb3Jtc0dyb3VwLCB3ZWJnbFByb2dyYW0gKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlKCB1bmlmb3Jtc0dyb3VwLCBwcm9ncmFtICkge1xuXG5cdFx0bGV0IGJ1ZmZlciA9IGJ1ZmZlcnNbIHVuaWZvcm1zR3JvdXAuaWQgXTtcblxuXHRcdGlmICggYnVmZmVyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHByZXBhcmVVbmlmb3Jtc0dyb3VwKCB1bmlmb3Jtc0dyb3VwICk7XG5cblx0XHRcdGJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlciggdW5pZm9ybXNHcm91cCApO1xuXHRcdFx0YnVmZmVyc1sgdW5pZm9ybXNHcm91cC5pZCBdID0gYnVmZmVyO1xuXG5cdFx0XHR1bmlmb3Jtc0dyb3VwLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25Vbmlmb3Jtc0dyb3Vwc0Rpc3Bvc2UgKTtcblxuXHRcdH1cblxuXHRcdC8vIGVuc3VyZSB0byB1cGRhdGUgdGhlIGJpbmRpbmcgcG9pbnRzL2Jsb2NrIGluZGljZXMgbWFwcGluZyBmb3IgdGhpcyBwcm9ncmFtXG5cblx0XHRjb25zdCB3ZWJnbFByb2dyYW0gPSBwcm9ncmFtLnByb2dyYW07XG5cdFx0c3RhdGUudXBkYXRlVUJPTWFwcGluZyggdW5pZm9ybXNHcm91cCwgd2ViZ2xQcm9ncmFtICk7XG5cblx0XHQvLyB1cGRhdGUgVUJPIG9uY2UgcGVyIGZyYW1lXG5cblx0XHRjb25zdCBmcmFtZSA9IGluZm8ucmVuZGVyLmZyYW1lO1xuXG5cdFx0aWYgKCB1cGRhdGVMaXN0WyB1bmlmb3Jtc0dyb3VwLmlkIF0gIT09IGZyYW1lICkge1xuXG5cdFx0XHR1cGRhdGVCdWZmZXJEYXRhKCB1bmlmb3Jtc0dyb3VwICk7XG5cblx0XHRcdHVwZGF0ZUxpc3RbIHVuaWZvcm1zR3JvdXAuaWQgXSA9IGZyYW1lO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVCdWZmZXIoIHVuaWZvcm1zR3JvdXAgKSB7XG5cblx0XHQvLyB0aGUgc2V0dXAgb2YgYW4gVUJPIGlzIGluZGVwZW5kZW50IG9mIGEgcGFydGljdWxhciBzaGFkZXIgcHJvZ3JhbSBidXQgZ2xvYmFsXG5cblx0XHRjb25zdCBiaW5kaW5nUG9pbnRJbmRleCA9IGFsbG9jYXRlQmluZGluZ1BvaW50SW5kZXgoKTtcblx0XHR1bmlmb3Jtc0dyb3VwLl9fYmluZGluZ1BvaW50SW5kZXggPSBiaW5kaW5nUG9pbnRJbmRleDtcblxuXHRcdGNvbnN0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGNvbnN0IHNpemUgPSB1bmlmb3Jtc0dyb3VwLl9fc2l6ZTtcblx0XHRjb25zdCB1c2FnZSA9IHVuaWZvcm1zR3JvdXAudXNhZ2U7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5VTklGT1JNX0JVRkZFUiwgYnVmZmVyICk7XG5cdFx0Z2wuYnVmZmVyRGF0YSggZ2wuVU5JRk9STV9CVUZGRVIsIHNpemUsIHVzYWdlICk7XG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuVU5JRk9STV9CVUZGRVIsIG51bGwgKTtcblx0XHRnbC5iaW5kQnVmZmVyQmFzZSggZ2wuVU5JRk9STV9CVUZGRVIsIGJpbmRpbmdQb2ludEluZGV4LCBidWZmZXIgKTtcblxuXHRcdHJldHVybiBidWZmZXI7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGFsbG9jYXRlQmluZGluZ1BvaW50SW5kZXgoKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBtYXhCaW5kaW5nUG9pbnRzOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIGFsbG9jYXRlZEJpbmRpbmdQb2ludHMuaW5kZXhPZiggaSApID09PSAtIDEgKSB7XG5cblx0XHRcdFx0YWxsb2NhdGVkQmluZGluZ1BvaW50cy5wdXNoKCBpICk7XG5cdFx0XHRcdHJldHVybiBpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogTWF4aW11bSBudW1iZXIgb2Ygc2ltdWx0YW5lb3VzbHkgdXNhYmxlIHVuaWZvcm1zIGdyb3VwcyByZWFjaGVkLicgKTtcblxuXHRcdHJldHVybiAwO1xuXG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVCdWZmZXJEYXRhKCB1bmlmb3Jtc0dyb3VwICkge1xuXG5cdFx0Y29uc3QgYnVmZmVyID0gYnVmZmVyc1sgdW5pZm9ybXNHcm91cC5pZCBdO1xuXHRcdGNvbnN0IHVuaWZvcm1zID0gdW5pZm9ybXNHcm91cC51bmlmb3Jtcztcblx0XHRjb25zdCBjYWNoZSA9IHVuaWZvcm1zR3JvdXAuX19jYWNoZTtcblxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLlVOSUZPUk1fQlVGRkVSLCBidWZmZXIgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSB1bmlmb3Jtcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgdW5pZm9ybUFycmF5ID0gQXJyYXkuaXNBcnJheSggdW5pZm9ybXNbIGkgXSApID8gdW5pZm9ybXNbIGkgXSA6IFsgdW5pZm9ybXNbIGkgXSBdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gdW5pZm9ybUFycmF5Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHVuaWZvcm0gPSB1bmlmb3JtQXJyYXlbIGogXTtcblxuXHRcdFx0XHRpZiAoIGhhc1VuaWZvcm1DaGFuZ2VkKCB1bmlmb3JtLCBpLCBqLCBjYWNoZSApID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gdW5pZm9ybS5fX29mZnNldDtcblxuXHRcdFx0XHRcdGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkoIHVuaWZvcm0udmFsdWUgKSA/IHVuaWZvcm0udmFsdWUgOiBbIHVuaWZvcm0udmFsdWUgXTtcblxuXHRcdFx0XHRcdGxldCBhcnJheU9mZnNldCA9IDA7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgayA9IDA7IGsgPCB2YWx1ZXMubGVuZ3RoOyBrICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IHZhbHVlc1sgayBdO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBpbmZvID0gZ2V0VW5pZm9ybVNpemUoIHZhbHVlICk7XG5cblx0XHRcdFx0XHRcdC8vIFRPRE8gYWRkIGludGVnZXIgYW5kIHN0cnVjdCBzdXBwb3J0XG5cdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgKSB7XG5cblx0XHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbIDAgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRnbC5idWZmZXJTdWJEYXRhKCBnbC5VTklGT1JNX0JVRkZFUiwgb2Zmc2V0ICsgYXJyYXlPZmZzZXQsIHVuaWZvcm0uX19kYXRhICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlLmlzTWF0cml4MyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBtYW51YWxseSBjb252ZXJ0aW5nIDN4MyB0byAzeDRcblxuXHRcdFx0XHRcdFx0XHR1bmlmb3JtLl9fZGF0YVsgMCBdID0gdmFsdWUuZWxlbWVudHNbIDAgXTtcblx0XHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbIDEgXSA9IHZhbHVlLmVsZW1lbnRzWyAxIF07XG5cdFx0XHRcdFx0XHRcdHVuaWZvcm0uX19kYXRhWyAyIF0gPSB2YWx1ZS5lbGVtZW50c1sgMiBdO1xuXHRcdFx0XHRcdFx0XHR1bmlmb3JtLl9fZGF0YVsgMyBdID0gMDtcblx0XHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbIDQgXSA9IHZhbHVlLmVsZW1lbnRzWyAzIF07XG5cdFx0XHRcdFx0XHRcdHVuaWZvcm0uX19kYXRhWyA1IF0gPSB2YWx1ZS5lbGVtZW50c1sgNCBdO1xuXHRcdFx0XHRcdFx0XHR1bmlmb3JtLl9fZGF0YVsgNiBdID0gdmFsdWUuZWxlbWVudHNbIDUgXTtcblx0XHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbIDcgXSA9IDA7XG5cdFx0XHRcdFx0XHRcdHVuaWZvcm0uX19kYXRhWyA4IF0gPSB2YWx1ZS5lbGVtZW50c1sgNiBdO1xuXHRcdFx0XHRcdFx0XHR1bmlmb3JtLl9fZGF0YVsgOSBdID0gdmFsdWUuZWxlbWVudHNbIDcgXTtcblx0XHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbIDEwIF0gPSB2YWx1ZS5lbGVtZW50c1sgOCBdO1xuXHRcdFx0XHRcdFx0XHR1bmlmb3JtLl9fZGF0YVsgMTEgXSA9IDA7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0dmFsdWUudG9BcnJheSggdW5pZm9ybS5fX2RhdGEsIGFycmF5T2Zmc2V0ICk7XG5cblx0XHRcdFx0XHRcdFx0YXJyYXlPZmZzZXQgKz0gaW5mby5zdG9yYWdlIC8gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRnbC5idWZmZXJTdWJEYXRhKCBnbC5VTklGT1JNX0JVRkZFUiwgb2Zmc2V0LCB1bmlmb3JtLl9fZGF0YSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuVU5JRk9STV9CVUZGRVIsIG51bGwgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFzVW5pZm9ybUNoYW5nZWQoIHVuaWZvcm0sIGluZGV4LCBpbmRleEFycmF5LCBjYWNoZSApIHtcblxuXHRcdGNvbnN0IHZhbHVlID0gdW5pZm9ybS52YWx1ZTtcblx0XHRjb25zdCBpbmRleFN0cmluZyA9IGluZGV4ICsgJ18nICsgaW5kZXhBcnJheTtcblxuXHRcdGlmICggY2FjaGVbIGluZGV4U3RyaW5nIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gY2FjaGUgZW50cnkgZG9lcyBub3QgZXhpc3Qgc28gZmFyXG5cblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyApIHtcblxuXHRcdFx0XHRjYWNoZVsgaW5kZXhTdHJpbmcgXSA9IHZhbHVlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNhY2hlWyBpbmRleFN0cmluZyBdID0gdmFsdWUuY2xvbmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGNhY2hlZE9iamVjdCA9IGNhY2hlWyBpbmRleFN0cmluZyBdO1xuXG5cdFx0XHQvLyBjb21wYXJlIGN1cnJlbnQgdmFsdWUgd2l0aCBjYWNoZWQgZW50cnlcblxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nICkge1xuXG5cdFx0XHRcdGlmICggY2FjaGVkT2JqZWN0ICE9PSB2YWx1ZSApIHtcblxuXHRcdFx0XHRcdGNhY2hlWyBpbmRleFN0cmluZyBdID0gdmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggY2FjaGVkT2JqZWN0LmVxdWFscyggdmFsdWUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRjYWNoZWRPYmplY3QuY29weSggdmFsdWUgKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcHJlcGFyZVVuaWZvcm1zR3JvdXAoIHVuaWZvcm1zR3JvdXAgKSB7XG5cblx0XHQvLyBkZXRlcm1pbmUgdG90YWwgYnVmZmVyIHNpemUgYWNjb3JkaW5nIHRvIHRoZSBTVEQxNDAgbGF5b3V0XG5cdFx0Ly8gSGludDogU1REMTQwIGlzIHRoZSBvbmx5IHN1cHBvcnRlZCBsYXlvdXQgaW4gV2ViR0wgMlxuXG5cdFx0Y29uc3QgdW5pZm9ybXMgPSB1bmlmb3Jtc0dyb3VwLnVuaWZvcm1zO1xuXG5cdFx0bGV0IG9mZnNldCA9IDA7IC8vIGdsb2JhbCBidWZmZXIgb2Zmc2V0IGluIGJ5dGVzXG5cdFx0Y29uc3QgY2h1bmtTaXplID0gMTY7IC8vIHNpemUgb2YgYSBjaHVuayBpbiBieXRlc1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdW5pZm9ybXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgdW5pZm9ybUFycmF5ID0gQXJyYXkuaXNBcnJheSggdW5pZm9ybXNbIGkgXSApID8gdW5pZm9ybXNbIGkgXSA6IFsgdW5pZm9ybXNbIGkgXSBdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gdW5pZm9ybUFycmF5Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHVuaWZvcm0gPSB1bmlmb3JtQXJyYXlbIGogXTtcblxuXHRcdFx0XHRjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KCB1bmlmb3JtLnZhbHVlICkgPyB1bmlmb3JtLnZhbHVlIDogWyB1bmlmb3JtLnZhbHVlIF07XG5cblx0XHRcdFx0Zm9yICggbGV0IGsgPSAwLCBrbCA9IHZhbHVlcy5sZW5ndGg7IGsgPCBrbDsgayArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gdmFsdWVzWyBrIF07XG5cblx0XHRcdFx0XHRjb25zdCBpbmZvID0gZ2V0VW5pZm9ybVNpemUoIHZhbHVlICk7XG5cblx0XHRcdFx0XHRjb25zdCBjaHVua09mZnNldCA9IG9mZnNldCAlIGNodW5rU2l6ZTsgLy8gb2Zmc2V0IGluIHRoZSBjdXJyZW50IGNodW5rXG5cdFx0XHRcdFx0Y29uc3QgY2h1bmtQYWRkaW5nID0gY2h1bmtPZmZzZXQgJSBpbmZvLmJvdW5kYXJ5OyAvLyByZXF1aXJlZCBwYWRkaW5nIHRvIG1hdGNoIGJvdW5kYXJ5XG5cdFx0XHRcdFx0Y29uc3QgY2h1bmtTdGFydCA9IGNodW5rT2Zmc2V0ICsgY2h1bmtQYWRkaW5nOyAvLyB0aGUgc3RhcnQgcG9zaXRpb24gaW4gdGhlIGN1cnJlbnQgY2h1bmsgZm9yIHRoZSBkYXRhXG5cblx0XHRcdFx0XHRvZmZzZXQgKz0gY2h1bmtQYWRkaW5nO1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZm9yIGNodW5rIG92ZXJmbG93XG5cdFx0XHRcdFx0aWYgKCBjaHVua1N0YXJ0ICE9PSAwICYmICggY2h1bmtTaXplIC0gY2h1bmtTdGFydCApIDwgaW5mby5zdG9yYWdlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBBZGQgcGFkZGluZyBhbmQgYWRqdXN0IG9mZnNldFxuXHRcdFx0XHRcdFx0b2Zmc2V0ICs9ICggY2h1bmtTaXplIC0gY2h1bmtTdGFydCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gdGhlIGZvbGxvd2luZyB0d28gcHJvcGVydGllcyB3aWxsIGJlIHVzZWQgZm9yIHBhcnRpYWwgYnVmZmVyIHVwZGF0ZXNcblx0XHRcdFx0XHR1bmlmb3JtLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoIGluZm8uc3RvcmFnZSAvIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCApO1xuXHRcdFx0XHRcdHVuaWZvcm0uX19vZmZzZXQgPSBvZmZzZXQ7XG5cblx0XHRcdFx0XHQvLyBVcGRhdGUgdGhlIGdsb2JhbCBvZmZzZXRcblx0XHRcdFx0XHRvZmZzZXQgKz0gaW5mby5zdG9yYWdlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZW5zdXJlIGNvcnJlY3QgZmluYWwgcGFkZGluZ1xuXG5cdFx0Y29uc3QgY2h1bmtPZmZzZXQgPSBvZmZzZXQgJSBjaHVua1NpemU7XG5cblx0XHRpZiAoIGNodW5rT2Zmc2V0ID4gMCApIG9mZnNldCArPSAoIGNodW5rU2l6ZSAtIGNodW5rT2Zmc2V0ICk7XG5cblx0XHQvL1xuXG5cdFx0dW5pZm9ybXNHcm91cC5fX3NpemUgPSBvZmZzZXQ7XG5cdFx0dW5pZm9ybXNHcm91cC5fX2NhY2hlID0ge307XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VW5pZm9ybVNpemUoIHZhbHVlICkge1xuXG5cdFx0Y29uc3QgaW5mbyA9IHtcblx0XHRcdGJvdW5kYXJ5OiAwLCAvLyBieXRlc1xuXHRcdFx0c3RvcmFnZTogMCAvLyBieXRlc1xuXHRcdH07XG5cblx0XHQvLyBkZXRlcm1pbmUgc2l6ZXMgYWNjb3JkaW5nIHRvIFNURDE0MFxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nICkge1xuXG5cdFx0XHQvLyBmbG9hdC9pbnQvYm9vbFxuXG5cdFx0XHRpbmZvLmJvdW5kYXJ5ID0gNDtcblx0XHRcdGluZm8uc3RvcmFnZSA9IDQ7XG5cblx0XHR9IGVsc2UgaWYgKCB2YWx1ZS5pc1ZlY3RvcjIgKSB7XG5cblx0XHRcdC8vIHZlYzJcblxuXHRcdFx0aW5mby5ib3VuZGFyeSA9IDg7XG5cdFx0XHRpbmZvLnN0b3JhZ2UgPSA4O1xuXG5cdFx0fSBlbHNlIGlmICggdmFsdWUuaXNWZWN0b3IzIHx8IHZhbHVlLmlzQ29sb3IgKSB7XG5cblx0XHRcdC8vIHZlYzNcblxuXHRcdFx0aW5mby5ib3VuZGFyeSA9IDE2O1xuXHRcdFx0aW5mby5zdG9yYWdlID0gMTI7IC8vIGV2aWw6IHZlYzMgbXVzdCBzdGFydCBvbiBhIDE2LWJ5dGUgYm91bmRhcnkgYnV0IGl0IG9ubHkgY29uc3VtZXMgMTIgYnl0ZXNcblxuXHRcdH0gZWxzZSBpZiAoIHZhbHVlLmlzVmVjdG9yNCApIHtcblxuXHRcdFx0Ly8gdmVjNFxuXG5cdFx0XHRpbmZvLmJvdW5kYXJ5ID0gMTY7XG5cdFx0XHRpbmZvLnN0b3JhZ2UgPSAxNjtcblxuXHRcdH0gZWxzZSBpZiAoIHZhbHVlLmlzTWF0cml4MyApIHtcblxuXHRcdFx0Ly8gbWF0MyAoaW4gU1REMTQwIGEgM3gzIG1hdHJpeCBpcyByZXByZXNlbnRlZCBhcyAzeDQpXG5cblx0XHRcdGluZm8uYm91bmRhcnkgPSA0ODtcblx0XHRcdGluZm8uc3RvcmFnZSA9IDQ4O1xuXG5cdFx0fSBlbHNlIGlmICggdmFsdWUuaXNNYXRyaXg0ICkge1xuXG5cdFx0XHQvLyBtYXQ0XG5cblx0XHRcdGluZm8uYm91bmRhcnkgPSA2NDtcblx0XHRcdGluZm8uc3RvcmFnZSA9IDY0O1xuXG5cdFx0fSBlbHNlIGlmICggdmFsdWUuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIHNhbXBsZXJzIGNhbiBub3QgYmUgcGFydCBvZiBhbiB1bmlmb3JtcyBncm91cC4nICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBVbnN1cHBvcnRlZCB1bmlmb3JtIHZhbHVlIHR5cGUuJywgdmFsdWUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBpbmZvO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvblVuaWZvcm1zR3JvdXBzRGlzcG9zZSggZXZlbnQgKSB7XG5cblx0XHRjb25zdCB1bmlmb3Jtc0dyb3VwID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0dW5pZm9ybXNHcm91cC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVW5pZm9ybXNHcm91cHNEaXNwb3NlICk7XG5cblx0XHRjb25zdCBpbmRleCA9IGFsbG9jYXRlZEJpbmRpbmdQb2ludHMuaW5kZXhPZiggdW5pZm9ybXNHcm91cC5fX2JpbmRpbmdQb2ludEluZGV4ICk7XG5cdFx0YWxsb2NhdGVkQmluZGluZ1BvaW50cy5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRnbC5kZWxldGVCdWZmZXIoIGJ1ZmZlcnNbIHVuaWZvcm1zR3JvdXAuaWQgXSApO1xuXG5cdFx0ZGVsZXRlIGJ1ZmZlcnNbIHVuaWZvcm1zR3JvdXAuaWQgXTtcblx0XHRkZWxldGUgdXBkYXRlTGlzdFsgdW5pZm9ybXNHcm91cC5pZCBdO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBkaXNwb3NlKCkge1xuXG5cdFx0Zm9yICggY29uc3QgaWQgaW4gYnVmZmVycyApIHtcblxuXHRcdFx0Z2wuZGVsZXRlQnVmZmVyKCBidWZmZXJzWyBpZCBdICk7XG5cblx0XHR9XG5cblx0XHRhbGxvY2F0ZWRCaW5kaW5nUG9pbnRzID0gW107XG5cdFx0YnVmZmVycyA9IHt9O1xuXHRcdHVwZGF0ZUxpc3QgPSB7fTtcblxuXHR9XG5cblx0cmV0dXJuIHtcblxuXHRcdGJpbmQ6IGJpbmQsXG5cdFx0dXBkYXRlOiB1cGRhdGUsXG5cblx0XHRkaXNwb3NlOiBkaXNwb3NlXG5cblx0fTtcblxufVxuXG5jbGFzcyBXZWJHTFJlbmRlcmVyIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyA9IHt9ICkge1xuXG5cdFx0Y29uc3Qge1xuXHRcdFx0Y2FudmFzID0gY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxuXHRcdFx0Y29udGV4dCA9IG51bGwsXG5cdFx0XHRkZXB0aCA9IHRydWUsXG5cdFx0XHRzdGVuY2lsID0gZmFsc2UsXG5cdFx0XHRhbHBoYSA9IGZhbHNlLFxuXHRcdFx0YW50aWFsaWFzID0gZmFsc2UsXG5cdFx0XHRwcmVtdWx0aXBsaWVkQWxwaGEgPSB0cnVlLFxuXHRcdFx0cHJlc2VydmVEcmF3aW5nQnVmZmVyID0gZmFsc2UsXG5cdFx0XHRwb3dlclByZWZlcmVuY2UgPSAnZGVmYXVsdCcsXG5cdFx0XHRmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0ID0gZmFsc2UsXG5cdFx0XHRyZXZlcnNlRGVwdGhCdWZmZXIgPSBmYWxzZSxcblx0XHR9ID0gcGFyYW1ldGVycztcblxuXHRcdHRoaXMuaXNXZWJHTFJlbmRlcmVyID0gdHJ1ZTtcblxuXHRcdGxldCBfYWxwaGE7XG5cblx0XHRpZiAoIGNvbnRleHQgIT09IG51bGwgKSB7XG5cblx0XHRcdGlmICggdHlwZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcgJiYgY29udGV4dCBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBXZWJHTCAxIGlzIG5vdCBzdXBwb3J0ZWQgc2luY2UgcjE2My4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X2FscGhhID0gY29udGV4dC5nZXRDb250ZXh0QXR0cmlidXRlcygpLmFscGhhO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X2FscGhhID0gYWxwaGE7XG5cblx0XHR9XG5cblx0XHRjb25zdCB1aW50Q2xlYXJDb2xvciA9IG5ldyBVaW50MzJBcnJheSggNCApO1xuXHRcdGNvbnN0IGludENsZWFyQ29sb3IgPSBuZXcgSW50MzJBcnJheSggNCApO1xuXG5cdFx0bGV0IGN1cnJlbnRSZW5kZXJMaXN0ID0gbnVsbDtcblx0XHRsZXQgY3VycmVudFJlbmRlclN0YXRlID0gbnVsbDtcblxuXHRcdC8vIHJlbmRlcigpIGNhbiBiZSBjYWxsZWQgZnJvbSB3aXRoaW4gYSBjYWxsYmFjayB0cmlnZ2VyZWQgYnkgYW5vdGhlciByZW5kZXIuXG5cdFx0Ly8gV2UgdHJhY2sgdGhpcyBzbyB0aGF0IHRoZSBuZXN0ZWQgcmVuZGVyIGNhbGwgZ2V0cyBpdHMgbGlzdCBhbmQgc3RhdGUgaXNvbGF0ZWQgZnJvbSB0aGUgcGFyZW50IHJlbmRlciBjYWxsLlxuXG5cdFx0Y29uc3QgcmVuZGVyTGlzdFN0YWNrID0gW107XG5cdFx0Y29uc3QgcmVuZGVyU3RhdGVTdGFjayA9IFtdO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblxuXHRcdHRoaXMuZG9tRWxlbWVudCA9IGNhbnZhcztcblxuXHRcdC8vIERlYnVnIGNvbmZpZ3VyYXRpb24gY29udGFpbmVyXG5cdFx0dGhpcy5kZWJ1ZyA9IHtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBFbmFibGVzIGVycm9yIGNoZWNraW5nIGFuZCByZXBvcnRpbmcgd2hlbiBzaGFkZXIgcHJvZ3JhbXMgYXJlIGJlaW5nIGNvbXBpbGVkXG5cdFx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHRcdCAqL1xuXHRcdFx0Y2hlY2tTaGFkZXJFcnJvcnM6IHRydWUsXG5cdFx0XHQvKipcblx0XHRcdCAqIENhbGxiYWNrIGZvciBjdXN0b20gZXJyb3IgcmVwb3J0aW5nLlxuXHRcdFx0ICogQHR5cGUgez9GdW5jdGlvbn1cblx0XHRcdCAqL1xuXHRcdFx0b25TaGFkZXJFcnJvcjogbnVsbFxuXHRcdH07XG5cblx0XHQvLyBjbGVhcmluZ1xuXG5cdFx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xuXHRcdHRoaXMuYXV0b0NsZWFyQ29sb3IgPSB0cnVlO1xuXHRcdHRoaXMuYXV0b0NsZWFyRGVwdGggPSB0cnVlO1xuXHRcdHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9IHRydWU7XG5cblx0XHQvLyBzY2VuZSBncmFwaFxuXG5cdFx0dGhpcy5zb3J0T2JqZWN0cyA9IHRydWU7XG5cblx0XHQvLyB1c2VyLWRlZmluZWQgY2xpcHBpbmdcblxuXHRcdHRoaXMuY2xpcHBpbmdQbGFuZXMgPSBbXTtcblx0XHR0aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkID0gZmFsc2U7XG5cblx0XHQvLyBwaHlzaWNhbGx5IGJhc2VkIHNoYWRpbmdcblxuXHRcdHRoaXMuX291dHB1dENvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZTtcblxuXHRcdC8vIHRvbmUgbWFwcGluZ1xuXG5cdFx0dGhpcy50b25lTWFwcGluZyA9IE5vVG9uZU1hcHBpbmc7XG5cdFx0dGhpcy50b25lTWFwcGluZ0V4cG9zdXJlID0gMS4wO1xuXG5cdFx0Ly8gaW50ZXJuYWwgcHJvcGVydGllc1xuXG5cdFx0Y29uc3QgX3RoaXMgPSB0aGlzO1xuXG5cdFx0bGV0IF9pc0NvbnRleHRMb3N0ID0gZmFsc2U7XG5cblx0XHQvLyBpbnRlcm5hbCBzdGF0ZSBjYWNoZVxuXG5cdFx0bGV0IF9jdXJyZW50QWN0aXZlQ3ViZUZhY2UgPSAwO1xuXHRcdGxldCBfY3VycmVudEFjdGl2ZU1pcG1hcExldmVsID0gMDtcblx0XHRsZXQgX2N1cnJlbnRSZW5kZXJUYXJnZXQgPSBudWxsO1xuXHRcdGxldCBfY3VycmVudE1hdGVyaWFsSWQgPSAtIDE7XG5cblx0XHRsZXQgX2N1cnJlbnRDYW1lcmEgPSBudWxsO1xuXG5cdFx0Y29uc3QgX2N1cnJlbnRWaWV3cG9ydCA9IG5ldyBWZWN0b3I0KCk7XG5cdFx0Y29uc3QgX2N1cnJlbnRTY2lzc29yID0gbmV3IFZlY3RvcjQoKTtcblx0XHRsZXQgX2N1cnJlbnRTY2lzc29yVGVzdCA9IG51bGw7XG5cblx0XHRjb25zdCBfY3VycmVudENsZWFyQ29sb3IgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XG5cdFx0bGV0IF9jdXJyZW50Q2xlYXJBbHBoYSA9IDA7XG5cblx0XHQvL1xuXG5cdFx0bGV0IF93aWR0aCA9IGNhbnZhcy53aWR0aDtcblx0XHRsZXQgX2hlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG5cblx0XHRsZXQgX3BpeGVsUmF0aW8gPSAxO1xuXHRcdGxldCBfb3BhcXVlU29ydCA9IG51bGw7XG5cdFx0bGV0IF90cmFuc3BhcmVudFNvcnQgPSBudWxsO1xuXG5cdFx0Y29uc3QgX3ZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoIDAsIDAsIF93aWR0aCwgX2hlaWdodCApO1xuXHRcdGNvbnN0IF9zY2lzc29yID0gbmV3IFZlY3RvcjQoIDAsIDAsIF93aWR0aCwgX2hlaWdodCApO1xuXHRcdGxldCBfc2Npc3NvclRlc3QgPSBmYWxzZTtcblxuXHRcdC8vIGZydXN0dW1cblxuXHRcdGNvbnN0IF9mcnVzdHVtID0gbmV3IEZydXN0dW0oKTtcblxuXHRcdC8vIGNsaXBwaW5nXG5cblx0XHRsZXQgX2NsaXBwaW5nRW5hYmxlZCA9IGZhbHNlO1xuXHRcdGxldCBfbG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBmYWxzZTtcblxuXHRcdC8vIHRyYW5zbWlzc2lvbiByZW5kZXIgdGFyZ2V0IHNjYWxlXG5cdFx0dGhpcy50cmFuc21pc3Npb25SZXNvbHV0aW9uU2NhbGUgPSAxLjA7XG5cblx0XHQvLyBjYW1lcmEgbWF0cmljZXMgY2FjaGVcblxuXHRcdGNvbnN0IF9jdXJyZW50UHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0Y29uc3QgX3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0Y29uc3QgX3ZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Y29uc3QgX3ZlY3RvcjQgPSBuZXcgVmVjdG9yNCgpO1xuXG5cdFx0Y29uc3QgX2VtcHR5U2NlbmUgPSB7IGJhY2tncm91bmQ6IG51bGwsIGZvZzogbnVsbCwgZW52aXJvbm1lbnQ6IG51bGwsIG92ZXJyaWRlTWF0ZXJpYWw6IG51bGwsIGlzU2NlbmU6IHRydWUgfTtcblxuXHRcdGxldCBfcmVuZGVyQmFja2dyb3VuZCA9IGZhbHNlO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0VGFyZ2V0UGl4ZWxSYXRpbygpIHtcblxuXHRcdFx0cmV0dXJuIF9jdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsID8gX3BpeGVsUmF0aW8gOiAxO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaW5pdGlhbGl6ZVxuXG5cdFx0bGV0IF9nbCA9IGNvbnRleHQ7XG5cblx0XHRmdW5jdGlvbiBnZXRDb250ZXh0KCBjb250ZXh0TmFtZSwgY29udGV4dEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdHJldHVybiBjYW52YXMuZ2V0Q29udGV4dCggY29udGV4dE5hbWUsIGNvbnRleHRBdHRyaWJ1dGVzICk7XG5cblx0XHR9XG5cblx0XHR0cnkge1xuXG5cdFx0XHRjb25zdCBjb250ZXh0QXR0cmlidXRlcyA9IHtcblx0XHRcdFx0YWxwaGE6IHRydWUsXG5cdFx0XHRcdGRlcHRoLFxuXHRcdFx0XHRzdGVuY2lsLFxuXHRcdFx0XHRhbnRpYWxpYXMsXG5cdFx0XHRcdHByZW11bHRpcGxpZWRBbHBoYSxcblx0XHRcdFx0cHJlc2VydmVEcmF3aW5nQnVmZmVyLFxuXHRcdFx0XHRwb3dlclByZWZlcmVuY2UsXG5cdFx0XHRcdGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQsXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBPZmZzY3JlZW5DYW52YXMgZG9lcyBub3QgaGF2ZSBzZXRBdHRyaWJ1dGUsIHNlZSAjMjI4MTFcblx0XHRcdGlmICggJ3NldEF0dHJpYnV0ZScgaW4gY2FudmFzICkgY2FudmFzLnNldEF0dHJpYnV0ZSggJ2RhdGEtZW5naW5lJywgYHRocmVlLmpzIHIke1JFVklTSU9OfWAgKTtcblxuXHRcdFx0Ly8gZXZlbnQgbGlzdGVuZXJzIG11c3QgYmUgcmVnaXN0ZXJlZCBiZWZvcmUgV2ViR0wgY29udGV4dCBpcyBjcmVhdGVkLCBzZWUgIzEyNzUzXG5cdFx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dGxvc3QnLCBvbkNvbnRleHRMb3N0LCBmYWxzZSApO1xuXHRcdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIG9uQ29udGV4dFJlc3RvcmUsIGZhbHNlICk7XG5cdFx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dGNyZWF0aW9uZXJyb3InLCBvbkNvbnRleHRDcmVhdGlvbkVycm9yLCBmYWxzZSApO1xuXG5cdFx0XHRpZiAoIF9nbCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRjb25zdCBjb250ZXh0TmFtZSA9ICd3ZWJnbDInO1xuXG5cdFx0XHRcdF9nbCA9IGdldENvbnRleHQoIGNvbnRleHROYW1lLCBjb250ZXh0QXR0cmlidXRlcyApO1xuXG5cdFx0XHRcdGlmICggX2dsID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0aWYgKCBnZXRDb250ZXh0KCBjb250ZXh0TmFtZSApICkge1xuXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0IHdpdGggeW91ciBzZWxlY3RlZCBhdHRyaWJ1dGVzLicgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQuJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIGVycm9yLm1lc3NhZ2UgKTtcblx0XHRcdHRocm93IGVycm9yO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcywgc3RhdGUsIGluZm87XG5cdFx0bGV0IHByb3BlcnRpZXMsIHRleHR1cmVzLCBjdWJlbWFwcywgY3ViZXV2bWFwcywgYXR0cmlidXRlcywgZ2VvbWV0cmllcywgb2JqZWN0cztcblx0XHRsZXQgcHJvZ3JhbUNhY2hlLCBtYXRlcmlhbHMsIHJlbmRlckxpc3RzLCByZW5kZXJTdGF0ZXMsIGNsaXBwaW5nLCBzaGFkb3dNYXA7XG5cblx0XHRsZXQgYmFja2dyb3VuZCwgbW9ycGh0YXJnZXRzLCBidWZmZXJSZW5kZXJlciwgaW5kZXhlZEJ1ZmZlclJlbmRlcmVyO1xuXG5cdFx0bGV0IHV0aWxzLCBiaW5kaW5nU3RhdGVzLCB1bmlmb3Jtc0dyb3VwcztcblxuXHRcdGZ1bmN0aW9uIGluaXRHTENvbnRleHQoKSB7XG5cblx0XHRcdGV4dGVuc2lvbnMgPSBuZXcgV2ViR0xFeHRlbnNpb25zKCBfZ2wgKTtcblx0XHRcdGV4dGVuc2lvbnMuaW5pdCgpO1xuXG5cdFx0XHR1dGlscyA9IG5ldyBXZWJHTFV0aWxzKCBfZ2wsIGV4dGVuc2lvbnMgKTtcblxuXHRcdFx0Y2FwYWJpbGl0aWVzID0gbmV3IFdlYkdMQ2FwYWJpbGl0aWVzKCBfZ2wsIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMsIHV0aWxzICk7XG5cblx0XHRcdHN0YXRlID0gbmV3IFdlYkdMU3RhdGUoIF9nbCwgZXh0ZW5zaW9ucyApO1xuXG5cdFx0XHRpZiAoIGNhcGFiaWxpdGllcy5yZXZlcnNlRGVwdGhCdWZmZXIgJiYgcmV2ZXJzZURlcHRoQnVmZmVyICkge1xuXG5cdFx0XHRcdHN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0UmV2ZXJzZWQoIHRydWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpbmZvID0gbmV3IFdlYkdMSW5mbyggX2dsICk7XG5cdFx0XHRwcm9wZXJ0aWVzID0gbmV3IFdlYkdMUHJvcGVydGllcygpO1xuXHRcdFx0dGV4dHVyZXMgPSBuZXcgV2ViR0xUZXh0dXJlcyggX2dsLCBleHRlbnNpb25zLCBzdGF0ZSwgcHJvcGVydGllcywgY2FwYWJpbGl0aWVzLCB1dGlscywgaW5mbyApO1xuXHRcdFx0Y3ViZW1hcHMgPSBuZXcgV2ViR0xDdWJlTWFwcyggX3RoaXMgKTtcblx0XHRcdGN1YmV1dm1hcHMgPSBuZXcgV2ViR0xDdWJlVVZNYXBzKCBfdGhpcyApO1xuXHRcdFx0YXR0cmlidXRlcyA9IG5ldyBXZWJHTEF0dHJpYnV0ZXMoIF9nbCApO1xuXHRcdFx0YmluZGluZ1N0YXRlcyA9IG5ldyBXZWJHTEJpbmRpbmdTdGF0ZXMoIF9nbCwgYXR0cmlidXRlcyApO1xuXHRcdFx0Z2VvbWV0cmllcyA9IG5ldyBXZWJHTEdlb21ldHJpZXMoIF9nbCwgYXR0cmlidXRlcywgaW5mbywgYmluZGluZ1N0YXRlcyApO1xuXHRcdFx0b2JqZWN0cyA9IG5ldyBXZWJHTE9iamVjdHMoIF9nbCwgZ2VvbWV0cmllcywgYXR0cmlidXRlcywgaW5mbyApO1xuXHRcdFx0bW9ycGh0YXJnZXRzID0gbmV3IFdlYkdMTW9ycGh0YXJnZXRzKCBfZ2wsIGNhcGFiaWxpdGllcywgdGV4dHVyZXMgKTtcblx0XHRcdGNsaXBwaW5nID0gbmV3IFdlYkdMQ2xpcHBpbmcoIHByb3BlcnRpZXMgKTtcblx0XHRcdHByb2dyYW1DYWNoZSA9IG5ldyBXZWJHTFByb2dyYW1zKCBfdGhpcywgY3ViZW1hcHMsIGN1YmV1dm1hcHMsIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcywgYmluZGluZ1N0YXRlcywgY2xpcHBpbmcgKTtcblx0XHRcdG1hdGVyaWFscyA9IG5ldyBXZWJHTE1hdGVyaWFscyggX3RoaXMsIHByb3BlcnRpZXMgKTtcblx0XHRcdHJlbmRlckxpc3RzID0gbmV3IFdlYkdMUmVuZGVyTGlzdHMoKTtcblx0XHRcdHJlbmRlclN0YXRlcyA9IG5ldyBXZWJHTFJlbmRlclN0YXRlcyggZXh0ZW5zaW9ucyApO1xuXHRcdFx0YmFja2dyb3VuZCA9IG5ldyBXZWJHTEJhY2tncm91bmQoIF90aGlzLCBjdWJlbWFwcywgY3ViZXV2bWFwcywgc3RhdGUsIG9iamVjdHMsIF9hbHBoYSwgcHJlbXVsdGlwbGllZEFscGhhICk7XG5cdFx0XHRzaGFkb3dNYXAgPSBuZXcgV2ViR0xTaGFkb3dNYXAoIF90aGlzLCBvYmplY3RzLCBjYXBhYmlsaXRpZXMgKTtcblx0XHRcdHVuaWZvcm1zR3JvdXBzID0gbmV3IFdlYkdMVW5pZm9ybXNHcm91cHMoIF9nbCwgaW5mbywgY2FwYWJpbGl0aWVzLCBzdGF0ZSApO1xuXG5cdFx0XHRidWZmZXJSZW5kZXJlciA9IG5ldyBXZWJHTEJ1ZmZlclJlbmRlcmVyKCBfZ2wsIGV4dGVuc2lvbnMsIGluZm8gKTtcblx0XHRcdGluZGV4ZWRCdWZmZXJSZW5kZXJlciA9IG5ldyBXZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlciggX2dsLCBleHRlbnNpb25zLCBpbmZvICk7XG5cblx0XHRcdGluZm8ucHJvZ3JhbXMgPSBwcm9ncmFtQ2FjaGUucHJvZ3JhbXM7XG5cblx0XHRcdF90aGlzLmNhcGFiaWxpdGllcyA9IGNhcGFiaWxpdGllcztcblx0XHRcdF90aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuXHRcdFx0X3RoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG5cdFx0XHRfdGhpcy5yZW5kZXJMaXN0cyA9IHJlbmRlckxpc3RzO1xuXHRcdFx0X3RoaXMuc2hhZG93TWFwID0gc2hhZG93TWFwO1xuXHRcdFx0X3RoaXMuc3RhdGUgPSBzdGF0ZTtcblx0XHRcdF90aGlzLmluZm8gPSBpbmZvO1xuXG5cdFx0fVxuXG5cdFx0aW5pdEdMQ29udGV4dCgpO1xuXG5cdFx0Ly8geHJcblxuXHRcdGNvbnN0IHhyID0gbmV3IFdlYlhSTWFuYWdlciggX3RoaXMsIF9nbCApO1xuXG5cdFx0dGhpcy54ciA9IHhyO1xuXG5cdFx0Ly8gQVBJXG5cblx0XHR0aGlzLmdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBfZ2w7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRDb250ZXh0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIF9nbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZm9yY2VDb250ZXh0TG9zcyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc3QgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9sb3NlX2NvbnRleHQnICk7XG5cdFx0XHRpZiAoIGV4dGVuc2lvbiApIGV4dGVuc2lvbi5sb3NlQ29udGV4dCgpO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZm9yY2VDb250ZXh0UmVzdG9yZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc3QgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9sb3NlX2NvbnRleHQnICk7XG5cdFx0XHRpZiAoIGV4dGVuc2lvbiApIGV4dGVuc2lvbi5yZXN0b3JlQ29udGV4dCgpO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIF9waXhlbFJhdGlvO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdFx0X3BpeGVsUmF0aW8gPSB2YWx1ZTtcblxuXHRcdFx0dGhpcy5zZXRTaXplKCBfd2lkdGgsIF9oZWlnaHQsIGZhbHNlICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRTaXplID0gZnVuY3Rpb24gKCB0YXJnZXQgKSB7XG5cblx0XHRcdHJldHVybiB0YXJnZXQuc2V0KCBfd2lkdGgsIF9oZWlnaHQgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlID0gdHJ1ZSApIHtcblxuXHRcdFx0aWYgKCB4ci5pc1ByZXNlbnRpbmcgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQ2FuXFwndCBjaGFuZ2Ugc2l6ZSB3aGlsZSBWUiBkZXZpY2UgaXMgcHJlc2VudGluZy4nICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHRfd2lkdGggPSB3aWR0aDtcblx0XHRcdF9oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHRcdGNhbnZhcy53aWR0aCA9IE1hdGguZmxvb3IoIHdpZHRoICogX3BpeGVsUmF0aW8gKTtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKCBoZWlnaHQgKiBfcGl4ZWxSYXRpbyApO1xuXG5cdFx0XHRpZiAoIHVwZGF0ZVN0eWxlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4Jztcblx0XHRcdFx0Y2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zZXRWaWV3cG9ydCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0RHJhd2luZ0J1ZmZlclNpemUgPSBmdW5jdGlvbiAoIHRhcmdldCApIHtcblxuXHRcdFx0cmV0dXJuIHRhcmdldC5zZXQoIF93aWR0aCAqIF9waXhlbFJhdGlvLCBfaGVpZ2h0ICogX3BpeGVsUmF0aW8gKS5mbG9vcigpO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0RHJhd2luZ0J1ZmZlclNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHBpeGVsUmF0aW8gKSB7XG5cblx0XHRcdF93aWR0aCA9IHdpZHRoO1xuXHRcdFx0X2hlaWdodCA9IGhlaWdodDtcblxuXHRcdFx0X3BpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuXG5cdFx0XHRjYW52YXMud2lkdGggPSBNYXRoLmZsb29yKCB3aWR0aCAqIHBpeGVsUmF0aW8gKTtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKCBoZWlnaHQgKiBwaXhlbFJhdGlvICk7XG5cblx0XHRcdHRoaXMuc2V0Vmlld3BvcnQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldEN1cnJlbnRWaWV3cG9ydCA9IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIF9jdXJyZW50Vmlld3BvcnQgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldFZpZXdwb3J0ID0gZnVuY3Rpb24gKCB0YXJnZXQgKSB7XG5cblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggX3ZpZXdwb3J0ICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRWaWV3cG9ydCA9IGZ1bmN0aW9uICggeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcblxuXHRcdFx0aWYgKCB4LmlzVmVjdG9yNCApIHtcblxuXHRcdFx0XHRfdmlld3BvcnQuc2V0KCB4LngsIHgueSwgeC56LCB4LncgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfdmlld3BvcnQuc2V0KCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0c3RhdGUudmlld3BvcnQoIF9jdXJyZW50Vmlld3BvcnQuY29weSggX3ZpZXdwb3J0ICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICkucm91bmQoKSApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0U2Npc3NvciA9IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIF9zY2lzc29yICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRTY2lzc29yID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0XHRpZiAoIHguaXNWZWN0b3I0ICkge1xuXG5cdFx0XHRcdF9zY2lzc29yLnNldCggeC54LCB4LnksIHgueiwgeC53ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X3NjaXNzb3Iuc2V0KCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0c3RhdGUuc2Npc3NvciggX2N1cnJlbnRTY2lzc29yLmNvcHkoIF9zY2lzc29yICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICkucm91bmQoKSApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0U2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBfc2Npc3NvclRlc3Q7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRTY2lzc29yVGVzdCA9IGZ1bmN0aW9uICggYm9vbGVhbiApIHtcblxuXHRcdFx0c3RhdGUuc2V0U2Npc3NvclRlc3QoIF9zY2lzc29yVGVzdCA9IGJvb2xlYW4gKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNldE9wYXF1ZVNvcnQgPSBmdW5jdGlvbiAoIG1ldGhvZCApIHtcblxuXHRcdFx0X29wYXF1ZVNvcnQgPSBtZXRob2Q7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRUcmFuc3BhcmVudFNvcnQgPSBmdW5jdGlvbiAoIG1ldGhvZCApIHtcblxuXHRcdFx0X3RyYW5zcGFyZW50U29ydCA9IG1ldGhvZDtcblxuXHRcdH07XG5cblx0XHQvLyBDbGVhcmluZ1xuXG5cdFx0dGhpcy5nZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCB0YXJnZXQgKSB7XG5cblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggYmFja2dyb3VuZC5nZXRDbGVhckNvbG9yKCkgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGJhY2tncm91bmQuc2V0Q2xlYXJDb2xvci5hcHBseSggYmFja2dyb3VuZCwgYXJndW1lbnRzICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gYmFja2dyb3VuZC5nZXRDbGVhckFscGhhKCk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRiYWNrZ3JvdW5kLnNldENsZWFyQWxwaGEuYXBwbHkoIGJhY2tncm91bmQsIGFyZ3VtZW50cyApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoIGNvbG9yID0gdHJ1ZSwgZGVwdGggPSB0cnVlLCBzdGVuY2lsID0gdHJ1ZSApIHtcblxuXHRcdFx0bGV0IGJpdHMgPSAwO1xuXG5cdFx0XHRpZiAoIGNvbG9yICkge1xuXG5cdFx0XHRcdC8vIGNoZWNrIGlmIHdlJ3JlIHRyeWluZyB0byBjbGVhciBhbiBpbnRlZ2VyIHRhcmdldFxuXHRcdFx0XHRsZXQgaXNJbnRlZ2VyRm9ybWF0ID0gZmFsc2U7XG5cdFx0XHRcdGlmICggX2N1cnJlbnRSZW5kZXJUYXJnZXQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB0YXJnZXRGb3JtYXQgPSBfY3VycmVudFJlbmRlclRhcmdldC50ZXh0dXJlLmZvcm1hdDtcblx0XHRcdFx0XHRpc0ludGVnZXJGb3JtYXQgPSB0YXJnZXRGb3JtYXQgPT09IFJHQkFJbnRlZ2VyRm9ybWF0IHx8XG5cdFx0XHRcdFx0XHR0YXJnZXRGb3JtYXQgPT09IFJHSW50ZWdlckZvcm1hdCB8fFxuXHRcdFx0XHRcdFx0dGFyZ2V0Rm9ybWF0ID09PSBSZWRJbnRlZ2VyRm9ybWF0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB1c2UgdGhlIGFwcHJvcHJpYXRlIGNsZWFyIGZ1bmN0aW9ucyB0byBjbGVhciB0aGUgdGFyZ2V0IGlmIGl0J3MgYSBzaWduZWRcblx0XHRcdFx0Ly8gb3IgdW5zaWduZWQgaW50ZWdlciB0YXJnZXRcblx0XHRcdFx0aWYgKCBpc0ludGVnZXJGb3JtYXQgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB0YXJnZXRUeXBlID0gX2N1cnJlbnRSZW5kZXJUYXJnZXQudGV4dHVyZS50eXBlO1xuXHRcdFx0XHRcdGNvbnN0IGlzVW5zaWduZWRUeXBlID0gdGFyZ2V0VHlwZSA9PT0gVW5zaWduZWRCeXRlVHlwZSB8fFxuXHRcdFx0XHRcdFx0dGFyZ2V0VHlwZSA9PT0gVW5zaWduZWRJbnRUeXBlIHx8XG5cdFx0XHRcdFx0XHR0YXJnZXRUeXBlID09PSBVbnNpZ25lZFNob3J0VHlwZSB8fFxuXHRcdFx0XHRcdFx0dGFyZ2V0VHlwZSA9PT0gVW5zaWduZWRJbnQyNDhUeXBlIHx8XG5cdFx0XHRcdFx0XHR0YXJnZXRUeXBlID09PSBVbnNpZ25lZFNob3J0NDQ0NFR5cGUgfHxcblx0XHRcdFx0XHRcdHRhcmdldFR5cGUgPT09IFVuc2lnbmVkU2hvcnQ1NTUxVHlwZTtcblxuXHRcdFx0XHRcdGNvbnN0IGNsZWFyQ29sb3IgPSBiYWNrZ3JvdW5kLmdldENsZWFyQ29sb3IoKTtcblx0XHRcdFx0XHRjb25zdCBhID0gYmFja2dyb3VuZC5nZXRDbGVhckFscGhhKCk7XG5cdFx0XHRcdFx0Y29uc3QgciA9IGNsZWFyQ29sb3Iucjtcblx0XHRcdFx0XHRjb25zdCBnID0gY2xlYXJDb2xvci5nO1xuXHRcdFx0XHRcdGNvbnN0IGIgPSBjbGVhckNvbG9yLmI7XG5cblx0XHRcdFx0XHRpZiAoIGlzVW5zaWduZWRUeXBlICkge1xuXG5cdFx0XHRcdFx0XHR1aW50Q2xlYXJDb2xvclsgMCBdID0gcjtcblx0XHRcdFx0XHRcdHVpbnRDbGVhckNvbG9yWyAxIF0gPSBnO1xuXHRcdFx0XHRcdFx0dWludENsZWFyQ29sb3JbIDIgXSA9IGI7XG5cdFx0XHRcdFx0XHR1aW50Q2xlYXJDb2xvclsgMyBdID0gYTtcblx0XHRcdFx0XHRcdF9nbC5jbGVhckJ1ZmZlcnVpdiggX2dsLkNPTE9SLCAwLCB1aW50Q2xlYXJDb2xvciApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0aW50Q2xlYXJDb2xvclsgMCBdID0gcjtcblx0XHRcdFx0XHRcdGludENsZWFyQ29sb3JbIDEgXSA9IGc7XG5cdFx0XHRcdFx0XHRpbnRDbGVhckNvbG9yWyAyIF0gPSBiO1xuXHRcdFx0XHRcdFx0aW50Q2xlYXJDb2xvclsgMyBdID0gYTtcblx0XHRcdFx0XHRcdF9nbC5jbGVhckJ1ZmZlcml2KCBfZ2wuQ09MT1IsIDAsIGludENsZWFyQ29sb3IgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Yml0cyB8PSBfZ2wuQ09MT1JfQlVGRkVSX0JJVDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBkZXB0aCApIHtcblxuXHRcdFx0XHRiaXRzIHw9IF9nbC5ERVBUSF9CVUZGRVJfQklUO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3RlbmNpbCApIHtcblxuXHRcdFx0XHRiaXRzIHw9IF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ7XG5cdFx0XHRcdHRoaXMuc3RhdGUuYnVmZmVycy5zdGVuY2lsLnNldE1hc2soIDB4ZmZmZmZmZmYgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfZ2wuY2xlYXIoIGJpdHMgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmNsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMuY2xlYXIoIHRydWUsIGZhbHNlLCBmYWxzZSApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5jbGVhciggZmFsc2UsIHRydWUsIGZhbHNlICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5jbGVhclN0ZW5jaWwgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMuY2xlYXIoIGZhbHNlLCBmYWxzZSwgdHJ1ZSApO1xuXG5cdFx0fTtcblxuXHRcdC8vXG5cblx0XHR0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlICk7XG5cdFx0XHRjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgb25Db250ZXh0UmVzdG9yZSwgZmFsc2UgKTtcblx0XHRcdGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvcicsIG9uQ29udGV4dENyZWF0aW9uRXJyb3IsIGZhbHNlICk7XG5cblx0XHRcdGJhY2tncm91bmQuZGlzcG9zZSgpO1xuXHRcdFx0cmVuZGVyTGlzdHMuZGlzcG9zZSgpO1xuXHRcdFx0cmVuZGVyU3RhdGVzLmRpc3Bvc2UoKTtcblx0XHRcdHByb3BlcnRpZXMuZGlzcG9zZSgpO1xuXHRcdFx0Y3ViZW1hcHMuZGlzcG9zZSgpO1xuXHRcdFx0Y3ViZXV2bWFwcy5kaXNwb3NlKCk7XG5cdFx0XHRvYmplY3RzLmRpc3Bvc2UoKTtcblx0XHRcdGJpbmRpbmdTdGF0ZXMuZGlzcG9zZSgpO1xuXHRcdFx0dW5pZm9ybXNHcm91cHMuZGlzcG9zZSgpO1xuXHRcdFx0cHJvZ3JhbUNhY2hlLmRpc3Bvc2UoKTtcblxuXHRcdFx0eHIuZGlzcG9zZSgpO1xuXG5cdFx0XHR4ci5yZW1vdmVFdmVudExpc3RlbmVyKCAnc2Vzc2lvbnN0YXJ0Jywgb25YUlNlc3Npb25TdGFydCApO1xuXHRcdFx0eHIucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3Nlc3Npb25lbmQnLCBvblhSU2Vzc2lvbkVuZCApO1xuXG5cdFx0XHRhbmltYXRpb24uc3RvcCgpO1xuXG5cdFx0fTtcblxuXHRcdC8vIEV2ZW50c1xuXG5cdFx0ZnVuY3Rpb24gb25Db250ZXh0TG9zdCggZXZlbnQgKSB7XG5cblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBMb3N0LicgKTtcblxuXHRcdFx0X2lzQ29udGV4dExvc3QgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Db250ZXh0UmVzdG9yZSggLyogZXZlbnQgKi8gKSB7XG5cblx0XHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBSZXN0b3JlZC4nICk7XG5cblx0XHRcdF9pc0NvbnRleHRMb3N0ID0gZmFsc2U7XG5cblx0XHRcdGNvbnN0IGluZm9BdXRvUmVzZXQgPSBpbmZvLmF1dG9SZXNldDtcblx0XHRcdGNvbnN0IHNoYWRvd01hcEVuYWJsZWQgPSBzaGFkb3dNYXAuZW5hYmxlZDtcblx0XHRcdGNvbnN0IHNoYWRvd01hcEF1dG9VcGRhdGUgPSBzaGFkb3dNYXAuYXV0b1VwZGF0ZTtcblx0XHRcdGNvbnN0IHNoYWRvd01hcE5lZWRzVXBkYXRlID0gc2hhZG93TWFwLm5lZWRzVXBkYXRlO1xuXHRcdFx0Y29uc3Qgc2hhZG93TWFwVHlwZSA9IHNoYWRvd01hcC50eXBlO1xuXG5cdFx0XHRpbml0R0xDb250ZXh0KCk7XG5cblx0XHRcdGluZm8uYXV0b1Jlc2V0ID0gaW5mb0F1dG9SZXNldDtcblx0XHRcdHNoYWRvd01hcC5lbmFibGVkID0gc2hhZG93TWFwRW5hYmxlZDtcblx0XHRcdHNoYWRvd01hcC5hdXRvVXBkYXRlID0gc2hhZG93TWFwQXV0b1VwZGF0ZTtcblx0XHRcdHNoYWRvd01hcC5uZWVkc1VwZGF0ZSA9IHNoYWRvd01hcE5lZWRzVXBkYXRlO1xuXHRcdFx0c2hhZG93TWFwLnR5cGUgPSBzaGFkb3dNYXBUeXBlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Db250ZXh0Q3JlYXRpb25FcnJvciggZXZlbnQgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBBIFdlYkdMIGNvbnRleHQgY291bGQgbm90IGJlIGNyZWF0ZWQuIFJlYXNvbjogJywgZXZlbnQuc3RhdHVzTWVzc2FnZSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25NYXRlcmlhbERpc3Bvc2UoIGV2ZW50ICkge1xuXG5cdFx0XHRjb25zdCBtYXRlcmlhbCA9IGV2ZW50LnRhcmdldDtcblxuXHRcdFx0bWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xuXG5cdFx0XHRkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICk7XG5cblx0XHR9XG5cblx0XHQvLyBCdWZmZXIgZGVhbGxvY2F0aW9uXG5cblx0XHRmdW5jdGlvbiBkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICkge1xuXG5cdFx0XHRyZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlcyggbWF0ZXJpYWwgKTtcblxuXHRcdFx0cHJvcGVydGllcy5yZW1vdmUoIG1hdGVyaWFsICk7XG5cblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2VzKCBtYXRlcmlhbCApIHtcblxuXHRcdFx0Y29uc3QgcHJvZ3JhbXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKS5wcm9ncmFtcztcblxuXHRcdFx0aWYgKCBwcm9ncmFtcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHByb2dyYW1zLmZvckVhY2goIGZ1bmN0aW9uICggcHJvZ3JhbSApIHtcblxuXHRcdFx0XHRcdHByb2dyYW1DYWNoZS5yZWxlYXNlUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRwcm9ncmFtQ2FjaGUucmVsZWFzZVNoYWRlckNhY2hlKCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gQnVmZmVyIHJlbmRlcmluZ1xuXG5cdFx0dGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QgPSBmdW5jdGlvbiAoIGNhbWVyYSwgc2NlbmUsIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCApIHtcblxuXHRcdFx0aWYgKCBzY2VuZSA9PT0gbnVsbCApIHNjZW5lID0gX2VtcHR5U2NlbmU7IC8vIHJlbmRlckJ1ZmZlckRpcmVjdCBzZWNvbmQgcGFyYW1ldGVyIHVzZWQgdG8gYmUgZm9nIChjb3VsZCBiZSBudWxsKVxuXG5cdFx0XHRjb25zdCBmcm9udEZhY2VDVyA9ICggb2JqZWN0LmlzTWVzaCAmJiBvYmplY3QubWF0cml4V29ybGQuZGV0ZXJtaW5hbnQoKSA8IDAgKTtcblxuXHRcdFx0Y29uc3QgcHJvZ3JhbSA9IHNldFByb2dyYW0oIGNhbWVyYSwgc2NlbmUsIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0ICk7XG5cblx0XHRcdHN0YXRlLnNldE1hdGVyaWFsKCBtYXRlcmlhbCwgZnJvbnRGYWNlQ1cgKTtcblxuXHRcdFx0Ly9cblxuXHRcdFx0bGV0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRsZXQgcmFuZ2VGYWN0b3IgPSAxO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRpbmRleCA9IGdlb21ldHJpZXMuZ2V0V2lyZWZyYW1lQXR0cmlidXRlKCBnZW9tZXRyeSApO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdFx0XHRyYW5nZUZhY3RvciA9IDI7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9cblxuXHRcdFx0Y29uc3QgZHJhd1JhbmdlID0gZ2VvbWV0cnkuZHJhd1JhbmdlO1xuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRsZXQgZHJhd1N0YXJ0ID0gZHJhd1JhbmdlLnN0YXJ0ICogcmFuZ2VGYWN0b3I7XG5cdFx0XHRsZXQgZHJhd0VuZCA9ICggZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50ICkgKiByYW5nZUZhY3RvcjtcblxuXHRcdFx0aWYgKCBncm91cCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRkcmF3U3RhcnQgPSBNYXRoLm1heCggZHJhd1N0YXJ0LCBncm91cC5zdGFydCAqIHJhbmdlRmFjdG9yICk7XG5cdFx0XHRcdGRyYXdFbmQgPSBNYXRoLm1pbiggZHJhd0VuZCwgKCBncm91cC5zdGFydCArIGdyb3VwLmNvdW50ICkgKiByYW5nZUZhY3RvciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0ZHJhd1N0YXJ0ID0gTWF0aC5tYXgoIGRyYXdTdGFydCwgMCApO1xuXHRcdFx0XHRkcmF3RW5kID0gTWF0aC5taW4oIGRyYXdFbmQsIGluZGV4LmNvdW50ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgJiYgcG9zaXRpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0ZHJhd1N0YXJ0ID0gTWF0aC5tYXgoIGRyYXdTdGFydCwgMCApO1xuXHRcdFx0XHRkcmF3RW5kID0gTWF0aC5taW4oIGRyYXdFbmQsIHBvc2l0aW9uLmNvdW50ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZHJhd0NvdW50ID0gZHJhd0VuZCAtIGRyYXdTdGFydDtcblxuXHRcdFx0aWYgKCBkcmF3Q291bnQgPCAwIHx8IGRyYXdDb3VudCA9PT0gSW5maW5pdHkgKSByZXR1cm47XG5cblx0XHRcdC8vXG5cblx0XHRcdGJpbmRpbmdTdGF0ZXMuc2V0dXAoIG9iamVjdCwgbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCBpbmRleCApO1xuXG5cdFx0XHRsZXQgYXR0cmlidXRlO1xuXHRcdFx0bGV0IHJlbmRlcmVyID0gYnVmZmVyUmVuZGVyZXI7XG5cblx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0YXR0cmlidXRlID0gYXR0cmlidXRlcy5nZXQoIGluZGV4ICk7XG5cblx0XHRcdFx0cmVuZGVyZXIgPSBpbmRleGVkQnVmZmVyUmVuZGVyZXI7XG5cdFx0XHRcdHJlbmRlcmVyLnNldEluZGV4KCBhdHRyaWJ1dGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL1xuXG5cdFx0XHRpZiAoIG9iamVjdC5pc01lc2ggKSB7XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRzdGF0ZS5zZXRMaW5lV2lkdGgoIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCAqIGdldFRhcmdldFBpeGVsUmF0aW8oKSApO1xuXHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FUyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuVFJJQU5HTEVTICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNMaW5lICkge1xuXG5cdFx0XHRcdGxldCBsaW5lV2lkdGggPSBtYXRlcmlhbC5saW5ld2lkdGg7XG5cblx0XHRcdFx0aWYgKCBsaW5lV2lkdGggPT09IHVuZGVmaW5lZCApIGxpbmVXaWR0aCA9IDE7IC8vIE5vdCB1c2luZyBMaW5lKk1hdGVyaWFsXG5cblx0XHRcdFx0c3RhdGUuc2V0TGluZVdpZHRoKCBsaW5lV2lkdGggKiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkgKTtcblxuXHRcdFx0XHRpZiAoIG9iamVjdC5pc0xpbmVTZWdtZW50cyApIHtcblxuXHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FUyApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0xpbmVMb29wICkge1xuXG5cdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVfTE9PUCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORV9TVFJJUCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzUG9pbnRzICkge1xuXG5cdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5QT0lOVFMgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzU3ByaXRlICkge1xuXG5cdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5UUklBTkdMRVMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9iamVjdC5pc0JhdGNoZWRNZXNoICkge1xuXG5cdFx0XHRcdGlmICggb2JqZWN0Ll9tdWx0aURyYXdJbnN0YW5jZXMgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRyZW5kZXJlci5yZW5kZXJNdWx0aURyYXdJbnN0YW5jZXMoIG9iamVjdC5fbXVsdGlEcmF3U3RhcnRzLCBvYmplY3QuX211bHRpRHJhd0NvdW50cywgb2JqZWN0Ll9tdWx0aURyYXdDb3VudCwgb2JqZWN0Ll9tdWx0aURyYXdJbnN0YW5jZXMgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aWYgKCAhIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfbXVsdGlfZHJhdycgKSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3Qgc3RhcnRzID0gb2JqZWN0Ll9tdWx0aURyYXdTdGFydHM7XG5cdFx0XHRcdFx0XHRjb25zdCBjb3VudHMgPSBvYmplY3QuX211bHRpRHJhd0NvdW50cztcblx0XHRcdFx0XHRcdGNvbnN0IGRyYXdDb3VudCA9IG9iamVjdC5fbXVsdGlEcmF3Q291bnQ7XG5cdFx0XHRcdFx0XHRjb25zdCBieXRlc1BlckVsZW1lbnQgPSBpbmRleCA/IGF0dHJpYnV0ZXMuZ2V0KCBpbmRleCApLmJ5dGVzUGVyRWxlbWVudCA6IDE7XG5cdFx0XHRcdFx0XHRjb25zdCB1bmlmb3JtcyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApLmN1cnJlbnRQcm9ncmFtLmdldFVuaWZvcm1zKCk7XG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBkcmF3Q291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ19nbF9EcmF3SUQnLCBpICk7XG5cdFx0XHRcdFx0XHRcdHJlbmRlcmVyLnJlbmRlciggc3RhcnRzWyBpIF0gLyBieXRlc1BlckVsZW1lbnQsIGNvdW50c1sgaSBdICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHJlbmRlcmVyLnJlbmRlck11bHRpRHJhdyggb2JqZWN0Ll9tdWx0aURyYXdTdGFydHMsIG9iamVjdC5fbXVsdGlEcmF3Q291bnRzLCBvYmplY3QuX211bHRpRHJhd0NvdW50ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNJbnN0YW5jZWRNZXNoICkge1xuXG5cdFx0XHRcdHJlbmRlcmVyLnJlbmRlckluc3RhbmNlcyggZHJhd1N0YXJ0LCBkcmF3Q291bnQsIG9iamVjdC5jb3VudCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdGNvbnN0IG1heEluc3RhbmNlQ291bnQgPSBnZW9tZXRyeS5fbWF4SW5zdGFuY2VDb3VudCAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQgOiBJbmZpbml0eTtcblx0XHRcdFx0Y29uc3QgaW5zdGFuY2VDb3VudCA9IE1hdGgubWluKCBnZW9tZXRyeS5pbnN0YW5jZUNvdW50LCBtYXhJbnN0YW5jZUNvdW50ICk7XG5cblx0XHRcdFx0cmVuZGVyZXIucmVuZGVySW5zdGFuY2VzKCBkcmF3U3RhcnQsIGRyYXdDb3VudCwgaW5zdGFuY2VDb3VudCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJlbmRlcmVyLnJlbmRlciggZHJhd1N0YXJ0LCBkcmF3Q291bnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdC8vIENvbXBpbGVcblxuXHRcdGZ1bmN0aW9uIHByZXBhcmVNYXRlcmlhbCggbWF0ZXJpYWwsIHNjZW5lLCBvYmplY3QgKSB7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgPT09IHRydWUgJiYgbWF0ZXJpYWwuc2lkZSA9PT0gRG91YmxlU2lkZSAmJiBtYXRlcmlhbC5mb3JjZVNpbmdsZVBhc3MgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsLnNpZGUgPSBCYWNrU2lkZTtcblx0XHRcdFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRnZXRQcm9ncmFtKCBtYXRlcmlhbCwgc2NlbmUsIG9iamVjdCApO1xuXG5cdFx0XHRcdG1hdGVyaWFsLnNpZGUgPSBGcm9udFNpZGU7XG5cdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0Z2V0UHJvZ3JhbSggbWF0ZXJpYWwsIHNjZW5lLCBvYmplY3QgKTtcblxuXHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gRG91YmxlU2lkZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRnZXRQcm9ncmFtKCBtYXRlcmlhbCwgc2NlbmUsIG9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLmNvbXBpbGUgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEsIHRhcmdldFNjZW5lID0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCB0YXJnZXRTY2VuZSA9PT0gbnVsbCApIHRhcmdldFNjZW5lID0gc2NlbmU7XG5cblx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlcy5nZXQoIHRhcmdldFNjZW5lICk7XG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUuaW5pdCggY2FtZXJhICk7XG5cblx0XHRcdHJlbmRlclN0YXRlU3RhY2sucHVzaCggY3VycmVudFJlbmRlclN0YXRlICk7XG5cblx0XHRcdC8vIGdhdGhlciBsaWdodHMgZnJvbSBib3RoIHRoZSB0YXJnZXQgc2NlbmUgYW5kIHRoZSBuZXcgb2JqZWN0IHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2NlbmUuXG5cblx0XHRcdHRhcmdldFNjZW5lLnRyYXZlcnNlVmlzaWJsZSggZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QuaXNMaWdodCAmJiBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYS5sYXllcnMgKSApIHtcblxuXHRcdFx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5wdXNoTGlnaHQoIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QuY2FzdFNoYWRvdyApIHtcblxuXHRcdFx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnB1c2hTaGFkb3coIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0XHRpZiAoIHNjZW5lICE9PSB0YXJnZXRTY2VuZSApIHtcblxuXHRcdFx0XHRzY2VuZS50cmF2ZXJzZVZpc2libGUoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QuaXNMaWdodCAmJiBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYS5sYXllcnMgKSApIHtcblxuXHRcdFx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnB1c2hMaWdodCggb2JqZWN0ICk7XG5cblx0XHRcdFx0XHRcdGlmICggb2JqZWN0LmNhc3RTaGFkb3cgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnB1c2hTaGFkb3coIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5zZXR1cExpZ2h0cygpO1xuXG5cdFx0XHQvLyBPbmx5IGluaXRpYWxpemUgbWF0ZXJpYWxzIGluIHRoZSBuZXcgc2NlbmUsIG5vdCB0aGUgdGFyZ2V0U2NlbmUuXG5cblx0XHRcdGNvbnN0IG1hdGVyaWFscyA9IG5ldyBTZXQoKTtcblxuXHRcdFx0c2NlbmUudHJhdmVyc2UoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHRcdGlmICggISAoIG9iamVjdC5pc01lc2ggfHwgb2JqZWN0LmlzUG9pbnRzIHx8IG9iamVjdC5pc0xpbmUgfHwgb2JqZWN0LmlzU3ByaXRlICkgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG1hdGVyaWFsLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBtYXRlcmlhbDIgPSBtYXRlcmlhbFsgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdHByZXBhcmVNYXRlcmlhbCggbWF0ZXJpYWwyLCB0YXJnZXRTY2VuZSwgb2JqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFscy5hZGQoIG1hdGVyaWFsMiApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRwcmVwYXJlTWF0ZXJpYWwoIG1hdGVyaWFsLCB0YXJnZXRTY2VuZSwgb2JqZWN0ICk7XG5cdFx0XHRcdFx0XHRtYXRlcmlhbHMuYWRkKCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0XHRyZW5kZXJTdGF0ZVN0YWNrLnBvcCgpO1xuXHRcdFx0Y3VycmVudFJlbmRlclN0YXRlID0gbnVsbDtcblxuXHRcdFx0cmV0dXJuIG1hdGVyaWFscztcblxuXHRcdH07XG5cblx0XHQvLyBjb21waWxlQXN5bmNcblxuXHRcdHRoaXMuY29tcGlsZUFzeW5jID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCB0YXJnZXRTY2VuZSA9IG51bGwgKSB7XG5cblx0XHRcdGNvbnN0IG1hdGVyaWFscyA9IHRoaXMuY29tcGlsZSggc2NlbmUsIGNhbWVyYSwgdGFyZ2V0U2NlbmUgKTtcblxuXHRcdFx0Ly8gV2FpdCBmb3IgYWxsIHRoZSBtYXRlcmlhbHMgaW4gdGhlIG5ldyBvYmplY3QgdG8gaW5kaWNhdGUgdGhhdCB0aGV5J3JlXG5cdFx0XHQvLyByZWFkeSB0byBiZSB1c2VkIGJlZm9yZSByZXNvbHZpbmcgdGhlIHByb21pc2UuXG5cblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZSggKCByZXNvbHZlICkgPT4ge1xuXG5cdFx0XHRcdGZ1bmN0aW9uIGNoZWNrTWF0ZXJpYWxzUmVhZHkoKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbHMuZm9yRWFjaCggZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XG5cdFx0XHRcdFx0XHRjb25zdCBwcm9ncmFtID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLmN1cnJlbnRQcm9ncmFtO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHByb2dyYW0uaXNSZWFkeSgpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIHJlbW92ZSBhbnkgcHJvZ3JhbXMgdGhhdCByZXBvcnQgdGhleSdyZSByZWFkeSB0byB1c2UgZnJvbSB0aGUgbGlzdFxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbHMuZGVsZXRlKCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHQvLyBvbmNlIHRoZSBsaXN0IG9mIGNvbXBpbGluZyBtYXRlcmlhbHMgaXMgZW1wdHksIGNhbGwgdGhlIGNhbGxiYWNrXG5cblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFscy5zaXplID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRyZXNvbHZlKCBzY2VuZSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gaWYgc29tZSBtYXRlcmlhbHMgYXJlIHN0aWxsIG5vdCByZWFkeSwgd2FpdCBhIGJpdCBhbmQgY2hlY2sgYWdhaW5cblxuXHRcdFx0XHRcdHNldFRpbWVvdXQoIGNoZWNrTWF0ZXJpYWxzUmVhZHksIDEwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9ucy5nZXQoICdLSFJfcGFyYWxsZWxfc2hhZGVyX2NvbXBpbGUnICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBjYW4gY2hlY2sgdGhlIGNvbXBpbGF0aW9uIHN0YXR1cyBvZiB0aGUgbWF0ZXJpYWxzIHdpdGhvdXRcblx0XHRcdFx0XHQvLyBibG9ja2luZyB0aGVuIGRvIHNvIHJpZ2h0IGF3YXkuXG5cblx0XHRcdFx0XHRjaGVja01hdGVyaWFsc1JlYWR5KCk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSBzdGFydCBieSB3YWl0aW5nIGEgYml0IHRvIGdpdmUgdGhlIG1hdGVyaWFscyB3ZSBqdXN0XG5cdFx0XHRcdFx0Ly8gaW5pdGlhbGl6ZWQgYSBjaGFuY2UgdG8gZmluaXNoLlxuXG5cdFx0XHRcdFx0c2V0VGltZW91dCggY2hlY2tNYXRlcmlhbHNSZWFkeSwgMTAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdH07XG5cblx0XHQvLyBBbmltYXRpb24gTG9vcFxuXG5cdFx0bGV0IG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayA9IG51bGw7XG5cblx0XHRmdW5jdGlvbiBvbkFuaW1hdGlvbkZyYW1lKCB0aW1lICkge1xuXG5cdFx0XHRpZiAoIG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayApIG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayggdGltZSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25YUlNlc3Npb25TdGFydCgpIHtcblxuXHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uWFJTZXNzaW9uRW5kKCkge1xuXG5cdFx0XHRhbmltYXRpb24uc3RhcnQoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGFuaW1hdGlvbiA9IG5ldyBXZWJHTEFuaW1hdGlvbigpO1xuXHRcdGFuaW1hdGlvbi5zZXRBbmltYXRpb25Mb29wKCBvbkFuaW1hdGlvbkZyYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyApIGFuaW1hdGlvbi5zZXRDb250ZXh0KCBzZWxmICk7XG5cblx0XHR0aGlzLnNldEFuaW1hdGlvbkxvb3AgPSBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0XHRvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHhyLnNldEFuaW1hdGlvbkxvb3AoIGNhbGxiYWNrICk7XG5cblx0XHRcdCggY2FsbGJhY2sgPT09IG51bGwgKSA/IGFuaW1hdGlvbi5zdG9wKCkgOiBhbmltYXRpb24uc3RhcnQoKTtcblxuXHRcdH07XG5cblx0XHR4ci5hZGRFdmVudExpc3RlbmVyKCAnc2Vzc2lvbnN0YXJ0Jywgb25YUlNlc3Npb25TdGFydCApO1xuXHRcdHhyLmFkZEV2ZW50TGlzdGVuZXIoICdzZXNzaW9uZW5kJywgb25YUlNlc3Npb25FbmQgKTtcblxuXHRcdC8vIFJlbmRlcmluZ1xuXG5cdFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHRcdGlmICggY2FtZXJhICE9PSB1bmRlZmluZWQgJiYgY2FtZXJhLmlzQ2FtZXJhICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuJyApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBfaXNDb250ZXh0TG9zdCA9PT0gdHJ1ZSApIHJldHVybjtcblxuXHRcdFx0Ly8gdXBkYXRlIHNjZW5lIGdyYXBoXG5cblx0XHRcdGlmICggc2NlbmUubWF0cml4V29ybGRBdXRvVXBkYXRlID09PSB0cnVlICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdFx0Ly8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxuXG5cdFx0XHRpZiAoIGNhbWVyYS5wYXJlbnQgPT09IG51bGwgJiYgY2FtZXJhLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0XHRpZiAoIHhyLmVuYWJsZWQgPT09IHRydWUgJiYgeHIuaXNQcmVzZW50aW5nID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGlmICggeHIuY2FtZXJhQXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHhyLnVwZGF0ZUNhbWVyYSggY2FtZXJhICk7XG5cblx0XHRcdFx0Y2FtZXJhID0geHIuZ2V0Q2FtZXJhKCk7IC8vIHVzZSBYUiBjYW1lcmEgZm9yIHJlbmRlcmluZ1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cdFx0XHRpZiAoIHNjZW5lLmlzU2NlbmUgPT09IHRydWUgKSBzY2VuZS5vbkJlZm9yZVJlbmRlciggX3RoaXMsIHNjZW5lLCBjYW1lcmEsIF9jdXJyZW50UmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlcy5nZXQoIHNjZW5lLCByZW5kZXJTdGF0ZVN0YWNrLmxlbmd0aCApO1xuXHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLmluaXQoIGNhbWVyYSApO1xuXG5cdFx0XHRyZW5kZXJTdGF0ZVN0YWNrLnB1c2goIGN1cnJlbnRSZW5kZXJTdGF0ZSApO1xuXG5cdFx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXHRcdFx0X2ZydXN0dW0uc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cblx0XHRcdF9sb2NhbENsaXBwaW5nRW5hYmxlZCA9IHRoaXMubG9jYWxDbGlwcGluZ0VuYWJsZWQ7XG5cdFx0XHRfY2xpcHBpbmdFbmFibGVkID0gY2xpcHBpbmcuaW5pdCggdGhpcy5jbGlwcGluZ1BsYW5lcywgX2xvY2FsQ2xpcHBpbmdFbmFibGVkICk7XG5cblx0XHRcdGN1cnJlbnRSZW5kZXJMaXN0ID0gcmVuZGVyTGlzdHMuZ2V0KCBzY2VuZSwgcmVuZGVyTGlzdFN0YWNrLmxlbmd0aCApO1xuXHRcdFx0Y3VycmVudFJlbmRlckxpc3QuaW5pdCgpO1xuXG5cdFx0XHRyZW5kZXJMaXN0U3RhY2sucHVzaCggY3VycmVudFJlbmRlckxpc3QgKTtcblxuXHRcdFx0aWYgKCB4ci5lbmFibGVkID09PSB0cnVlICYmIHhyLmlzUHJlc2VudGluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRjb25zdCBkZXB0aFNlbnNpbmdNZXNoID0gX3RoaXMueHIuZ2V0RGVwdGhTZW5zaW5nTWVzaCgpO1xuXG5cdFx0XHRcdGlmICggZGVwdGhTZW5zaW5nTWVzaCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdHByb2plY3RPYmplY3QoIGRlcHRoU2Vuc2luZ01lc2gsIGNhbWVyYSwgLSBJbmZpbml0eSwgX3RoaXMuc29ydE9iamVjdHMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cHJvamVjdE9iamVjdCggc2NlbmUsIGNhbWVyYSwgMCwgX3RoaXMuc29ydE9iamVjdHMgKTtcblxuXHRcdFx0Y3VycmVudFJlbmRlckxpc3QuZmluaXNoKCk7XG5cblx0XHRcdGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3Quc29ydCggX29wYXF1ZVNvcnQsIF90cmFuc3BhcmVudFNvcnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfcmVuZGVyQmFja2dyb3VuZCA9IHhyLmVuYWJsZWQgPT09IGZhbHNlIHx8IHhyLmlzUHJlc2VudGluZyA9PT0gZmFsc2UgfHwgeHIuaGFzRGVwdGhTZW5zaW5nKCkgPT09IGZhbHNlO1xuXHRcdFx0aWYgKCBfcmVuZGVyQmFja2dyb3VuZCApIHtcblxuXHRcdFx0XHRiYWNrZ3JvdW5kLmFkZFRvUmVuZGVyTGlzdCggY3VycmVudFJlbmRlckxpc3QsIHNjZW5lICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9cblxuXHRcdFx0dGhpcy5pbmZvLnJlbmRlci5mcmFtZSArKztcblxuXHRcdFx0aWYgKCBfY2xpcHBpbmdFbmFibGVkID09PSB0cnVlICkgY2xpcHBpbmcuYmVnaW5TaGFkb3dzKCk7XG5cblx0XHRcdGNvbnN0IHNoYWRvd3NBcnJheSA9IGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS5zaGFkb3dzQXJyYXk7XG5cblx0XHRcdHNoYWRvd01hcC5yZW5kZXIoIHNoYWRvd3NBcnJheSwgc2NlbmUsIGNhbWVyYSApO1xuXG5cdFx0XHRpZiAoIF9jbGlwcGluZ0VuYWJsZWQgPT09IHRydWUgKSBjbGlwcGluZy5lbmRTaGFkb3dzKCk7XG5cblx0XHRcdC8vXG5cblx0XHRcdGlmICggdGhpcy5pbmZvLmF1dG9SZXNldCA9PT0gdHJ1ZSApIHRoaXMuaW5mby5yZXNldCgpO1xuXG5cdFx0XHQvLyByZW5kZXIgc2NlbmVcblxuXHRcdFx0Y29uc3Qgb3BhcXVlT2JqZWN0cyA9IGN1cnJlbnRSZW5kZXJMaXN0Lm9wYXF1ZTtcblx0XHRcdGNvbnN0IHRyYW5zbWlzc2l2ZU9iamVjdHMgPSBjdXJyZW50UmVuZGVyTGlzdC50cmFuc21pc3NpdmU7XG5cblx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5zZXR1cExpZ2h0cygpO1xuXG5cdFx0XHRpZiAoIGNhbWVyYS5pc0FycmF5Q2FtZXJhICkge1xuXG5cdFx0XHRcdGNvbnN0IGNhbWVyYXMgPSBjYW1lcmEuY2FtZXJhcztcblxuXHRcdFx0XHRpZiAoIHRyYW5zbWlzc2l2ZU9iamVjdHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNhbWVyYXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgY2FtZXJhMiA9IGNhbWVyYXNbIGkgXTtcblxuXHRcdFx0XHRcdFx0cmVuZGVyVHJhbnNtaXNzaW9uUGFzcyggb3BhcXVlT2JqZWN0cywgdHJhbnNtaXNzaXZlT2JqZWN0cywgc2NlbmUsIGNhbWVyYTIgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBfcmVuZGVyQmFja2dyb3VuZCApIGJhY2tncm91bmQucmVuZGVyKCBzY2VuZSApO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNhbWVyYXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGNhbWVyYTIgPSBjYW1lcmFzWyBpIF07XG5cblx0XHRcdFx0XHRyZW5kZXJTY2VuZSggY3VycmVudFJlbmRlckxpc3QsIHNjZW5lLCBjYW1lcmEyLCBjYW1lcmEyLnZpZXdwb3J0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggdHJhbnNtaXNzaXZlT2JqZWN0cy5sZW5ndGggPiAwICkgcmVuZGVyVHJhbnNtaXNzaW9uUGFzcyggb3BhcXVlT2JqZWN0cywgdHJhbnNtaXNzaXZlT2JqZWN0cywgc2NlbmUsIGNhbWVyYSApO1xuXG5cdFx0XHRcdGlmICggX3JlbmRlckJhY2tncm91bmQgKSBiYWNrZ3JvdW5kLnJlbmRlciggc2NlbmUgKTtcblxuXHRcdFx0XHRyZW5kZXJTY2VuZSggY3VycmVudFJlbmRlckxpc3QsIHNjZW5lLCBjYW1lcmEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL1xuXG5cdFx0XHRpZiAoIF9jdXJyZW50UmVuZGVyVGFyZ2V0ICE9PSBudWxsICYmIF9jdXJyZW50QWN0aXZlTWlwbWFwTGV2ZWwgPT09IDAgKSB7XG5cblx0XHRcdFx0Ly8gcmVzb2x2ZSBtdWx0aXNhbXBsZSByZW5kZXJidWZmZXJzIHRvIGEgc2luZ2xlLXNhbXBsZSB0ZXh0dXJlIGlmIG5lY2Vzc2FyeVxuXG5cdFx0XHRcdHRleHR1cmVzLnVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0KCBfY3VycmVudFJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRcdC8vIEdlbmVyYXRlIG1pcG1hcCBpZiB3ZSdyZSB1c2luZyBhbnkga2luZCBvZiBtaXBtYXAgZmlsdGVyaW5nXG5cblx0XHRcdFx0dGV4dHVyZXMudXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKCBfY3VycmVudFJlbmRlclRhcmdldCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cblx0XHRcdGlmICggc2NlbmUuaXNTY2VuZSA9PT0gdHJ1ZSApIHNjZW5lLm9uQWZ0ZXJSZW5kZXIoIF90aGlzLCBzY2VuZSwgY2FtZXJhICk7XG5cblx0XHRcdC8vIF9nbC5maW5pc2goKTtcblxuXHRcdFx0YmluZGluZ1N0YXRlcy5yZXNldERlZmF1bHRTdGF0ZSgpO1xuXHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLSAxO1xuXHRcdFx0X2N1cnJlbnRDYW1lcmEgPSBudWxsO1xuXG5cdFx0XHRyZW5kZXJTdGF0ZVN0YWNrLnBvcCgpO1xuXG5cdFx0XHRpZiAoIHJlbmRlclN0YXRlU3RhY2subGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZVN0YWNrWyByZW5kZXJTdGF0ZVN0YWNrLmxlbmd0aCAtIDEgXTtcblxuXHRcdFx0XHRpZiAoIF9jbGlwcGluZ0VuYWJsZWQgPT09IHRydWUgKSBjbGlwcGluZy5zZXRHbG9iYWxTdGF0ZSggX3RoaXMuY2xpcHBpbmdQbGFuZXMsIGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS5jYW1lcmEgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUgPSBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJlbmRlckxpc3RTdGFjay5wb3AoKTtcblxuXHRcdFx0aWYgKCByZW5kZXJMaXN0U3RhY2subGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRjdXJyZW50UmVuZGVyTGlzdCA9IHJlbmRlckxpc3RTdGFja1sgcmVuZGVyTGlzdFN0YWNrLmxlbmd0aCAtIDEgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjdXJyZW50UmVuZGVyTGlzdCA9IG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KCBvYmplY3QsIGNhbWVyYSwgZ3JvdXBPcmRlciwgc29ydE9iamVjdHMgKSB7XG5cblx0XHRcdGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRjb25zdCB2aXNpYmxlID0gb2JqZWN0LmxheWVycy50ZXN0KCBjYW1lcmEubGF5ZXJzICk7XG5cblx0XHRcdGlmICggdmlzaWJsZSApIHtcblxuXHRcdFx0XHRpZiAoIG9iamVjdC5pc0dyb3VwICkge1xuXG5cdFx0XHRcdFx0Z3JvdXBPcmRlciA9IG9iamVjdC5yZW5kZXJPcmRlcjtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNMT0QgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG9iamVjdC5hdXRvVXBkYXRlID09PSB0cnVlICkgb2JqZWN0LnVwZGF0ZSggY2FtZXJhICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTGlnaHQgKSB7XG5cblx0XHRcdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUucHVzaExpZ2h0KCBvYmplY3QgKTtcblxuXHRcdFx0XHRcdGlmICggb2JqZWN0LmNhc3RTaGFkb3cgKSB7XG5cblx0XHRcdFx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5wdXNoU2hhZG93KCBvYmplY3QgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNTcHJpdGUgKSB7XG5cblx0XHRcdFx0XHRpZiAoICEgb2JqZWN0LmZydXN0dW1DdWxsZWQgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c1Nwcml0ZSggb2JqZWN0ICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggc29ydE9iamVjdHMgKSB7XG5cblx0XHRcdFx0XHRcdFx0X3ZlY3RvcjQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBvYmplY3QubWF0cml4V29ybGQgKVxuXHRcdFx0XHRcdFx0XHRcdC5hcHBseU1hdHJpeDQoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBvYmplY3RzLnVwZGF0ZSggb2JqZWN0ICk7XG5cdFx0XHRcdFx0XHRjb25zdCBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC52aXNpYmxlICkge1xuXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRSZW5kZXJMaXN0LnB1c2goIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCBfdmVjdG9yNC56LCBudWxsICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNNZXNoIHx8IG9iamVjdC5pc0xpbmUgfHwgb2JqZWN0LmlzUG9pbnRzICkge1xuXG5cdFx0XHRcdFx0aWYgKCAhIG9iamVjdC5mcnVzdHVtQ3VsbGVkIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBnZW9tZXRyeSA9IG9iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcblx0XHRcdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNvcnRPYmplY3RzICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggb2JqZWN0LmJvdW5kaW5nU3BoZXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIG9iamVjdC5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIG9iamVjdC5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblx0XHRcdFx0XHRcdFx0XHRfdmVjdG9yNC5jb3B5KCBvYmplY3QuYm91bmRpbmdTcGhlcmUuY2VudGVyICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblx0XHRcdFx0XHRcdFx0XHRfdmVjdG9yNC5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jZW50ZXIgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0X3ZlY3RvcjRcblx0XHRcdFx0XHRcdFx0XHQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKVxuXHRcdFx0XHRcdFx0XHRcdC5hcHBseU1hdHJpeDQoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBtYXRlcmlhbCApICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsWyBncm91cC5tYXRlcmlhbEluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGdyb3VwTWF0ZXJpYWwgJiYgZ3JvdXBNYXRlcmlhbC52aXNpYmxlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50UmVuZGVyTGlzdC5wdXNoKCBvYmplY3QsIGdlb21ldHJ5LCBncm91cE1hdGVyaWFsLCBncm91cE9yZGVyLCBfdmVjdG9yNC56LCBncm91cCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwudmlzaWJsZSApIHtcblxuXHRcdFx0XHRcdFx0XHRjdXJyZW50UmVuZGVyTGlzdC5wdXNoKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgX3ZlY3RvcjQueiwgbnVsbCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHByb2plY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSwgZ3JvdXBPcmRlciwgc29ydE9iamVjdHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVuZGVyU2NlbmUoIGN1cnJlbnRSZW5kZXJMaXN0LCBzY2VuZSwgY2FtZXJhLCB2aWV3cG9ydCApIHtcblxuXHRcdFx0Y29uc3Qgb3BhcXVlT2JqZWN0cyA9IGN1cnJlbnRSZW5kZXJMaXN0Lm9wYXF1ZTtcblx0XHRcdGNvbnN0IHRyYW5zbWlzc2l2ZU9iamVjdHMgPSBjdXJyZW50UmVuZGVyTGlzdC50cmFuc21pc3NpdmU7XG5cdFx0XHRjb25zdCB0cmFuc3BhcmVudE9iamVjdHMgPSBjdXJyZW50UmVuZGVyTGlzdC50cmFuc3BhcmVudDtcblxuXHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnNldHVwTGlnaHRzVmlldyggY2FtZXJhICk7XG5cblx0XHRcdGlmICggX2NsaXBwaW5nRW5hYmxlZCA9PT0gdHJ1ZSApIGNsaXBwaW5nLnNldEdsb2JhbFN0YXRlKCBfdGhpcy5jbGlwcGluZ1BsYW5lcywgY2FtZXJhICk7XG5cblx0XHRcdGlmICggdmlld3BvcnQgKSBzdGF0ZS52aWV3cG9ydCggX2N1cnJlbnRWaWV3cG9ydC5jb3B5KCB2aWV3cG9ydCApICk7XG5cblx0XHRcdGlmICggb3BhcXVlT2JqZWN0cy5sZW5ndGggPiAwICkgcmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgc2NlbmUsIGNhbWVyYSApO1xuXHRcdFx0aWYgKCB0cmFuc21pc3NpdmVPYmplY3RzLmxlbmd0aCA+IDAgKSByZW5kZXJPYmplY3RzKCB0cmFuc21pc3NpdmVPYmplY3RzLCBzY2VuZSwgY2FtZXJhICk7XG5cdFx0XHRpZiAoIHRyYW5zcGFyZW50T2JqZWN0cy5sZW5ndGggPiAwICkgcmVuZGVyT2JqZWN0cyggdHJhbnNwYXJlbnRPYmplY3RzLCBzY2VuZSwgY2FtZXJhICk7XG5cblx0XHRcdC8vIEVuc3VyZSBkZXB0aCBidWZmZXIgd3JpdGluZyBpcyBlbmFibGVkIHNvIGl0IGNhbiBiZSBjbGVhcmVkIG9uIG5leHQgcmVuZGVyXG5cblx0XHRcdHN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0VGVzdCggdHJ1ZSApO1xuXHRcdFx0c3RhdGUuYnVmZmVycy5kZXB0aC5zZXRNYXNrKCB0cnVlICk7XG5cdFx0XHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldE1hc2soIHRydWUgKTtcblxuXHRcdFx0c3RhdGUuc2V0UG9seWdvbk9mZnNldCggZmFsc2UgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbmRlclRyYW5zbWlzc2lvblBhc3MoIG9wYXF1ZU9iamVjdHMsIHRyYW5zbWlzc2l2ZU9iamVjdHMsIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHRcdGNvbnN0IG92ZXJyaWRlTWF0ZXJpYWwgPSBzY2VuZS5pc1NjZW5lID09PSB0cnVlID8gc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA6IG51bGw7XG5cblx0XHRcdGlmICggb3ZlcnJpZGVNYXRlcmlhbCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjdXJyZW50UmVuZGVyU3RhdGUuc3RhdGUudHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0WyBjYW1lcmEuaWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS50cmFuc21pc3Npb25SZW5kZXJUYXJnZXRbIGNhbWVyYS5pZCBdID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KCAxLCAxLCB7XG5cdFx0XHRcdFx0Z2VuZXJhdGVNaXBtYXBzOiB0cnVlLFxuXHRcdFx0XHRcdHR5cGU6ICggZXh0ZW5zaW9ucy5oYXMoICdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnICkgfHwgZXh0ZW5zaW9ucy5oYXMoICdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JyApICkgPyBIYWxmRmxvYXRUeXBlIDogVW5zaWduZWRCeXRlVHlwZSxcblx0XHRcdFx0XHRtaW5GaWx0ZXI6IExpbmVhck1pcG1hcExpbmVhckZpbHRlcixcblx0XHRcdFx0XHRzYW1wbGVzOiA0LFxuXHRcdFx0XHRcdHN0ZW5jaWxCdWZmZXI6IHN0ZW5jaWwsXG5cdFx0XHRcdFx0cmVzb2x2ZURlcHRoQnVmZmVyOiBmYWxzZSxcblx0XHRcdFx0XHRyZXNvbHZlU3RlbmNpbEJ1ZmZlcjogZmFsc2UsXG5cdFx0XHRcdFx0Y29sb3JTcGFjZTogQ29sb3JNYW5hZ2VtZW50LndvcmtpbmdDb2xvclNwYWNlLFxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gZGVidWdcblxuXHRcdFx0XHQvKlxuXHRcdFx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBQbGFuZUdlb21ldHJ5KCk7XG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IG1hcDogX3RyYW5zbWlzc2lvblJlbmRlclRhcmdldC50ZXh0dXJlIH0gKTtcblxuXHRcdFx0XHRjb25zdCBtZXNoID0gbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXHRcdFx0XHRzY2VuZS5hZGQoIG1lc2ggKTtcblx0XHRcdFx0Ki9cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0cmFuc21pc3Npb25SZW5kZXJUYXJnZXQgPSBjdXJyZW50UmVuZGVyU3RhdGUuc3RhdGUudHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0WyBjYW1lcmEuaWQgXTtcblxuXHRcdFx0Y29uc3QgYWN0aXZlVmlld3BvcnQgPSBjYW1lcmEudmlld3BvcnQgfHwgX2N1cnJlbnRWaWV3cG9ydDtcblx0XHRcdHRyYW5zbWlzc2lvblJlbmRlclRhcmdldC5zZXRTaXplKCBhY3RpdmVWaWV3cG9ydC56ICogX3RoaXMudHJhbnNtaXNzaW9uUmVzb2x1dGlvblNjYWxlLCBhY3RpdmVWaWV3cG9ydC53ICogX3RoaXMudHJhbnNtaXNzaW9uUmVzb2x1dGlvblNjYWxlICk7XG5cblx0XHRcdC8vXG5cblx0XHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSBfdGhpcy5nZXRSZW5kZXJUYXJnZXQoKTtcblx0XHRcdF90aGlzLnNldFJlbmRlclRhcmdldCggdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdF90aGlzLmdldENsZWFyQ29sb3IoIF9jdXJyZW50Q2xlYXJDb2xvciApO1xuXHRcdFx0X2N1cnJlbnRDbGVhckFscGhhID0gX3RoaXMuZ2V0Q2xlYXJBbHBoYSgpO1xuXHRcdFx0aWYgKCBfY3VycmVudENsZWFyQWxwaGEgPCAxICkgX3RoaXMuc2V0Q2xlYXJDb2xvciggMHhmZmZmZmYsIDAuNSApO1xuXG5cdFx0XHRfdGhpcy5jbGVhcigpO1xuXG5cdFx0XHRpZiAoIF9yZW5kZXJCYWNrZ3JvdW5kICkgYmFja2dyb3VuZC5yZW5kZXIoIHNjZW5lICk7XG5cblx0XHRcdC8vIFR1cm4gb2ZmIHRoZSBmZWF0dXJlcyB3aGljaCBjYW4gYWZmZWN0IHRoZSBmcmFnIGNvbG9yIGZvciBvcGFxdWUgb2JqZWN0cyBwYXNzLlxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHRoZXkgYXJlIGFwcGxpZWQgdHdpY2UgaW4gb3BhcXVlIG9iamVjdHMgcGFzcyBhbmQgdHJhbnNtaXNzaW9uIG9iamVjdHMgcGFzcy5cblx0XHRcdGNvbnN0IGN1cnJlbnRUb25lTWFwcGluZyA9IF90aGlzLnRvbmVNYXBwaW5nO1xuXHRcdFx0X3RoaXMudG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xuXG5cdFx0XHQvLyBSZW1vdmUgdmlld3BvcnQgZnJvbSBjYW1lcmEgdG8gYXZvaWQgbmVzdGVkIHJlbmRlciBjYWxscyByZXNldHRpbmcgdmlld3BvcnQgdG8gaXQgKGUuZyBSZWZsZWN0b3IpLlxuXHRcdFx0Ly8gVHJhbnNtaXNzaW9uIHJlbmRlciBwYXNzIHJlcXVpcmVzIHZpZXdwb3J0IHRvIG1hdGNoIHRoZSB0cmFuc21pc3Npb25SZW5kZXJUYXJnZXQuXG5cdFx0XHRjb25zdCBjdXJyZW50Q2FtZXJhVmlld3BvcnQgPSBjYW1lcmEudmlld3BvcnQ7XG5cdFx0XHRpZiAoIGNhbWVyYS52aWV3cG9ydCAhPT0gdW5kZWZpbmVkICkgY2FtZXJhLnZpZXdwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUuc2V0dXBMaWdodHNWaWV3KCBjYW1lcmEgKTtcblxuXHRcdFx0aWYgKCBfY2xpcHBpbmdFbmFibGVkID09PSB0cnVlICkgY2xpcHBpbmcuc2V0R2xvYmFsU3RhdGUoIF90aGlzLmNsaXBwaW5nUGxhbmVzLCBjYW1lcmEgKTtcblxuXHRcdFx0cmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgc2NlbmUsIGNhbWVyYSApO1xuXG5cdFx0XHR0ZXh0dXJlcy51cGRhdGVNdWx0aXNhbXBsZVJlbmRlclRhcmdldCggdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0ICk7XG5cdFx0XHR0ZXh0dXJlcy51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoIHRyYW5zbWlzc2lvblJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRpZiAoIGV4dGVuc2lvbnMuaGFzKCAnV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlJyApID09PSBmYWxzZSApIHsgLy8gc2VlICMyODEzMVxuXG5cdFx0XHRcdGxldCByZW5kZXJUYXJnZXROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRyYW5zbWlzc2l2ZU9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHJlbmRlckl0ZW0gPSB0cmFuc21pc3NpdmVPYmplY3RzWyBpIF07XG5cblx0XHRcdFx0XHRjb25zdCBvYmplY3QgPSByZW5kZXJJdGVtLm9iamVjdDtcblx0XHRcdFx0XHRjb25zdCBnZW9tZXRyeSA9IHJlbmRlckl0ZW0uZ2VvbWV0cnk7XG5cdFx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSByZW5kZXJJdGVtLm1hdGVyaWFsO1xuXHRcdFx0XHRcdGNvbnN0IGdyb3VwID0gcmVuZGVySXRlbS5ncm91cDtcblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwuc2lkZSA9PT0gRG91YmxlU2lkZSAmJiBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYS5sYXllcnMgKSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgY3VycmVudFNpZGUgPSBtYXRlcmlhbC5zaWRlO1xuXG5cdFx0XHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gQmFja1NpZGU7XG5cdFx0XHRcdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdHJlbmRlck9iamVjdCggb2JqZWN0LCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICk7XG5cblx0XHRcdFx0XHRcdG1hdGVyaWFsLnNpZGUgPSBjdXJyZW50U2lkZTtcblx0XHRcdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0cmVuZGVyVGFyZ2V0TmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldE5lZWRzVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZXMudXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQoIHRyYW5zbWlzc2lvblJlbmRlclRhcmdldCApO1xuXHRcdFx0XHRcdHRleHR1cmVzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdF90aGlzLnNldFJlbmRlclRhcmdldCggY3VycmVudFJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRfdGhpcy5zZXRDbGVhckNvbG9yKCBfY3VycmVudENsZWFyQ29sb3IsIF9jdXJyZW50Q2xlYXJBbHBoYSApO1xuXG5cdFx0XHRpZiAoIGN1cnJlbnRDYW1lcmFWaWV3cG9ydCAhPT0gdW5kZWZpbmVkICkgY2FtZXJhLnZpZXdwb3J0ID0gY3VycmVudENhbWVyYVZpZXdwb3J0O1xuXG5cdFx0XHRfdGhpcy50b25lTWFwcGluZyA9IGN1cnJlbnRUb25lTWFwcGluZztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbmRlck9iamVjdHMoIHJlbmRlckxpc3QsIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHRcdGNvbnN0IG92ZXJyaWRlTWF0ZXJpYWwgPSBzY2VuZS5pc1NjZW5lID09PSB0cnVlID8gc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA6IG51bGw7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCByZW5kZXJJdGVtID0gcmVuZGVyTGlzdFsgaSBdO1xuXG5cdFx0XHRcdGNvbnN0IG9iamVjdCA9IHJlbmRlckl0ZW0ub2JqZWN0O1xuXHRcdFx0XHRjb25zdCBnZW9tZXRyeSA9IHJlbmRlckl0ZW0uZ2VvbWV0cnk7XG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbCA9PT0gbnVsbCA/IHJlbmRlckl0ZW0ubWF0ZXJpYWwgOiBvdmVycmlkZU1hdGVyaWFsO1xuXHRcdFx0XHRjb25zdCBncm91cCA9IHJlbmRlckl0ZW0uZ3JvdXA7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYS5sYXllcnMgKSApIHtcblxuXHRcdFx0XHRcdHJlbmRlck9iamVjdCggb2JqZWN0LCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW5kZXJPYmplY3QoIG9iamVjdCwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCApIHtcblxuXHRcdFx0b2JqZWN0Lm9uQmVmb3JlUmVuZGVyKCBfdGhpcywgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCApO1xuXG5cdFx0XHRvYmplY3QubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0b2JqZWN0Lm5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIG9iamVjdC5tb2RlbFZpZXdNYXRyaXggKTtcblxuXHRcdFx0bWF0ZXJpYWwub25CZWZvcmVSZW5kZXIoIF90aGlzLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgb2JqZWN0LCBncm91cCApO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlICYmIG1hdGVyaWFsLnNpZGUgPT09IERvdWJsZVNpZGUgJiYgbWF0ZXJpYWwuZm9yY2VTaW5nbGVQYXNzID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gQmFja1NpZGU7XG5cdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0X3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KCBjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKTtcblxuXHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gRnJvbnRTaWRlO1xuXHRcdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCggY2FtZXJhLCBzY2VuZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICk7XG5cblx0XHRcdFx0bWF0ZXJpYWwuc2lkZSA9IERvdWJsZVNpZGU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KCBjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvYmplY3Qub25BZnRlclJlbmRlciggX3RoaXMsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFByb2dyYW0oIG1hdGVyaWFsLCBzY2VuZSwgb2JqZWN0ICkge1xuXG5cdFx0XHRpZiAoIHNjZW5lLmlzU2NlbmUgIT09IHRydWUgKSBzY2VuZSA9IF9lbXB0eVNjZW5lOyAvLyBzY2VuZSBjb3VsZCBiZSBhIE1lc2gsIExpbmUsIFBvaW50cywgLi4uXG5cblx0XHRcdGNvbnN0IG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApO1xuXG5cdFx0XHRjb25zdCBsaWdodHMgPSBjdXJyZW50UmVuZGVyU3RhdGUuc3RhdGUubGlnaHRzO1xuXHRcdFx0Y29uc3Qgc2hhZG93c0FycmF5ID0gY3VycmVudFJlbmRlclN0YXRlLnN0YXRlLnNoYWRvd3NBcnJheTtcblxuXHRcdFx0Y29uc3QgbGlnaHRzU3RhdGVWZXJzaW9uID0gbGlnaHRzLnN0YXRlLnZlcnNpb247XG5cblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSBwcm9ncmFtQ2FjaGUuZ2V0UGFyYW1ldGVycyggbWF0ZXJpYWwsIGxpZ2h0cy5zdGF0ZSwgc2hhZG93c0FycmF5LCBzY2VuZSwgb2JqZWN0ICk7XG5cdFx0XHRjb25zdCBwcm9ncmFtQ2FjaGVLZXkgPSBwcm9ncmFtQ2FjaGUuZ2V0UHJvZ3JhbUNhY2hlS2V5KCBwYXJhbWV0ZXJzICk7XG5cblx0XHRcdGxldCBwcm9ncmFtcyA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtcztcblxuXHRcdFx0Ly8gYWx3YXlzIHVwZGF0ZSBlbnZpcm9ubWVudCBhbmQgZm9nIC0gY2hhbmdpbmcgdGhlc2UgdHJpZ2dlciBhbiBnZXRQcm9ncmFtIGNhbGwsIGJ1dCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHByb2dyYW0gZG9lc24ndCBjaGFuZ2VcblxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmVudmlyb25tZW50ID0gbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA/IHNjZW5lLmVudmlyb25tZW50IDogbnVsbDtcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5mb2cgPSBzY2VuZS5mb2c7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuZW52TWFwID0gKCBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID8gY3ViZXV2bWFwcyA6IGN1YmVtYXBzICkuZ2V0KCBtYXRlcmlhbC5lbnZNYXAgfHwgbWF0ZXJpYWxQcm9wZXJ0aWVzLmVudmlyb25tZW50ICk7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuZW52TWFwUm90YXRpb24gPSAoIG1hdGVyaWFsUHJvcGVydGllcy5lbnZpcm9ubWVudCAhPT0gbnVsbCAmJiBtYXRlcmlhbC5lbnZNYXAgPT09IG51bGwgKSA/IHNjZW5lLmVudmlyb25tZW50Um90YXRpb24gOiBtYXRlcmlhbC5lbnZNYXBSb3RhdGlvbjtcblxuXHRcdFx0aWYgKCBwcm9ncmFtcyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIG5ldyBtYXRlcmlhbFxuXG5cdFx0XHRcdG1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcblxuXHRcdFx0XHRwcm9ncmFtcyA9IG5ldyBNYXAoKTtcblx0XHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW1zID0gcHJvZ3JhbXM7XG5cblx0XHRcdH1cblxuXHRcdFx0bGV0IHByb2dyYW0gPSBwcm9ncmFtcy5nZXQoIHByb2dyYW1DYWNoZUtleSApO1xuXG5cdFx0XHRpZiAoIHByb2dyYW0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBlYXJseSBvdXQgaWYgcHJvZ3JhbSBhbmQgbGlnaHQgc3RhdGUgaXMgaWRlbnRpY2FsXG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbFByb3BlcnRpZXMuY3VycmVudFByb2dyYW0gPT09IHByb2dyYW0gJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0c1N0YXRlVmVyc2lvbiA9PT0gbGlnaHRzU3RhdGVWZXJzaW9uICkge1xuXG5cdFx0XHRcdFx0dXBkYXRlQ29tbW9uTWF0ZXJpYWxQcm9wZXJ0aWVzKCBtYXRlcmlhbCwgcGFyYW1ldGVycyApO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHByb2dyYW07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHBhcmFtZXRlcnMudW5pZm9ybXMgPSBwcm9ncmFtQ2FjaGUuZ2V0VW5pZm9ybXMoIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0bWF0ZXJpYWwub25CZWZvcmVDb21waWxlKCBwYXJhbWV0ZXJzLCBfdGhpcyApO1xuXG5cdFx0XHRcdHByb2dyYW0gPSBwcm9ncmFtQ2FjaGUuYWNxdWlyZVByb2dyYW0oIHBhcmFtZXRlcnMsIHByb2dyYW1DYWNoZUtleSApO1xuXHRcdFx0XHRwcm9ncmFtcy5zZXQoIHByb2dyYW1DYWNoZUtleSwgcHJvZ3JhbSApO1xuXG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3JtcyA9IHBhcmFtZXRlcnMudW5pZm9ybXM7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXM7XG5cblx0XHRcdGlmICggKCAhIG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgJiYgISBtYXRlcmlhbC5pc1Jhd1NoYWRlck1hdGVyaWFsICkgfHwgbWF0ZXJpYWwuY2xpcHBpbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXMuY2xpcHBpbmdQbGFuZXMgPSBjbGlwcGluZy51bmlmb3JtO1xuXG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZUNvbW1vbk1hdGVyaWFsUHJvcGVydGllcyggbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKTtcblxuXHRcdFx0Ly8gc3RvcmUgdGhlIGxpZ2h0IHNldHVwIGl0IHdhcyBjcmVhdGVkIGZvclxuXG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMubmVlZHNMaWdodHMgPSBtYXRlcmlhbE5lZWRzTGlnaHRzKCBtYXRlcmlhbCApO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0c1N0YXRlVmVyc2lvbiA9IGxpZ2h0c1N0YXRlVmVyc2lvbjtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbFByb3BlcnRpZXMubmVlZHNMaWdodHMgKSB7XG5cblx0XHRcdFx0Ly8gd2lyZSB1cCB0aGUgbWF0ZXJpYWwgdG8gdGhpcyByZW5kZXJlcidzIGxpZ2h0aW5nIHN0YXRlXG5cblx0XHRcdFx0dW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMuc3RhdGUuYW1iaWVudDtcblx0XHRcdFx0dW5pZm9ybXMubGlnaHRQcm9iZS52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5wcm9iZTtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUuZGlyZWN0aW9uYWw7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzLnZhbHVlID0gbGlnaHRzLnN0YXRlLmRpcmVjdGlvbmFsU2hhZG93O1xuXHRcdFx0XHR1bmlmb3Jtcy5zcG90TGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3Q7XG5cdFx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodFNoYWRvd3MudmFsdWUgPSBsaWdodHMuc3RhdGUuc3BvdFNoYWRvdztcblx0XHRcdFx0dW5pZm9ybXMucmVjdEFyZWFMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUucmVjdEFyZWE7XG5cdFx0XHRcdHVuaWZvcm1zLmx0Y18xLnZhbHVlID0gbGlnaHRzLnN0YXRlLnJlY3RBcmVhTFRDMTtcblx0XHRcdFx0dW5pZm9ybXMubHRjXzIudmFsdWUgPSBsaWdodHMuc3RhdGUucmVjdEFyZWFMVEMyO1xuXHRcdFx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5wb2ludDtcblx0XHRcdFx0dW5pZm9ybXMucG9pbnRMaWdodFNoYWRvd3MudmFsdWUgPSBsaWdodHMuc3RhdGUucG9pbnRTaGFkb3c7XG5cdFx0XHRcdHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUuaGVtaTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbFNoYWRvd01hcC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hcDtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXgudmFsdWUgPSBsaWdodHMuc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg7XG5cdFx0XHRcdHVuaWZvcm1zLnNwb3RTaGFkb3dNYXAudmFsdWUgPSBsaWdodHMuc3RhdGUuc3BvdFNoYWRvd01hcDtcblx0XHRcdFx0dW5pZm9ybXMuc3BvdExpZ2h0TWF0cml4LnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3RMaWdodE1hdHJpeDtcblx0XHRcdFx0dW5pZm9ybXMuc3BvdExpZ2h0TWFwLnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3RMaWdodE1hcDtcblx0XHRcdFx0dW5pZm9ybXMucG9pbnRTaGFkb3dNYXAudmFsdWUgPSBsaWdodHMuc3RhdGUucG9pbnRTaGFkb3dNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLnBvaW50U2hhZG93TWF0cml4LnZhbHVlID0gbGlnaHRzLnN0YXRlLnBvaW50U2hhZG93TWF0cml4O1xuXHRcdFx0XHQvLyBUT0RPIChhYmVsbmF0aW9uKTogYWRkIGFyZWEgbGlnaHRzIHNoYWRvdyBpbmZvIHRvIHVuaWZvcm1zXG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmN1cnJlbnRQcm9ncmFtID0gcHJvZ3JhbTtcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QgPSBudWxsO1xuXG5cdFx0XHRyZXR1cm4gcHJvZ3JhbTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFVuaWZvcm1MaXN0KCBtYXRlcmlhbFByb3BlcnRpZXMgKSB7XG5cblx0XHRcdGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRjb25zdCBwcm9nVW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMuY3VycmVudFByb2dyYW0uZ2V0VW5pZm9ybXMoKTtcblx0XHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdCA9IFdlYkdMVW5pZm9ybXMuc2VxV2l0aFZhbHVlKCBwcm9nVW5pZm9ybXMuc2VxLCBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZUNvbW1vbk1hdGVyaWFsUHJvcGVydGllcyggbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRcdGNvbnN0IG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApO1xuXG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMub3V0cHV0Q29sb3JTcGFjZSA9IHBhcmFtZXRlcnMub3V0cHV0Q29sb3JTcGFjZTtcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5iYXRjaGluZyA9IHBhcmFtZXRlcnMuYmF0Y2hpbmc7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuYmF0Y2hpbmdDb2xvciA9IHBhcmFtZXRlcnMuYmF0Y2hpbmdDb2xvcjtcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5pbnN0YW5jaW5nID0gcGFyYW1ldGVycy5pbnN0YW5jaW5nO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmluc3RhbmNpbmdDb2xvciA9IHBhcmFtZXRlcnMuaW5zdGFuY2luZ0NvbG9yO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmluc3RhbmNpbmdNb3JwaCA9IHBhcmFtZXRlcnMuaW5zdGFuY2luZ01vcnBoO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnNraW5uaW5nID0gcGFyYW1ldGVycy5za2lubmluZztcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5tb3JwaFRhcmdldHMgPSBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cztcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5tb3JwaE5vcm1hbHMgPSBwYXJhbWV0ZXJzLm1vcnBoTm9ybWFscztcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5tb3JwaENvbG9ycyA9IHBhcmFtZXRlcnMubW9ycGhDb2xvcnM7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMubW9ycGhUYXJnZXRzQ291bnQgPSBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0c0NvdW50O1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUNsaXBwaW5nUGxhbmVzID0gcGFyYW1ldGVycy5udW1DbGlwcGluZ1BsYW5lcztcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5udW1JbnRlcnNlY3Rpb24gPSBwYXJhbWV0ZXJzLm51bUNsaXBJbnRlcnNlY3Rpb247XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMudmVydGV4QWxwaGFzID0gcGFyYW1ldGVycy52ZXJ0ZXhBbHBoYXM7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMudmVydGV4VGFuZ2VudHMgPSBwYXJhbWV0ZXJzLnZlcnRleFRhbmdlbnRzO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnRvbmVNYXBwaW5nID0gcGFyYW1ldGVycy50b25lTWFwcGluZztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldFByb2dyYW0oIGNhbWVyYSwgc2NlbmUsIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0ICkge1xuXG5cdFx0XHRpZiAoIHNjZW5lLmlzU2NlbmUgIT09IHRydWUgKSBzY2VuZSA9IF9lbXB0eVNjZW5lOyAvLyBzY2VuZSBjb3VsZCBiZSBhIE1lc2gsIExpbmUsIFBvaW50cywgLi4uXG5cblx0XHRcdHRleHR1cmVzLnJlc2V0VGV4dHVyZVVuaXRzKCk7XG5cblx0XHRcdGNvbnN0IGZvZyA9IHNjZW5lLmZvZztcblx0XHRcdGNvbnN0IGVudmlyb25tZW50ID0gbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA/IHNjZW5lLmVudmlyb25tZW50IDogbnVsbDtcblx0XHRcdGNvbnN0IGNvbG9yU3BhY2UgPSAoIF9jdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsICkgPyBfdGhpcy5vdXRwdXRDb2xvclNwYWNlIDogKCBfY3VycmVudFJlbmRlclRhcmdldC5pc1hSUmVuZGVyVGFyZ2V0ID09PSB0cnVlID8gX2N1cnJlbnRSZW5kZXJUYXJnZXQudGV4dHVyZS5jb2xvclNwYWNlIDogTGluZWFyU1JHQkNvbG9yU3BhY2UgKTtcblx0XHRcdGNvbnN0IGVudk1hcCA9ICggbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA/IGN1YmV1dm1hcHMgOiBjdWJlbWFwcyApLmdldCggbWF0ZXJpYWwuZW52TWFwIHx8IGVudmlyb25tZW50ICk7XG5cdFx0XHRjb25zdCB2ZXJ0ZXhBbHBoYXMgPSBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPT09IHRydWUgJiYgISEgZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvciAmJiBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLml0ZW1TaXplID09PSA0O1xuXHRcdFx0Y29uc3QgdmVydGV4VGFuZ2VudHMgPSAhISBnZW9tZXRyeS5hdHRyaWJ1dGVzLnRhbmdlbnQgJiYgKCAhISBtYXRlcmlhbC5ub3JtYWxNYXAgfHwgbWF0ZXJpYWwuYW5pc290cm9weSA+IDAgKTtcblx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0cyA9ICEhIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdGNvbnN0IG1vcnBoTm9ybWFscyA9ICEhIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWw7XG5cdFx0XHRjb25zdCBtb3JwaENvbG9ycyA9ICEhIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvcjtcblxuXHRcdFx0bGV0IHRvbmVNYXBwaW5nID0gTm9Ub25lTWFwcGluZztcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC50b25lTWFwcGVkICkge1xuXG5cdFx0XHRcdGlmICggX2N1cnJlbnRSZW5kZXJUYXJnZXQgPT09IG51bGwgfHwgX2N1cnJlbnRSZW5kZXJUYXJnZXQuaXNYUlJlbmRlclRhcmdldCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHRvbmVNYXBwaW5nID0gX3RoaXMudG9uZU1hcHBpbmc7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uIHx8IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgfHwgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLmNvbG9yO1xuXHRcdFx0Y29uc3QgbW9ycGhUYXJnZXRzQ291bnQgPSAoIG1vcnBoQXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSA/IG1vcnBoQXR0cmlidXRlLmxlbmd0aCA6IDA7XG5cblx0XHRcdGNvbnN0IG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApO1xuXHRcdFx0Y29uc3QgbGlnaHRzID0gY3VycmVudFJlbmRlclN0YXRlLnN0YXRlLmxpZ2h0cztcblxuXHRcdFx0aWYgKCBfY2xpcHBpbmdFbmFibGVkID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGlmICggX2xvY2FsQ2xpcHBpbmdFbmFibGVkID09PSB0cnVlIHx8IGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB1c2VDYWNoZSA9XG5cdFx0XHRcdFx0XHRjYW1lcmEgPT09IF9jdXJyZW50Q2FtZXJhICYmXG5cdFx0XHRcdFx0XHRtYXRlcmlhbC5pZCA9PT0gX2N1cnJlbnRNYXRlcmlhbElkO1xuXG5cdFx0XHRcdFx0Ly8gd2UgbWlnaHQgd2FudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gd2l0aCBzb21lIENsaXBwaW5nR3JvdXBcblx0XHRcdFx0XHQvLyBvYmplY3QgaW5zdGVhZCBvZiB0aGUgbWF0ZXJpYWwsIG9uY2UgaXQgYmVjb21lcyBmZWFzaWJsZVxuXHRcdFx0XHRcdC8vICgjODQ2NSwgIzgzNzkpXG5cdFx0XHRcdFx0Y2xpcHBpbmcuc2V0U3RhdGUoIG1hdGVyaWFsLCBjYW1lcmEsIHVzZUNhY2hlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cblx0XHRcdGxldCBuZWVkc1Byb2dyYW1DaGFuZ2UgPSBmYWxzZTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC52ZXJzaW9uID09PSBtYXRlcmlhbFByb3BlcnRpZXMuX192ZXJzaW9uICkge1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLm5lZWRzTGlnaHRzICYmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0c1N0YXRlVmVyc2lvbiAhPT0gbGlnaHRzLnN0YXRlLnZlcnNpb24gKSApIHtcblxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLm91dHB1dENvbG9yU3BhY2UgIT09IGNvbG9yU3BhY2UgKSB7XG5cblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0JhdGNoZWRNZXNoICYmIG1hdGVyaWFsUHJvcGVydGllcy5iYXRjaGluZyA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoICEgb2JqZWN0LmlzQmF0Y2hlZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmJhdGNoaW5nID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNCYXRjaGVkTWVzaCAmJiBtYXRlcmlhbFByb3BlcnRpZXMuYmF0Y2hpbmdDb2xvciA9PT0gdHJ1ZSAmJiBvYmplY3QuY29sb3JUZXh0dXJlID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNCYXRjaGVkTWVzaCAmJiBtYXRlcmlhbFByb3BlcnRpZXMuYmF0Y2hpbmdDb2xvciA9PT0gZmFsc2UgJiYgb2JqZWN0LmNvbG9yVGV4dHVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzSW5zdGFuY2VkTWVzaCAmJiBtYXRlcmlhbFByb3BlcnRpZXMuaW5zdGFuY2luZyA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoICEgb2JqZWN0LmlzSW5zdGFuY2VkTWVzaCAmJiBtYXRlcmlhbFByb3BlcnRpZXMuaW5zdGFuY2luZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzU2tpbm5lZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLnNraW5uaW5nID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggISBvYmplY3QuaXNTa2lubmVkTWVzaCAmJiBtYXRlcmlhbFByb3BlcnRpZXMuc2tpbm5pbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0luc3RhbmNlZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmluc3RhbmNpbmdDb2xvciA9PT0gdHJ1ZSAmJiBvYmplY3QuaW5zdGFuY2VDb2xvciA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzSW5zdGFuY2VkTWVzaCAmJiBtYXRlcmlhbFByb3BlcnRpZXMuaW5zdGFuY2luZ0NvbG9yID09PSBmYWxzZSAmJiBvYmplY3QuaW5zdGFuY2VDb2xvciAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzSW5zdGFuY2VkTWVzaCAmJiBtYXRlcmlhbFByb3BlcnRpZXMuaW5zdGFuY2luZ01vcnBoID09PSB0cnVlICYmIG9iamVjdC5tb3JwaFRleHR1cmUgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0luc3RhbmNlZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmluc3RhbmNpbmdNb3JwaCA9PT0gZmFsc2UgJiYgb2JqZWN0Lm1vcnBoVGV4dHVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLmVudk1hcCAhPT0gZW52TWFwICkge1xuXG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5mb2cgPT09IHRydWUgJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmZvZyAhPT0gZm9nICkge1xuXG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbFByb3BlcnRpZXMubnVtQ2xpcHBpbmdQbGFuZXMgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRcdCggbWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUNsaXBwaW5nUGxhbmVzICE9PSBjbGlwcGluZy5udW1QbGFuZXMgfHxcblx0XHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMubnVtSW50ZXJzZWN0aW9uICE9PSBjbGlwcGluZy5udW1JbnRlcnNlY3Rpb24gKSApIHtcblxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLnZlcnRleEFscGhhcyAhPT0gdmVydGV4QWxwaGFzICkge1xuXG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbFByb3BlcnRpZXMudmVydGV4VGFuZ2VudHMgIT09IHZlcnRleFRhbmdlbnRzICkge1xuXG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbFByb3BlcnRpZXMubW9ycGhUYXJnZXRzICE9PSBtb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsUHJvcGVydGllcy5tb3JwaE5vcm1hbHMgIT09IG1vcnBoTm9ybWFscyApIHtcblxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoQ29sb3JzICE9PSBtb3JwaENvbG9ycyApIHtcblxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLnRvbmVNYXBwaW5nICE9PSB0b25lTWFwcGluZyApIHtcblxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoVGFyZ2V0c0NvdW50ICE9PSBtb3JwaFRhcmdldHNDb3VudCApIHtcblxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5fX3ZlcnNpb24gPSBtYXRlcmlhbC52ZXJzaW9uO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cblx0XHRcdGxldCBwcm9ncmFtID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLmN1cnJlbnRQcm9ncmFtO1xuXG5cdFx0XHRpZiAoIG5lZWRzUHJvZ3JhbUNoYW5nZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRwcm9ncmFtID0gZ2V0UHJvZ3JhbSggbWF0ZXJpYWwsIHNjZW5lLCBvYmplY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgcmVmcmVzaFByb2dyYW0gPSBmYWxzZTtcblx0XHRcdGxldCByZWZyZXNoTWF0ZXJpYWwgPSBmYWxzZTtcblx0XHRcdGxldCByZWZyZXNoTGlnaHRzID0gZmFsc2U7XG5cblx0XHRcdGNvbnN0IHBfdW5pZm9ybXMgPSBwcm9ncmFtLmdldFVuaWZvcm1zKCksXG5cdFx0XHRcdG1fdW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXM7XG5cblx0XHRcdGlmICggc3RhdGUudXNlUHJvZ3JhbSggcHJvZ3JhbS5wcm9ncmFtICkgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFByb2dyYW0gPSB0cnVlO1xuXHRcdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xuXHRcdFx0XHRyZWZyZXNoTGlnaHRzID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlkICE9PSBfY3VycmVudE1hdGVyaWFsSWQgKSB7XG5cblx0XHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gbWF0ZXJpYWwuaWQ7XG5cblx0XHRcdFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHJlZnJlc2hQcm9ncmFtIHx8IF9jdXJyZW50Q2FtZXJhICE9PSBjYW1lcmEgKSB7XG5cblx0XHRcdFx0Ly8gY29tbW9uIGNhbWVyYSB1bmlmb3Jtc1xuXG5cdFx0XHRcdGNvbnN0IHJldmVyc2VEZXB0aEJ1ZmZlciA9IHN0YXRlLmJ1ZmZlcnMuZGVwdGguZ2V0UmV2ZXJzZWQoKTtcblxuXHRcdFx0XHRpZiAoIHJldmVyc2VEZXB0aEJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdF9jdXJyZW50UHJvamVjdGlvbk1hdHJpeC5jb3B5KCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuXG5cdFx0XHRcdFx0dG9Ob3JtYWxpemVkUHJvamVjdGlvbk1hdHJpeCggX2N1cnJlbnRQcm9qZWN0aW9uTWF0cml4ICk7XG5cdFx0XHRcdFx0dG9SZXZlcnNlZFByb2plY3Rpb25NYXRyaXgoIF9jdXJyZW50UHJvamVjdGlvbk1hdHJpeCApO1xuXG5cdFx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAncHJvamVjdGlvbk1hdHJpeCcsIF9jdXJyZW50UHJvamVjdGlvbk1hdHJpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdwcm9qZWN0aW9uTWF0cml4JywgY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAndmlld01hdHJpeCcsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblxuXHRcdFx0XHRjb25zdCB1Q2FtUG9zID0gcF91bmlmb3Jtcy5tYXAuY2FtZXJhUG9zaXRpb247XG5cblx0XHRcdFx0aWYgKCB1Q2FtUG9zICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR1Q2FtUG9zLnNldFZhbHVlKCBfZ2wsIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ2xvZ0RlcHRoQnVmRkMnLFxuXHRcdFx0XHRcdFx0Mi4wIC8gKCBNYXRoLmxvZyggY2FtZXJhLmZhciArIDEuMCApIC8gTWF0aC5MTjIgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjb25zaWRlciBtb3ZpbmcgaXNPcnRob2dyYXBoaWMgdG8gVW5pZm9ybUxpYiBhbmQgV2ViR0xNYXRlcmlhbHMsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjY0NjcjaXNzdWVjb21tZW50LTE2NDUxODUwNjdcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgfHxcblx0XHRcdFx0XHRtYXRlcmlhbC5pc01lc2hUb29uTWF0ZXJpYWwgfHxcblx0XHRcdFx0XHRtYXRlcmlhbC5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcblx0XHRcdFx0XHRtYXRlcmlhbC5pc01lc2hCYXNpY01hdGVyaWFsIHx8XG5cdFx0XHRcdFx0bWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCB8fFxuXHRcdFx0XHRcdG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdpc09ydGhvZ3JhcGhpYycsIGNhbWVyYS5pc09ydGhvZ3JhcGhpY0NhbWVyYSA9PT0gdHJ1ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIF9jdXJyZW50Q2FtZXJhICE9PSBjYW1lcmEgKSB7XG5cblx0XHRcdFx0XHRfY3VycmVudENhbWVyYSA9IGNhbWVyYTtcblxuXHRcdFx0XHRcdC8vIGxpZ2h0aW5nIHVuaWZvcm1zIGRlcGVuZCBvbiB0aGUgY2FtZXJhIHNvIGVuZm9yY2UgYW4gdXBkYXRlXG5cdFx0XHRcdFx0Ly8gbm93LCBpbiBjYXNlIHRoaXMgbWF0ZXJpYWwgc3VwcG9ydHMgbGlnaHRzIC0gb3IgbGF0ZXIsIHdoZW5cblx0XHRcdFx0XHQvLyB0aGUgbmV4dCBtYXRlcmlhbCB0aGF0IGRvZXMgZ2V0cyBhY3RpdmF0ZWQ6XG5cblx0XHRcdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1x0XHQvLyBzZXQgdG8gdHJ1ZSBvbiBtYXRlcmlhbCBjaGFuZ2Vcblx0XHRcdFx0XHRyZWZyZXNoTGlnaHRzID0gdHJ1ZTtcdFx0Ly8gcmVtYWlucyBzZXQgdW50aWwgdXBkYXRlIGRvbmVcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gc2tpbm5pbmcgYW5kIG1vcnBoIHRhcmdldCB1bmlmb3JtcyBtdXN0IGJlIHNldCBldmVuIGlmIG1hdGVyaWFsIGRpZG4ndCBjaGFuZ2Vcblx0XHRcdC8vIGF1dG8tc2V0dGluZyBvZiB0ZXh0dXJlIHVuaXQgZm9yIGJvbmUgYW5kIG1vcnBoIHRleHR1cmUgbXVzdCBnbyBiZWZvcmUgb3RoZXIgdGV4dHVyZXNcblx0XHRcdC8vIG90aGVyd2lzZSB0ZXh0dXJlcyB1c2VkIGZvciBza2lubmluZyBhbmQgbW9ycGhpbmcgY2FuIHRha2Ugb3ZlciB0ZXh0dXJlIHVuaXRzIHJlc2VydmVkIGZvciBvdGhlciBtYXRlcmlhbCB0ZXh0dXJlc1xuXG5cdFx0XHRpZiAoIG9iamVjdC5pc1NraW5uZWRNZXNoICkge1xuXG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0T3B0aW9uYWwoIF9nbCwgb2JqZWN0LCAnYmluZE1hdHJpeCcgKTtcblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRPcHRpb25hbCggX2dsLCBvYmplY3QsICdiaW5kTWF0cml4SW52ZXJzZScgKTtcblxuXHRcdFx0XHRjb25zdCBza2VsZXRvbiA9IG9iamVjdC5za2VsZXRvbjtcblxuXHRcdFx0XHRpZiAoIHNrZWxldG9uICkge1xuXG5cdFx0XHRcdFx0aWYgKCBza2VsZXRvbi5ib25lVGV4dHVyZSA9PT0gbnVsbCApIHNrZWxldG9uLmNvbXB1dGVCb25lVGV4dHVyZSgpO1xuXG5cdFx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAnYm9uZVRleHR1cmUnLCBza2VsZXRvbi5ib25lVGV4dHVyZSwgdGV4dHVyZXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvYmplY3QuaXNCYXRjaGVkTWVzaCApIHtcblxuXHRcdFx0XHRwX3VuaWZvcm1zLnNldE9wdGlvbmFsKCBfZ2wsIG9iamVjdCwgJ2JhdGNoaW5nVGV4dHVyZScgKTtcblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAnYmF0Y2hpbmdUZXh0dXJlJywgb2JqZWN0Ll9tYXRyaWNlc1RleHR1cmUsIHRleHR1cmVzICk7XG5cblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRPcHRpb25hbCggX2dsLCBvYmplY3QsICdiYXRjaGluZ0lkVGV4dHVyZScgKTtcblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAnYmF0Y2hpbmdJZFRleHR1cmUnLCBvYmplY3QuX2luZGlyZWN0VGV4dHVyZSwgdGV4dHVyZXMgKTtcblxuXHRcdFx0XHRwX3VuaWZvcm1zLnNldE9wdGlvbmFsKCBfZ2wsIG9iamVjdCwgJ2JhdGNoaW5nQ29sb3JUZXh0dXJlJyApO1xuXHRcdFx0XHRpZiAoIG9iamVjdC5fY29sb3JzVGV4dHVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ2JhdGNoaW5nQ29sb3JUZXh0dXJlJywgb2JqZWN0Ll9jb2xvcnNUZXh0dXJlLCB0ZXh0dXJlcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XG5cblx0XHRcdGlmICggbW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgfHwgbW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCAhPT0gdW5kZWZpbmVkIHx8ICggbW9ycGhBdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0XHRtb3JwaHRhcmdldHMudXBkYXRlKCBvYmplY3QsIGdlb21ldHJ5LCBwcm9ncmFtICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCByZWZyZXNoTWF0ZXJpYWwgfHwgbWF0ZXJpYWxQcm9wZXJ0aWVzLnJlY2VpdmVTaGFkb3cgIT09IG9iamVjdC5yZWNlaXZlU2hhZG93ICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5yZWNlaXZlU2hhZG93ID0gb2JqZWN0LnJlY2VpdmVTaGFkb3c7XG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ3JlY2VpdmVTaGFkb3cnLCBvYmplY3QucmVjZWl2ZVNoYWRvdyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yNDQ2NyNpc3N1ZWNvbW1lbnQtMTIwOTAzMTUxMlxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlzTWVzaEdvdXJhdWRNYXRlcmlhbCAmJiBtYXRlcmlhbC5lbnZNYXAgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0bV91bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBlbnZNYXA7XG5cblx0XHRcdFx0bV91bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gKCBlbnZNYXAuaXNDdWJlVGV4dHVyZSAmJiBlbnZNYXAuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID09PSBmYWxzZSApID8gLSAxIDogMTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgJiYgbWF0ZXJpYWwuZW52TWFwID09PSBudWxsICYmIHNjZW5lLmVudmlyb25tZW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdG1fdW5pZm9ybXMuZW52TWFwSW50ZW5zaXR5LnZhbHVlID0gc2NlbmUuZW52aXJvbm1lbnRJbnRlbnNpdHk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCByZWZyZXNoTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAndG9uZU1hcHBpbmdFeHBvc3VyZScsIF90aGlzLnRvbmVNYXBwaW5nRXhwb3N1cmUgKTtcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsUHJvcGVydGllcy5uZWVkc0xpZ2h0cyApIHtcblxuXHRcdFx0XHRcdC8vIHRoZSBjdXJyZW50IG1hdGVyaWFsIHJlcXVpcmVzIGxpZ2h0aW5nIGluZm9cblxuXHRcdFx0XHRcdC8vIG5vdGU6IGFsbCBsaWdodGluZyB1bmlmb3JtcyBhcmUgYWx3YXlzIHNldCBjb3JyZWN0bHlcblx0XHRcdFx0XHQvLyB0aGV5IHNpbXBseSByZWZlcmVuY2UgdGhlIHJlbmRlcmVyJ3Mgc3RhdGUgZm9yIHRoZWlyXG5cdFx0XHRcdFx0Ly8gdmFsdWVzXG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvLyB1c2UgdGhlIGN1cnJlbnQgbWF0ZXJpYWwncyAubmVlZHNVcGRhdGUgZmxhZ3MgdG8gc2V0XG5cdFx0XHRcdFx0Ly8gdGhlIEdMIHN0YXRlIHdoZW4gcmVxdWlyZWRcblxuXHRcdFx0XHRcdG1hcmtVbmlmb3Jtc0xpZ2h0c05lZWRzVXBkYXRlKCBtX3VuaWZvcm1zLCByZWZyZXNoTGlnaHRzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlZnJlc2ggdW5pZm9ybXMgY29tbW9uIHRvIHNldmVyYWwgbWF0ZXJpYWxzXG5cblx0XHRcdFx0aWYgKCBmb2cgJiYgbWF0ZXJpYWwuZm9nID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWxzLnJlZnJlc2hGb2dVbmlmb3JtcyggbV91bmlmb3JtcywgZm9nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1hdGVyaWFscy5yZWZyZXNoTWF0ZXJpYWxVbmlmb3JtcyggbV91bmlmb3JtcywgbWF0ZXJpYWwsIF9waXhlbFJhdGlvLCBfaGVpZ2h0LCBjdXJyZW50UmVuZGVyU3RhdGUuc3RhdGUudHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0WyBjYW1lcmEuaWQgXSApO1xuXG5cdFx0XHRcdFdlYkdMVW5pZm9ybXMudXBsb2FkKCBfZ2wsIGdldFVuaWZvcm1MaXN0KCBtYXRlcmlhbFByb3BlcnRpZXMgKSwgbV91bmlmb3JtcywgdGV4dHVyZXMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgJiYgbWF0ZXJpYWwudW5pZm9ybXNOZWVkVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFdlYkdMVW5pZm9ybXMudXBsb2FkKCBfZ2wsIGdldFVuaWZvcm1MaXN0KCBtYXRlcmlhbFByb3BlcnRpZXMgKSwgbV91bmlmb3JtcywgdGV4dHVyZXMgKTtcblx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5pc1Nwcml0ZU1hdGVyaWFsICkge1xuXG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ2NlbnRlcicsIG9iamVjdC5jZW50ZXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb21tb24gbWF0cmljZXNcblxuXHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAnbW9kZWxWaWV3TWF0cml4Jywgb2JqZWN0Lm1vZGVsVmlld01hdHJpeCApO1xuXHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAnbm9ybWFsTWF0cml4Jywgb2JqZWN0Lm5vcm1hbE1hdHJpeCApO1xuXHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAnbW9kZWxNYXRyaXgnLCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0Ly8gVUJPc1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNSYXdTaGFkZXJNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRjb25zdCBncm91cHMgPSBtYXRlcmlhbC51bmlmb3Jtc0dyb3VwcztcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cblx0XHRcdFx0XHR1bmlmb3Jtc0dyb3Vwcy51cGRhdGUoIGdyb3VwLCBwcm9ncmFtICk7XG5cdFx0XHRcdFx0dW5pZm9ybXNHcm91cHMuYmluZCggZ3JvdXAsIHByb2dyYW0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb2dyYW07XG5cblx0XHR9XG5cblx0XHQvLyBJZiB1bmlmb3JtcyBhcmUgbWFya2VkIGFzIGNsZWFuLCB0aGV5IGRvbid0IG5lZWQgdG8gYmUgbG9hZGVkIHRvIHRoZSBHUFUuXG5cblx0XHRmdW5jdGlvbiBtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggdW5pZm9ybXMsIHZhbHVlICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdFx0dW5pZm9ybXMubGlnaHRQcm9iZS5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG5cdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodFNoYWRvd3MubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLnBvaW50TGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0U2hhZG93cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdFx0dW5pZm9ybXMuc3BvdExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdFx0dW5pZm9ybXMuc3BvdExpZ2h0U2hhZG93cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdFx0dW5pZm9ybXMucmVjdEFyZWFMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG1hdGVyaWFsTmVlZHNMaWdodHMoIG1hdGVyaWFsICkge1xuXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWwuaXNNZXNoTGFtYmVydE1hdGVyaWFsIHx8IG1hdGVyaWFsLmlzTWVzaFRvb25NYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsIHx8XG5cdFx0XHRcdG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNTaGFkb3dNYXRlcmlhbCB8fFxuXHRcdFx0XHQoIG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgJiYgbWF0ZXJpYWwubGlnaHRzID09PSB0cnVlICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmdldEFjdGl2ZUN1YmVGYWNlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gX2N1cnJlbnRBY3RpdmVDdWJlRmFjZTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldEFjdGl2ZU1pcG1hcExldmVsID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gX2N1cnJlbnRBY3RpdmVNaXBtYXBMZXZlbDtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIF9jdXJyZW50UmVuZGVyVGFyZ2V0O1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0UmVuZGVyVGFyZ2V0VGV4dHVyZXMgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgY29sb3JUZXh0dXJlLCBkZXB0aFRleHR1cmUgKSB7XG5cblx0XHRcdHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlID0gY29sb3JUZXh0dXJlO1xuXHRcdFx0cHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSA9IGRlcHRoVGV4dHVyZTtcblxuXHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX19oYXNFeHRlcm5hbFRleHR1cmVzID0gdHJ1ZTtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX2F1dG9BbGxvY2F0ZURlcHRoQnVmZmVyID0gZGVwdGhUZXh0dXJlID09PSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggISByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fYXV0b0FsbG9jYXRlRGVwdGhCdWZmZXIgKSB7XG5cblx0XHRcdFx0Ly8gVGhlIG11bHRpc2FtcGxlX3JlbmRlcl90b190ZXh0dXJlIGV4dGVuc2lvbiBkb2Vzbid0IHdvcmsgcHJvcGVybHkgaWYgdGhlcmVcblx0XHRcdFx0Ly8gYXJlIG1pZGZyYW1lIGZsdXNoZXMgYW5kIGFuIGV4dGVybmFsIGRlcHRoIGJ1ZmZlci4gRGlzYWJsZSB1c2Ugb2YgdGhlIGV4dGVuc2lvbi5cblx0XHRcdFx0aWYgKCBleHRlbnNpb25zLmhhcyggJ1dFQkdMX211bHRpc2FtcGxlZF9yZW5kZXJfdG9fdGV4dHVyZScgKSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFJlbmRlci10by10ZXh0dXJlIGV4dGVuc2lvbiB3YXMgZGlzYWJsZWQgYmVjYXVzZSBhbiBleHRlcm5hbCB0ZXh0dXJlIHdhcyBwcm92aWRlZCcgKTtcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fdXNlUmVuZGVyVG9UZXh0dXJlID0gZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXRGcmFtZWJ1ZmZlciA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCBkZWZhdWx0RnJhbWVidWZmZXIgKSB7XG5cblx0XHRcdGNvbnN0IHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IGRlZmF1bHRGcmFtZWJ1ZmZlcjtcblx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX191c2VEZWZhdWx0RnJhbWVidWZmZXIgPSBkZWZhdWx0RnJhbWVidWZmZXIgPT09IHVuZGVmaW5lZDtcblxuXHRcdH07XG5cblx0XHRjb25zdCBfc2NyYXRjaEZyYW1lQnVmZmVyID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgYWN0aXZlQ3ViZUZhY2UgPSAwLCBhY3RpdmVNaXBtYXBMZXZlbCA9IDAgKSB7XG5cblx0XHRcdF9jdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuXHRcdFx0X2N1cnJlbnRBY3RpdmVDdWJlRmFjZSA9IGFjdGl2ZUN1YmVGYWNlO1xuXHRcdFx0X2N1cnJlbnRBY3RpdmVNaXBtYXBMZXZlbCA9IGFjdGl2ZU1pcG1hcExldmVsO1xuXG5cdFx0XHRsZXQgdXNlRGVmYXVsdEZyYW1lYnVmZmVyID0gdHJ1ZTtcblx0XHRcdGxldCBmcmFtZWJ1ZmZlciA9IG51bGw7XG5cdFx0XHRsZXQgaXNDdWJlID0gZmFsc2U7XG5cdFx0XHRsZXQgaXNSZW5kZXJUYXJnZXQzRCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0XHRjb25zdCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3VzZURlZmF1bHRGcmFtZWJ1ZmZlciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBtYWtlIHN1cmUgdG8gcmViaW5kIHRoZSBmcmFtZWJ1ZmZlci5cblx0XHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXHRcdFx0XHRcdHVzZURlZmF1bHRGcmFtZWJ1ZmZlciA9IGZhbHNlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlcy5zZXR1cFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX2hhc0V4dGVybmFsVGV4dHVyZXMgKSB7XG5cblx0XHRcdFx0XHQvLyBDb2xvciBhbmQgZGVwdGggdGV4dHVyZSBtdXN0IGJlIHJlYm91bmQgaW4gb3JkZXIgZm9yIHRoZSBzd2FwY2hhaW4gdG8gdXBkYXRlLlxuXHRcdFx0XHRcdHRleHR1cmVzLnJlYmluZFRleHR1cmVzKCByZW5kZXJUYXJnZXQsIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlLCBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICkge1xuXG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgdGhlIGRlcHRoIHRleHR1cmUgaXMgYWxyZWFkeSBib3VuZCB0byB0aGUgZnJhbWUgYnVmZmVyIGFuZCB0aGF0IGl0J3MgYmVlbiBpbml0aWFsaXplZFxuXHRcdFx0XHRcdGNvbnN0IGRlcHRoVGV4dHVyZSA9IHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmU7XG5cdFx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fYm91bmREZXB0aFRleHR1cmUgIT09IGRlcHRoVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gY2hlY2sgaWYgdGhlIGRlcHRoIHRleHR1cmUgaXMgY29tcGF0aWJsZVxuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRkZXB0aFRleHR1cmUgIT09IG51bGwgJiZcblx0XHRcdFx0XHRcdFx0cHJvcGVydGllcy5oYXMoIGRlcHRoVGV4dHVyZSApICYmXG5cdFx0XHRcdFx0XHRcdCggcmVuZGVyVGFyZ2V0LndpZHRoICE9PSBkZXB0aFRleHR1cmUuaW1hZ2Uud2lkdGggfHwgcmVuZGVyVGFyZ2V0LmhlaWdodCAhPT0gZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodCApXG5cdFx0XHRcdFx0XHQpIHtcblxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdXZWJHTFJlbmRlclRhcmdldDogQXR0YWNoZWQgRGVwdGhUZXh0dXJlIGlzIGluaXRpYWxpemVkIHRvIHRoZSBpbmNvcnJlY3Qgc2l6ZS4nICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gU3dhcCB0aGUgZGVwdGggYnVmZmVyIHRvIHRoZSBjdXJyZW50bHkgYXR0YWNoZWQgb25lXG5cdFx0XHRcdFx0XHR0ZXh0dXJlcy5zZXR1cERlcHRoUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xuXG5cdFx0XHRcdGlmICggdGV4dHVyZS5pc0RhdGEzRFRleHR1cmUgfHwgdGV4dHVyZS5pc0RhdGFBcnJheVRleHR1cmUgfHwgdGV4dHVyZS5pc0NvbXByZXNzZWRBcnJheVRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRpc1JlbmRlclRhcmdldDNEID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgX193ZWJnbEZyYW1lYnVmZmVyID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtcblxuXHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggX193ZWJnbEZyYW1lYnVmZmVyWyBhY3RpdmVDdWJlRmFjZSBdICkgKSB7XG5cblx0XHRcdFx0XHRcdGZyYW1lYnVmZmVyID0gX193ZWJnbEZyYW1lYnVmZmVyWyBhY3RpdmVDdWJlRmFjZSBdWyBhY3RpdmVNaXBtYXBMZXZlbCBdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0ZnJhbWVidWZmZXIgPSBfX3dlYmdsRnJhbWVidWZmZXJbIGFjdGl2ZUN1YmVGYWNlIF07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpc0N1YmUgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggcmVuZGVyVGFyZ2V0LnNhbXBsZXMgPiAwICkgJiYgdGV4dHVyZXMudXNlTXVsdGlzYW1wbGVkUlRUKCByZW5kZXJUYXJnZXQgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRmcmFtZWJ1ZmZlciA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXI7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggX193ZWJnbEZyYW1lYnVmZmVyICkgKSB7XG5cblx0XHRcdFx0XHRcdGZyYW1lYnVmZmVyID0gX193ZWJnbEZyYW1lYnVmZmVyWyBhY3RpdmVNaXBtYXBMZXZlbCBdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0ZnJhbWVidWZmZXIgPSBfX3dlYmdsRnJhbWVidWZmZXI7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9jdXJyZW50Vmlld3BvcnQuY29weSggcmVuZGVyVGFyZ2V0LnZpZXdwb3J0ICk7XG5cdFx0XHRcdF9jdXJyZW50U2Npc3Nvci5jb3B5KCByZW5kZXJUYXJnZXQuc2Npc3NvciApO1xuXHRcdFx0XHRfY3VycmVudFNjaXNzb3JUZXN0ID0gcmVuZGVyVGFyZ2V0LnNjaXNzb3JUZXN0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdF9jdXJyZW50Vmlld3BvcnQuY29weSggX3ZpZXdwb3J0ICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICkuZmxvb3IoKTtcblx0XHRcdFx0X2N1cnJlbnRTY2lzc29yLmNvcHkoIF9zY2lzc29yICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICkuZmxvb3IoKTtcblx0XHRcdFx0X2N1cnJlbnRTY2lzc29yVGVzdCA9IF9zY2lzc29yVGVzdDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBVc2UgYSBzY3JhdGNoIGZyYW1lIGJ1ZmZlciBpZiByZW5kZXJpbmcgdG8gYSBtaXAgbGV2ZWwgdG8gYXZvaWQgZGVwdGggYnVmZmVyc1xuXHRcdFx0Ly8gYmVpbmcgYm91bmQgdGhhdCBhcmUgZGlmZmVyZW50IHNpemVzLlxuXHRcdFx0aWYgKCBhY3RpdmVNaXBtYXBMZXZlbCAhPT0gMCApIHtcblxuXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IF9zY3JhdGNoRnJhbWVCdWZmZXI7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZnJhbWVidWZmZXJCb3VuZCA9IHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuXG5cdFx0XHRpZiAoIGZyYW1lYnVmZmVyQm91bmQgJiYgdXNlRGVmYXVsdEZyYW1lYnVmZmVyICkge1xuXG5cdFx0XHRcdHN0YXRlLmRyYXdCdWZmZXJzKCByZW5kZXJUYXJnZXQsIGZyYW1lYnVmZmVyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0c3RhdGUudmlld3BvcnQoIF9jdXJyZW50Vmlld3BvcnQgKTtcblx0XHRcdHN0YXRlLnNjaXNzb3IoIF9jdXJyZW50U2Npc3NvciApO1xuXHRcdFx0c3RhdGUuc2V0U2Npc3NvclRlc3QoIF9jdXJyZW50U2Npc3NvclRlc3QgKTtcblxuXHRcdFx0aWYgKCBpc0N1YmUgKSB7XG5cblx0XHRcdFx0Y29uc3QgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcblx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGFjdGl2ZUN1YmVGYWNlLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgYWN0aXZlTWlwbWFwTGV2ZWwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggaXNSZW5kZXJUYXJnZXQzRCApIHtcblxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xuXHRcdFx0XHRjb25zdCBsYXllciA9IGFjdGl2ZUN1YmVGYWNlO1xuXHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlTGF5ZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgYWN0aXZlTWlwbWFwTGV2ZWwsIGxheWVyICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHJlbmRlclRhcmdldCAhPT0gbnVsbCAmJiBhY3RpdmVNaXBtYXBMZXZlbCAhPT0gMCApIHtcblxuXHRcdFx0XHQvLyBPbmx5IGJpbmQgdGhlIGZyYW1lIGJ1ZmZlciBpZiB3ZSBhcmUgdXNpbmcgYSBzY3JhdGNoIGZyYW1lIGJ1ZmZlciB0byByZW5kZXIgdG8gYSBtaXBtYXAuXG5cdFx0XHRcdC8vIElmIHdlIHJlYmluZCB0aGUgdGV4dHVyZSB3aGVuIHVzaW5nIGEgbXVsdGkgc2FtcGxlIGJ1ZmZlciB0aGVuIGFuIGVycm9yIGFib3V0IGluY29uc2lzdGVudCBzYW1wbGVzIHdpbGwgYmUgdGhyb3duLlxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xuXHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIGFjdGl2ZU1pcG1hcExldmVsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLSAxOyAvLyByZXNldCBjdXJyZW50IG1hdGVyaWFsIHRvIGVuc3VyZSBjb3JyZWN0IHVuaWZvcm0gYmluZGluZ3NcblxuXHRcdH07XG5cblx0XHR0aGlzLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHMgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgYnVmZmVyLCBhY3RpdmVDdWJlRmFjZUluZGV4ICkge1xuXG5cdFx0XHRpZiAoICEgKCByZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXQgKSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LicgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxldCBmcmFtZWJ1ZmZlciA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXI7XG5cblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ICYmIGFjdGl2ZUN1YmVGYWNlSW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyWyBhY3RpdmVDdWJlRmFjZUluZGV4IF07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBmcmFtZWJ1ZmZlciApIHtcblxuXHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xuXHRcdFx0XHRcdGNvbnN0IHRleHR1cmVGb3JtYXQgPSB0ZXh0dXJlLmZvcm1hdDtcblx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlVHlwZSA9IHRleHR1cmUudHlwZTtcblxuXHRcdFx0XHRcdGlmICggISBjYXBhYmlsaXRpZXMudGV4dHVyZUZvcm1hdFJlYWRhYmxlKCB0ZXh0dXJlRm9ybWF0ICkgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gUkdCQSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIGZvcm1hdC4nICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoICEgY2FwYWJpbGl0aWVzLnRleHR1cmVUeXBlUmVhZGFibGUoIHRleHR1cmVUeXBlICkgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gVW5zaWduZWRCeXRlVHlwZSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIHR5cGUuJyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gdGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnQgZW5zdXJlcyB2YWxpZCByZWFkIHJlcXVlc3RzIChubyBvdXQtb2YtYm91bmRzIHBpeGVscywgc2VlICM4NjA0KVxuXG5cdFx0XHRcdFx0aWYgKCAoIHggPj0gMCAmJiB4IDw9ICggcmVuZGVyVGFyZ2V0LndpZHRoIC0gd2lkdGggKSApICYmICggeSA+PSAwICYmIHkgPD0gKCByZW5kZXJUYXJnZXQuaGVpZ2h0IC0gaGVpZ2h0ICkgKSApIHtcblxuXHRcdFx0XHRcdFx0X2dsLnJlYWRQaXhlbHMoIHgsIHksIHdpZHRoLCBoZWlnaHQsIHV0aWxzLmNvbnZlcnQoIHRleHR1cmVGb3JtYXQgKSwgdXRpbHMuY29udmVydCggdGV4dHVyZVR5cGUgKSwgYnVmZmVyICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBmaW5hbGx5IHtcblxuXHRcdFx0XHRcdC8vIHJlc3RvcmUgZnJhbWVidWZmZXIgb2YgY3VycmVudCByZW5kZXIgdGFyZ2V0IGlmIG5lY2Vzc2FyeVxuXG5cdFx0XHRcdFx0Y29uc3QgZnJhbWVidWZmZXIgPSAoIF9jdXJyZW50UmVuZGVyVGFyZ2V0ICE9PSBudWxsICkgPyBwcm9wZXJ0aWVzLmdldCggX2N1cnJlbnRSZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXIgOiBudWxsO1xuXHRcdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMucmVhZFJlbmRlclRhcmdldFBpeGVsc0FzeW5jID0gYXN5bmMgZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGJ1ZmZlciwgYWN0aXZlQ3ViZUZhY2VJbmRleCApIHtcblxuXHRcdFx0aWYgKCAhICggcmVuZGVyVGFyZ2V0ICYmIHJlbmRlclRhcmdldC5pc1dlYkdMUmVuZGVyVGFyZ2V0ICkgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgZnJhbWVidWZmZXIgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyO1xuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQgJiYgYWN0aXZlQ3ViZUZhY2VJbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGZyYW1lYnVmZmVyID0gZnJhbWVidWZmZXJbIGFjdGl2ZUN1YmVGYWNlSW5kZXggXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGZyYW1lYnVmZmVyICkge1xuXG5cdFx0XHRcdGNvbnN0IHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblx0XHRcdFx0Y29uc3QgdGV4dHVyZUZvcm1hdCA9IHRleHR1cmUuZm9ybWF0O1xuXHRcdFx0XHRjb25zdCB0ZXh0dXJlVHlwZSA9IHRleHR1cmUudHlwZTtcblxuXHRcdFx0XHRpZiAoICEgY2FwYWJpbGl0aWVzLnRleHR1cmVGb3JtYXRSZWFkYWJsZSggdGV4dHVyZUZvcm1hdCApICkge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzQXN5bmM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gUkdCQSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIGZvcm1hdC4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggISBjYXBhYmlsaXRpZXMudGV4dHVyZVR5cGVSZWFkYWJsZSggdGV4dHVyZVR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsc0FzeW5jOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFVuc2lnbmVkQnl0ZVR5cGUgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCB0eXBlLicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnQgZW5zdXJlcyB2YWxpZCByZWFkIHJlcXVlc3RzIChubyBvdXQtb2YtYm91bmRzIHBpeGVscywgc2VlICM4NjA0KVxuXHRcdFx0XHRpZiAoICggeCA+PSAwICYmIHggPD0gKCByZW5kZXJUYXJnZXQud2lkdGggLSB3aWR0aCApICkgJiYgKCB5ID49IDAgJiYgeSA8PSAoIHJlbmRlclRhcmdldC5oZWlnaHQgLSBoZWlnaHQgKSApICkge1xuXG5cdFx0XHRcdFx0Ly8gc2V0IHRoZSBhY3RpdmUgZnJhbWUgYnVmZmVyIHRvIHRoZSBvbmUgd2Ugd2FudCB0byByZWFkXG5cdFx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XG5cblx0XHRcdFx0XHRjb25zdCBnbEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLlBJWEVMX1BBQ0tfQlVGRkVSLCBnbEJ1ZmZlciApO1xuXHRcdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuUElYRUxfUEFDS19CVUZGRVIsIGJ1ZmZlci5ieXRlTGVuZ3RoLCBfZ2wuU1RSRUFNX1JFQUQgKTtcblx0XHRcdFx0XHRfZ2wucmVhZFBpeGVscyggeCwgeSwgd2lkdGgsIGhlaWdodCwgdXRpbHMuY29udmVydCggdGV4dHVyZUZvcm1hdCApLCB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlVHlwZSApLCAwICk7XG5cblx0XHRcdFx0XHQvLyByZXNldCB0aGUgZnJhbWUgYnVmZmVyIHRvIHRoZSBjdXJyZW50bHkgc2V0IGJ1ZmZlciBiZWZvcmUgd2FpdGluZ1xuXHRcdFx0XHRcdGNvbnN0IGN1cnJGcmFtZWJ1ZmZlciA9IF9jdXJyZW50UmVuZGVyVGFyZ2V0ICE9PSBudWxsID8gcHJvcGVydGllcy5nZXQoIF9jdXJyZW50UmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyIDogbnVsbDtcblx0XHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgY3VyckZyYW1lYnVmZmVyICk7XG5cblx0XHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgY29tbWFuZHMgaGF2ZSBmaW5pc2hlZCBldmVyeSA4IG1zXG5cdFx0XHRcdFx0Y29uc3Qgc3luYyA9IF9nbC5mZW5jZVN5bmMoIF9nbC5TWU5DX0dQVV9DT01NQU5EU19DT01QTEVURSwgMCApO1xuXG5cdFx0XHRcdFx0X2dsLmZsdXNoKCk7XG5cblx0XHRcdFx0XHRhd2FpdCBwcm9iZUFzeW5jKCBfZ2wsIHN5bmMsIDQgKTtcblxuXHRcdFx0XHRcdC8vIHJlYWQgdGhlIGRhdGEgYW5kIGRlbGV0ZSB0aGUgYnVmZmVyXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5QSVhFTF9QQUNLX0JVRkZFUiwgZ2xCdWZmZXIgKTtcblx0XHRcdFx0XHRfZ2wuZ2V0QnVmZmVyU3ViRGF0YSggX2dsLlBJWEVMX1BBQ0tfQlVGRkVSLCAwLCBidWZmZXIgKTtcblx0XHRcdFx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnbEJ1ZmZlciApO1xuXHRcdFx0XHRcdF9nbC5kZWxldGVTeW5jKCBzeW5jICk7XG5cblx0XHRcdFx0XHRyZXR1cm4gYnVmZmVyO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHNBc3luYzogcmVxdWVzdGVkIHJlYWQgYm91bmRzIGFyZSBvdXQgb2YgcmFuZ2UuJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMuY29weUZyYW1lYnVmZmVyVG9UZXh0dXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBwb3NpdGlvbiA9IG51bGwsIGxldmVsID0gMCApIHtcblxuXHRcdFx0Ly8gc3VwcG9ydCBwcmV2aW91cyBzaWduYXR1cmUgd2l0aCBwb3NpdGlvbiBmaXJzdFxuXHRcdFx0aWYgKCB0ZXh0dXJlLmlzVGV4dHVyZSAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHQvLyBAZGVwcmVjYXRlZCwgcjE2NVxuXHRcdFx0XHR3YXJuT25jZSggJ1dlYkdMUmVuZGVyZXI6IGNvcHlGcmFtZWJ1ZmZlclRvVGV4dHVyZSBmdW5jdGlvbiBzaWduYXR1cmUgaGFzIGNoYW5nZWQuJyApO1xuXG5cdFx0XHRcdHBvc2l0aW9uID0gYXJndW1lbnRzWyAwIF0gfHwgbnVsbDtcblx0XHRcdFx0dGV4dHVyZSA9IGFyZ3VtZW50c1sgMSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGxldmVsU2NhbGUgPSBNYXRoLnBvdyggMiwgLSBsZXZlbCApO1xuXHRcdFx0Y29uc3Qgd2lkdGggPSBNYXRoLmZsb29yKCB0ZXh0dXJlLmltYWdlLndpZHRoICogbGV2ZWxTY2FsZSApO1xuXHRcdFx0Y29uc3QgaGVpZ2h0ID0gTWF0aC5mbG9vciggdGV4dHVyZS5pbWFnZS5oZWlnaHQgKiBsZXZlbFNjYWxlICk7XG5cblx0XHRcdGNvbnN0IHggPSBwb3NpdGlvbiAhPT0gbnVsbCA/IHBvc2l0aW9uLnggOiAwO1xuXHRcdFx0Y29uc3QgeSA9IHBvc2l0aW9uICE9PSBudWxsID8gcG9zaXRpb24ueSA6IDA7XG5cblx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUyRCggdGV4dHVyZSwgMCApO1xuXG5cdFx0XHRfZ2wuY29weVRleFN1YkltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBsZXZlbCwgMCwgMCwgeCwgeSwgd2lkdGgsIGhlaWdodCApO1xuXG5cdFx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG5cblx0XHR9O1xuXG5cdFx0Y29uc3QgX3NyY0ZyYW1lYnVmZmVyID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cdFx0Y29uc3QgX2RzdEZyYW1lYnVmZmVyID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cdFx0dGhpcy5jb3B5VGV4dHVyZVRvVGV4dHVyZSA9IGZ1bmN0aW9uICggc3JjVGV4dHVyZSwgZHN0VGV4dHVyZSwgc3JjUmVnaW9uID0gbnVsbCwgZHN0UG9zaXRpb24gPSBudWxsLCBzcmNMZXZlbCA9IDAsIGRzdExldmVsID0gbnVsbCApIHtcblxuXHRcdFx0Ly8gc3VwcG9ydCBwcmV2aW91cyBzaWduYXR1cmUgd2l0aCBkc3RQb3NpdGlvbiBmaXJzdFxuXHRcdFx0aWYgKCBzcmNUZXh0dXJlLmlzVGV4dHVyZSAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHQvLyBAZGVwcmVjYXRlZCwgcjE2NVxuXHRcdFx0XHR3YXJuT25jZSggJ1dlYkdMUmVuZGVyZXI6IGNvcHlUZXh0dXJlVG9UZXh0dXJlIGZ1bmN0aW9uIHNpZ25hdHVyZSBoYXMgY2hhbmdlZC4nICk7XG5cblx0XHRcdFx0ZHN0UG9zaXRpb24gPSBhcmd1bWVudHNbIDAgXSB8fCBudWxsO1xuXHRcdFx0XHRzcmNUZXh0dXJlID0gYXJndW1lbnRzWyAxIF07XG5cdFx0XHRcdGRzdFRleHR1cmUgPSBhcmd1bWVudHNbIDIgXTtcblx0XHRcdFx0ZHN0TGV2ZWwgPSBhcmd1bWVudHNbIDMgXSB8fCAwO1xuXHRcdFx0XHRzcmNSZWdpb24gPSBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHN1cHBvcnQgdGhlIHByZXZpb3VzIHNpZ25hdHVyZSB3aXRoIGp1c3QgYSBzaW5nbGUgZHN0IG1pcG1hcCBsZXZlbFxuXHRcdFx0aWYgKCBkc3RMZXZlbCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRpZiAoIHNyY0xldmVsICE9PSAwICkge1xuXG5cdFx0XHRcdFx0Ly8gQGRlcHJlY2F0ZWQsIHIxNzFcblx0XHRcdFx0XHR3YXJuT25jZSggJ1dlYkdMUmVuZGVyZXI6IGNvcHlUZXh0dXJlVG9UZXh0dXJlIGZ1bmN0aW9uIHNpZ25hdHVyZSBoYXMgY2hhbmdlZCB0byBzdXBwb3J0IHNyYyBhbmQgZHN0IG1pcG1hcCBsZXZlbHMuJyApO1xuXHRcdFx0XHRcdGRzdExldmVsID0gc3JjTGV2ZWw7XG5cdFx0XHRcdFx0c3JjTGV2ZWwgPSAwO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRkc3RMZXZlbCA9IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdhdGhlciB0aGUgbmVjZXNzYXJ5IGRpbWVuc2lvbnMgdG8gY29weVxuXHRcdFx0bGV0IHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBtaW5YLCBtaW5ZLCBtaW5aO1xuXHRcdFx0bGV0IGRzdFgsIGRzdFksIGRzdFo7XG5cdFx0XHRjb25zdCBpbWFnZSA9IHNyY1RleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSA/IHNyY1RleHR1cmUubWlwbWFwc1sgZHN0TGV2ZWwgXSA6IHNyY1RleHR1cmUuaW1hZ2U7XG5cdFx0XHRpZiAoIHNyY1JlZ2lvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR3aWR0aCA9IHNyY1JlZ2lvbi5tYXgueCAtIHNyY1JlZ2lvbi5taW4ueDtcblx0XHRcdFx0aGVpZ2h0ID0gc3JjUmVnaW9uLm1heC55IC0gc3JjUmVnaW9uLm1pbi55O1xuXHRcdFx0XHRkZXB0aCA9IHNyY1JlZ2lvbi5pc0JveDMgPyBzcmNSZWdpb24ubWF4LnogLSBzcmNSZWdpb24ubWluLnogOiAxO1xuXHRcdFx0XHRtaW5YID0gc3JjUmVnaW9uLm1pbi54O1xuXHRcdFx0XHRtaW5ZID0gc3JjUmVnaW9uLm1pbi55O1xuXHRcdFx0XHRtaW5aID0gc3JjUmVnaW9uLmlzQm94MyA/IHNyY1JlZ2lvbi5taW4ueiA6IDA7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgbGV2ZWxTY2FsZSA9IE1hdGgucG93KCAyLCAtIHNyY0xldmVsICk7XG5cdFx0XHRcdHdpZHRoID0gTWF0aC5mbG9vciggaW1hZ2Uud2lkdGggKiBsZXZlbFNjYWxlICk7XG5cdFx0XHRcdGhlaWdodCA9IE1hdGguZmxvb3IoIGltYWdlLmhlaWdodCAqIGxldmVsU2NhbGUgKTtcblx0XHRcdFx0aWYgKCBzcmNUZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdGRlcHRoID0gaW1hZ2UuZGVwdGg7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggc3JjVGV4dHVyZS5pc0RhdGEzRFRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRkZXB0aCA9IE1hdGguZmxvb3IoIGltYWdlLmRlcHRoICogbGV2ZWxTY2FsZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRkZXB0aCA9IDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1pblggPSAwO1xuXHRcdFx0XHRtaW5ZID0gMDtcblx0XHRcdFx0bWluWiA9IDA7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBkc3RQb3NpdGlvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRkc3RYID0gZHN0UG9zaXRpb24ueDtcblx0XHRcdFx0ZHN0WSA9IGRzdFBvc2l0aW9uLnk7XG5cdFx0XHRcdGRzdFogPSBkc3RQb3NpdGlvbi56O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGRzdFggPSAwO1xuXHRcdFx0XHRkc3RZID0gMDtcblx0XHRcdFx0ZHN0WiA9IDA7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHVwIHRoZSBkZXN0aW5hdGlvbiB0YXJnZXRcblx0XHRcdGNvbnN0IGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCggZHN0VGV4dHVyZS5mb3JtYXQgKTtcblx0XHRcdGNvbnN0IGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIGRzdFRleHR1cmUudHlwZSApO1xuXHRcdFx0bGV0IGdsVGFyZ2V0O1xuXG5cdFx0XHRpZiAoIGRzdFRleHR1cmUuaXNEYXRhM0RUZXh0dXJlICkge1xuXG5cdFx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUzRCggZHN0VGV4dHVyZSwgMCApO1xuXHRcdFx0XHRnbFRhcmdldCA9IF9nbC5URVhUVVJFXzNEO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBkc3RUZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSB8fCBkc3RUZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSApIHtcblxuXHRcdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkRBcnJheSggZHN0VGV4dHVyZSwgMCApO1xuXHRcdFx0XHRnbFRhcmdldCA9IF9nbC5URVhUVVJFXzJEX0FSUkFZO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUyRCggZHN0VGV4dHVyZSwgMCApO1xuXHRcdFx0XHRnbFRhcmdldCA9IF9nbC5URVhUVVJFXzJEO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIGRzdFRleHR1cmUuZmxpcFkgKTtcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgZHN0VGV4dHVyZS5wcmVtdWx0aXBseUFscGhhICk7XG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfQUxJR05NRU5ULCBkc3RUZXh0dXJlLnVucGFja0FsaWdubWVudCApO1xuXG5cdFx0XHQvLyB1c2VkIGZvciBjb3B5aW5nIGRhdGEgZnJvbSBjcHVcblx0XHRcdGNvbnN0IGN1cnJlbnRVbnBhY2tSb3dMZW4gPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuVU5QQUNLX1JPV19MRU5HVEggKTtcblx0XHRcdGNvbnN0IGN1cnJlbnRVbnBhY2tJbWFnZUhlaWdodCA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5VTlBBQ0tfSU1BR0VfSEVJR0hUICk7XG5cdFx0XHRjb25zdCBjdXJyZW50VW5wYWNrU2tpcFBpeGVscyA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5VTlBBQ0tfU0tJUF9QSVhFTFMgKTtcblx0XHRcdGNvbnN0IGN1cnJlbnRVbnBhY2tTa2lwUm93cyA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5VTlBBQ0tfU0tJUF9ST1dTICk7XG5cdFx0XHRjb25zdCBjdXJyZW50VW5wYWNrU2tpcEltYWdlcyA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5VTlBBQ0tfU0tJUF9JTUFHRVMgKTtcblxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1JPV19MRU5HVEgsIGltYWdlLndpZHRoICk7XG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfSU1BR0VfSEVJR0hULCBpbWFnZS5oZWlnaHQgKTtcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19TS0lQX1BJWEVMUywgbWluWCApO1xuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1NLSVBfUk9XUywgbWluWSApO1xuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1NLSVBfSU1BR0VTLCBtaW5aICk7XG5cblx0XHRcdC8vIHNldCB1cCB0aGUgc3JjIHRleHR1cmVcblx0XHRcdGNvbnN0IGlzU3JjM0QgPSBzcmNUZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSB8fCBzcmNUZXh0dXJlLmlzRGF0YTNEVGV4dHVyZTtcblx0XHRcdGNvbnN0IGlzRHN0M0QgPSBkc3RUZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSB8fCBkc3RUZXh0dXJlLmlzRGF0YTNEVGV4dHVyZTtcblx0XHRcdGlmICggc3JjVGV4dHVyZS5pc0RlcHRoVGV4dHVyZSApIHtcblxuXHRcdFx0XHRjb25zdCBzcmNUZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBzcmNUZXh0dXJlICk7XG5cdFx0XHRcdGNvbnN0IGRzdFRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIGRzdFRleHR1cmUgKTtcblx0XHRcdFx0Y29uc3Qgc3JjUmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBzcmNUZXh0dXJlUHJvcGVydGllcy5fX3JlbmRlclRhcmdldCApO1xuXHRcdFx0XHRjb25zdCBkc3RSZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIGRzdFRleHR1cmVQcm9wZXJ0aWVzLl9fcmVuZGVyVGFyZ2V0ICk7XG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLlJFQURfRlJBTUVCVUZGRVIsIHNyY1JlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyICk7XG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkRSQVdfRlJBTUVCVUZGRVIsIGRzdFJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyICk7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZGVwdGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHQvLyBpZiB0aGUgc291cmNlIG9yIGRlc3RpbmF0aW9uIGFyZSBhIDNkIHRhcmdldCB0aGVuIGEgbGF5ZXIgbmVlZHMgdG8gYmUgYm91bmRcblx0XHRcdFx0XHRpZiAoIGlzU3JjM0QgKSB7XG5cblx0XHRcdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmVMYXllciggX2dsLlJFQURfRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgcHJvcGVydGllcy5nZXQoIHNyY1RleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSwgc3JjTGV2ZWwsIG1pblogKyBpICk7XG5cdFx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlTGF5ZXIoIF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHByb3BlcnRpZXMuZ2V0KCBkc3RUZXh0dXJlICkuX193ZWJnbFRleHR1cmUsIGRzdExldmVsLCBkc3RaICsgaSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X2dsLmJsaXRGcmFtZWJ1ZmZlciggbWluWCwgbWluWSwgd2lkdGgsIGhlaWdodCwgZHN0WCwgZHN0WSwgd2lkdGgsIGhlaWdodCwgX2dsLkRFUFRIX0JVRkZFUl9CSVQsIF9nbC5ORUFSRVNUICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLlJFQURfRlJBTUVCVUZGRVIsIG51bGwgKTtcblx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRFJBV19GUkFNRUJVRkZFUiwgbnVsbCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBzcmNMZXZlbCAhPT0gMCB8fCBzcmNUZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSB8fCBwcm9wZXJ0aWVzLmhhcyggc3JjVGV4dHVyZSApICkge1xuXG5cdFx0XHRcdC8vIGdldCB0aGUgYXBwcm9wcmlhdGUgZnJhbWUgYnVmZmVyc1xuXHRcdFx0XHRjb25zdCBzcmNUZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBzcmNUZXh0dXJlICk7XG5cdFx0XHRcdGNvbnN0IGRzdFRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIGRzdFRleHR1cmUgKTtcblxuXHRcdFx0XHQvLyBiaW5kIHRoZSBmcmFtZSBidWZmZXIgdGFyZ2V0c1xuXHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5SRUFEX0ZSQU1FQlVGRkVSLCBfc3JjRnJhbWVidWZmZXIgKTtcblx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRFJBV19GUkFNRUJVRkZFUiwgX2RzdEZyYW1lYnVmZmVyICk7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZGVwdGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHQvLyBhc3NpZ24gdGhlIGNvcnJlY3QgbGF5ZXJzIGFuZCBtaXAgbWFwcyB0byB0aGUgZnJhbWUgYnVmZmVyc1xuXHRcdFx0XHRcdGlmICggaXNTcmMzRCApIHtcblxuXHRcdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZUxheWVyKCBfZ2wuUkVBRF9GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBzcmNUZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgc3JjTGV2ZWwsIG1pblogKyBpICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5SRUFEX0ZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5URVhUVVJFXzJELCBzcmNUZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgc3JjTGV2ZWwgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggaXNEc3QzRCApIHtcblxuXHRcdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZUxheWVyKCBfZ2wuRFJBV19GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBkc3RUZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgZHN0TGV2ZWwsIGRzdFogKyBpICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5URVhUVVJFXzJELCBkc3RUZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgZHN0TGV2ZWwgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGNvcHkgdGhlIGRhdGEgdXNpbmcgdGhlIGZhc3Rlc3QgZnVuY3Rpb24gdGhhdCBjYW4gYWNoaWV2ZSB0aGUgY29weVxuXHRcdFx0XHRcdGlmICggc3JjTGV2ZWwgIT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdF9nbC5ibGl0RnJhbWVidWZmZXIoIG1pblgsIG1pblksIHdpZHRoLCBoZWlnaHQsIGRzdFgsIGRzdFksIHdpZHRoLCBoZWlnaHQsIF9nbC5DT0xPUl9CVUZGRVJfQklULCBfZ2wuTkVBUkVTVCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggaXNEc3QzRCApIHtcblxuXHRcdFx0XHRcdFx0X2dsLmNvcHlUZXhTdWJJbWFnZTNEKCBnbFRhcmdldCwgZHN0TGV2ZWwsIGRzdFgsIGRzdFksIGRzdFogKyBpLCBtaW5YLCBtaW5ZLCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRfZ2wuY29weVRleFN1YkltYWdlMkQoIGdsVGFyZ2V0LCBkc3RMZXZlbCwgZHN0WCwgZHN0WSwgbWluWCwgbWluWSwgd2lkdGgsIGhlaWdodCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB1bmJpbmQgcmVhZCwgZHJhdyBidWZmZXJzXG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLlJFQURfRlJBTUVCVUZGRVIsIG51bGwgKTtcblx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRFJBV19GUkFNRUJVRkZFUiwgbnVsbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggaXNEc3QzRCApIHtcblxuXHRcdFx0XHRcdC8vIGNvcHkgZGF0YSBpbnRvIHRoZSAzZCB0ZXh0dXJlXG5cdFx0XHRcdFx0aWYgKCBzcmNUZXh0dXJlLmlzRGF0YVRleHR1cmUgfHwgc3JjVGV4dHVyZS5pc0RhdGEzRFRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRcdF9nbC50ZXhTdWJJbWFnZTNEKCBnbFRhcmdldCwgZHN0TGV2ZWwsIGRzdFgsIGRzdFksIGRzdFosIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBkc3RUZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdFx0X2dsLmNvbXByZXNzZWRUZXhTdWJJbWFnZTNEKCBnbFRhcmdldCwgZHN0TGV2ZWwsIGRzdFgsIGRzdFksIGRzdFosIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBnbEZvcm1hdCwgaW1hZ2UuZGF0YSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0X2dsLnRleFN1YkltYWdlM0QoIGdsVGFyZ2V0LCBkc3RMZXZlbCwgZHN0WCwgZHN0WSwgZHN0Wiwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGNvcHkgZGF0YSBpbnRvIHRoZSAyZCB0ZXh0dXJlXG5cdFx0XHRcdFx0aWYgKCBzcmNUZXh0dXJlLmlzRGF0YVRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRcdF9nbC50ZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgZHN0TGV2ZWwsIGRzdFgsIGRzdFksIHdpZHRoLCBoZWlnaHQsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHNyY1RleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdFx0X2dsLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgZHN0TGV2ZWwsIGRzdFgsIGRzdFksIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGdsRm9ybWF0LCBpbWFnZS5kYXRhICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRfZ2wudGV4U3ViSW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGRzdExldmVsLCBkc3RYLCBkc3RZLCB3aWR0aCwgaGVpZ2h0LCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZXNldCB2YWx1ZXNcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19ST1dfTEVOR1RILCBjdXJyZW50VW5wYWNrUm93TGVuICk7XG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfSU1BR0VfSEVJR0hULCBjdXJyZW50VW5wYWNrSW1hZ2VIZWlnaHQgKTtcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19TS0lQX1BJWEVMUywgY3VycmVudFVucGFja1NraXBQaXhlbHMgKTtcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19TS0lQX1JPV1MsIGN1cnJlbnRVbnBhY2tTa2lwUm93cyApO1xuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1NLSVBfSU1BR0VTLCBjdXJyZW50VW5wYWNrU2tpcEltYWdlcyApO1xuXG5cdFx0XHQvLyBHZW5lcmF0ZSBtaXBtYXBzIG9ubHkgd2hlbiBjb3B5aW5nIGxldmVsIDBcblx0XHRcdGlmICggZHN0TGV2ZWwgPT09IDAgJiYgZHN0VGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgKSB7XG5cblx0XHRcdFx0X2dsLmdlbmVyYXRlTWlwbWFwKCBnbFRhcmdldCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHN0YXRlLnVuYmluZFRleHR1cmUoKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmNvcHlUZXh0dXJlVG9UZXh0dXJlM0QgPSBmdW5jdGlvbiAoIHNyY1RleHR1cmUsIGRzdFRleHR1cmUsIHNyY1JlZ2lvbiA9IG51bGwsIGRzdFBvc2l0aW9uID0gbnVsbCwgbGV2ZWwgPSAwICkge1xuXG5cdFx0XHQvLyBzdXBwb3J0IHByZXZpb3VzIHNpZ25hdHVyZSB3aXRoIHNvdXJjZSBib3ggZmlyc3Rcblx0XHRcdGlmICggc3JjVGV4dHVyZS5pc1RleHR1cmUgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0Ly8gQGRlcHJlY2F0ZWQsIHIxNjVcblx0XHRcdFx0d2Fybk9uY2UoICdXZWJHTFJlbmRlcmVyOiBjb3B5VGV4dHVyZVRvVGV4dHVyZTNEIGZ1bmN0aW9uIHNpZ25hdHVyZSBoYXMgY2hhbmdlZC4nICk7XG5cblx0XHRcdFx0c3JjUmVnaW9uID0gYXJndW1lbnRzWyAwIF0gfHwgbnVsbDtcblx0XHRcdFx0ZHN0UG9zaXRpb24gPSBhcmd1bWVudHNbIDEgXSB8fCBudWxsO1xuXHRcdFx0XHRzcmNUZXh0dXJlID0gYXJndW1lbnRzWyAyIF07XG5cdFx0XHRcdGRzdFRleHR1cmUgPSBhcmd1bWVudHNbIDMgXTtcblx0XHRcdFx0bGV2ZWwgPSBhcmd1bWVudHNbIDQgXSB8fCAwO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIEBkZXByZWNhdGVkLCByMTcwXG5cdFx0XHR3YXJuT25jZSggJ1dlYkdMUmVuZGVyZXI6IGNvcHlUZXh0dXJlVG9UZXh0dXJlM0QgZnVuY3Rpb24gaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFwiY29weVRleHR1cmVUb1RleHR1cmVcIiBpbnN0ZWFkLicgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuY29weVRleHR1cmVUb1RleHR1cmUoIHNyY1RleHR1cmUsIGRzdFRleHR1cmUsIHNyY1JlZ2lvbiwgZHN0UG9zaXRpb24sIGxldmVsICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5pbml0UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCB0YXJnZXQgKSB7XG5cblx0XHRcdGlmICggcHJvcGVydGllcy5nZXQoIHRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRleHR1cmVzLnNldHVwUmVuZGVyVGFyZ2V0KCB0YXJnZXQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMuaW5pdFRleHR1cmUgPSBmdW5jdGlvbiAoIHRleHR1cmUgKSB7XG5cblx0XHRcdGlmICggdGV4dHVyZS5pc0N1YmVUZXh0dXJlICkge1xuXG5cdFx0XHRcdHRleHR1cmVzLnNldFRleHR1cmVDdWJlKCB0ZXh0dXJlLCAwICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNEYXRhM0RUZXh0dXJlICkge1xuXG5cdFx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUzRCggdGV4dHVyZSwgMCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSB8fCB0ZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSApIHtcblxuXHRcdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkRBcnJheSggdGV4dHVyZSwgMCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUyRCggdGV4dHVyZSwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHN0YXRlLnVuYmluZFRleHR1cmUoKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnJlc2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdF9jdXJyZW50QWN0aXZlQ3ViZUZhY2UgPSAwO1xuXHRcdFx0X2N1cnJlbnRBY3RpdmVNaXBtYXBMZXZlbCA9IDA7XG5cdFx0XHRfY3VycmVudFJlbmRlclRhcmdldCA9IG51bGw7XG5cblx0XHRcdHN0YXRlLnJlc2V0KCk7XG5cdFx0XHRiaW5kaW5nU3RhdGVzLnJlc2V0KCk7XG5cblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgX19USFJFRV9ERVZUT09MU19fICE9PSAndW5kZWZpbmVkJyApIHtcblxuXHRcdFx0X19USFJFRV9ERVZUT09MU19fLmRpc3BhdGNoRXZlbnQoIG5ldyBDdXN0b21FdmVudCggJ29ic2VydmUnLCB7IGRldGFpbDogdGhpcyB9ICkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Z2V0IGNvb3JkaW5hdGVTeXN0ZW0oKSB7XG5cblx0XHRyZXR1cm4gV2ViR0xDb29yZGluYXRlU3lzdGVtO1xuXG5cdH1cblxuXHRnZXQgb3V0cHV0Q29sb3JTcGFjZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9vdXRwdXRDb2xvclNwYWNlO1xuXG5cdH1cblxuXHRzZXQgb3V0cHV0Q29sb3JTcGFjZSggY29sb3JTcGFjZSApIHtcblxuXHRcdHRoaXMuX291dHB1dENvbG9yU3BhY2UgPSBjb2xvclNwYWNlO1xuXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdldENvbnRleHQoKTtcblx0XHRnbC5kcmF3aW5nQnVmZmVyQ29sb3JzcGFjZSA9IENvbG9yTWFuYWdlbWVudC5fZ2V0RHJhd2luZ0J1ZmZlckNvbG9yU3BhY2UoIGNvbG9yU3BhY2UgKTtcblx0XHRnbC51bnBhY2tDb2xvclNwYWNlID0gQ29sb3JNYW5hZ2VtZW50Ll9nZXRVbnBhY2tDb2xvclNwYWNlKCk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEFDRVNGaWxtaWNUb25lTWFwcGluZywgQWRkRXF1YXRpb24sIEFkZE9wZXJhdGlvbiwgQWRkaXRpdmVCbGVuZGluZywgQWdYVG9uZU1hcHBpbmcsIEFscGhhRm9ybWF0LCBBbHdheXNDb21wYXJlLCBBbHdheXNEZXB0aCwgQXJyYXlDYW1lcmEsIEJhY2tTaWRlLCBCb3hHZW9tZXRyeSwgQnVmZmVyQXR0cmlidXRlLCBCdWZmZXJHZW9tZXRyeSwgQnl0ZVR5cGUsIENpbmVvblRvbmVNYXBwaW5nLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBDb2xvciwgQ29sb3JNYW5hZ2VtZW50LCBDb25zdGFudEFscGhhRmFjdG9yLCBDb25zdGFudENvbG9yRmFjdG9yLCBDdWJlUmVmbGVjdGlvbk1hcHBpbmcsIEN1YmVSZWZyYWN0aW9uTWFwcGluZywgQ3ViZVRleHR1cmUsIEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nLCBDdWxsRmFjZUJhY2ssIEN1bGxGYWNlRnJvbnQsIEN1bGxGYWNlTm9uZSwgQ3VzdG9tQmxlbmRpbmcsIEN1c3RvbVRvbmVNYXBwaW5nLCBEYXRhM0RUZXh0dXJlLCBEYXRhQXJyYXlUZXh0dXJlLCBEZXB0aEZvcm1hdCwgRGVwdGhTdGVuY2lsRm9ybWF0LCBEZXB0aFRleHR1cmUsIERvdWJsZVNpZGUsIERzdEFscGhhRmFjdG9yLCBEc3RDb2xvckZhY3RvciwgRXF1YWxDb21wYXJlLCBFcXVhbERlcHRoLCBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZywgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcsIEV1bGVyLCBFdmVudERpc3BhdGNoZXIsIEZsb2F0VHlwZSwgRnJvbnRTaWRlLCBGcnVzdHVtLCBHTFNMMywgR3JlYXRlckNvbXBhcmUsIEdyZWF0ZXJEZXB0aCwgR3JlYXRlckVxdWFsQ29tcGFyZSwgR3JlYXRlckVxdWFsRGVwdGgsIEdyb3VwLCBIYWxmRmxvYXRUeXBlLCBJbnRUeXBlLCBMYXllcnMsIExlc3NDb21wYXJlLCBMZXNzRGVwdGgsIExlc3NFcXVhbENvbXBhcmUsIExlc3NFcXVhbERlcHRoLCBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcG1hcExpbmVhckZpbHRlciwgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciwgTGluZWFyU1JHQkNvbG9yU3BhY2UsIExpbmVhclRvbmVNYXBwaW5nLCBMaW5lYXJUcmFuc2ZlciwgTHVtaW5hbmNlQWxwaGFGb3JtYXQsIEx1bWluYW5jZUZvcm1hdCwgTWF0cml4MywgTWF0cml4NCwgTWF4RXF1YXRpb24sIE1lc2gsIE1lc2hCYXNpY01hdGVyaWFsLCBNZXNoRGVwdGhNYXRlcmlhbCwgTWVzaERpc3RhbmNlTWF0ZXJpYWwsIE1pbkVxdWF0aW9uLCBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLCBNaXhPcGVyYXRpb24sIE11bHRpcGx5QmxlbmRpbmcsIE11bHRpcGx5T3BlcmF0aW9uLCBOZWFyZXN0RmlsdGVyLCBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyLCBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciwgTmV1dHJhbFRvbmVNYXBwaW5nLCBOZXZlckNvbXBhcmUsIE5ldmVyRGVwdGgsIE5vQmxlbmRpbmcsIE5vQ29sb3JTcGFjZSwgTm9Ub25lTWFwcGluZywgTm9ybWFsQmxlbmRpbmcsIE5vdEVxdWFsQ29tcGFyZSwgTm90RXF1YWxEZXB0aCwgT2JqZWN0U3BhY2VOb3JtYWxNYXAsIE9uZUZhY3RvciwgT25lTWludXNDb25zdGFudEFscGhhRmFjdG9yLCBPbmVNaW51c0NvbnN0YW50Q29sb3JGYWN0b3IsIE9uZU1pbnVzRHN0QWxwaGFGYWN0b3IsIE9uZU1pbnVzRHN0Q29sb3JGYWN0b3IsIE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IsIE9uZU1pbnVzU3JjQ29sb3JGYWN0b3IsIE9ydGhvZ3JhcGhpY0NhbWVyYSwgUENGU2hhZG93TWFwLCBQQ0ZTb2Z0U2hhZG93TWFwLCBQTVJFTUdlbmVyYXRvciwgUGVyc3BlY3RpdmVDYW1lcmEsIFBsYW5lLCBQbGFuZUdlb21ldHJ5LCBSRURfR1JFRU5fUkdUQzJfRm9ybWF0LCBSRURfUkdUQzFfRm9ybWF0LCBSRVZJU0lPTiwgUkdCQURlcHRoUGFja2luZywgUkdCQUZvcm1hdCwgUkdCQUludGVnZXJGb3JtYXQsIFJHQkFfQVNUQ18xMHgxMF9Gb3JtYXQsIFJHQkFfQVNUQ18xMHg1X0Zvcm1hdCwgUkdCQV9BU1RDXzEweDZfRm9ybWF0LCBSR0JBX0FTVENfMTB4OF9Gb3JtYXQsIFJHQkFfQVNUQ18xMngxMF9Gb3JtYXQsIFJHQkFfQVNUQ18xMngxMl9Gb3JtYXQsIFJHQkFfQVNUQ180eDRfRm9ybWF0LCBSR0JBX0FTVENfNXg0X0Zvcm1hdCwgUkdCQV9BU1RDXzV4NV9Gb3JtYXQsIFJHQkFfQVNUQ182eDVfRm9ybWF0LCBSR0JBX0FTVENfNng2X0Zvcm1hdCwgUkdCQV9BU1RDXzh4NV9Gb3JtYXQsIFJHQkFfQVNUQ184eDZfRm9ybWF0LCBSR0JBX0FTVENfOHg4X0Zvcm1hdCwgUkdCQV9CUFRDX0Zvcm1hdCwgUkdCQV9FVEMyX0VBQ19Gb3JtYXQsIFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCwgUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0LCBSR0JBX1MzVENfRFhUMV9Gb3JtYXQsIFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCwgUkdCQV9TM1RDX0RYVDVfRm9ybWF0LCBSR0JGb3JtYXQsIFJHQl9CUFRDX1NJR05FRF9Gb3JtYXQsIFJHQl9CUFRDX1VOU0lHTkVEX0Zvcm1hdCwgUkdCX0VUQzFfRm9ybWF0LCBSR0JfRVRDMl9Gb3JtYXQsIFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0LCBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCwgUkdCX1MzVENfRFhUMV9Gb3JtYXQsIFJHRm9ybWF0LCBSR0ludGVnZXJGb3JtYXQsIFJlZEZvcm1hdCwgUmVkSW50ZWdlckZvcm1hdCwgUmVpbmhhcmRUb25lTWFwcGluZywgUmVwZWF0V3JhcHBpbmcsIFJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uLCBTSUdORURfUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCwgU0lHTkVEX1JFRF9SR1RDMV9Gb3JtYXQsIFNSR0JDb2xvclNwYWNlLCBTUkdCVHJhbnNmZXIsIFNoYWRlckNodW5rLCBTaGFkZXJMaWIsIFNoYWRlck1hdGVyaWFsLCBTaG9ydFR5cGUsIFNyY0FscGhhRmFjdG9yLCBTcmNBbHBoYVNhdHVyYXRlRmFjdG9yLCBTcmNDb2xvckZhY3RvciwgU3VidHJhY3RFcXVhdGlvbiwgU3VidHJhY3RpdmVCbGVuZGluZywgVGFuZ2VudFNwYWNlTm9ybWFsTWFwLCBUZXh0dXJlLCBVaW50MTZCdWZmZXJBdHRyaWJ1dGUsIFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSwgVW5pZm9ybXNMaWIsIFVuaWZvcm1zVXRpbHMsIFVuc2lnbmVkQnl0ZVR5cGUsIFVuc2lnbmVkSW50MjQ4VHlwZSwgVW5zaWduZWRJbnQ1OTk5VHlwZSwgVW5zaWduZWRJbnRUeXBlLCBVbnNpZ25lZFNob3J0NDQ0NFR5cGUsIFVuc2lnbmVkU2hvcnQ1NTUxVHlwZSwgVW5zaWduZWRTaG9ydFR5cGUsIFZTTVNoYWRvd01hcCwgVmVjdG9yMiwgVmVjdG9yMywgVmVjdG9yNCwgV2ViR0xDb29yZGluYXRlU3lzdGVtLCBXZWJHTEN1YmVSZW5kZXJUYXJnZXQsIFdlYkdMUmVuZGVyVGFyZ2V0LCBXZWJHTFJlbmRlcmVyLCBXZWJHTFV0aWxzLCBaZXJvRmFjdG9yLCBjcmVhdGVDYW52YXNFbGVtZW50IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/three@0.172.0/node_modules/three/build/three.module.js\n");

/***/ })

};
;