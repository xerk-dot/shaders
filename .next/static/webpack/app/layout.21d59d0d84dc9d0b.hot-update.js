"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./app/data.ts":
/*!*********************!*\
  !*** ./app/data.ts ***!
  \*********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shaderData: () => (/* binding */ shaderData)\n/* harmony export */ });\n/* harmony import */ var _shaders_dirty_notch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shaders/dirty-notch */ \"(app-pages-browser)/./app/shaders/dirty-notch.ts\");\n\nconst shaderData = [\n    {\n        id: 'fluid-simulation',\n        name: 'Fluid Simulation',\n        icon: '⭡',\n        description: 'WebGL Fluid Simulation shader',\n        sourceUrl: 'https://github.com/PavelDoGreat/WebGL-Fluid-Simulation',\n        code: \"// Add your code here\"\n    },\n    {\n        id: 'fractal-pyramid',\n        name: 'Fractal Pyramid',\n        icon: '⭢',\n        description: 'Fractal Pyramid shader visualization',\n        sourceUrl: 'https://www.shadertoy.com/view/l3cfW4',\n        code: \"// Add your code here\"\n    },\n    {\n        id: 'protean-clouds',\n        name: 'Protean Clouds',\n        icon: '⭣',\n        description: 'Volumetric clouds shader',\n        sourceUrl: 'https://www.shadertoy.com/view/4dfGzs',\n        code: \"// Add your code here\"\n    },\n    {\n        id: 'seascape',\n        name: 'Seascape',\n        icon: '⭠',\n        description: 'Animated seascape shader',\n        sourceUrl: 'https://www.shadertoy.com/view/XslGRr',\n        code: \"// Add your code here\"\n    },\n    {\n        id: 'dirty-notch',\n        name: 'Dirty Notch',\n        icon: '⭣',\n        description: 'A mesmerizing voxel-based wireframe terrain visualization with dynamic lighting and camera movement',\n        sourceUrl: '',\n        code: {\n            fragmentShader: _shaders_dirty_notch__WEBPACK_IMPORTED_MODULE_0__.fragmentShader\n        }\n    }\n];\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9kYXRhLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQ3VEO0FBRWhELE1BQU1DLGFBQWE7SUFDeEI7UUFDRUMsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxXQUFXO1FBQ1hDLE1BQU87SUFDVDtJQUNBO1FBQ0VMLElBQUk7UUFDSkMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxNQUFPO0lBQ1Q7SUFDQTtRQUNFTCxJQUFJO1FBQ0pDLE1BQU07UUFDTkMsTUFBTTtRQUNOQyxhQUFhO1FBQ2JDLFdBQVc7UUFDWEMsTUFBTztJQUNUO0lBQ0E7UUFDRUwsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxXQUFXO1FBQ1hDLE1BQU87SUFDVDtJQUNBO1FBQ0VMLElBQUk7UUFDSkMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxNQUFNO1lBQUNQLGNBQWNBLGtFQUFBQTtRQUFBO0lBQ3ZCO0NBQ0QsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2plcmVteWovRG9jdW1lbnRzL3NvdXJjZS9yZXBvcy9zaGFkZXJzL2FwcC9kYXRhLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZlcnRleFNoYWRlciB9IGZyb20gJy4vc2hhZGVycy9kaXJ0eS1ub3RjaCc7XG5pbXBvcnQgeyBmcmFnbWVudFNoYWRlciB9IGZyb20gJy4vc2hhZGVycy9kaXJ0eS1ub3RjaCc7XG5cbmV4cG9ydCBjb25zdCBzaGFkZXJEYXRhID0gW1xuICB7XG4gICAgaWQ6ICdmbHVpZC1zaW11bGF0aW9uJyxcbiAgICBuYW1lOiAnRmx1aWQgU2ltdWxhdGlvbicsXG4gICAgaWNvbjogJ+KtoScsXG4gICAgZGVzY3JpcHRpb246ICdXZWJHTCBGbHVpZCBTaW11bGF0aW9uIHNoYWRlcicsXG4gICAgc291cmNlVXJsOiAnaHR0cHM6Ly9naXRodWIuY29tL1BhdmVsRG9HcmVhdC9XZWJHTC1GbHVpZC1TaW11bGF0aW9uJyxcbiAgICBjb2RlOiBgLy8gQWRkIHlvdXIgY29kZSBoZXJlYFxuICB9LFxuICB7XG4gICAgaWQ6ICdmcmFjdGFsLXB5cmFtaWQnLFxuICAgIG5hbWU6ICdGcmFjdGFsIFB5cmFtaWQnLFxuICAgIGljb246ICfiraInLFxuICAgIGRlc2NyaXB0aW9uOiAnRnJhY3RhbCBQeXJhbWlkIHNoYWRlciB2aXN1YWxpemF0aW9uJyxcbiAgICBzb3VyY2VVcmw6ICdodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvbDNjZlc0JyxcbiAgICBjb2RlOiBgLy8gQWRkIHlvdXIgY29kZSBoZXJlYFxuICB9LFxuICB7XG4gICAgaWQ6ICdwcm90ZWFuLWNsb3VkcycsXG4gICAgbmFtZTogJ1Byb3RlYW4gQ2xvdWRzJyxcbiAgICBpY29uOiAn4q2jJyxcbiAgICBkZXNjcmlwdGlvbjogJ1ZvbHVtZXRyaWMgY2xvdWRzIHNoYWRlcicsXG4gICAgc291cmNlVXJsOiAnaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3LzRkZkd6cycsXG4gICAgY29kZTogYC8vIEFkZCB5b3VyIGNvZGUgaGVyZWBcbiAgfSxcbiAge1xuICAgIGlkOiAnc2Vhc2NhcGUnLFxuICAgIG5hbWU6ICdTZWFzY2FwZScsXG4gICAgaWNvbjogJ+KtoCcsXG4gICAgZGVzY3JpcHRpb246ICdBbmltYXRlZCBzZWFzY2FwZSBzaGFkZXInLFxuICAgIHNvdXJjZVVybDogJ2h0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy9Yc2xHUnInLFxuICAgIGNvZGU6IGAvLyBBZGQgeW91ciBjb2RlIGhlcmVgXG4gIH0sXG4gIHtcbiAgICBpZDogJ2RpcnR5LW5vdGNoJyxcbiAgICBuYW1lOiAnRGlydHkgTm90Y2gnLFxuICAgIGljb246ICfiraMnLFxuICAgIGRlc2NyaXB0aW9uOiAnQSBtZXNtZXJpemluZyB2b3hlbC1iYXNlZCB3aXJlZnJhbWUgdGVycmFpbiB2aXN1YWxpemF0aW9uIHdpdGggZHluYW1pYyBsaWdodGluZyBhbmQgY2FtZXJhIG1vdmVtZW50JyxcbiAgICBzb3VyY2VVcmw6ICcnLFxuICAgIGNvZGU6IHtmcmFnbWVudFNoYWRlcn1cbiAgfVxuXTsgIl0sIm5hbWVzIjpbImZyYWdtZW50U2hhZGVyIiwic2hhZGVyRGF0YSIsImlkIiwibmFtZSIsImljb24iLCJkZXNjcmlwdGlvbiIsInNvdXJjZVVybCIsImNvZGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/data.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/shaders/dirty-notch.ts":
/*!************************************!*\
  !*** ./app/shaders/dirty-notch.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fragmentShader: () => (/* binding */ fragmentShader),\n/* harmony export */   vertexShader: () => (/* binding */ vertexShader)\n/* harmony export */ });\nconst vertexShader = \"#version 300 es\\n  in vec4 position;  // Input vertex position\\n  void main() {\\n    gl_Position = position;  // Output position in clip space\\n  }\\n\";\nconst fragmentShader = \"#version 300 es\\n  // Required precision qualifier for all float values\\n  precision highp float;\\n\\n  // Input uniforms from JavaScript\\n  uniform vec2 iResolution;  // Screen resolution (width, height)\\n  uniform float iTime;       // Time in seconds since start\\n  uniform vec4 iMouse;       // Mouse position (x, y, click-x, click-y)\\n  uniform sampler2D iChannel0;  // Input texture for noise\\n  out vec4 fragColor;       // Output color\\n\\n  // 3D noise function\\n  // Returns a smoothed random value based on position\\n  float noise(in vec3 x) {\\n    vec3 i = floor(x);      // Integer part\\n    vec3 f = fract(x);      // Fractional part\\n    f = f*f*(3.0-2.0*f);    // Smooth interpolation curve\\n    vec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;  // UV coordinates for texture lookup\\n    vec2 rg = texture(iChannel0, (uv+0.5)/256.0).yx;  // Sample noise texture\\n    return mix(rg.x, rg.y, f.z);  // Interpolate between two noise values\\n  }\\n\\n  float mapTerrain( vec3 p )\\n  {\\n    p *= 0.1; \\n    p.xz *= 0.6;\\n    \\n    float time = 0.5 + 0.15*iTime;\\n    float ft = fract( time );\\n    float it = floor( time );\\n    ft = smoothstep( 0.7, 1.0, ft );\\n    time = it + ft;\\n    float spe = 1.4;\\n    \\n    float f;\\n    f  = 0.5000*noise( p*1.00 + vec3(0.0,1.0,0.0)*spe*time );\\n    f += 0.2500*noise( p*2.02 + vec3(0.0,2.0,0.0)*spe*time );\\n    f += 0.1250*noise( p*4.01 );\\n    return 25.0*f-10.0;\\n  }\\n\\n  vec3 gro = vec3(0.0);\\n\\n  float map(in vec3 c) \\n  {\\n    vec3 p = c + 0.5;\\n    \\n    float f = mapTerrain( p ) + 0.25*p.y;\\n\\n    f = mix( f, 1.0, step( length(gro-p), 5.0 ) );\\n\\n    return step( f, 0.5 );\\n  }\\n\\n  const vec3 lig = normalize( vec3(-0.4,0.3,0.7) );\\n\\n  float raycast( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir )\\n  {\\n    vec3 pos = floor(ro);\\n    vec3 ri = 1.0/rd;\\n    vec3 rs = sign(rd);\\n    vec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\\n    \\n    float res = -1.0;\\n    vec3 mm = vec3(0.0);\\n    for( int i=0; i<128; i++ ) \\n    {\\n      if( map(pos)>0.5 ) { res=1.0; break; }\\n      mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\\n      dis += mm * rs * ri;\\n      pos += mm * rs;\\n    }\\n\\n    vec3 nor = -mm*rs;\\n    vec3 vos = pos;\\n    \\n    // intersect the cube\t\\n    vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\\n    float t = max ( mini.x, max ( mini.y, mini.z ) );\\n    \\n    oDir = mm;\\n    oVos = vos;\\n\\n    return t*res;\\n  }\\n\\n  vec3 path( float t, float ya )\\n  {\\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\\n    p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\\n    \\n    return vec3( p.x, 18.0 + ya*4.0*sin(0.05*t), p.y );\\n  }\\n\\n  mat3 setCamera( in vec3 ro, in vec3 ta, float cr )\\n  {\\n    vec3 cw = normalize(ta-ro);\\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\\n    vec3 cu = normalize( cross(cw,cp) );\\n    vec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, -cw );\\n  }\\n\\n  float maxcomp( in vec4 v )\\n  {\\n    return max( max(v.x,v.y), max(v.z,v.w) );\\n  }\\n\\n  float isEdge( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\\n  {\\n    vec2 st = 1.0 - uv;\\n\\n    // edges\\n    vec4 wb = smoothstep( 0.85, 0.99, vec4(uv.x,\\n                                           st.x,\\n                                           uv.y,\\n                                           st.y) ) * ( 1.0 - va + va*vc );\\n    // corners\\n    vec4 wc = smoothstep( 0.85, 0.99, vec4(uv.x*uv.y,\\n                                           st.x*uv.y,\\n                                           st.x*st.y,\\n                                           uv.x*st.y) ) * ( 1.0 - vb + vd*vb );\\n    return maxcomp( max(wb,wc) );\\n  }\\n\\n  vec3 render( in vec3 ro, in vec3 rd )\\n  {\\n    vec3 col = vec3(0.0);\\n    \\n    // raymarch\t\\n    vec3 vos, dir;\\n    float t = raycast( ro, rd, vos, dir );\\n    if( t>0.0 )\\n    {\\n      vec3 nor = -dir*sign(rd);\\n      vec3 pos = ro + rd*t;\\n      vec3 uvw = pos - vos;\\n      \\n      vec3 v1  = vos + nor + dir.yzx;\\n      vec3 v2  = vos + nor - dir.yzx;\\n      vec3 v3  = vos + nor + dir.zxy;\\n      vec3 v4  = vos + nor - dir.zxy;\\n      vec3 v5  = vos + nor + dir.yzx + dir.zxy;\\n      vec3 v6  = vos + nor - dir.yzx + dir.zxy;\\n      vec3 v7  = vos + nor - dir.yzx - dir.zxy;\\n      vec3 v8  = vos + nor + dir.yzx - dir.zxy;\\n      vec3 v9  = vos + dir.yzx;\\n      vec3 v10 = vos - dir.yzx;\\n      vec3 v11 = vos + dir.zxy;\\n      vec3 v12 = vos - dir.zxy;\\n      vec3 v13 = vos + dir.yzx + dir.zxy; \\n      vec3 v14 = vos - dir.yzx + dir.zxy ;\\n      vec3 v15 = vos - dir.yzx - dir.zxy;\\n      vec3 v16 = vos + dir.yzx - dir.zxy;\\n\\n      vec4 vc = vec4( map(v1),  map(v2),  map(v3),  map(v4)  );\\n      vec4 vd = vec4( map(v5),  map(v6),  map(v7),  map(v8)  );\\n      vec4 va = vec4( map(v9),  map(v10), map(v11), map(v12) );\\n      vec4 vb = vec4( map(v13), map(v14), map(v15), map(v16) );\\n      \\n      vec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\\n      \\n      // wireframe\\n      float www = 1.0 - isEdge( uv, va, vb, vc, vd );\\n      \\n      vec3 wir = smoothstep( 0.4, 0.5, abs(uvw-0.5) );\\n      float vvv = (1.0-wir.x*wir.y)*(1.0-wir.x*wir.z)*(1.0-wir.y*wir.z);\\n\\n      col = vec3(0.5);\\n      col += 0.8*vec3(0.1,0.3,0.4);\\n      col *= 1.0 - 0.75*(1.0-vvv)*www;\\n      \\n      // lighting\\n      float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\\n      float bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\\n      float sky = 0.5 + 0.5*nor.y;\\n      float amb = clamp(0.75 + pos.y/25.0,0.0,1.0);\\n      float occ = 1.0;\\n\\n      // ambient occlusion (https://iquilezles.org/articles/voxellines/)\\n      vec2 st = 1.0 - uv;\\n      // edges\\n      vec4 wa = vec4( uv.x, st.x, uv.y, st.y ) * vc;\\n      // corners\\n      vec4 wb = vec4(uv.x*uv.y,\\n                     st.x*uv.y,\\n                     st.x*st.y,\\n                     uv.x*st.y)*vd*(1.0-vc.xzyw)*(1.0-vc.zywx);\\n      occ = wa.x + wa.y + wa.z + wa.w +\\n            wb.x + wb.y + wb.z + wb.w;\\n           \\n           \\n      occ = 1.0 - occ/8.0;\\n      occ = occ*occ;\\n      occ = occ*occ;\\n      occ *= amb;\\n\\n      // lighting\\n      vec3 lin = vec3(0.0);\\n      lin += 2.5*dif*vec3(1.00,0.90,0.70)*(0.5+0.5*occ);\\n      lin += 0.5*bac*vec3(0.15,0.10,0.10)*occ;\\n      lin += 2.0*sky*vec3(0.40,0.30,0.15)*occ;\\n\\n      // line glow\t\\n      float lineglow = 0.0;\\n      lineglow += smoothstep( 0.4, 1.0,     uv.x )*(1.0-va.x*(1.0-vc.x));\\n      lineglow += smoothstep( 0.4, 1.0, 1.0-uv.x )*(1.0-va.y*(1.0-vc.y));\\n      lineglow += smoothstep( 0.4, 1.0,     uv.y )*(1.0-va.z*(1.0-vc.z));\\n      lineglow += smoothstep( 0.4, 1.0, 1.0-uv.y )*(1.0-va.w*(1.0-vc.w));\\n      lineglow += smoothstep( 0.4, 1.0,      uv.y*      uv.x )*(1.0-vb.x*(1.0-vd.x));\\n      lineglow += smoothstep( 0.4, 1.0,      uv.y* (1.0-uv.x))*(1.0-vb.y*(1.0-vd.y));\\n      lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*(1.0-uv.x))*(1.0-vb.z*(1.0-vd.z));\\n      lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*     uv.x )*(1.0-vb.w*(1.0-vd.w));\\n      \\n      vec3 linCol = 2.0*vec3(5.0,0.6,0.0);\\n      linCol *= (0.5+0.5*occ)*0.5;\\n      lin += lineglow*linCol;\\n      \\n      col = col*lin;\\n      col += 8.0*linCol*vec3(1.0,2.0,3.0)*(1.0-www);//*(0.5+1.0*sha);\\n      col += 0.1*lineglow*linCol;\\n      col *= min(0.1,exp( -0.07*t ));\\n    \\n      // blend to black & white\t\t\\n      vec3 col2 = vec3(1.3)*(0.5+0.5*nor.y)*occ*exp( -0.04*t );;\\n      float mi = cos(-0.7+0.5*iTime);\\n      mi = smoothstep( 0.70, 0.75, mi );\\n      col = mix( col, col2, mi );\\n    }\\n\\n    // gamma\t\\n    col = pow( col, vec3(0.45) );\\n\\n    return col;\\n  }\\n\\n  // Main image processing function\\n  void mainImage(out vec4 fragColor, in vec2 fragCoord) {\\n    // Convert pixel coordinates to normalized device coordinates (-1 to 1)\\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\\n    \\n    // Handle mouse input\\n    vec2 mo = iMouse.xy / iResolution.xy;\\n    if(iMouse.z <= 0.00001) mo = vec2(0.0);  // No mouse input\\n    float time = 2.0*iTime + 50.0*mo.x;\\n    \\n    // Camera setup\\n    float cr = 0.2*cos(0.1*iTime);  // Camera rotation\\n    vec3 ro = path(time+0.0, 1.0);  // Camera position (ray origin)\\n    vec3 ta = path(time+5.0, 1.0) - vec3(0.0,6.0,0.0);  // Target position\\n    gro = ro;  // Store global ray origin\\n\\n    // Setup camera matrix\\n    mat3 cam = setCamera(ro, ta, cr);\\n    \\n    // Apply lens distortion\\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\\n    \\n    // Calculate ray direction\\n    vec3 rd = normalize(cam * vec3(p.xy,-2.5));\\n\\n    // Render the scene\\n    vec3 col = render(ro, rd);\\n    \\n    // Apply vignette effect\\n    vec2 q = fragCoord / iResolution.xy;\\n    col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\\n    \\n    // Output final color\\n    fragColor = vec4(col, 1.0);\\n  }\\n\\n  // Entry point\\n  void main() {\\n    mainImage(fragColor, gl_FragCoord.xy);  // Process the image\\n  }\\n\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zaGFkZXJzL2RpcnR5LW5vdGNoLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU8sTUFBTUEsZUFBZ0Isd0pBSzNCO0FBRUssTUFBTUMsaUJBQWtCLHl0UkFxUjdCIiwic291cmNlcyI6WyIvVXNlcnMvamVyZW15ai9Eb2N1bWVudHMvc291cmNlL3JlcG9zL3NoYWRlcnMvYXBwL3NoYWRlcnMvZGlydHktbm90Y2gudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnRleFNoYWRlciA9IGAjdmVyc2lvbiAzMDAgZXNcbiAgaW4gdmVjNCBwb3NpdGlvbjsgIC8vIElucHV0IHZlcnRleCBwb3NpdGlvblxuICB2b2lkIG1haW4oKSB7XG4gICAgZ2xfUG9zaXRpb24gPSBwb3NpdGlvbjsgIC8vIE91dHB1dCBwb3NpdGlvbiBpbiBjbGlwIHNwYWNlXG4gIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBmcmFnbWVudFNoYWRlciA9IGAjdmVyc2lvbiAzMDAgZXNcbiAgLy8gUmVxdWlyZWQgcHJlY2lzaW9uIHF1YWxpZmllciBmb3IgYWxsIGZsb2F0IHZhbHVlc1xuICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cbiAgLy8gSW5wdXQgdW5pZm9ybXMgZnJvbSBKYXZhU2NyaXB0XG4gIHVuaWZvcm0gdmVjMiBpUmVzb2x1dGlvbjsgIC8vIFNjcmVlbiByZXNvbHV0aW9uICh3aWR0aCwgaGVpZ2h0KVxuICB1bmlmb3JtIGZsb2F0IGlUaW1lOyAgICAgICAvLyBUaW1lIGluIHNlY29uZHMgc2luY2Ugc3RhcnRcbiAgdW5pZm9ybSB2ZWM0IGlNb3VzZTsgICAgICAgLy8gTW91c2UgcG9zaXRpb24gKHgsIHksIGNsaWNrLXgsIGNsaWNrLXkpXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGlDaGFubmVsMDsgIC8vIElucHV0IHRleHR1cmUgZm9yIG5vaXNlXG4gIG91dCB2ZWM0IGZyYWdDb2xvcjsgICAgICAgLy8gT3V0cHV0IGNvbG9yXG5cbiAgLy8gM0Qgbm9pc2UgZnVuY3Rpb25cbiAgLy8gUmV0dXJucyBhIHNtb290aGVkIHJhbmRvbSB2YWx1ZSBiYXNlZCBvbiBwb3NpdGlvblxuICBmbG9hdCBub2lzZShpbiB2ZWMzIHgpIHtcbiAgICB2ZWMzIGkgPSBmbG9vcih4KTsgICAgICAvLyBJbnRlZ2VyIHBhcnRcbiAgICB2ZWMzIGYgPSBmcmFjdCh4KTsgICAgICAvLyBGcmFjdGlvbmFsIHBhcnRcbiAgICBmID0gZipmKigzLjAtMi4wKmYpOyAgICAvLyBTbW9vdGggaW50ZXJwb2xhdGlvbiBjdXJ2ZVxuICAgIHZlYzIgdXYgPSAoaS54eSt2ZWMyKDM3LjAsMTcuMCkqaS56KSArIGYueHk7ICAvLyBVViBjb29yZGluYXRlcyBmb3IgdGV4dHVyZSBsb29rdXBcbiAgICB2ZWMyIHJnID0gdGV4dHVyZShpQ2hhbm5lbDAsICh1diswLjUpLzI1Ni4wKS55eDsgIC8vIFNhbXBsZSBub2lzZSB0ZXh0dXJlXG4gICAgcmV0dXJuIG1peChyZy54LCByZy55LCBmLnopOyAgLy8gSW50ZXJwb2xhdGUgYmV0d2VlbiB0d28gbm9pc2UgdmFsdWVzXG4gIH1cblxuICBmbG9hdCBtYXBUZXJyYWluKCB2ZWMzIHAgKVxuICB7XG4gICAgcCAqPSAwLjE7IFxuICAgIHAueHogKj0gMC42O1xuICAgIFxuICAgIGZsb2F0IHRpbWUgPSAwLjUgKyAwLjE1KmlUaW1lO1xuICAgIGZsb2F0IGZ0ID0gZnJhY3QoIHRpbWUgKTtcbiAgICBmbG9hdCBpdCA9IGZsb29yKCB0aW1lICk7XG4gICAgZnQgPSBzbW9vdGhzdGVwKCAwLjcsIDEuMCwgZnQgKTtcbiAgICB0aW1lID0gaXQgKyBmdDtcbiAgICBmbG9hdCBzcGUgPSAxLjQ7XG4gICAgXG4gICAgZmxvYXQgZjtcbiAgICBmICA9IDAuNTAwMCpub2lzZSggcCoxLjAwICsgdmVjMygwLjAsMS4wLDAuMCkqc3BlKnRpbWUgKTtcbiAgICBmICs9IDAuMjUwMCpub2lzZSggcCoyLjAyICsgdmVjMygwLjAsMi4wLDAuMCkqc3BlKnRpbWUgKTtcbiAgICBmICs9IDAuMTI1MCpub2lzZSggcCo0LjAxICk7XG4gICAgcmV0dXJuIDI1LjAqZi0xMC4wO1xuICB9XG5cbiAgdmVjMyBncm8gPSB2ZWMzKDAuMCk7XG5cbiAgZmxvYXQgbWFwKGluIHZlYzMgYykgXG4gIHtcbiAgICB2ZWMzIHAgPSBjICsgMC41O1xuICAgIFxuICAgIGZsb2F0IGYgPSBtYXBUZXJyYWluKCBwICkgKyAwLjI1KnAueTtcblxuICAgIGYgPSBtaXgoIGYsIDEuMCwgc3RlcCggbGVuZ3RoKGdyby1wKSwgNS4wICkgKTtcblxuICAgIHJldHVybiBzdGVwKCBmLCAwLjUgKTtcbiAgfVxuXG4gIGNvbnN0IHZlYzMgbGlnID0gbm9ybWFsaXplKCB2ZWMzKC0wLjQsMC4zLDAuNykgKTtcblxuICBmbG9hdCByYXljYXN0KCBpbiB2ZWMzIHJvLCBpbiB2ZWMzIHJkLCBvdXQgdmVjMyBvVm9zLCBvdXQgdmVjMyBvRGlyIClcbiAge1xuICAgIHZlYzMgcG9zID0gZmxvb3Iocm8pO1xuICAgIHZlYzMgcmkgPSAxLjAvcmQ7XG4gICAgdmVjMyBycyA9IHNpZ24ocmQpO1xuICAgIHZlYzMgZGlzID0gKHBvcy1ybyArIDAuNSArIHJzKjAuNSkgKiByaTtcbiAgICBcbiAgICBmbG9hdCByZXMgPSAtMS4wO1xuICAgIHZlYzMgbW0gPSB2ZWMzKDAuMCk7XG4gICAgZm9yKCBpbnQgaT0wOyBpPDEyODsgaSsrICkgXG4gICAge1xuICAgICAgaWYoIG1hcChwb3MpPjAuNSApIHsgcmVzPTEuMDsgYnJlYWs7IH1cbiAgICAgIG1tID0gc3RlcChkaXMueHl6LCBkaXMueXp4KSAqIHN0ZXAoZGlzLnh5eiwgZGlzLnp4eSk7XG4gICAgICBkaXMgKz0gbW0gKiBycyAqIHJpO1xuICAgICAgcG9zICs9IG1tICogcnM7XG4gICAgfVxuXG4gICAgdmVjMyBub3IgPSAtbW0qcnM7XG4gICAgdmVjMyB2b3MgPSBwb3M7XG4gICAgXG4gICAgLy8gaW50ZXJzZWN0IHRoZSBjdWJlXHRcbiAgICB2ZWMzIG1pbmkgPSAocG9zLXJvICsgMC41IC0gMC41KnZlYzMocnMpKSpyaTtcbiAgICBmbG9hdCB0ID0gbWF4ICggbWluaS54LCBtYXggKCBtaW5pLnksIG1pbmkueiApICk7XG4gICAgXG4gICAgb0RpciA9IG1tO1xuICAgIG9Wb3MgPSB2b3M7XG5cbiAgICByZXR1cm4gdCpyZXM7XG4gIH1cblxuICB2ZWMzIHBhdGgoIGZsb2F0IHQsIGZsb2F0IHlhIClcbiAge1xuICAgIHZlYzIgcCAgPSAxMDAuMCpzaW4oIDAuMDIqdCp2ZWMyKDEuMCwxLjIpICsgdmVjMigwLjEsMC45KSApO1xuICAgIHAgKz0gIDUwLjAqc2luKCAwLjA0KnQqdmVjMigxLjMsMS4wKSArIHZlYzIoMS4wLDQuNSkgKTtcbiAgICBcbiAgICByZXR1cm4gdmVjMyggcC54LCAxOC4wICsgeWEqNC4wKnNpbigwLjA1KnQpLCBwLnkgKTtcbiAgfVxuXG4gIG1hdDMgc2V0Q2FtZXJhKCBpbiB2ZWMzIHJvLCBpbiB2ZWMzIHRhLCBmbG9hdCBjciApXG4gIHtcbiAgICB2ZWMzIGN3ID0gbm9ybWFsaXplKHRhLXJvKTtcbiAgICB2ZWMzIGNwID0gdmVjMyhzaW4oY3IpLCBjb3MoY3IpLDAuMCk7XG4gICAgdmVjMyBjdSA9IG5vcm1hbGl6ZSggY3Jvc3MoY3csY3ApICk7XG4gICAgdmVjMyBjdiA9IG5vcm1hbGl6ZSggY3Jvc3MoY3UsY3cpICk7XG4gICAgcmV0dXJuIG1hdDMoIGN1LCBjdiwgLWN3ICk7XG4gIH1cblxuICBmbG9hdCBtYXhjb21wKCBpbiB2ZWM0IHYgKVxuICB7XG4gICAgcmV0dXJuIG1heCggbWF4KHYueCx2LnkpLCBtYXgodi56LHYudykgKTtcbiAgfVxuXG4gIGZsb2F0IGlzRWRnZSggaW4gdmVjMiB1diwgdmVjNCB2YSwgdmVjNCB2YiwgdmVjNCB2YywgdmVjNCB2ZCApXG4gIHtcbiAgICB2ZWMyIHN0ID0gMS4wIC0gdXY7XG5cbiAgICAvLyBlZGdlc1xuICAgIHZlYzQgd2IgPSBzbW9vdGhzdGVwKCAwLjg1LCAwLjk5LCB2ZWM0KHV2LngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3QueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1di55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0LnkpICkgKiAoIDEuMCAtIHZhICsgdmEqdmMgKTtcbiAgICAvLyBjb3JuZXJzXG4gICAgdmVjNCB3YyA9IHNtb290aHN0ZXAoIDAuODUsIDAuOTksIHZlYzQodXYueCp1di55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0LngqdXYueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdC54KnN0LnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXYueCpzdC55KSApICogKCAxLjAgLSB2YiArIHZkKnZiICk7XG4gICAgcmV0dXJuIG1heGNvbXAoIG1heCh3Yix3YykgKTtcbiAgfVxuXG4gIHZlYzMgcmVuZGVyKCBpbiB2ZWMzIHJvLCBpbiB2ZWMzIHJkIClcbiAge1xuICAgIHZlYzMgY29sID0gdmVjMygwLjApO1xuICAgIFxuICAgIC8vIHJheW1hcmNoXHRcbiAgICB2ZWMzIHZvcywgZGlyO1xuICAgIGZsb2F0IHQgPSByYXljYXN0KCBybywgcmQsIHZvcywgZGlyICk7XG4gICAgaWYoIHQ+MC4wIClcbiAgICB7XG4gICAgICB2ZWMzIG5vciA9IC1kaXIqc2lnbihyZCk7XG4gICAgICB2ZWMzIHBvcyA9IHJvICsgcmQqdDtcbiAgICAgIHZlYzMgdXZ3ID0gcG9zIC0gdm9zO1xuICAgICAgXG4gICAgICB2ZWMzIHYxICA9IHZvcyArIG5vciArIGRpci55eng7XG4gICAgICB2ZWMzIHYyICA9IHZvcyArIG5vciAtIGRpci55eng7XG4gICAgICB2ZWMzIHYzICA9IHZvcyArIG5vciArIGRpci56eHk7XG4gICAgICB2ZWMzIHY0ICA9IHZvcyArIG5vciAtIGRpci56eHk7XG4gICAgICB2ZWMzIHY1ICA9IHZvcyArIG5vciArIGRpci55enggKyBkaXIuenh5O1xuICAgICAgdmVjMyB2NiAgPSB2b3MgKyBub3IgLSBkaXIueXp4ICsgZGlyLnp4eTtcbiAgICAgIHZlYzMgdjcgID0gdm9zICsgbm9yIC0gZGlyLnl6eCAtIGRpci56eHk7XG4gICAgICB2ZWMzIHY4ICA9IHZvcyArIG5vciArIGRpci55enggLSBkaXIuenh5O1xuICAgICAgdmVjMyB2OSAgPSB2b3MgKyBkaXIueXp4O1xuICAgICAgdmVjMyB2MTAgPSB2b3MgLSBkaXIueXp4O1xuICAgICAgdmVjMyB2MTEgPSB2b3MgKyBkaXIuenh5O1xuICAgICAgdmVjMyB2MTIgPSB2b3MgLSBkaXIuenh5O1xuICAgICAgdmVjMyB2MTMgPSB2b3MgKyBkaXIueXp4ICsgZGlyLnp4eTsgXG4gICAgICB2ZWMzIHYxNCA9IHZvcyAtIGRpci55enggKyBkaXIuenh5IDtcbiAgICAgIHZlYzMgdjE1ID0gdm9zIC0gZGlyLnl6eCAtIGRpci56eHk7XG4gICAgICB2ZWMzIHYxNiA9IHZvcyArIGRpci55enggLSBkaXIuenh5O1xuXG4gICAgICB2ZWM0IHZjID0gdmVjNCggbWFwKHYxKSwgIG1hcCh2MiksICBtYXAodjMpLCAgbWFwKHY0KSAgKTtcbiAgICAgIHZlYzQgdmQgPSB2ZWM0KCBtYXAodjUpLCAgbWFwKHY2KSwgIG1hcCh2NyksICBtYXAodjgpICApO1xuICAgICAgdmVjNCB2YSA9IHZlYzQoIG1hcCh2OSksICBtYXAodjEwKSwgbWFwKHYxMSksIG1hcCh2MTIpICk7XG4gICAgICB2ZWM0IHZiID0gdmVjNCggbWFwKHYxMyksIG1hcCh2MTQpLCBtYXAodjE1KSwgbWFwKHYxNikgKTtcbiAgICAgIFxuICAgICAgdmVjMiB1diA9IHZlYzIoIGRvdChkaXIueXp4LCB1dncpLCBkb3QoZGlyLnp4eSwgdXZ3KSApO1xuICAgICAgXG4gICAgICAvLyB3aXJlZnJhbWVcbiAgICAgIGZsb2F0IHd3dyA9IDEuMCAtIGlzRWRnZSggdXYsIHZhLCB2YiwgdmMsIHZkICk7XG4gICAgICBcbiAgICAgIHZlYzMgd2lyID0gc21vb3Roc3RlcCggMC40LCAwLjUsIGFicyh1dnctMC41KSApO1xuICAgICAgZmxvYXQgdnZ2ID0gKDEuMC13aXIueCp3aXIueSkqKDEuMC13aXIueCp3aXIueikqKDEuMC13aXIueSp3aXIueik7XG5cbiAgICAgIGNvbCA9IHZlYzMoMC41KTtcbiAgICAgIGNvbCArPSAwLjgqdmVjMygwLjEsMC4zLDAuNCk7XG4gICAgICBjb2wgKj0gMS4wIC0gMC43NSooMS4wLXZ2dikqd3d3O1xuICAgICAgXG4gICAgICAvLyBsaWdodGluZ1xuICAgICAgZmxvYXQgZGlmID0gY2xhbXAoIGRvdCggbm9yLCBsaWcgKSwgMC4wLCAxLjAgKTtcbiAgICAgIGZsb2F0IGJhYyA9IGNsYW1wKCBkb3QoIG5vciwgbm9ybWFsaXplKGxpZyp2ZWMzKC0xLjAsMC4wLC0xLjApKSApLCAwLjAsIDEuMCApO1xuICAgICAgZmxvYXQgc2t5ID0gMC41ICsgMC41Km5vci55O1xuICAgICAgZmxvYXQgYW1iID0gY2xhbXAoMC43NSArIHBvcy55LzI1LjAsMC4wLDEuMCk7XG4gICAgICBmbG9hdCBvY2MgPSAxLjA7XG5cbiAgICAgIC8vIGFtYmllbnQgb2NjbHVzaW9uIChodHRwczovL2lxdWlsZXpsZXMub3JnL2FydGljbGVzL3ZveGVsbGluZXMvKVxuICAgICAgdmVjMiBzdCA9IDEuMCAtIHV2O1xuICAgICAgLy8gZWRnZXNcbiAgICAgIHZlYzQgd2EgPSB2ZWM0KCB1di54LCBzdC54LCB1di55LCBzdC55ICkgKiB2YztcbiAgICAgIC8vIGNvcm5lcnNcbiAgICAgIHZlYzQgd2IgPSB2ZWM0KHV2LngqdXYueSxcbiAgICAgICAgICAgICAgICAgICAgIHN0LngqdXYueSxcbiAgICAgICAgICAgICAgICAgICAgIHN0Lngqc3QueSxcbiAgICAgICAgICAgICAgICAgICAgIHV2Lngqc3QueSkqdmQqKDEuMC12Yy54enl3KSooMS4wLXZjLnp5d3gpO1xuICAgICAgb2NjID0gd2EueCArIHdhLnkgKyB3YS56ICsgd2EudyArXG4gICAgICAgICAgICB3Yi54ICsgd2IueSArIHdiLnogKyB3Yi53O1xuICAgICAgICAgICBcbiAgICAgICAgICAgXG4gICAgICBvY2MgPSAxLjAgLSBvY2MvOC4wO1xuICAgICAgb2NjID0gb2NjKm9jYztcbiAgICAgIG9jYyA9IG9jYypvY2M7XG4gICAgICBvY2MgKj0gYW1iO1xuXG4gICAgICAvLyBsaWdodGluZ1xuICAgICAgdmVjMyBsaW4gPSB2ZWMzKDAuMCk7XG4gICAgICBsaW4gKz0gMi41KmRpZip2ZWMzKDEuMDAsMC45MCwwLjcwKSooMC41KzAuNSpvY2MpO1xuICAgICAgbGluICs9IDAuNSpiYWMqdmVjMygwLjE1LDAuMTAsMC4xMCkqb2NjO1xuICAgICAgbGluICs9IDIuMCpza3kqdmVjMygwLjQwLDAuMzAsMC4xNSkqb2NjO1xuXG4gICAgICAvLyBsaW5lIGdsb3dcdFxuICAgICAgZmxvYXQgbGluZWdsb3cgPSAwLjA7XG4gICAgICBsaW5lZ2xvdyArPSBzbW9vdGhzdGVwKCAwLjQsIDEuMCwgICAgIHV2LnggKSooMS4wLXZhLngqKDEuMC12Yy54KSk7XG4gICAgICBsaW5lZ2xvdyArPSBzbW9vdGhzdGVwKCAwLjQsIDEuMCwgMS4wLXV2LnggKSooMS4wLXZhLnkqKDEuMC12Yy55KSk7XG4gICAgICBsaW5lZ2xvdyArPSBzbW9vdGhzdGVwKCAwLjQsIDEuMCwgICAgIHV2LnkgKSooMS4wLXZhLnoqKDEuMC12Yy56KSk7XG4gICAgICBsaW5lZ2xvdyArPSBzbW9vdGhzdGVwKCAwLjQsIDEuMCwgMS4wLXV2LnkgKSooMS4wLXZhLncqKDEuMC12Yy53KSk7XG4gICAgICBsaW5lZ2xvdyArPSBzbW9vdGhzdGVwKCAwLjQsIDEuMCwgICAgICB1di55KiAgICAgIHV2LnggKSooMS4wLXZiLngqKDEuMC12ZC54KSk7XG4gICAgICBsaW5lZ2xvdyArPSBzbW9vdGhzdGVwKCAwLjQsIDEuMCwgICAgICB1di55KiAoMS4wLXV2LngpKSooMS4wLXZiLnkqKDEuMC12ZC55KSk7XG4gICAgICBsaW5lZ2xvdyArPSBzbW9vdGhzdGVwKCAwLjQsIDEuMCwgKDEuMC11di55KSooMS4wLXV2LngpKSooMS4wLXZiLnoqKDEuMC12ZC56KSk7XG4gICAgICBsaW5lZ2xvdyArPSBzbW9vdGhzdGVwKCAwLjQsIDEuMCwgKDEuMC11di55KSogICAgIHV2LnggKSooMS4wLXZiLncqKDEuMC12ZC53KSk7XG4gICAgICBcbiAgICAgIHZlYzMgbGluQ29sID0gMi4wKnZlYzMoNS4wLDAuNiwwLjApO1xuICAgICAgbGluQ29sICo9ICgwLjUrMC41Km9jYykqMC41O1xuICAgICAgbGluICs9IGxpbmVnbG93KmxpbkNvbDtcbiAgICAgIFxuICAgICAgY29sID0gY29sKmxpbjtcbiAgICAgIGNvbCArPSA4LjAqbGluQ29sKnZlYzMoMS4wLDIuMCwzLjApKigxLjAtd3d3KTsvLyooMC41KzEuMCpzaGEpO1xuICAgICAgY29sICs9IDAuMSpsaW5lZ2xvdypsaW5Db2w7XG4gICAgICBjb2wgKj0gbWluKDAuMSxleHAoIC0wLjA3KnQgKSk7XG4gICAgXG4gICAgICAvLyBibGVuZCB0byBibGFjayAmIHdoaXRlXHRcdFxuICAgICAgdmVjMyBjb2wyID0gdmVjMygxLjMpKigwLjUrMC41Km5vci55KSpvY2MqZXhwKCAtMC4wNCp0ICk7O1xuICAgICAgZmxvYXQgbWkgPSBjb3MoLTAuNyswLjUqaVRpbWUpO1xuICAgICAgbWkgPSBzbW9vdGhzdGVwKCAwLjcwLCAwLjc1LCBtaSApO1xuICAgICAgY29sID0gbWl4KCBjb2wsIGNvbDIsIG1pICk7XG4gICAgfVxuXG4gICAgLy8gZ2FtbWFcdFxuICAgIGNvbCA9IHBvdyggY29sLCB2ZWMzKDAuNDUpICk7XG5cbiAgICByZXR1cm4gY29sO1xuICB9XG5cbiAgLy8gTWFpbiBpbWFnZSBwcm9jZXNzaW5nIGZ1bmN0aW9uXG4gIHZvaWQgbWFpbkltYWdlKG91dCB2ZWM0IGZyYWdDb2xvciwgaW4gdmVjMiBmcmFnQ29vcmQpIHtcbiAgICAvLyBDb252ZXJ0IHBpeGVsIGNvb3JkaW5hdGVzIHRvIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGVzICgtMSB0byAxKVxuICAgIHZlYzIgcCA9ICgyLjAqZnJhZ0Nvb3JkLWlSZXNvbHV0aW9uLnh5KS9pUmVzb2x1dGlvbi55O1xuICAgIFxuICAgIC8vIEhhbmRsZSBtb3VzZSBpbnB1dFxuICAgIHZlYzIgbW8gPSBpTW91c2UueHkgLyBpUmVzb2x1dGlvbi54eTtcbiAgICBpZihpTW91c2UueiA8PSAwLjAwMDAxKSBtbyA9IHZlYzIoMC4wKTsgIC8vIE5vIG1vdXNlIGlucHV0XG4gICAgZmxvYXQgdGltZSA9IDIuMCppVGltZSArIDUwLjAqbW8ueDtcbiAgICBcbiAgICAvLyBDYW1lcmEgc2V0dXBcbiAgICBmbG9hdCBjciA9IDAuMipjb3MoMC4xKmlUaW1lKTsgIC8vIENhbWVyYSByb3RhdGlvblxuICAgIHZlYzMgcm8gPSBwYXRoKHRpbWUrMC4wLCAxLjApOyAgLy8gQ2FtZXJhIHBvc2l0aW9uIChyYXkgb3JpZ2luKVxuICAgIHZlYzMgdGEgPSBwYXRoKHRpbWUrNS4wLCAxLjApIC0gdmVjMygwLjAsNi4wLDAuMCk7ICAvLyBUYXJnZXQgcG9zaXRpb25cbiAgICBncm8gPSBybzsgIC8vIFN0b3JlIGdsb2JhbCByYXkgb3JpZ2luXG5cbiAgICAvLyBTZXR1cCBjYW1lcmEgbWF0cml4XG4gICAgbWF0MyBjYW0gPSBzZXRDYW1lcmEocm8sIHRhLCBjcik7XG4gICAgXG4gICAgLy8gQXBwbHkgbGVucyBkaXN0b3J0aW9uXG4gICAgZmxvYXQgcjIgPSBwLngqcC54KjAuMzIgKyBwLnkqcC55O1xuICAgIHAgKj0gKDcuMC1zcXJ0KDM3LjUtMTEuNSpyMikpLyhyMisxLjApO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSByYXkgZGlyZWN0aW9uXG4gICAgdmVjMyByZCA9IG5vcm1hbGl6ZShjYW0gKiB2ZWMzKHAueHksLTIuNSkpO1xuXG4gICAgLy8gUmVuZGVyIHRoZSBzY2VuZVxuICAgIHZlYzMgY29sID0gcmVuZGVyKHJvLCByZCk7XG4gICAgXG4gICAgLy8gQXBwbHkgdmlnbmV0dGUgZWZmZWN0XG4gICAgdmVjMiBxID0gZnJhZ0Nvb3JkIC8gaVJlc29sdXRpb24ueHk7XG4gICAgY29sICo9IDAuNSArIDAuNSpwb3coMTYuMCpxLngqcS55KigxLjAtcS54KSooMS4wLXEueSksIDAuMSk7XG4gICAgXG4gICAgLy8gT3V0cHV0IGZpbmFsIGNvbG9yXG4gICAgZnJhZ0NvbG9yID0gdmVjNChjb2wsIDEuMCk7XG4gIH1cblxuICAvLyBFbnRyeSBwb2ludFxuICB2b2lkIG1haW4oKSB7XG4gICAgbWFpbkltYWdlKGZyYWdDb2xvciwgZ2xfRnJhZ0Nvb3JkLnh5KTsgIC8vIFByb2Nlc3MgdGhlIGltYWdlXG4gIH1cbmA7ICJdLCJuYW1lcyI6WyJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/shaders/dirty-notch.ts\n"));

/***/ })

});