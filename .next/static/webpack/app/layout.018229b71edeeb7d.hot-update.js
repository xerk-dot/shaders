"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./app/data.ts":
/*!*********************!*\
  !*** ./app/data.ts ***!
  \*********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shaderData: () => (/* binding */ shaderData)\n/* harmony export */ });\nconst shaderData = [\n    {\n        id: 'fluid-simulation',\n        name: 'Fluid Simulation',\n        icon: '⭡',\n        description: 'WebGL Fluid Simulation shader',\n        sourceUrl: 'https://github.com/PavelDoGreat/WebGL-Fluid-Simulation',\n        code: \"// Add your code here\"\n    },\n    {\n        id: 'fractal-pyramid',\n        name: 'Fractal Pyramid',\n        icon: '⭢',\n        description: 'Fractal Pyramid shader visualization',\n        sourceUrl: 'https://www.shadertoy.com/view/l3cfW4',\n        code: \"// Add your code here\"\n    },\n    {\n        id: 'protean-clouds',\n        name: 'Protean Clouds',\n        icon: '⭣',\n        description: 'Volumetric clouds shader',\n        sourceUrl: 'https://www.shadertoy.com/view/4dfGzs',\n        code: \"// Add your code here\"\n    },\n    {\n        id: 'seascape',\n        name: 'Seascape',\n        icon: '⭠',\n        description: 'Animated seascape shader',\n        sourceUrl: 'https://www.shadertoy.com/view/XslGRr',\n        code: \"// Add your code here\"\n    },\n    {\n        id: 'dirty-notch',\n        name: 'Dirty Notch',\n        icon: '⭣',\n        description: 'A mesmerizing voxel-based wireframe terrain visualization with dynamic lighting and camera movement',\n        sourceUrl: '',\n        code: \"// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\\n// I am the sole copyright owner of this Work.\\n// You cannot host, display, distribute or share this Work neither\\n// as it is or altered, here on Shadertoy or anywhere else, in any\\n// form including physical and digital. You cannot use this Work in any\\n// commercial or non-commercial product, website or project. You cannot\\n// sell this Work and you cannot mint an NFTs of it or train a neural\\n// network with it without permission. I share this Work for educational\\n// purposes, and you can link to it, through an URL, proper attribution\\n// and unmodified screenshot, as part of your educational material. If\\n// these conditions are too restrictive please contact me and we'll\\n// definitely work it out.\\n\\n// Shading technique explained here:\\n//\\n// https://iquilezles.org/articles/voxellines\\n\\n\\n\\n// consider replacing this by a proper noise function\\nfloat noise( in vec3 x )\\n{\\n    vec3 i = floor(x);\\n    vec3 f = fract(x);\\n\tf = f*f*(3.0-2.0*f);\\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\\n\treturn mix( rg.x, rg.y, f.z );\\n}\\n\\nfloat mapTerrain( vec3 p )\\n{\\n\tp *= 0.1; \\n\tp.xz *= 0.6;\\n\t\\n\tfloat time = 0.5 + 0.15*iTime;\\n\tfloat ft = fract( time );\\n\tfloat it = floor( time );\\n\tft = smoothstep( 0.7, 1.0, ft );\\n\ttime = it + ft;\\n\tfloat spe = 1.4;\\n\t\\n\tfloat f;\\n    f  = 0.5000*noise( p*1.00 + vec3(0.0,1.0,0.0)*spe*time );\\n    f += 0.2500*noise( p*2.02 + vec3(0.0,2.0,0.0)*spe*time );\\n    f += 0.1250*noise( p*4.01 );\\n\treturn 25.0*f-10.0;\\n}\\n\\nvec3 gro = vec3(0.0);\\n\\nfloat map(in vec3 c) \\n{\\n\tvec3 p = c + 0.5;\\n\t\\n\tfloat f = mapTerrain( p ) + 0.25*p.y;\\n\\n    f = mix( f, 1.0, step( length(gro-p), 5.0 ) );\\n\\n\treturn step( f, 0.5 );\\n}\\n\\nconst vec3 lig = normalize( vec3(-0.4,0.3,0.7) );\\n\\nfloat raycast( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir )\\n{\\n\tvec3 pos = floor(ro);\\n\tvec3 ri = 1.0/rd;\\n\tvec3 rs = sign(rd);\\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\\n\t\\n\tfloat res = -1.0;\\n\tvec3 mm = vec3(0.0);\\n\tfor( int i=0; i<128; i++ ) \\n\t{\\n\t\tif( map(pos)>0.5 ) { res=1.0; break; }\\n\t\tmm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\\n\t\tdis += mm * rs * ri;\\n        pos += mm * rs;\\n\t}\\n\\n\tvec3 nor = -mm*rs;\\n\tvec3 vos = pos;\\n\t\\n    // intersect the cube\t\\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\\n\t\\n\toDir = mm;\\n\toVos = vos;\\n\\n\treturn t*res;\\n}\\n\\nvec3 path( float t, float ya )\\n{\\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\\n\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\\n\t\\n\treturn vec3( p.x, 18.0 + ya*4.0*sin(0.05*t), p.y );\\n}\\n\\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\\n{\\n\tvec3 cw = normalize(ta-ro);\\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\\n\tvec3 cu = normalize( cross(cw,cp) );\\n\tvec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, -cw );\\n}\\n\\nfloat maxcomp( in vec4 v )\\n{\\n    return max( max(v.x,v.y), max(v.z,v.w) );\\n}\\n\\nfloat isEdge( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\\n{\\n    vec2 st = 1.0 - uv;\\n\\n    // edges\\n    vec4 wb = smoothstep( 0.85, 0.99, vec4(uv.x,\\n                                           st.x,\\n                                           uv.y,\\n                                           st.y) ) * ( 1.0 - va + va*vc );\\n    // corners\\n    vec4 wc = smoothstep( 0.85, 0.99, vec4(uv.x*uv.y,\\n                                           st.x*uv.y,\\n                                           st.x*st.y,\\n                                           uv.x*st.y) ) * ( 1.0 - vb + vd*vb );\\n    return maxcomp( max(wb,wc) );\\n}\\n\\n\\nvec3 render( in vec3 ro, in vec3 rd )\\n{\\n    vec3 col = vec3(0.0);\\n\t\\n    // raymarch\t\\n\tvec3 vos, dir;\\n\tfloat t = raycast( ro, rd, vos, dir );\\n\tif( t>0.0 )\\n\t{\\n        vec3 nor = -dir*sign(rd);\\n        vec3 pos = ro + rd*t;\\n        vec3 uvw = pos - vos;\\n\t\t\\n\t\tvec3 v1  = vos + nor + dir.yzx;\\n\t    vec3 v2  = vos + nor - dir.yzx;\\n\t    vec3 v3  = vos + nor + dir.zxy;\\n\t    vec3 v4  = vos + nor - dir.zxy;\\n\t\tvec3 v5  = vos + nor + dir.yzx + dir.zxy;\\n        vec3 v6  = vos + nor - dir.yzx + dir.zxy;\\n\t    vec3 v7  = vos + nor - dir.yzx - dir.zxy;\\n\t    vec3 v8  = vos + nor + dir.yzx - dir.zxy;\\n\t    vec3 v9  = vos + dir.yzx;\\n\t    vec3 v10 = vos - dir.yzx;\\n\t    vec3 v11 = vos + dir.zxy;\\n\t    vec3 v12 = vos - dir.zxy;\\n \t    vec3 v13 = vos + dir.yzx + dir.zxy; \\n\t    vec3 v14 = vos - dir.yzx + dir.zxy ;\\n\t    vec3 v15 = vos - dir.yzx - dir.zxy;\\n\t    vec3 v16 = vos + dir.yzx - dir.zxy;\\n\\n\t\tvec4 vc = vec4( map(v1),  map(v2),  map(v3),  map(v4)  );\\n\t    vec4 vd = vec4( map(v5),  map(v6),  map(v7),  map(v8)  );\\n\t    vec4 va = vec4( map(v9),  map(v10), map(v11), map(v12) );\\n\t    vec4 vb = vec4( map(v13), map(v14), map(v15), map(v16) );\\n\t\t\\n\t\tvec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\\n\t\t\t\\n        // wireframe\\n        float www = 1.0 - isEdge( uv, va, vb, vc, vd );\\n        \\n        vec3 wir = smoothstep( 0.4, 0.5, abs(uvw-0.5) );\\n        float vvv = (1.0-wir.x*wir.y)*(1.0-wir.x*wir.z)*(1.0-wir.y*wir.z);\\n\\n        col = vec3(0.5);\\n        col += 0.8*vec3(0.1,0.3,0.4);\\n        col *= 1.0 - 0.75*(1.0-vvv)*www;\\n\t\t\\n        // lighting\\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\\n        float bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\\n        float sky = 0.5 + 0.5*nor.y;\\n        float amb = clamp(0.75 + pos.y/25.0,0.0,1.0);\\n        float occ = 1.0;\\n\t\\n        // ambient occlusion (https://iquilezles.org/articles/voxellines/)\\n        vec2 st = 1.0 - uv;\\n        // edges\\n        vec4 wa = vec4( uv.x, st.x, uv.y, st.y ) * vc;\\n        // corners\\n        vec4 wb = vec4(uv.x*uv.y,\\n                       st.x*uv.y,\\n                       st.x*st.y,\\n                       uv.x*st.y)*vd*(1.0-vc.xzyw)*(1.0-vc.zywx);\\n        occ = wa.x + wa.y + wa.z + wa.w +\\n              wb.x + wb.y + wb.z + wb.w;\\n           \\n           \\n        occ = 1.0 - occ/8.0;\\n        occ = occ*occ;\\n        occ = occ*occ;\\n        occ *= amb;\\n\\n        // lighting\\n        vec3 lin = vec3(0.0);\\n        lin += 2.5*dif*vec3(1.00,0.90,0.70)*(0.5+0.5*occ);\\n        lin += 0.5*bac*vec3(0.15,0.10,0.10)*occ;\\n        lin += 2.0*sky*vec3(0.40,0.30,0.15)*occ;\\n\\n        // line glow\t\\n        float lineglow = 0.0;\\n        lineglow += smoothstep( 0.4, 1.0,     uv.x )*(1.0-va.x*(1.0-vc.x));\\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.x )*(1.0-va.y*(1.0-vc.y));\\n        lineglow += smoothstep( 0.4, 1.0,     uv.y )*(1.0-va.z*(1.0-vc.z));\\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.y )*(1.0-va.w*(1.0-vc.w));\\n        lineglow += smoothstep( 0.4, 1.0,      uv.y*      uv.x )*(1.0-vb.x*(1.0-vd.x));\\n        lineglow += smoothstep( 0.4, 1.0,      uv.y* (1.0-uv.x))*(1.0-vb.y*(1.0-vd.y));\\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*(1.0-uv.x))*(1.0-vb.z*(1.0-vd.z));\\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*     uv.x )*(1.0-vb.w*(1.0-vd.w));\\n\t\t\\n        vec3 linCol = 2.0*vec3(5.0,0.6,0.0);\\n        linCol *= (0.5+0.5*occ)*0.5;\\n        lin += lineglow*linCol;\\n\t\t\\n        col = col*lin;\\n        col += 8.0*linCol*vec3(1.0,2.0,3.0)*(1.0-www);//*(0.5+1.0*sha);\\n        col += 0.1*lineglow*linCol;\\n        col *= min(0.1,exp( -0.07*t ));\\n\t\\n        // blend to black & white\t\t\\n        vec3 col2 = vec3(1.3)*(0.5+0.5*nor.y)*occ*exp( -0.04*t );;\\n        float mi = cos(-0.7+0.5*iTime);\\n        mi = smoothstep( 0.70, 0.75, mi );\\n        col = mix( col, col2, mi );\\n\t}\\n\\n\t// gamma\t\\n\tcol = pow( col, vec3(0.45) );\\n\\n    return col;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\n{\\n    // inputs\t\\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\\n    vec2 mo = iMouse.xy / iResolution.xy;\\n    if( iMouse.z<=0.00001 ) mo=vec2(0.0);\\n\tfloat time = 2.0*iTime + 50.0*mo.x;\\n    \\n    // camera\\n\tfloat cr = 0.2*cos(0.1*iTime);\\n\tvec3 ro = path( time+0.0, 1.0 );\\n\tvec3 ta = path( time+5.0, 1.0 ) - vec3(0.0,6.0,0.0);\\n\tgro = ro;\\n\\n    mat3 cam = setCamera( ro, ta, cr );\\n\t\\n\t// build ray\\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\\n    vec3 rd = normalize( cam * vec3(p.xy,-2.5) );\\n\\n    vec3 col = render( ro, rd );\\n    \\n\t// vignetting\t\\n\tvec2 q = fragCoord / iResolution.xy;\\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\\n\t\\n\tfragColor = vec4( col, 1.0 );\\n}\\n\\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\\n{\\n\tfloat time = 1.0*iTime;\\n\\n    float cr = 0.0;\\n\tvec3 ro = path( time+0.0, 0.0 ) + vec3(0.0,0.7,0.0);\\n\tvec3 ta = path( time+2.5, 0.0 ) + vec3(0.0,0.7,0.0);\\n\\n    mat3 cam = setCamera( ro, ta, cr );\\n\\n    vec3 col = render( ro + cam*fragRayOri, cam*fragRayDir );\\n    \\n    fragColor = vec4( col, 1.0 );\\n}\"\n    }\n];\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9kYXRhLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSxhQUFhO0lBQ3hCO1FBQ0VDLElBQUk7UUFDSkMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxNQUFPO0lBQ1Q7SUFDQTtRQUNFTCxJQUFJO1FBQ0pDLE1BQU07UUFDTkMsTUFBTTtRQUNOQyxhQUFhO1FBQ2JDLFdBQVc7UUFDWEMsTUFBTztJQUNUO0lBQ0E7UUFDRUwsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxXQUFXO1FBQ1hDLE1BQU87SUFDVDtJQUNBO1FBQ0VMLElBQUk7UUFDSkMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxNQUFPO0lBQ1Q7SUFDQTtRQUNFTCxJQUFJO1FBQ0pDLE1BQU07UUFDTkMsTUFBTTtRQUNOQyxhQUFhO1FBQ2JDLFdBQVc7UUFDWEMsTUFBTztJQWlTVDtDQUNELENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qZXJlbXlqL0RvY3VtZW50cy9zb3VyY2UvcmVwb3Mvc2hhZGVycy9hcHAvZGF0YS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3Qgc2hhZGVyRGF0YSA9IFtcbiAge1xuICAgIGlkOiAnZmx1aWQtc2ltdWxhdGlvbicsXG4gICAgbmFtZTogJ0ZsdWlkIFNpbXVsYXRpb24nLFxuICAgIGljb246ICfiraEnLFxuICAgIGRlc2NyaXB0aW9uOiAnV2ViR0wgRmx1aWQgU2ltdWxhdGlvbiBzaGFkZXInLFxuICAgIHNvdXJjZVVybDogJ2h0dHBzOi8vZ2l0aHViLmNvbS9QYXZlbERvR3JlYXQvV2ViR0wtRmx1aWQtU2ltdWxhdGlvbicsXG4gICAgY29kZTogYC8vIEFkZCB5b3VyIGNvZGUgaGVyZWBcbiAgfSxcbiAge1xuICAgIGlkOiAnZnJhY3RhbC1weXJhbWlkJyxcbiAgICBuYW1lOiAnRnJhY3RhbCBQeXJhbWlkJyxcbiAgICBpY29uOiAn4q2iJyxcbiAgICBkZXNjcmlwdGlvbjogJ0ZyYWN0YWwgUHlyYW1pZCBzaGFkZXIgdmlzdWFsaXphdGlvbicsXG4gICAgc291cmNlVXJsOiAnaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3L2wzY2ZXNCcsXG4gICAgY29kZTogYC8vIEFkZCB5b3VyIGNvZGUgaGVyZWBcbiAgfSxcbiAge1xuICAgIGlkOiAncHJvdGVhbi1jbG91ZHMnLFxuICAgIG5hbWU6ICdQcm90ZWFuIENsb3VkcycsXG4gICAgaWNvbjogJ+KtoycsXG4gICAgZGVzY3JpcHRpb246ICdWb2x1bWV0cmljIGNsb3VkcyBzaGFkZXInLFxuICAgIHNvdXJjZVVybDogJ2h0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy80ZGZHenMnLFxuICAgIGNvZGU6IGAvLyBBZGQgeW91ciBjb2RlIGhlcmVgXG4gIH0sXG4gIHtcbiAgICBpZDogJ3NlYXNjYXBlJyxcbiAgICBuYW1lOiAnU2Vhc2NhcGUnLFxuICAgIGljb246ICfiraAnLFxuICAgIGRlc2NyaXB0aW9uOiAnQW5pbWF0ZWQgc2Vhc2NhcGUgc2hhZGVyJyxcbiAgICBzb3VyY2VVcmw6ICdodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvWHNsR1JyJyxcbiAgICBjb2RlOiBgLy8gQWRkIHlvdXIgY29kZSBoZXJlYFxuICB9LFxuICB7XG4gICAgaWQ6ICdkaXJ0eS1ub3RjaCcsXG4gICAgbmFtZTogJ0RpcnR5IE5vdGNoJyxcbiAgICBpY29uOiAn4q2jJyxcbiAgICBkZXNjcmlwdGlvbjogJ0EgbWVzbWVyaXppbmcgdm94ZWwtYmFzZWQgd2lyZWZyYW1lIHRlcnJhaW4gdmlzdWFsaXphdGlvbiB3aXRoIGR5bmFtaWMgbGlnaHRpbmcgYW5kIGNhbWVyYSBtb3ZlbWVudCcsXG4gICAgc291cmNlVXJsOiAnJyxcbiAgICBjb2RlOiBgLy8gQ29weXJpZ2h0IEluaWdvIFF1aWxleiwgMjAxMyAtIGh0dHBzOi8vaXF1aWxlemxlcy5vcmcvXG4vLyBJIGFtIHRoZSBzb2xlIGNvcHlyaWdodCBvd25lciBvZiB0aGlzIFdvcmsuXG4vLyBZb3UgY2Fubm90IGhvc3QsIGRpc3BsYXksIGRpc3RyaWJ1dGUgb3Igc2hhcmUgdGhpcyBXb3JrIG5laXRoZXJcbi8vIGFzIGl0IGlzIG9yIGFsdGVyZWQsIGhlcmUgb24gU2hhZGVydG95IG9yIGFueXdoZXJlIGVsc2UsIGluIGFueVxuLy8gZm9ybSBpbmNsdWRpbmcgcGh5c2ljYWwgYW5kIGRpZ2l0YWwuIFlvdSBjYW5ub3QgdXNlIHRoaXMgV29yayBpbiBhbnlcbi8vIGNvbW1lcmNpYWwgb3Igbm9uLWNvbW1lcmNpYWwgcHJvZHVjdCwgd2Vic2l0ZSBvciBwcm9qZWN0LiBZb3UgY2Fubm90XG4vLyBzZWxsIHRoaXMgV29yayBhbmQgeW91IGNhbm5vdCBtaW50IGFuIE5GVHMgb2YgaXQgb3IgdHJhaW4gYSBuZXVyYWxcbi8vIG5ldHdvcmsgd2l0aCBpdCB3aXRob3V0IHBlcm1pc3Npb24uIEkgc2hhcmUgdGhpcyBXb3JrIGZvciBlZHVjYXRpb25hbFxuLy8gcHVycG9zZXMsIGFuZCB5b3UgY2FuIGxpbmsgdG8gaXQsIHRocm91Z2ggYW4gVVJMLCBwcm9wZXIgYXR0cmlidXRpb25cbi8vIGFuZCB1bm1vZGlmaWVkIHNjcmVlbnNob3QsIGFzIHBhcnQgb2YgeW91ciBlZHVjYXRpb25hbCBtYXRlcmlhbC4gSWZcbi8vIHRoZXNlIGNvbmRpdGlvbnMgYXJlIHRvbyByZXN0cmljdGl2ZSBwbGVhc2UgY29udGFjdCBtZSBhbmQgd2UnbGxcbi8vIGRlZmluaXRlbHkgd29yayBpdCBvdXQuXG5cbi8vIFNoYWRpbmcgdGVjaG5pcXVlIGV4cGxhaW5lZCBoZXJlOlxuLy9cbi8vIGh0dHBzOi8vaXF1aWxlemxlcy5vcmcvYXJ0aWNsZXMvdm94ZWxsaW5lc1xuXG5cblxuLy8gY29uc2lkZXIgcmVwbGFjaW5nIHRoaXMgYnkgYSBwcm9wZXIgbm9pc2UgZnVuY3Rpb25cbmZsb2F0IG5vaXNlKCBpbiB2ZWMzIHggKVxue1xuICAgIHZlYzMgaSA9IGZsb29yKHgpO1xuICAgIHZlYzMgZiA9IGZyYWN0KHgpO1xuXHRmID0gZipmKigzLjAtMi4wKmYpO1xuXHR2ZWMyIHV2ID0gKGkueHkrdmVjMigzNy4wLDE3LjApKmkueikgKyBmLnh5O1xuXHR2ZWMyIHJnID0gdGV4dHVyZUxvZCggaUNoYW5uZWwwLCAodXYrMC41KS8yNTYuMCwgMC4wICkueXg7XG5cdHJldHVybiBtaXgoIHJnLngsIHJnLnksIGYueiApO1xufVxuXG5mbG9hdCBtYXBUZXJyYWluKCB2ZWMzIHAgKVxue1xuXHRwICo9IDAuMTsgXG5cdHAueHogKj0gMC42O1xuXHRcblx0ZmxvYXQgdGltZSA9IDAuNSArIDAuMTUqaVRpbWU7XG5cdGZsb2F0IGZ0ID0gZnJhY3QoIHRpbWUgKTtcblx0ZmxvYXQgaXQgPSBmbG9vciggdGltZSApO1xuXHRmdCA9IHNtb290aHN0ZXAoIDAuNywgMS4wLCBmdCApO1xuXHR0aW1lID0gaXQgKyBmdDtcblx0ZmxvYXQgc3BlID0gMS40O1xuXHRcblx0ZmxvYXQgZjtcbiAgICBmICA9IDAuNTAwMCpub2lzZSggcCoxLjAwICsgdmVjMygwLjAsMS4wLDAuMCkqc3BlKnRpbWUgKTtcbiAgICBmICs9IDAuMjUwMCpub2lzZSggcCoyLjAyICsgdmVjMygwLjAsMi4wLDAuMCkqc3BlKnRpbWUgKTtcbiAgICBmICs9IDAuMTI1MCpub2lzZSggcCo0LjAxICk7XG5cdHJldHVybiAyNS4wKmYtMTAuMDtcbn1cblxudmVjMyBncm8gPSB2ZWMzKDAuMCk7XG5cbmZsb2F0IG1hcChpbiB2ZWMzIGMpIFxue1xuXHR2ZWMzIHAgPSBjICsgMC41O1xuXHRcblx0ZmxvYXQgZiA9IG1hcFRlcnJhaW4oIHAgKSArIDAuMjUqcC55O1xuXG4gICAgZiA9IG1peCggZiwgMS4wLCBzdGVwKCBsZW5ndGgoZ3JvLXApLCA1LjAgKSApO1xuXG5cdHJldHVybiBzdGVwKCBmLCAwLjUgKTtcbn1cblxuY29uc3QgdmVjMyBsaWcgPSBub3JtYWxpemUoIHZlYzMoLTAuNCwwLjMsMC43KSApO1xuXG5mbG9hdCByYXljYXN0KCBpbiB2ZWMzIHJvLCBpbiB2ZWMzIHJkLCBvdXQgdmVjMyBvVm9zLCBvdXQgdmVjMyBvRGlyIClcbntcblx0dmVjMyBwb3MgPSBmbG9vcihybyk7XG5cdHZlYzMgcmkgPSAxLjAvcmQ7XG5cdHZlYzMgcnMgPSBzaWduKHJkKTtcblx0dmVjMyBkaXMgPSAocG9zLXJvICsgMC41ICsgcnMqMC41KSAqIHJpO1xuXHRcblx0ZmxvYXQgcmVzID0gLTEuMDtcblx0dmVjMyBtbSA9IHZlYzMoMC4wKTtcblx0Zm9yKCBpbnQgaT0wOyBpPDEyODsgaSsrICkgXG5cdHtcblx0XHRpZiggbWFwKHBvcyk+MC41ICkgeyByZXM9MS4wOyBicmVhazsgfVxuXHRcdG1tID0gc3RlcChkaXMueHl6LCBkaXMueXp4KSAqIHN0ZXAoZGlzLnh5eiwgZGlzLnp4eSk7XG5cdFx0ZGlzICs9IG1tICogcnMgKiByaTtcbiAgICAgICAgcG9zICs9IG1tICogcnM7XG5cdH1cblxuXHR2ZWMzIG5vciA9IC1tbSpycztcblx0dmVjMyB2b3MgPSBwb3M7XG5cdFxuICAgIC8vIGludGVyc2VjdCB0aGUgY3ViZVx0XG5cdHZlYzMgbWluaSA9IChwb3Mtcm8gKyAwLjUgLSAwLjUqdmVjMyhycykpKnJpO1xuXHRmbG9hdCB0ID0gbWF4ICggbWluaS54LCBtYXggKCBtaW5pLnksIG1pbmkueiApICk7XG5cdFxuXHRvRGlyID0gbW07XG5cdG9Wb3MgPSB2b3M7XG5cblx0cmV0dXJuIHQqcmVzO1xufVxuXG52ZWMzIHBhdGgoIGZsb2F0IHQsIGZsb2F0IHlhIClcbntcbiAgICB2ZWMyIHAgID0gMTAwLjAqc2luKCAwLjAyKnQqdmVjMigxLjAsMS4yKSArIHZlYzIoMC4xLDAuOSkgKTtcblx0ICAgICBwICs9ICA1MC4wKnNpbiggMC4wNCp0KnZlYzIoMS4zLDEuMCkgKyB2ZWMyKDEuMCw0LjUpICk7XG5cdFxuXHRyZXR1cm4gdmVjMyggcC54LCAxOC4wICsgeWEqNC4wKnNpbigwLjA1KnQpLCBwLnkgKTtcbn1cblxubWF0MyBzZXRDYW1lcmEoIGluIHZlYzMgcm8sIGluIHZlYzMgdGEsIGZsb2F0IGNyIClcbntcblx0dmVjMyBjdyA9IG5vcm1hbGl6ZSh0YS1ybyk7XG5cdHZlYzMgY3AgPSB2ZWMzKHNpbihjciksIGNvcyhjciksMC4wKTtcblx0dmVjMyBjdSA9IG5vcm1hbGl6ZSggY3Jvc3MoY3csY3ApICk7XG5cdHZlYzMgY3YgPSBub3JtYWxpemUoIGNyb3NzKGN1LGN3KSApO1xuICAgIHJldHVybiBtYXQzKCBjdSwgY3YsIC1jdyApO1xufVxuXG5mbG9hdCBtYXhjb21wKCBpbiB2ZWM0IHYgKVxue1xuICAgIHJldHVybiBtYXgoIG1heCh2Lngsdi55KSwgbWF4KHYueix2LncpICk7XG59XG5cbmZsb2F0IGlzRWRnZSggaW4gdmVjMiB1diwgdmVjNCB2YSwgdmVjNCB2YiwgdmVjNCB2YywgdmVjNCB2ZCApXG57XG4gICAgdmVjMiBzdCA9IDEuMCAtIHV2O1xuXG4gICAgLy8gZWRnZXNcbiAgICB2ZWM0IHdiID0gc21vb3Roc3RlcCggMC44NSwgMC45OSwgdmVjNCh1di54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0LngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXYueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdC55KSApICogKCAxLjAgLSB2YSArIHZhKnZjICk7XG4gICAgLy8gY29ybmVyc1xuICAgIHZlYzQgd2MgPSBzbW9vdGhzdGVwKCAwLjg1LCAwLjk5LCB2ZWM0KHV2LngqdXYueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdC54KnV2LnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3QueCpzdC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2Lngqc3QueSkgKSAqICggMS4wIC0gdmIgKyB2ZCp2YiApO1xuICAgIHJldHVybiBtYXhjb21wKCBtYXgod2Isd2MpICk7XG59XG5cblxudmVjMyByZW5kZXIoIGluIHZlYzMgcm8sIGluIHZlYzMgcmQgKVxue1xuICAgIHZlYzMgY29sID0gdmVjMygwLjApO1xuXHRcbiAgICAvLyByYXltYXJjaFx0XG5cdHZlYzMgdm9zLCBkaXI7XG5cdGZsb2F0IHQgPSByYXljYXN0KCBybywgcmQsIHZvcywgZGlyICk7XG5cdGlmKCB0PjAuMCApXG5cdHtcbiAgICAgICAgdmVjMyBub3IgPSAtZGlyKnNpZ24ocmQpO1xuICAgICAgICB2ZWMzIHBvcyA9IHJvICsgcmQqdDtcbiAgICAgICAgdmVjMyB1dncgPSBwb3MgLSB2b3M7XG5cdFx0XG5cdFx0dmVjMyB2MSAgPSB2b3MgKyBub3IgKyBkaXIueXp4O1xuXHQgICAgdmVjMyB2MiAgPSB2b3MgKyBub3IgLSBkaXIueXp4O1xuXHQgICAgdmVjMyB2MyAgPSB2b3MgKyBub3IgKyBkaXIuenh5O1xuXHQgICAgdmVjMyB2NCAgPSB2b3MgKyBub3IgLSBkaXIuenh5O1xuXHRcdHZlYzMgdjUgID0gdm9zICsgbm9yICsgZGlyLnl6eCArIGRpci56eHk7XG4gICAgICAgIHZlYzMgdjYgID0gdm9zICsgbm9yIC0gZGlyLnl6eCArIGRpci56eHk7XG5cdCAgICB2ZWMzIHY3ICA9IHZvcyArIG5vciAtIGRpci55enggLSBkaXIuenh5O1xuXHQgICAgdmVjMyB2OCAgPSB2b3MgKyBub3IgKyBkaXIueXp4IC0gZGlyLnp4eTtcblx0ICAgIHZlYzMgdjkgID0gdm9zICsgZGlyLnl6eDtcblx0ICAgIHZlYzMgdjEwID0gdm9zIC0gZGlyLnl6eDtcblx0ICAgIHZlYzMgdjExID0gdm9zICsgZGlyLnp4eTtcblx0ICAgIHZlYzMgdjEyID0gdm9zIC0gZGlyLnp4eTtcbiBcdCAgICB2ZWMzIHYxMyA9IHZvcyArIGRpci55enggKyBkaXIuenh5OyBcblx0ICAgIHZlYzMgdjE0ID0gdm9zIC0gZGlyLnl6eCArIGRpci56eHkgO1xuXHQgICAgdmVjMyB2MTUgPSB2b3MgLSBkaXIueXp4IC0gZGlyLnp4eTtcblx0ICAgIHZlYzMgdjE2ID0gdm9zICsgZGlyLnl6eCAtIGRpci56eHk7XG5cblx0XHR2ZWM0IHZjID0gdmVjNCggbWFwKHYxKSwgIG1hcCh2MiksICBtYXAodjMpLCAgbWFwKHY0KSAgKTtcblx0ICAgIHZlYzQgdmQgPSB2ZWM0KCBtYXAodjUpLCAgbWFwKHY2KSwgIG1hcCh2NyksICBtYXAodjgpICApO1xuXHQgICAgdmVjNCB2YSA9IHZlYzQoIG1hcCh2OSksICBtYXAodjEwKSwgbWFwKHYxMSksIG1hcCh2MTIpICk7XG5cdCAgICB2ZWM0IHZiID0gdmVjNCggbWFwKHYxMyksIG1hcCh2MTQpLCBtYXAodjE1KSwgbWFwKHYxNikgKTtcblx0XHRcblx0XHR2ZWMyIHV2ID0gdmVjMiggZG90KGRpci55engsIHV2dyksIGRvdChkaXIuenh5LCB1dncpICk7XG5cdFx0XHRcbiAgICAgICAgLy8gd2lyZWZyYW1lXG4gICAgICAgIGZsb2F0IHd3dyA9IDEuMCAtIGlzRWRnZSggdXYsIHZhLCB2YiwgdmMsIHZkICk7XG4gICAgICAgIFxuICAgICAgICB2ZWMzIHdpciA9IHNtb290aHN0ZXAoIDAuNCwgMC41LCBhYnModXZ3LTAuNSkgKTtcbiAgICAgICAgZmxvYXQgdnZ2ID0gKDEuMC13aXIueCp3aXIueSkqKDEuMC13aXIueCp3aXIueikqKDEuMC13aXIueSp3aXIueik7XG5cbiAgICAgICAgY29sID0gdmVjMygwLjUpO1xuICAgICAgICBjb2wgKz0gMC44KnZlYzMoMC4xLDAuMywwLjQpO1xuICAgICAgICBjb2wgKj0gMS4wIC0gMC43NSooMS4wLXZ2dikqd3d3O1xuXHRcdFxuICAgICAgICAvLyBsaWdodGluZ1xuICAgICAgICBmbG9hdCBkaWYgPSBjbGFtcCggZG90KCBub3IsIGxpZyApLCAwLjAsIDEuMCApO1xuICAgICAgICBmbG9hdCBiYWMgPSBjbGFtcCggZG90KCBub3IsIG5vcm1hbGl6ZShsaWcqdmVjMygtMS4wLDAuMCwtMS4wKSkgKSwgMC4wLCAxLjAgKTtcbiAgICAgICAgZmxvYXQgc2t5ID0gMC41ICsgMC41Km5vci55O1xuICAgICAgICBmbG9hdCBhbWIgPSBjbGFtcCgwLjc1ICsgcG9zLnkvMjUuMCwwLjAsMS4wKTtcbiAgICAgICAgZmxvYXQgb2NjID0gMS4wO1xuXHRcbiAgICAgICAgLy8gYW1iaWVudCBvY2NsdXNpb24gKGh0dHBzOi8vaXF1aWxlemxlcy5vcmcvYXJ0aWNsZXMvdm94ZWxsaW5lcy8pXG4gICAgICAgIHZlYzIgc3QgPSAxLjAgLSB1djtcbiAgICAgICAgLy8gZWRnZXNcbiAgICAgICAgdmVjNCB3YSA9IHZlYzQoIHV2LngsIHN0LngsIHV2LnksIHN0LnkgKSAqIHZjO1xuICAgICAgICAvLyBjb3JuZXJzXG4gICAgICAgIHZlYzQgd2IgPSB2ZWM0KHV2LngqdXYueSxcbiAgICAgICAgICAgICAgICAgICAgICAgc3QueCp1di55LFxuICAgICAgICAgICAgICAgICAgICAgICBzdC54KnN0LnksXG4gICAgICAgICAgICAgICAgICAgICAgIHV2Lngqc3QueSkqdmQqKDEuMC12Yy54enl3KSooMS4wLXZjLnp5d3gpO1xuICAgICAgICBvY2MgPSB3YS54ICsgd2EueSArIHdhLnogKyB3YS53ICtcbiAgICAgICAgICAgICAgd2IueCArIHdiLnkgKyB3Yi56ICsgd2IudztcbiAgICAgICAgICAgXG4gICAgICAgICAgIFxuICAgICAgICBvY2MgPSAxLjAgLSBvY2MvOC4wO1xuICAgICAgICBvY2MgPSBvY2Mqb2NjO1xuICAgICAgICBvY2MgPSBvY2Mqb2NjO1xuICAgICAgICBvY2MgKj0gYW1iO1xuXG4gICAgICAgIC8vIGxpZ2h0aW5nXG4gICAgICAgIHZlYzMgbGluID0gdmVjMygwLjApO1xuICAgICAgICBsaW4gKz0gMi41KmRpZip2ZWMzKDEuMDAsMC45MCwwLjcwKSooMC41KzAuNSpvY2MpO1xuICAgICAgICBsaW4gKz0gMC41KmJhYyp2ZWMzKDAuMTUsMC4xMCwwLjEwKSpvY2M7XG4gICAgICAgIGxpbiArPSAyLjAqc2t5KnZlYzMoMC40MCwwLjMwLDAuMTUpKm9jYztcblxuICAgICAgICAvLyBsaW5lIGdsb3dcdFxuICAgICAgICBmbG9hdCBsaW5lZ2xvdyA9IDAuMDtcbiAgICAgICAgbGluZWdsb3cgKz0gc21vb3Roc3RlcCggMC40LCAxLjAsICAgICB1di54ICkqKDEuMC12YS54KigxLjAtdmMueCkpO1xuICAgICAgICBsaW5lZ2xvdyArPSBzbW9vdGhzdGVwKCAwLjQsIDEuMCwgMS4wLXV2LnggKSooMS4wLXZhLnkqKDEuMC12Yy55KSk7XG4gICAgICAgIGxpbmVnbG93ICs9IHNtb290aHN0ZXAoIDAuNCwgMS4wLCAgICAgdXYueSApKigxLjAtdmEueiooMS4wLXZjLnopKTtcbiAgICAgICAgbGluZWdsb3cgKz0gc21vb3Roc3RlcCggMC40LCAxLjAsIDEuMC11di55ICkqKDEuMC12YS53KigxLjAtdmMudykpO1xuICAgICAgICBsaW5lZ2xvdyArPSBzbW9vdGhzdGVwKCAwLjQsIDEuMCwgICAgICB1di55KiAgICAgIHV2LnggKSooMS4wLXZiLngqKDEuMC12ZC54KSk7XG4gICAgICAgIGxpbmVnbG93ICs9IHNtb290aHN0ZXAoIDAuNCwgMS4wLCAgICAgIHV2LnkqICgxLjAtdXYueCkpKigxLjAtdmIueSooMS4wLXZkLnkpKTtcbiAgICAgICAgbGluZWdsb3cgKz0gc21vb3Roc3RlcCggMC40LCAxLjAsICgxLjAtdXYueSkqKDEuMC11di54KSkqKDEuMC12Yi56KigxLjAtdmQueikpO1xuICAgICAgICBsaW5lZ2xvdyArPSBzbW9vdGhzdGVwKCAwLjQsIDEuMCwgKDEuMC11di55KSogICAgIHV2LnggKSooMS4wLXZiLncqKDEuMC12ZC53KSk7XG5cdFx0XG4gICAgICAgIHZlYzMgbGluQ29sID0gMi4wKnZlYzMoNS4wLDAuNiwwLjApO1xuICAgICAgICBsaW5Db2wgKj0gKDAuNSswLjUqb2NjKSowLjU7XG4gICAgICAgIGxpbiArPSBsaW5lZ2xvdypsaW5Db2w7XG5cdFx0XG4gICAgICAgIGNvbCA9IGNvbCpsaW47XG4gICAgICAgIGNvbCArPSA4LjAqbGluQ29sKnZlYzMoMS4wLDIuMCwzLjApKigxLjAtd3d3KTsvLyooMC41KzEuMCpzaGEpO1xuICAgICAgICBjb2wgKz0gMC4xKmxpbmVnbG93KmxpbkNvbDtcbiAgICAgICAgY29sICo9IG1pbigwLjEsZXhwKCAtMC4wNyp0ICkpO1xuXHRcbiAgICAgICAgLy8gYmxlbmQgdG8gYmxhY2sgJiB3aGl0ZVx0XHRcbiAgICAgICAgdmVjMyBjb2wyID0gdmVjMygxLjMpKigwLjUrMC41Km5vci55KSpvY2MqZXhwKCAtMC4wNCp0ICk7O1xuICAgICAgICBmbG9hdCBtaSA9IGNvcygtMC43KzAuNSppVGltZSk7XG4gICAgICAgIG1pID0gc21vb3Roc3RlcCggMC43MCwgMC43NSwgbWkgKTtcbiAgICAgICAgY29sID0gbWl4KCBjb2wsIGNvbDIsIG1pICk7XG5cdH1cblxuXHQvLyBnYW1tYVx0XG5cdGNvbCA9IHBvdyggY29sLCB2ZWMzKDAuNDUpICk7XG5cbiAgICByZXR1cm4gY29sO1xufVxuXG52b2lkIG1haW5JbWFnZSggb3V0IHZlYzQgZnJhZ0NvbG9yLCBpbiB2ZWMyIGZyYWdDb29yZCApXG57XG4gICAgLy8gaW5wdXRzXHRcbiAgICB2ZWMyIHAgPSAoMi4wKmZyYWdDb29yZC1pUmVzb2x1dGlvbi54eSkvaVJlc29sdXRpb24ueTtcbiAgICB2ZWMyIG1vID0gaU1vdXNlLnh5IC8gaVJlc29sdXRpb24ueHk7XG4gICAgaWYoIGlNb3VzZS56PD0wLjAwMDAxICkgbW89dmVjMigwLjApO1xuXHRmbG9hdCB0aW1lID0gMi4wKmlUaW1lICsgNTAuMCptby54O1xuICAgIFxuICAgIC8vIGNhbWVyYVxuXHRmbG9hdCBjciA9IDAuMipjb3MoMC4xKmlUaW1lKTtcblx0dmVjMyBybyA9IHBhdGgoIHRpbWUrMC4wLCAxLjAgKTtcblx0dmVjMyB0YSA9IHBhdGgoIHRpbWUrNS4wLCAxLjAgKSAtIHZlYzMoMC4wLDYuMCwwLjApO1xuXHRncm8gPSBybztcblxuICAgIG1hdDMgY2FtID0gc2V0Q2FtZXJhKCBybywgdGEsIGNyICk7XG5cdFxuXHQvLyBidWlsZCByYXlcbiAgICBmbG9hdCByMiA9IHAueCpwLngqMC4zMiArIHAueSpwLnk7XG4gICAgcCAqPSAoNy4wLXNxcnQoMzcuNS0xMS41KnIyKSkvKHIyKzEuMCk7XG4gICAgdmVjMyByZCA9IG5vcm1hbGl6ZSggY2FtICogdmVjMyhwLnh5LC0yLjUpICk7XG5cbiAgICB2ZWMzIGNvbCA9IHJlbmRlciggcm8sIHJkICk7XG4gICAgXG5cdC8vIHZpZ25ldHRpbmdcdFxuXHR2ZWMyIHEgPSBmcmFnQ29vcmQgLyBpUmVzb2x1dGlvbi54eTtcblx0Y29sICo9IDAuNSArIDAuNSpwb3coIDE2LjAqcS54KnEueSooMS4wLXEueCkqKDEuMC1xLnkpLCAwLjEgKTtcblx0XG5cdGZyYWdDb2xvciA9IHZlYzQoIGNvbCwgMS4wICk7XG59XG5cbnZvaWQgbWFpblZSKCBvdXQgdmVjNCBmcmFnQ29sb3IsIGluIHZlYzIgZnJhZ0Nvb3JkLCBpbiB2ZWMzIGZyYWdSYXlPcmksIGluIHZlYzMgZnJhZ1JheURpciApXG57XG5cdGZsb2F0IHRpbWUgPSAxLjAqaVRpbWU7XG5cbiAgICBmbG9hdCBjciA9IDAuMDtcblx0dmVjMyBybyA9IHBhdGgoIHRpbWUrMC4wLCAwLjAgKSArIHZlYzMoMC4wLDAuNywwLjApO1xuXHR2ZWMzIHRhID0gcGF0aCggdGltZSsyLjUsIDAuMCApICsgdmVjMygwLjAsMC43LDAuMCk7XG5cbiAgICBtYXQzIGNhbSA9IHNldENhbWVyYSggcm8sIHRhLCBjciApO1xuXG4gICAgdmVjMyBjb2wgPSByZW5kZXIoIHJvICsgY2FtKmZyYWdSYXlPcmksIGNhbSpmcmFnUmF5RGlyICk7XG4gICAgXG4gICAgZnJhZ0NvbG9yID0gdmVjNCggY29sLCAxLjAgKTtcbn1gXG4gIH1cbl07ICJdLCJuYW1lcyI6WyJzaGFkZXJEYXRhIiwiaWQiLCJuYW1lIiwiaWNvbiIsImRlc2NyaXB0aW9uIiwic291cmNlVXJsIiwiY29kZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/data.ts\n"));

/***/ })

});