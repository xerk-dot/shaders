"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/[id]/page",{

/***/ "(app-pages-browser)/./app/shaders/dirty-notch.ts":
/*!************************************!*\
  !*** ./app/shaders/dirty-notch.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fragmentShader: () => (/* binding */ fragmentShader),\n/* harmony export */   vertexShader: () => (/* binding */ vertexShader)\n/* harmony export */ });\nconst vertexShader = \"\\n  attribute vec4 position;\\n  void main() {\\n    gl_Position = position;\\n  }\\n\";\nconst fragmentShader = \"\\n/ consider replacing this by a proper noise function\\nfloat noise( in vec3 x )\\n{\\n    vec3 i = floor(x);\\n    vec3 f = fract(x);\\n\tf = f*f*(3.0-2.0*f);\\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\\n\treturn mix( rg.x, rg.y, f.z );\\n}\\n\\nfloat mapTerrain( vec3 p )\\n{\\n\tp *= 0.1; \\n\tp.xz *= 0.6;\\n\t\\n\tfloat time = 0.5 + 0.15*iTime;\\n\tfloat ft = fract( time );\\n\tfloat it = floor( time );\\n\tft = smoothstep( 0.7, 1.0, ft );\\n\ttime = it + ft;\\n\tfloat spe = 1.4;\\n\t\\n\tfloat f;\\n    f  = 0.5000*noise( p*1.00 + vec3(0.0,1.0,0.0)*spe*time );\\n    f += 0.2500*noise( p*2.02 + vec3(0.0,2.0,0.0)*spe*time );\\n    f += 0.1250*noise( p*4.01 );\\n\treturn 25.0*f-10.0;\\n}\\n\\nvec3 gro = vec3(0.0);\\n\\nfloat map(in vec3 c) \\n{\\n\tvec3 p = c + 0.5;\\n\t\\n\tfloat f = mapTerrain( p ) + 0.25*p.y;\\n\\n    f = mix( f, 1.0, step( length(gro-p), 5.0 ) );\\n\\n\treturn step( f, 0.5 );\\n}\\n\\nconst vec3 lig = normalize( vec3(-0.4,0.3,0.7) );\\n\\nfloat raycast( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir )\\n{\\n\tvec3 pos = floor(ro);\\n\tvec3 ri = 1.0/rd;\\n\tvec3 rs = sign(rd);\\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\\n\t\\n\tfloat res = -1.0;\\n\tvec3 mm = vec3(0.0);\\n\tfor( int i=0; i<128; i++ ) \\n\t{\\n\t\tif( map(pos)>0.5 ) { res=1.0; break; }\\n\t\tmm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\\n\t\tdis += mm * rs * ri;\\n        pos += mm * rs;\\n\t}\\n\\n\tvec3 nor = -mm*rs;\\n\tvec3 vos = pos;\\n\t\\n    // intersect the cube\t\\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\\n\t\\n\toDir = mm;\\n\toVos = vos;\\n\\n\treturn t*res;\\n}\\n\\nvec3 path( float t, float ya )\\n{\\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\\n\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\\n\t\\n\treturn vec3( p.x, 18.0 + ya*4.0*sin(0.05*t), p.y );\\n}\\n\\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\\n{\\n\tvec3 cw = normalize(ta-ro);\\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\\n\tvec3 cu = normalize( cross(cw,cp) );\\n\tvec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, -cw );\\n}\\n\\nfloat maxcomp( in vec4 v )\\n{\\n    return max( max(v.x,v.y), max(v.z,v.w) );\\n}\\n\\nfloat isEdge( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\\n{\\n    vec2 st = 1.0 - uv;\\n\\n    // edges\\n    vec4 wb = smoothstep( 0.85, 0.99, vec4(uv.x,\\n                                           st.x,\\n                                           uv.y,\\n                                           st.y) ) * ( 1.0 - va + va*vc );\\n    // corners\\n    vec4 wc = smoothstep( 0.85, 0.99, vec4(uv.x*uv.y,\\n                                           st.x*uv.y,\\n                                           st.x*st.y,\\n                                           uv.x*st.y) ) * ( 1.0 - vb + vd*vb );\\n    return maxcomp( max(wb,wc) );\\n}\\n\\n\\nvec3 render( in vec3 ro, in vec3 rd )\\n{\\n    vec3 col = vec3(0.0);\\n\t\\n    // raymarch\t\\n\tvec3 vos, dir;\\n\tfloat t = raycast( ro, rd, vos, dir );\\n\tif( t>0.0 )\\n\t{\\n        vec3 nor = -dir*sign(rd);\\n        vec3 pos = ro + rd*t;\\n        vec3 uvw = pos - vos;\\n\t\t\\n\t\tvec3 v1  = vos + nor + dir.yzx;\\n\t    vec3 v2  = vos + nor - dir.yzx;\\n\t    vec3 v3  = vos + nor + dir.zxy;\\n\t    vec3 v4  = vos + nor - dir.zxy;\\n\t\tvec3 v5  = vos + nor + dir.yzx + dir.zxy;\\n        vec3 v6  = vos + nor - dir.yzx + dir.zxy;\\n\t    vec3 v7  = vos + nor - dir.yzx - dir.zxy;\\n\t    vec3 v8  = vos + nor + dir.yzx - dir.zxy;\\n\t    vec3 v9  = vos + dir.yzx;\\n\t    vec3 v10 = vos - dir.yzx;\\n\t    vec3 v11 = vos + dir.zxy;\\n\t    vec3 v12 = vos - dir.zxy;\\n \t    vec3 v13 = vos + dir.yzx + dir.zxy; \\n\t    vec3 v14 = vos - dir.yzx + dir.zxy ;\\n\t    vec3 v15 = vos - dir.yzx - dir.zxy;\\n\t    vec3 v16 = vos + dir.yzx - dir.zxy;\\n\\n\t\tvec4 vc = vec4( map(v1),  map(v2),  map(v3),  map(v4)  );\\n\t    vec4 vd = vec4( map(v5),  map(v6),  map(v7),  map(v8)  );\\n\t    vec4 va = vec4( map(v9),  map(v10), map(v11), map(v12) );\\n\t    vec4 vb = vec4( map(v13), map(v14), map(v15), map(v16) );\\n\t\t\\n\t\tvec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\\n\t\t\t\\n        // wireframe\\n        float www = 1.0 - isEdge( uv, va, vb, vc, vd );\\n        \\n        vec3 wir = smoothstep( 0.4, 0.5, abs(uvw-0.5) );\\n        float vvv = (1.0-wir.x*wir.y)*(1.0-wir.x*wir.z)*(1.0-wir.y*wir.z);\\n\\n        col = vec3(0.5);\\n        col += 0.8*vec3(0.1,0.3,0.4);\\n        col *= 1.0 - 0.75*(1.0-vvv)*www;\\n\t\t\\n        // lighting\\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\\n        float bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\\n        float sky = 0.5 + 0.5*nor.y;\\n        float amb = clamp(0.75 + pos.y/25.0,0.0,1.0);\\n        float occ = 1.0;\\n\t\\n        // ambient occlusion (https://iquilezles.org/articles/voxellines/)\\n        vec2 st = 1.0 - uv;\\n        // edges\\n        vec4 wa = vec4( uv.x, st.x, uv.y, st.y ) * vc;\\n        // corners\\n        vec4 wb = vec4(uv.x*uv.y,\\n                       st.x*uv.y,\\n                       st.x*st.y,\\n                       uv.x*st.y)*vd*(1.0-vc.xzyw)*(1.0-vc.zywx);\\n        occ = wa.x + wa.y + wa.z + wa.w +\\n              wb.x + wb.y + wb.z + wb.w;\\n           \\n           \\n        occ = 1.0 - occ/8.0;\\n        occ = occ*occ;\\n        occ = occ*occ;\\n        occ *= amb;\\n\\n        // lighting\\n        vec3 lin = vec3(0.0);\\n        lin += 2.5*dif*vec3(1.00,0.90,0.70)*(0.5+0.5*occ);\\n        lin += 0.5*bac*vec3(0.15,0.10,0.10)*occ;\\n        lin += 2.0*sky*vec3(0.40,0.30,0.15)*occ;\\n\\n        // line glow\t\\n        float lineglow = 0.0;\\n        lineglow += smoothstep( 0.4, 1.0,     uv.x )*(1.0-va.x*(1.0-vc.x));\\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.x )*(1.0-va.y*(1.0-vc.y));\\n        lineglow += smoothstep( 0.4, 1.0,     uv.y )*(1.0-va.z*(1.0-vc.z));\\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.y )*(1.0-va.w*(1.0-vc.w));\\n        lineglow += smoothstep( 0.4, 1.0,      uv.y*      uv.x )*(1.0-vb.x*(1.0-vd.x));\\n        lineglow += smoothstep( 0.4, 1.0,      uv.y* (1.0-uv.x))*(1.0-vb.y*(1.0-vd.y));\\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*(1.0-uv.x))*(1.0-vb.z*(1.0-vd.z));\\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*     uv.x )*(1.0-vb.w*(1.0-vd.w));\\n\t\t\\n        vec3 linCol = 2.0*vec3(5.0,0.6,0.0);\\n        linCol *= (0.5+0.5*occ)*0.5;\\n        lin += lineglow*linCol;\\n\t\t\\n        col = col*lin;\\n        col += 8.0*linCol*vec3(1.0,2.0,3.0)*(1.0-www);//*(0.5+1.0*sha);\\n        col += 0.1*lineglow*linCol;\\n        col *= min(0.1,exp( -0.07*t ));\\n\t\\n        // blend to black & white\t\t\\n        vec3 col2 = vec3(1.3)*(0.5+0.5*nor.y)*occ*exp( -0.04*t );;\\n        float mi = cos(-0.7+0.5*iTime);\\n        mi = smoothstep( 0.70, 0.75, mi );\\n        col = mix( col, col2, mi );\\n\t}\\n\\n\t// gamma\t\\n\tcol = pow( col, vec3(0.45) );\\n\\n    return col;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\n{\\n    // inputs\t\\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\\n    vec2 mo = iMouse.xy / iResolution.xy;\\n    if( iMouse.z<=0.00001 ) mo=vec2(0.0);\\n\tfloat time = 2.0*iTime + 50.0*mo.x;\\n    \\n    // camera\\n\tfloat cr = 0.2*cos(0.1*iTime);\\n\tvec3 ro = path( time+0.0, 1.0 );\\n\tvec3 ta = path( time+5.0, 1.0 ) - vec3(0.0,6.0,0.0);\\n\tgro = ro;\\n\\n    mat3 cam = setCamera( ro, ta, cr );\\n\t\\n\t// build ray\\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\\n    vec3 rd = normalize( cam * vec3(p.xy,-2.5) );\\n\\n    vec3 col = render( ro, rd );\\n    \\n\t// vignetting\t\\n\tvec2 q = fragCoord / iResolution.xy;\\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\\n\t\\n\tfragColor = vec4( col, 1.0 );\\n}\\n\\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\\n{\\n\tfloat time = 1.0*iTime;\\n\\n    float cr = 0.0;\\n\tvec3 ro = path( time+0.0, 0.0 ) + vec3(0.0,0.7,0.0);\\n\tvec3 ta = path( time+2.5, 0.0 ) + vec3(0.0,0.7,0.0);\\n\\n    mat3 cam = setCamera( ro, ta, cr );\\n\\n    vec3 col = render( ro + cam*fragRayOri, cam*fragRayDir );\\n    \\n    fragColor = vec4( col, 1.0 );\\n}\\n\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zaGFkZXJzL2RpcnR5LW5vdGNoLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU8sTUFBTUEsZUFBZ0Isb0ZBSzNCO0FBRUssTUFBTUMsaUJBQWtCLHUwUEErUTdCIiwic291cmNlcyI6WyIvVXNlcnMvamVyZW15ai9Eb2N1bWVudHMvc291cmNlL3JlcG9zL3NoYWRlcnMvYXBwL3NoYWRlcnMvZGlydHktbm90Y2gudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnRleFNoYWRlciA9IGBcbiAgYXR0cmlidXRlIHZlYzQgcG9zaXRpb247XG4gIHZvaWQgbWFpbigpIHtcbiAgICBnbF9Qb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB9XG5gO1xuXG5leHBvcnQgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBgXG4vIGNvbnNpZGVyIHJlcGxhY2luZyB0aGlzIGJ5IGEgcHJvcGVyIG5vaXNlIGZ1bmN0aW9uXG5mbG9hdCBub2lzZSggaW4gdmVjMyB4IClcbntcbiAgICB2ZWMzIGkgPSBmbG9vcih4KTtcbiAgICB2ZWMzIGYgPSBmcmFjdCh4KTtcblx0ZiA9IGYqZiooMy4wLTIuMCpmKTtcblx0dmVjMiB1diA9IChpLnh5K3ZlYzIoMzcuMCwxNy4wKSppLnopICsgZi54eTtcblx0dmVjMiByZyA9IHRleHR1cmVMb2QoIGlDaGFubmVsMCwgKHV2KzAuNSkvMjU2LjAsIDAuMCApLnl4O1xuXHRyZXR1cm4gbWl4KCByZy54LCByZy55LCBmLnogKTtcbn1cblxuZmxvYXQgbWFwVGVycmFpbiggdmVjMyBwIClcbntcblx0cCAqPSAwLjE7IFxuXHRwLnh6ICo9IDAuNjtcblx0XG5cdGZsb2F0IHRpbWUgPSAwLjUgKyAwLjE1KmlUaW1lO1xuXHRmbG9hdCBmdCA9IGZyYWN0KCB0aW1lICk7XG5cdGZsb2F0IGl0ID0gZmxvb3IoIHRpbWUgKTtcblx0ZnQgPSBzbW9vdGhzdGVwKCAwLjcsIDEuMCwgZnQgKTtcblx0dGltZSA9IGl0ICsgZnQ7XG5cdGZsb2F0IHNwZSA9IDEuNDtcblx0XG5cdGZsb2F0IGY7XG4gICAgZiAgPSAwLjUwMDAqbm9pc2UoIHAqMS4wMCArIHZlYzMoMC4wLDEuMCwwLjApKnNwZSp0aW1lICk7XG4gICAgZiArPSAwLjI1MDAqbm9pc2UoIHAqMi4wMiArIHZlYzMoMC4wLDIuMCwwLjApKnNwZSp0aW1lICk7XG4gICAgZiArPSAwLjEyNTAqbm9pc2UoIHAqNC4wMSApO1xuXHRyZXR1cm4gMjUuMCpmLTEwLjA7XG59XG5cbnZlYzMgZ3JvID0gdmVjMygwLjApO1xuXG5mbG9hdCBtYXAoaW4gdmVjMyBjKSBcbntcblx0dmVjMyBwID0gYyArIDAuNTtcblx0XG5cdGZsb2F0IGYgPSBtYXBUZXJyYWluKCBwICkgKyAwLjI1KnAueTtcblxuICAgIGYgPSBtaXgoIGYsIDEuMCwgc3RlcCggbGVuZ3RoKGdyby1wKSwgNS4wICkgKTtcblxuXHRyZXR1cm4gc3RlcCggZiwgMC41ICk7XG59XG5cbmNvbnN0IHZlYzMgbGlnID0gbm9ybWFsaXplKCB2ZWMzKC0wLjQsMC4zLDAuNykgKTtcblxuZmxvYXQgcmF5Y2FzdCggaW4gdmVjMyBybywgaW4gdmVjMyByZCwgb3V0IHZlYzMgb1Zvcywgb3V0IHZlYzMgb0RpciApXG57XG5cdHZlYzMgcG9zID0gZmxvb3Iocm8pO1xuXHR2ZWMzIHJpID0gMS4wL3JkO1xuXHR2ZWMzIHJzID0gc2lnbihyZCk7XG5cdHZlYzMgZGlzID0gKHBvcy1ybyArIDAuNSArIHJzKjAuNSkgKiByaTtcblx0XG5cdGZsb2F0IHJlcyA9IC0xLjA7XG5cdHZlYzMgbW0gPSB2ZWMzKDAuMCk7XG5cdGZvciggaW50IGk9MDsgaTwxMjg7IGkrKyApIFxuXHR7XG5cdFx0aWYoIG1hcChwb3MpPjAuNSApIHsgcmVzPTEuMDsgYnJlYWs7IH1cblx0XHRtbSA9IHN0ZXAoZGlzLnh5eiwgZGlzLnl6eCkgKiBzdGVwKGRpcy54eXosIGRpcy56eHkpO1xuXHRcdGRpcyArPSBtbSAqIHJzICogcmk7XG4gICAgICAgIHBvcyArPSBtbSAqIHJzO1xuXHR9XG5cblx0dmVjMyBub3IgPSAtbW0qcnM7XG5cdHZlYzMgdm9zID0gcG9zO1xuXHRcbiAgICAvLyBpbnRlcnNlY3QgdGhlIGN1YmVcdFxuXHR2ZWMzIG1pbmkgPSAocG9zLXJvICsgMC41IC0gMC41KnZlYzMocnMpKSpyaTtcblx0ZmxvYXQgdCA9IG1heCAoIG1pbmkueCwgbWF4ICggbWluaS55LCBtaW5pLnogKSApO1xuXHRcblx0b0RpciA9IG1tO1xuXHRvVm9zID0gdm9zO1xuXG5cdHJldHVybiB0KnJlcztcbn1cblxudmVjMyBwYXRoKCBmbG9hdCB0LCBmbG9hdCB5YSApXG57XG4gICAgdmVjMiBwICA9IDEwMC4wKnNpbiggMC4wMip0KnZlYzIoMS4wLDEuMikgKyB2ZWMyKDAuMSwwLjkpICk7XG5cdCAgICAgcCArPSAgNTAuMCpzaW4oIDAuMDQqdCp2ZWMyKDEuMywxLjApICsgdmVjMigxLjAsNC41KSApO1xuXHRcblx0cmV0dXJuIHZlYzMoIHAueCwgMTguMCArIHlhKjQuMCpzaW4oMC4wNSp0KSwgcC55ICk7XG59XG5cbm1hdDMgc2V0Q2FtZXJhKCBpbiB2ZWMzIHJvLCBpbiB2ZWMzIHRhLCBmbG9hdCBjciApXG57XG5cdHZlYzMgY3cgPSBub3JtYWxpemUodGEtcm8pO1xuXHR2ZWMzIGNwID0gdmVjMyhzaW4oY3IpLCBjb3MoY3IpLDAuMCk7XG5cdHZlYzMgY3UgPSBub3JtYWxpemUoIGNyb3NzKGN3LGNwKSApO1xuXHR2ZWMzIGN2ID0gbm9ybWFsaXplKCBjcm9zcyhjdSxjdykgKTtcbiAgICByZXR1cm4gbWF0MyggY3UsIGN2LCAtY3cgKTtcbn1cblxuZmxvYXQgbWF4Y29tcCggaW4gdmVjNCB2IClcbntcbiAgICByZXR1cm4gbWF4KCBtYXgodi54LHYueSksIG1heCh2Lnosdi53KSApO1xufVxuXG5mbG9hdCBpc0VkZ2UoIGluIHZlYzIgdXYsIHZlYzQgdmEsIHZlYzQgdmIsIHZlYzQgdmMsIHZlYzQgdmQgKVxue1xuICAgIHZlYzIgc3QgPSAxLjAgLSB1djtcblxuICAgIC8vIGVkZ2VzXG4gICAgdmVjNCB3YiA9IHNtb290aHN0ZXAoIDAuODUsIDAuOTksIHZlYzQodXYueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2LnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3QueSkgKSAqICggMS4wIC0gdmEgKyB2YSp2YyApO1xuICAgIC8vIGNvcm5lcnNcbiAgICB2ZWM0IHdjID0gc21vb3Roc3RlcCggMC44NSwgMC45OSwgdmVjNCh1di54KnV2LnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3QueCp1di55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0Lngqc3QueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1di54KnN0LnkpICkgKiAoIDEuMCAtIHZiICsgdmQqdmIgKTtcbiAgICByZXR1cm4gbWF4Y29tcCggbWF4KHdiLHdjKSApO1xufVxuXG5cbnZlYzMgcmVuZGVyKCBpbiB2ZWMzIHJvLCBpbiB2ZWMzIHJkIClcbntcbiAgICB2ZWMzIGNvbCA9IHZlYzMoMC4wKTtcblx0XG4gICAgLy8gcmF5bWFyY2hcdFxuXHR2ZWMzIHZvcywgZGlyO1xuXHRmbG9hdCB0ID0gcmF5Y2FzdCggcm8sIHJkLCB2b3MsIGRpciApO1xuXHRpZiggdD4wLjAgKVxuXHR7XG4gICAgICAgIHZlYzMgbm9yID0gLWRpcipzaWduKHJkKTtcbiAgICAgICAgdmVjMyBwb3MgPSBybyArIHJkKnQ7XG4gICAgICAgIHZlYzMgdXZ3ID0gcG9zIC0gdm9zO1xuXHRcdFxuXHRcdHZlYzMgdjEgID0gdm9zICsgbm9yICsgZGlyLnl6eDtcblx0ICAgIHZlYzMgdjIgID0gdm9zICsgbm9yIC0gZGlyLnl6eDtcblx0ICAgIHZlYzMgdjMgID0gdm9zICsgbm9yICsgZGlyLnp4eTtcblx0ICAgIHZlYzMgdjQgID0gdm9zICsgbm9yIC0gZGlyLnp4eTtcblx0XHR2ZWMzIHY1ICA9IHZvcyArIG5vciArIGRpci55enggKyBkaXIuenh5O1xuICAgICAgICB2ZWMzIHY2ICA9IHZvcyArIG5vciAtIGRpci55enggKyBkaXIuenh5O1xuXHQgICAgdmVjMyB2NyAgPSB2b3MgKyBub3IgLSBkaXIueXp4IC0gZGlyLnp4eTtcblx0ICAgIHZlYzMgdjggID0gdm9zICsgbm9yICsgZGlyLnl6eCAtIGRpci56eHk7XG5cdCAgICB2ZWMzIHY5ICA9IHZvcyArIGRpci55eng7XG5cdCAgICB2ZWMzIHYxMCA9IHZvcyAtIGRpci55eng7XG5cdCAgICB2ZWMzIHYxMSA9IHZvcyArIGRpci56eHk7XG5cdCAgICB2ZWMzIHYxMiA9IHZvcyAtIGRpci56eHk7XG4gXHQgICAgdmVjMyB2MTMgPSB2b3MgKyBkaXIueXp4ICsgZGlyLnp4eTsgXG5cdCAgICB2ZWMzIHYxNCA9IHZvcyAtIGRpci55enggKyBkaXIuenh5IDtcblx0ICAgIHZlYzMgdjE1ID0gdm9zIC0gZGlyLnl6eCAtIGRpci56eHk7XG5cdCAgICB2ZWMzIHYxNiA9IHZvcyArIGRpci55enggLSBkaXIuenh5O1xuXG5cdFx0dmVjNCB2YyA9IHZlYzQoIG1hcCh2MSksICBtYXAodjIpLCAgbWFwKHYzKSwgIG1hcCh2NCkgICk7XG5cdCAgICB2ZWM0IHZkID0gdmVjNCggbWFwKHY1KSwgIG1hcCh2NiksICBtYXAodjcpLCAgbWFwKHY4KSAgKTtcblx0ICAgIHZlYzQgdmEgPSB2ZWM0KCBtYXAodjkpLCAgbWFwKHYxMCksIG1hcCh2MTEpLCBtYXAodjEyKSApO1xuXHQgICAgdmVjNCB2YiA9IHZlYzQoIG1hcCh2MTMpLCBtYXAodjE0KSwgbWFwKHYxNSksIG1hcCh2MTYpICk7XG5cdFx0XG5cdFx0dmVjMiB1diA9IHZlYzIoIGRvdChkaXIueXp4LCB1dncpLCBkb3QoZGlyLnp4eSwgdXZ3KSApO1xuXHRcdFx0XG4gICAgICAgIC8vIHdpcmVmcmFtZVxuICAgICAgICBmbG9hdCB3d3cgPSAxLjAgLSBpc0VkZ2UoIHV2LCB2YSwgdmIsIHZjLCB2ZCApO1xuICAgICAgICBcbiAgICAgICAgdmVjMyB3aXIgPSBzbW9vdGhzdGVwKCAwLjQsIDAuNSwgYWJzKHV2dy0wLjUpICk7XG4gICAgICAgIGZsb2F0IHZ2diA9ICgxLjAtd2lyLngqd2lyLnkpKigxLjAtd2lyLngqd2lyLnopKigxLjAtd2lyLnkqd2lyLnopO1xuXG4gICAgICAgIGNvbCA9IHZlYzMoMC41KTtcbiAgICAgICAgY29sICs9IDAuOCp2ZWMzKDAuMSwwLjMsMC40KTtcbiAgICAgICAgY29sICo9IDEuMCAtIDAuNzUqKDEuMC12dnYpKnd3dztcblx0XHRcbiAgICAgICAgLy8gbGlnaHRpbmdcbiAgICAgICAgZmxvYXQgZGlmID0gY2xhbXAoIGRvdCggbm9yLCBsaWcgKSwgMC4wLCAxLjAgKTtcbiAgICAgICAgZmxvYXQgYmFjID0gY2xhbXAoIGRvdCggbm9yLCBub3JtYWxpemUobGlnKnZlYzMoLTEuMCwwLjAsLTEuMCkpICksIDAuMCwgMS4wICk7XG4gICAgICAgIGZsb2F0IHNreSA9IDAuNSArIDAuNSpub3IueTtcbiAgICAgICAgZmxvYXQgYW1iID0gY2xhbXAoMC43NSArIHBvcy55LzI1LjAsMC4wLDEuMCk7XG4gICAgICAgIGZsb2F0IG9jYyA9IDEuMDtcblx0XG4gICAgICAgIC8vIGFtYmllbnQgb2NjbHVzaW9uIChodHRwczovL2lxdWlsZXpsZXMub3JnL2FydGljbGVzL3ZveGVsbGluZXMvKVxuICAgICAgICB2ZWMyIHN0ID0gMS4wIC0gdXY7XG4gICAgICAgIC8vIGVkZ2VzXG4gICAgICAgIHZlYzQgd2EgPSB2ZWM0KCB1di54LCBzdC54LCB1di55LCBzdC55ICkgKiB2YztcbiAgICAgICAgLy8gY29ybmVyc1xuICAgICAgICB2ZWM0IHdiID0gdmVjNCh1di54KnV2LnksXG4gICAgICAgICAgICAgICAgICAgICAgIHN0LngqdXYueSxcbiAgICAgICAgICAgICAgICAgICAgICAgc3QueCpzdC55LFxuICAgICAgICAgICAgICAgICAgICAgICB1di54KnN0LnkpKnZkKigxLjAtdmMueHp5dykqKDEuMC12Yy56eXd4KTtcbiAgICAgICAgb2NjID0gd2EueCArIHdhLnkgKyB3YS56ICsgd2EudyArXG4gICAgICAgICAgICAgIHdiLnggKyB3Yi55ICsgd2IueiArIHdiLnc7XG4gICAgICAgICAgIFxuICAgICAgICAgICBcbiAgICAgICAgb2NjID0gMS4wIC0gb2NjLzguMDtcbiAgICAgICAgb2NjID0gb2NjKm9jYztcbiAgICAgICAgb2NjID0gb2NjKm9jYztcbiAgICAgICAgb2NjICo9IGFtYjtcblxuICAgICAgICAvLyBsaWdodGluZ1xuICAgICAgICB2ZWMzIGxpbiA9IHZlYzMoMC4wKTtcbiAgICAgICAgbGluICs9IDIuNSpkaWYqdmVjMygxLjAwLDAuOTAsMC43MCkqKDAuNSswLjUqb2NjKTtcbiAgICAgICAgbGluICs9IDAuNSpiYWMqdmVjMygwLjE1LDAuMTAsMC4xMCkqb2NjO1xuICAgICAgICBsaW4gKz0gMi4wKnNreSp2ZWMzKDAuNDAsMC4zMCwwLjE1KSpvY2M7XG5cbiAgICAgICAgLy8gbGluZSBnbG93XHRcbiAgICAgICAgZmxvYXQgbGluZWdsb3cgPSAwLjA7XG4gICAgICAgIGxpbmVnbG93ICs9IHNtb290aHN0ZXAoIDAuNCwgMS4wLCAgICAgdXYueCApKigxLjAtdmEueCooMS4wLXZjLngpKTtcbiAgICAgICAgbGluZWdsb3cgKz0gc21vb3Roc3RlcCggMC40LCAxLjAsIDEuMC11di54ICkqKDEuMC12YS55KigxLjAtdmMueSkpO1xuICAgICAgICBsaW5lZ2xvdyArPSBzbW9vdGhzdGVwKCAwLjQsIDEuMCwgICAgIHV2LnkgKSooMS4wLXZhLnoqKDEuMC12Yy56KSk7XG4gICAgICAgIGxpbmVnbG93ICs9IHNtb290aHN0ZXAoIDAuNCwgMS4wLCAxLjAtdXYueSApKigxLjAtdmEudyooMS4wLXZjLncpKTtcbiAgICAgICAgbGluZWdsb3cgKz0gc21vb3Roc3RlcCggMC40LCAxLjAsICAgICAgdXYueSogICAgICB1di54ICkqKDEuMC12Yi54KigxLjAtdmQueCkpO1xuICAgICAgICBsaW5lZ2xvdyArPSBzbW9vdGhzdGVwKCAwLjQsIDEuMCwgICAgICB1di55KiAoMS4wLXV2LngpKSooMS4wLXZiLnkqKDEuMC12ZC55KSk7XG4gICAgICAgIGxpbmVnbG93ICs9IHNtb290aHN0ZXAoIDAuNCwgMS4wLCAoMS4wLXV2LnkpKigxLjAtdXYueCkpKigxLjAtdmIueiooMS4wLXZkLnopKTtcbiAgICAgICAgbGluZWdsb3cgKz0gc21vb3Roc3RlcCggMC40LCAxLjAsICgxLjAtdXYueSkqICAgICB1di54ICkqKDEuMC12Yi53KigxLjAtdmQudykpO1xuXHRcdFxuICAgICAgICB2ZWMzIGxpbkNvbCA9IDIuMCp2ZWMzKDUuMCwwLjYsMC4wKTtcbiAgICAgICAgbGluQ29sICo9ICgwLjUrMC41Km9jYykqMC41O1xuICAgICAgICBsaW4gKz0gbGluZWdsb3cqbGluQ29sO1xuXHRcdFxuICAgICAgICBjb2wgPSBjb2wqbGluO1xuICAgICAgICBjb2wgKz0gOC4wKmxpbkNvbCp2ZWMzKDEuMCwyLjAsMy4wKSooMS4wLXd3dyk7Ly8qKDAuNSsxLjAqc2hhKTtcbiAgICAgICAgY29sICs9IDAuMSpsaW5lZ2xvdypsaW5Db2w7XG4gICAgICAgIGNvbCAqPSBtaW4oMC4xLGV4cCggLTAuMDcqdCApKTtcblx0XG4gICAgICAgIC8vIGJsZW5kIHRvIGJsYWNrICYgd2hpdGVcdFx0XG4gICAgICAgIHZlYzMgY29sMiA9IHZlYzMoMS4zKSooMC41KzAuNSpub3IueSkqb2NjKmV4cCggLTAuMDQqdCApOztcbiAgICAgICAgZmxvYXQgbWkgPSBjb3MoLTAuNyswLjUqaVRpbWUpO1xuICAgICAgICBtaSA9IHNtb290aHN0ZXAoIDAuNzAsIDAuNzUsIG1pICk7XG4gICAgICAgIGNvbCA9IG1peCggY29sLCBjb2wyLCBtaSApO1xuXHR9XG5cblx0Ly8gZ2FtbWFcdFxuXHRjb2wgPSBwb3coIGNvbCwgdmVjMygwLjQ1KSApO1xuXG4gICAgcmV0dXJuIGNvbDtcbn1cblxudm9pZCBtYWluSW1hZ2UoIG91dCB2ZWM0IGZyYWdDb2xvciwgaW4gdmVjMiBmcmFnQ29vcmQgKVxue1xuICAgIC8vIGlucHV0c1x0XG4gICAgdmVjMiBwID0gKDIuMCpmcmFnQ29vcmQtaVJlc29sdXRpb24ueHkpL2lSZXNvbHV0aW9uLnk7XG4gICAgdmVjMiBtbyA9IGlNb3VzZS54eSAvIGlSZXNvbHV0aW9uLnh5O1xuICAgIGlmKCBpTW91c2Uuejw9MC4wMDAwMSApIG1vPXZlYzIoMC4wKTtcblx0ZmxvYXQgdGltZSA9IDIuMCppVGltZSArIDUwLjAqbW8ueDtcbiAgICBcbiAgICAvLyBjYW1lcmFcblx0ZmxvYXQgY3IgPSAwLjIqY29zKDAuMSppVGltZSk7XG5cdHZlYzMgcm8gPSBwYXRoKCB0aW1lKzAuMCwgMS4wICk7XG5cdHZlYzMgdGEgPSBwYXRoKCB0aW1lKzUuMCwgMS4wICkgLSB2ZWMzKDAuMCw2LjAsMC4wKTtcblx0Z3JvID0gcm87XG5cbiAgICBtYXQzIGNhbSA9IHNldENhbWVyYSggcm8sIHRhLCBjciApO1xuXHRcblx0Ly8gYnVpbGQgcmF5XG4gICAgZmxvYXQgcjIgPSBwLngqcC54KjAuMzIgKyBwLnkqcC55O1xuICAgIHAgKj0gKDcuMC1zcXJ0KDM3LjUtMTEuNSpyMikpLyhyMisxLjApO1xuICAgIHZlYzMgcmQgPSBub3JtYWxpemUoIGNhbSAqIHZlYzMocC54eSwtMi41KSApO1xuXG4gICAgdmVjMyBjb2wgPSByZW5kZXIoIHJvLCByZCApO1xuICAgIFxuXHQvLyB2aWduZXR0aW5nXHRcblx0dmVjMiBxID0gZnJhZ0Nvb3JkIC8gaVJlc29sdXRpb24ueHk7XG5cdGNvbCAqPSAwLjUgKyAwLjUqcG93KCAxNi4wKnEueCpxLnkqKDEuMC1xLngpKigxLjAtcS55KSwgMC4xICk7XG5cdFxuXHRmcmFnQ29sb3IgPSB2ZWM0KCBjb2wsIDEuMCApO1xufVxuXG52b2lkIG1haW5WUiggb3V0IHZlYzQgZnJhZ0NvbG9yLCBpbiB2ZWMyIGZyYWdDb29yZCwgaW4gdmVjMyBmcmFnUmF5T3JpLCBpbiB2ZWMzIGZyYWdSYXlEaXIgKVxue1xuXHRmbG9hdCB0aW1lID0gMS4wKmlUaW1lO1xuXG4gICAgZmxvYXQgY3IgPSAwLjA7XG5cdHZlYzMgcm8gPSBwYXRoKCB0aW1lKzAuMCwgMC4wICkgKyB2ZWMzKDAuMCwwLjcsMC4wKTtcblx0dmVjMyB0YSA9IHBhdGgoIHRpbWUrMi41LCAwLjAgKSArIHZlYzMoMC4wLDAuNywwLjApO1xuXG4gICAgbWF0MyBjYW0gPSBzZXRDYW1lcmEoIHJvLCB0YSwgY3IgKTtcblxuICAgIHZlYzMgY29sID0gcmVuZGVyKCBybyArIGNhbSpmcmFnUmF5T3JpLCBjYW0qZnJhZ1JheURpciApO1xuICAgIFxuICAgIGZyYWdDb2xvciA9IHZlYzQoIGNvbCwgMS4wICk7XG59XG5gOyAiXSwibmFtZXMiOlsidmVydGV4U2hhZGVyIiwiZnJhZ21lbnRTaGFkZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/shaders/dirty-notch.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/ShaderCanvas.tsx":
/*!*************************************!*\
  !*** ./components/ShaderCanvas.tsx ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ShaderCanvas)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.2_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.2_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _app_shaders_dirty_notch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../app/shaders/dirty-notch */ \"(app-pages-browser)/./app/shaders/dirty-notch.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction ShaderCanvas(param) {\n    let { shaderId, width, height } = param;\n    _s();\n    var _s1 = $RefreshSig$();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const frameRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const startTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(Date.now());\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ShaderCanvas.useEffect\": _s1(()=>{\n            _s1();\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const gl = canvas.getContext('webgl2');\n            if (!gl) {\n                console.error('WebGL2 not supported');\n                return;\n            }\n            // Create shader program\n            const program = createShaderProgram(gl, _app_shaders_dirty_notch__WEBPACK_IMPORTED_MODULE_2__.vertexShader, _app_shaders_dirty_notch__WEBPACK_IMPORTED_MODULE_2__.fragmentShader);\n            if (!program) return;\n            gl.useProgram(program);\n            // Set up buffers\n            const positions = new Float32Array([\n                -1.0,\n                -1.0,\n                1.0,\n                -1.0,\n                -1.0,\n                1.0,\n                1.0,\n                1.0\n            ]);\n            const positionBuffer = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n            // Set up attributes and uniforms\n            const positionLocation = gl.getAttribLocation(program, 'position');\n            gl.enableVertexAttribArray(positionLocation);\n            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n            const resolutionLocation = gl.getUniformLocation(program, 'iResolution');\n            const timeLocation = gl.getUniformLocation(program, 'iTime');\n            const mouseLocation = gl.getUniformLocation(program, 'iMouse');\n            // Create and set up noise texture\n            const noiseTexture = createNoiseTexture(gl);\n            const channel0Location = gl.getUniformLocation(program, 'iChannel0');\n            gl.uniform1i(channel0Location, 0);\n            // Animation frame\n            function render() {\n                const time = (Date.now() - startTimeRef.current) / 1000;\n                gl.viewport(0, 0, canvas.width, canvas.height);\n                gl.uniform2f(resolutionLocation, canvas.width, canvas.height);\n                gl.uniform1f(timeLocation, time);\n                gl.uniform4f(mouseLocation, 0, 0, 0, 0); // Update with actual mouse position if needed\n                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n                frameRef.current = requestAnimationFrame(render);\n            }\n            render();\n            // Cleanup\n            return ({\n                \"ShaderCanvas.useEffect\": ()=>{\n                    if (frameRef.current) {\n                        cancelAnimationFrame(frameRef.current);\n                    }\n                    gl.deleteProgram(program);\n                    gl.deleteBuffer(positionBuffer);\n                }\n            })[\"ShaderCanvas.useEffect\"];\n        }, \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", true)\n    }[\"ShaderCanvas.useEffect\"], [\n        shaderId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        width: width,\n        height: height,\n        style: {\n            width: '100%',\n            height: 'auto'\n        }\n    }, void 0, false, {\n        fileName: \"/Users/jeremyj/Documents/source/repos/shaders/components/ShaderCanvas.tsx\",\n        lineNumber: 85,\n        columnNumber: 5\n    }, this);\n}\n_s(ShaderCanvas, \"3i19xcW9wU7f8spHXNU4YXO3Ey8=\");\n_c = ShaderCanvas;\nfunction createShaderProgram(gl, vertexSource, fragmentSource) {\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    if (!vertexShader) return null;\n    gl.shaderSource(vertexShader, vertexSource);\n    gl.compileShader(vertexShader);\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    if (!fragmentShader) return null;\n    gl.shaderSource(fragmentShader, fragmentSource);\n    gl.compileShader(fragmentShader);\n    const program = gl.createProgram();\n    if (!program) return null;\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    return program;\n}\nfunction createNoiseTexture(gl) {\n    const texture = gl.createTexture();\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    // Create noise texture data\n    const size = 256;\n    const data = new Uint8Array(size * size * 4);\n    for(let i = 0; i < data.length; i += 4){\n        const value = Math.random() * 255;\n        data[i] = value;\n        data[i + 1] = value;\n        data[i + 2] = value;\n        data[i + 3] = 255;\n    }\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.generateMipmap(gl.TEXTURE_2D);\n    return texture;\n}\nvar _c;\n$RefreshReg$(_c, \"ShaderCanvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvU2hhZGVyQ2FudmFzLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBRTBDO0FBQ2dDO0FBUTNELFNBQVNJLGFBQWEsS0FBOEM7UUFBOUMsRUFBRUMsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBcUIsR0FBOUM7OztJQUNuQyxNQUFNQyxZQUFZUCw2Q0FBTUEsQ0FBb0I7SUFDNUMsTUFBTVEsV0FBV1IsNkNBQU1BO0lBQ3ZCLE1BQU1TLGVBQWVULDZDQUFNQSxDQUFTVSxLQUFLQyxHQUFHO0lBRTVDWixnREFBU0E7c0NBQUM7O1lBQ1IsTUFBTWEsU0FBU0wsVUFBVU0sT0FBTztZQUNoQyxJQUFJLENBQUNELFFBQVE7WUFFYixNQUFNRSxLQUFLRixPQUFPRyxVQUFVLENBQUM7WUFDN0IsSUFBSSxDQUFDRCxJQUFJO2dCQUNQRSxRQUFRQyxLQUFLLENBQUM7Z0JBQ2Q7WUFDRjtZQUVBLHdCQUF3QjtZQUN4QixNQUFNQyxVQUFVQyxvQkFBb0JMLElBQUliLGtFQUFZQSxFQUFFQyxvRUFBY0E7WUFDcEUsSUFBSSxDQUFDZ0IsU0FBUztZQUVkSixHQUFHTSxVQUFVLENBQUNGO1lBRWQsaUJBQWlCO1lBQ2pCLE1BQU1HLFlBQVksSUFBSUMsYUFBYTtnQkFDakMsQ0FBQztnQkFBSyxDQUFDO2dCQUNOO2dCQUFLLENBQUM7Z0JBQ1AsQ0FBQztnQkFBTTtnQkFDTjtnQkFBTTthQUNSO1lBRUQsTUFBTUMsaUJBQWlCVCxHQUFHVSxZQUFZO1lBQ3RDVixHQUFHVyxVQUFVLENBQUNYLEdBQUdZLFlBQVksRUFBRUg7WUFDL0JULEdBQUdhLFVBQVUsQ0FBQ2IsR0FBR1ksWUFBWSxFQUFFTCxXQUFXUCxHQUFHYyxXQUFXO1lBRXhELGlDQUFpQztZQUNqQyxNQUFNQyxtQkFBbUJmLEdBQUdnQixpQkFBaUIsQ0FBQ1osU0FBUztZQUN2REosR0FBR2lCLHVCQUF1QixDQUFDRjtZQUMzQmYsR0FBR2tCLG1CQUFtQixD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QUFLO1FBQzlCTixJQUFJLENBQUNFLEVBQUUsR0FBR0U7UUFDVkosSUFBSSxDQUFDRSxJQUFJLEVBQUUsR0FBR0U7UUFDZEosSUFBSSxDQUFDRSxJQUFJLEVBQUUsR0FBR0U7UUFDZEosSUFBSSxDQUFDRSxJQUFJLEVBQUUsR0FBRztJQUNoQjtJQUVBN0QsR0FBR2tFLFVBQVUsQ0FDWGxFLEdBQUd5RCxVQUFVLEVBQ2IsR0FDQXpELEdBQUdtRSxJQUFJLEVBQ1BULE1BQ0FBLE1BQ0EsR0FDQTFELEdBQUdtRSxJQUFJLEVBQ1BuRSxHQUFHb0UsYUFBYSxFQUNoQlQ7SUFHRjNELEdBQUdxRSxhQUFhLENBQUNyRSxHQUFHeUQsVUFBVSxFQUFFekQsR0FBR3NFLGtCQUFrQixFQUFFdEUsR0FBR3VFLG9CQUFvQjtJQUM5RXZFLEdBQUdxRSxhQUFhLENBQUNyRSxHQUFHeUQsVUFBVSxFQUFFekQsR0FBR3dFLGtCQUFrQixFQUFFeEUsR0FBR3lFLE1BQU07SUFDaEV6RSxHQUFHMEUsY0FBYyxDQUFDMUUsR0FBR3lELFVBQVU7SUFFL0IsT0FBT0w7QUFDVCIsInNvdXJjZXMiOlsiL1VzZXJzL2plcmVteWovRG9jdW1lbnRzL3NvdXJjZS9yZXBvcy9zaGFkZXJzL2NvbXBvbmVudHMvU2hhZGVyQ2FudmFzLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlciB9IGZyb20gJy4uL2FwcC9zaGFkZXJzL2RpcnR5LW5vdGNoJztcblxuaW50ZXJmYWNlIFNoYWRlckNhbnZhc1Byb3BzIHtcbiAgc2hhZGVySWQ6IHN0cmluZztcbiAgd2lkdGg6IG51bWJlcjtcbiAgaGVpZ2h0OiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNoYWRlckNhbnZhcyh7IHNoYWRlcklkLCB3aWR0aCwgaGVpZ2h0IH06IFNoYWRlckNhbnZhc1Byb3BzKSB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IGZyYW1lUmVmID0gdXNlUmVmPG51bWJlcj4oKTtcbiAgY29uc3Qgc3RhcnRUaW1lUmVmID0gdXNlUmVmPG51bWJlcj4oRGF0ZS5ub3coKSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xuXG4gICAgY29uc3QgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJyk7XG4gICAgaWYgKCFnbCkge1xuICAgICAgY29uc29sZS5lcnJvcignV2ViR0wyIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgc2hhZGVyIHByb2dyYW1cbiAgICBjb25zdCBwcm9ncmFtID0gY3JlYXRlU2hhZGVyUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcik7XG4gICAgaWYgKCFwcm9ncmFtKSByZXR1cm47XG5cbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgLy8gU2V0IHVwIGJ1ZmZlcnNcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgIC0xLjAsIC0xLjAsXG4gICAgICAgMS4wLCAtMS4wLFxuICAgICAgLTEuMCwgIDEuMCxcbiAgICAgICAxLjAsICAxLjAsXG4gICAgXSk7XG5cbiAgICBjb25zdCBwb3NpdGlvbkJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbkJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9ucywgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgLy8gU2V0IHVwIGF0dHJpYnV0ZXMgYW5kIHVuaWZvcm1zXG4gICAgY29uc3QgcG9zaXRpb25Mb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdwb3NpdGlvbicpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24pO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblxuICAgIGNvbnN0IHJlc29sdXRpb25Mb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnaVJlc29sdXRpb24nKTtcbiAgICBjb25zdCB0aW1lTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ2lUaW1lJyk7XG4gICAgY29uc3QgbW91c2VMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnaU1vdXNlJyk7XG5cbiAgICAvLyBDcmVhdGUgYW5kIHNldCB1cCBub2lzZSB0ZXh0dXJlXG4gICAgY29uc3Qgbm9pc2VUZXh0dXJlID0gY3JlYXRlTm9pc2VUZXh0dXJlKGdsKTtcbiAgICBjb25zdCBjaGFubmVsMExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdpQ2hhbm5lbDAnKTtcbiAgICBnbC51bmlmb3JtMWkoY2hhbm5lbDBMb2NhdGlvbiwgMCk7XG5cbiAgICAvLyBBbmltYXRpb24gZnJhbWVcbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICBjb25zdCB0aW1lID0gKERhdGUubm93KCkgLSBzdGFydFRpbWVSZWYuY3VycmVudCkgLyAxMDAwO1xuICAgICAgXG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIGdsLnVuaWZvcm0xZih0aW1lTG9jYXRpb24sIHRpbWUpO1xuICAgICAgZ2wudW5pZm9ybTRmKG1vdXNlTG9jYXRpb24sIDAsIDAsIDAsIDApOyAvLyBVcGRhdGUgd2l0aCBhY3R1YWwgbW91c2UgcG9zaXRpb24gaWYgbmVlZGVkXG5cbiAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgICAgZnJhbWVSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xuICAgIH1cblxuICAgIHJlbmRlcigpO1xuXG4gICAgLy8gQ2xlYW51cFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoZnJhbWVSZWYuY3VycmVudCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZVJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICBnbC5kZWxldGVCdWZmZXIocG9zaXRpb25CdWZmZXIpO1xuICAgIH07XG4gIH0sIFtzaGFkZXJJZF0pO1xuXG4gIHJldHVybiAoXG4gICAgPGNhbnZhc1xuICAgICAgcmVmPXtjYW52YXNSZWZ9XG4gICAgICB3aWR0aD17d2lkdGh9XG4gICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgIHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJ2F1dG8nIH19XG4gICAgLz5cbiAgKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2hhZGVyUHJvZ3JhbShnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCwgdmVydGV4U291cmNlOiBzdHJpbmcsIGZyYWdtZW50U291cmNlOiBzdHJpbmcpIHtcbiAgY29uc3QgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xuICBpZiAoIXZlcnRleFNoYWRlcikgcmV0dXJuIG51bGw7XG4gIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNvdXJjZSk7XG4gIGdsLmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyKTtcblxuICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICBpZiAoIWZyYWdtZW50U2hhZGVyKSByZXR1cm4gbnVsbDtcbiAgZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNvdXJjZSk7XG4gIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuXG4gIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gIGlmICghcHJvZ3JhbSkgcmV0dXJuIG51bGw7XG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICByZXR1cm4gcHJvZ3JhbTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9pc2VUZXh0dXJlKGdsOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KSB7XG4gIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuICAvLyBDcmVhdGUgbm9pc2UgdGV4dHVyZSBkYXRhXG4gIGNvbnN0IHNpemUgPSAyNTY7XG4gIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShzaXplICogc2l6ZSAqIDQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IE1hdGgucmFuZG9tKCkgKiAyNTU7XG4gICAgZGF0YVtpXSA9IHZhbHVlO1xuICAgIGRhdGFbaSArIDFdID0gdmFsdWU7XG4gICAgZGF0YVtpICsgMl0gPSB2YWx1ZTtcbiAgICBkYXRhW2kgKyAzXSA9IDI1NTtcbiAgfVxuXG4gIGdsLnRleEltYWdlMkQoXG4gICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAwLFxuICAgIGdsLlJHQkEsXG4gICAgc2l6ZSxcbiAgICBzaXplLFxuICAgIDAsXG4gICAgZ2wuUkdCQSxcbiAgICBnbC5VTlNJR05FRF9CWVRFLFxuICAgIGRhdGFcbiAgKTtcblxuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSX01JUE1BUF9MSU5FQVIpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG5cbiAgcmV0dXJuIHRleHR1cmU7XG59ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciIsIlNoYWRlckNhbnZhcyIsInNoYWRlcklkIiwid2lkdGgiLCJoZWlnaHQiLCJjYW52YXNSZWYiLCJmcmFtZVJlZiIsInN0YXJ0VGltZVJlZiIsIkRhdGUiLCJub3ciLCJjYW52YXMiLCJjdXJyZW50IiwiZ2wiLCJnZXRDb250ZXh0IiwiY29uc29sZSIsImVycm9yIiwicHJvZ3JhbSIsImNyZWF0ZVNoYWRlclByb2dyYW0iLCJ1c2VQcm9ncmFtIiwicG9zaXRpb25zIiwiRmxvYXQzMkFycmF5IiwicG9zaXRpb25CdWZmZXIiLCJjcmVhdGVCdWZmZXIiLCJiaW5kQnVmZmVyIiwiQVJSQVlfQlVGRkVSIiwiYnVmZmVyRGF0YSIsIlNUQVRJQ19EUkFXIiwicG9zaXRpb25Mb2NhdGlvbiIsImdldEF0dHJpYkxvY2F0aW9uIiwiZW5hYmxlVmVydGV4QXR0cmliQXJyYXkiLCJ2ZXJ0ZXhBdHRyaWJQb2ludGVyIiwiRkxPQVQiLCJyZXNvbHV0aW9uTG9jYXRpb24iLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJ0aW1lTG9jYXRpb24iLCJtb3VzZUxvY2F0aW9uIiwibm9pc2VUZXh0dXJlIiwiY3JlYXRlTm9pc2VUZXh0dXJlIiwiY2hhbm5lbDBMb2NhdGlvbiIsInVuaWZvcm0xaSIsInJlbmRlciIsInRpbWUiLCJ2aWV3cG9ydCIsInVuaWZvcm0yZiIsInVuaWZvcm0xZiIsInVuaWZvcm00ZiIsImRyYXdBcnJheXMiLCJUUklBTkdMRV9TVFJJUCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiZGVsZXRlUHJvZ3JhbSIsImRlbGV0ZUJ1ZmZlciIsInJlZiIsInN0eWxlIiwidmVydGV4U291cmNlIiwiZnJhZ21lbnRTb3VyY2UiLCJjcmVhdGVTaGFkZXIiLCJWRVJURVhfU0hBREVSIiwic2hhZGVyU291cmNlIiwiY29tcGlsZVNoYWRlciIsIkZSQUdNRU5UX1NIQURFUiIsImNyZWF0ZVByb2dyYW0iLCJhdHRhY2hTaGFkZXIiLCJsaW5rUHJvZ3JhbSIsInRleHR1cmUiLCJjcmVhdGVUZXh0dXJlIiwiYWN0aXZlVGV4dHVyZSIsIlRFWFRVUkUwIiwiYmluZFRleHR1cmUiLCJURVhUVVJFXzJEIiwic2l6ZSIsImRhdGEiLCJVaW50OEFycmF5IiwiaSIsImxlbmd0aCIsInZhbHVlIiwiTWF0aCIsInJhbmRvbSIsInRleEltYWdlMkQiLCJSR0JBIiwiVU5TSUdORURfQllURSIsInRleFBhcmFtZXRlcmkiLCJURVhUVVJFX01JTl9GSUxURVIiLCJMSU5FQVJfTUlQTUFQX0xJTkVBUiIsIlRFWFRVUkVfTUFHX0ZJTFRFUiIsIkxJTkVBUiIsImdlbmVyYXRlTWlwbWFwIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ShaderCanvas.tsx\n"));

/***/ })

});