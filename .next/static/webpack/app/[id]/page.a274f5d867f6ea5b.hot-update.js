"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/[id]/page",{

/***/ "(app-pages-browser)/./app/shaders/seascape.ts":
/*!*********************************!*\
  !*** ./app/shaders/seascape.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fragmentShader: () => (/* binding */ fragmentShader),\n/* harmony export */   vertexShader: () => (/* binding */ vertexShader)\n/* harmony export */ });\nconst vertexShader = \"#version 300 es\\n  in vec4 position;\\n  void main() {\\n    gl_Position = position;\\n  }\\n\";\nconst fragmentShader = \"#version 300 es\\n  precision highp float;\\n  uniform vec2 iResolution;\\n  uniform float iTime;\\n  out vec4 fragColor;\\n\\n  const int NUM_STEPS = 8;\\n  const float PI = 3.141592;\\n  const float EPSILON = 1e-3;\\n\\n  // sea\\n  const int ITER_GEOMETRY = 3;\\n  const int ITER_FRAGMENT = 5;\\n  const float SEA_HEIGHT = 0.6;\\n  const float SEA_CHOPPY = 4.0;\\n  const float SEA_SPEED = 0.8;\\n  const float SEA_FREQ = 0.16;\\n  const vec3 SEA_BASE = vec3(0.1,0.19,0.22);\\n  const vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\\n\\n  mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\\n\\n  // Noise functions from Inigo Quilez\\n  float hash( vec2 p ) {\\n    float h = dot(p,vec2(127.1,311.7));\t\\n    return fract(sin(h)*43758.5453123);\\n  }\\n\\n  float noise( in vec2 p ) {\\n    vec2 i = floor(p);\\n    vec2 f = fract(p);\t\\n    vec2 u = f*f*(3.0-2.0*f);\\n    return -1.0+2.0*mix(\\n      mix(hash(i + vec2(0.0,0.0)), hash(i + vec2(1.0,0.0)), u.x),\\n      mix(hash(i + vec2(0.0,1.0)), hash(i + vec2(1.0,1.0)), u.x), \\n      u.y\\n    );\\n  }\\n\\n  float sea_octave(vec2 uv, float choppy) {\\n    uv += noise(uv);        \\n    vec2 wv = 1.0-abs(sin(uv));\\n    vec2 swv = abs(cos(uv));    \\n    wv = mix(wv,swv,wv);\\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\\n  }\\n\\n  float map(vec3 p) {\\n    float freq = SEA_FREQ;\\n    float amp = SEA_HEIGHT;\\n    float choppy = SEA_CHOPPY;\\n    vec2 uv = p.xz; \\n    uv.x *= 0.75;\\n    float SEA_TIME = iTime * SEA_SPEED;\\n    \\n    float d, h = 0.0;    \\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \\n      d = sea_octave((uv+SEA_TIME)*freq,choppy);\\n      d += sea_octave((uv-SEA_TIME)*freq,choppy);\\n      h += d * amp;        \\n      uv *= octave_m; \\n      freq *= 1.9; \\n      amp *= 0.22;\\n      choppy = mix(choppy,1.0,0.2);\\n    }\\n    return p.y - h;\\n  }\\n\\n  void mainImage(out vec4 fragColor, in vec2 fragCoord) {\\n    vec2 uv = fragCoord.xy / iResolution.xy;\\n    uv = uv * 2.0 - 1.0;\\n    uv.x *= iResolution.x/iResolution.y;    \\n    float time = iTime * 0.3;\\n        \\n    // ray\\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \\n    vec3 ori = vec3(0.0,3.5,time*5.0);\\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); \\n    dir.z += length(uv) * 0.15;\\n    dir = normalize(dir);\\n    \\n    // tracing\\n    vec3 p;\\n    float tm = 0.0;\\n    float tx = 0.0;    \\n    if (dir.y > 0.0) {\\n      p = vec3(0.0);\\n    }\\n    else {\\n      float hm = map(ori + dir * tm);    \\n      p = ori + dir * tm;\\n    }\\n    \\n    // color\\n    vec3 col = mix(\\n      SEA_BASE,\\n      SEA_WATER_COLOR,\\n      clamp(length(p.xz)/100.0,0.0,1.0)\\n    );    \\n    \\n    // post\\n    fragColor = vec4(pow(col,vec3(0.75)), 1.0);\\n  }\\n\\n  void main() {\\n    mainImage(fragColor, gl_FragCoord.xy);\\n  }\\n\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zaGFkZXJzL3NlYXNjYXBlLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU8sTUFBTUEsZUFBZ0IsNEZBSzNCO0FBRUssTUFBTUMsaUJBQWtCLDZxRkEyRzdCIiwic291cmNlcyI6WyIvVXNlcnMvamVyZW15ai9Eb2N1bWVudHMvc291cmNlL3JlcG9zL3NoYWRlcnMvYXBwL3NoYWRlcnMvc2Vhc2NhcGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnRleFNoYWRlciA9IGAjdmVyc2lvbiAzMDAgZXNcbiAgaW4gdmVjNCBwb3NpdGlvbjtcbiAgdm9pZCBtYWluKCkge1xuICAgIGdsX1Bvc2l0aW9uID0gcG9zaXRpb247XG4gIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBmcmFnbWVudFNoYWRlciA9IGAjdmVyc2lvbiAzMDAgZXNcbiAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICB1bmlmb3JtIHZlYzIgaVJlc29sdXRpb247XG4gIHVuaWZvcm0gZmxvYXQgaVRpbWU7XG4gIG91dCB2ZWM0IGZyYWdDb2xvcjtcblxuICBjb25zdCBpbnQgTlVNX1NURVBTID0gODtcbiAgY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjtcbiAgY29uc3QgZmxvYXQgRVBTSUxPTiA9IDFlLTM7XG5cbiAgLy8gc2VhXG4gIGNvbnN0IGludCBJVEVSX0dFT01FVFJZID0gMztcbiAgY29uc3QgaW50IElURVJfRlJBR01FTlQgPSA1O1xuICBjb25zdCBmbG9hdCBTRUFfSEVJR0hUID0gMC42O1xuICBjb25zdCBmbG9hdCBTRUFfQ0hPUFBZID0gNC4wO1xuICBjb25zdCBmbG9hdCBTRUFfU1BFRUQgPSAwLjg7XG4gIGNvbnN0IGZsb2F0IFNFQV9GUkVRID0gMC4xNjtcbiAgY29uc3QgdmVjMyBTRUFfQkFTRSA9IHZlYzMoMC4xLDAuMTksMC4yMik7XG4gIGNvbnN0IHZlYzMgU0VBX1dBVEVSX0NPTE9SID0gdmVjMygwLjgsMC45LDAuNik7XG5cbiAgbWF0MiBvY3RhdmVfbSA9IG1hdDIoMS42LDEuMiwtMS4yLDEuNik7XG5cbiAgLy8gTm9pc2UgZnVuY3Rpb25zIGZyb20gSW5pZ28gUXVpbGV6XG4gIGZsb2F0IGhhc2goIHZlYzIgcCApIHtcbiAgICBmbG9hdCBoID0gZG90KHAsdmVjMigxMjcuMSwzMTEuNykpO1x0XG4gICAgcmV0dXJuIGZyYWN0KHNpbihoKSo0Mzc1OC41NDUzMTIzKTtcbiAgfVxuXG4gIGZsb2F0IG5vaXNlKCBpbiB2ZWMyIHAgKSB7XG4gICAgdmVjMiBpID0gZmxvb3IocCk7XG4gICAgdmVjMiBmID0gZnJhY3QocCk7XHRcbiAgICB2ZWMyIHUgPSBmKmYqKDMuMC0yLjAqZik7XG4gICAgcmV0dXJuIC0xLjArMi4wKm1peChcbiAgICAgIG1peChoYXNoKGkgKyB2ZWMyKDAuMCwwLjApKSwgaGFzaChpICsgdmVjMigxLjAsMC4wKSksIHUueCksXG4gICAgICBtaXgoaGFzaChpICsgdmVjMigwLjAsMS4wKSksIGhhc2goaSArIHZlYzIoMS4wLDEuMCkpLCB1LngpLCBcbiAgICAgIHUueVxuICAgICk7XG4gIH1cblxuICBmbG9hdCBzZWFfb2N0YXZlKHZlYzIgdXYsIGZsb2F0IGNob3BweSkge1xuICAgIHV2ICs9IG5vaXNlKHV2KTsgICAgICAgIFxuICAgIHZlYzIgd3YgPSAxLjAtYWJzKHNpbih1dikpO1xuICAgIHZlYzIgc3d2ID0gYWJzKGNvcyh1dikpOyAgICBcbiAgICB3diA9IG1peCh3dixzd3Ysd3YpO1xuICAgIHJldHVybiBwb3coMS4wLXBvdyh3di54ICogd3YueSwwLjY1KSxjaG9wcHkpO1xuICB9XG5cbiAgZmxvYXQgbWFwKHZlYzMgcCkge1xuICAgIGZsb2F0IGZyZXEgPSBTRUFfRlJFUTtcbiAgICBmbG9hdCBhbXAgPSBTRUFfSEVJR0hUO1xuICAgIGZsb2F0IGNob3BweSA9IFNFQV9DSE9QUFk7XG4gICAgdmVjMiB1diA9IHAueHo7IFxuICAgIHV2LnggKj0gMC43NTtcbiAgICBmbG9hdCBTRUFfVElNRSA9IGlUaW1lICogU0VBX1NQRUVEO1xuICAgIFxuICAgIGZsb2F0IGQsIGggPSAwLjA7ICAgIFxuICAgIGZvcihpbnQgaSA9IDA7IGkgPCBJVEVSX0dFT01FVFJZOyBpKyspIHsgICAgICAgIFxuICAgICAgZCA9IHNlYV9vY3RhdmUoKHV2K1NFQV9USU1FKSpmcmVxLGNob3BweSk7XG4gICAgICBkICs9IHNlYV9vY3RhdmUoKHV2LVNFQV9USU1FKSpmcmVxLGNob3BweSk7XG4gICAgICBoICs9IGQgKiBhbXA7ICAgICAgICBcbiAgICAgIHV2ICo9IG9jdGF2ZV9tOyBcbiAgICAgIGZyZXEgKj0gMS45OyBcbiAgICAgIGFtcCAqPSAwLjIyO1xuICAgICAgY2hvcHB5ID0gbWl4KGNob3BweSwxLjAsMC4yKTtcbiAgICB9XG4gICAgcmV0dXJuIHAueSAtIGg7XG4gIH1cblxuICB2b2lkIG1haW5JbWFnZShvdXQgdmVjNCBmcmFnQ29sb3IsIGluIHZlYzIgZnJhZ0Nvb3JkKSB7XG4gICAgdmVjMiB1diA9IGZyYWdDb29yZC54eSAvIGlSZXNvbHV0aW9uLnh5O1xuICAgIHV2ID0gdXYgKiAyLjAgLSAxLjA7XG4gICAgdXYueCAqPSBpUmVzb2x1dGlvbi54L2lSZXNvbHV0aW9uLnk7ICAgIFxuICAgIGZsb2F0IHRpbWUgPSBpVGltZSAqIDAuMztcbiAgICAgICAgXG4gICAgLy8gcmF5XG4gICAgdmVjMyBhbmcgPSB2ZWMzKHNpbih0aW1lKjMuMCkqMC4xLHNpbih0aW1lKSowLjIrMC4zLHRpbWUpOyAgICBcbiAgICB2ZWMzIG9yaSA9IHZlYzMoMC4wLDMuNSx0aW1lKjUuMCk7XG4gICAgdmVjMyBkaXIgPSBub3JtYWxpemUodmVjMyh1di54eSwtMi4wKSk7IFxuICAgIGRpci56ICs9IGxlbmd0aCh1dikgKiAwLjE1O1xuICAgIGRpciA9IG5vcm1hbGl6ZShkaXIpO1xuICAgIFxuICAgIC8vIHRyYWNpbmdcbiAgICB2ZWMzIHA7XG4gICAgZmxvYXQgdG0gPSAwLjA7XG4gICAgZmxvYXQgdHggPSAwLjA7ICAgIFxuICAgIGlmIChkaXIueSA+IDAuMCkge1xuICAgICAgcCA9IHZlYzMoMC4wKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmbG9hdCBobSA9IG1hcChvcmkgKyBkaXIgKiB0bSk7ICAgIFxuICAgICAgcCA9IG9yaSArIGRpciAqIHRtO1xuICAgIH1cbiAgICBcbiAgICAvLyBjb2xvclxuICAgIHZlYzMgY29sID0gbWl4KFxuICAgICAgU0VBX0JBU0UsXG4gICAgICBTRUFfV0FURVJfQ09MT1IsXG4gICAgICBjbGFtcChsZW5ndGgocC54eikvMTAwLjAsMC4wLDEuMClcbiAgICApOyAgICBcbiAgICBcbiAgICAvLyBwb3N0XG4gICAgZnJhZ0NvbG9yID0gdmVjNChwb3coY29sLHZlYzMoMC43NSkpLCAxLjApO1xuICB9XG5cbiAgdm9pZCBtYWluKCkge1xuICAgIG1haW5JbWFnZShmcmFnQ29sb3IsIGdsX0ZyYWdDb29yZC54eSk7XG4gIH1cbmA7ICJdLCJuYW1lcyI6WyJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/shaders/seascape.ts\n"));

/***/ })

});