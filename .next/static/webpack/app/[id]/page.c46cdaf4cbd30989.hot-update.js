"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/[id]/page",{

/***/ "(app-pages-browser)/./app/shaders/seascape.ts":
/*!*********************************!*\
  !*** ./app/shaders/seascape.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fragmentShader: () => (/* binding */ fragmentShader),\n/* harmony export */   vertexShader: () => (/* binding */ vertexShader)\n/* harmony export */ });\nconst vertexShader = \"\\n  attribute vec4 position;\\n  void main() {\\n    gl_Position = position;\\n  }\\n\";\nconst fragmentShader = \"#version 300 es\\n  precision highp float;\\n  uniform vec2 iResolution;\\n  uniform float iTime;\\n  out vec4 fragColor;\\n\\n  const int NUM_STEPS = 8;\\n  const float PI = 3.141592;\\n  const float EPSILON = 1e-3;\\n  float EPSILON_NRM = 0.1 / iResolution.x;\\n\\n  // sea\\n  const int ITER_GEOMETRY = 3;\\n  const int ITER_FRAGMENT = 5;\\n  const float SEA_HEIGHT = 0.6;\\n  const float SEA_CHOPPY = 4.0;\\n  const float SEA_SPEED = 0.8;\\n  const float SEA_FREQ = 0.16;\\n  const vec3 SEA_BASE = vec3(0.1,0.19,0.22);\\n  const vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\\n  float SEA_TIME = iTime * SEA_SPEED;\\n\\n  mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\\n\\n  float sea_octave(vec2 uv, float choppy) {\\n    uv += noise(uv);        \\n    vec2 wv = 1.0-abs(sin(uv));\\n    vec2 swv = abs(cos(uv));    \\n    wv = mix(wv,swv,wv);\\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\\n  }\\n\\n  float map(vec3 p) {\\n    float freq = SEA_FREQ;\\n    float amp = SEA_HEIGHT;\\n    float choppy = SEA_CHOPPY;\\n    vec2 uv = p.xz; uv.x *= 0.75;\\n    \\n    float d, h = 0.0;    \\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \\n      d = sea_octave((uv+SEA_TIME)*freq,choppy);\\n      d += sea_octave((uv-SEA_TIME)*freq,choppy);\\n      h += d * amp;        \\n      uv *= octave_m; freq *= 1.9; amp *= 0.22;\\n      choppy = mix(choppy,1.0,0.2);\\n    }\\n    return p.y - h;\\n  }\\n\\n  void mainImage(out vec4 fragColor, in vec2 fragCoord) {\\n    vec2 uv = fragCoord.xy / iResolution.xy;\\n    uv = uv * 2.0 - 1.0;\\n    uv.x *= iResolution.x/iResolution.y;    \\n    float time = iTime * 0.3;\\n        \\n    // ray\\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \\n    vec3 ori = vec3(0.0,3.5,time*5.0);\\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;\\n    dir = normalize(dir);\\n    \\n    // tracing\\n    vec3 p;\\n    float tm = 0.0;\\n    float tx = 0.0;    \\n    if (dir.y > 0.0) {\\n      p = vec3(0.0);\\n    }\\n    else {\\n      float hm = map(ori + dir * tm);    \\n      p = ori + dir * tm;\\n    }\\n    \\n    // color\\n    vec3 col = mix(\\n      SEA_BASE,\\n      SEA_WATER_COLOR,\\n      clamp(length(p.xz)/100.0,0.0,1.0)\\n    );    \\n    \\n    // post\\n    fragColor = vec4(pow(col,vec3(0.75)), 1.0);\\n  }\\n\\n  void main() {\\n    mainImage(fragColor, gl_FragCoord.xy);\\n  }\\n\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zaGFkZXJzL3NlYXNjYXBlLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU8sTUFBTUEsZUFBZ0Isb0ZBSzNCO0FBRUssTUFBTUMsaUJBQWtCLHN2RUF1RjdCIiwic291cmNlcyI6WyIvVXNlcnMvamVyZW15ai9Eb2N1bWVudHMvc291cmNlL3JlcG9zL3NoYWRlcnMvYXBwL3NoYWRlcnMvc2Vhc2NhcGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnRleFNoYWRlciA9IGBcbiAgYXR0cmlidXRlIHZlYzQgcG9zaXRpb247XG4gIHZvaWQgbWFpbigpIHtcbiAgICBnbF9Qb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB9XG5gO1xuXG5leHBvcnQgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBgI3ZlcnNpb24gMzAwIGVzXG4gIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgdW5pZm9ybSB2ZWMyIGlSZXNvbHV0aW9uO1xuICB1bmlmb3JtIGZsb2F0IGlUaW1lO1xuICBvdXQgdmVjNCBmcmFnQ29sb3I7XG5cbiAgY29uc3QgaW50IE5VTV9TVEVQUyA9IDg7XG4gIGNvbnN0IGZsb2F0IFBJID0gMy4xNDE1OTI7XG4gIGNvbnN0IGZsb2F0IEVQU0lMT04gPSAxZS0zO1xuICBmbG9hdCBFUFNJTE9OX05STSA9IDAuMSAvIGlSZXNvbHV0aW9uLng7XG5cbiAgLy8gc2VhXG4gIGNvbnN0IGludCBJVEVSX0dFT01FVFJZID0gMztcbiAgY29uc3QgaW50IElURVJfRlJBR01FTlQgPSA1O1xuICBjb25zdCBmbG9hdCBTRUFfSEVJR0hUID0gMC42O1xuICBjb25zdCBmbG9hdCBTRUFfQ0hPUFBZID0gNC4wO1xuICBjb25zdCBmbG9hdCBTRUFfU1BFRUQgPSAwLjg7XG4gIGNvbnN0IGZsb2F0IFNFQV9GUkVRID0gMC4xNjtcbiAgY29uc3QgdmVjMyBTRUFfQkFTRSA9IHZlYzMoMC4xLDAuMTksMC4yMik7XG4gIGNvbnN0IHZlYzMgU0VBX1dBVEVSX0NPTE9SID0gdmVjMygwLjgsMC45LDAuNik7XG4gIGZsb2F0IFNFQV9USU1FID0gaVRpbWUgKiBTRUFfU1BFRUQ7XG5cbiAgbWF0MiBvY3RhdmVfbSA9IG1hdDIoMS42LDEuMiwtMS4yLDEuNik7XG5cbiAgZmxvYXQgc2VhX29jdGF2ZSh2ZWMyIHV2LCBmbG9hdCBjaG9wcHkpIHtcbiAgICB1diArPSBub2lzZSh1dik7ICAgICAgICBcbiAgICB2ZWMyIHd2ID0gMS4wLWFicyhzaW4odXYpKTtcbiAgICB2ZWMyIHN3diA9IGFicyhjb3ModXYpKTsgICAgXG4gICAgd3YgPSBtaXgod3Ysc3d2LHd2KTtcbiAgICByZXR1cm4gcG93KDEuMC1wb3cod3YueCAqIHd2LnksMC42NSksY2hvcHB5KTtcbiAgfVxuXG4gIGZsb2F0IG1hcCh2ZWMzIHApIHtcbiAgICBmbG9hdCBmcmVxID0gU0VBX0ZSRVE7XG4gICAgZmxvYXQgYW1wID0gU0VBX0hFSUdIVDtcbiAgICBmbG9hdCBjaG9wcHkgPSBTRUFfQ0hPUFBZO1xuICAgIHZlYzIgdXYgPSBwLnh6OyB1di54ICo9IDAuNzU7XG4gICAgXG4gICAgZmxvYXQgZCwgaCA9IDAuMDsgICAgXG4gICAgZm9yKGludCBpID0gMDsgaSA8IElURVJfR0VPTUVUUlk7IGkrKykgeyAgICAgICAgXG4gICAgICBkID0gc2VhX29jdGF2ZSgodXYrU0VBX1RJTUUpKmZyZXEsY2hvcHB5KTtcbiAgICAgIGQgKz0gc2VhX29jdGF2ZSgodXYtU0VBX1RJTUUpKmZyZXEsY2hvcHB5KTtcbiAgICAgIGggKz0gZCAqIGFtcDsgICAgICAgIFxuICAgICAgdXYgKj0gb2N0YXZlX207IGZyZXEgKj0gMS45OyBhbXAgKj0gMC4yMjtcbiAgICAgIGNob3BweSA9IG1peChjaG9wcHksMS4wLDAuMik7XG4gICAgfVxuICAgIHJldHVybiBwLnkgLSBoO1xuICB9XG5cbiAgdm9pZCBtYWluSW1hZ2Uob3V0IHZlYzQgZnJhZ0NvbG9yLCBpbiB2ZWMyIGZyYWdDb29yZCkge1xuICAgIHZlYzIgdXYgPSBmcmFnQ29vcmQueHkgLyBpUmVzb2x1dGlvbi54eTtcbiAgICB1diA9IHV2ICogMi4wIC0gMS4wO1xuICAgIHV2LnggKj0gaVJlc29sdXRpb24ueC9pUmVzb2x1dGlvbi55OyAgICBcbiAgICBmbG9hdCB0aW1lID0gaVRpbWUgKiAwLjM7XG4gICAgICAgIFxuICAgIC8vIHJheVxuICAgIHZlYzMgYW5nID0gdmVjMyhzaW4odGltZSozLjApKjAuMSxzaW4odGltZSkqMC4yKzAuMyx0aW1lKTsgICAgXG4gICAgdmVjMyBvcmkgPSB2ZWMzKDAuMCwzLjUsdGltZSo1LjApO1xuICAgIHZlYzMgZGlyID0gbm9ybWFsaXplKHZlYzModXYueHksLTIuMCkpOyBkaXIueiArPSBsZW5ndGgodXYpICogMC4xNTtcbiAgICBkaXIgPSBub3JtYWxpemUoZGlyKTtcbiAgICBcbiAgICAvLyB0cmFjaW5nXG4gICAgdmVjMyBwO1xuICAgIGZsb2F0IHRtID0gMC4wO1xuICAgIGZsb2F0IHR4ID0gMC4wOyAgICBcbiAgICBpZiAoZGlyLnkgPiAwLjApIHtcbiAgICAgIHAgPSB2ZWMzKDAuMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmxvYXQgaG0gPSBtYXAob3JpICsgZGlyICogdG0pOyAgICBcbiAgICAgIHAgPSBvcmkgKyBkaXIgKiB0bTtcbiAgICB9XG4gICAgXG4gICAgLy8gY29sb3JcbiAgICB2ZWMzIGNvbCA9IG1peChcbiAgICAgIFNFQV9CQVNFLFxuICAgICAgU0VBX1dBVEVSX0NPTE9SLFxuICAgICAgY2xhbXAobGVuZ3RoKHAueHopLzEwMC4wLDAuMCwxLjApXG4gICAgKTsgICAgXG4gICAgXG4gICAgLy8gcG9zdFxuICAgIGZyYWdDb2xvciA9IHZlYzQocG93KGNvbCx2ZWMzKDAuNzUpKSwgMS4wKTtcbiAgfVxuXG4gIHZvaWQgbWFpbigpIHtcbiAgICBtYWluSW1hZ2UoZnJhZ0NvbG9yLCBnbF9GcmFnQ29vcmQueHkpO1xuICB9XG5gOyAiXSwibmFtZXMiOlsidmVydGV4U2hhZGVyIiwiZnJhZ21lbnRTaGFkZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/shaders/seascape.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/ShaderCanvas.tsx":
/*!*************************************!*\
  !*** ./components/ShaderCanvas.tsx ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ShaderCanvas)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.2_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.2_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _app_shaders_seascape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../app/shaders/seascape */ \"(app-pages-browser)/./app/shaders/seascape.ts\");\n/* harmony import */ var _app_shaders_dirty_notch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../app/shaders/dirty-notch */ \"(app-pages-browser)/./app/shaders/dirty-notch.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst shaders = {\n    'seascape': {\n        vertex: _app_shaders_seascape__WEBPACK_IMPORTED_MODULE_2__.vertexShader,\n        fragment: _app_shaders_seascape__WEBPACK_IMPORTED_MODULE_2__.fragmentShader\n    },\n    'dirty-notch': {\n        vertex: _app_shaders_dirty_notch__WEBPACK_IMPORTED_MODULE_3__.vertexShader,\n        fragment: _app_shaders_dirty_notch__WEBPACK_IMPORTED_MODULE_3__.fragmentShader\n    }\n};\nfunction ShaderCanvas(param) {\n    let { shaderId, width, height } = param;\n    _s();\n    var _s1 = $RefreshSig$();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const frameRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const startTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(Date.now());\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ShaderCanvas.useEffect\": _s1(()=>{\n            _s1();\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const gl = canvas.getContext('webgl2');\n            if (!gl) {\n                console.error('WebGL2 not supported');\n                return;\n            }\n            const shaderProgram = shaders[shaderId];\n            if (!shaderProgram) {\n                console.error('Shader not found:', shaderId);\n                return;\n            }\n            // Create shader program\n            const program = createShaderProgram(gl, shaderProgram.vertex, shaderProgram.fragment);\n            if (!program) return;\n            gl.useProgram(program);\n            // Set up buffers\n            const positions = new Float32Array([\n                -1.0,\n                -1.0,\n                1.0,\n                -1.0,\n                -1.0,\n                1.0,\n                1.0,\n                1.0\n            ]);\n            const positionBuffer = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n            // Set up attributes and uniforms\n            const positionLocation = gl.getAttribLocation(program, 'position');\n            gl.enableVertexAttribArray(positionLocation);\n            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n            const resolutionLocation = gl.getUniformLocation(program, 'iResolution');\n            const timeLocation = gl.getUniformLocation(program, 'iTime');\n            const mouseLocation = gl.getUniformLocation(program, 'iMouse');\n            // Create and set up noise texture\n            const noiseTexture = createNoiseTexture(gl);\n            const channel0Location = gl.getUniformLocation(program, 'iChannel0');\n            gl.uniform1i(channel0Location, 0);\n            // Animation frame\n            function render() {\n                const time = (Date.now() - startTimeRef.current) / 1000;\n                gl.viewport(0, 0, canvas.width, canvas.height);\n                gl.uniform2f(resolutionLocation, canvas.width, canvas.height);\n                gl.uniform1f(timeLocation, time);\n                gl.uniform4f(mouseLocation, 0, 0, 0, 0); // Update with actual mouse position if needed\n                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n                frameRef.current = requestAnimationFrame(render);\n            }\n            render();\n            // Cleanup\n            return ({\n                \"ShaderCanvas.useEffect\": ()=>{\n                    if (frameRef.current) {\n                        cancelAnimationFrame(frameRef.current);\n                    }\n                    gl.deleteProgram(program);\n                    gl.deleteBuffer(positionBuffer);\n                }\n            })[\"ShaderCanvas.useEffect\"];\n        }, \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", true)\n    }[\"ShaderCanvas.useEffect\"], [\n        shaderId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        width: width,\n        height: height,\n        style: {\n            width: '100%',\n            height: 'auto'\n        }\n    }, void 0, false, {\n        fileName: \"/Users/jeremyj/Documents/source/repos/shaders/components/ShaderCanvas.tsx\",\n        lineNumber: 103,\n        columnNumber: 5\n    }, this);\n}\n_s(ShaderCanvas, \"3i19xcW9wU7f8spHXNU4YXO3Ey8=\");\n_c = ShaderCanvas;\nfunction createShaderProgram(gl, vertexSource, fragmentSource) {\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    if (!vertexShader) return null;\n    gl.shaderSource(vertexShader, vertexSource);\n    gl.compileShader(vertexShader);\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    if (!fragmentShader) return null;\n    gl.shaderSource(fragmentShader, fragmentSource);\n    gl.compileShader(fragmentShader);\n    const program = gl.createProgram();\n    if (!program) return null;\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    return program;\n}\nfunction createNoiseTexture(gl) {\n    const texture = gl.createTexture();\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    // Create noise texture data\n    const size = 256;\n    const data = new Uint8Array(size * size * 4);\n    for(let i = 0; i < data.length; i += 4){\n        const value = Math.random() * 255;\n        data[i] = value;\n        data[i + 1] = value;\n        data[i + 2] = value;\n        data[i + 3] = 255;\n    }\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.generateMipmap(gl.TEXTURE_2D);\n    return texture;\n}\nvar _c;\n$RefreshReg$(_c, \"ShaderCanvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvU2hhZGVyQ2FudmFzLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUUwQztBQUNtRTtBQUNPO0FBUXBILE1BQU1RLFVBQVU7SUFDZCxZQUFZO1FBQ1ZDLFFBQVFOLCtEQUFjQTtRQUN0Qk8sVUFBVUwsaUVBQWdCQTtJQUM1QjtJQUNBLGVBQWU7UUFDYkksUUFBUUgsa0VBQWdCQTtRQUN4QkksVUFBVUgsb0VBQWtCQTtJQUM5QjtBQUNGO0FBRWUsU0FBU0ksYUFBYSxLQUE4QztRQUE5QyxFQUFFQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFxQixHQUE5Qzs7O0lBQ25DLE1BQU1DLFlBQVlkLDZDQUFNQSxDQUFvQjtJQUM1QyxNQUFNZSxXQUFXZiw2Q0FBTUE7SUFDdkIsTUFBTWdCLGVBQWVoQiw2Q0FBTUEsQ0FBU2lCLEtBQUtDLEdBQUc7SUFFNUNuQixnREFBU0E7c0NBQUM7O1lBQ1IsTUFBTW9CLFNBQVNMLFVBQVVNLE9BQU87WUFDaEMsSUFBSSxDQUFDRCxRQUFRO1lBRWIsTUFBTUUsS0FBS0YsT0FBT0csVUFBVSxDQUFDO1lBQzdCLElBQUksQ0FBQ0QsSUFBSTtnQkFDUEUsUUFBUUMsS0FBSyxDQUFDO2dCQUNkO1lBQ0Y7WUFFQSxNQUFNQyxnQkFBZ0JsQixPQUFPLENBQUNJLFNBQWlDO1lBQy9ELElBQUksQ0FBQ2MsZUFBZTtnQkFDbEJGLFFBQVFDLEtBQUssQ0FBQyxxQkFBcUJiO2dCQUNuQztZQUNGO1lBRUEsd0JBQXdCO1lBQ3hCLE1BQU1lLFVBQVVDLG9CQUFvQk4sSUFBSUksY0FBY2pCLE1BQU0sRUFBRWlCLGNBQWNoQixRQUFRO1lBQ3BGLElBQUksQ0FBQ2lCLFNBQVM7WUFFZEwsR0FBR08sVUFBVSxDQUFDRjtZQUVkLGlCQUFpQjtZQUNqQixNQUFNRyxZQUFZLElBQUlDLGFBQWE7Z0JBQ2pDLENBQUM7Z0JBQUssQ0FBQztnQkFDTjtnQkFBSyxDQUFDO2dCQUNQLENBQUM7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QU1xRCxVQUFVckQsR0FBR3NELGFBQWE7SUFDaEN0RCxHQUFHdUQsYUFBYSxDQUFDdkQsR0FBR3dELFFBQVE7SUFDNUJ4RCxHQUFHeUQsV0FBVyxDQUFDekQsR0FBRzBELFVBQVUsRUFBRUw7SUFFOUIsNEJBQTRCO0lBQzVCLE1BQU1NLE9BQU87SUFDYixNQUFNQyxPQUFPLElBQUlDLFdBQVdGLE9BQU9BLE9BQU87SUFDMUMsSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlGLEtBQUtHLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQ3ZDLE1BQU1FLFFBQVFDLEtBQUtDLE1BQU0sS0FBSztRQUM5Qk4sSUFBSSxDQUFDRSxFQUFFLEdBQUdFO1FBQ1ZKLElBQUksQ0FBQ0UsSUFBSSxFQUFFLEdBQUdFO1FBQ2RKLElBQUksQ0FBQ0UsSUFBSSxFQUFFLEdBQUdFO1FBQ2RKLElBQUksQ0FBQ0UsSUFBSSxFQUFFLEdBQUc7SUFDaEI7SUFFQTlELEdBQUdtRSxVQUFVLENBQ1huRSxHQUFHMEQsVUFBVSxFQUNiLEdBQ0ExRCxHQUFHb0UsSUFBSSxFQUNQVCxNQUNBQSxNQUNBLEdBQ0EzRCxHQUFHb0UsSUFBSSxFQUNQcEUsR0FBR3FFLGFBQWEsRUFDaEJUO0lBR0Y1RCxHQUFHc0UsYUFBYSxDQUFDdEUsR0FBRzBELFVBQVUsRUFBRTFELEdBQUd1RSxrQkFBa0IsRUFBRXZFLEdBQUd3RSxvQkFBb0I7SUFDOUV4RSxHQUFHc0UsYUFBYSxDQUFDdEUsR0FBRzBELFVBQVUsRUFBRTFELEdBQUd5RSxrQkFBa0IsRUFBRXpFLEdBQUcwRSxNQUFNO0lBQ2hFMUUsR0FBRzJFLGNBQWMsQ0FBQzNFLEdBQUcwRCxVQUFVO0lBRS9CLE9BQU9MO0FBQ1QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qZXJlbXlqL0RvY3VtZW50cy9zb3VyY2UvcmVwb3Mvc2hhZGVycy9jb21wb25lbnRzL1NoYWRlckNhbnZhcy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHZlcnRleFNoYWRlciBhcyBzZWFzY2FwZVZlcnRleCwgZnJhZ21lbnRTaGFkZXIgYXMgc2Vhc2NhcGVGcmFnbWVudCB9IGZyb20gJy4uL2FwcC9zaGFkZXJzL3NlYXNjYXBlJztcbmltcG9ydCB7IHZlcnRleFNoYWRlciBhcyBkaXJ0eU5vdGNoVmVydGV4LCBmcmFnbWVudFNoYWRlciBhcyBkaXJ0eU5vdGNoRnJhZ21lbnQgfSBmcm9tICcuLi9hcHAvc2hhZGVycy9kaXJ0eS1ub3RjaCc7XG5cbmludGVyZmFjZSBTaGFkZXJDYW52YXNQcm9wcyB7XG4gIHNoYWRlcklkOiBzdHJpbmc7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xufVxuXG5jb25zdCBzaGFkZXJzID0ge1xuICAnc2Vhc2NhcGUnOiB7XG4gICAgdmVydGV4OiBzZWFzY2FwZVZlcnRleCxcbiAgICBmcmFnbWVudDogc2Vhc2NhcGVGcmFnbWVudFxuICB9LFxuICAnZGlydHktbm90Y2gnOiB7XG4gICAgdmVydGV4OiBkaXJ0eU5vdGNoVmVydGV4LFxuICAgIGZyYWdtZW50OiBkaXJ0eU5vdGNoRnJhZ21lbnRcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2hhZGVyQ2FudmFzKHsgc2hhZGVySWQsIHdpZHRoLCBoZWlnaHQgfTogU2hhZGVyQ2FudmFzUHJvcHMpIHtcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmPEhUTUxDYW52YXNFbGVtZW50PihudWxsKTtcbiAgY29uc3QgZnJhbWVSZWYgPSB1c2VSZWY8bnVtYmVyPigpO1xuICBjb25zdCBzdGFydFRpbWVSZWYgPSB1c2VSZWY8bnVtYmVyPihEYXRlLm5vdygpKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmICghY2FudmFzKSByZXR1cm47XG5cbiAgICBjb25zdCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInKTtcbiAgICBpZiAoIWdsKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdXZWJHTDIgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNoYWRlclByb2dyYW0gPSBzaGFkZXJzW3NoYWRlcklkIGFzIGtleW9mIHR5cGVvZiBzaGFkZXJzXTtcbiAgICBpZiAoIXNoYWRlclByb2dyYW0pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1NoYWRlciBub3QgZm91bmQ6Jywgc2hhZGVySWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBzaGFkZXIgcHJvZ3JhbVxuICAgIGNvbnN0IHByb2dyYW0gPSBjcmVhdGVTaGFkZXJQcm9ncmFtKGdsLCBzaGFkZXJQcm9ncmFtLnZlcnRleCwgc2hhZGVyUHJvZ3JhbS5mcmFnbWVudCk7XG4gICAgaWYgKCFwcm9ncmFtKSByZXR1cm47XG5cbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgLy8gU2V0IHVwIGJ1ZmZlcnNcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgIC0xLjAsIC0xLjAsXG4gICAgICAgMS4wLCAtMS4wLFxuICAgICAgLTEuMCwgIDEuMCxcbiAgICAgICAxLjAsICAxLjAsXG4gICAgXSk7XG5cbiAgICBjb25zdCBwb3NpdGlvbkJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbkJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9ucywgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgLy8gU2V0IHVwIGF0dHJpYnV0ZXMgYW5kIHVuaWZvcm1zXG4gICAgY29uc3QgcG9zaXRpb25Mb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdwb3NpdGlvbicpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24pO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblxuICAgIGNvbnN0IHJlc29sdXRpb25Mb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnaVJlc29sdXRpb24nKTtcbiAgICBjb25zdCB0aW1lTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ2lUaW1lJyk7XG4gICAgY29uc3QgbW91c2VMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnaU1vdXNlJyk7XG5cbiAgICAvLyBDcmVhdGUgYW5kIHNldCB1cCBub2lzZSB0ZXh0dXJlXG4gICAgY29uc3Qgbm9pc2VUZXh0dXJlID0gY3JlYXRlTm9pc2VUZXh0dXJlKGdsKTtcbiAgICBjb25zdCBjaGFubmVsMExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdpQ2hhbm5lbDAnKTtcbiAgICBnbC51bmlmb3JtMWkoY2hhbm5lbDBMb2NhdGlvbiwgMCk7XG5cbiAgICAvLyBBbmltYXRpb24gZnJhbWVcbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICBjb25zdCB0aW1lID0gKERhdGUubm93KCkgLSBzdGFydFRpbWVSZWYuY3VycmVudCkgLyAxMDAwO1xuICAgICAgXG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIGdsLnVuaWZvcm0xZih0aW1lTG9jYXRpb24sIHRpbWUpO1xuICAgICAgZ2wudW5pZm9ybTRmKG1vdXNlTG9jYXRpb24sIDAsIDAsIDAsIDApOyAvLyBVcGRhdGUgd2l0aCBhY3R1YWwgbW91c2UgcG9zaXRpb24gaWYgbmVlZGVkXG5cbiAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgICAgZnJhbWVSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xuICAgIH1cblxuICAgIHJlbmRlcigpO1xuXG4gICAgLy8gQ2xlYW51cFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoZnJhbWVSZWYuY3VycmVudCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZVJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICBnbC5kZWxldGVCdWZmZXIocG9zaXRpb25CdWZmZXIpO1xuICAgIH07XG4gIH0sIFtzaGFkZXJJZF0pO1xuXG4gIHJldHVybiAoXG4gICAgPGNhbnZhc1xuICAgICAgcmVmPXtjYW52YXNSZWZ9XG4gICAgICB3aWR0aD17d2lkdGh9XG4gICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgIHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJ2F1dG8nIH19XG4gICAgLz5cbiAgKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2hhZGVyUHJvZ3JhbShnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCwgdmVydGV4U291cmNlOiBzdHJpbmcsIGZyYWdtZW50U291cmNlOiBzdHJpbmcpIHtcbiAgY29uc3QgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xuICBpZiAoIXZlcnRleFNoYWRlcikgcmV0dXJuIG51bGw7XG4gIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNvdXJjZSk7XG4gIGdsLmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyKTtcblxuICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICBpZiAoIWZyYWdtZW50U2hhZGVyKSByZXR1cm4gbnVsbDtcbiAgZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNvdXJjZSk7XG4gIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuXG4gIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gIGlmICghcHJvZ3JhbSkgcmV0dXJuIG51bGw7XG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICByZXR1cm4gcHJvZ3JhbTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9pc2VUZXh0dXJlKGdsOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KSB7XG4gIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuICAvLyBDcmVhdGUgbm9pc2UgdGV4dHVyZSBkYXRhXG4gIGNvbnN0IHNpemUgPSAyNTY7XG4gIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShzaXplICogc2l6ZSAqIDQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IE1hdGgucmFuZG9tKCkgKiAyNTU7XG4gICAgZGF0YVtpXSA9IHZhbHVlO1xuICAgIGRhdGFbaSArIDFdID0gdmFsdWU7XG4gICAgZGF0YVtpICsgMl0gPSB2YWx1ZTtcbiAgICBkYXRhW2kgKyAzXSA9IDI1NTtcbiAgfVxuXG4gIGdsLnRleEltYWdlMkQoXG4gICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAwLFxuICAgIGdsLlJHQkEsXG4gICAgc2l6ZSxcbiAgICBzaXplLFxuICAgIDAsXG4gICAgZ2wuUkdCQSxcbiAgICBnbC5VTlNJR05FRF9CWVRFLFxuICAgIGRhdGFcbiAgKTtcblxuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSX01JUE1BUF9MSU5FQVIpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG5cbiAgcmV0dXJuIHRleHR1cmU7XG59ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ2ZXJ0ZXhTaGFkZXIiLCJzZWFzY2FwZVZlcnRleCIsImZyYWdtZW50U2hhZGVyIiwic2Vhc2NhcGVGcmFnbWVudCIsImRpcnR5Tm90Y2hWZXJ0ZXgiLCJkaXJ0eU5vdGNoRnJhZ21lbnQiLCJzaGFkZXJzIiwidmVydGV4IiwiZnJhZ21lbnQiLCJTaGFkZXJDYW52YXMiLCJzaGFkZXJJZCIsIndpZHRoIiwiaGVpZ2h0IiwiY2FudmFzUmVmIiwiZnJhbWVSZWYiLCJzdGFydFRpbWVSZWYiLCJEYXRlIiwibm93IiwiY2FudmFzIiwiY3VycmVudCIsImdsIiwiZ2V0Q29udGV4dCIsImNvbnNvbGUiLCJlcnJvciIsInNoYWRlclByb2dyYW0iLCJwcm9ncmFtIiwiY3JlYXRlU2hhZGVyUHJvZ3JhbSIsInVzZVByb2dyYW0iLCJwb3NpdGlvbnMiLCJGbG9hdDMyQXJyYXkiLCJwb3NpdGlvbkJ1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsImJpbmRCdWZmZXIiLCJBUlJBWV9CVUZGRVIiLCJidWZmZXJEYXRhIiwiU1RBVElDX0RSQVciLCJwb3NpdGlvbkxvY2F0aW9uIiwiZ2V0QXR0cmliTG9jYXRpb24iLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsInZlcnRleEF0dHJpYlBvaW50ZXIiLCJGTE9BVCIsInJlc29sdXRpb25Mb2NhdGlvbiIsImdldFVuaWZvcm1Mb2NhdGlvbiIsInRpbWVMb2NhdGlvbiIsIm1vdXNlTG9jYXRpb24iLCJub2lzZVRleHR1cmUiLCJjcmVhdGVOb2lzZVRleHR1cmUiLCJjaGFubmVsMExvY2F0aW9uIiwidW5pZm9ybTFpIiwicmVuZGVyIiwidGltZSIsInZpZXdwb3J0IiwidW5pZm9ybTJmIiwidW5pZm9ybTFmIiwidW5pZm9ybTRmIiwiZHJhd0FycmF5cyIsIlRSSUFOR0xFX1NUUklQIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJkZWxldGVQcm9ncmFtIiwiZGVsZXRlQnVmZmVyIiwicmVmIiwic3R5bGUiLCJ2ZXJ0ZXhTb3VyY2UiLCJmcmFnbWVudFNvdXJjZSIsImNyZWF0ZVNoYWRlciIsIlZFUlRFWF9TSEFERVIiLCJzaGFkZXJTb3VyY2UiLCJjb21waWxlU2hhZGVyIiwiRlJBR01FTlRfU0hBREVSIiwiY3JlYXRlUHJvZ3JhbSIsImF0dGFjaFNoYWRlciIsImxpbmtQcm9ncmFtIiwidGV4dHVyZSIsImNyZWF0ZVRleHR1cmUiLCJhY3RpdmVUZXh0dXJlIiwiVEVYVFVSRTAiLCJiaW5kVGV4dHVyZSIsIlRFWFRVUkVfMkQiLCJzaXplIiwiZGF0YSIsIlVpbnQ4QXJyYXkiLCJpIiwibGVuZ3RoIiwidmFsdWUiLCJNYXRoIiwicmFuZG9tIiwidGV4SW1hZ2UyRCIsIlJHQkEiLCJVTlNJR05FRF9CWVRFIiwidGV4UGFyYW1ldGVyaSIsIlRFWFRVUkVfTUlOX0ZJTFRFUiIsIkxJTkVBUl9NSVBNQVBfTElORUFSIiwiVEVYVFVSRV9NQUdfRklMVEVSIiwiTElORUFSIiwiZ2VuZXJhdGVNaXBtYXAiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ShaderCanvas.tsx\n"));

/***/ })

});