"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/[id]/page",{

/***/ "(app-pages-browser)/./components/ShaderCanvas.tsx":
/*!*************************************!*\
  !*** ./components/ShaderCanvas.tsx ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ShaderCanvas)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.2_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.2_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _app_shaders_seascape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../app/shaders/seascape */ \"(app-pages-browser)/./app/shaders/seascape.ts\");\n/* harmony import */ var _app_shaders_dirty_notch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../app/shaders/dirty-notch */ \"(app-pages-browser)/./app/shaders/dirty-notch.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst shaders = {\n    'seascape': {\n        vertex: _app_shaders_seascape__WEBPACK_IMPORTED_MODULE_2__.vertexShader,\n        fragment: _app_shaders_seascape__WEBPACK_IMPORTED_MODULE_2__.fragmentShader\n    },\n    'dirty-notch': {\n        vertex: _app_shaders_dirty_notch__WEBPACK_IMPORTED_MODULE_3__.vertexShader,\n        fragment: _app_shaders_dirty_notch__WEBPACK_IMPORTED_MODULE_3__.fragmentShader\n    }\n};\nfunction ShaderCanvas(param) {\n    let { shaderId, width, height } = param;\n    _s();\n    var _s1 = $RefreshSig$();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const frameRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const startTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(Date.now());\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ShaderCanvas.useEffect\": _s1(()=>{\n            _s1();\n            console.log('ShaderCanvas mounted, shaderId:', shaderId);\n            const canvas = canvasRef.current;\n            if (!canvas) {\n                console.error('No canvas element found');\n                return;\n            }\n            const gl = canvas.getContext('webgl2');\n            if (!gl) {\n                console.error('WebGL2 not supported');\n                return;\n            }\n            const shaderProgram = shaders[shaderId];\n            if (!shaderProgram) {\n                console.error('Shader not found:', shaderId);\n                return;\n            }\n            // Create shader program\n            const program = createShaderProgram(gl, shaderProgram.vertex, shaderProgram.fragment);\n            if (!program) {\n                console.error('Failed to create shader program');\n                return;\n            }\n            console.log('Shader program created successfully');\n            gl.useProgram(program);\n            // Set up buffers\n            const positions = new Float32Array([\n                -1.0,\n                -1.0,\n                1.0,\n                -1.0,\n                -1.0,\n                1.0,\n                1.0,\n                1.0\n            ]);\n            const positionBuffer = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n            // Set up attributes and uniforms\n            const positionLocation = gl.getAttribLocation(program, 'position');\n            gl.enableVertexAttribArray(positionLocation);\n            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n            const resolutionLocation = gl.getUniformLocation(program, 'iResolution');\n            const timeLocation = gl.getUniformLocation(program, 'iTime');\n            const mouseLocation = gl.getUniformLocation(program, 'iMouse');\n            // Create and set up noise texture\n            const noiseTexture = createNoiseTexture(gl);\n            const channel0Location = gl.getUniformLocation(program, 'iChannel0');\n            gl.uniform1i(channel0Location, 0);\n            // Animation frame\n            function render() {\n                const time = (Date.now() - startTimeRef.current) / 1000;\n                gl.viewport(0, 0, canvas.width, canvas.height);\n                gl.uniform2f(resolutionLocation, canvas.width, canvas.height);\n                gl.uniform1f(timeLocation, time);\n                gl.uniform4f(mouseLocation, 0, 0, 0, 0); // Update with actual mouse position if needed\n                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n                frameRef.current = requestAnimationFrame(render);\n            }\n            render();\n            // Cleanup\n            return ({\n                \"ShaderCanvas.useEffect\": ()=>{\n                    if (frameRef.current) {\n                        cancelAnimationFrame(frameRef.current);\n                    }\n                    gl.deleteProgram(program);\n                    gl.deleteBuffer(positionBuffer);\n                }\n            })[\"ShaderCanvas.useEffect\"];\n        }, \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", true)\n    }[\"ShaderCanvas.useEffect\"], [\n        shaderId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        width: width,\n        height: height,\n        style: {\n            width: '100%',\n            height: 'auto',\n            background: '#000',\n            border: '1px solid #333'\n        }\n    }, void 0, false, {\n        fileName: \"/Users/jeremyj/Documents/source/repos/shaders/components/ShaderCanvas.tsx\",\n        lineNumber: 112,\n        columnNumber: 5\n    }, this);\n}\n_s(ShaderCanvas, \"3i19xcW9wU7f8spHXNU4YXO3Ey8=\");\n_c = ShaderCanvas;\nfunction createShaderProgram(gl, vertexSource, fragmentSource) {\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    if (!vertexShader) {\n        console.error('Failed to create vertex shader');\n        return null;\n    }\n    gl.shaderSource(vertexShader, vertexSource);\n    gl.compileShader(vertexShader);\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n        console.error('Vertex shader compilation failed:', gl.getShaderInfoLog(vertexShader));\n        return null;\n    }\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    if (!fragmentShader) {\n        console.error('Failed to create fragment shader');\n        return null;\n    }\n    gl.shaderSource(fragmentShader, fragmentSource);\n    gl.compileShader(fragmentShader);\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n        console.error('Fragment shader compilation failed:', gl.getShaderInfoLog(fragmentShader));\n        return null;\n    }\n    const program = gl.createProgram();\n    if (!program) {\n        console.error('Failed to create program');\n        return null;\n    }\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error('Program linking failed:', gl.getProgramInfoLog(program));\n        return null;\n    }\n    return program;\n}\nfunction createNoiseTexture(gl) {\n    const texture = gl.createTexture();\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    // Create noise texture data\n    const size = 256;\n    const data = new Uint8Array(size * size * 4);\n    for(let i = 0; i < data.length; i += 4){\n        const value = Math.random() * 255;\n        data[i] = value;\n        data[i + 1] = value;\n        data[i + 2] = value;\n        data[i + 3] = 255;\n    }\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.generateMipmap(gl.TEXTURE_2D);\n    return texture;\n}\nvar _c;\n$RefreshReg$(_c, \"ShaderCanvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvU2hhZGVyQ2FudmFzLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUUwQztBQUNtRTtBQUNPO0FBUXBILE1BQU1RLFVBQVU7SUFDZCxZQUFZO1FBQ1ZDLFFBQVFOLCtEQUFjQTtRQUN0Qk8sVUFBVUwsaUVBQWdCQTtJQUM1QjtJQUNBLGVBQWU7UUFDYkksUUFBUUgsa0VBQWdCQTtRQUN4QkksVUFBVUgsb0VBQWtCQTtJQUM5QjtBQUNGO0FBRWUsU0FBU0ksYUFBYSxLQUE4QztRQUE5QyxFQUFFQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFxQixHQUE5Qzs7O0lBQ25DLE1BQU1DLFlBQVlkLDZDQUFNQSxDQUFvQjtJQUM1QyxNQUFNZSxXQUFXZiw2Q0FBTUE7SUFDdkIsTUFBTWdCLGVBQWVoQiw2Q0FBTUEsQ0FBU2lCLEtBQUtDLEdBQUc7SUFFNUNuQixnREFBU0E7c0NBQUM7O1lBQ1JvQixRQUFRQyxHQUFHLENBQUMsbUNBQW1DVDtZQUMvQyxNQUFNVSxTQUFTUCxVQUFVUSxPQUFPO1lBQ2hDLElBQUksQ0FBQ0QsUUFBUTtnQkFDWEYsUUFBUUksS0FBSyxDQUFDO2dCQUNkO1lBQ0Y7WUFFQSxNQUFNQyxLQUFLSCxPQUFPSSxVQUFVLENBQUM7WUFDN0IsSUFBSSxDQUFDRCxJQUFJO2dCQUNQTCxRQUFRSSxLQUFLLENBQUM7Z0JBQ2Q7WUFDRjtZQUVBLE1BQU1HLGdCQUFnQm5CLE9BQU8sQ0FBQ0ksU0FBaUM7WUFDL0QsSUFBSSxDQUFDZSxlQUFlO2dCQUNsQlAsUUFBUUksS0FBSyxDQUFDLHFCQUFxQlo7Z0JBQ25DO1lBQ0Y7WUFFQSx3QkFBd0I7WUFDeEIsTUFBTWdCLFVBQVVDLG9CQUFvQkosSUFBSUUsY0FBY2xCLE1BQU0sRUFBRWtCLGNBQWNqQixRQUFRO1lBQ3BGLElBQUksQ0FBQ2tCLFNBQVM7Z0JBQ1pSLFFBQVFJLEtBQUssQ0FBQztnQkFDZDtZQUNGO1lBRUFKLFFBQVFDLEdB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O1FBQzlCTixJQUFJLENBQUNFLEVBQUUsR0FBR0U7UUFDVkosSUFBSSxDQUFDRSxJQUFJLEVBQUUsR0FBR0U7UUFDZEosSUFBSSxDQUFDRSxJQUFJLEVBQUUsR0FBR0U7UUFDZEosSUFBSSxDQUFDRSxJQUFJLEVBQUUsR0FBRztJQUNoQjtJQUVBcEUsR0FBR3lFLFVBQVUsQ0FDWHpFLEdBQUdnRSxVQUFVLEVBQ2IsR0FDQWhFLEdBQUcwRSxJQUFJLEVBQ1BULE1BQ0FBLE1BQ0EsR0FDQWpFLEdBQUcwRSxJQUFJLEVBQ1AxRSxHQUFHMkUsYUFBYSxFQUNoQlQ7SUFHRmxFLEdBQUc0RSxhQUFhLENBQUM1RSxHQUFHZ0UsVUFBVSxFQUFFaEUsR0FBRzZFLGtCQUFrQixFQUFFN0UsR0FBRzhFLG9CQUFvQjtJQUM5RTlFLEdBQUc0RSxhQUFhLENBQUM1RSxHQUFHZ0UsVUFBVSxFQUFFaEUsR0FBRytFLGtCQUFrQixFQUFFL0UsR0FBR2dGLE1BQU07SUFDaEVoRixHQUFHaUYsY0FBYyxDQUFDakYsR0FBR2dFLFVBQVU7SUFFL0IsT0FBT0w7QUFDVCIsInNvdXJjZXMiOlsiL1VzZXJzL2plcmVteWovRG9jdW1lbnRzL3NvdXJjZS9yZXBvcy9zaGFkZXJzL2NvbXBvbmVudHMvU2hhZGVyQ2FudmFzLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdmVydGV4U2hhZGVyIGFzIHNlYXNjYXBlVmVydGV4LCBmcmFnbWVudFNoYWRlciBhcyBzZWFzY2FwZUZyYWdtZW50IH0gZnJvbSAnLi4vYXBwL3NoYWRlcnMvc2Vhc2NhcGUnO1xuaW1wb3J0IHsgdmVydGV4U2hhZGVyIGFzIGRpcnR5Tm90Y2hWZXJ0ZXgsIGZyYWdtZW50U2hhZGVyIGFzIGRpcnR5Tm90Y2hGcmFnbWVudCB9IGZyb20gJy4uL2FwcC9zaGFkZXJzL2RpcnR5LW5vdGNoJztcblxuaW50ZXJmYWNlIFNoYWRlckNhbnZhc1Byb3BzIHtcbiAgc2hhZGVySWQ6IHN0cmluZztcbiAgd2lkdGg6IG51bWJlcjtcbiAgaGVpZ2h0OiBudW1iZXI7XG59XG5cbmNvbnN0IHNoYWRlcnMgPSB7XG4gICdzZWFzY2FwZSc6IHtcbiAgICB2ZXJ0ZXg6IHNlYXNjYXBlVmVydGV4LFxuICAgIGZyYWdtZW50OiBzZWFzY2FwZUZyYWdtZW50XG4gIH0sXG4gICdkaXJ0eS1ub3RjaCc6IHtcbiAgICB2ZXJ0ZXg6IGRpcnR5Tm90Y2hWZXJ0ZXgsXG4gICAgZnJhZ21lbnQ6IGRpcnR5Tm90Y2hGcmFnbWVudFxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTaGFkZXJDYW52YXMoeyBzaGFkZXJJZCwgd2lkdGgsIGhlaWdodCB9OiBTaGFkZXJDYW52YXNQcm9wcykge1xuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBmcmFtZVJlZiA9IHVzZVJlZjxudW1iZXI+KCk7XG4gIGNvbnN0IHN0YXJ0VGltZVJlZiA9IHVzZVJlZjxudW1iZXI+KERhdGUubm93KCkpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1NoYWRlckNhbnZhcyBtb3VudGVkLCBzaGFkZXJJZDonLCBzaGFkZXJJZCk7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIGNhbnZhcyBlbGVtZW50IGZvdW5kJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJyk7XG4gICAgaWYgKCFnbCkge1xuICAgICAgY29uc29sZS5lcnJvcignV2ViR0wyIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzaGFkZXJQcm9ncmFtID0gc2hhZGVyc1tzaGFkZXJJZCBhcyBrZXlvZiB0eXBlb2Ygc2hhZGVyc107XG4gICAgaWYgKCFzaGFkZXJQcm9ncmFtKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdTaGFkZXIgbm90IGZvdW5kOicsIHNoYWRlcklkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgc2hhZGVyIHByb2dyYW1cbiAgICBjb25zdCBwcm9ncmFtID0gY3JlYXRlU2hhZGVyUHJvZ3JhbShnbCwgc2hhZGVyUHJvZ3JhbS52ZXJ0ZXgsIHNoYWRlclByb2dyYW0uZnJhZ21lbnQpO1xuICAgIGlmICghcHJvZ3JhbSkge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBzaGFkZXIgcHJvZ3JhbScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdTaGFkZXIgcHJvZ3JhbSBjcmVhdGVkIHN1Y2Nlc3NmdWxseScpO1xuXG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgIC8vIFNldCB1cCBidWZmZXJzXG4gICAgY29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAtMS4wLCAtMS4wLFxuICAgICAgIDEuMCwgLTEuMCxcbiAgICAgIC0xLjAsICAxLjAsXG4gICAgICAgMS4wLCAgMS4wLFxuICAgIF0pO1xuXG4gICAgY29uc3QgcG9zaXRpb25CdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcG9zaXRpb25CdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbnMsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIC8vIFNldCB1cCBhdHRyaWJ1dGVzIGFuZCB1bmlmb3Jtc1xuICAgIGNvbnN0IHBvc2l0aW9uTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAncG9zaXRpb24nKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cbiAgICBjb25zdCByZXNvbHV0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ2lSZXNvbHV0aW9uJyk7XG4gICAgY29uc3QgdGltZUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdpVGltZScpO1xuICAgIGNvbnN0IG1vdXNlTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ2lNb3VzZScpO1xuXG4gICAgLy8gQ3JlYXRlIGFuZCBzZXQgdXAgbm9pc2UgdGV4dHVyZVxuICAgIGNvbnN0IG5vaXNlVGV4dHVyZSA9IGNyZWF0ZU5vaXNlVGV4dHVyZShnbCk7XG4gICAgY29uc3QgY2hhbm5lbDBMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnaUNoYW5uZWwwJyk7XG4gICAgZ2wudW5pZm9ybTFpKGNoYW5uZWwwTG9jYXRpb24sIDApO1xuXG4gICAgLy8gQW5pbWF0aW9uIGZyYW1lXG4gICAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgY29uc3QgdGltZSA9IChEYXRlLm5vdygpIC0gc3RhcnRUaW1lUmVmLmN1cnJlbnQpIC8gMTAwMDtcbiAgICAgIFxuICAgICAgZ2wudmlld3BvcnQoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBnbC51bmlmb3JtMWYodGltZUxvY2F0aW9uLCB0aW1lKTtcbiAgICAgIGdsLnVuaWZvcm00Zihtb3VzZUxvY2F0aW9uLCAwLCAwLCAwLCAwKTsgLy8gVXBkYXRlIHdpdGggYWN0dWFsIG1vdXNlIHBvc2l0aW9uIGlmIG5lZWRlZFxuXG4gICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgICAgIGZyYW1lUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKTtcblxuICAgIC8vIENsZWFudXBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGZyYW1lUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgZ2wuZGVsZXRlQnVmZmVyKHBvc2l0aW9uQnVmZmVyKTtcbiAgICB9O1xuICB9LCBbc2hhZGVySWRdKTtcblxuICByZXR1cm4gKFxuICAgIDxjYW52YXNcbiAgICAgIHJlZj17Y2FudmFzUmVmfVxuICAgICAgd2lkdGg9e3dpZHRofVxuICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICBzdHlsZT17eyBcbiAgICAgICAgd2lkdGg6ICcxMDAlJywgXG4gICAgICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAgICBiYWNrZ3JvdW5kOiAnIzAwMCcsXG4gICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjMzMzJ1xuICAgICAgfX1cbiAgICAvPlxuICApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTaGFkZXJQcm9ncmFtKGdsOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LCB2ZXJ0ZXhTb3VyY2U6IHN0cmluZywgZnJhZ21lbnRTb3VyY2U6IHN0cmluZykge1xuICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XG4gIGlmICghdmVydGV4U2hhZGVyKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSB2ZXJ0ZXggc2hhZGVyJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2wuc2hhZGVyU291cmNlKHZlcnRleFNoYWRlciwgdmVydGV4U291cmNlKTtcbiAgZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICBcbiAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIodmVydGV4U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICBjb25zb2xlLmVycm9yKCdWZXJ0ZXggc2hhZGVyIGNvbXBpbGF0aW9uIGZhaWxlZDonLCBnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRleFNoYWRlcikpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgaWYgKCFmcmFnbWVudFNoYWRlcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgZnJhZ21lbnQgc2hhZGVyJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNvdXJjZSk7XG4gIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuXG4gIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGZyYWdtZW50U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGcmFnbWVudCBzaGFkZXIgY29tcGlsYXRpb24gZmFpbGVkOicsIGdsLmdldFNoYWRlckluZm9Mb2coZnJhZ21lbnRTaGFkZXIpKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gIGlmICghcHJvZ3JhbSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgcHJvZ3JhbScpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgY29uc29sZS5lcnJvcignUHJvZ3JhbSBsaW5raW5nIGZhaWxlZDonLCBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcHJvZ3JhbTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9pc2VUZXh0dXJlKGdsOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KSB7XG4gIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuICAvLyBDcmVhdGUgbm9pc2UgdGV4dHVyZSBkYXRhXG4gIGNvbnN0IHNpemUgPSAyNTY7XG4gIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShzaXplICogc2l6ZSAqIDQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IE1hdGgucmFuZG9tKCkgKiAyNTU7XG4gICAgZGF0YVtpXSA9IHZhbHVlO1xuICAgIGRhdGFbaSArIDFdID0gdmFsdWU7XG4gICAgZGF0YVtpICsgMl0gPSB2YWx1ZTtcbiAgICBkYXRhW2kgKyAzXSA9IDI1NTtcbiAgfVxuXG4gIGdsLnRleEltYWdlMkQoXG4gICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAwLFxuICAgIGdsLlJHQkEsXG4gICAgc2l6ZSxcbiAgICBzaXplLFxuICAgIDAsXG4gICAgZ2wuUkdCQSxcbiAgICBnbC5VTlNJR05FRF9CWVRFLFxuICAgIGRhdGFcbiAgKTtcblxuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSX01JUE1BUF9MSU5FQVIpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG5cbiAgcmV0dXJuIHRleHR1cmU7XG59ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ2ZXJ0ZXhTaGFkZXIiLCJzZWFzY2FwZVZlcnRleCIsImZyYWdtZW50U2hhZGVyIiwic2Vhc2NhcGVGcmFnbWVudCIsImRpcnR5Tm90Y2hWZXJ0ZXgiLCJkaXJ0eU5vdGNoRnJhZ21lbnQiLCJzaGFkZXJzIiwidmVydGV4IiwiZnJhZ21lbnQiLCJTaGFkZXJDYW52YXMiLCJzaGFkZXJJZCIsIndpZHRoIiwiaGVpZ2h0IiwiY2FudmFzUmVmIiwiZnJhbWVSZWYiLCJzdGFydFRpbWVSZWYiLCJEYXRlIiwibm93IiwiY29uc29sZSIsImxvZyIsImNhbnZhcyIsImN1cnJlbnQiLCJlcnJvciIsImdsIiwiZ2V0Q29udGV4dCIsInNoYWRlclByb2dyYW0iLCJwcm9ncmFtIiwiY3JlYXRlU2hhZGVyUHJvZ3JhbSIsInVzZVByb2dyYW0iLCJwb3NpdGlvbnMiLCJGbG9hdDMyQXJyYXkiLCJwb3NpdGlvbkJ1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsImJpbmRCdWZmZXIiLCJBUlJBWV9CVUZGRVIiLCJidWZmZXJEYXRhIiwiU1RBVElDX0RSQVciLCJwb3NpdGlvbkxvY2F0aW9uIiwiZ2V0QXR0cmliTG9jYXRpb24iLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsInZlcnRleEF0dHJpYlBvaW50ZXIiLCJGTE9BVCIsInJlc29sdXRpb25Mb2NhdGlvbiIsImdldFVuaWZvcm1Mb2NhdGlvbiIsInRpbWVMb2NhdGlvbiIsIm1vdXNlTG9jYXRpb24iLCJub2lzZVRleHR1cmUiLCJjcmVhdGVOb2lzZVRleHR1cmUiLCJjaGFubmVsMExvY2F0aW9uIiwidW5pZm9ybTFpIiwicmVuZGVyIiwidGltZSIsInZpZXdwb3J0IiwidW5pZm9ybTJmIiwidW5pZm9ybTFmIiwidW5pZm9ybTRmIiwiZHJhd0FycmF5cyIsIlRSSUFOR0xFX1NUUklQIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJkZWxldGVQcm9ncmFtIiwiZGVsZXRlQnVmZmVyIiwicmVmIiwic3R5bGUiLCJiYWNrZ3JvdW5kIiwiYm9yZGVyIiwidmVydGV4U291cmNlIiwiZnJhZ21lbnRTb3VyY2UiLCJjcmVhdGVTaGFkZXIiLCJWRVJURVhfU0hBREVSIiwic2hhZGVyU291cmNlIiwiY29tcGlsZVNoYWRlciIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwiZ2V0U2hhZGVySW5mb0xvZyIsIkZSQUdNRU5UX1NIQURFUiIsImNyZWF0ZVByb2dyYW0iLCJhdHRhY2hTaGFkZXIiLCJsaW5rUHJvZ3JhbSIsImdldFByb2dyYW1QYXJhbWV0ZXIiLCJMSU5LX1NUQVRVUyIsImdldFByb2dyYW1JbmZvTG9nIiwidGV4dHVyZSIsImNyZWF0ZVRleHR1cmUiLCJhY3RpdmVUZXh0dXJlIiwiVEVYVFVSRTAiLCJiaW5kVGV4dHVyZSIsIlRFWFRVUkVfMkQiLCJzaXplIiwiZGF0YSIsIlVpbnQ4QXJyYXkiLCJpIiwibGVuZ3RoIiwidmFsdWUiLCJNYXRoIiwicmFuZG9tIiwidGV4SW1hZ2UyRCIsIlJHQkEiLCJVTlNJR05FRF9CWVRFIiwidGV4UGFyYW1ldGVyaSIsIlRFWFRVUkVfTUlOX0ZJTFRFUiIsIkxJTkVBUl9NSVBNQVBfTElORUFSIiwiVEVYVFVSRV9NQUdfRklMVEVSIiwiTElORUFSIiwiZ2VuZXJhdGVNaXBtYXAiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ShaderCanvas.tsx\n"));

/***/ })

});