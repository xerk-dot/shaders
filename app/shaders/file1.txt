const float PI = radians(180.);
struct Camera {
	float fov, aspect;
	vec3  origin, target, up;
	mat3 vMat, mMat;
	float factor;
	vec3  forward, right, position, coord;
	mat3 pMat, uMat;
};

struct Object {
	float   distance;
	float 	id;
	vec3 	position;
};

struct Ray {
	vec3  origin;
	vec3  direction;
	float near;
	float far;
	float epsilon;
	float steps;
	float swing;
	float distance;
	vec3  position;
	vec3  normal;
	bool  hit;
	Object object;
};
Ray lookAt (in vec2 uv, inout Camera cam) {
	cam.factor		= 1.0/tan(radians(cam.fov/2.));
	cam.forward 	= normalize(cam.target-cam.origin); 
	cam.right 		= normalize(cross(cam.up, cam.forward));
	cam.up 			= cross(cam.forward, cam.right);
	cam.position 	= cam.origin + cam.factor * cam.forward;
	cam.coord 		= cam.position + uv.x * cam.right*cam.aspect + uv.y * cam.up;
	cam.pMat 		= mat3(cam.right, cam.up, cam.forward);

	Ray ray;
	{
		ray.origin 		= cam.mMat * cam.origin;
		ray.direction 	= cam.mMat * normalize( cam.pMat * cam.vMat * vec3(uv.x*cam.aspect, uv.y, cam.factor));
		ray.near		= 0.01;
		ray.far			= 100.;
		ray.epsilon		= 0.001;
		ray.swing		= 1.0;
		ray.steps		= 200.;
	}
	return ray;
}
float EPS = 0.01;
#define TF_ROUND(d, R) (length(max(d, 0.)) - (R))
#define TF_BOX_ROUND(p, S, R) TF_ROUND(abs(p)-(S), R)
#define TF_BOX_ROUND1(p, S, R) TF_ROUND(abs(p)-(S) + R, R)
#define TF_BOX(p, S) TF_BOX_ROUND(p, S, 0.)
#define TF_BOX1(p, S) TF_BOX_ROUND(p, S, EPS)
#define TF_BOXE(p, S) TF_BOX_ROUND(p, S - EPS, EPS)
#define TF_BOX3D(p, S) max(abs((p).x)-vec3(S).x, max(abs((p).y)-vec3(S).y, abs((p).z)-vec3(S).z))
#define TF_BOX2D(p, S) max(abs((p).x)-vec2(S).x, abs((p).y)-vec2(S).y)
#define TF_BOX3D_SD(p, S) TF_BOX(p, S) + min(TF_BOX3D(p, S), 0.)
#define TF_BOX2D_SD(p, S) TF_BOX(p, S) + min(TF_BOX2D(p, S), 0.)

#define TF_ROUND_MIN(d, R) (-length(min(d, 0.)) + (R))
#define TF_CROSS_ROUND(p, S, R) TF_ROUND_MIN(abs(p)-(S), R)
#define TF_CROSS(p, S) TF_CROSS_ROUND(p, S, 0.)
#define TF_CROSS3D(p, S) min(abs((p).x)-vec3(S).x, min(abs((p).y)-vec3(S).y, abs((p).z)-vec3(S).z))
#define TF_CROSS2D(p, S) min(abs((p).x)-vec2(S).x, abs((p).y)-vec2(S).y)
#define TF_CROSS3D_SD(p, S) TF_CROSS(p, S) + max(TF_CROSS3D(p, S), 0.)
#define TF_CROSS2D_SD(p, S) TF_CROSS(p, S) + max(TF_CROSS2D(p, S), 0.)

#define TF_BALL(p, R) TF_ROUND(abs(p), R)
#define TF_ELLIPSE3D(p, r) min ((r).x, min((r).y, (r).z)) * TF_BALL((p)/(r), 1.)
#define TF_ELLIPSE2D(p, r) min ((r).x, (r).y) * TF_BALL((p)/(r), 1.)
#define TF_SEGMENT(p, a, b, r) TF_BALL((p)-(a) - ((b)-(a)) * clamp( dot((p)-(a),(b)-(a))/dot((b)-(a),(b)-(a)), 0.0, 1.0 ), r)

#define TF_BEFORE(p, p1) (p - (p1))
#define TF_BEFORE_EPS(p, p1) TF_ROUND(p - (p1) + EPS, EPS)
#define TF_BEFORE_PLANE(p, normal, off) dot(p, normal) - (off)
#define TF_BEFORE_ROTATE(p, ang, off) dot((p).xy, cos ((ang) + vec2 (0, 0.5 * PI))) - (off)

#define TF_AFTER(p, p1) (-p + (p1))
#define TF_AFTER_EPS(p, p1) TF_ROUND(-p + (p1) + EPS, EPS)
#define TF_AFTER_PLANE(p, normal, off) dot(-p, normal) + (off)
#define TF_AFTER_ROTATE(p, ang, off) dot((-p).xy, cos ((ang) + vec2 (0, 0.5 * PI))) + (off)

#define TF_BETWEEN(p, p1) (abs(p) - (p1))
#define TF_BETWEEN_EPS(p, p1) TF_ROUND(abs(p) - (p1) + EPS, EPS)
#define TF_BETWEEN2(p, p1, p2) (abs(p - 0.5*((p1)+(p2))) - 0.5*((p2)-(p1)))
#define TF_BETWEEN_PLANE(p, normal, off) AND(TF_AFTER_PLANE(p, normal, -off), TF_BEFORE_PLANE(p, normal, off))
#define TF_BETWEEN_ROTATE(p, ang, off) AND(TF_AFTER_ROTATE((p).xy, ang, -0.5*off), TF_BEFORE_ROTATE((p).xy, ang, 0.5*off))

#define TF_TRANSLATE(p, d) p -= d;
#define TF_SCALE(p, s) p /= s
#if 0
	#define TF_CYL(p, R, n) p = vec2((R)*atan(p.x,p.y), TF_BALL(p.xy, R))
#else
	#define TF_CYL(p, R, n) p = vec2((R)*atan(p.x,p.y), pow(length(pow(p.xy,vec2(n))), 1./float(n)) - (R))
#endif

#if 0
	#define TF_ROTATE(p, a) p = mat2(cos(a), sin(a), -sin(a), cos(a)) * p
#else
	#define TF_ROTATE(p, a) p = p.xy * cos (a) * vec2 (1., 1.) + p.yx * sin (a) * vec2 (-1., 1.)
#endif
#define TF_ROTATE_MAT2(a) mat2(cos(a), sin(a), -sin(a), cos(a))
#define TF_ROTATE_X(a) mat3(1.0,    0.0, 0.0,       0.0, cos(a), -sin(a),   0.0, sin(a), cos(a))
#define TF_ROTATE_Y(a) mat3(cos(a), 0.0, -sin(a),   0.0, 1.0, 0.0,   	    sin(a), 0.0, cos(a))
#define TF_ROTATE_Z(a) mat3(cos(a), -sin(a), 0.0,   sin(a), cos(a), 0.0,   	0.0, 0.0, 1.0)
#define TF_ROTATE_X_90(p) p.xyz = p.xzy
#define TF_ROTATE_Y_90(p) p.xyz = p.zyx
#define TF_ROTATE_Z_90(p) p.xyz = p.yxz
#define TF_MIRROR(p, d) p = abs(p) - (d)
#define TF_REPLICA(p, d) \
	floor((p)/(d) + 0.5);\
	p = mod((p) + 0.5*(d), d) - 0.5*(d)
#define TF_REPLICA_LIMIT(p, d, ida, idb) \
	floor((p)/(d) + 0.5);\
	p = p-(d)*clamp(floor((p)/(d) + 0.5), ida, idb)
#define TF_REPLICA_LIMIT_MIRROR(p, d, id) \
	floor((p=p-0.5*(d))/(d) + 0.5);\
	p = p-(d)*clamp(floor((p)/(d) + 0.5), -id, id-1.)

#define TF_REPLICA_ANGLE_POLAR(p, n, off)\
	floor(mod(atan(p.x, p.y) + off + PI /(n), 2.*PI)/(2.*PI/(n)));\
	p = vec2(atan(p.x, p.y) + off, length(p.xy));\
	p.x = mod(p.x + 0.5*(2.*PI/(n)), (2.*PI/(n))) - 0.5*(2.*PI/(n))
#if 1
	#define TF_REPLICA_ANGLE(p, n, off) \
		floor(mod(atan(p.x, p.y) + off + PI /(n), 2.*PI)/(2. * PI/(n)));\
		TF_ROTATE(p.xy, -off + (2.*PI/(n)) * floor(mod(atan(p.x, p.y) + off + PI /(n), 2.*PI)/(2.*PI/(n))))
#else
	#define TF_REPLICA_ANGLE(p, n, off) \
		TF_REPLICA_ANGLE_POLAR(p, n, off);\
		p = p.y * vec2(sin(p.x), cos(p.x))
#endif

#if 1
	#define TF_HELIX_Y(p, N, R, Step, Nrot)\
		TF_CYL(p.xz, R, 1.);\
		{\
			float a = floor(N)*p.x/(2.*PI*(R));\
			TF_TRANSLATE(p.y, (Step)*a);\
			TF_REPLICA(p.y, (Step));\
			TF_ROTATE(p.yz, (Nrot) * PI * a);\
		}\
		p = p.zxy
#else
	#define TF_HELIX_Y(p, N, R, Step, Nrot)\
		TF_CYL(p.xz, R, 1.);\
		{\
			float a = floor(N)*p.x/(2.*PI*(R));\
			TF_TRANSLATE(p.y, (Step)*a);\
			float id = TF_REPLICA(p.y, (Step));\
			p.x -= -id*(2.*PI*R)/floor(N);\
			TF_ROTATE(p.yz, (Nrot) * PI * a);\
		}\
		p = p.zxy
#endif

#define TF_TORUS_XZ(p, R, r) \
	TF_CYL(p.xz, R, 1.);\
	TF_CYL(p.yz, r, 1.);\
	p = p.xzy

#define TF_REPLICA_SPIN_Y(p, n, R, step, sect) \
	{\
		float a = atan(p.x, p.z)/(2.*PI);\
		p.y -= a * (n) * (step);\
		TF_REPLICA(p.y, step);\
		TF_REPLICA_ANGLE(p.xz, sect, 0.);\
		p.z -= R;\
	}\
	p = p.zxy;
		
#define TF_REPLICA_SPIN(p1, p2, n, step) \
	p1 -= (atan((p2).x,(p2).y)/(2. * PI))*(n)*(step);\
	TF_REPLICA(p1, (step))
#define TF_REPLICA_SPIN_LIMIT(p1, p2, n, step, ida, idb) \
	p1 -= (atan((p2).x,(p2).y)/(2. * PI))*(n)*(step);\
	TF_REPLICA_LIMIT(p1, (step), ida, idb)

#if 1
	#define TF_SPIRAL(p, n, k)\
		length(p.xy);\
		{\
			vec2 p0 = p.xy;\
			p.y = atan(p.x,p.y)*(n)/(2.*PI);\
			p.x = p.y - (k) * length(p0.xy);\
			p.x += -floor(p.x + 0.5);\
		}
#else
	#if 1
		#define TF_SPIRAL(p, n)\
			p.x = atan(p.x,p.y)*(n)/(2.*PI) - length(p.xy) - 0.5;\
			p.x -= 1. * floor(p.x/1. + 0.5)
	#else
		#define TF_SPIRAL(p, n)\
			p.xy = vec2(atan(p.x,p.y), length(p.xy));\
			p.x = p.x*(n)/(2.*PI) - p.y - 0.5;\
			p.x -= 1. * floor(p.x/1. + 0.5)
	#endif
#endif
#if 1
	#define TF_SPIRAL_LIMIT(p, n, k, ida, idb)\
		length(p.xy);\
		{\
			vec2 p0 = p.xy;\
			p.y = atan(p.x,p.y)*(n)/(2.*PI);\
			p.x = p.y - (k) * length(p0.xy);\
			p.x += clamp(-floor(p.x + 0.5), ida, idb);\
		}
#else
	#if 1
		#define TF_SPIRAL_LIMIT(p, n, ida, idb)\
			p.x = atan(p.x,p.y)*(n)/(2.*PI) - length(p.xy) - 0.5;\
			p.x -= 1. * clamp(floor(p.x/1. + 0.5), ida, idb);
	#else
		#define TF_SPIRAL_LIMIT(p, n, ida, idb)\
			p.xy = vec2(atan(p.x,p.y), length(p.xy));\
			p.x = p.x*(n)/(2.*PI) - p.y - 0.5;\
			p.x -= 1. * clamp(floor(p.x/1. + 0.5), ida, idb);
	#endif
#endif
#if 1
	#define TF_SPIRAL_LOG(p, n, k)\
		length(p.xy);\
		{\
			vec2 p0 = p.xy;\
			p.y = atan(p.x,p.y)*(n)/(2.*PI);\
			p.x = p.y - (k) * log(length(p0.xy));\
			p.x += -floor(p.x + 0.5);\
		}
#else
	#if 1
		#define TF_SPIRAL_LOG(p, n)\
			length(p.xy);\
			p.x = atan(p.x,p.y)*(n)/(2.*PI) - log(length(p.xy)) - 0.5;\
			p.x -= 1. * floor(p.x/1. + 0.5)
	#else
		#define TF_SPIRAL_LOG(p, n)\
			length(p.xy);\
			p.xy = vec2(atan(p.x,p.y), length(p.xy));\
			p.y = log(p.y);\
			p.x = p.x*(n)/(2.*PI) - p.y - 0.5;\
			p.x -= 1. * floor(p.x/1. + 0.5)
	#endif
#endif
#if 1
	#define TF_SPIRAL_LOG_LIMIT(p, n, k, ida, idb)\
		length(p.xy);\
		{\
			vec2 p0 = p.xy;\
			p.y = atan(p.x,p.y)*(n)/(2.*PI);\
			p.x = p.y - (k) * log(length(p0.xy));\
			p.x += clamp(-floor(p.x + 0.5), ida, idb);\
		}
#else
	#if 1
		#define TF_SPIRAL_LOG_LIMIT(p, n, ida, idb)\
			length(p.xy);\
			p.x = atan(p.x,p.y)*(n)/(2.*PI) - log(length(p.xy)) - 0.5;\
			p.x -= 1. * clamp(floor(p.x/1. + 0.5), ida, idb);
	#else
		#define TF_SPIRAL_LOG_LIMIT(p, n, ida, idb)\
			length(p.xy);\
			p.xy = vec2(atan(p.x,p.y), length(p.xy));\
			p.y = log(p.y);\
			p.x = p.x*(n)/(2.*PI) - p.y - 0.5;\
			p.x -= 1. * clamp(floor(p.x/1. + 0.5), ida, idb);
	#endif
#endif

#define TF_REPLICA_ANGLE_SPHERIC(p, nx, nz, id)\
	p = vec3( atan (p.x, p.z)*(nx)/(2. * PI), length (p), asin (p.y / length (p))*(nz)/PI );\
	if (mod(nz, 2.)==0.) p.z -= 0.5;\
	id = TF_REPLICA(p.xz, 1.)

#define TF_STEP_AFTER(p, a) step(a, p)
#define TF_STEP_BEFORE(p, a) step(p, a)
#define TF_STEP_BETWEEN(p, a) TF_STEP_BEFORE(abs(p), a)
#define TF_STEP_BETWEEN2(p, a, b) TF_STEP_AFTER(p, a)*TF_STEP_BEFORE(p, b)

#define TF_SMOOTHSTEP_AFTER_EPS(p, a, eps) smoothstep(a-0.5*eps, a+0.5*eps, p)
#define TF_SMOOTHSTEP_AFTER(p, a, b) smoothstep(a, b, p)
#define TF_SMOOTHSTEP_BEFORE_EPS(p, a, eps) (1.-smoothstep(a-0.5*eps, a+0.5*eps, p))
#define TF_SMOOTHSTEP_BEFORE(p, a, b) (1.-smoothstep(a, b, p))

#define TF_SMOOTHSTEP_BETWEEN_EPS(p, a, eps) TF_SMOOTHSTEP_BEFORE_EPS(abs(p), a, eps)
#define TF_SMOOTHSTEP_BETWEEN(p, a, b) TF_SMOOTHSTEP_BEFORE(abs(p), a, b)
#define TF_SMOOTHSTEP_BETWEEN2_EPS(p, a, b, eps) TF_SMOOTHSTEP_AFTER_EPS(p, a, eps)*TF_SMOOTHSTEP_BEFORE_EPS(p, b, eps)
#define TF_SMOOTHSTEP_BETWEEN2(p, a1, b1, a2, b2) TF_SMOOTHSTEP_AFTER(p, a1, b1)*TF_SMOOTHSTEP_BEFORE(p, a2, b2)

#define TF_TIMER(u_time, intervalCount, intervalDuration, intervalId) \
	mod(u_time, intervalDuration*intervalCount)/(intervalDuration*intervalCount);\
	intervalId = mod(floor(u_time/(intervalDuration)), (intervalCount))
#define TF_TIMER_VIEW(col, pix, uv0_value) \
	{\
		vec2 uv0 = gl_FragCoord.xy/u_canvas.xy;\
		if (uv0.y<pix/u_canvas.y && uv0.x<uv0_value) col = vec3(1,0,0);\
	}

float OR(float distA, float distB) {
	return min(distA, distB);
}
float AND(float distA, float distB) {
	return max(distA, distB);
}
float OR( float distA, float distB, float k ) {
	float h = clamp( 0.5 + 0.5*(distB-distA)/k, 0., 1. );
	return mix( distB, distA, h ) - k*h*(1.-h);
}
#if 0
	float AND( float distA, float distB, float k ) {
		float h = clamp( 0.5 - 0.5*(distB-distA)/k, 0., 1. );
		return mix( distB, distA, h ) + k*h*(1.-h);
	}
#else
	float AND( float distA, float distB, float k ) {
		return - OR (- distA, - distB, k);
	}
#endif
float NOT(float dist) {
	return -dist;
}

Object OR(Object objectA, Object objectB) {
	if (objectB.distance<objectA.distance) return objectB;
	return objectA;
}
Object OR(Object objectA, Object objectB, float k) {
	Object object = objectA;
	if (objectB.distance<objectA.distance) object = objectB;
	if (k!=0.) object.distance = OR(objectA.distance, objectB.distance, k);
	return object;
}
Object AND(Object objectA, Object objectB) {
	if (objectB.distance>objectA.distance) return objectB;
	return objectA;
}
Object AND(Object objectA, Object objectB, float k) {
	Object object = objectA;
	if (objectB.distance>objectA.distance) object = objectB;
	if (k!=0.) object.distance = AND(objectA.distance, objectB.distance, k);
	return object;
}
Object NOT(Object object) {
	object.distance = -object.distance;
	return object;
}
